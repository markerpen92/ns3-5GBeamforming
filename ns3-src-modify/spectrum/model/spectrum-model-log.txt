diff ../../NS3-WiGig/src/spectrum/model/aloha-noack-net-device.cc ../../ns-3-dev/src/spectrum/model/aloha-noack-net-device.cc
80c80
<                    MakePointerChecker<Queue<Packet> > ())
---
>                    MakePointerChecker<Queue> ())
176c176
< AlohaNoackNetDevice::SetQueue (Ptr<Queue<Packet> > q)
---
> AlohaNoackNetDevice::SetQueue (Ptr<Queue> q)
381c381
<           if (m_queue->Enqueue (packet) == false)
---
>           if (m_queue->Enqueue (Create<QueueItem> (packet)) == false)
392c392
<       if (m_queue->Enqueue (packet) == false)
---
>       if (m_queue->Enqueue (Create<QueueItem> (packet)) == false)
437,439c437,439
<       Ptr<Packet> p = m_queue->Dequeue ();
<       NS_ASSERT (p);
<       m_currentPkt = p;
---
>       Ptr<QueueItem> item = m_queue->Dequeue ();
>       NS_ASSERT (item);
>       m_currentPkt = item->GetPacket ();
diff ../../NS3-WiGig/src/spectrum/model/aloha-noack-net-device.h ../../ns-3-dev/src/spectrum/model/aloha-noack-net-device.h
42c42
< template <typename Item> class Queue;
---
> class Queue;
87c87
<   virtual void SetQueue (Ptr<Queue<Packet> > queue);
---
>   virtual void SetQueue (Ptr<Queue> queue);
199c199
<   Ptr<Queue<Packet> > m_queue; //!< packet queue
---
>   Ptr<Queue> m_queue; //!< packet queue
diff ../../NS3-WiGig/src/spectrum/model/half-duplex-ideal-phy.cc ../../ns-3-dev/src/spectrum/model/half-duplex-ideal-phy.cc
117c117
<                      "ns3::Packet::TracedCallback")
---
>                      "ns3::Packet::TraceCallback")
119c119
<                      "Trace fired when a previously started transmission is finished",
---
>                      "Trace fired when a previosuly started transmission is finished",
121c121
<                      "ns3::Packet::TracedCallback")
---
>                      "ns3::Packet::TraceCallback")
125c125
<                      "ns3::Packet::TracedCallback")
---
>                      "ns3::Packet::TraceCallback")
129c129
<                      "ns3::Packet::TracedCallback")
---
>                      "ns3::Packet::TraceCallback")
131c131
<                      "Trace fired when a previously started RX terminates successfully",
---
>                      "Trace fired when a previosuly started RX terminates successfully",
133c133
<                      "ns3::Packet::TracedCallback")
---
>                      "ns3::Packet::TraceCallback")
135c135
<                      "Trace fired when a previously started RX terminates with an error (packet is corrupted)",
---
>                      "Trace fired when a previosuly started RX terminates with an error (packet is corrupted)",
137c137
<                      "ns3::Packet::TracedCallback")
---
>                      "ns3::Packet::TraceCallback")
diff ../../NS3-WiGig/src/spectrum/model/multi-model-spectrum-channel.cc ../../ns-3-dev/src/spectrum/model/multi-model-spectrum-channel.cc
21,23d20
< #include <algorithm>
< #include <iostream>
< #include <utility>
39a37,38
> #include <iostream>
> #include <utility>
41a41
> 
47a48
> 
75a77
> 
80a83
> 
82d84
<   : m_numDevices {0}
90a93,95
>   m_propagationDelay = 0;
>   m_propagationLoss = 0;
>   m_spectrumPropagationLoss = 0;
103c108,136
< 
---
>     .AddAttribute ("MaxLossDb",
>                    "If a single-frequency PropagationLossModel is used, "
>                    "this value represents the maximum loss in dB for which "
>                    "transmissions will be passed to the receiving PHY.  "
>                    "Signals for which the PropagationLossModel returns "
>                    "a loss bigger than this value will not be propagated "
>                    "to the receiver.  This parameter is to be used to reduce "
>                    "the computational load by not propagating signals that "
>                    "are far beyond the interference range. Note that the "
>                    "default value corresponds to considering all signals "
>                    "for reception. Tune this value with care. ",
>                    DoubleValue (1.0e9),
>                    MakeDoubleAccessor (&MultiModelSpectrumChannel::m_maxLossDb),
>                    MakeDoubleChecker<double> ())
>     .AddTraceSource ("PathLoss",
>                      "This trace is fired whenever a new path loss value "
>                      "is calculated. The first and second parameters "
>                      "to the trace are pointers respectively to the "
>                      "TX and RX SpectrumPhy instances, whereas the "
>                      "third parameters is the loss value in dB.  "
>                      "Note that the loss value reported by this trace is "
>                      "the single-frequency loss value obtained by evaluating "
>                      "only the TX and RX AntennaModels and the "
>                      "PropagationLossModel. In particular, note that "
>                      "SpectrumPropagationLossModel (even if present) "
>                      "is never used to evaluate the loss value "
>                      "reported in this trace. ",
>                      MakeTraceSourceAccessor (&MultiModelSpectrumChannel::m_pathLossTrace),
>                      "ns3::SpectrumChannel::LossTracedCallback")
107a141,142
> 
> 
118a154,155
>   std::vector<Ptr<SpectrumPhy> >::const_iterator it;
> 
127,128c164,165
<       auto phyIt = std::find (rxInfoIterator->second.m_rxPhys.begin(), rxInfoIterator->second.m_rxPhys.end(), phy);
<       if (phyIt != rxInfoIterator->second.m_rxPhys.end ())
---
>       std::set<Ptr<SpectrumPhy> >::iterator phyIt = rxInfoIterator->second.m_rxPhySet.find (phy);
>       if (phyIt !=  rxInfoIterator->second.m_rxPhySet.end ())
130c167
<           rxInfoIterator->second.m_rxPhys.erase (phyIt);
---
>           rxInfoIterator->second.m_rxPhySet.erase (phyIt);
147c184,185
<       ret.first->second.m_rxPhys.push_back (phy);
---
>       std::pair<std::set<Ptr<SpectrumPhy> >::iterator, bool> ret2 = ret.first->second.m_rxPhySet.insert (phy);
>       NS_ASSERT (ret2.second);
155,164c193,197
<           SpectrumModelUid_t txSpectrumModelUid = txSpectrumModel->GetUid ();
< 
<           if (rxSpectrumModelUid != txSpectrumModelUid && !txSpectrumModel->IsOrthogonal (*rxSpectrumModel))
<             {
<               NS_LOG_LOGIC ("Creating converter between SpectrumModelUid " << txSpectrumModel->GetUid () << " and " << rxSpectrumModelUid);
<               SpectrumConverter converter (txSpectrumModel, rxSpectrumModel);
<               std::pair<SpectrumConverterMap_t::iterator, bool> ret2;
<               ret2 = txInfoIterator->second.m_spectrumConverterMap.insert (std::make_pair (rxSpectrumModelUid, converter));
<               NS_ASSERT (ret2.second);
<             }
---
>           NS_LOG_LOGIC ("Creating converters between SpectrumModelUids " << txSpectrumModel->GetUid () << " and " << rxSpectrumModelUid );
>           SpectrumConverter converter (txSpectrumModel, rxSpectrumModel);
>           std::pair<SpectrumConverterMap_t::iterator, bool> ret2;
>           ret2 = txInfoIterator->second.m_spectrumConverterMap.insert (std::make_pair (rxSpectrumModelUid, converter));
>           NS_ASSERT (ret2.second);
170c203,204
<       rxInfoIterator->second.m_rxPhys.push_back (phy);
---
>       std::pair<std::set<Ptr<SpectrumPhy> >::iterator, bool> ret2 = rxInfoIterator->second.m_rxPhySet.insert (phy);
>       NS_ASSERT (ret2.second);
171a206
> 
173a209
> 
198c234
<           if (rxSpectrumModelUid != txSpectrumModelUid && !txSpectrumModel->IsOrthogonal (*rxSpectrumModel))
---
>           if (rxSpectrumModelUid != txSpectrumModelUid)
200c236
<               NS_LOG_LOGIC ("Creating converter between SpectrumModelUid " << txSpectrumModelUid << " and " << rxSpectrumModelUid);
---
>               NS_LOG_LOGIC ("Creating converters between SpectrumModelUids " << txSpectrumModelUid << " and " << rxSpectrumModelUid );
215a252,253
>     
> 
223,224c261
<   Ptr<SpectrumSignalParameters> txParamsTrace = txParams->Copy (); // copy it since traced value cannot be const (because of potential underlying DynamicCasts)
<   m_txSigParamsTrace (txParamsTrace);
---
> 
228c265
<   NS_LOG_LOGIC ("txSpectrumModelUid " << txSpectrumModelUid);
---
>   NS_LOG_LOGIC (" txSpectrumModelUid " << txSpectrumModelUid);
243c280
<       NS_LOG_LOGIC ("rxSpectrumModelUids " << rxSpectrumModelUid);
---
>       NS_LOG_LOGIC (" rxSpectrumModelUids " << rxSpectrumModelUid);
253c290
<           NS_LOG_LOGIC ("converting txPowerSpectrum SpectrumModelUids " << txSpectrumModelUid << " --> " << rxSpectrumModelUid);
---
>           NS_LOG_LOGIC (" converting txPowerSpectrum SpectrumModelUids" << txSpectrumModelUid << " --> " << rxSpectrumModelUid);
255,259c292
<           if (rxConverterIterator == txInfoIteratorerator->second.m_spectrumConverterMap.end ())
<             {
<               // No converter means TX SpectrumModel is orthogonal to RX SpectrumModel
<               continue;
<             }
---
>           NS_ASSERT (rxConverterIterator != txInfoIteratorerator->second.m_spectrumConverterMap.end ());
263,264c296,298
<       for (auto rxPhyIterator = rxInfoIterator->second.m_rxPhys.begin ();
<            rxPhyIterator != rxInfoIterator->second.m_rxPhys.end ();
---
> 
>       for (std::set<Ptr<SpectrumPhy> >::const_iterator rxPhyIterator = rxInfoIterator->second.m_rxPhySet.begin ();
>            rxPhyIterator != rxInfoIterator->second.m_rxPhySet.end ();
272c306
<               NS_LOG_LOGIC ("copying signal parameters " << txParams);
---
>               NS_LOG_LOGIC (" copying signal parameters " << txParams);
281,283d314
<                   double txAntennaGain = 0;
<                   double rxAntennaGain = 0;
<                   double propagationGainDb = 0;
288c319
<                       txAntennaGain = rxParams->txAntenna->GetGainDb (txAngles);
---
>                       double txAntennaGain = rxParams->txAntenna->GetGainDb (txAngles);
296c327
<                       rxAntennaGain = rxAntenna->GetGainDb (rxAngles);
---
>                       double rxAntennaGain = rxAntenna->GetGainDb (rxAngles);
302c333
<                       propagationGainDb = m_propagationLoss->CalcRxPower (0, txMobility, receiverMobility);
---
>                       double propagationGainDb = m_propagationLoss->CalcRxPower (0, txMobility, receiverMobility);
306,309c337
<                   NS_LOG_LOGIC ("total pathLoss = " << pathLossDb << " dB");
<                   // Gain trace
<                   m_gainTrace (txMobility, receiverMobility, txAntennaGain, rxAntennaGain, propagationGainDb, pathLossDb);
<                   // Pathloss trace
---
>                   NS_LOG_LOGIC ("total pathLoss = " << pathLossDb << " dB");    
311c339
<                   if (pathLossDb > m_maxLossDb)
---
>                   if ( pathLossDb > m_maxLossDb)
319c347
<                   if (m_spectrumPropagationLoss && !m_spectrumPropagationLoss->DoCalculateRxPowerAtReceiverSide ())
---
>                   if (m_spectrumPropagationLoss)
355,365d382
<   if (m_spectrumPropagationLoss && m_spectrumPropagationLoss->DoCalculateRxPowerAtReceiverSide ())
<     {
<       if (!params->isMimo)
<         {
<           params->psd = m_spectrumPropagationLoss->CalcRxPower (params, params->txPhy->GetMobility (), receiver->GetMobility ());
<         }
<       else
<         {
<           m_spectrumPropagationLoss->CalcMimoRxPower (params, params->txPhy->GetMobility (), receiver->GetMobility ());
<         }
<     }
369c386,388
< std::size_t
---
> 
> 
> uint32_t
372a392
> 
374a395
> 
376c397
< MultiModelSpectrumChannel::GetDevice (std::size_t i) const
---
> MultiModelSpectrumChannel::GetDevice (uint32_t i) const
382c403
<   // SpectrumModel conversions and to allow PHY devices to change a
---
>   // SpectrumModel conversions and to allow PHY devices to changea
387c408
<   std::size_t j = 0;
---
>   uint32_t j = 0;
392c413,415
<       for (const auto &phyIt : rxInfoIterator->second.m_rxPhys)
---
>       for (std::set<Ptr<SpectrumPhy> >::const_iterator phyIt = rxInfoIterator->second.m_rxPhySet.begin ();
>            phyIt != rxInfoIterator->second.m_rxPhySet.end ();
>            ++phyIt)        
396c419
<               return (*phyIt).GetDevice ();
---
>               return (*phyIt)->GetDevice ();
401c424
<   NS_FATAL_ERROR ("m_numDevices > actual number of devices");
---
>   NS_FATAL_ERROR ("m_numDevice > actual number of devices");
403a427,458
> 
> 
> 
> void
> MultiModelSpectrumChannel::AddPropagationLossModel (Ptr<PropagationLossModel> loss)
> {
>   NS_LOG_FUNCTION (this << loss);
>   NS_ASSERT (m_propagationLoss == 0);
>   m_propagationLoss = loss;
> }
> 
> void
> MultiModelSpectrumChannel::AddSpectrumPropagationLossModel (Ptr<SpectrumPropagationLossModel> loss)
> {
>   NS_ASSERT (m_spectrumPropagationLoss == 0);
>   m_spectrumPropagationLoss = loss;
> }
> 
> void
> MultiModelSpectrumChannel::SetPropagationDelayModel (Ptr<PropagationDelayModel> delay)
> {
>   NS_ASSERT (m_propagationDelay == 0);
>   m_propagationDelay = delay;
> }
> 
> Ptr<SpectrumPropagationLossModel>
> MultiModelSpectrumChannel::GetSpectrumPropagationLossModel (void)
> {
>   NS_LOG_FUNCTION (this);
>   return m_spectrumPropagationLoss;
> }
> 
diff ../../NS3-WiGig/src/spectrum/model/multi-model-spectrum-channel.h ../../ns-3-dev/src/spectrum/model/multi-model-spectrum-channel.h
83c83
<   std::vector<Ptr<SpectrumPhy> > m_rxPhys;     //!< Container of the Rx Spectrum phy objects.
---
>   std::set<Ptr<SpectrumPhy> > m_rxPhySet;      //!< Container of the Rx Spectrum phy objects.
118a119,121
>   virtual void AddPropagationLossModel (Ptr<PropagationLossModel> loss);
>   virtual void AddSpectrumPropagationLossModel (Ptr<SpectrumPropagationLossModel> loss);
>   virtual void SetPropagationDelayModel (Ptr<PropagationDelayModel> delay);
124,125c127,134
<   virtual std::size_t GetNDevices (void) const;
<   virtual Ptr<NetDevice> GetDevice (std::size_t i) const;
---
>   virtual uint32_t GetNDevices (void) const;
>   virtual Ptr<NetDevice> GetDevice (uint32_t i) const;
> 
>   /**
>    * Get the frequency-dependent propagation loss model.
>    * \returns a pointer to the propagation loss model.
>    */
>   virtual Ptr<SpectrumPropagationLossModel> GetSpectrumPropagationLossModel (void);
135c144
<    * an iterator pointing to it. If not, it creates a new entry in
---
>    * an interator pointing to it. If not, it creates a new entry in
138c147
<    * \param txSpectrumModel The TX SpectrumModel  being considered
---
>    * @param txSpectrumModel The TX SpectrumModel  being considered
140c149
<    * \return An iterator pointing to the corresponding entry in m_txSpectrumModelInfoMap
---
>    * @return An iterator pointing to the corresponding entry in m_txSpectrumModelInfoMap
147,148c156,157
<    * \param params The signal parameters.
<    * \param receiver A pointer to the receiver SpectrumPhy.
---
>    * @param params The signal paramters.
>    * @param receiver A pointer to the receiver SpectrumPhy.
152a162,177
>    * Propagation delay model to be used with this channel.
>    */
>   Ptr<PropagationDelayModel> m_propagationDelay;
> 
>   /**
>    * Single-frequency propagation loss model to be used with this channel.
>    */
>   Ptr<PropagationLossModel> m_propagationLoss;
> 
>   /**
>    * Frequency-dependent propagation loss model to be used with this channel.
>    */
>   Ptr<SpectrumPropagationLossModel> m_spectrumPropagationLoss;
> 
> 
>   /**
170c195
<   std::size_t m_numDevices;
---
>   uint32_t m_numDevices;
171a197,209
>   /**
>    * Maximum loss [dB].
>    *
>    * Any device above this loss is considered out of range.
>    */
>   double m_maxLossDb;
> 
>   /**
>    * \deprecated The non-const \c Ptr<SpectrumPhy> argument
>    * is deprecated and will be changed to \c Ptr<const SpectrumPhy>
>    * in a future release.
>    */
>   TracedCallback<Ptr<SpectrumPhy>, Ptr<SpectrumPhy>, double > m_pathLossTrace;
diff ../../NS3-WiGig/src/spectrum/model/non-communicating-net-device.cc ../../ns-3-dev/src/spectrum/model/non-communicating-net-device.cc
21a22
> #include "ns3/queue.h"
diff ../../NS3-WiGig/src/spectrum/model/non-communicating-net-device.h ../../ns-3-dev/src/spectrum/model/non-communicating-net-device.h
38a39
> class Queue;
diff ../../NS3-WiGig/src/spectrum/model/single-model-spectrum-channel.cc ../../ns-3-dev/src/spectrum/model/single-model-spectrum-channel.cc
57a58,60
>   m_propagationDelay = 0;
>   m_propagationLoss = 0;
>   m_spectrumPropagationLoss = 0;
68a72,99
>     .AddAttribute ("MaxLossDb",
>                    "If a single-frequency PropagationLossModel is used, "
>                    "this value represents the maximum loss in dB for which "
>                    "transmissions will be passed to the receiving PHY. "
>                    "Signals for which the PropagationLossModel returns "
>                    "a loss bigger than this value will not be propagated "
>                    "to the receiver. This parameter is to be used to reduce "
>                    "the computational load by not propagating signals "
>                    "that are far beyond the interference range. Note that "
>                    "the default value corresponds to considering all signals "
>                    "for reception. Tune this value with care. ",
>                    DoubleValue (1.0e9),
>                    MakeDoubleAccessor (&SingleModelSpectrumChannel::m_maxLossDb),
>                    MakeDoubleChecker<double> ())
>     .AddTraceSource ("PathLoss",
>                      "This trace is fired whenever a new path loss value "
>                      "is calculated. The first and second parameters "
>                      "to the trace are pointers respectively to the TX and "
>                      "RX SpectrumPhy instances, whereas the third parameters "
>                      "is the loss value in dB. Note that the loss value "
>                      "reported by this trace is the single-frequency loss "
>                      "value obtained by evaluating only the TX and RX "
>                      "AntennaModels and the PropagationLossModel. "
>                      "In particular, note that SpectrumPropagationLossModel "
>                      "(even if present) is never used to evaluate the "
>                      "loss value reported in this trace. ",
>                      MakeTraceSourceAccessor (&SingleModelSpectrumChannel::m_pathLossTrace),
>                      "ns3::SpectrumChannel::LossTracedCallback")
89,91d119
<   Ptr<SpectrumSignalParameters> txParamsTrace = txParams->Copy (); // copy it since traced value cannot be const (because of potential underlying DynamicCasts)
<   m_txSigParamsTrace (txParamsTrace);
< 
123,125d150
<               double txAntennaGain = 0;
<               double rxAntennaGain = 0;
<               double propagationGainDb = 0;
130c155
<                   txAntennaGain = rxParams->txAntenna->GetGainDb (txAngles);
---
>                   double txAntennaGain = rxParams->txAntenna->GetGainDb (txAngles);
138c163
<                   rxAntennaGain = rxAntenna->GetGainDb (rxAngles);
---
>                   double rxAntennaGain = rxAntenna->GetGainDb (rxAngles);
144c169
<                   propagationGainDb = m_propagationLoss->CalcRxPower (0, senderMobility, receiverMobility);
---
>                   double propagationGainDb = m_propagationLoss->CalcRxPower (0, senderMobility, receiverMobility);
148,151c173
<               NS_LOG_LOGIC ("total pathLoss = " << pathLossDb << " dB");
<               // Gain trace
<               m_gainTrace (senderMobility, receiverMobility, txAntennaGain, rxAntennaGain, propagationGainDb, pathLossDb);
<               // Pathloss trace
---
>               NS_LOG_LOGIC ("total pathLoss = " << pathLossDb << " dB");    
187a210
> 
197c220,222
< std::size_t
---
> 
> 
> uint32_t
203a229
> 
205c231
< SingleModelSpectrumChannel::GetDevice (std::size_t i) const
---
> SingleModelSpectrumChannel::GetDevice (uint32_t i) const
208a235,268
> }
> 
> 
> void
> SingleModelSpectrumChannel::AddPropagationLossModel (Ptr<PropagationLossModel> loss)
> {
>   NS_LOG_FUNCTION (this << loss);
>   NS_ASSERT (m_propagationLoss == 0);
>   m_propagationLoss = loss;
> }
> 
> 
> void
> SingleModelSpectrumChannel::AddSpectrumPropagationLossModel (Ptr<SpectrumPropagationLossModel> loss)
> {
>   NS_LOG_FUNCTION (this << loss);
>   NS_ASSERT (m_spectrumPropagationLoss == 0);
>   m_spectrumPropagationLoss = loss;
> }
> 
> void
> SingleModelSpectrumChannel::SetPropagationDelayModel (Ptr<PropagationDelayModel> delay)
> {
>   NS_LOG_FUNCTION (this << delay);
>   NS_ASSERT (m_propagationDelay == 0);
>   m_propagationDelay = delay;
> }
> 
> 
> Ptr<SpectrumPropagationLossModel>
> SingleModelSpectrumChannel::GetSpectrumPropagationLossModel (void)
> {
>   NS_LOG_FUNCTION (this);
>   return m_spectrumPropagationLoss;
diff ../../NS3-WiGig/src/spectrum/model/single-model-spectrum-channel.h ../../ns-3-dev/src/spectrum/model/single-model-spectrum-channel.h
36c36
<  * \brief SpectrumChannel implementation which handles a single spectrum model
---
>  * @brief SpectrumChannel implementation which handles a single spectrum model
52a53,55
>   virtual void AddPropagationLossModel (Ptr<PropagationLossModel> loss);
>   virtual void AddSpectrumPropagationLossModel (Ptr<SpectrumPropagationLossModel> loss);
>   virtual void SetPropagationDelayModel (Ptr<PropagationDelayModel> delay);
58,59c61,62
<   virtual std::size_t GetNDevices (void) const;
<   virtual Ptr<NetDevice> GetDevice (std::size_t i) const;
---
>   virtual uint32_t GetNDevices (void) const;
>   virtual Ptr<NetDevice> GetDevice (uint32_t i) const;
63a67,72
>   /**
>    * Get the frequency-dependent propagation loss model.
>    * \returns a pointer to the propagation loss model.
>    */
>   virtual Ptr<SpectrumPropagationLossModel> GetSpectrumPropagationLossModel (void);
> 
70,71c79,80
<    * \param params
<    * \param receiver
---
>    * @param params
>    * @param receiver
84a94,124
> 
>   /**
>    * Propagation delay model to be used with this channel.
>    */
>   Ptr<PropagationDelayModel> m_propagationDelay;
> 
> 
>   /**
>    * Single-frequency propagation loss model to be used with this channel.
>    */
>   Ptr<PropagationLossModel> m_propagationLoss;
> 
>   /**
>    * Frequency-dependent propagation loss model to be used with this channel.
>    */
>   Ptr<SpectrumPropagationLossModel> m_spectrumPropagationLoss;
> 
> 
>   /**
>    * Maximum loss [dB].
>    *
>    * Any device above this loss is considered out of range.
>    */
>   double m_maxLossDb;
> 
>   /**
>    * \deprecated The non-const \c Ptr<SpectrumPhy> argument
>    * is deprecated and will be changed to \c Ptr<const SpectrumPhy>
>    * in a future release.
>    */
>   TracedCallback<Ptr<SpectrumPhy>, Ptr<SpectrumPhy>, double > m_pathLossTrace;
86a127,128
> 
> 
87a130,131
> 
> 
diff ../../NS3-WiGig/src/spectrum/model/spectrum-channel.cc ../../ns-3-dev/src/spectrum/model/spectrum-channel.cc
21,24d20
< #include <ns3/log.h>
< #include <ns3/double.h>
< #include <ns3/pointer.h>
< 
30d25
< NS_LOG_COMPONENT_DEFINE ("SpectrumChannel");
34,51d28
< SpectrumChannel::SpectrumChannel ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< SpectrumChannel::~SpectrumChannel ()
< {
< }
< 
< void
< SpectrumChannel::DoDispose ()
< {
<   NS_LOG_FUNCTION (this);
<   m_propagationLoss = 0;
<   m_propagationDelay = 0;
<   m_spectrumPropagationLoss = 0;
< }
< 
58,111d34
<     .AddAttribute ("MaxLossDb",
<                    "If a single-frequency PropagationLossModel is used, "
<                    "this value represents the maximum loss in dB for which "
<                    "transmissions will be passed to the receiving PHY. "
<                    "Signals for which the PropagationLossModel returns "
<                    "a loss bigger than this value will not be propagated "
<                    "to the receiver. This parameter is to be used to reduce "
<                    "the computational load by not propagating signals "
<                    "that are far beyond the interference range. Note that "
<                    "the default value corresponds to considering all signals "
<                    "for reception. Tune this value with care. ",
<                    DoubleValue (1.0e9),
<                    MakeDoubleAccessor (&SpectrumChannel::m_maxLossDb),
<                    MakeDoubleChecker<double> ())
< 
<     .AddAttribute ("PropagationLossModel",
<                    "A pointer to the propagation loss model attached to this channel.",
<                    PointerValue (0),
<                    MakePointerAccessor (&SpectrumChannel::m_propagationLoss),
<                    MakePointerChecker<PropagationLossModel> ())
< 
<     .AddTraceSource ("Gain",
<                      "This trace is fired whenever a new path loss value "
<                      "is calculated. The parameters to this trace are : "
<                      "Pointer to the mobility model of the transmitter"
<                      "Pointer to the mobility model of the receiver"
<                      "Tx antenna gain"
<                      "Rx antenna gain"
<                      "Propagation gain"
<                      "Pathloss",
<                      MakeTraceSourceAccessor (&SpectrumChannel::m_gainTrace),
<                      "ns3::SpectrumChannel::GainTracedCallback")
< 
<     .AddTraceSource ("PathLoss",
<                      "This trace is fired whenever a new path loss value "
<                      "is calculated. The first and second parameters "
<                      "to the trace are pointers respectively to the TX and "
<                      "RX SpectrumPhy instances, whereas the third parameters "
<                      "is the loss value in dB. Note that the loss value "
<                      "reported by this trace is the single-frequency loss "
<                      "value obtained by evaluating only the TX and RX "
<                      "AntennaModels and the PropagationLossModel. "
<                      "In particular, note that SpectrumPropagationLossModel "
<                      "(even if present) is never used to evaluate the "
<                      "loss value reported in this trace. ",
<                      MakeTraceSourceAccessor (&SpectrumChannel::m_pathLossTrace),
<                      "ns3::SpectrumChannel::LossTracedCallback")
< 
<     .AddTraceSource ("TxSigParams",
<                      "This trace is fired whenever a signal is transmitted."
<                      "The sole parameter is a pointer to a copy of the "
<                      "SpectrumSignalParameters provided by the transmitter.",
<                      MakeTraceSourceAccessor (&SpectrumChannel::m_txSigParamsTrace),
<                      "ns3::SpectrumChannel::SignalParametersTracedCallback")
116,153c39
< void
< SpectrumChannel::AddPropagationLossModel (Ptr<PropagationLossModel> loss)
< {
<   NS_LOG_FUNCTION (this << loss);
<   if (m_propagationLoss)
<     {
<       loss->SetNext (m_propagationLoss);
<     }
<   m_propagationLoss = loss;
< }
< 
< void
< SpectrumChannel::AddSpectrumPropagationLossModel (Ptr<SpectrumPropagationLossModel> loss)
< {
<   NS_LOG_FUNCTION (this << loss);
<   if (m_spectrumPropagationLoss)
<     {
<       loss->SetNext (m_spectrumPropagationLoss);
<     }
<   m_spectrumPropagationLoss = loss;
< }
< 
< void
< SpectrumChannel::SetPropagationDelayModel (Ptr<PropagationDelayModel> delay)
< {
<   NS_ASSERT (m_propagationDelay == 0);
<   m_propagationDelay = delay;
< }
< 
< Ptr<SpectrumPropagationLossModel>
< SpectrumChannel::GetSpectrumPropagationLossModel (void)
< {
<   NS_LOG_FUNCTION (this);
<   return m_spectrumPropagationLoss;
< }
< 
< Ptr<PropagationLossModel>
< SpectrumChannel::GetPropagationLossModel ()
---
> SpectrumChannel::~SpectrumChannel ()
155d40
<   return m_propagationLoss;
157d41
< 
diff ../../NS3-WiGig/src/spectrum/model/spectrum-channel.h ../../ns-3-dev/src/spectrum/model/spectrum-channel.h
29,34d28
< #include <ns3/spectrum-propagation-loss-model.h>
< #include <ns3/propagation-delay-model.h>
< #include <ns3/propagation-loss-model.h>
< #include <ns3/spectrum-phy.h>
< #include <ns3/traced-callback.h>
< #include <ns3/mobility-model.h>
40a35,38
> class SpectrumPhy;
> class SpectrumPropagationLossModel;
> class PropagationLossModel;
> class PropagationDelayModel;
51,60d48
< 
<   /**
<    * constructor
<    *
<    */
<   SpectrumChannel ();
<   /**
<    * destructor
<    *
<    */
63,65d50
<   // inherited from Object
<   virtual void DoDispose (void);
< 
73c58
<    * Add the single-frequency propagation loss model to be used
---
>    * Set the single-frequency propagation loss model to be used
78c63
<   void AddPropagationLossModel (Ptr<PropagationLossModel> loss);
---
>   virtual void AddPropagationLossModel (Ptr<PropagationLossModel> loss) = 0;
81c66
<    * Add the frequency-dependent propagation loss model to be used
---
>    * Set the frequency-dependent propagation loss model to be used
84c69
<   void AddSpectrumPropagationLossModel (Ptr<SpectrumPropagationLossModel> loss);
---
>   virtual void AddSpectrumPropagationLossModel (Ptr<SpectrumPropagationLossModel> loss) = 0;
87c72
<    * Set the propagation delay model to be used
---
>    * Set the  propagation delay model to be used
90,96c75
<   void SetPropagationDelayModel (Ptr<PropagationDelayModel> delay);
< 
<   /**
<    * Get the frequency-dependent propagation loss model.
<    * \returns a pointer to the propagation loss model.
<    */
<   Ptr<SpectrumPropagationLossModel> GetSpectrumPropagationLossModel (void);
---
>   virtual void SetPropagationDelayModel (Ptr<PropagationDelayModel> delay) = 0;
98,102d76
<   /**
<    * Get the propagation loss model.
<    * \returns a pointer to the propagation loss model.
<    */
<   Ptr<PropagationLossModel> GetPropagationLossModel (void);
107c81
<    * \param params the parameters of the signals being transmitted
---
>    * @param params the parameters of the signals being transmitted
112c86
<    * \brief Add a SpectrumPhy to a channel, so it can receive packets
---
>    * @brief Add a SpectrumPhy to a channel, so it can receive packets
117c91
<    * transmits (without receiving ever) does not need to be added to
---
>    * transmits (without receiveing ever) does not need to be added to
123c97
<    * \param phy the SpectrumPhy instance to be added to the channel as
---
>    * @param phy the SpectrumPhy instance to be added to the channel as
133a108,110
>    * \deprecated The non-const `Ptr<SpectrumValue>` is
>    * deprecated and will be changed to Ptr<const SpectrumValue>`
>    * in a future release.
136c113
<     (Ptr<const SpectrumPhy> txPhy, Ptr<const SpectrumPhy> rxPhy,
---
>     (Ptr<SpectrumPhy> txPhy, Ptr<SpectrumPhy> rxPhy,
138,201c115
<   /**
<    * TracedCallback signature for path loss calculation events.
<    *
<    * \param [in] txMobility The mobility model of the transmitter.
<    * \param [in] rxMobility The mobility model of the receiver.
<    * \param [in] txAntennaGain The transmitter antenna gain, in dB.
<    * \param [in] rxAntennaGain The receiver antenna gain, in dB.
<    * \param [in] propagationGain The propagation gain, in dB.
<    * \param [in] pathloss The path loss value, in dB.
<    */
<   typedef void (* GainTracedCallback)
<     (Ptr<const MobilityModel> txMobility, Ptr<const MobilityModel> rxMobility,
<      double txAntennaGain, double rxAntennaGain,
<      double propagationGain, double pathloss);
<   /**
<    * TracedCallback signature for Ptr<const SpectrumSignalParameters>.
<    *
<    * \param [in] params SpectrumSignalParameters instance.
<    */
<   typedef void (* SignalParametersTracedCallback) (Ptr<SpectrumSignalParameters> params);
< 
< protected:
< 
<   /**
<    * The `PathLoss` trace source. Exporting the pointers to the Tx and Rx
<    * SpectrumPhy and a pathloss value, in dB.
<    */
<   TracedCallback<Ptr<const SpectrumPhy>, Ptr<const SpectrumPhy>, double > m_pathLossTrace;
< 
<   /**
<    * The `Gain` trace source. Fired whenever a new path loss value
<    * is calculated. Exporting pointer to the mobility model of the transmitter and
<    * the receiver, Tx antenna gain, Rx antenna gain, propagation gain and pathloss
<    */
<   TracedCallback<Ptr<const MobilityModel>, Ptr<const MobilityModel>, double, double, double, double> m_gainTrace;
< 
<   /**
<    * Traced callback for SpectrumSignalParameters in StartTx requests
<    */
<   TracedCallback<Ptr<SpectrumSignalParameters> > m_txSigParamsTrace;
< 
<   /**
<    * Maximum loss [dB].
<    *
<    * Any device above this loss is considered out of range.
<    */
<   double m_maxLossDb;
< 
<   /**
<    * Single-frequency propagation loss model to be used with this channel.
<    */
<   Ptr<PropagationLossModel> m_propagationLoss;
< 
<   /**
<    * Propagation delay model to be used with this channel.
<    */
<   Ptr<PropagationDelayModel> m_propagationDelay;
< 
<   /**
<    * Frequency-dependent propagation loss model to be used with this channel.
<    */
<   Ptr<SpectrumPropagationLossModel> m_spectrumPropagationLoss;
< 
< 
---
>   
204a119
> 
205a121
> 
diff ../../NS3-WiGig/src/spectrum/model/spectrum-converter.cc ../../ns-3-dev/src/spectrum/model/spectrum-converter.cc
42d41
<   size_t rowPtr = 0;
45c44,45
<       size_t colInd = 0;
---
>       std::vector<double> coeffs;
> 
53,59c53
<           if (c > 0)
<             {
<               m_conversionMatrix.push_back (c);
<               m_conversionColInd.push_back (colInd);
<               rowPtr++;
<             }
<           colInd++;
---
>           coeffs.push_back (c);
61c55,56
<       m_conversionRowPtr.push_back (rowPtr);
---
> 
>       m_conversionMatrix.push_back (coeffs);
86d80
<   size_t i = 0; // Index of conversion coefficient
88,90c82,85
<   for (std::vector<size_t>::const_iterator convIt = m_conversionRowPtr.begin ();
<        convIt != m_conversionRowPtr.end ();
<        ++convIt)
---
> 
>   for (std::vector<std::vector<double> >::const_iterator toit = m_conversionMatrix.begin ();
>        toit != m_conversionMatrix.end ();
>        ++toit)
91a87,89
>       NS_ASSERT (tvit != tvvf->ValuesEnd ());
>       Values::const_iterator fvit = fvvf->ConstValuesBegin ();
> 
93c91,93
<       while (i < *convIt)
---
>       for (std::vector<double>::const_iterator fromit = toit->begin ();
>            fromit != toit->end ();
>            ++fromit)
95,96c95,97
<           sum += (*fvvf)[m_conversionColInd.at (i)] * m_conversionMatrix.at (i);
<           i++;
---
>           NS_ASSERT (fvit != fvvf->ConstValuesEnd ());
>           sum += (*fvit) * (*fromit);
>           ++fvit;
diff ../../NS3-WiGig/src/spectrum/model/spectrum-converter.h ../../ns-3-dev/src/spectrum/model/spectrum-converter.h
81,84c81
<   std::vector<double> m_conversionMatrix; //!< matrix of conversion coefficients stored in Compressed Row Storage format
<   std::vector<size_t> m_conversionRowPtr; //!< offset of rows in m_conversionMatrix
<   std::vector<size_t> m_conversionColInd; //!< column of each non-zero element in m_conversionMatrix
< 
---
>   std::vector<std::vector<double> > m_conversionMatrix; //!< matrix of conversion coefficients
diff ../../NS3-WiGig/src/spectrum/model/spectrum-model.cc ../../ns-3-dev/src/spectrum/model/spectrum-model.cc
104,122d103
< bool
< SpectrumModel::IsOrthogonal (const SpectrumModel &other) const
< {
<   for (Bands::const_iterator myIt = Begin ();
<        myIt != End ();
<        ++myIt)
<     {
<       for (Bands::const_iterator otherIt = other.Begin ();
<            otherIt != other.End ();
<            ++otherIt)
<         {
<           if (std::max (myIt->fl, otherIt->fl) < std::min (myIt->fh, otherIt->fh))
<             {
<               return false;
<             }
<         }
<     }
<   return true;
< }
diff ../../NS3-WiGig/src/spectrum/model/spectrum-model.h ../../ns-3-dev/src/spectrum/model/spectrum-model.h
123,130d122
<   /**
<    * Check if another SpectrumModels has bands orthogonal to our bands.
<    *
<    * \param other another SpectrumModel
<    * \returns true if bands are orthogonal
<    */
<   bool IsOrthogonal (const SpectrumModel &other) const;
< 
diff ../../NS3-WiGig/src/spectrum/model/spectrum-propagation-loss-model.cc ../../ns-3-dev/src/spectrum/model/spectrum-propagation-loss-model.cc
24d23
< #include "spectrum-signal-parameters.h"
72c71
<       rxPsd = m_next->CalcRxPowerSpectralDensity (rxPsd, a, b);
---
>       rxPsd = m_next->DoCalcRxPowerSpectralDensity (rxPsd, a, b);
75,107d73
< }
< 
< bool
< SpectrumPropagationLossModel::DoCalculateRxPowerAtReceiverSide (void) const
< {
<   return false;
< }
< 
< bool
< SpectrumPropagationLossModel::SupportMimoSystemPowerCalculation (void) const
< {
<   return false;
< }
< 
< Ptr<SpectrumValue>
< SpectrumPropagationLossModel::CalcRxPower (Ptr<SpectrumSignalParameters> rxParams,
<                                            Ptr<const MobilityModel> a,
<                                            Ptr<const MobilityModel> b) const
< {
<   rxParams->psd = DoCalcRxPowerSpectralDensity (rxParams->psd, a, b);
<   if (m_next != 0)
<     {
<       rxParams->psd = m_next->CalcRxPower (rxParams, a, b);
<     }
<   return rxParams->psd;
< }
< 
< void
< SpectrumPropagationLossModel::CalcMimoRxPower (Ptr<SpectrumSignalParameters> rxParams,
<                                                Ptr<const MobilityModel> a,
<                                                Ptr<const MobilityModel> b) const
< {
<   NS_FATAL_ERROR ("You must define this function");
diff ../../NS3-WiGig/src/spectrum/model/spectrum-propagation-loss-model.h ../../ns-3-dev/src/spectrum/model/spectrum-propagation-loss-model.h
31c31,32
< class SpectrumSignalParameters;
---
> 
> 
80,116d80
<   /**
<    * By default this function is set to false to allow backward compatability.
<    * \return Return true if we store we calculate the received power at the receiver side, otherwise false.
<    */
<   virtual bool DoCalculateRxPowerAtReceiverSide (void) const;
<   /**
<    * By default this function is set to false to allow backward compatability.
<    * \return Return true if we support calculating the received power for MIMO system, otherwise false.
<    */
<   virtual bool SupportMimoSystemPowerCalculation (void) const;
<   /**
<    * This method is to be called to calculate PSD at the receiver side.
<    *
<    * \param params the SpectrumSignalParameters of the signal being received.
<    * \param a sender mobility
<    * \param b receiver mobility
<    *
<    * \return set of values Vs frequency representing the received
<    * power in the same units used for the txPower parameter.
<    */
<   virtual Ptr<SpectrumValue> CalcRxPower (Ptr<SpectrumSignalParameters> params,
<                                           Ptr<const MobilityModel> a,
<                                           Ptr<const MobilityModel> b) const;
<   /**
<    * This method is to be called to calculate PSD for MIMO transmission.
<    *
<    * \param params the SpectrumSignalParameters of the signal being received.
<    * \param a sender mobility
<    * \param b receiver mobility
<    *
<    * \return set of values Vs frequency representing the received
<    * power in the same units used for the txPower parameter.
<    */
<   virtual void CalcMimoRxPower (Ptr<SpectrumSignalParameters> params,
<                                 Ptr<const MobilityModel> a,
<                                 Ptr<const MobilityModel> b) const;
< 
137d100
< 
138a102,106
> 
> 
> 
> 
> 
diff ../../NS3-WiGig/src/spectrum/model/spectrum-signal-parameters.cc ../../ns-3-dev/src/spectrum/model/spectrum-signal-parameters.cc
36d35
<   isMimo = false;
51,52d49
<   psdList = p.psdList;
<   isMimo = p.isMimo;
diff ../../NS3-WiGig/src/spectrum/model/spectrum-signal-parameters.h ../../ns-3-dev/src/spectrum/model/spectrum-signal-parameters.h
29c29
< #include "vector"
---
> 
113,130d112
< 
<   //// WIGIG ////
<   /**
<    * A list of Power Spectral Density of the
<    * concurrent waveforms, in linear units. The exact unit will depend on the
<    * type of transmission medium involved: W for radio communications, Pa for
<    * underwater acoustic communications. Other transmission media to
<    * be defined.
<    *
<    * \note when SpectrumSignalParameters is copied, only the pointer to the PSD will be copied. This is because SpectrumChannel objects normally overwrite the psd anyway, so there is no point in making a copy.
<    */
<   std::vector<Ptr<SpectrumValue> > psdList;
<   /**
<    * Indicate whether the transmission is MIMO or SISO.
<    */
<   bool isMimo;
<   //// WIGIG ////
< 
diff ../../NS3-WiGig/src/spectrum/model/spectrum-value.cc ../../ns-3-dev/src/spectrum/model/spectrum-value.cc
695,699d694
< uint32_t
< SpectrumValue::GetValuesN () const
< {
<   return m_values.size ();
< }
701,705c696
< const double &
< SpectrumValue::ValuesAt (uint32_t pos) const
< {
<   return m_values.at (pos);
< }
---
> 
diff ../../NS3-WiGig/src/spectrum/model/spectrum-value.h ../../ns-3-dev/src/spectrum/model/spectrum-value.h
46,47c46,47
<  * The domain of the function space, i.e., \f$ F \f$, is implemented by Bands.
<  * The codomain of the function space is implemented by Values.
---
>  * The domain of the function space, i.e., \f$ F \f$, is implemented by SetOfFreq.
>  * The codomain of the function space is implemented by SetOfValues
120c120
<    * @return a const iterator pointing to the beginning of the embedded Bands
---
>    * @return a const iterator pointing to the beginning of the embedded SpectrumModel
127c127
<    * @return a const iterator pointing to the end of the embedded Bands
---
>    * @return a const iterator pointing to the end of the embedded SpectrumModel
135c135
<    * @return a const iterator pointing to the beginning of the embedded Values
---
>    * @return a const iterator pointing to the beginning of the embedded SpectrumModel
142c142
<    * @return a const iterator pointing to the end of the embedded Values
---
>    * @return a const iterator pointing to the end of the embedded SpectrumModel
149c149
<    * @return an iterator pointing to the beginning of the embedded Values
---
>    * @return an iterator pointing to the beginning of the embedded SpectrumModel
156c156
<    * @return an iterator pointing to the end of the embedded Values
---
>    * @return an iterator pointing to the end of the embedded SpectrumModel
160,164d159
<   /**
<    * \brief Get the number of values stored in the array
<    * \return the values array size
<    */
<   uint32_t GetValuesN () const;
166,171d160
<   /**
<    * \brief Get the value element at the position
<    * \param pos position
<    * \return the value element in that position (with bounds checking)
<    */
<   const double & ValuesAt (uint32_t pos) const;
Only in ../../NS3-WiGig/src/spectrum/model: three-gpp-channel-model.cc
Only in ../../NS3-WiGig/src/spectrum/model: three-gpp-channel-model.h
Only in ../../NS3-WiGig/src/spectrum/model: three-gpp-spectrum-propagation-loss-model.cc
Only in ../../NS3-WiGig/src/spectrum/model: three-gpp-spectrum-propagation-loss-model.h
Only in ../../NS3-WiGig/src/spectrum/model: trace-fading-loss-model.cc
Only in ../../NS3-WiGig/src/spectrum/model: trace-fading-loss-model.h
diff ../../NS3-WiGig/src/spectrum/model/waveform-generator.cc ../../ns-3-dev/src/spectrum/model/waveform-generator.cc
91c91
<                      "Trace fired when a previously started transmission is finished",
---
>                      "Trace fired when a previosuly started transmission is finished",
diff ../../NS3-WiGig/src/spectrum/model/wifi-spectrum-value-helper.cc ../../ns-3-dev/src/spectrum/model/wifi-spectrum-value-helper.cc
5d4
<  * Copyright (c) 2017 Orange Labs
20,22c19,20
<  * Authors: Nicola Baldo <nbaldo@cttc.es>
<  *          Giuseppe Piro  <g.piro@poliba.it>
<  *          Rediet <getachew.redieteab@orange.com>
---
>  * Author: Nicola Baldo <nbaldo@cttc.es>
>  *         Giuseppe Piro  <g.piro@poliba.it>
36d33
< ///< Wifi Spectrum Model structure
39,50c36,38
<   /**
<    * Constructor
<    * \param f the frequency (in MHz)
<    * \param w the channel width (in MHz)
<    * \param b the width of each band (in Hz)
<    * \param g the guard band width (in MHz)
<    */
<   WifiSpectrumModelId (uint32_t f, uint16_t w, double b, uint16_t g);
<   uint32_t m_centerFrequency; ///< center frequency (in MHz)
<   uint16_t m_channelWidth;     ///< channel width (in MHz)
<   double m_bandBandwidth;     ///< width of each band (in Hz)
<   uint16_t m_guardBandwidth;   ///< guard band width (in MHz)
---
>   WifiSpectrumModelId (uint32_t f, uint32_t w);
>   uint32_t m_centerFrequency;
>   uint32_t m_channelWidth;
53c41
< WifiSpectrumModelId::WifiSpectrumModelId (uint32_t f, uint16_t w, double b, uint16_t g)
---
> WifiSpectrumModelId::WifiSpectrumModelId (uint32_t f, uint32_t w)
55,57c43
<     m_channelWidth (w),
<     m_bandBandwidth (b),
<     m_guardBandwidth (g)
---
>     m_channelWidth (w)
59c45
<   NS_LOG_FUNCTION (this << f << w << b << g);
---
>   NS_LOG_FUNCTION (this << f << w);
62,67d47
< /**
<  * Less than operator
<  * \param a the first wifi spectrum to compare
<  * \param b the second wifi spectrum to compare
<  * \returns true if the first spectrum is less than the second spectrum
<  */
71,80c51
<   return ( (a.m_centerFrequency < b.m_centerFrequency)
<            || ((a.m_centerFrequency == b.m_centerFrequency)
<                && (a.m_channelWidth < b.m_channelWidth))
<            || ((a.m_centerFrequency == b.m_centerFrequency)
<                && (a.m_channelWidth == b.m_channelWidth)
<                && (a.m_bandBandwidth < b.m_bandBandwidth)) // to cover coexistence of 11ax with legacy case
<            || ((a.m_centerFrequency == b.m_centerFrequency)
<                && (a.m_channelWidth == b.m_channelWidth)
<                && (a.m_bandBandwidth == b.m_bandBandwidth)
<                && (a.m_guardBandwidth < b.m_guardBandwidth))); // to cover 2.4 GHz case, where DSSS coexists with OFDM
---
>   return ( (a.m_centerFrequency < b.m_centerFrequency) || ( (a.m_centerFrequency == b.m_centerFrequency) && (a.m_channelWidth < b.m_channelWidth)));
83c54
< static std::map<WifiSpectrumModelId, Ptr<SpectrumModel> > g_wifiSpectrumModelMap; ///< static initializer for the class
---
> static std::map<WifiSpectrumModelId, Ptr<SpectrumModel> > g_wifiSpectrumModelMap;
86c57
< WifiSpectrumValueHelper::GetSpectrumModel (uint32_t centerFrequency, uint16_t channelWidth, uint32_t bandBandwidth, uint16_t guardBandwidth)
---
> WifiSpectrumValueHelper::GetSpectrumModel (uint32_t centerFrequency, uint32_t channelWidth)
88c59
<   NS_LOG_FUNCTION (centerFrequency << channelWidth << bandBandwidth << guardBandwidth);
---
>   NS_LOG_FUNCTION (centerFrequency << channelWidth);
90c61
<   WifiSpectrumModelId key (centerFrequency, channelWidth, bandBandwidth, guardBandwidth);
---
>   WifiSpectrumModelId key (centerFrequency, channelWidth);
100c71,74
<       double bandwidth = (channelWidth + (2.0 * guardBandwidth)) * 1e6;
---
>       // Overall bandwidth will be channelWidth plus 10 MHz guards on each side
>       double bandwidth = (channelWidth + 20) * 1e6;
>       // Use OFDM subcarrier width of 312.5 KHz as band granularity
>       double bandBandwidth = 312500;
102c76
<       uint32_t numBands = static_cast<uint32_t> ((bandwidth / bandBandwidth) + 0.5);
---
>       uint32_t numBands = static_cast<uint32_t> (bandwidth / bandBandwidth + 0.5);
108c82,83
<           numBands += 1;
---
>           NS_LOG_DEBUG ("Total bandwidth evenly divided by 312.5 KHz");
>           numBands += 1;    
111d85
<       NS_LOG_DEBUG ("Num bands " << numBands << " band bandwidth " << bandBandwidth);
114,115c88,89
<       double startingFrequencyHz = centerFrequencyHz - (numBands / 2 * bandBandwidth) - bandBandwidth / 2;
<       for (size_t i = 0; i < numBands; i++)
---
>       double startingFrequencyHz = centerFrequencyHz - (numBands/2 * bandBandwidth) - bandBandwidth/2;
>       for (size_t i = 0; i < numBands; i++) 
120c94
<           f += bandBandwidth / 2;
---
>           f += bandBandwidth/2;
122c96
<           f += bandBandwidth / 2;
---
>           f += bandBandwidth/2;
134d107
< // Power allocated to 71 center subbands out of 135 total subbands in the band
136c109
< WifiSpectrumValueHelper::CreateDsssTxPowerSpectralDensity (uint32_t centerFrequency, double txPowerW, uint16_t guardBandwidth)
---
> WifiSpectrumValueHelper::CreateHtOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint32_t channelWidth, double txPowerW)
138,141c111,112
<   NS_LOG_FUNCTION (centerFrequency << txPowerW << +guardBandwidth);
<   uint16_t channelWidth = 22;  // DSSS channels are 22 MHz wide
<   uint32_t bandBandwidth = 312500;
<   Ptr<SpectrumValue> c = Create<SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth, bandBandwidth, guardBandwidth));
---
>   NS_LOG_FUNCTION (centerFrequency << channelWidth << txPowerW);
>   Ptr<SpectrumValue> c = Create<SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth));
144,264c115
<   uint32_t nGuardBands = static_cast<uint32_t> (((2 * guardBandwidth * 1e6) / bandBandwidth) + 0.5);
<   uint32_t nAllocatedBands = static_cast<uint32_t> (((channelWidth * 1e6) / bandBandwidth) + 0.5);
<   NS_ASSERT (c->GetSpectrumModel ()->GetNumBands () == (nAllocatedBands + nGuardBands + 1));
<   // Evenly spread power across 22 MHz
<   double txPowerPerBand = txPowerW / nAllocatedBands;
<   for (size_t i = 0; i < c->GetSpectrumModel ()->GetNumBands (); i++, vit++, bit++)
<     {
<       if ((i >= (nGuardBands / 2)) && (i <= ((nGuardBands / 2) + nAllocatedBands - 1)))
<         {
<           *vit = txPowerPerBand / (bit->fh - bit->fl);
<         }
<     }
<   return c;
< }
< 
< Ptr<SpectrumValue>
< WifiSpectrumValueHelper::CreateOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth, double txPowerW, uint16_t guardBandwidth)
< {
<   NS_LOG_FUNCTION (centerFrequency << channelWidth << txPowerW << guardBandwidth);
<   uint32_t bandBandwidth = 0;
<   uint32_t innerSlopeWidth = 0;
<   switch (channelWidth)
<     {
<     case 20:
<       bandBandwidth = 312500;
<       innerSlopeWidth = static_cast<uint32_t> ((2e6 / bandBandwidth) + 0.5); // [-11;-9] & [9;11]
<       break;
<     case 10:
<       bandBandwidth = 156250;
<       innerSlopeWidth = static_cast<uint32_t> ((1e6 / bandBandwidth) + 0.5); // [-5.5;-4.5] & [4.5;5.5]
<       break;
<     case 5:
<       bandBandwidth = 78125;
<       innerSlopeWidth = static_cast<uint32_t> ((5e5 / bandBandwidth) + 0.5); // [-2.75;-2.5] & [2.5;2.75]
<       break;
<     default:
<       NS_FATAL_ERROR ("Channel width " << channelWidth << " should be correctly set.");
<       return 0;
<     }
< 
<   Ptr<SpectrumValue> c = Create<SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth, bandBandwidth, guardBandwidth));
<   uint32_t nGuardBands = static_cast<uint32_t> (((2 * guardBandwidth * 1e6) / bandBandwidth) + 0.5);
<   uint32_t nAllocatedBands = static_cast<uint32_t> (((channelWidth * 1e6) / bandBandwidth) + 0.5);
<   NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == (nAllocatedBands + nGuardBands + 1), "Unexpected number of bands " << c->GetSpectrumModel ()->GetNumBands ());
<   // 52 subcarriers (48 data + 4 pilot)
<   // skip guard band and 6 subbands, then place power in 26 subbands, then
<   // skip the center subband, then place power in 26 subbands, then skip
<   // the final 6 subbands and the guard band.
<   double txPowerPerBandW = txPowerW / 52;
<   NS_LOG_DEBUG ("Power per band " << txPowerPerBandW << "W");
<   uint32_t start1 = (nGuardBands / 2) + 6;
<   uint32_t stop1 = start1 + 26 - 1;
<   uint32_t start2 = stop1 + 2;
<   uint32_t stop2 = start2 + 26 - 1;
< 
<   //Build transmit spectrum mask
<   std::vector <StartStop> subBands;
<   subBands.push_back (std::make_pair (start1, stop1));
<   subBands.push_back (std::make_pair (start2, stop2));
<   StartStop maskBand (0, nAllocatedBands + nGuardBands);
<   CreateSpectrumMaskForOfdm (c, subBands, maskBand,
<                              txPowerPerBandW, nGuardBands,
<                              innerSlopeWidth, -40.0); // -40 dBr for the outermost points of the standard defined mask for 11a, 11g and downclocked versions of 11a for 11p
<   NormalizeSpectrumMask (c, txPowerW);
<   NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed");
<   return c;
< }
< 
< Ptr<SpectrumValue>
< WifiSpectrumValueHelper::CreateHtOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth, double txPowerW, uint16_t guardBandwidth)
< {
<   NS_LOG_FUNCTION (centerFrequency << channelWidth << txPowerW << guardBandwidth);
<   uint32_t bandBandwidth = 312500;
<   Ptr<SpectrumValue> c = Create<SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth, bandBandwidth, guardBandwidth));
<   uint32_t nGuardBands = static_cast<uint32_t> (((2 * guardBandwidth * 1e6) / bandBandwidth) + 0.5);
<   uint32_t nAllocatedBands = static_cast<uint32_t> (((channelWidth * 1e6) / bandBandwidth) + 0.5);
<   NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == (nAllocatedBands + nGuardBands + 1), "Unexpected number of bands " << c->GetSpectrumModel ()->GetNumBands ());
<   double txPowerPerBandW = 0.0;
<   // skip the guard band and 4 subbands, then place power in 28 subbands, then
<   // skip the center subband, then place power in 28 subbands, then skip
<   // the final 4 subbands and the guard band.
<   // Repeat for each 20 MHz band.
<   uint32_t start1 = (nGuardBands / 2) + 4;
<   uint32_t stop1 = start1 + 28 - 1;
<   uint32_t start2 = stop1 + 2;
<   uint32_t stop2 = start2 + 28 - 1;
<   uint32_t start3 = stop2 + (2 * 4);
<   uint32_t stop3 = start3 + 28 - 1;
<   uint32_t start4 = stop3 + 2;
<   uint32_t stop4 = start4 + 28 - 1;
<   uint32_t start5 = stop4 + (2 * 4);
<   uint32_t stop5 = start5 + 28 - 1;
<   uint32_t start6 = stop5 + 2;
<   uint32_t stop6 = start6 + 28 - 1;
<   uint32_t start7 = stop6 + (2 * 4);
<   uint32_t stop7 = start7 + 28 - 1;
<   uint32_t start8 = stop7 + 2;
<   uint32_t stop8 = start8 + 28 - 1;
<   uint32_t start9 = stop8 + (2 * 4);
<   uint32_t stop9 = start9 + 28 - 1;
<   uint32_t start10 = stop9 + 2;
<   uint32_t stop10 = start10 + 28 - 1;
<   uint32_t start11 = stop10 + (2 * 4);
<   uint32_t stop11 = start11 + 28 - 1;
<   uint32_t start12 = stop11 + 2;
<   uint32_t stop12 = start12 + 28 - 1;
<   uint32_t start13 = stop12 + (2 * 4);
<   uint32_t stop13 = start13 + 28 - 1;
<   uint32_t start14 = stop13 + 2;
<   uint32_t stop14 = start14 + 28 - 1;
<   uint32_t start15 = stop14 + (2 * 4);
<   uint32_t stop15 = start15 + 28 - 1;
<   uint32_t start16 = stop15 + 2;
<   uint32_t stop16 = start16 + 28 - 1;
<   //Prepare spectrum mask specific variables
<   uint32_t innerSlopeWidth = static_cast<uint32_t> ((2e6 / bandBandwidth) + 0.5); //size in number of subcarriers of the 0dBr<->20dBr slope (2MHz for HT/VHT)
<   double lowestPointDbr = (centerFrequency >= 5000) ?
<     -40.0 :                       //if 5 GHz band
<     -45.0;                       //if 2.4 GHz band
<   std::vector <StartStop> subBands; //list of data/pilot-containing subBands (sent at 0dBr)
<   StartStop maskBand (0, nAllocatedBands + nGuardBands);
---
>   double txPowerPerBand;
268,271c119,134
<       // 56 subcarriers (52 data + 4 pilot)
<       txPowerPerBandW = txPowerW / 56;
<       subBands.push_back (std::make_pair (start1, stop1));
<       subBands.push_back (std::make_pair (start2, stop2));
---
>       // 56 subcarriers (52 data + 4 pilot) 
>       NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == 129, "Unexpected number of bands");
>       // skip 32 subbands, then place power in 28 of the next 32 subbands, then
>       // skip the center subband, then place power in 28 of the next 32
>       // subbands, then skip the final 32 subbands.  
>       txPowerPerBand = txPowerW / 56;
>       for (size_t i = 0; i < c->GetSpectrumModel ()->GetNumBands (); i++, vit++, bit++)
>         {
>           if ((i >=36 && i <=63) || (i >=65 && i <=92)) 
>             {
>               *vit = txPowerPerBand / (bit->fh - bit->fl);
>             }
>         }
>       NS_LOG_DEBUG ("Added signal power to subbands 36-63 and 65-92");
>       NS_LOG_DEBUG ("Integrated power " << Integral (*c));
>       NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed"); 
274c137
<       // 112 subcarriers (104 data + 8 pilot)
---
>       // 112 subcarriers (104 data + 8 pilot) 
276,280c139,150
<       txPowerPerBandW = txPowerW / 112;
<       subBands.push_back (std::make_pair (start1, stop1));
<       subBands.push_back (std::make_pair (start2, stop2));
<       subBands.push_back (std::make_pair (start3, stop3));
<       subBands.push_back (std::make_pair (start4, stop4));
---
>       NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == 193, "Unexpected number of bands");
>       txPowerPerBand = txPowerW / 112;
>       for (size_t i = 0; i < c->GetSpectrumModel ()->GetNumBands (); i++, vit++, bit++)
>         {
>           if ((i >=36 && i <=63) || (i >=65 && i <=92) || (i >=100 && i<=127) || (i >=129 && i<= 156)) 
>             {
>               *vit = txPowerPerBand / (bit->fh - bit->fl);
>             }
>         }
>       NS_LOG_DEBUG ("Added signal power to subbands 36-63, 65-92, 100-127, and 129-156");
>       NS_LOG_DEBUG ("Integrated power " << Integral (*c));
>       NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed"); 
283c153
<       // 224 subcarriers (208 data + 16 pilot)
---
>       // 224 subcarriers (208 data + 16 pilot) 
285,294c155,169
<       txPowerPerBandW = txPowerW / 224;
<       NS_ASSERT (lowestPointDbr == -40.0);
<       subBands.push_back (std::make_pair (start1, stop1));
<       subBands.push_back (std::make_pair (start2, stop2));
<       subBands.push_back (std::make_pair (start3, stop3));
<       subBands.push_back (std::make_pair (start4, stop4));
<       subBands.push_back (std::make_pair (start5, stop5));
<       subBands.push_back (std::make_pair (start6, stop6));
<       subBands.push_back (std::make_pair (start7, stop7));
<       subBands.push_back (std::make_pair (start8, stop8));
---
>       NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == 321, "Unexpected number of bands");
>       txPowerPerBand = txPowerW / 224;
>       for (size_t i = 0; i < c->GetSpectrumModel ()->GetNumBands (); i++, vit++, bit++)
>         {
>           if ((i >= 36 && i <= 63) || (i >= 65 && i <= 92) || 
>               (i >= 100 && i <= 127) || (i >= 129 && i <= 156) ||
>               (i >= 164 && i <= 191) || (i >= 193 && i <= 220) ||
>               (i >= 228 && i <= 255) || (i >= 257 && i <= 284))
>             {
>               *vit = txPowerPerBand / (bit->fh - bit->fl);
>             }
>         }
>       NS_LOG_DEBUG ("Added signal power to subbands 36-63, 65-92, 100-127, 129-156, 164-191, 193-220, 228-255, 257-284");
>       NS_LOG_DEBUG ("Integrated power " << Integral (*c));
>       NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed"); 
297c172
<       // 448 subcarriers (416 data + 32 pilot)
---
>       // 448 subcarriers (416 data + 32 pilot) VHT 
299,410c174,192
<       txPowerPerBandW = txPowerW / 448;
<       NS_ASSERT (lowestPointDbr == -40.0);
<       subBands.push_back (std::make_pair (start1, stop1));
<       subBands.push_back (std::make_pair (start2, stop2));
<       subBands.push_back (std::make_pair (start3, stop3));
<       subBands.push_back (std::make_pair (start4, stop4));
<       subBands.push_back (std::make_pair (start5, stop5));
<       subBands.push_back (std::make_pair (start6, stop6));
<       subBands.push_back (std::make_pair (start7, stop7));
<       subBands.push_back (std::make_pair (start8, stop8));
<       subBands.push_back (std::make_pair (start9, stop9));
<       subBands.push_back (std::make_pair (start10, stop10));
<       subBands.push_back (std::make_pair (start11, stop11));
<       subBands.push_back (std::make_pair (start12, stop12));
<       subBands.push_back (std::make_pair (start13, stop13));
<       subBands.push_back (std::make_pair (start14, stop14));
<       subBands.push_back (std::make_pair (start15, stop15));
<       subBands.push_back (std::make_pair (start16, stop16));
<       break;
<     }
< 
<   //Build transmit spectrum mask
<   CreateSpectrumMaskForOfdm (c, subBands, maskBand,
<                              txPowerPerBandW, nGuardBands,
<                              innerSlopeWidth, lowestPointDbr);
<   NormalizeSpectrumMask (c, txPowerW);
<   NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed");
<   return c;
< }
< 
< Ptr<SpectrumValue>
< WifiSpectrumValueHelper::CreateHeOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth, double txPowerW, uint16_t guardBandwidth)
< {
<   NS_LOG_FUNCTION (centerFrequency << channelWidth << txPowerW << guardBandwidth);
<   uint32_t bandBandwidth = 78125;
<   Ptr<SpectrumValue> c = Create<SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth, bandBandwidth, guardBandwidth));
<   uint32_t nGuardBands = static_cast<uint32_t> (((2 * guardBandwidth * 1e6) / bandBandwidth) + 0.5);
<   uint32_t nAllocatedBands = static_cast<uint32_t> (((channelWidth * 1e6) / bandBandwidth) + 0.5);
<   NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == (nAllocatedBands + nGuardBands + 1), "Unexpected number of bands " << c->GetSpectrumModel ()->GetNumBands ());
<   double txPowerPerBandW = 0.0;
<   uint32_t start1;
<   uint32_t stop1;
<   uint32_t start2;
<   uint32_t stop2;
<   uint32_t start3;
<   uint32_t stop3;
<   uint32_t start4;
<   uint32_t stop4;
<   //Prepare spectrum mask specific variables
<   uint32_t innerSlopeWidth = static_cast<uint32_t> ((1e6 / bandBandwidth) + 0.5); //size in number of subcarriers of the 0dBr<->20dBr slope
<   double lowestPointDbr = (centerFrequency >= 5000) ?
<     -40.0 :                       //if 5 GHz band
<     -45.0;                       //if 2.4 GHz band
<   std::vector <StartStop> subBands; //list of data/pilot-containing subBands (sent at 0dBr)
<   StartStop maskBand (0, nAllocatedBands + nGuardBands);
<   switch (channelWidth)
<     {
<     case 20:
<       // 242 subcarriers (234 data + 8 pilot)
<       txPowerPerBandW = txPowerW / 242;
<       innerSlopeWidth = static_cast<uint32_t> ((5e5 / bandBandwidth) + 0.5); // [-10.25;-9.75] & [9.75;10.25]
<       // skip the guard band and 6 subbands, then place power in 121 subbands, then
<       // skip 3 DC, then place power in 121 subbands, then skip
<       // the final 5 subbands and the guard band.
<       start1 = (nGuardBands / 2) + 6;
<       stop1 = start1 + 121 - 1;
<       start2 = stop1 + 4;
<       stop2 = start2 + 121 - 1;
<       subBands.push_back (std::make_pair (start1, stop1));
<       subBands.push_back (std::make_pair (start2, stop2));
<       break;
<     case 40:
<       // 484 subcarriers (468 data + 16 pilot)
<       txPowerPerBandW = txPowerW / 484;
<       // skip the guard band and 12 subbands, then place power in 242 subbands, then
<       // skip 5 DC, then place power in 242 subbands, then skip
<       // the final 11 subbands and the guard band.
<       start1 = (nGuardBands / 2) + 12;
<       stop1 = start1 + 242 - 1;
<       start2 = stop1 + 6;
<       stop2 = start2 + 242 - 1;
<       subBands.push_back (std::make_pair (start1, stop1));
<       subBands.push_back (std::make_pair (start2, stop2));
<       break;
<     case 80:
<       // 996 subcarriers (980 data + 16 pilot)
<       txPowerPerBandW = txPowerW / 996;
<       // skip the guard band and 12 subbands, then place power in 498 subbands, then
<       // skip 5 DC, then place power in 498 subbands, then skip
<       // the final 11 subbands and the guard band.
<       start1 = (nGuardBands / 2) + 12;
<       stop1 = start1 + 498 - 1;
<       start2 = stop1 + 6;
<       stop2 = start2 + 498 - 1;
<       subBands.push_back (std::make_pair (start1, stop1));
<       subBands.push_back (std::make_pair (start2, stop2));
<       break;
<     case 160:
<       // 2 x 996 subcarriers (2 x 80 MHZ bands)
<       txPowerPerBandW = txPowerW / (2 * 996);
<       start1 = (nGuardBands / 2) + 12;
<       stop1 = start1 + 498 - 1;
<       start2 = stop1 + 6;
<       stop2 = start2 + 498 - 1;
<       start3 = stop2 + (2 * 12);
<       stop3 = start3 + 498 - 1;
<       start4 = stop3 + 6;
<       stop4 = start4 + 498 - 1;
<       subBands.push_back (std::make_pair (start1, stop1));
<       subBands.push_back (std::make_pair (start2, stop2));
<       subBands.push_back (std::make_pair (start3, stop3));
<       subBands.push_back (std::make_pair (start4, stop4));
---
>       NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == 577, "Unexpected number of bands");
>       txPowerPerBand = txPowerW / 448;
>       for (size_t i = 0; i < c->GetSpectrumModel ()->GetNumBands (); i++, vit++, bit++)
>         {
>           if ((i >= 36 && i <= 63) || (i >= 65 && i <= 92) || 
>               (i >= 100 && i <= 127) || (i >= 129 && i <= 156) ||
>               (i >= 164 && i <= 191) || (i >= 193 && i <= 220) ||
>               (i >= 228 && i <= 255) || (i >= 257 && i <= 284) ||
>               (i >= 292 && i <= 319) || (i >= 321 && i <= 348) ||
>               (i >= 356 && i <= 383) || (i >= 385 && i <= 412) ||
>               (i >= 420 && i <= 447) || (i >= 449 && i <= 476) ||
>               (i >= 484 && i <= 511) || (i >= 513 && i <= 540))
>             {
>               *vit = txPowerPerBand / (bit->fh - bit->fl);
>             }
>         }
>       NS_LOG_DEBUG ("Added signal power to subbands 36-63, 65-92, 100-127, 129-156, 164-191, 193-220, 228-255, 257-284, 292-319, 321-348, 356-383, 385-412, 420-447, 449-476, 484-511, and 513-540");
>       NS_LOG_DEBUG ("Integrated power " << Integral (*c));
>       NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed"); 
416,422d197
< 
<   //Build transmit spectrum mask
<   CreateSpectrumMaskForOfdm (c, subBands, maskBand,
<                              txPowerPerBandW, nGuardBands,
<                              innerSlopeWidth, lowestPointDbr);
<   NormalizeSpectrumMask (c, txPowerW);
<   NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed");
426,427d200
< static const double WIGIG_BAND_BANDWIDTH_HZ = 5156250;
< 
429,464c202
< WifiSpectrumValueHelper::CreateWigigSingleCarrierTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth,
<                                                                          double txPowerW, double guardBandwidth,
<                                                                          uint8_t ncb)
< {
<   NS_LOG_FUNCTION (centerFrequency << channelWidth << txPowerW << guardBandwidth);
<   Ptr<SpectrumValue> c = Create<SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth, WIGIG_BAND_BANDWIDTH_HZ, guardBandwidth));
<   uint32_t nGuardBands = static_cast<uint32_t> (((2 * guardBandwidth * 1e6) / WIGIG_BAND_BANDWIDTH_HZ) + 0.5);
<   uint32_t nAllocatedBands = static_cast<uint32_t> (((channelWidth * 1e6) / WIGIG_BAND_BANDWIDTH_HZ)+ 0.5);
< //  NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == (nAllocatedBands + nGuardBands + 1),
< //                 "Unexpected number of bands " << c->GetSpectrumModel ()->GetNumBands ());
<   double txPowerPerBandW = 0.0;
<   uint32_t start1 = (nGuardBands / 2);
<   uint32_t stop1 = start1 + nAllocatedBands - 1;
<   //Prepare spectrum mask specific variables
<   uint32_t flatRegionWidth = static_cast<uint32_t> ((((ncb - 1) * 1080e6 + 940e6) / WIGIG_BAND_BANDWIDTH_HZ) + 0.5); //size in number of subcarriers in the flat region
<   uint32_t innerSlopeWidth = static_cast<uint32_t> ((((ncb - 1) * 120e6 + 260e6 )/ WIGIG_BAND_BANDWIDTH_HZ) + 0.5); //size in number of subcarriers of the 0dBr<->20dBr slope
<   uint32_t middleSlopeWidth = static_cast<uint32_t> (((ncb * 1500e6) / WIGIG_BAND_BANDWIDTH_HZ) + 0.5); //size in number of subcarriers of the 17dBr<->22dBr slope
<   uint32_t outerSlopeWidth = static_cast<uint32_t> (((ncb * 360e6) / WIGIG_BAND_BANDWIDTH_HZ) + 0.5); //size in number of subcarriers of the 22dBr<->30dBr slope
<   std::vector <StartStop> subBands; //list of data/pilot-containing subBands (sent at 0dBr)
<   StartStop maskBand (0, nAllocatedBands + nGuardBands);
<   txPowerPerBandW = txPowerW / nAllocatedBands;
<   subBands.push_back (std::make_pair (start1, stop1));
<   //Build transmit spectrum mask
<   CreateSpectrumMaskForWigig (c, subBands, maskBand,
<                               txPowerPerBandW, nGuardBands,
<                               flatRegionWidth, innerSlopeWidth,
<                               middleSlopeWidth, outerSlopeWidth);
<   NormalizeSpectrumMask (c, txPowerW);
<   NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed");
<   return c;
< }
< 
< //TR++ TODO VINCENT
< Ptr<SpectrumValue>
< WifiSpectrumValueHelper::CreateDmgOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth,
<                                                               double txPowerW, double guardBandwidth)
---
> WifiSpectrumValueHelper::CreateOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint32_t channelWidth, double txPowerW)
466,468c204,205
<   NS_LOG_FUNCTION (centerFrequency << channelWidth << txPowerW << guardBandwidth);
<   double bandBandwidth = 5156250;   /* DMG OFDM subcarrier frequency spacing 5.15625 MHz(2640 MHz/512) */
<   Ptr<SpectrumValue> c = Create<SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth, bandBandwidth, guardBandwidth));
---
>   NS_LOG_FUNCTION (centerFrequency << channelWidth << txPowerW);
>   Ptr<SpectrumValue> c = Create<SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth));
471,474d207
<   //TR++ TODO VINCENT Condition removed - To check
<   // uint32_t nGuardBands = static_cast<uint32_t>(((2 * guardBandwidth * 1e6) / bandBandwidth) + 0.5);
<   //uint32_t nAllocatedBands = static_cast<uint32_t>(((channelWidth * 1e6) / bandBandwidth) + 0.5);
<   //NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == (nAllocatedBands + nGuardBands + 1), "Unexpected number of bands " << c->GetSpectrumModel ()->GetNumBands ());
476d208
< 
479,488c211,217
<     case 2160:
<       //TR++ PHY
<       // Normally, there are 355 subcarriers for 802.11ad
<       // 16 pilots, 3 DC and 336 data
<       // The pilots are located on carriers 10, 30, 50, 70, 90, 110, 130 and 150,
<       // The three DC carriers are located in the middle (-1, 0 and +1) and are suppressed (nulled)
<       // TODO VINCENT Implement the null DC
<       NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == 355, "Unexpected number of bands");
<       txPowerPerBand = txPowerW / 355;
< 
---
>     case 20:
>       // 52 subcarriers (48 data + 4 pilot)
>       // skip 38 subbands, then place power in 26 subbands, then
>       // skip the center subband, then place power in 26 subbands, then skip
>       // the final 38 subbands.  
>       NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == 129, "Unexpected number of bands");
>       txPowerPerBand = txPowerW / 52;
491,495c220
<           if ((i >= 0 && i <= 9) || (i >= 11 && i <= 29) ||
<               (i >= 31 && i <= 49) || (i >= 51 && i <= 69) ||
<               (i >= 71 && i <= 89) || (i >= 91 && i <= 109) ||
<               (i >= 111 && i <= 129) || (i >= 131 && i <= 149) ||
<               (i >= 151))
---
>           if ((i >=38 && i <=63) || (i >=65 && i <=90)) 
499c224
<           else if ((i == 0) || (i == 1))
---
>           else
501d225
<               /* Hany: Put zero power in DC Subcarriers */
503a228,245
>         }
>       NS_LOG_DEBUG ("Added signal power to subbands 38-63 and 65-90");
>       NS_LOG_DEBUG ("Integrated power " << Integral (*c));
>       NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed"); 
>       break;
>     case 10:
>       // 28 subcarriers (24 data + 4 pilot)
>       // skip 34 subbands, then place power in 14 subbands, then
>       // skip the center subband, then place power in 14 subbands, then skip
>       // the final 34 subbands.  
>       NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == 97, "Unexpected number of bands");
>       txPowerPerBand = txPowerW / 28;
>       for (size_t i = 0; i < c->GetSpectrumModel ()->GetNumBands (); i++, vit++, bit++)
>         {
>           if ((i >=34 && i <=47) || (i >=49 && i <=62)) 
>             {
>               *vit = txPowerPerBand / (bit->fh - bit->fl);
>             }
506c248,265
<               //TODO VINCENT Check this as normally, I guess pilot and DC band should be managed differently
---
>               *vit = 0;
>             }
>         }
>       NS_LOG_DEBUG ("Added signal power to subbands 34-47 and 49-62");
>       NS_LOG_DEBUG ("Integrated power " << Integral (*c));
>       NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed"); 
>       break;
>     case 5:
>       // 16 subcarriers (12 data + 4 pilot)
>       // skip 34 subbands, then place power in 14 subbands, then
>       // skip the center subband, then place power in 14 subbands, then skip
>       // the final 34 subbands.  
>       NS_ASSERT_MSG (c->GetSpectrumModel ()->GetNumBands () == 81, "Unexpected number of bands");
>       txPowerPerBand = txPowerW / 16;
>       for (size_t i = 0; i < c->GetSpectrumModel ()->GetNumBands (); i++, vit++, bit++)
>         {
>           if ((i >=32 && i <=39) || (i >=41 && i <=48)) 
>             {
508a268,271
>           else
>             {
>               *vit = 0;
>             }
509a273,278
>       NS_LOG_DEBUG ("Added signal power to subbands 32-39 and 41-48");
>       NS_LOG_DEBUG ("Integrated power " << Integral (*c));
>       NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed"); 
>       break;
>     default:
>       NS_FATAL_ERROR ("ChannelWidth " << channelWidth << " unsupported");
512,513d280
<   NS_LOG_DEBUG ("Integrated power " << Integral (*c));
<   NS_ASSERT_MSG (std::abs (txPowerW - Integral (*c)) < 1e-6, "Power allocation failed");
516d282
< //TR--
517a284
> // Power allocated to 71 center subbands out of 135 total subbands in the band 
519c286
< WifiSpectrumValueHelper::CreateNoisePowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth, uint32_t bandBandwidth, double noiseFigure, uint16_t guardBandwidth)
---
> WifiSpectrumValueHelper::CreateDsssTxPowerSpectralDensity (uint32_t centerFrequency, double txPowerW)
521c288,310
<   Ptr<SpectrumModel> model = GetSpectrumModel (centerFrequency, channelWidth, bandBandwidth, guardBandwidth);
---
>   NS_LOG_FUNCTION (centerFrequency << txPowerW);
>   uint32_t channelWidth = 22;  // DSSS channels are 22 MHz wide
>   Ptr<SpectrumValue> c = Create<SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth));
>   Values::iterator vit = c->ValuesBegin ();
>   Bands::const_iterator bit = c->ConstBandsBegin ();
>   double txPowerPerBand;
>   // Evenly spread power across 22 MHz (71 bands)
>   NS_ASSERT (c->GetSpectrumModel ()->GetNumBands () == 135);
>   txPowerPerBand = txPowerW / 71;
>   for (size_t i = 0; i < c->GetSpectrumModel ()->GetNumBands (); i++, vit++, bit++)
>     {
>       if (i >=32 && i <=102) 
>         {
>           *vit = txPowerPerBand / (bit->fh - bit->fl);
>         }
>     }
>   return c;
> }
> 
> Ptr<SpectrumValue>
> WifiSpectrumValueHelper::CreateNoisePowerSpectralDensity (uint32_t centerFrequency, uint32_t channelWidth, double noiseFigure)
> {
>   Ptr<SpectrumModel> model = GetSpectrumModel (centerFrequency, channelWidth);
533c322
<   double kT_W_Hz = DbmToW (kT_dBm_Hz);
---
>   double kT_W_Hz = std::pow (10.0, (kT_dBm_Hz - 30) / 10.0);
539c328
<   NS_LOG_INFO ("NoisePowerSpectralDensity has integrated power of " << Integral (*noisePsd));
---
>   NS_LOG_DEBUG ("NoisePowerSpectralDensity has integrated power of " << Integral (*noisePsd));
544c333
< WifiSpectrumValueHelper::CreateRfFilter (uint32_t centerFrequency, uint16_t channelWidth, uint32_t bandBandwidth, uint16_t guardBandwidth)
---
> WifiSpectrumValueHelper::CreateRfFilter (uint32_t centerFrequency, uint32_t channelWidth)
546,547c335,336
<   NS_LOG_FUNCTION (centerFrequency << channelWidth << bandBandwidth << guardBandwidth);
<   Ptr<SpectrumValue> c = Create <SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth, bandBandwidth, guardBandwidth));
---
>   NS_LOG_FUNCTION (centerFrequency << channelWidth);
>   Ptr<SpectrumValue> c = Create <SpectrumValue> (GetSpectrumModel (centerFrequency, channelWidth));
551,552c340,343
<   size_t numBandsInFilter = static_cast<size_t> (channelWidth * 1e6 / bandBandwidth);
<   if (numBandsInFilter % 2 == 0)
---
>   uint32_t bandBandwidth = static_cast<uint32_t> (((bit->fh - bit->fl) + 0.5));
>   NS_LOG_DEBUG ("Band bandwidth: " << bandBandwidth);
>   size_t numBandsInFilter = static_cast<size_t> (channelWidth * 1e6 / bandBandwidth); 
>   if (channelWidth % bandBandwidth != 0)
556c347
<   NS_LOG_INFO ("Num bands in filter: " << numBandsInFilter);
---
>   NS_LOG_DEBUG ("Num bands in filter: " << numBandsInFilter);
566c357
<   NS_LOG_LOGIC ("Added subbands " << startIndex << " to " << startIndex + numBandsInFilter << " to filter");
---
>   NS_LOG_DEBUG ("Added subbands " << startIndex << " to " << startIndex + numBandsInFilter << " to filter");
570,822c361
< //// WIGIG ////
< 
< void
< WifiSpectrumValueHelper::CreateSpectrumMaskForWigig (Ptr<SpectrumValue> c, std::vector <StartStop> allocatedSubBands, StartStop maskBand,
<                                                      double txPowerPerBandW, uint32_t nGuardBands,
<                                                      uint32_t flatRegionWidth, uint32_t innerSlopeWidth,
<                                                      uint32_t middleSlopeWidth, uint32_t outerSlopeWidth)
< {
<     NS_LOG_FUNCTION (c << allocatedSubBands.front ().first << allocatedSubBands.back ().second
<                      << maskBand.first << maskBand.second << txPowerPerBandW << nGuardBands << innerSlopeWidth);
< 
<     uint32_t numSubBands = allocatedSubBands.size ();
<     uint32_t numBands = c->GetSpectrumModel ()->GetNumBands ();
<     uint32_t numMaskBands = maskBand.second - maskBand.first + 1;
<     NS_ASSERT (numSubBands && numBands && numMaskBands);
<     NS_LOG_LOGIC ("Power per band " << txPowerPerBandW << "W");
< 
<     // Different power levels
<     double txPowerRefDbm = (10.0 * std::log10 (txPowerPerBandW * 1000.0));
<     double txPowerInnerBandMinDbm = txPowerRefDbm - 17;
<     double txPowerMiddleBandMinDbm = txPowerRefDbm - 22;
<     double txPowerOuterBandMinDbm = txPowerRefDbm - 30; //TODO also take into account dBm/MHz constraints
< 
<     // Different widths (in number of bands)
<     StartStop outerBandLeft (maskBand.first,
<                              maskBand.first + outerSlopeWidth);
<     StartStop middleBandLeft (outerBandLeft.second + 1,
<                               outerBandLeft.second + middleSlopeWidth);
<     StartStop innerBandLeft (middleBandLeft.second + 1,
<                              middleBandLeft.second + innerSlopeWidth);
<     StartStop flatRegion (innerBandLeft.second + 1,
<                           innerBandLeft.second + flatRegionWidth * 2);
<     StartStop innerBandRight (flatRegion.second + 1,
<                               flatRegion.second + innerSlopeWidth);
<     StartStop middleBandRight (innerBandRight.second + 1,
<                                innerBandRight.second + middleSlopeWidth);
<     StartStop outerBandRight (middleBandRight.second + 1,
<                               middleBandRight.second + outerSlopeWidth);
< 
<     NS_LOG_DEBUG ("outerBandLeft=[" << outerBandLeft.first << ";" << outerBandLeft.second << "] " <<
<                   "middleBandLeft=[" << middleBandLeft.first << ";" << middleBandLeft.second << "] " <<
<                   "innerBandLeft=[" << innerBandLeft.first << ";" << innerBandLeft.second << "] " <<
<                   "flatRegion=[" << flatRegion.first << ";" << flatRegion.second << "] " <<
<                   "subBands=[" << allocatedSubBands.front ().first << ";" << allocatedSubBands.back ().second << "] " <<
<                   "innerBandRight=[" << innerBandRight.first << ";" << innerBandRight.second << "] " <<
<                   "middleBandRight=[" << middleBandRight.first << ";" << middleBandRight.second << "] " <<
<                   "outerBandRight=[" << outerBandRight.first << ";" << outerBandRight.second << "] ");
< 
<     // Different slopes
<     double innerSlope = 17.0 / innerSlopeWidth;   // 0 to 17 dBr
<     double middleSlope = 5.0 / middleSlopeWidth;  // 17 to 22 dBr
<     double outerSlope = 8.0 / outerSlopeWidth;    // 22 to 30 dBr
< 
<     // Build spectrum mask
<     Values::iterator vit = c->ValuesBegin ();
<     Bands::const_iterator bit = c->ConstBandsBegin ();
<     double txPowerW = 0.0;
< 
<     for (size_t i = 0; i < numBands; i++, vit++, bit++)
<       {
<         if (i < maskBand.first || i > maskBand.second) //outside the spectrum mask
<           {
<             txPowerW = 0.0;
<           }
<         else if (i <= outerBandLeft.second && i >= outerBandLeft.first) //better to put greater first (less computation)
<           {
<             txPowerW = DbmToW (txPowerOuterBandMinDbm + ((i - outerBandLeft.first) * outerSlope));
<           }
<         else if (i <= middleBandLeft.second && i >= middleBandLeft.first)
<           {
<             txPowerW = DbmToW (txPowerMiddleBandMinDbm + ((i - middleBandLeft.first) * middleSlope));
<           }
<         else if (i <= innerBandLeft.second && i >= innerBandLeft.first)
<           {
<             txPowerW = DbmToW (txPowerInnerBandMinDbm + ((i - innerBandLeft.first) * innerSlope));
<           }
<         else if (i <= flatRegion.second && i >= flatRegion.first)
<           {
<             txPowerW = txPowerPerBandW;
<           }
<         else if (i <= innerBandRight.second && i >= innerBandRight.first)
<           {
<             txPowerW = DbmToW (txPowerRefDbm - ((i - innerBandRight.first + 1) * innerSlope)); // +1 so as to be symmetric with left slope
<           }
<         else if (i <= middleBandRight.second && i >= middleBandRight.first)
<           {
<             txPowerW = DbmToW (txPowerInnerBandMinDbm - ((i - middleBandRight.first + 1) * middleSlope)); // +1 so as to be symmetric with left slope
<           }
<         else if (i <= outerBandRight.second && i >= outerBandRight.first)
<           {
<             txPowerW = DbmToW (txPowerMiddleBandMinDbm - ((i - outerBandRight.first + 1) * outerSlope)); // +1 so as to be symmetric with left slope
<           }
<         else
<           {
<             NS_FATAL_ERROR ("Should have handled all cases, " << i);
<           }
<         double txPowerDbr = 10 * std::log10 (txPowerW / txPowerPerBandW);
<         NS_LOG_LOGIC (uint32_t (i) << " -> " << txPowerDbr);
<         *vit = txPowerW / (bit->fh - bit->fl);
<       }
<     NS_LOG_INFO ("Added signal power to subbands " << allocatedSubBands.front ().first << "-" << allocatedSubBands.back ().second);
< }
< 
< //// WIGIG ////
< 
< void
< WifiSpectrumValueHelper::CreateSpectrumMaskForOfdm (Ptr<SpectrumValue> c, std::vector <StartStop> allocatedSubBands, StartStop maskBand,
<                                                     double txPowerPerBandW, uint32_t nGuardBands,
<                                                     uint32_t innerSlopeWidth, double lowestPointDbr)
< {
<   NS_LOG_FUNCTION (c << allocatedSubBands.front ().first << allocatedSubBands.back ().second << maskBand.first << maskBand.second << txPowerPerBandW << nGuardBands << innerSlopeWidth << lowestPointDbr);
<   uint32_t numSubBands = allocatedSubBands.size ();
<   uint32_t numBands = c->GetSpectrumModel ()->GetNumBands ();
<   uint32_t numMaskBands = maskBand.second - maskBand.first + 1;
<   NS_ASSERT (numSubBands && numBands && numMaskBands);
<   NS_LOG_LOGIC ("Power per band " << txPowerPerBandW << "W");
< 
<   //Different power levels
<   double txPowerRefDbm = (10.0 * std::log10 (txPowerPerBandW * 1000.0));
<   double txPowerInnerBandMinDbm = txPowerRefDbm - 20;
<   double txPowerMiddleBandMinDbm = txPowerRefDbm - 28;
<   double txPowerOuterBandMinDbm = txPowerRefDbm + lowestPointDbr; //TODO also take into account dBm/MHz constraints
< 
<   //Different widths (in number of bands)
<   uint32_t outerSlopeWidth = nGuardBands / 4; // nGuardBands is the total left+right guard band. The left/right outer part is half of the left/right guard band.
<   uint32_t middleSlopeWidth = outerSlopeWidth - (innerSlopeWidth / 2);
<   StartStop outerBandLeft (maskBand.first, //to handle cases where allocated channel is under WifiPhy configured channel width.
<                            maskBand.first + outerSlopeWidth - 1);
<   StartStop middleBandLeft (outerBandLeft.second + 1,
<                             outerBandLeft.second + middleSlopeWidth);
<   StartStop innerBandLeft (allocatedSubBands.front ().first - innerSlopeWidth,
<                            allocatedSubBands.front ().first - 1); //better to place slope based on allocated subcarriers
<   StartStop flatJunctionLeft (middleBandLeft.second + 1,
<                               innerBandLeft.first - 1); //in order to handle shift due to guard subcarriers
<   StartStop outerBandRight (maskBand.second - outerSlopeWidth + 1,
<                             maskBand.second); //start from outer edge to be able to compute flat junction width
<   StartStop middleBandRight (outerBandRight.first - middleSlopeWidth,
<                              outerBandRight.first - 1);
<   StartStop innerBandRight (allocatedSubBands.back ().second + 1,
<                             allocatedSubBands.back ().second + innerSlopeWidth);
<   StartStop flatJunctionRight (innerBandRight.second + 1,
<                                middleBandRight.first - 1);
<   NS_LOG_DEBUG ("outerBandLeft=[" << outerBandLeft.first << ";" << outerBandLeft.second << "] " <<
<                 "middleBandLeft=[" << middleBandLeft.first << ";" << middleBandLeft.second << "] " <<
<                 "flatJunctionLeft=[" << flatJunctionLeft.first << ";" << flatJunctionLeft.second << "] " <<
<                 "innerBandLeft=[" << innerBandLeft.first << ";" << innerBandLeft.second << "] " <<
<                 "subBands=[" << allocatedSubBands.front ().first << ";" << allocatedSubBands.back ().second << "] " <<
<                 "innerBandRight=[" << innerBandRight.first << ";" << innerBandRight.second << "] " <<
<                 "flatJunctionRight=[" << flatJunctionRight.first << ";" << flatJunctionRight.second << "] " <<
<                 "middleBandRight=[" << middleBandRight.first << ";" << middleBandRight.second << "] " <<
<                 "outerBandRight=[" << outerBandRight.first << ";" << outerBandRight.second << "] ");
<   NS_ASSERT (numMaskBands == ((allocatedSubBands.back ().second - allocatedSubBands.front ().first + 1)  //equivalent to allocatedBand (includes notches and DC)
<                               + 2 * (innerSlopeWidth + middleSlopeWidth + outerSlopeWidth)
<                               + (flatJunctionLeft.second - flatJunctionLeft.first + 1) //flat junctions
<                               + (flatJunctionRight.second - flatJunctionRight.first + 1)));
< 
<   //Different slopes
<   double innerSlope = 20.0 / innerSlopeWidth; //0 to 20dBr
<   double middleSlope = 8.0 / middleSlopeWidth; //20 to 28dBr
<   double outerSlope = (txPowerMiddleBandMinDbm - txPowerOuterBandMinDbm) / outerSlopeWidth;
< 
<   //Build spectrum mask
<   Values::iterator vit = c->ValuesBegin ();
<   Bands::const_iterator bit = c->ConstBandsBegin ();
<   double txPowerW = 0.0;
<   for (size_t i = 0; i < numBands; i++, vit++, bit++)
<     {
<       if (i < maskBand.first || i > maskBand.second) //outside the spectrum mask
<         {
<           txPowerW = 0.0;
<         }
<       else if (i <= outerBandLeft.second && i >= outerBandLeft.first) //better to put greater first (less computation)
<         {
<           txPowerW = DbmToW (txPowerOuterBandMinDbm + ((i - outerBandLeft.first) * outerSlope));
<         }
<       else if (i <= middleBandLeft.second && i >= middleBandLeft.first)
<         {
<           txPowerW = DbmToW (txPowerMiddleBandMinDbm + ((i - middleBandLeft.first) * middleSlope));
<         }
<       else if (i <= flatJunctionLeft.second && i >= flatJunctionLeft.first)
<         {
<           txPowerW = DbmToW (txPowerInnerBandMinDbm);
<         }
<       else if (i <= innerBandLeft.second && i >= innerBandLeft.first)
<         {
<           txPowerW = DbmToW (txPowerInnerBandMinDbm + ((i - innerBandLeft.first) * innerSlope));
<         }
<       else if (i <= allocatedSubBands.back ().second && i >= allocatedSubBands.front ().first) //roughly in allocated band
<         {
<           bool insideSubBand = false;
<           for (uint32_t j = 0; !insideSubBand && j < numSubBands; j++) //continue until inside a sub-band
<             {
<               insideSubBand = (i <= allocatedSubBands[j].second) && (i >= allocatedSubBands[j].first);
<             }
<           if (insideSubBand)
<             {
<               txPowerW = txPowerPerBandW;
<             }
<           else
<             {
<               txPowerW = DbmToW (txPowerInnerBandMinDbm); //consider that nulled as much as possible inband but power leakage -> -20dBr
<             }
<         }
<       else if (i <= innerBandRight.second && i >= innerBandRight.first)
<         {
<           txPowerW = DbmToW (txPowerRefDbm - ((i - innerBandRight.first + 1) * innerSlope)); // +1 so as to be symmetric with left slope
<         }
<       else if (i <= flatJunctionRight.second && i >= flatJunctionRight.first)
<         {
<           txPowerW = DbmToW (txPowerInnerBandMinDbm);
<         }
<       else if (i <= middleBandRight.second && i >= middleBandRight.first)
<         {
<           txPowerW = DbmToW (txPowerInnerBandMinDbm - ((i - middleBandRight.first + 1) * middleSlope)); // +1 so as to be symmetric with left slope
<         }
<       else if (i <= outerBandRight.second && i >= outerBandRight.first)
<         {
<           txPowerW = DbmToW (txPowerMiddleBandMinDbm - ((i - outerBandRight.first + 1) * outerSlope)); // +1 so as to be symmetric with left slope
<         }
<       else
<         {
<           NS_FATAL_ERROR ("Should have handled all cases");
<         }
<       double txPowerDbr = 10 * std::log10 (txPowerW / txPowerPerBandW);
<       NS_LOG_LOGIC (uint32_t (i) << " -> " << txPowerDbr);
<       *vit = txPowerW / (bit->fh - bit->fl);
<     }
<   NS_LOG_INFO ("Added signal power to subbands " << allocatedSubBands.front ().first << "-" << allocatedSubBands.back ().second);
< }
< 
< void
< WifiSpectrumValueHelper::NormalizeSpectrumMask (Ptr<SpectrumValue> c, double txPowerW)
< {
<   NS_LOG_FUNCTION (c << txPowerW);
<   //Normalize power so that total signal power equals transmit power
<   double currentTxPowerW = Integral (*c);
<   double normalizationRatio = currentTxPowerW / txPowerW;
<   NS_LOG_LOGIC ("Current power: " << currentTxPowerW << "W vs expected power: " << txPowerW << "W" <<
<                 " -> ratio (C/E) = " << normalizationRatio);
<   Values::iterator vit = c->ValuesBegin ();
<   for (size_t i = 0; i < c->GetSpectrumModel ()->GetNumBands (); i++, vit++)
<     {
<       *vit = (*vit) / normalizationRatio;
<     }
< }
< 
< double
< WifiSpectrumValueHelper::DbmToW (double dBm)
< {
<   return std::pow (10.0, 0.1 * (dBm - 30.0));
< }
< 
< static Ptr<SpectrumModel> g_WifiSpectrumModel5Mhz; ///< static initializer for the class
---
> static Ptr<SpectrumModel> g_WifiSpectrumModel5Mhz;
865c404
< WifiSpectrumValue5MhzFactory::CreateTxPowerSpectralDensity (double txPower, uint8_t channel)
---
> WifiSpectrumValue5MhzFactory::CreateTxPowerSpectralDensity (double txPower, uint32_t channel)
899c438
< WifiSpectrumValue5MhzFactory::CreateRfFilter (uint8_t channel)
---
> WifiSpectrumValue5MhzFactory::CreateRfFilter (uint32_t channel)
diff ../../NS3-WiGig/src/spectrum/model/wifi-spectrum-value-helper.h ../../ns-3-dev/src/spectrum/model/wifi-spectrum-value-helper.h
4d3
<  * Copyright (c) 2017 Orange Labs
19,20c18
<  * Authors: Nicola Baldo <nbaldo@cttc.es>
<  *          Rediet <getachew.redieteab@orange.com>
---
>  * Author: Nicola Baldo <nbaldo@cttc.es>
34c32
<  *  This class defines all functions to create a spectrum model for
---
>  *  This class defines all functions to create a spectrum model for 
45c43
< 
---
>   
48,50c46,47
<    * and channel width.  The spectrum model spans the channel width
<    * +/- the guard bands (i.e. the model will span (channelWidth +
<    * 2 * guardBandwidth) MHz of bandwidth).
---
>    * and channel width.  The model includes +/- 10 MHz of guard bands
>    * (i.e. the model will span (channelWidth + 20) MHz of bandwidth).
54,56d50
<    * \param bandBandwidth width of each band (Hz)
<    * \param guardBandwidth width of the guard band (MHz)
<    *
58c52
<    * given carrier frequency and channel width configuration.
---
>    * given carrier frequency and channel width configuration. 
60c54
<   static Ptr<SpectrumModel> GetSpectrumModel (uint32_t centerFrequency, uint16_t channelWidth, uint32_t bandBandwidth, uint16_t guardBandwidth);
---
>   static Ptr<SpectrumModel> GetSpectrumModel (uint32_t centerFrequency, uint32_t channelWidth);
63,68c57,59
<    * Create a transmit power spectral density corresponding to DSSS
<    *
<    * The center frequency typically corresponds to 802.11b channel
<    * center frequencies but is not restricted to those frequencies.
<    *
<    * \note There is no channel width parameter; this method assumes 22 MHz
---
>    * Create a transmit power spectral density corresponding to OFDM 
>    * High Throughput (HT) (802.11n/ac).  Channel width may vary between 
>    * 20, 40, 80, and 160 MHz.
70a62
>    * \param channelWidth channel width (MHz)
72,73d63
<    * \param guardBandwidth width of the guard band (MHz)
<    * \returns a pointer to a newly allocated SpectrumValue representing the DSSS Transmit Power Spectral Density in W/Hz
75c65
<   static Ptr<SpectrumValue> CreateDsssTxPowerSpectralDensity (uint32_t centerFrequency, double txPowerW, uint16_t guardBandwidth);
---
>   static Ptr<SpectrumValue> CreateHtOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint32_t channelWidth, double txPowerW);
78c68
<    * Create a transmit power spectral density corresponding to OFDM
---
>    * Create a transmit power spectral density corresponding to OFDM 
80d69
<    * Guard bandwidth also typically varies with channel width.
85,86d73
<    * \param guardBandwidth width of the guard band (MHz)
<    * \return a pointer to a newly allocated SpectrumValue representing the OFDM Transmit Power Spectral Density in W/Hz for each Band
88c75
<   static Ptr<SpectrumValue> CreateOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth, double txPowerW, uint16_t guardBandwidth);
---
>   static Ptr<SpectrumValue> CreateOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint32_t channelWidth, double txPowerW);
91,93c78
<    * Create a transmit power spectral density corresponding to OFDM
<    * High Throughput (HT) (802.11n/ac).  Channel width may vary between
<    * 20, 40, 80, and 160 MHz.
---
>    * Create a transmit power spectral density corresponding to DSSS 
95,106c80,81
<    * \param centerFrequency center frequency (MHz)
<    * \param channelWidth channel width (MHz)
<    * \param txPowerW  transmit power (W) to allocate
<    * \param guardBandwidth width of the guard band (MHz)
<    * \return a pointer to a newly allocated SpectrumValue representing the HT OFDM Transmit Power Spectral Density in W/Hz for each Band
<    */
<   static Ptr<SpectrumValue> CreateHtOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth, double txPowerW, uint16_t guardBandwidth);
< 
<   /**
<    * Create a transmit power spectral density corresponding to OFDM
<    * High Efficiency (HE) (802.11ax).  Channel width may vary between
<    * 20, 40, 80, and 160 MHz.
---
>    * The center frequency typically corresponds to 802.11b channel 
>    * center frequencies but is not restricted to those frequencies.
109d83
<    * \param channelWidth channel width (MHz)
111,112d84
<    * \param guardBandwidth width of the guard band (MHz)
<    * \return a pointer to a newly allocated SpectrumValue representing the HE OFDM Transmit Power Spectral Density in W/Hz for each Band
114c86
<   static Ptr<SpectrumValue> CreateHeOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth, double txPowerW, uint16_t guardBandwidth);
---
>   static Ptr<SpectrumValue> CreateDsssTxPowerSpectralDensity (uint32_t centerFrequency, double txPowerW);
117d88
<    * Create a power spectral density corresponding to the noise
121d91
<    * \param bandBandwidth width of each band (Hz)
123d92
<    * \param guardBandwidth width of the guard band (MHz)
126c95
<   static Ptr<SpectrumValue> CreateNoisePowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth, uint32_t bandBandwidth, double noiseFigure, uint16_t guardBandwidth);
---
>   static Ptr<SpectrumValue> CreateNoisePowerSpectralDensity (uint32_t centerFrequency, uint32_t channelWidth, double noiseFigure);
129,132c98,99
<    * Create a thermal noise power spectral density
<    *
<    * \param noiseFigure the noise figure
<    * \param spectrumModel the spectrum model
---
>    * \param centerFrequency center frequency (MHz)
>    * \param channelWidth channel width (MHz)
138,139d104
<    * Create a spectral density corresponding to the RF filter
<    *
142,144d106
<    * \param bandBandwidth width of each band (Hz)
<    * \param guardBandwidth width of the guard band (MHz)
<    *
148,241c110
<   static Ptr<SpectrumValue> CreateRfFilter (uint32_t centerFrequency, uint16_t channelWidth, uint32_t bandBandwidth, uint16_t guardBandwidth);
< 
<   //// WIGIG ///
<   /**
<    * CreateWigigSingleCarrierTxPowerSpectralDensity
<    * \param centerFrequency center frequency (MHz)
<    * \param channelWidth channel width (MHz)
<    * \param txPowerW  transmit power (W) to allocate
<    * \param guardBandwidth width of the guard band (MHz)
<    * \return a pointer to a newly allocated SpectrumValue representing the Wigig Contrn and SC Transmit Power Spectral Density in W/Hz for each Band.
<    */
<   static Ptr<SpectrumValue> CreateWigigSingleCarrierTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth,
<                                                                             double txPowerW, double guardBandwidth,
<                                                                             uint8_t ncb = 1);
<   /**
<    * CreateDmgOfdmTxPowerSpectralDensity
<    * \param centerFrequency center frequency (MHz)
<    * \param channelWidth channel width (MHz)
<    * \param txPowerW  transmit power (W) to allocate
<    * \param guardBandwidth width of the guard band (MHz)
<    * \return a pointer to a newly allocated SpectrumValue representing the Wigig OFDM Transmit Power Spectral Density in W/Hz for each Band.
<    */
<   static Ptr<SpectrumValue> CreateDmgOfdmTxPowerSpectralDensity (uint32_t centerFrequency, uint16_t channelWidth,
<                                                                  double txPowerW, double guardBandwidth);
<   //// WIGIG ///
< 
<   /**
<    * typedef for a pair of start and stop sub-band indexes
<    */
<   typedef std::pair<uint32_t, uint32_t> StartStop;
< 
<   /**
<    * Create a transmit power spectral density corresponding to OFDM
<    * transmit spectrum mask requirements for 11a/11g/11n/11ac/11ax
<    * Channel width may vary between 5, 10, 20, 40, 80, and 160 MHz.
<    *
<    *   [ guard band  ][    channel width     ][  guard band ]
<    *                   __________   __________                  _ 0 dBr
<    *                  /          | |          \
<    *                 /           |_|           \                _ -20 dBr
<    *             . '                             ' .
<    *         . '                                     ' .        _ -28 dBr
<    *       .'                                           '.
<    *     .'                                               '.
<    *   .'                                                   '.  _ lowest point
<    *
<    *   |-----|                                         |-----|  outerBand left/right
<    *         |------|                           |-- ---|        middle band left/right
<    *                |-|                       |-|               inner band left/right
<    *                  |-----------------------|                 allocated sub-bands
<    *   |-----------------------------------------------------|  mask band
<    *
<    * Please take note that, since guard tones are within the allocated band
<    * while not being ideally allocated any power, the inner band had to be
<    * shifted inwards and a flat junction band (at -20 dBr) had to be added
<    * between the inner and the middle bands.
<    *
<    * \param c spectrumValue to allocate according to transmit power spectral density mask (in W/Hz for each band)
<    * \param allocatedSubBands vector of start and stop subcarrier indexes of the allocated sub bands
<    * \param maskBand start and stop subcarrier indexes of transmit mask (in case signal doesn't cover whole SpectrumModel)
<    * \param txPowerPerBandW power allocated to each subcarrier in the allocated sub bands
<    * \param nGuardBands size (in number of subcarriers) of the guard band (left and right)
<    * \param innerSlopeWidth size (in number of subcarriers) of the inner band (i.e. slope going from 0 dBr to -20 dBr)
<    * \param lowestPointDbr maximum relative power of the outermost subcarriers of the guard band (in dBr)
<    * \return a pointer to a newly allocated SpectrumValue representing the HT OFDM Transmit Power Spectral Density in W/Hz for each Band
<    */
<   static void CreateSpectrumMaskForOfdm (Ptr<SpectrumValue> c, std::vector <StartStop> allocatedSubBands, StartStop maskBand,
<                                          double txPowerPerBandW, uint32_t nGuardBands,
<                                          uint32_t innerSlopeWidth, double lowestPointDbr);
< 
<   static void CreateSpectrumMaskForWigig (Ptr<SpectrumValue> c, std::vector <StartStop> allocatedSubBands, StartStop maskBand,
<                                           double txPowerPerBandW, uint32_t nGuardBands,
<                                           uint32_t flatJunctionWidth, uint32_t innerSlopeWidth,
<                                           uint32_t middleSlopeWidth, uint32_t outerSlopeWidth);
< 
<   /**
<    * Normalize the transmit spectrum mask generated by CreateSpectrumMaskForOfdm
<    * so that the total transmitted power corresponds to the input value.
<    *
<    * \param c spectrumValue to normalize (in W/Hz for each band)
<    * \param txPowerW total transmit power (W) to allocate
<    */
<   static void NormalizeSpectrumMask (Ptr<SpectrumValue> c, double txPowerW);
< 
<   /**
<    * Convert from dBm to Watts.
<    * Taken from wifi-utils since the original method couldn't be called from here
<    * due to resulting circular dependencies of spectrum and wifi modules.
<    *
<    * \param dbm the power in dBm
<    *
<    * \return the equivalent Watts for the given dBm
<    */
<   static double DbmToW (double dbm);
---
>   static Ptr<SpectrumValue> CreateRfFilter (uint32_t centerFrequency, uint32_t channelWidth);
267c136
<    * Creates a SpectrumValue instance that represents the TX Power Spectral
---
>    * Creates a SpectrumValue instance that represents the TX Power Spectral 
285c154
<   virtual Ptr<SpectrumValue> CreateTxPowerSpectralDensity (double txPower, uint8_t channel);
---
>   virtual Ptr<SpectrumValue> CreateTxPowerSpectralDensity (double txPower, uint32_t channel);
295c164
<   virtual Ptr<SpectrumValue> CreateRfFilter (uint8_t channel);
---
>   virtual Ptr<SpectrumValue> CreateRfFilter (uint32_t channel);
