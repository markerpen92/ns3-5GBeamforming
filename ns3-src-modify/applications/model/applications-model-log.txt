diff ../../NS3-WiGig/src/applications/model/bulk-send-application.cc ../../ns-3-dev/src/applications/model/bulk-send-application.cc
32d31
< #include "ns3/boolean.h"
56,60d54
<     .AddAttribute ("Local",
<                    "The Address on which to bind the socket. If not set, it is generated automatically.",
<                    AddressValue (),
<                    MakeAddressAccessor (&BulkSendApplication::m_local),
<                    MakeAddressChecker ())
73,77d66
<     .AddAttribute ("EnableE2EStats",
<                    "Enable E2E statistics (sequences, timestamps)",
<                    BooleanValue (false),
<                    MakeBooleanAccessor (&BulkSendApplication::m_enableE2EStats),
<                    MakeBooleanChecker ())
81,83d69
<     .AddTraceSource ("TxE2EStat", "Statistic sent with the packet",
<                      MakeTraceSourceAccessor (&BulkSendApplication::m_txTraceWithStats),
<                      "ns3::PacketSink::E2EStatCallback")
92,93c78
<     m_totBytes (0),
<     m_txPackets (0)
---
>     m_totBytes (0)
131d115
<   Address from;
137d120
<       int ret = -1;
148,155c131
<       if (! m_local.IsInvalid())
<         {
<           NS_ABORT_MSG_IF ((Inet6SocketAddress::IsMatchingType (m_peer) && InetSocketAddress::IsMatchingType (m_local)) ||
<                            (InetSocketAddress::IsMatchingType (m_peer) && Inet6SocketAddress::IsMatchingType (m_local)),
<                            "Incompatible peer and local address IP version");
<           ret = m_socket->Bind (m_local);
<         }
<       else
---
>       if (Inet6SocketAddress::IsMatchingType (m_peer))
157,164c133
<           if (Inet6SocketAddress::IsMatchingType (m_peer))
<             {
<               ret = m_socket->Bind6 ();
<             }
<           else if (InetSocketAddress::IsMatchingType (m_peer))
<             {
<               ret = m_socket->Bind ();
<             }
---
>           m_socket->Bind6 ();
166,167c135
< 
<       if (ret == -1)
---
>       else if (InetSocketAddress::IsMatchingType (m_peer))
169c137
<           NS_FATAL_ERROR ("Failed to bind socket");
---
>           m_socket->Bind ();
182,183c150
<       m_socket->GetSockName (from);
<       SendData (from, m_peer);
---
>       SendData ();
205c172
< void BulkSendApplication::SendData (const Address &from, const Address &to)
---
> void BulkSendApplication::SendData (void)
223,240c190,191
< 
<       Ptr<Packet> packet;
<       if (m_enableE2EStats)
<         {
<           // Should we add a trace for the sent tx and timestamp?
<           E2eStatsHeader header;
<           header.SetSeq (m_seq++);
<           header.SetSize (toSend);
<           NS_ABORT_IF (toSend < header.GetSerializedSize ());
<           packet = Create<Packet> (toSend - header.GetSerializedSize ());
<           packet->AddHeader (header);
<           m_txTraceWithStats (packet, from, to, header);
<         }
<       else
<         {
<           packet = Create<Packet> (toSend);
<         }
< 
---
>       Ptr<Packet> packet = Create<Packet> (toSend);
>       m_txTrace (packet);
245,246d195
<           m_txTrace (packet);
<           m_txPackets++;
250c199
<       // some buffer space has freed up.
---
>       // some buffer space has freed ip.
269,272c218
<   Address from, to;
<   socket->GetSockName (from);
<   socket->GetPeerName (to);
<   SendData (from, to);
---
>   SendData ();
281c227
< void BulkSendApplication::DataSend (Ptr<Socket> socket, uint32_t)
---
> void BulkSendApplication::DataSend (Ptr<Socket>, uint32_t)
287,290c233
<       Address from, to;
<       socket->GetSockName (from);
<       socket->GetPeerName (to);
<       SendData (from, to);
---
>       SendData ();
294,298d236
< uint64_t
< BulkSendApplication::GetTotalTxPackets (void) const
< {
<   return m_txPackets;
< }
300,304d237
< uint64_t
< BulkSendApplication::GetTotalTxBytes (void) const
< {
<   return m_totBytes;
< }
diff ../../NS3-WiGig/src/applications/model/bulk-send-application.h ../../ns-3-dev/src/applications/model/bulk-send-application.h
29d28
< #include "ns3/e2e-stats-header.h"
68,73d66
<  * If the attribute "EnableE2EStats" is enabled, the application will use
<  * some byte of the payload to store an header with a sequence number,
<  * a timestamp, and the size of the packet sent. To get these statistics,
<  * please use PacketSink (and enable its "EnableE2EStats" attribute) or extract
<  * the header yourself in your application (you can see how PacketSink is working
<  * with such headers).
109,117c102,104
<   /**
<    * \return the total packets transmitted
<    */
<   uint64_t GetTotalTxPackets (void) const;
<   /**
<    * \return the total bytes transmitted
<    */
<   uint64_t GetTotalTxBytes (void) const;
< 
---
> protected:
>   virtual void DoDispose (void);
> private:
122,124d108
< protected:
<   virtual void DoDispose (void);
< private:
127,128d110
<    * \param from From address
<    * \param to To address
130c112
<   void SendData (const Address &from, const Address &to);
---
>   void SendData ();
134d115
<   Address         m_local;        //!< Local address to bind to
140,143d120
<   uint64_t        m_txPackets;    //!< Total packets sent so far
<   uint32_t        m_seq {0};      //!< Sequence
<   bool            m_enableE2EStats {false}; //!< Enable or disable the e2e statistic generation
< 
147,149d123
< 
<   /// Callback for tracing the packet Tx events, includes source, destination, and the packet sent
<   TracedCallback<Ptr<const Packet>, const Address &, const Address &, const E2eStatsHeader &> m_txTraceWithStats;
Only in ../../NS3-WiGig/src/applications/model: e2e-stats-header.cc
Only in ../../NS3-WiGig/src/applications/model: e2e-stats-header.h
diff ../../NS3-WiGig/src/applications/model/onoff-application.cc ../../ns-3-dev/src/applications/model/onoff-application.cc
44,45d43
< #include "ns3/seq-ts-header.h"
< #include "timestamp-tag.h"
72,76d69
<     .AddAttribute ("Local",
<                    "The Address on which to bind the socket. If not set, it is generated automatically.",
<                    AddressValue (),
<                    MakeAddressAccessor (&OnOffApplication::m_local),
<                    MakeAddressChecker ())
85,88d77
<     .AddAttribute ("EnableTimestamp", "Whether we add timestamp tag to each outgoing packet or not.",
<                    BooleanValue (false),
<                    MakeBooleanAccessor (&OnOffApplication::m_enableTimestamp),
<                    MakeBooleanChecker ())
96,104c85
<     .AddAttribute ("MaxPackets",
<                    "The total number of packets to send. Once these packets are sent, "
<                    "no packet is sent again, even in on state. The value zero means "
<                    "that there is no limit.",
<                    UintegerValue (0),
<                    MakeUintegerAccessor (&OnOffApplication::m_maxPackets),
<                    MakeUintegerChecker<uint64_t> ())
<     .AddAttribute ("Protocol", "The type of protocol to use. This should be "
<                    "a subclass of ns3::SocketFactory",
---
>     .AddAttribute ("Protocol", "The type of protocol to use.",
107d87
<                    // This should check for SocketFactory as a parent
109,113d88
<     .AddAttribute ("EnableE2EStats",
<                    "Enable E2E statistics (sequences, timestamps)",
<                    BooleanValue (false),
<                    MakeBooleanAccessor (&OnOffApplication::m_enableE2EStats),
<                    MakeBooleanChecker ())
117,122d91
<     .AddTraceSource ("TxWithAddresses", "A new packet is created and is sent",
<                      MakeTraceSourceAccessor (&OnOffApplication::m_txTraceWithAddresses),
<                      "ns3::Packet::TwoAddressTracedCallback")
<     .AddTraceSource ("TxE2EStat", "Statistic sent with the packet",
<                      MakeTraceSourceAccessor (&OnOffApplication::m_txTraceWithStats),
<                      "ns3::PacketSink::E2EStatCallback")
133,134c102
<     m_totBytes (0),
<     m_txPackets (0)
---
>     m_totBytes (0)
158,169d125
< uint64_t
< OnOffApplication::GetTotalTxPackets (void) const
< {
<   return m_txPackets;
< }
< 
< uint64_t
< OnOffApplication::GetTotalTxBytes (void) const
< {
<   return m_totBytes;
< }
< 
184d139
<   CancelEvents ();
199,201c154
<       int ret = -1;
< 
<       if (! m_local.IsInvalid())
---
>       if (Inet6SocketAddress::IsMatchingType (m_peer))
203,206c156
<           NS_ABORT_MSG_IF ((Inet6SocketAddress::IsMatchingType (m_peer) && InetSocketAddress::IsMatchingType (m_local)) ||
<                            (InetSocketAddress::IsMatchingType (m_peer) && Inet6SocketAddress::IsMatchingType (m_local)),
<                            "Incompatible peer and local address IP version");
<           ret = m_socket->Bind (m_local);
---
>           m_socket->Bind6 ();
208c158,159
<       else
---
>       else if (InetSocketAddress::IsMatchingType (m_peer) ||
>                PacketSocketAddress::IsMatchingType (m_peer))
210,218c161
<           if (Inet6SocketAddress::IsMatchingType (m_peer))
<             {
<               ret = m_socket->Bind6 ();
<             }
<           else if (InetSocketAddress::IsMatchingType (m_peer) ||
<                    PacketSocketAddress::IsMatchingType (m_peer))
<             {
<               ret = m_socket->Bind ();
<             }
---
>           m_socket->Bind ();
220,225d162
< 
<       if (ret == -1)
<         {
<           NS_FATAL_ERROR ("Failed to bind socket");
<         }
< 
297c234
<   if ((m_maxBytes == 0 || m_totBytes < m_maxBytes) && (m_maxPackets == 0 || m_txPackets < m_maxPackets))
---
>   if (m_maxBytes == 0 || m_totBytes < m_maxBytes)
337,363c274
< 
<   Ptr<Packet> packet;
<   if (m_enableE2EStats)
<     {
<       Address from, to;
<       m_socket->GetSockName (from);
<       m_socket->GetPeerName (to);
<       E2eStatsHeader header;
<       header.SetSeq (m_seq++);
<       header.SetSize (m_pktSize);
<       NS_ABORT_IF (m_pktSize < header.GetSerializedSize ());
<       packet = Create<Packet> (m_pktSize - header.GetSerializedSize ());
<       packet->AddHeader (header);
<       m_txTraceWithStats (packet, from, to, header);
<     }
<   else
<     {
<       packet = Create<Packet> (m_pktSize);
<     }
< 
<   if (m_enableTimestamp)
<     {
<       TimestampTag timestamp;
<       timestamp.SetTimestamp (Simulator::Now ());
<       packet->AddByteTag (timestamp);
<     }
< 
---
>   Ptr<Packet> packet = Create<Packet> (m_pktSize);
367,369d277
<   m_txPackets++;
<   Address localAddress;
<   m_socket->GetSockName (localAddress);
378d285
<       m_txTraceWithAddresses (packet, localAddress, InetSocketAddress::ConvertFrom (m_peer));
388d294
<       m_txTraceWithAddresses (packet, localAddress, Inet6SocketAddress::ConvertFrom(m_peer));
405d310
<   NS_FATAL_ERROR ("Can't connect");
diff ../../NS3-WiGig/src/applications/model/onoff-application.h ../../ns-3-dev/src/applications/model/onoff-application.h
34d33
< #include "ns3/e2e-stats-header.h"
86,92d84
< *
< * If the attribute "EnableE2EStats" is enabled, the application will use
< * some byte of the payload to store an header with a sequence number,
< * a timestamp, and the size of the packet sent. To get these statistics,
< * please use PacketSink (and enable its "EnableE2EStats" attribute) or extract
< * the header yourself in your application (you can see how PacketSink is working
< * with such headers).
123,131d114
<   /**
<    * \return the total packets transmitted
<    */
<   uint64_t GetTotalTxPackets (void) const;
<   /**
<    * \return the total bytes transmitted
<    */
<   uint64_t GetTotalTxBytes (void) const;
< 
140a124,126
> protected:
>   virtual void DoDispose (void);
> private:
145,147d130
< protected:
<   virtual void DoDispose (void);
< private:
170d152
<   Address         m_local;        //!< Local address to bind to
180d161
<   uint64_t        m_maxPackets;   //!< Limit total number of packets sent
182d162
<   uint64_t        m_txPackets;     //!< Total packets sent so far
186,189d165
<   bool            m_enableTimestamp; //!< Add timestamp to each outgoing packet.
<   uint32_t        m_seq {0};      //!< Sequence
<   bool            m_enableE2EStats {false}; //!< Enable or disable the e2e statistic generation
< 
193,198d168
< 
<   /// Callbacks for tracing the packet Tx events, includes source and destination addresses
<   TracedCallback<Ptr<const Packet>, const Address &, const Address &> m_txTraceWithAddresses;
< 
<   /// Callback for tracing the packet Tx events, includes source, destination, and the packet sent
<   TracedCallback<Ptr<const Packet>, const Address &, const Address &, const E2eStatsHeader &> m_txTraceWithStats;
diff ../../NS3-WiGig/src/applications/model/packet-loss-counter.h ../../ns-3-dev/src/applications/model/packet-loss-counter.h
43c43
<  * (i.e., too old with respect to the last sequence number seen) are considered lost,
---
>  * (i.e., too old wit respect to the last sequence number seen) are considered lost,
diff ../../NS3-WiGig/src/applications/model/packet-sink.cc ../../ns-3-dev/src/applications/model/packet-sink.cc
34,40d33
< #include "timestamp-tag.h"
< 
< 
< #include <iostream>
< #include <fstream>
< using namespace ns3;
< using namespace std;
65,69d57
<     .AddAttribute ("EnableE2EStats",
<                    "Enable E2E statistics (sequences, timestamps)",
<                    BooleanValue (false),
<                    MakeBooleanAccessor (&PacketSink::m_enableE2EStats),
<                    MakeBooleanChecker ())
74,80d61
<     .AddTraceSource ("RxWithAddresses", "A packet has been received",
<                      MakeTraceSourceAccessor (&PacketSink::m_rxTraceWithAddresses),
<                      "ns3::Packet::TwoAddressTracedCallback")
<     .AddTraceSource ("RxE2EStat",
<                      "A sequence number and a timestamp have been received",
<                      MakeTraceSourceAccessor (&PacketSink::m_rxTraceWithAddressesAndSeqTs),
<                      "ns3::PacketSink::E2EStatCallback")
90d70
<   m_totalPackets = 0;
104,110d83
< uint64_t
< PacketSink::GetTotalReceivedPackets (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return m_totalPackets;
< }
< 
144,147c117
<       if (m_socket->Bind (m_local) == -1)
<         {
<           NS_FATAL_ERROR ("Failed to bind socket");
<         }
---
>       m_socket->Bind (m_local);
195d164
<   Address localAddress;
221d189
<       socket->GetSockName (localAddress);
223,295d190
<       m_rxTraceWithAddresses (packet, from, localAddress);
< 
<       if (m_enableE2EStats)
<         {
<           PacketReceived (packet, from, localAddress);
<         }
<      TimestampTag timestamp;
<      if (packet->FindFirstMatchingByteTag (timestamp))
<        {
<          Time tx = timestamp.GetTimestamp ();
<          accummulator += Simulator::Now () - tx;
<          if (Simulator::Now ().GetSeconds () > 1.9)
<          {
<            ofstream fout;
<            fout.open( "0_packet_latency.txt" ,ios::app);
<            fout << Simulator::Now ().GetSeconds ()  <<  " "  << (Simulator::Now () - tx).GetMicroSeconds() << " " << std::abs(49152-(InetSocketAddress::ConvertFrom (from).GetPort ()))<< "\n";
<            fout.close();
<          }
< 
<        }
<       m_totalPackets++;
<     }
< }
< 
< void
< PacketSink::PacketReceived (const Ptr<Packet> &p, const Address &from,
<                             const Address &localAddress)
< {
<   E2eStatsHeader header;
<   Ptr<Packet> buffer;
< 
<   auto itBuffer = m_buffer.find (from);
<   if (itBuffer == m_buffer.end ())
<     {
<       itBuffer = m_buffer.insert (std::make_pair (from, Create<Packet> (0))).first;
<     }
< 
<   buffer = itBuffer->second;
<   buffer->AddAtEnd (p);
<   buffer->PeekHeader (header);
< 
<   NS_ABORT_IF (header.GetSize () == 0);
< 
<   while (buffer->GetSize () >= header.GetSize ())
<     {
<       Ptr<Packet> complete = buffer->CreateFragment (0, static_cast<uint32_t> (header.GetSize ()));
<       buffer->RemoveAtStart (static_cast<uint32_t> (header.GetSize ()));
< 
<       complete->RemoveHeader (header);
< 
<       m_rxTraceWithAddressesAndSeqTs (complete, from, localAddress, header);
< 
<       if (buffer->GetSize () > 0)
<         {
<           buffer->PeekHeader (header);
<         }
<       else
<         {
<           break;
<         }
<     }
< }
< 
< Time
< PacketSink::GetAverageDelay (void) const
< {
<   if (m_totalPackets != 0)
<     {
<       return accummulator/m_totalPackets;
<     }
<   else
<     {
<       return Seconds (0);
diff ../../NS3-WiGig/src/applications/model/packet-sink.h ../../ns-3-dev/src/applications/model/packet-sink.h
29,31d28
< #include "ns3/inet-socket-address.h"
< #include "ns3/e2e-stats-header.h"
< #include <unordered_map>
80c77
<   
---
> 
87,90d83
<   /**
<    * \return the total number of received
<    */
<   uint64_t GetTotalReceivedPackets (void) const;
92d84
<   Time GetAverageDelay (void) const;
102,114c94
< 
<   /**
<    * TracedCallback signature for an E2E stat callback
<    *
<    * \param p The packet received
<    * \param from From address
<    * \param to Local address
<    * \param seq The sequence received
<    * \param time The delay the sequence has needed from the sender to the receiver
<    */
<   typedef void (* E2EStatCallback)(Ptr<const Packet> p, const Address &from, const Address & to,
<                                    const E2eStatsHeader &header);
< 
---
>  
144,181c124
<   /**
<    * \brief Packet received: calculation of the e2e statistics
<    * \param p received packet
<    * \param from from address
<    * \param localAddress local address
<    *
<    * The method calculates e2e statistics about the received packet. If
<    * the transport protocol is stream-based, then reconstruct first the
<    * original packet, and then extract the statistic header from it.
<    */
<   void PacketReceived (const Ptr<Packet> &p, const Address &from, const Address &localAddress);
< 
<   /**
<    * \brief Hashing for the Address class
<    */
<   struct AddressHash
<   {
<     /**
<      * \brief operator ()
<      * \param x the address of which calculate the hash
<      * \return the hash of x
<      *
<      * Should this method go in address.h?
<      *
<      * It calculates the hash taking the uint32_t hash value of the ipv4 address.
<      * It works only for InetSocketAddresses (Ipv4 version)
<      */
<     size_t operator() (const Address &x) const
<     {
<       NS_ABORT_IF (!InetSocketAddress::IsMatchingType (x));
<       InetSocketAddress a = InetSocketAddress::ConvertFrom (x);
<       return std::hash<uint32_t>()(a.GetIpv4 ().Get ());
<     }
<   };
< 
<   std::unordered_map<Address, Ptr<Packet>, AddressHash> m_buffer; //!< Buffer for received packets
< 
<   // In the case of TCP, each socket accept returns a new socket, so the
---
>   // In the case of TCP, each socket accept returns a new socket, so the 
189,191d131
<   uint64_t        m_totalPackets; //!< Total received packets.
< 
<   bool            m_enableE2EStats {false}; //!< Enable or disable the E2E statistics generation
195,199c135
<   /// Callback for tracing the packet Rx events, includes source and destination addresses
<   TracedCallback<Ptr<const Packet>, const Address &, const Address &> m_rxTraceWithAddresses;
<   /// Callback for tracing the packet Rx events, includes source, destination addresses, sequence and timestamp
<   TracedCallback<Ptr<const Packet>, const Address &, const Address &, const E2eStatsHeader&> m_rxTraceWithAddressesAndSeqTs;
<   Time accummulator;
---
> 
diff ../../NS3-WiGig/src/applications/model/seq-ts-header.h ../../ns-3-dev/src/applications/model/seq-ts-header.h
34,35c34
<  * a 64bits time stamp. If you need to use this header with a transport protocol
<  * such as TCP, please consider to use SizeHeader.
---
>  * a 64bits time stamp.
Only in ../../NS3-WiGig/src/applications/model: three-gpp-http-client.cc
Only in ../../NS3-WiGig/src/applications/model: three-gpp-http-client.h
Only in ../../NS3-WiGig/src/applications/model: three-gpp-http-header.cc
Only in ../../NS3-WiGig/src/applications/model: three-gpp-http-header.h
Only in ../../NS3-WiGig/src/applications/model: three-gpp-http-server.cc
Only in ../../NS3-WiGig/src/applications/model: three-gpp-http-server.h
Only in ../../NS3-WiGig/src/applications/model: three-gpp-http-variables.cc
Only in ../../NS3-WiGig/src/applications/model: three-gpp-http-variables.h
Only in ../../NS3-WiGig/src/applications/model: timestamp-tag.cc
Only in ../../NS3-WiGig/src/applications/model: timestamp-tag.h
diff ../../NS3-WiGig/src/applications/model/udp-client.cc ../../ns-3-dev/src/applications/model/udp-client.cc
71c71
<                    MakeUintegerChecker<uint32_t> (12,65507))
---
>                    MakeUintegerChecker<uint32_t> (12,1500))
122,125c122
<           if (m_socket->Bind () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind ();
130,133c127
<           if (m_socket->Bind6 () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind6 ();
138,141c132
<           if (m_socket->Bind () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind ();
146,149c137
<           if (m_socket->Bind6 () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind6 ();
diff ../../NS3-WiGig/src/applications/model/udp-echo-client.cc ../../ns-3-dev/src/applications/model/udp-echo-client.cc
73,81d72
<     .AddTraceSource ("Rx", "A packet has been received",
<                      MakeTraceSourceAccessor (&UdpEchoClient::m_rxTrace),
<                      "ns3::Packet::TracedCallback")
<     .AddTraceSource ("TxWithAddresses", "A new packet is created and is sent",
<                      MakeTraceSourceAccessor (&UdpEchoClient::m_txTraceWithAddresses),
<                      "ns3::Packet::TwoAddressTracedCallback")
<     .AddTraceSource ("RxWithAddresses", "A packet has been received",
<                      MakeTraceSourceAccessor (&UdpEchoClient::m_rxTraceWithAddresses),
<                      "ns3::Packet::TwoAddressTracedCallback")
139,142c130
<           if (m_socket->Bind () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind();
147,150c135
<           if (m_socket->Bind6 () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind6();
155,158c140
<           if (m_socket->Bind () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind ();
163,166c145
<           if (m_socket->Bind6 () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind6 ();
336,337d314
<   Address localAddress;
<   m_socket->GetSockName (localAddress);
341,348d317
<   if (Ipv4Address::IsMatchingType (m_peerAddress))
<     {
<       m_txTraceWithAddresses (p, localAddress, InetSocketAddress (Ipv4Address::ConvertFrom (m_peerAddress), m_peerPort));
<     }
<   else if (Ipv6Address::IsMatchingType (m_peerAddress))
<     {
<       m_txTraceWithAddresses (p, localAddress, Inet6SocketAddress (Ipv6Address::ConvertFrom (m_peerAddress), m_peerPort));
<     }
349a319
> 
385d354
<   Address localAddress;
400,402d368
<       socket->GetSockName (localAddress);
<       m_rxTrace (packet);
<       m_rxTraceWithAddresses (packet, from, localAddress);
diff ../../NS3-WiGig/src/applications/model/udp-echo-client.h ../../ns-3-dev/src/applications/model/udp-echo-client.h
175,184d174
< 
<   /// Callbacks for tracing the packet Rx events
<   TracedCallback<Ptr<const Packet> > m_rxTrace;
<   
<   /// Callbacks for tracing the packet Tx events, includes source and destination addresses
<   TracedCallback<Ptr<const Packet>, const Address &, const Address &> m_txTraceWithAddresses;
<   
<   /// Callbacks for tracing the packet Rx events, includes source and destination addresses
<   TracedCallback<Ptr<const Packet>, const Address &, const Address &> m_rxTraceWithAddresses;
< 
diff ../../NS3-WiGig/src/applications/model/udp-echo-server.cc ../../ns-3-dev/src/applications/model/udp-echo-server.cc
52,57d51
<     .AddTraceSource ("Rx", "A packet has been received",
<                      MakeTraceSourceAccessor (&UdpEchoServer::m_rxTrace),
<                      "ns3::Packet::TracedCallback")
<     .AddTraceSource ("RxWithAddresses", "A packet has been received",
<                      MakeTraceSourceAccessor (&UdpEchoServer::m_rxTraceWithAddresses),
<                      "ns3::Packet::TwoAddressTracedCallback")
91,94c85
<       if (m_socket->Bind (local) == -1)
<         {
<           NS_FATAL_ERROR ("Failed to bind socket");
<         }
---
>       m_socket->Bind (local);
115,118c106
<       if (m_socket6->Bind (local6) == -1)
<         {
<           NS_FATAL_ERROR ("Failed to bind socket");
<         }
---
>       m_socket6->Bind (local6);
162d149
<   Address localAddress;
165,167d151
<       socket->GetSockName (localAddress);
<       m_rxTrace (packet);
<       m_rxTraceWithAddresses (packet, from, localAddress);
diff ../../NS3-WiGig/src/applications/model/udp-echo-server.h ../../ns-3-dev/src/applications/model/udp-echo-server.h
26d25
< #include "ns3/traced-callback.h"
76,81d74
< 
<   /// Callbacks for tracing the packet Rx events
<   TracedCallback<Ptr<const Packet> > m_rxTrace;
< 
<   /// Callbacks for tracing the packet Rx events, includes source and destination addresses
<   TracedCallback<Ptr<const Packet>, const Address &, const Address &> m_rxTraceWithAddresses;
diff ../../NS3-WiGig/src/applications/model/udp-server.cc ../../ns-3-dev/src/applications/model/udp-server.cc
62,67d61
<     .AddTraceSource ("Rx", "A packet has been received",
<                      MakeTraceSourceAccessor (&UdpServer::m_rxTrace),
<                      "ns3::Packet::TracedCallback")
<     .AddTraceSource ("RxWithAddresses", "A packet has been received",
<                      MakeTraceSourceAccessor (&UdpServer::m_rxTraceWithAddresses),
<                      "ns3::Packet::TwoAddressTracedCallback")
130,133c124
<       if (m_socket->Bind (local) == -1)
<         {
<           NS_FATAL_ERROR ("Failed to bind socket");
<         }
---
>       m_socket->Bind (local);
144,147c135
<       if (m_socket6->Bind (local) == -1)
<         {
<           NS_FATAL_ERROR ("Failed to bind socket");
<         }
---
>       m_socket6->Bind (local);
171d158
<   Address localAddress;
174,176d160
<       socket->GetSockName (localAddress);
<       m_rxTrace (packet);
<       m_rxTraceWithAddresses (packet, from, localAddress);
diff ../../NS3-WiGig/src/applications/model/udp-server.h ../../ns-3-dev/src/applications/model/udp-server.h
30d29
< #include "ns3/traced-callback.h"
32d30
< 
105,111d102
< 
<   /// Callbacks for tracing the packet Rx events
<   TracedCallback<Ptr<const Packet> > m_rxTrace;
< 
<   /// Callbacks for tracing the packet Rx events, includes source and destination addresses
<   TracedCallback<Ptr<const Packet>, const Address &, const Address &> m_rxTraceWithAddresses;
< 
diff ../../NS3-WiGig/src/applications/model/udp-trace-client.cc ../../ns-3-dev/src/applications/model/udp-trace-client.cc
31d30
< #include "ns3/boolean.h"
88,92d86
<     .AddAttribute ("TraceLoop",
<                    "Loops through the trace file, starting again once it is over.",
<                    BooleanValue (true),
<                    MakeBooleanAccessor (&UdpTraceClient::SetTraceLoop),
<                    MakeBooleanChecker ())
187,191c181
<   uint32_t time = 0;
<   uint32_t index = 0;
<   uint32_t oldIndex = 0;
<   uint32_t size = 0;
<   uint32_t prevTime = 0;
---
>   uint32_t time, index, size, prevTime = 0;
204,207d193
<       if (index == oldIndex)
<         {
<           continue;
<         }
220d205
<       oldIndex = index;
223d207
<   NS_ASSERT_MSG (prevTime != 0, "A trace file can not contain B frames only.");
261,264c245
<           if (m_socket->Bind () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind ();
269,272c250
<           if (m_socket->Bind6 () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind6 ();
277,280c255
<           if (m_socket->Bind () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind ();
285,288c260
<           if (m_socket->Bind6 () == -1)
<             {
<               NS_FATAL_ERROR ("Failed to bind socket");
<             }
---
>           m_socket->Bind6 ();
360,361d331
< 
<   bool cycled = false;
375,379c345
<       if (m_currentEntry >= m_entries.size ())
<         {
<           m_currentEntry = 0;
<           cycled = true;
<         }
---
>       m_currentEntry %= m_entries.size ();
383,393c349
< 
<   if (!cycled || m_traceLoop)
<     {
<       m_sendEvent = Simulator::Schedule (MilliSeconds (entry->timeToSend), &UdpTraceClient::Send, this);
<     }
< }
< 
< void
< UdpTraceClient::SetTraceLoop (bool traceLoop)
< {
<   m_traceLoop = traceLoop;
---
>   m_sendEvent = Simulator::Schedule (MilliSeconds (entry->timeToSend), &UdpTraceClient::Send, this);
diff ../../NS3-WiGig/src/applications/model/udp-trace-client.h ../../ns-3-dev/src/applications/model/udp-trace-client.h
48c48
<  * \li -3- the third one indicates the time on which the frame was generated by the encoder (integer, milliseconds)
---
>  * \li -3- the third one indicates the time on which the frame was generated by the encoder
53,58d52
<  *
<  * Also note that:
<  * \li -1- consecutive 'B' frames are sent together,
<  * \li -2- any trace file is (by default) read again once finished (loop).
<  *
<  * The latter behavior can be changed through the "TraceLoop" attribute.
118,123d111
<   /**
<    * \brief Set the trace loop flag
<    * \param traceLoop true if the trace should be re-used
<    */
<   void SetTraceLoop (bool traceLoop);
< 
172d159
<   bool m_traceLoop; //!< Loop through the trace file
