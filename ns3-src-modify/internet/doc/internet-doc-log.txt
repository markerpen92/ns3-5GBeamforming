Only in ../../ns-3-dev/src/internet/doc: figures
diff ../../NS3-WiGig/src/internet/doc/ipv4.rst ../../ns-3-dev/src/internet/doc/ipv4.rst
14,96d13
< This chapter describes the |ns3| IPv4 address assignment and basic components tracking.
< 
< IPv4 addresses assignment
< *************************
< 
< In order to use IPv4 on a network, the first thing to do is assigning IPv4 addresses.
< 
< Any IPv4-enabled |ns3| node will have at least one NetDevice: the :cpp:class:`ns3::LoopbackNetDevice`.
< The loopback device address is ``127.0.0.1``.
< All the other NetDevices will have one (or more) IPv4 addresses.
< 
< Note that, as today, |ns3| does not have a NAT module, and it does not follows the rules about
< filtering private addresses (:rfc:`1918`): 10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16.
< These addresses are routed as any other address. This behaviour could change in the future.
< 
< IPv4 global addresses can be:
< 
< * manually assigned
< * assigned though DHCP
< 
< |ns3| can use both methods, and it's quite important to understand the implications of both.
< 
< Manually assigned IPv4 addresses
< ================================
< 
< This is probably the easiest and most used method. As an example:
< 
< ::
< 
<     Ptr<Node> n0 = CreateObject<Node> ();
<     Ptr<Node> n1 = CreateObject<Node> ();
<     NodeContainer net (n0, n1);
<     CsmaHelper csma;
<     NetDeviceContainer ndc = csma.Install (net); 
<     
<     NS_LOG_INFO ("Assign IPv4 Addresses.");
<     Ipv4AddressHelper ipv4;
<     ipv4.SetBase (Ipv4Address ("192.168.1.0"), NetMask ("/24"));
<     Ipv4InterfaceContainer ic = ipv4.Assign (ndc);
< 
< This method will add two global IPv4 addresses to the nodes.
< 
< Note that the addresses are assigned in sequence. As a consequence, the first Node / NetDevice 
< will have "192.168.1.1", the second "192.168.1.2" and so on.
< 
< It is possible to repeat the above to assign more than one address to a node.
< However, due to the :cpp:class:`Ipv4AddressHelper` singleton nature, one should first assign all the
< addresses of a network, then change the network base (``SetBase``), then do a new assignment.
< 
< Alternatively, it is possible to assign a specific address to a node:
< 
< ::
< 
<     Ptr<Node> n0 = CreateObject<Node> ();
<     NodeContainer net (n0);
<     CsmaHelper csma;
<     NetDeviceContainer ndc = csma.Install (net); 
< 
<     NS_LOG_INFO ("Specifically Assign an IPv4 Address.");
<     Ipv4AddressHelper ipv4;
<     Ptr<NetDevice> device = ndc.Get (0);
<     Ptr<Node> node = device->GetNode ();
<     Ptr<Ipv4> ipv4proto = node->GetObject<Ipv4> ();
<     int32_t ifIndex = 0;
<     ifIndex = ipv4proto->GetInterfaceForDevice (device);
<     Ipv4InterfaceAddress ipv4Addr = Ipv4InterfaceAddress (Ipv4Address ("192.168.1.42"), NetMask ("/24"));
<     ipv4proto->AddAddress (ifIndex, ipv4Addr);
< 
< 
< DHCP assigned IPv4 addresses
< ============================
< 
< DHCP is available in the internet-apps module. In order to use DHCP you have to have a 
< :cpp:class:`DhcpServer` application in a node (the DHC server node) and a :cpp:class:`DhcpClient` application in
< each of the nodes. Note that it not necessary that all the nodes in a subnet use DHCP. Some
< nodes can have static addresses.
< 
< All the DHCP setup is performed though the :cpp:class:`DhcpHelper`  class. A complete example is in
< ``src/internet-apps/examples/dhcp-example.cc``.
< 
< Further info about the DHCP functionalities can be found in the ``internet-apps`` model documentation.
< 
< 
125c42
< - If an ARP reply is received for a non-existent entry, the ARP reply packet
---
> - If an ARP reply is received for a non-existant entry, the ARP reply packet
201,235d117
< 
< Explicit Congestion Notification (ECN) bits
< *******************************************
< 
< - In IPv4, ECN bits are the last 2 bits in TOS field and occupy 14th and 15th
<   bits in the header.
< 
< - The IPv4 header class defines an EcnType enum with all four ECN codepoints
<   (ECN_NotECT, ECN_ECT1, ECN_ECT0, ECN_CE) mentioned
<   in RFC 3168, and also a setter and getter method to handle ECN values in
<   the TOS field.
< 
< Ipv4QueueDiscItem
< *****************
< 
< The traffic control sublayer in |ns3| handles objects of class
< ``QueueDiscItem`` which are used to hold an ns3::Packet and an ns3::Header.
< This is done to facilitate the marking of packets for Explicit
< Congestion Notification.  The ``Mark ()`` method is implemented in
< Ipv4QueueDiscItem. It returns true if marking the packet is successful, i.e.,
< it successfully sets the CE bit in the IPv4 header. The ``Mark ()`` method
< will return false, however, if the IPv4 header indicates the ``ECN_NotECT``
< codepoint.
< 
< RFC 6621 duplicate packet detection 
< ***********************************
< To support mesh network protocols over broadcast-capable networks (e.g. Wi-Fi),
< it is useful to have support for duplicate packet detection and filtering,
< since nodes in a network may receive multiple copies of flooded multicast
< packets arriving on different paths.  The ``Ipv4L3Protocol`` model in |ns3| 
< has a model for hash-based duplicate packet detection (DPD) based on 
< Section 6.2.2 of (:rfc:`6621`).  The model, disabled by default, must be
< enabled by setting ``EnableRFC6621`` to true.  A second attribute, 
< ``DuplicateExpire``, sets the expiration delay for erasing the cache entry
< of a packet in the duplicate cache; the delay value defaults to 1ms. 
diff ../../NS3-WiGig/src/internet/doc/ipv6.rst ../../ns-3-dev/src/internet/doc/ipv6.rst
138,139c138,139
< Manually assigned IPv6 addresses
< ++++++++++++++++++++++++++++++++
---
> Manually assigned IPv6 adddresses
> +++++++++++++++++++++++++++++++++
160c160
< Note that the global addresses will be derived from the MAC address. As a consequence, expect
---
> Note that the global addesses will be derived from the MAC address. As a consequence, expect
164,165c164,165
< However, due to the :cpp:class:`Ipv6AddressHelper` singleton nature, one should first assign all the
< addresses of a network, then change the network base (``SetBase``), then do a new assignment.
---
> However, due to the ``Ipv6AddressHelper`` singleton nature, one should first assign all the
> adddresses of a network, then change the network base (``SetBase``), then do a new assignment.
187,188c187,188
< Auto-generated IPv6 addresses
< #############################
---
> Auto-generated IPv6 adddresses
> ##############################
196c196
< allows to setup every parameter of the announced router advertisement on a given interface.
---
> allows to setup every parameter of the announced router advetisement on a given interface.
209,210c209,210
< Random-generated IPv6 addresses
< ###############################
---
> Random-generated IPv6 adddresses
> ################################
223c223
< since |ns3| nodes will usually be well-behaving, there shouldn't be any Duplicate Address.
---
> since |ns3| nodes will usually be well-behaving, therea should't be any Duplicate Address.
227,250d226
< Explicit Congestion Notification (ECN) bits in IPv6
< ===================================================
< 
< - In IPv6, ECN bits are the last 2 bits of the Traffic class and occupy 10th and 11th bit
<   in the header.
< 
< - The IPv6 header class defines an EcnType enum with all four ECN codepoints
<   (ECN_NotECT, ECN_ECT1, ECN_ECT0, ECN_CE) mentioned
<   in RFC 3168, and also a setter and getter method to handle ECN values in
<   the Traffic Class field.
< 
< Ipv6QueueDiscItem
< *****************
< 
< The traffic control sublayer in |ns3| handles objects of class
< ``QueueDiscItem`` which are used to hold an ns3::Packet and an ns3::Header.
< This is done to facilitate the marking of packets for Explicit
< Congestion Notification.  The ``Mark ()`` method is implemented in
< Ipv6QueueDiscItem. It returns true if marking the packet is successful, i.e.,
< it successfully sets the CE bit in the IPv6 header. The ``Mark ()`` method
< will return false, however, if the IPv6 header indicates the ``ECN_NotECT``
< codepoint.
< 
< 
300c276
< ICMPv6 PACKET_TOO_BIG messages from an interface with forwarding off. This is completely normal,
---
> ICMPv6 PACKET_TOO_BIG messages from an interface with frowarding off. This is completely normal,
346c322
< particular routing algorithm and to print the routing tables. 
---
> particular routing algorith and to print the routing tables. 
406c382
< protocols (UDP, TCP, etc.), or by receiving an ICMPv6 PACKET_TOO_BIG message.
---
> protocols (UDP, TCP, etc.), or by receving an ICMPv6 PACKET_TOO_BIG message.
diff ../../NS3-WiGig/src/internet/doc/routing-overview.rst ../../ns-3-dev/src/internet/doc/routing-overview.rst
41c41
< This is analogous to a dst_cache entry in Linux. The Ipv4Route is carried down
---
> This is analagous to a dst_cache entry in Linux. The Ipv4Route is carried down
84,158d83
< .. _Unicast-routing:
< 
< Unicast routing
< ***************
< 
< The following unicast routing protocols are defined for IPv4 and IPv6:
< 
< * classes Ipv4ListRouting and Ipv6ListRouting (used to store a prioritized list of routing protocols)
< * classes Ipv4StaticRouting and Ipv6StaticRouting (covering both unicast and multicast)
< * class Ipv4GlobalRouting (used to store routes computed by the global route
<   manager, if that is used)
< * class Ipv4NixVectorRouting (a more efficient version of global routing that
<   stores source routes in a packet header field)
< * class Rip - the IPv4 RIPv2 protocol (:rfc:`2453`)
< * class RipNg - the IPv6 RIPng protocol (:rfc:`2080`)
< * IPv4 Optimized Link State Routing (OLSR) (a MANET protocol defined in 
<   :rfc:`3626`)
< * IPv4 Ad Hoc On Demand Distance Vector (AODV) (a MANET protocol defined in
<   :rfc:`3561`)
< * IPv4 Destination Sequenced Distance Vector (DSDV) (a MANET protocol)
< * IPv4 Dynamic Source Routing (DSR) (a MANET protocol)
< 
< In the future, this architecture should also allow someone to implement a
< Linux-like implementation with routing cache, or a Click modular router, but
< those are out of scope for now.
< 
< Ipv[4,6]ListRouting
< +++++++++++++++++++
< 
< This section describes the current default |ns3| Ipv[4,6]RoutingProtocol. Typically,
< multiple routing protocols are supported in user space and coordinate to write a
< single forwarding table in the kernel. Presently in |ns3|, the implementation
< instead allows for multiple routing protocols to build/keep their own routing
< state, and the IP implementation will query each one of these routing
< protocols (in some order determined by the simulation author) until a route is
< found.  
< 
< We chose this approach because it may better facilitate the integration of
< disparate routing approaches that may be difficult to coordinate the writing to
< a single table, approaches where more information than destination IP address
< (e.g., source routing) is used to determine the next hop, and on-demand routing
< approaches where packets must be cached.  
< 
< Ipv[4,6]ListRouting::AddRoutingProtocol
< ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
< 
< Classes Ipv4ListRouting and Ipv6ListRouting provides a pure virtual function declaration
< for the method that allows one to add a routing protocol::
< 
<   void AddRoutingProtocol (Ptr<Ipv4RoutingProtocol> routingProtocol,
<                            int16_t priority);
< 
<   void AddRoutingProtocol (Ptr<Ipv6RoutingProtocol> routingProtocol,
<                            int16_t priority);
< 
< These methods are implemented respectively by class Ipv4ListRoutingImpl and by class 
< Ipv6ListRoutingImpl in the internet module.
< 
< The priority variable above governs the priority in which the routing protocols
< are inserted. Notice that it is a signed int.  By default in |ns3|, the helper
< classes will instantiate a Ipv[4,6]ListRoutingImpl object, and add to it an
< Ipv[4,6]StaticRoutingImpl object at priority zero.  Internally, a list of
< Ipv[4,6]RoutingProtocols is stored, and and the routing protocols are each consulted
< in decreasing order of priority to see whether a match is found. Therefore, if
< you want your Ipv4RoutingProtocol to have priority lower than the static
< routing, insert it with priority less than 0; e.g.::
< 
<   Ptr<MyRoutingProtocol> myRoutingProto = CreateObject<MyRoutingProtocol> ();
<   listRoutingPtr->AddRoutingProtocol (myRoutingProto, -10);
< 
< Upon calls to RouteOutput() or RouteInput(), the list routing object will search
< the list of routing protocols, in priority order, until a route is found. Such
< routing protocol will invoke the appropriate callback and no further routing
< protocols will be searched.  
< 
162c87
< ++++++++++++++++++++++++++
---
> **************************
187c112
< ~~~~~~~~~~~~~~~~~~~~~~~~~~
---
> ++++++++++++++++++++++++++
230c155
< ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
---
> +++++++++++++++++++++++++++++
287a213,336
> .. _Unicast-routing:
> 
> Unicast routing
> ***************
> 
> There are presently eigth unicast routing protocols defined for IPv4 and three for
> IPv6:
> 
> * class Ipv4StaticRouting (covering both unicast and multicast)
> * IPv4 Optimized Link State Routing (OLSR) (a MANET protocol defined in 
>   :rfc:`3626`)
> * IPv4 Ad Hoc On Demand Distance Vector (AODV) (a MANET protocol defined in
>   :rfc:`3561`)
> * IPv4 Destination Sequenced Distance Vector (DSDV) (a MANET protocol)
> * IPv4 Dynamic Source Routing (DSR) (a MANET protocol)
> * class Ipv4ListRouting (used to store a prioritized list of routing protocols)
> * class Ipv4GlobalRouting (used to store routes computed by the global route
>   manager, if that is used)
> * class Ipv4NixVectorRouting (a more efficient version of global routing that
>   stores source routes in a packet header field)
> * class Rip - the IPv4 RIPv2 protocol (:rfc:`2453`)
> * class Ipv6ListRouting (used to store a prioritized list of routing protocols)
> * class Ipv6StaticRouting 
> * class RipNg - the IPv6 RIPng protocol (:rfc:`2080`)
> 
> In the future, this architecture should also allow someone to implement a
> Linux-like implementation with routing cache, or a Click modular router, but
> those are out of scope for now.
> 
> Ipv[4,6]ListRouting
> +++++++++++++++++++
> 
> This section describes the current default |ns3| Ipv[4,6]RoutingProtocol. Typically,
> multiple routing protocols are supported in user space and coordinate to write a
> single forwarding table in the kernel. Presently in |ns3|, the implementation
> instead allows for multiple routing protocols to build/keep their own routing
> state, and the IP implementation will query each one of these routing
> protocols (in some order determined by the simulation author) until a route is
> found.  
> 
> We chose this approach because it may better facilitate the integration of
> disparate routing approaches that may be difficult to coordinate the writing to
> a single table, approaches where more information than destination IP address
> (e.g., source routing) is used to determine the next hop, and on-demand routing
> approaches where packets must be cached.  
> 
> Ipv[4,6]4ListRouting::AddRoutingProtocol
> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> 
> Classes Ipv4ListRouting and Ipv6ListRouting provides a pure virtual function declaration
> for the method that allows one to add a routing protocol::
> 
>   void AddRoutingProtocol (Ptr<Ipv4RoutingProtocol> routingProtocol,
>                            int16_t priority);
> 
>   void AddRoutingProtocol (Ptr<Ipv6RoutingProtocol> routingProtocol,
>                            int16_t priority);
> 
> These methods are implemented respectively by class Ipv4ListRoutingImpl and by class 
> Ipv6ListRoutingImpl in the internet module.
> 
> The priority variable above governs the priority in which the routing protocols
> are inserted. Notice that it is a signed int.  By default in |ns3|, the helper
> classes will instantiate a Ipv[4,6]ListRoutingImpl object, and add to it an
> Ipv[4,6]StaticRoutingImpl object at priority zero.  Internally, a list of
> Ipv[4,6]RoutingProtocols is stored, and and the routing protocols are each consulted
> in decreasing order of priority to see whether a match is found. Therefore, if
> you want your Ipv4RoutingProtocol to have priority lower than the static
> routing, insert it with priority less than 0; e.g.::
> 
>   Ptr<MyRoutingProtocol> myRoutingProto = CreateObject<MyRoutingProtocol> ();
>   listRoutingPtr->AddRoutingProtocol (myRoutingProto, -10);
> 
> Upon calls to RouteOutput() or RouteInput(), the list routing object will search
> the list of routing protocols, in priority order, until a route is found. Such
> routing protocol will invoke the appropriate callback and no further routing
> protocols will be searched.  
> 
> Optimized Link State Routing (OLSR)
> +++++++++++++++++++++++++++++++++++
> 
> This IPv4 routing protocol was originally ported from the OLSR-UM implementation
> for ns-2. The implementation is found in the src/olsr directory, and an
> example script is in examples/simple-point-to-point-olsr.cc.
> 
> Typically, OLSR is enabled in a main program by use of an OlsrHelper class that
> installs OLSR into an Ipv4ListRoutingProtocol object. The following sample
> commands will enable OLSR in a simulation using this helper class along with
> some other routing helper objects. The setting of priority value 10, ahead of
> the staticRouting priority of 0, means that OLSR will be consulted for a route
> before the node's static routing table.::
> 
>   NodeContainer c:
>   ...
>   // Enable OLSR
>   NS_LOG_INFO ("Enabling OLSR Routing.");
>   OlsrHelper olsr;
> 
>   Ipv4StaticRoutingHelper staticRouting;
> 
>   Ipv4ListRoutingHelper list;
>   list.Add (staticRouting, 0);
>   list.Add (olsr, 10);
> 
>   InternetStackHelper internet;
>   internet.SetRoutingHelper (list);
>   internet.Install (c);
> 
> Once installed,the OLSR "main interface" can be set with the SetMainInterface()
> command. If the user does not specify a main address, the protocol will select
> the first primary IP address that it finds, starting first the loopback
> interface and then the next non-loopback interface found, in order of Ipv4
> interface index. The loopback address of 127.0.0.1 is not selected. In addition,
> a number of protocol constants are defined in olsr-routing-protocol.cc.
> 
> Olsr is started at time zero of the simulation, based on a call to
> Object::Start() that eventually calls OlsrRoutingProtocol::DoStart(). Note:  a
> patch to allow the user to start and stop the protocol at other times would be
> welcome.
> 
> Presently, OLSR is limited to use with an Ipv4ListRouting object, and does not
> respond to dynamic changes to a device's IP address or link up/down
> notifications; i.e. the topology changes are due to loss/gain of connectivity
> over a wireless channel.
319c368
< cooldown, the topology can require some time to be stabilized.
---
> cooldown, the toplogy can require some time to be stabilized.
354c403
< The examples are based on the network topology
---
> The examples are based on the network toplogy
406,420d454
< 
< 
< Other routing protocols
< +++++++++++++++++++++++
< 
< Other routing protocols documentation can be found under the respective
< modules sections, e.g.:
< 
< * AODV
< * Click
< * DSDV
< * DSR
< * NixVectorRouting
< * OLSR
< * etc.
Binary files ../../NS3-WiGig/src/internet/doc/routing-specialization.dia and ../../ns-3-dev/src/internet/doc/routing-specialization.dia differ
diff ../../NS3-WiGig/src/internet/doc/tcp.rst ../../ns-3-dev/src/internet/doc/tcp.rst
9,10c9,10
< Overview of support for TCP
< ***************************
---
> Generic support for TCP
> ***********************
18c18
< * class :cpp:class:`TcpSocket`: This is defined in
---
> * class :cpp:class:`TcpSocket`:  This is defined in
23c23
< * class :cpp:class:`TcpSocketFactory`: This is used by the layer-4 protocol
---
> * class :cpp:class:`TcpSocketFactory`:  This is used by the layer-4 protocol
26c26
< There are presently two active and one legacy implementations of TCP available for |ns3|.
---
> There are presently three implementations of TCP available for |ns3|.
29,33c29,30
< * support for kernel implementations via `Direct Code Execution (DCE) <https://www.nsnam.org/overview/projects/direct-code-execution/>`__
< * (legacy) support for kernel implementations for the `Network Simulation Cradle (NSC) <http://www.wand.net.nz/~stj2/nsc/>`__
< 
< NSC is no longer actively supported; it requires use of gcc-5 or gcc-4.9, and
< only covers up to Linux kernel version 2.6.29.
---
> * support for the `Network Simulation Cradle (NSC) <http://www.wand.net.nz/~stj2/nsc/>`__
> * support for `Direct Code Execution (DCE) <https://www.nsnam.org/overview/projects/direct-code-execution/>`__
43,50c40,43
< connection setup and close logic. Several congestion control algorithms
< are supported, with NewReno the default, and Westwood, Hybla, HighSpeed,
< Vegas, Scalable, Veno, Binary Increase Congestion Control (BIC), Yet Another
< HighSpeed TCP (YeAH), Illinois, H-TCP, Low Extra Delay Background Transport
< (LEDBAT), TCP Low Priority (TCP-LP) and and Data Center TCP (DCTCP) also supported. The model also supports
< Selective Acknowledgements (SACK), Proportional Rate Reduction (PRR) and
< Explicit Congestion Notification (ECN). Multipath-TCP is not yet supported in
< the |ns3| releases.
---
> connection setup and close logic.  Several congestion control algorithms
> are supported, with NewReno the default, and Westwood, Hybla, and HighSpeed
> also supported.  Multipath-TCP and TCP Selective Acknowledgements (SACK)
> are not yet supported in the |ns3| releases.
56,57c49
< <http://www.ece.gatech.edu/research/labs/MANIACS/GTNetS/index.html>`_, 
< developed initially by George Riley and ported to |ns3| by Raj Bhattacharjea. 
---
> <http://www.ece.gatech.edu/research/labs/MANIACS/GTNetS/index.html>`_. 
59c51
< In 2015, the TCP module was redesigned in order to create a better 
---
> In 2015, the TCP module has been redesigned in order to create a better 
63c55
< Before the ns-3.25 release, a congestion control was considered as a stand-alone TCP
---
> Before ns-3.25 release, a congestion control was considered as a stand-alone TCP
78,94d69
< Acknowledgments
< +++++++++++++++
< 
< As mentioned above, |ns3| TCP has had multiple authors and maintainers over
< the years. Several publications exist on aspects of |ns3| TCP, and users
< of |ns3| TCP are requested to cite one of the applicable papers when 
< publishing new work.
< 
< A general reference on the current architecture is found in the following paper:
< 
< * Maurizio Casoni, Natale Patriciello, Next-generation TCP for ns-3 simulator, Simulation Modelling Practice and Theory, Volume 66, 2016, Pages 81-93. (http://www.sciencedirect.com/science/article/pii/S1569190X15300939) 
< 
< For an academic peer-reviewed paper on the SACK implementation in ns-3,
< please refer to:
< 
< * Natale Patriciello. 2017. A SACK-based Conservative Loss Recovery Algorithm for ns-3 TCP: a Linux-inspired Proposal. In Proceedings of the Workshop on ns-3 (WNS3 '17). ACM, New York, NY, USA, 1-8. (https://dl.acm.org/citation.cfm?id=3067666)
< 
120c95
< |ns3| that it wants the native |ns3| TCP vs. some other one? Well, when
---
> |ns3| that it wants the native |ns3| TCP vs. some other one?  Well, when
122c97
< aggregated to the node is the |ns3| TCP. This can be overridden as we show
---
> aggregated to the node is the |ns3| TCP.  This can be overridden as we show
129,130c104,105
< <http://www.nsnam.org/doxygen/classns3_1_1_tcp_socket.html>`_ for class
< :cpp:class:`TcpSocket`. For example, the maximum segment size is a
---
> <http://www.nsnam.org/doxygen/classns3_1_1_tcp_socket.html>` for class
> :cpp:class:`TcpSocket`.  For example, the maximum segment size is a
142c117
< ``Socket::CreateSocket()`` method. The TypeId passed to CreateSocket()
---
> ``Socket::CreateSocket()`` method.  The TypeId passed to CreateSocket()
145,146c120,121
< underlying TcpL4Protocol object. The easiest way to get at this would be
< through the attribute configuration system. In the below example,
---
> underlying TcpL4Protocol object.  The easiest way to get at this would be 
> through the attribute configuration system.  In the below example,
158c133
< NewReno, not just on node 'n0n1.Get (0)'. If one wants to limit it to just
---
> NewReno, not just on node 'n0n1.Get (0)'.  If one wants to limit it to just 
174c149
< and so is not straightforward to connect directly to them using pointers. Please
---
> and so is not straightforward to connect direcly to them using pointers. Please
242c217
<   Signal a termination of send, or in other words prevents data from being added
---
>   Signal a termination of send, or in other words revents data from being added
297,299c272,274
<   will send a reset. If the socket is in the state SYN_SENT, CLOSING, LISTEN,
<   FIN_WAIT_2, or LAST_ACK, after that call the application will be notified with
<   *NotifyNormalClose()*. In other cases, the notification is delayed
---
>   will send a reset. If the socket is in the state SYN_SENT, CLOSING, LISTEN or
>   LAST_ACK, after that call the application will be notified with
>   *NotifyNormalClose()*. In all the other cases, the notification is delayed
313,315c288,290
<   have sent the SYN, and we received the SYN-ACK: the socket prepares the
<   sequence numbers, sends the ACK for the SYN-ACK, tries to send out more data (in
<   another segment) and then invokes this callback. After this callback, it
---
>   have sent the SYN, and we received the SYN-ACK: the socket prepare the
>   sequence numbers, send the ACK for the SYN-ACK, try to send out more data (in
>   another segment) and then invoke this callback. After this callback, it
320c295
<   multiple times, and the socket gives up.
---
>   multiple time, and the socket give up.
329c304
<   - Upon entering the TIME_WAIT state, before waiting the 2*Maximum Segment Lifetime seconds to finally deallocate the socket.
---
>   - After 2*Maximum Segment Lifetime seconds passed since the socket entered the TIME_WAIT state.
342c317
<   up the congestion control, the sequence numbers, and processing the incoming
---
>   up the congestion control, the sequence numbers, and processed the incoming
348c323
<   The Socket notifies the application that some bytes have been transmitted on
---
>   The Socket notifies the application that some bytes has been transmitted on
355c330
<   succeeds (e.g. after the SYN-ACK is received) and after each new ACK (i.e.
---
>   succeeds (e.g. after the SYN-ACK is received) and after each new ack (i.e.
359c334
<   Called when in the receiver buffer there are in-order bytes, and when in
---
>   Called when in the receiver buffere there are in-order bytes, and when in
370c345
< NewReno
---
> New Reno
372c347
< NewReno algorithm introduces partial ACKs inside the well-established Reno
---
> New Reno algorithm introduces partial ACKs inside the well-established Reno
378c353
<   each ACK received that cumulatively acknowledges new data. Slow
---
>   each ACK received that cumulatively acknowledges new data.  Slow
380c355
<   reaches it, as noted above) or when congestion is observed. While
---
>   reaches it, as noted above) or when congestion is observed.  While
394c369
< HighSpeed
---
> High Speed
402c377
< certain threshold, which allows TCP HighSpeed to be friendly with standard
---
> certain threshold, which allows TCP Highspeed to be friendly with standard
409d383
<    :label: highspeedcwndincrement
418d391
<    :label: highspeedcwnddecrement
421c394
< More information at: http://dl.acm.org/citation.cfm?id=2756518
---
> More informations at: http://dl.acm.org/citation.cfm?id=2756518
435c408
< More information at: http://dl.acm.org/citation.cfm?id=2756518
---
> More informations at: http://dl.acm.org/citation.cfm?id=2756518
446c419
< More information at: http://dl.acm.org/citation.cfm?id=381704 and
---
> More informations at: http://dl.acm.org/citation.cfm?id=381704 and
454,456c427,429
< the actual throughput a connection achieves using Equation :eq:`vegasactual` and compares it
< with the expected throughput calculated in Equation :eq:`vegasexpected`. The difference between
< these 2 sending rates in Equation :eq:`vegasdiff` reflects the amount of extra packets being
---
> the actual throughput a connection achieves using Equation (1) and compares it
> with the expected throughput calculated in Equation (2). The difference between
> these 2 sending rates in Equation (3) reflects the amount of extra packets being
459,463c432
< .. math::   actual &= \frac{cWnd}{RTT}
<    :label: vegasactual
< 
< .. math::   expected &= \frac{cWnd}{BaseRTT}
<    :label: vegasexpected
---
> .. math::
465,466c434,436
< .. math::   diff &= expected - actual
<    :label: vegasdiff
---
>    actual &= \frac{cWnd}{RTT}        \\
>    expected &= \frac{cWnd}{BaseRTT}  \\
>    diff &= expected - actual
469c439
< to ensure the diff value falls between the two predefined thresholds, alpha and
---
> to ensure the diff value fall between the two predefined thresholds, alpha and
476c446
< More information at: http://dx.doi.org/10.1109/49.464716
---
> More informations at: http://dx.doi.org/10.1109/49.464716
482c452
< algorithm. When congestion has not been detected, for each ACK received in an
---
> algorithm.  When congestion has not been detected, for each ACK received in an
486d455
<    :label: scalablecwndincrement
495d463
<    :label: scalablecwnddecrement
497c465
< More information at: http://dl.acm.org/citation.cfm?id=956989
---
> More informations at: http://dl.acm.org/citation.cfm?id=956989
508c476
< calculated using Equation :eq:`venoN`:
---
> calculated using Equation (1):
513d480
<    :label: venoN
520d486
<    :label: venoDiff
528c494
< been fully utilized, i.e. when N exceeds beta. Otherwise, Veno increases
---
> been fully utilized, i.e. when N exceeds beta.  Otherwise, Veno increases
534c500
< congestion-based. Only when N is greater than beta, Veno halves its sending
---
> congestion-based.  Only when N is greater than beta, Veno halves its sending
537c503
< More information at: http://dx.doi.org/10.1109/JSAC.2002.807336
---
> More informations at: http://dx.doi.org/10.1109/JSAC.2002.807336
539c505
< BIC
---
> Bic
542c508
< In TCP BIC the congestion control problem is viewed as a search
---
> In TCP Bic the congestion control problem is viewed as a search
560c526
< More information at: http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1354672
---
> More informations at: http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=1354672
575c541
< YeAH operates between 2 modes: Fast and Slow mode. In the Fast mode when the queue
---
> YeAH operates between 2 modes: Fast and Slow mode.  In the Fast mode when the queue
577c543
< its congestion window according to the aggressive HSTCP rule. When the number of packets
---
> its congestion window according to the aggressive STCP rule.  When the number of packets
579,580c545,546
< its Slow mode, acting as Reno with a decongestion algorithm. YeAH employs Vegas' mechanism
< for calculating the backlog as in Equation :eq:`q_yeah`. The estimation of the network congestion
---
> its Slow mode, acting as Reno with a decongestion algorithm.  YeAH employs Vegas' mechanism
> for calculating the backlog as in Equation :eq:`q_yeah`.  The estimation of the network congestion
590,591c556,557
< Reno flows. Upon the receipt of 3 duplicate ACKs, YeAH decreases its slow start threshold
< according to Equation :eq:`yeahssthresh` if it's not competing with Reno flows. Otherwise, the ssthresh is
---
> Reno flows.  Upon the receipt of 3 duplicate ACKs, YeAH decreases its slow start threshold
> according to Equation (3) if it's not competing with Reno flows.  Otherwise,  the ssthresh is
595d560
<    :label: yeahssthresh
603c568
< high-speed networks. Illinois implements a Concave-AIMD (or C-AIMD)
---
> high-speed networks.  Illinois implements a Concave-AIMD (or C-AIMD)
610c575
< delay da as shown in Equations :eq:`illinoisalpha` and :eq:`illinoisbeta`. To improve the protocol
---
> delay da as shown in Equations (1) and (2).  To improve the protocol
620,623c585,586
<    \end{cases}
<    :label: illinoisalpha
< 
< .. math::
---
>    \end{cases} \\
>    \\
630d592
<    :label: illinoisbeta
634,641c596
< .. math::   k1 &= \frac{(dm - d1) \cdot alphaMin \cdot alphaMax}{alphaMax - alphaMin}
<    :label: illinoisk1
< 
< .. math::   k2 &= \frac{(dm - d1) \cdot alphaMin}{alphaMax - alphaMin} - d1
<    :label: illinoisk2
< 
< .. math::   k3 &= \frac{alphaMin \cdot d3 - alphaMax \cdot d2}{d3 - d2}
<    :label: illinoisk3
---
> .. math::
643,644c598,604
< .. math::   k4 &= \frac{alphaMax - alphaMin}{d3 - d2}
<    :label: illinoisk4
---
>    k1 &= \frac{(dm - d1) \cdot alphaMin \cdot alphaMax}{alphaMax - alphaMin} \\
>    \\
>    k2 &= \frac{(dm - d1) \cdot alphaMin}{alphaMax - alphaMin} - d1 \\
>    \\
>    k3 &= \frac{alphaMin \cdot d3 - alphaMax \cdot d2}{d3 - d2} \\
>    \\
>    k4 &= \frac{alphaMax - alphaMin}{d3 - d2}
652,653c612,614
< .. math::   da &= Ta - Tmin
<    :label: illinoisda
---
> .. math::
> 
>    da &= Ta - Tmin
655,656c616
< .. math::   dm &= Tmax - Tmin
<    :label: illinoisdm
---
>    dm &= Tmax - Tmin
658,659c618
< .. math::   d_i &= eta_i \cdot dm
<    :label: illinoisdi
---
>    d_i &= eta_i \cdot dm
690,691c649,651
< .. math::   alpha(delta)=1+10(delta-deltal)+0.5(delta-deltal)^2
<    :label: htcpalpha
---
> .. math::
> 
>         alpha(delta)=1+10(delta-deltal)+0.5(delta-deltal)^2 
696c656
< in the reference paper. The calculated throughput between the last two
---
> in the reference paper.  The calculated throughput between the last two 
700c660
< ``examples/tcp/tcp-variants-comparison.cc`` to perform an experiment with H-TCP,
---
> ``examples/tcp/tcp-variants/comparison`` to perform an experiment with H-TCP,
708,809c668
< More information (paper): http://www.hamilton.ie/net/htcp3.pdf
< 
< More information (Internet Draft): https://tools.ietf.org/html/draft-leith-tcp-htcp-06
< 
< LEDBAT
< ^^^^^^
< 
< Low Extra Delay Background Transport (LEDBAT) is an experimental delay-based 
< congestion control algorithm that seeks to utilize the available bandwidth on
< an end-to-end path while limiting the consequent increase in queueing delay 
< on that path. LEDBAT uses changes in one-way delay measurements to limit 
< congestion that the flow itself induces in the network.
< 
< As a first approximation, the LEDBAT sender operates as shown below:
< 
< On receipt of an ACK:
< 
< ::
<        currentdelay = acknowledgement.delay
<        basedelay = min (basedelay, currentdelay)
<        queuingdelay = currentdelay - basedelay
<        offtarget = (TARGET - queuingdelay) / TARGET
<        cWnd += GAIN * offtarget * bytesnewlyacked * MSS / cWnd
< 
< ``TARGET`` is the maximum queueing delay that LEDBAT itself may introduce in the
< network, and ``GAIN`` determines the rate at which the cwnd responds to changes in 
< queueing delay; ``offtarget`` is a normalized value representing the difference between
< the measured current queueing delay and the predetermined TARGET delay. offtarget can 
< be positive or negative; consequently, cwnd increases or decreases in proportion to 
< offtarget.
< 
< Following the recommendation of RFC 6817, the default values of the parameters are:
< 
< * TargetDelay = 100
< * baseHistoryLen = 10
< * noiseFilterLen = 4
< * Gain = 1
< 
< To enable LEDBAT on all TCP sockets, the following configuration can be used:
< 
< ::
< 
<   Config::SetDefault ("ns3::TcpL4Protocol::SocketType", TypeIdValue (TcpLedbat::GetTypeId ()));
< 
< To enable LEDBAT on a chosen TCP socket, the following configuration can be used:
< 
< ::
< 
<   Config::Set ("$ns3::NodeListPriv/NodeList/1/$ns3::TcpL4Protocol/SocketType", TypeIdValue (TcpLedbat::GetTypeId ()));
< 
< The following unit tests have been written to validate the implementation of LEDBAT:
< 
< * LEDBAT should operate same as NewReno during slow start
< * LEDBAT should operate same as NewReno if timestamps are disabled
< * Test to validate cwnd increment in LEDBAT
< 
< In comparison to RFC 6817, the scope and limitations of the current LEDBAT
< implementation are:
< 
< * It assumes that the clocks on the sender side and receiver side are synchronised
< * In line with Linux implementation, the one-way delay is calculated at the sender side by using the timestamps option in TCP header
< * Only the MIN function is used for noise filtering 
< 
< More information about LEDBAT is available in RFC 6817: https://tools.ietf.org/html/rfc6817
< 
< TCP-LP
< ^^^^^^
< 
< TCP-Low Priority (TCP-LP) is a delay based congestion control protocol in which the low
< priority data utilizes only the excess bandwidth available on an end-to-end path.
< TCP-LP uses one way delay measurements as an indicator of congestion as it does
< not influence cross-traffic in the reverse direction.
< 
< On receipt of an ACK:
< 
< .. math::
< 
<   One way delay = Receiver timestamp - Receiver timestamp echo reply
<   Smoothed one way delay = 7/8 * Old Smoothed one way delay + 1/8 * one way delay
<   If smoothed one way delay > owdMin + 15 * (owdMax - owdMin) / 100
<     if LP_WITHIN_INF
<       cwnd = 1
<     else
<       cwnd = cwnd / 2
<     Inference timer is set
< 
< where owdMin and owdMax are the minimum and maximum one way delays experienced
< throughout the connection, LP_WITHIN_INF indicates if TCP-LP is in inference
< phase or not
< 
< More information (paper): http://cs.northwestern.edu/~akuzma/rice/doc/TCP-LP.pdf
< 
< Data Center TCP (DCTCP)
< ^^^^^^^^^^^^^^^^^^^^^^^^
< 
< DCTCP is an enhancement to the TCP congestion control algorithm for data center
< networks and leverages Explicit Congestion Notification (ECN) to provide more fine-grained congestion
< feedback to the end hosts. DCTCP extends the Explicit Congestion Notification
< to estimate the fraction of bytes that encounter congestion, rather than simply
< detecting that the congestion has occurred. DCTCP then scales the congestion
< window based on this estimate. This approach achieves high burst tolerance, low
< latency, and high throughput with shallow-buffered switches.
---
> More information (paper):  http://www.hamilton.ie/net/htcp3.pdf
811,1073c670
< * Receiver functionality: If CE is set in IP header of incoming packet, send congestion notification to the sender by setting ECE in TCP header. This processing is different from standard ECN processing which sets ECE bit for every ACK until it observes CWR
< 
< * Sender functionality: The sender makes use of the modified receiver ECE semantics to maintain an average of fraction of packets marked (:math:`\alpha`) by using the exponential weighted moving average as shown below:
< 
< .. math::
< 
<                \alpha = (1 - g) x \alpha + g x F
< 
< where
< 
< * g is the estimation gain (between 0 and 1)
< * F is the fraction of packets marked in current RTT.
< 
< For windows in which at least one ACK was received with ECE set,
< the sender should respond by reducing the congestion
< window as follows, once for every window of data:
< 
< .. math::
< 
<                cwnd = cwnd * (1 - \alpha / 2)
< 
< Following the recommendation of RFC 8257, the default values of the parameters are:
< 
< .. math::
< 
<   g = 0.0625 (i.e., 1/16)
< 
<   initial alpha (\alpha) = 1
< 
< 
< 
< To enable DCTCP on all TCP sockets, the following configuration can be used:
< 
< ::
< 
<   Config::SetDefault ("ns3::TcpL4Protocol::SocketType", TypeIdValue (TcpDctcp::GetTypeId ()));
< 
< To enable DCTCP on a chosen TCP socket, the following configuration can be used:
< 
< ::
< 
<   Config::Set ("$ns3::NodeListPriv/NodeList/1/$ns3::TcpL4Protocol/SocketType", TypeIdValue (TcpDctcp::GetTypeId ()));
< 
< This will take effect only if socket has already instantiated.
< 
< The ECN is enabled automatically when DCTCP is used, even if the user has not explicitly enabled it.
< 
< DCTCP depends on a simple queue management algorithm in routers / switches to
< mark packets. The current implementation of DCTCP in ns-3 uses RED with a simple
< configuration to achieve the behavior of desired queue management algorithm.
< 
< To configure RED router for DCTCP:
< 
< ::
< 
<   Config::SetDefault ("ns3::RedQueueDisc::UseEcn", BooleanValue (true));
<   Config::SetDefault ("ns3::RedQueueDisc::QW", DoubleValue (1.0));
<   Config::SetDefault ("ns3::RedQueueDisc::MinTh", DoubleValue (16));
<   Config::SetDefault ("ns3::RedQueueDisc::MaxTh", DoubleValue (16));
< 
< 
< The following unit tests have been written to validate the implementation of DCTCP:
< 
< * ECT flags should be set for SYN, SYN+ACK, ACK and data packets for DCTCP traffic
< * ECT flags should not be set for SYN, SYN+ACK and pure ACK packets, but should be set on data packets for ECN enabled traditional TCP flows
< * ECE should be set only when CE flags are received at receiver and even if sender doesn’t send CWR, receiver should not send ECE if it doesn’t receive packets with CE flags
< * DCTCP follows NewReno behavior for slow start
< * Test to validate cwnd decrement in DCTCP
< 
< An example program based on an experimental topology found in the original
< DCTCP SIGCOMM paper is provided in ``examples/tcp/dctcp-example.cc``.
< This example uses a simple topology consisting of forty DCTCP senders
< and receivers and two ECN-enabled switches to examine throughput,
< fairness, and queue delay properties of the network.
< 
< This implementation was tested extensively against a version of DCTCP in
< the Linux kernel version 4.4 using the ns-3 direct code execution (DCE)
< environment. Some differences were noted:
< 
< * Linux maintains its congestion window in segments and not bytes, and
<   the arithmetic is not floating point, so some differences in the
<   evolution of congestion window have been observed.
< * Linux uses pacing, while ns-3 currently does not provide a dynamically
<   adjusting pacing implementation; segments are sent out at the line rate
<   unless the user has enabled pacing and set the maximum pacing rate to
<   less than the line rate.
< * Linux implements a state called 'Congestion Window Reduced' (CWR) 
<   immediately following a cwnd reduction, and performs proportional rate
<   reduction similar to how a fast retransmit event is handled.  During
<   CWR, no cwnd additive increases are performed.  This implementation does
<   not implement CWR and performs additive increase during the round trip
<   time that immediately follows a cwnd reduction.
< 
< More information about DCTCP is available in the RFC 8257:
< https://tools.ietf.org/html/rfc8257
< 
< Support for Explicit Congestion Notification (ECN)
< ++++++++++++++++++++++++++++++++++++++++++++++++++
< 
< ECN provides end-to-end notification of network congestion without dropping
< packets. It uses two bits in the IP header: ECN Capable Transport (ECT bit)
< and Congestion Experienced (CE bit), and two bits in the TCP header: Congestion
< Window Reduced (CWR) and ECN Echo (ECE).
< 
< More information is available in RFC 3168: https://tools.ietf.org/html/rfc3168
< 
< The following ECN states are declared in ``src/internet/model/tcp-socket-state.h``
< 
< ::
< 
<   typedef enum
<     {
<       ECN_DISABLED = 0, //!< ECN disabled traffic
<       ECN_IDLE,         //!< ECN is enabled but currently there is no action pertaining to ECE or CWR to be taken
<       ECN_CE_RCVD,      //!< Last packet received had CE bit set in IP header
<       ECN_SENDING_ECE,  //!< Receiver sends an ACK with ECE bit set in TCP header
<       ECN_ECE_RCVD,     //!< Last ACK received had ECE bit set in TCP header
<       ECN_CWR_SENT      //!< Sender has reduced the congestion window, and sent a packet with CWR bit set in TCP header. This is used for tracing.
<     } EcnStates_t;
< 
< Current implementation of ECN is based on RFC 3168 and is referred as Classic ECN.
< 
< The following enum represents the mode of ECN:
< 
< ::
< 
<   typedef enum
<     {
<       ClassicEcn,  //!< ECN functionality as described in RFC 3168.
<       DctcpEcn,    //!< ECN functionality as described in RFC 8257. Note: this mode is specific to DCTCP.
<     } EcnMode_t;
< 
< The following are some important ECN parameters:
< 
< ::
<   // ECN parameters
<   EcnMode_t              m_ecnMode {ClassicEcn}; //!< ECN mode
<   UseEcn_t               m_useEcn {Off};         //!< Socket ECN capability
< 
< Enabling ECN
< ^^^^^^^^^^^^
< 
< By default, support for ECN is disabled in TCP sockets. To enable, change
< the value of the attribute ``ns3::TcpSocketBase::UseEcn`` to ``On``.
< Following are supported values for the same, this functionality is aligned with
< Linux: https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt
< 
< ::
< 
<   typedef enum
<     {
<       Off        = 0,   //!< Disable
<       On         = 1,   //!< Enable
<       AcceptOnly = 2,   //!< Enable only when the peer endpoint is ECN capable
<     } UseEcn_t;
< 
< For example:
< 
< ::
< 
<   Config::SetDefault ("ns3::TcpSocketBase::UseEcn", StringValue ("On"))
< 
< ECN negotiation
< ^^^^^^^^^^^^^^^
< 
< ECN capability is negotiated during the three-way TCP handshake:
< 
< 1. Sender sends SYN + CWR + ECE
< 
< ::
< 
<     if (m_useEcn == UseEcn_t::On)
<       {
<         SendEmptyPacket (TcpHeader::SYN | TcpHeader::ECE | TcpHeader::CWR);
<       }
<     else
<       {
<         SendEmptyPacket (TcpHeader::SYN);
<       }
<     m_ecnState = ECN_DISABLED;
< 
< 2. Receiver sends SYN + ACK + ECE
< 
< ::
< 
<     if (m_useEcn != UseEcn_t::Off && (tcpHeader.GetFlags () & (TcpHeader::CWR | TcpHeader::ECE)) == (TcpHeader::CWR | TcpHeader::ECE))
<       {
<         SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK |TcpHeader::ECE);
<         m_ecnState = ECN_IDLE;
<       }
<     else
<       {
<         SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
<         m_ecnState = ECN_DISABLED;
<       }
< 
< 3. Sender sends ACK
< 
< ::
< 
<     if (m_useEcn != UseEcn_t::Off &&  (tcpHeader.GetFlags () & (TcpHeader::CWR | TcpHeader::ECE)) == (TcpHeader::ECE))
<       {
<         m_ecnState = ECN_IDLE;
<       }
<     else
<       {
<         m_ecnState = ECN_DISABLED;
<       }
< 
< Once the ECN-negotiation is successful, the sender sends data packets with ECT
< bits set in the IP header.
< 
< Note: As mentioned in `Section 6.1.1 of RFC 3168 <https://tools.ietf.org/html/rfc3168#section-6.1.1>`_, ECT bits should not be set
< during ECN negotiation. The ECN negotiation implemented in |ns3| follows
< this guideline.
< 
< ECN State Transitions
< ^^^^^^^^^^^^^^^^^^^^^
< 
< 1. Initially both sender and receiver have their m_ecnState set as ECN_DISABLED
< 2. Once the ECN negotiation is successful, their states are set to ECN_IDLE
< 3. The receiver's state changes to ECN_CE_RCVD when it receives a packet with
<    CE bit set. The state then moves to ECN_SENDING_ECE when the receiver sends
<    an ACK with ECE set. This state is retained until a CWR is received
<    , following which, the state changes to ECN_IDLE.
< 4. When the sender receives an ACK with ECE bit set from receiver, its state
<    is set as ECN_ECE_RCVD
< 5. The sender's state changes to ECN_CWR_SENT when it sends a packet with
<    CWR bit set. It remains in this state until an ACK with valid ECE is received
<    (i.e., ECE is received for a packet that belongs to a new window),
<    following which, its state changes to ECN_ECE_RCVD.
< 
< RFC 3168 compliance
< ^^^^^^^^^^^^^^^^^^^
< 
< Based on the suggestions provided in RFC 3168, the following behavior has
< been implemented:
< 
< 1. Pure ACK packets should not have the ECT bit set (`Section 6.1.4 <https://tools.ietf.org/html/rfc3168#section-6.1.4>`_).
< 2. In the current implementation, the sender only sends ECT(0) in the IP header.
< 3. The sender should should reduce the congestion window only once in each
<    window (`Section 6.1.2 <https://tools.ietf.org/html/rfc3168#section-6.1.2>`_).
< 4. The receiver should ignore the CE bits set in a packet arriving out of
<    window (`Section 6.1.5 <https://tools.ietf.org/html/rfc3168#section-6.1.5>`_).
< 5. The sender should ignore the ECE bits set in the packet arriving out of
<    window (`Section 6.1.2 <https://tools.ietf.org/html/rfc3168#section-6.1.2>`_).
< 
< Open issues
< ^^^^^^^^^^^
< 
< The following issues are yet to be addressed:
< 
< 1. Retransmitted packets should not have the CWR bit set (`Section 6.1.5 <https://tools.ietf.org/html/rfc3168#section-6.1.5>`_).
< 
< 2. Despite the congestion window size being 1 MSS, the sender should reduce its
<    congestion window by half when it receives a packet with the ECE bit set. The
<    sender must reset the retransmit timer on receiving the ECN-Echo packet when
<    the congestion window is one. The sending TCP will then be able to send a
<    new packet only when the retransmit timer expires (`Section 6.1.2 <https://tools.ietf.org/html/rfc3168#section-6.1.2>`_).
< 
< 3. Support for separately handling the enabling of ECN on the incoming and
<    outgoing TCP sessions (e.g. a TCP may perform ECN echoing but not set the
<    ECT codepoints on its outbound data segments).
---
> More information (Internet Draft):  https://tools.ietf.org/html/draft-leith-tcp-htcp-06
1078c675
< The following tests are found in the ``src/internet/test`` directory. In
---
> The following tests are found in the ``src/internet/test`` directory.  In
1081c678
< objects. For more information on how to write new tests, see the
---
> objects.  For more information on how to write new tests, see the
1091c688
< * **tcp-highspeed-test:** Unit tests on the HighSpeed congestion control
---
> * **tcp-highspeed-test:** Unit tests on the Highspeed congestion control
1100,1102d696
< * **tcp-ledbat-test:** Unit tests on the LEDBAT congestion control
< * **tcp-lp-test:** Unit tests on the TCP-LP congestion control
< * **tcp-dctcp-test:** Unit tests on the DCTCP congestion control
1105c699
< * **tcp-rto-test:** Unit test behavior after a RTO occurs
---
> * **tcp-rto-test:** Unit test behavior after a RTO timeout occurs
1111,1112d704
< * **tcp-close-test:** Unit test on the socket closing: both receiver and sender have to close their socket when all bytes are transferred
< * **tcp-ecn-test:** Unit tests on Explicit Congestion Notification
1115c707
< are located in a system test directory called ``src/test/ns3tcp``. Three
---
> are located in a system test directory called ``src/test/ns3tcp``.  Three
1123c715
< * **ns3-tcp-no-delay:** Check that ns-3 TCP Nagle's algorithm works correctly and that it can be disabled
---
> * **ns3-tcp-no-delay:** Check that ns-3 TCP Nagle"s algorithm works correctly and that it can be disabled
1131,1133d722
< TCP ECN operation is tested in the ARED and RED tests that are documented in the traffic-control
< module documentation.
< 
1152d740
<   virtual void CwndEvent (Ptr<TcpSocketState> tcb, const TcpSocketState::TcpCaEvent_t event);
1167,1315d754
< CwndEvent is used in case the algorithm needs the state of socket during different
< congestion window event.
< 
< TCP SACK and non-SACK
< +++++++++++++++++++++
< To avoid code duplication and the effort of maintaining two different versions
< of the TCP core, namely RFC 6675 (TCP-SACK) and RFC 5681 (TCP congestion control),
< we have merged RFC 6675 in the current code base. If the receiver supports the
< option, the sender bases its retransmissions over the received SACK information.
< However, in the absence of that option, the best it can do is to follow the RFC
< 5681 specification (on Fast Retransmit/Recovery) and employing NewReno
< modifications in case of partial ACKs.
< 
< A similar concept is used in Linux with the function tcp_add_reno_sack.
< Our implementation resides in the TcpTxBuffer class that implements a scoreboard
< through two different lists of segments. TcpSocketBase actively uses the API
< provided by TcpTxBuffer to query the scoreboard; please refer to the Doxygen
< documentation (and to in-code comments) if you want to learn more about this
< implementation.
< 
< For an academic peer-reviewed paper on the SACK implementation in ns-3,
< please refer to https://dl.acm.org/citation.cfm?id=3067666.
< 
< Loss Recovery Algorithms
< ++++++++++++++++++++++++
< The following loss recovery algorithms are supported in ns-3 TCP:
< 
< Classic Recovery
< ^^^^^^^^^^^^^^^^
< Classic Recovery refers to the combination of NewReno algorithm described in
< RFC 6582 along with SACK based loss recovery algorithm mentioned in RFC 6675.
< SACK based loss recovery is used when sender and receiver support SACK options.
< In the case when SACK options are disabled, the NewReno modification handles
< the recovery.
< 
< At the start of recovery phase the congestion window is reduced diffently for
< NewReno and SACK based recovery. For NewReno the reduction is done as given below:
< 
< .. math::  cWnd = ssThresh
< 
< For SACK based recovery, this is done as follows:
< 
< .. math::   cWnd = ssThresh + (dupAckCount * segmentSize)
< 
< While in the recovery phase, the congestion window is inflated by segmentSize
< on arrival of every ACK when NewReno is used. The congestion window is kept
< same when SACK based loss recovery is used.
< 
< Proportional Rate Reduction
< ^^^^^^^^^^^^^^^^^^^^^^^^^^^
< Proportional Rate Reduction (PRR) is a loss recovery algorithm described in
< RFC 6937 and currently used in Linux. The design of PRR helps in avoiding
< excess window adjustments and aims to keep the congestion window as close as
< possible to ssThresh.
< 
< PRR updates the congestion window by comparing the values of bytesInFlight and
< ssThresh. If the value of bytesInFlight is greater than ssThresh, congestion window
< is updated as shown below:
< 
< .. math::  sndcnt = CEIL(prrDelivered * ssThresh / RecoverFS) - prrOut
< .. math::  cWnd = pipe + sndcnt
< 
< where ``RecoverFS`` is the value of bytesInFlight at the start of recovery phase,
< ``prrDelivered`` is the total bytes delivered during recovery phase,
< ``prrOut`` is the total bytes sent during recovery phase and
< ``sndcnt`` represents the number of bytes to be sent in response to each ACK.
< 
< Otherwise, the congestion window is updated by either using Conservative Reduction
< Bound (CRB) or Slow Start Reduction Bound (SSRB) with SSRB being the default
< Reduction Bound. Each Reduction Bound calculates a maximum data sending limit.
< For CRB, the limit is calculated as shown below:
< 
< .. math::  limit = prrDelivered - prr out
< 
< For SSRB, it is calculated as:
< 
< .. math::  limit = MAX(prrDelivered - prrOut, DeliveredData) + MSS
< 
< where ``DeliveredData`` represets the total number of bytes delivered to the
< receiver as indicated by the current ACK and ``MSS`` is the maximum segment size.
< 
< After limit calculation, the cWnd is updated as given below:
< 
< .. math::  sndcnt = MIN (ssThresh - pipe, limit)
< .. math::  cWnd = pipe + sndcnt
< 
< More information (paper): https://dl.acm.org/citation.cfm?id=2068832
< 
< More information (RFC): https://tools.ietf.org/html/rfc6937
< 
< Adding a new loss recovery algorithm in ns-3
< ++++++++++++++++++++++++++++++++++++++++++++
< 
< Writing (or porting) a loss recovery algorithms from scratch (or from
< other systems) is a process completely separated from the internals of
< TcpSocketBase.
< 
< All operations that are delegated to a loss recovery are contained in
< the class TcpRecoveryOps and are given below:
< 
< .. code-block:: c++
< 
<   virtual std::string GetName () const;
<   virtual void EnterRecovery (Ptr<const TcpSocketState> tcb, uint32_t unAckDataCount,
<                               bool isSackEnabled, uint32_t dupAckCount,
<                               uint32_t bytesInFlight, uint32_t lastDeliveredBytes);
<   virtual void DoRecovery (Ptr<const TcpSocketState> tcb, uint32_t unAckDataCount,
<                            bool isSackEnabled, uint32_t dupAckCount,
<                            uint32_t bytesInFlight, uint32_t lastDeliveredBytes);
<   virtual void ExitRecovery (Ptr<TcpSocketState> tcb, uint32_t bytesInFlight);
<   virtual void UpdateBytesSent (uint32_t bytesSent);
<   virtual Ptr<TcpRecoveryOps> Fork ();
< 
< EnterRecovery is called when packet loss is detected and recovery is triggered.
< While in recovery phase, each time when an ACK arrives, DoRecovery is called which
< performs the necessary congestion window changes as per the recovery algorithm.
< ExitRecovery is called just prior to exiting recovery phase in order to perform the
< required congestion window ajustments. UpdateBytesSent is used to keep track of
< bytes sent and is called whenever a data packet is sent during recovery phase.
< 
< Delivery Rate Estimation
< ++++++++++++++++++++++++
< Current TCP implementation measures the approximate value of the delivery rate of
< inflight data based on Delivery Rate Estimation.
< 
< As high level idea, keep in mind that the algorithm keeps track of 2 variables:
< 
< 1. `delivered`: Total amount of data delivered so far.
< 
< 2. `deliveredStamp`: Last time `delivered` was updated.
< 
< When a packet is transmitted, the value of `delivered (d0)` and `deliveredStamp (t0)`
< is stored in its respective TcpTxItem.
< 
< When an acknowledgement comes for this packet, the value of `delivered` and `deliveredStamp`
< is updated to `d1` and `t1` in the same TcpTxItem.
< 
< After processing the acknowledgement, the rate sample is calculated and then passed
< to a congestion avoidance algorithm:
< 
< .. math:: delivery_rate = (d1 - d0)/(t1 - t0)
< 
< 
< The implementation to estimate delivery rate is a joint work between TcpTxBuffer and TcpRateOps.
< For more information, please take a look at their Doxygen documentation.
< 
< The implementation follows the Internet draft (Delivery Rate Estimation):
< https://tools.ietf.org/html/draft-cheng-iccrg-delivery-rate-estimation-00
< 
1318a758
> * SACK is not supported
1319a760
> * Fast retransmit / fast recovery are bound with TcpSocketBase, thereby preventing easy simulation of TCP Tahoe
1329c770
< case that reproduces the `Bug #1571 <https://www.nsnam.org/bugzilla/show_bug.cgi?id=1571>`_.
---
> case that reproduces a bug (#1571 in the project bug tracker).
1331,1332c772,773
< The bug concerns the zero window situation, which happens when the receiver
< cannot handle more data. In this case, it advertises a zero window, which causes
---
> The bug concerns the zero window situation, which happens when the receiver can
> not handle more data. In this case, it advertises a zero window, which causes
1348c789
<    be called by the main TcpGeneralTest class when events occur. For example,
---
>    be called by the main TcpGeneralTest class when events occour. For example,
1355c796
< We describe the writing of two test cases, covering both situations: the
---
> We describe the writing of two test case, covering both situations: the
1400c841
< the method ConfigureEnvironment:
---
> ehe method ConfigureEnvironment:
1419c860
< are meant to be called inside ConfigureProperties (). Please see the Doxygen
---
> are meant to be called inside ConfigureProperties (). Please see the doxygen
1479c920
<    By design, we choose to maintain a close relationship between TcpSocketBase
---
>    By design, we choose to mantain a close relationship between TcpSocketBase
1564c1005
< Now we need to test for the persistent timer, which should be started by
---
> Now we need to test for the persistent timer, which sould be started by
1621c1062
< Since the persist timeout is initialized at 6 seconds (exercise left for the
---
> Since the persist timeout is initialized at 6 seconds (excercise left for the
1752c1193
<    test; hopefully the first situation). Correcting bugs is an iterative
---
>    test; hopefull the first situation). Correcting bugs is an iterative
1764c1205
< extremely accurate results. NSC supports four real world stacks: FreeBSD,
---
> extremely accurate results.  NSC supports four real world stacks: FreeBSD,
1771c1212
< was added to |ns3| in September 2008 (ns-3.2 release). This section
---
> was added to |ns3| in September 2008 (ns-3.2 release).  This section 
1774,1778c1215,1217
< NSC has been obsoleted by the Linux kernel support within 
< `Direct Code Execution (DCE) <http://www.nsnam.org/docs/dce/manual/singlehtml/index.html>`__. However, NSC is still available through the bake build
< system. NSC supports Linux kernels 2.6.18 and 2.6.26, and an experimental
< version of 2.6.29 exists on ns-3's code server
< (http://code.nsnam.org/fw/nsc-linux-2.6.29/), but newer
---
> To some extent, NSC has been superseded by the Linux kernel support within 
> `Direct Code Execution (DCE) <http://www.nsnam.org/docs/dce/manual/singlehtml/index.html>`__.  However, NSC is still available through the bake build
> system.  NSC supports Linux kernels 2.6.18 and 2.6.26, but newer
1785c1224
< Linux i386 and Linux x86-64. NSC does not support powerpc. Use on
---
> Linux i386 and Linux x86-64.  NSC does not support powerpc.  Use on
1790,1792d1228
< NSC requires use of gcc-4.9 or gcc-5 series, and will not build on 
< newer systems lacking the older compilers.
< 
1796c1232
< NSC must either be downloaded separately from
---
> As of ns-3.17 or later, NSC must either be downloaded separately from
1799,1808c1235
< |ns3|.
< 
< For ns-3.17 through ns-3.28 releases, when using bake, one obtains NSC implicitly as part of an "allinone" configuration, such as:
< 
< .. sourcecode:: bash
< 
<   $ cd bake
<   $ python bake.py configure -e ns-allinone-3.27
<   $ python bake.py download
<   $ python bake.py build
---
> |ns3|.  
1810,1812c1237,1238
< For ns-3.29 and later versions, including the 'ns-3-allinone' development
< version, one must explicitly add NSC ('nsc-0.5.3') to the bake configuration, 
< such as:
---
> For ns-3.17 or later releases, when using bake, one must configure NSC as 
> part of an "allinone" configuration, such as:
1817c1243
<   $ python bake.py configure -e ns-allinone-3.29 -e nsc-0.5.3
---
>   $ python bake.py configure -e ns-allinone-3.19
1882c1308
< with waf as without it. Once |ns3| is built, try running the following
---
> with waf as without it.  Once |ns3| is built, try running the following 
1901c1327
< There are a few example files. Try:
---
> There are a few example files.  Try:
1924c1350
< The key line is the ``SetNscStack``. This tells the InternetStack
---
> The key line is the ``SetNscStack``.  This tells the InternetStack
1926c1352
< to the remaining nodes. It is important that this function be called
---
> to the remaining nodes.  It is important that this function be called
1966c1392
< Also note that default values for TCP attributes in |ns3| TCP may differ from the NSC TCP implementation. Specifically in |ns3|:
---
> Also note that default values for TCP attributes in |ns3| TCP may differ from the nsc TCP implementation.  Specifically in |ns3|:
1969c1395
<   2) TCP Delayed ACK count is 2
---
>   2) TCP Delayed Ack count is 2 
1971c1397
< Therefore when making comparisons between results obtained using NSC and |ns3| TCP, care must be taken to ensure these values are set appropriately. See /examples/tcp/tcp-nsc-comparison.cc for an example.
---
> Therefore when making comparisons between results obtained using nsc and |ns3| TCP, care must be taken to ensure these values are set appropriately.  See /examples/tcp/tcp-nsc-comparision.cc for an example.
1982c1408
<   stack (think of this as the 'network driver interface'). There are also
---
>   stack (think of this as the 'network driver interface'. There are also
1988c1414
<   back to the receivers NSC instance via INetStack->if_receive()).
---
>   back to the receivers NSC instance via INetStack->if_receive() ).
1992c1418
< * **IInterruptCallback** This contains the wakeup() callback, which is called by
---
> * **IInterruptCallback** This contains the wakeup callback, which is called by
2007c1433
< * :cpp:class:`ns3::NscTcpL4Protocol`: a subclass of Ipv4L4Protocol (and two NSC
---
> * :cpp:class:`ns3::NscTcpL4Protocol`:  a subclass of Ipv4L4Protocol (and two nsc
2010c1436
< * :cpp:class:`ns3::NscTcpSocketFactoryImpl`: a factory to create new NSC
---
> * :cpp:class:`ns3::NscTcpSocketFactoryImpl`:  a factory to create new NSC
2014c1440
< Initialization, it loads an NSC network stack to use (via dlopen()). Each
---
> Initialization, it loads an nsc network stack to use (via dlopen()). Each
2017c1443
< via the internet stack helper). The NSC stack is then set up accordingly (timers
---
> via the internet stack helper). The nsc stack is then set up accordingly (timers
2019,2021c1445,1447
< (must be a complete TCP/IP packet) to the NSC stack for further processing. To
< be able to send packets, this class implements the NSC send_callback() method.
< This method is called by NSC whenever the NSC stack wishes to send a packet out
---
> (must be a complete tcp/ip packet) to the nsc stack for further processing.  To
> be able to send packets, this class implements the nsc send_callback method.
> This method is called by nsc whenever the nsc stack wishes to send a packet out
2024,2025c1450,1451
< a Ptr<Packet> usable by |ns3|. In order to avoid various IPv4 header issues,
< the NSC IP header is not included. Instead, the TCP header and the actual
---
> a Ptr<Packet> usable by |ns3|. In order to avoid various ipv4 header issues,
> the nsc ip header is not included. Instead, the tcp header and the actual
2030,2031c1456,1457
< This class calls ``ns3::NscTcpSocketImpl`` both from the NSC wakeup() callback
< and from the receive path (to ensure that possibly queued data is scheduled for
---
> This class calls ``ns3::NscTcpSocketImpl`` both from the nsc wakeup() callback
> and from the Receive path (to ensure that possibly queued data is scheduled for
2034,2040c1460,1466
< ``src/internet/model/nsc-tcp-socket-impl`` implements the NSC socket interface.
< Each instance has its own m_nscTcpSocket. Data that is sent will be handed to
< the NSC stack via m_nscTcpSocket->send_data() (and not to NscTcpL4Protocol, this
< is the major difference compared to |ns3| TCP). The class also queues up data
< that is sent before the underlying descriptor has entered an ESTABLISHED state.
< This class is called from the NscTcpL4Protocol class, when the NscTcpL4Protocol
< wakeup() callback is invoked by NSC. NscTcpSocketImpl then checks the current
---
> ``src/internet/model/nsc-tcp-socket-impl`` implements the nsc socket interface.
> Each instance has its own nscTcpSocket. Data that is Send() will be handed to
> the nsc stack via m_nscTcpSocket->send_data(). (and not to nsc-tcp-l4, this is
> the major difference compared to |ns3| TCP). The class also queues up data that
> is Send() before the underlying descriptor has entered an ESTABLISHED state.
> This class is called from the nsc-tcp-l4 class, when the nsc-tcp-l4 wakeup()
> callback is invoked by nsc. nsc-tcp-socket-impl then checks the current
2042c1468
< callbacks as needed, e.g. a LISTEN socket will schedule accept() to see if a new
---
> callbacks as needed, e.g. a LISTEN socket will schedule Accept to see if a new
2044c1470
< for writing, schedule a read() callback, etc.
---
> for writing, schedule a read callback, etc.
2046,2048c1472,1474
< Note that ``ns3::NscTcpSocketImpl`` does not interact with NSC TCP directly:
< instead, data is redirected to NSC. NSC TCP calls the NSC TCP sockets of a node
< when its wakeup() callback is invoked by NSC.
---
> Note that ``ns3::NscTcpSocketImpl`` does not interact with nsc-tcp directly:
> instead, data is redirected to nsc. nsc-tcp calls the nsc-tcp-sockets of a node
> when its wakeup callback is invoked by nsc. 
