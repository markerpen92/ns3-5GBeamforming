diff ../../NS3-WiGig/src/internet/model/arp-cache.cc ../../ns-3-dev/src/internet/model/arp-cache.cc
321,322c321
<   CacheI it = m_arpCache.find (to);
<   if (it != m_arpCache.end ())
---
>   if (m_arpCache.find (to) != m_arpCache.end ()) 
324c323,324
<       return it->second;
---
>       ArpCache::Entry *entry = m_arpCache[to];
>       return entry;
439,451d438
< 
< void
< ArpCache::Entry::MarkWaitReply (Ptr<Packet> waiting)
< {
<   NS_LOG_FUNCTION (this << waiting);
<   NS_ASSERT (m_state == ALIVE || m_state == DEAD);
<   NS_ASSERT (m_pending.empty ());
<   m_state = WAIT_REPLY;
<   m_pending.push_back (std::make_pair (waiting, Ipv4Header ()));
<   UpdateSeen ();
<   m_arp->StartWaitReplyTimer ();
< }
< 
473c460
< ArpCache::Entry::SetMacAddress (Address macAddress)
---
> ArpCache::Entry::SetMacAddresss (Address macAddress)
diff ../../NS3-WiGig/src/internet/model/arp-cache.h ../../ns-3-dev/src/internet/model/arp-cache.h
159,160d158
<    * \param to the destination address of the ARP entry.
<    * \returns A pointer to a new ARP Entry.
207,210d204
<     void MarkWaitReply (Ptr<Packet> waiting);
<     /**
<      * \param waiting
<      */
250c244
<     void SetMacAddress (Address macAddress);
---
>     void SetMacAddresss (Address macAddress);
diff ../../NS3-WiGig/src/internet/model/arp-header.cc ../../ns-3-dev/src/internet/model/arp-header.cc
71c71
< ArpHeader::GetSourceHardwareAddress (void) const
---
> ArpHeader::GetSourceHardwareAddress (void)
77c77
< ArpHeader::GetDestinationHardwareAddress (void) const
---
> ArpHeader::GetDestinationHardwareAddress (void)
83c83
< ArpHeader::GetSourceIpv4Address (void) const
---
> ArpHeader::GetSourceIpv4Address (void)
89c89
< ArpHeader::GetDestinationIpv4Address (void) const
---
> ArpHeader::GetDestinationIpv4Address (void)
139c139
<   NS_ASSERT ((m_macSource.GetLength () == 6) || (m_macSource.GetLength () == 8) || (m_macSource.GetLength () == 1));
---
>   NS_ASSERT((m_macSource.GetLength () == 6) || (m_macSource.GetLength () == 8));
diff ../../NS3-WiGig/src/internet/model/arp-header.h ../../ns-3-dev/src/internet/model/arp-header.h
76c76
<   Address GetSourceHardwareAddress (void) const;
---
>   Address GetSourceHardwareAddress (void);
82c82
<   Address GetDestinationHardwareAddress (void) const;
---
>   Address GetDestinationHardwareAddress (void);
88c88
<   Ipv4Address GetSourceIpv4Address (void) const;
---
>   Ipv4Address GetSourceIpv4Address (void);
94c94
<   Ipv4Address GetDestinationIpv4Address (void) const;
---
>   Ipv4Address GetDestinationIpv4Address (void);
diff ../../NS3-WiGig/src/internet/model/arp-l3-protocol.cc ../../ns-3-dev/src/internet/model/arp-l3-protocol.cc
33d32
< #include "arp-queue-disc-item.h"
35d33
< #include "ns3/traffic-control-layer.h"
76d73
<   : m_tc (0)
101,107d97
< void
< ArpL3Protocol::SetTrafficControl (Ptr<TrafficControlLayer> tc)
< {
<   NS_LOG_FUNCTION (this << tc);
<   m_tc = tc;
< }
< 
109c99
<  * This method is called by AggregateObject and completes the aggregation
---
>  * This method is called by AddAgregate and completes the aggregation
140d129
<   m_tc = 0;
231c220
<                arp.GetDestinationIpv4Address () == cache->GetInterface ()->GetAddress (i).GetLocal () &&
---
>                arp.GetDestinationIpv4Address ().IsEqual (cache->GetInterface ()->GetAddress (i).GetLocal ()) &&
372a362,363
>   Ipv4Header header;
>   header.SetDestination (to);
379,380c370,371
<   NS_ASSERT (m_tc != 0);
<   m_tc->Send (device, Create<ArpQueueDiscItem> (packet, device->GetBroadcast (), PROT_NUMBER, arp));
---
>   packet->AddHeader (arp);
>   cache->GetDevice ()->Send (packet, device->GetBroadcast (), PROT_NUMBER);
394,395c385,386
<   NS_ASSERT (m_tc != 0);
<   m_tc->Send (cache->GetDevice (), Create<ArpQueueDiscItem> (packet, toMac, PROT_NUMBER, arp));
---
>   packet->AddHeader (arp);
>   cache->GetDevice ()->Send (packet, toMac, PROT_NUMBER);
diff ../../NS3-WiGig/src/internet/model/arp-l3-protocol.h ../../ns-3-dev/src/internet/model/arp-l3-protocol.h
38d37
< class TrafficControlLayer;
73,78d71
<    * \brief Set the TrafficControlLayer.
<    * \param tc TrafficControlLayer object
<    */
<   void SetTrafficControl (Ptr<TrafficControlLayer> tc);
< 
<   /**
173d165
<   Ptr<TrafficControlLayer> m_tc; //!< The associated TrafficControlLayer
Only in ../../NS3-WiGig/src/internet/model: arp-queue-disc-item.cc
Only in ../../NS3-WiGig/src/internet/model: arp-queue-disc-item.h
diff ../../NS3-WiGig/src/internet/model/global-route-manager.h ../../ns-3-dev/src/internet/model/global-route-manager.h
45d44
<  * @returns A new new RouterId.
diff ../../NS3-WiGig/src/internet/model/global-route-manager-impl.cc ../../ns-3-dev/src/internet/model/global-route-manager-impl.cc
154c154
<       // pop out children one by one. Some children may disappear 
---
>       // pop out children one by one. Some children may disapper 
316c316
<   //NS_ASSERT_MSG (m_ecmpRootExits.size () <= 1, "Assumed there is at most one exit from the root to this vertex");
---
>   NS_ASSERT_MSG (m_ecmpRootExits.size () <= 1, "Assumed there is at most one exit from the root to this vertex");
diff ../../NS3-WiGig/src/internet/model/global-route-manager-impl.h ../../ns-3-dev/src/internet/model/global-route-manager-impl.h
867c867
<    * \brief Search for a link between two vertices.
---
>    * \brief Search for a link between two vertexes.
diff ../../NS3-WiGig/src/internet/model/global-router-interface.cc ../../ns-3-dev/src/internet/model/global-router-interface.cc
21,22d20
< #include <iostream>
< 
687c685
<       // We have a net device that we need to check out.  If it supports 
---
>       // We have a net device that we need to check out.  If it suports 
843,844c841
<       Ipv4Address desigRtr;
<       desigRtr = FindDesignatedRouterForLink (nd);
---
>       Ipv4Address desigRtr = FindDesignatedRouterForLink (nd);
854c851
<           NS_ABORT_MSG_UNLESS (networkHere == networkThere,
---
>           NS_ABORT_MSG_UNLESS (networkHere == networkThere, 
857c854
<       if (desigRtr == addrLocal)
---
>       if (desigRtr == addrLocal) 
915c912
<   Ipv4Mask maskLocal = ipv4Local->GetAddress (interfaceLocal, 0).GetMask ();
---
>   Ipv4Mask maskLocal = ipv4Local->GetAddress (interfaceLocal, 0).GetMask ();;
1206c1203
<       std::size_t nDevices = ch->GetNDevices ();
---
>       uint32_t nDevices = ch->GetNDevices ();
1275c1272
<   for (std::size_t i = 0; i < ch->GetNDevices (); i++)
---
>   for (uint32_t i = 0; i < ch->GetNDevices (); i++)
diff ../../NS3-WiGig/src/internet/model/global-router-interface.h ../../ns-3-dev/src/internet/model/global-router-interface.h
54c54
<   friend class GlobalRoutingLSA; //!< Friend class.
---
>   friend class GlobalRoutingLSA;
387d386
<  * @returns The LS Type.
392d390
<  * @param typ the LS Type.
438d435
<  * @param mask the Network Mask field.
845d841
<    * \returns the NetDeviceContainer.
900d895
<  * @param sr object to copy from.
906,907d900
<  * @param sr object to copy from.
<  * @returns The object copied.
diff ../../NS3-WiGig/src/internet/model/global-routing.h ../../ns-3-dev/src/internet/model/global-routing.h
46c46
<  * - Manually call the sequence of GlobalRouteManager methods to delete global
---
>  * - Manually call the sequence of GlobalRouteManager methods to delte global
diff ../../NS3-WiGig/src/internet/model/icmpv4.h ../../ns-3-dev/src/internet/model/icmpv4.h
43,51c43,47
< 
<   /**
<    * ICMP type code.
<    */
<   enum Type_e {
<     ICMPV4_ECHO_REPLY = 0,
<     ICMPV4_DEST_UNREACH = 3,
<     ICMPV4_ECHO = 8,
<     ICMPV4_TIME_EXCEEDED = 11
---
>   enum {
>     ECHO_REPLY = 0,
>     DEST_UNREACH = 3,
>     ECHO = 8,
>     TIME_EXCEEDED = 11
175,184c171,177
<   /**
<    * ICMP error code : Destination Unreachable
<    */
<   enum ErrorDestinationUnreachable_e {
<     ICMPV4_NET_UNREACHABLE = 0,
<     ICMPV4_HOST_UNREACHABLE = 1,
<     ICMPV4_PROTOCOL_UNREACHABLE = 2,
<     ICMPV4_PORT_UNREACHABLE = 3,
<     ICMPV4_FRAG_NEEDED = 4,
<     ICMPV4_SOURCE_ROUTE_FAILED = 5
---
>   enum {
>     NET_UNREACHABLE = 0,
>     HOST_UNREACHABLE = 1,
>     PROTOCOL_UNREACHABLE = 2,
>     PORT_UNREACHABLE = 3,
>     FRAG_NEEDED = 4,
>     SOURCE_ROUTE_FAILED = 5
249,255c242,244
<   /**
<    * \brief ICMP error code : Time Exceeded
<    */
<   enum ErrorTimeExceeded_e
<   {
<     ICMPV4_TIME_TO_LIVE = 0,
<     ICMPV4_FRAGMENT_REASSEMBLY = 1
---
>   enum {
>     TIME_TO_LIVE = 0,
>     FRAGMENT_REASSEMBLY = 1
diff ../../NS3-WiGig/src/internet/model/icmpv4-l4-protocol.cc ../../ns-3-dev/src/internet/model/icmpv4-l4-protocol.cc
72c72
<  * This method is called by AggregateObject and completes the aggregation
---
>  * This method is called by AddAgregate and completes the aggregation
158c158
<   SendDestUnreach (header, orgData, Icmpv4DestinationUnreachable::ICMPV4_FRAG_NEEDED, nextHopMtu);
---
>   SendDestUnreach (header, orgData, Icmpv4DestinationUnreachable::FRAG_NEEDED, nextHopMtu);
165c165
<   SendDestUnreach (header, orgData, Icmpv4DestinationUnreachable::ICMPV4_PORT_UNREACHABLE, 0);
---
>   SendDestUnreach (header, orgData, Icmpv4DestinationUnreachable::PORT_UNREACHABLE, 0);
178c178
<   SendMessage (p, header.GetSource (), Icmpv4Header::ICMPV4_DEST_UNREACH, code);
---
>   SendMessage (p, header.GetSource (), Icmpv4Header::DEST_UNREACH, code);
182c182
< Icmpv4L4Protocol::SendTimeExceededTtl (Ipv4Header header, Ptr<const Packet> orgData, bool isFragment)
---
> Icmpv4L4Protocol::SendTimeExceededTtl (Ipv4Header header, Ptr<const Packet> orgData)
190,197c190
<   if (!isFragment)
<     {
<       SendMessage (p, header.GetSource (), Icmpv4Header::ICMPV4_TIME_EXCEEDED, Icmpv4TimeExceeded::ICMPV4_TIME_TO_LIVE);
<     }
<   else
<     {
<       SendMessage (p, header.GetSource (), Icmpv4Header::ICMPV4_TIME_EXCEEDED, Icmpv4TimeExceeded::ICMPV4_FRAGMENT_REASSEMBLY);
<     }
---
>   SendMessage (p, header.GetSource (), Icmpv4Header::TIME_EXCEEDED, Icmpv4TimeExceeded::TIME_TO_LIVE);
212c205
<   SendMessage (reply, destination, source, Icmpv4Header::ICMPV4_ECHO_REPLY, 0, 0);
---
>   SendMessage (reply, destination, source, Icmpv4Header::ECHO_REPLY, 0, 0);
271c264
<     case Icmpv4Header::ICMPV4_ECHO:
---
>     case Icmpv4Header::ECHO:
274c267
<     case Icmpv4Header::ICMPV4_DEST_UNREACH:
---
>     case Icmpv4Header::DEST_UNREACH:
277c270
<     case Icmpv4Header::ICMPV4_TIME_EXCEEDED:
---
>     case Icmpv4Header::TIME_EXCEEDED:
diff ../../NS3-WiGig/src/internet/model/icmpv4-l4-protocol.h ../../ns-3-dev/src/internet/model/icmpv4-l4-protocol.h
110d109
<    * \param isFragment true if the opcode must be FRAGMENT_REASSEMBLY
112c111
<   void SendTimeExceededTtl (Ipv4Header header, Ptr<const Packet> orgData, bool isFragment);
---
>   void SendTimeExceededTtl (Ipv4Header header, Ptr<const Packet> orgData);
diff ../../NS3-WiGig/src/internet/model/icmpv6-header.h ../../ns-3-dev/src/internet/model/icmpv6-header.h
176c176
<    * \brief Print information.
---
>    * \brief Print informations.
288c288
<    * \brief Print information.
---
>    * \brief Print informations.
385c385
<    * \brief Print information.
---
>    * \brief Print informations.
513c513
<    * \brief Print information.
---
>    * \brief Print informations.
679c679
<    * \brief Print information.
---
>    * \brief Print informations.
800c800
<    * \brief Print information.
---
>    * \brief Print informations.
886c886
<    * \brief Print information.
---
>    * \brief Print informations.
1000c1000
<    * \brief Print information.
---
>    * \brief Print informations.
1079c1079
<    * \brief Print information.
---
>    * \brief Print informations.
1165c1165
<    * \brief Print information.
---
>    * \brief Print informations.
1245c1245
<    * \brief Print information.
---
>    * \brief Print informations.
1332c1332
<    * \brief Print information.
---
>    * \brief Print informations.
1430c1430
<    * \brief Print information.
---
>    * \brief Print informations.
1576c1576
<    * \brief Print information.
---
>    * \brief Print informations.
1688c1688
<    * \brief Print information.
---
>    * \brief Print informations.
1762c1762
<    * \brief Print information.
---
>    * \brief Print informations.
diff ../../NS3-WiGig/src/internet/model/icmpv6-l4-protocol.cc ../../ns-3-dev/src/internet/model/icmpv6-l4-protocol.cc
33d32
< #include "ns3/integer.h"
34a34
> #include "ipv6-raw-socket-factory-impl.h"
47,61c47,65
< //const uint8_t Icmpv6L4Protocol::MAX_INITIAL_RTR_ADVERT_INTERVAL = 16; // max initial RA initial interval.
< //const uint8_t Icmpv6L4Protocol::MAX_INITIAL_RTR_ADVERTISEMENTS = 3;   // max initial RA transmission.
< //const uint8_t Icmpv6L4Protocol::MAX_FINAL_RTR_ADVERTISEMENTS = 3;     // max final RA transmission.
< //const uint8_t Icmpv6L4Protocol::MIN_DELAY_BETWEEN_RAS = 3;            // min delay between RA.
< //const uint32_t Icmpv6L4Protocol::MAX_RA_DELAY_TIME = 500;             // millisecond - max delay between RA.
< 
< //const uint8_t Icmpv6L4Protocol::MAX_RTR_SOLICITATION_DELAY = 1;       // max RS delay.
< //const uint8_t Icmpv6L4Protocol::RTR_SOLICITATION_INTERVAL = 4;        // RS interval.
< //const uint8_t Icmpv6L4Protocol::MAX_RTR_SOLICITATIONS = 3;            // max RS transmission.
< 
< //const uint8_t Icmpv6L4Protocol::MAX_ANYCAST_DELAY_TIME = 1;           // max anycast delay.
< //const uint8_t Icmpv6L4Protocol::MAX_NEIGHBOR_ADVERTISEMENT = 3;       // max NA transmission.
< 
< //const double Icmpv6L4Protocol::MIN_RANDOM_FACTOR = 0.5;               // min random factor.
< //const double Icmpv6L4Protocol::MAX_RANDOM_FACTOR = 1.5;               // max random factor.
---
> const uint8_t Icmpv6L4Protocol::MAX_INITIAL_RTR_ADVERT_INTERVAL = 16;
> const uint8_t Icmpv6L4Protocol::MAX_INITIAL_RTR_ADVERTISEMENTS = 3;
> const uint8_t Icmpv6L4Protocol::MAX_FINAL_RTR_ADVERTISEMENTS = 3;
> const uint8_t Icmpv6L4Protocol::MIN_DELAY_BETWEEN_RAS = 3;
> const uint32_t Icmpv6L4Protocol::MAX_RA_DELAY_TIME = 500; /* millisecond */
> 
> const uint8_t Icmpv6L4Protocol::MAX_RTR_SOLICITATION_DELAY = 1;
> const uint8_t Icmpv6L4Protocol::RTR_SOLICITATION_INTERVAL = 4;
> const uint8_t Icmpv6L4Protocol::MAX_RTR_SOLICITATIONS = 3;
> 
> const uint8_t Icmpv6L4Protocol::MAX_MULTICAST_SOLICIT = 3;
> const uint8_t Icmpv6L4Protocol::MAX_UNICAST_SOLICIT = 3;
> const uint8_t Icmpv6L4Protocol::MAX_ANYCAST_DELAY_TIME = 1;
> const uint8_t Icmpv6L4Protocol::MAX_NEIGHBOR_ADVERTISEMENT = 3;
> const uint32_t Icmpv6L4Protocol::REACHABLE_TIME = 30000;
> const uint32_t Icmpv6L4Protocol::RETRANS_TIMER = 1000;
> const uint8_t Icmpv6L4Protocol::DELAY_FIRST_PROBE_TIME = 5;
> const double Icmpv6L4Protocol::MIN_RANDOM_FACTOR = 0.5;
> const double Icmpv6L4Protocol::MAX_RANDOM_FACTOR = 1.5;
73c77
<     .AddAttribute ("SolicitationJitter", "The jitter in ms a node is allowed to wait before sending any solicitation. Some jitter aims to prevent collisions. By default, the model will wait for a duration in ms defined by a uniform random-variable between 0 and SolicitationJitter",
---
>     .AddAttribute ("SolicitationJitter", "The jitter in ms a node is allowed to wait before sending any solicitation . Some jitter aims to prevent collisions. By default, the model will wait for a duration in ms defined by a uniform random-variable between 0 and SolicitationJitter",
77,99d80
<     .AddAttribute ("MaxMulticastSolicit", "Neighbor Discovery node constants: max multicast solicitations.",
<                    IntegerValue (3),
<                    MakeIntegerAccessor (&Icmpv6L4Protocol::m_maxMulticastSolicit),
<                    MakeIntegerChecker<uint8_t> ())
<     .AddAttribute ("MaxUnicastSolicit", "Neighbor Discovery node constants: max unicast solicitations.",
<                    IntegerValue (3),
<                    MakeIntegerAccessor (&Icmpv6L4Protocol::m_maxUnicastSolicit),
<                    MakeIntegerChecker<uint8_t> ())
<     .AddAttribute ("ReachableTime", "Neighbor Discovery node constants: reachable time.",
<                    TimeValue (Seconds (30)),
<                    MakeTimeAccessor (&Icmpv6L4Protocol::m_reachableTime),
<                    MakeTimeChecker ())
<     .AddAttribute ("RetransmissionTime", "Neighbor Discovery node constants: retransmission timer.",
<                    TimeValue (Seconds (1)),
<                    MakeTimeAccessor (&Icmpv6L4Protocol::m_retransmissionTime),
<                    MakeTimeChecker ())
<     .AddAttribute ("DelayFirstProbe", "Neighbor Discovery node constants: delay for the first probe.",
<                    TimeValue (Seconds (5)),
<                    MakeTimeAccessor (&Icmpv6L4Protocol::m_delayFirstProbe),
<                    MakeTimeChecker ())
<     ;
<   return tid;
< }
101,104c82,83
< TypeId Icmpv6L4Protocol::GetInstanceTypeId () const
< {
<   NS_LOG_FUNCTION (this);
<   return Icmpv6L4Protocol::GetTypeId ();
---
>   ;
>   return tid;
153a133,134
>               Ptr<Ipv6RawSocketFactoryImpl> rawFactory = CreateObject<Ipv6RawSocketFactoryImpl> ();
>               ipv6->AggregateObject (rawFactory);
167,172d147
< Ptr<Node> Icmpv6L4Protocol::GetNode ()
< {
<   NS_LOG_FUNCTION (this);
<   return m_node;
< }
< 
211c186
<   
---
> 
378c353
<           /* unknown option, quit */
---
>           /* unknow option, quit */
575,578c550
<   NdiscCache::Ipv6PayloadHeaderPair p = ForgeNA (target.IsLinkLocal () ? interface->GetLinkLocalAddress ().GetAddress () : ifaddr.GetAddress (),
<                                                  src.IsAny () ? dst : src, // DAD replies must go to the multicast group it was sent to.
<                                                  &hardwareAddress,
<                                                  flags );
---
>   NdiscCache::Ipv6PayloadHeaderPair p = ForgeNA (target.IsLinkLocal () ? interface->GetLinkLocalAddress ().GetAddress () : ifaddr.GetAddress (), src.IsAny () ? Ipv6Address::GetAllNodesMulticast () : src, &hardwareAddress, flags );
804c776
<           entry->SetRouter (redirTarget != redirDestination);
---
>           entry->SetRouter (!redirTarget.IsEqual (redirDestination) ? true : false);
829c801
<   if (redirTarget == redirDestination)
---
>   if (redirTarget.IsEqual (redirDestination))
915c887
<   SocketIpv6HopLimitTag tag;
---
>   SocketIpTtlTag tag;
918c890
<   tag.SetHopLimit (ttl);
---
>   tag.SetTtl (ttl);
935c907
<   SocketIpv6HopLimitTag tag;
---
>   SocketIpTtlTag tag;
946c918
<       tag.SetHopLimit (ttl);
---
>       tag.SetTtl (ttl);
1258a1231,1236
>   /* if the source is unspec, multicast the NA to all-nodes multicast */
>   if (src == Ipv6Address::GetAny ())
>     {
>       dst = Ipv6Address::GetAllNodesMulticast ();
>     }
> 
1286c1264
<   NS_ASSERT_MSG (false, "Icmpv6L4Protocol can not find a NDIS Cache for device " << device);
---
>   NS_ASSERT (false);
1297c1275
<   cache->SetDevice (device, interface, this);
---
>   cache->SetDevice (device, interface);
1445c1423
<            * because all nodes start at the same time, there will be many of RS around 1 second of simulation time
---
>            * because all nodes start at the same time, there will be many of RS arround 1 second of simulation time
1478,1508d1455
< 
< uint8_t
< Icmpv6L4Protocol::GetMaxMulticastSolicit () const
< {
<   return m_maxMulticastSolicit;
< }
< 
< uint8_t
< Icmpv6L4Protocol::GetMaxUnicastSolicit () const
< {
<   return m_maxUnicastSolicit;
< }
< 
< Time
< Icmpv6L4Protocol::GetReachableTime () const
< {
<   return m_reachableTime;
< }
< 
< Time
< Icmpv6L4Protocol::GetRetransmissionTime () const
< {
<   return m_retransmissionTime;
< }
< 
< Time
< Icmpv6L4Protocol::GetDelayFirstProbe () const
< {
<   return m_delayFirstProbe;
< }
< 
diff ../../NS3-WiGig/src/internet/model/icmpv6-l4-protocol.h ../../ns-3-dev/src/internet/model/icmpv6-l4-protocol.h
56,57c56
<    * \brief Get the type ID.
<    * \return the object TypeId
---
>    * \brief Interface ID
60d58
<   virtual TypeId GetInstanceTypeId (void) const;
68,69c66
<    * \brief Neighbor Discovery node constants: max multicast solicitations.
<    * \returns The max multicast solicitations number.
---
>    * \brief Neighbor Discovery router constants : max initial RA initial interval.
71c68
<   uint8_t GetMaxMulticastSolicit () const;
---
>   static const uint8_t MAX_INITIAL_RTR_ADVERT_INTERVAL;
74,75c71
<    * \brief Neighbor Discovery node constants: max unicast solicitations.
<    * \returns The max unicast solicitations number.
---
>    * \brief Neighbor Discovery router constants : max initial RA transmission.
77c73
<   uint8_t GetMaxUnicastSolicit () const;
---
>   static const uint8_t MAX_INITIAL_RTR_ADVERTISEMENTS;
80,81c76
<    * \brief Neighbor Discovery node constants: reachable time.
<    * \returns The Reachable time for an Neighbor cache entry.
---
>    * \brief Neighbor Discovery router constants : max final RA transmission.
83c78
<   Time GetReachableTime () const;
---
>   static const uint8_t MAX_FINAL_RTR_ADVERTISEMENTS;
86,87c81
<    * \brief Neighbor Discovery node constants: retransmission timer.
<    * \returns The Retransmission time for an Neighbor cache entry probe.
---
>    * \brief Neighbor Discovery router constants : min delay between RA.
89c83,133
<   Time GetRetransmissionTime () const;
---
>   static const uint8_t MIN_DELAY_BETWEEN_RAS;
> 
>   /**
>    * \brief Neighbor Discovery router constants : max delay between RA.
>    */
>   static const uint32_t MAX_RA_DELAY_TIME;
> 
>   /**
>    * \brief Neighbor Discovery host constants : max RS delay.
>    */
>   static const uint8_t MAX_RTR_SOLICITATION_DELAY;
> 
>   /**
>    * \brief Neighbor Discovery host constants : RS interval.
>    */
>   static const uint8_t RTR_SOLICITATION_INTERVAL;
> 
>   /**
>    * \brief Neighbor Discovery host constants : max RS transmission.
>    */
>   static const uint8_t MAX_RTR_SOLICITATIONS;
> 
>   /**
>    * \brief Neighbor Discovery node constants : max multicast solicitations.
>    */
>   static const uint8_t MAX_MULTICAST_SOLICIT;
> 
>   /**
>    * \brief Neighbor Discovery node constants : max unicast solicitations.
>    */
>   static const uint8_t MAX_UNICAST_SOLICIT;
> 
>   /**
>    * \brief Neighbor Discovery node constants : max anycast delay.
>    */
>   static const uint8_t MAX_ANYCAST_DELAY_TIME;
> 
>   /**
>    * \brief Neighbor Discovery node constants : max NA transmission.
>    */
>   static const uint8_t MAX_NEIGHBOR_ADVERTISEMENT;
> 
>   /**
>    * \brief Neighbor Discovery node constants : reachable time.
>    */
>   static const uint32_t REACHABLE_TIME;
> 
>   /**
>    * \brief Neighbor Discovery node constants : retransmission timer.
>    */
>   static const uint32_t RETRANS_TIMER;
93d136
<    * \returns The time before a first probe for an Neighbor cache entry.
95c138,148
<   Time GetDelayFirstProbe () const;
---
>   static const uint8_t DELAY_FIRST_PROBE_TIME;
> 
>   /**
>    * \brief Neighbor Discovery node constants : min random factor.
>    */
>   static const double MIN_RANDOM_FACTOR;
> 
>   /**
>    * \brief Neighbor Discovery node constants : max random factor.
>    */
>   static const double MAX_RANDOM_FACTOR;
120,126c173
<    * \brief Get the node.
<    * \return node
<    */
<   Ptr<Node> GetNode ();
< 
<   /**
<    * \brief This method is called by AggregateObject and completes the aggregation
---
>    * \brief This method is called by AddAgregate and completes the aggregation
209c256
<   virtual void SendNS (Ipv6Address src, Ipv6Address dst, Ipv6Address target, Address hardwareAddress);
---
>   void SendNS (Ipv6Address src, Ipv6Address dst, Ipv6Address target, Address hardwareAddress);
355c402
<    * \param dst destination address (usually ff02::2 i.e all-routers)
---
>    * \param dst destination address (usealy ff02::2 i.e all-routers)
366c413
<   virtual Ptr<NdiscCache> CreateCache (Ptr<NetDevice> device, Ptr<Ipv6Interface> interface);
---
>   Ptr<NdiscCache> CreateCache (Ptr<NetDevice> device, Ptr<Ipv6Interface> interface);
389a437
> private:
392a441,460
>    * \brief The node.
>    */
>   Ptr<Node> m_node;
> 
>   /**
>    * \brief A list of cache by device.
>    */
>   CacheList m_cacheList;
> 
>   /**
>    * \brief Always do DAD ?
>    */
>   bool m_alwaysDad;
> 
>   /**
>    * \brief Random jitter before sending solicitations
>    */
>   Ptr<RandomVariableStream> m_solicitationJitter;
> 
>   /**
516,561d583
< 
<   /**
<    * \brief Always do DAD ?
<    */
<   bool m_alwaysDad;
< 
<   /**
<    * \brief A list of cache by device.
<    */
<   CacheList m_cacheList;
< 
< private:
<   /**
<    * \brief Neighbor Discovery node constants: max multicast solicitations.
<    */
<   uint8_t m_maxMulticastSolicit;
< 
<   /**
<    * \brief Neighbor Discovery node constants: max unicast solicitations.
<    */
<   uint8_t m_maxUnicastSolicit;
< 
<   /**
<    * \brief Neighbor Discovery node constants: reachable time.
<    */
<   Time m_reachableTime;
< 
<   /**
<    * \brief Neighbor Discovery node constants: retransmission timer.
<    */
<   Time m_retransmissionTime;
< 
<   /**
<    * \brief Neighbor Discovery node constants: delay for the first probe.
<    */
<   Time m_delayFirstProbe;
< 
<   /**
<    * \brief The node.
<    */
<   Ptr<Node> m_node;
< 
<   /**
<    * \brief Random jitter before sending solicitations
<    */
<   Ptr<RandomVariableStream> m_solicitationJitter;
diff ../../NS3-WiGig/src/internet/model/ipv4-address-generator.cc ../../ns-3-dev/src/internet/model/ipv4-address-generator.cc
130,146d129
<    * \brief Check the Ipv4Address allocation in the list of IPv4 entries
<    *
<    * \param addr The Ipv4Address to be checked in the list of Ipv4 entries
<    * \returns true if the address is already allocated
<    */
<   bool IsAddressAllocated (const Ipv4Address addr);
< 
<   /**
<    * \brief Check if a network has already allocated addresses
<    *
<    * \param addr The Ipv4 network to be checked
<    * \param mask The Ipv4 network mask
<    * \returns true if the network is already allocated
<    */
<   bool IsNetworkAllocated (const Ipv4Address addr, const Ipv4Mask mask);
< 
<   /**
229c212
<       m_netTable[i].addrMax = ~m_netTable[i].mask;
---
>       m_netTable[i].addrMax = ~mask;
270d252
< 
432c414
< // So we know it's safe to extend the current block down to include the new
---
> // So we know it's safe to extend the current block down to includ the new
449,500d430
< bool
< Ipv4AddressGeneratorImpl::IsAddressAllocated (const Ipv4Address address)
< {
<   NS_LOG_FUNCTION (this << address);
< 
<   uint32_t addr = address.Get ();
< 
<   NS_ABORT_MSG_UNLESS (addr, "Ipv4AddressGeneratorImpl::IsAddressAllocated(): Don't check for the broadcast address...");
< 
<   std::list<Entry>::iterator i;
< 
<   for (i = m_entries.begin (); i != m_entries.end (); ++i)
<     {
<       NS_LOG_LOGIC ("examine entry: " << Ipv4Address ((*i).addrLow) <<
<                     " to " << Ipv4Address ((*i).addrHigh));
<       if (addr >= (*i).addrLow && addr <= (*i).addrHigh)
<         {
<           NS_LOG_LOGIC ("Ipv4AddressGeneratorImpl::IsAddressAllocated(): Address Collision: " << Ipv4Address (addr));
<           return false;
<         }
<     }
<   return true;
< }
< 
< bool
< Ipv4AddressGeneratorImpl::IsNetworkAllocated (const Ipv4Address address, const Ipv4Mask mask)
< {
<   NS_LOG_FUNCTION (this << address << mask);
< 
<   NS_ABORT_MSG_UNLESS (address == address.CombineMask (mask),
<                        "Ipv4AddressGeneratorImpl::IsNetworkAllocated(): network address and mask don't match " << address << " " << mask);
< 
<   std::list<Entry>::iterator i;
< 
<   for (i = m_entries.begin (); i != m_entries.end (); ++i)
<     {
<       NS_LOG_LOGIC ("examine entry: " << Ipv4Address ((*i).addrLow) << " to " << Ipv4Address ((*i).addrHigh));
<       Ipv4Address low = Ipv4Address ((*i).addrLow);
<       Ipv4Address high = Ipv4Address ((*i).addrHigh);
< 
<       if (address == low.CombineMask (mask) || address == high.CombineMask (mask))
<         {
<           NS_LOG_LOGIC ("Ipv4AddressGeneratorImpl::IsNetworkAllocated(): Network already allocated: " <<
<                         address << " " << low << "-" << high);
<           return false;
<         }
< 
<     }
<   return true;
< }
< 
< 
616,633d545
< }
< 
< bool
< Ipv4AddressGenerator::IsAddressAllocated (const Ipv4Address addr)
< {
<   NS_LOG_FUNCTION_NOARGS ();
< 
<   return SimulationSingleton<Ipv4AddressGeneratorImpl>::Get ()
<          ->IsAddressAllocated (addr);
< }
< 
< bool
< Ipv4AddressGenerator::IsNetworkAllocated (const Ipv4Address addr, const Ipv4Mask mask)
< {
<   NS_LOG_FUNCTION_NOARGS ();
< 
<   return SimulationSingleton<Ipv4AddressGeneratorImpl>::Get ()
<          ->IsNetworkAllocated (addr, mask);
diff ../../NS3-WiGig/src/internet/model/ipv4-address-generator.h ../../ns-3-dev/src/internet/model/ipv4-address-generator.h
127,143d126
<    * \brief Check the Ipv4Address allocation in the list of IPv4 entries
<    *
<    * \param addr The Ipv4Address to be checked in the list of Ipv4 entries
<    * \returns true if the network is already allocated
<    */
<   static bool IsAddressAllocated (const Ipv4Address addr);
< 
<   /**
<    * \brief Check if a network has already allocated addresses
<    *
<    * \param addr The Ipv4 network to be checked
<    * \param mask The Ipv4 network mask
<    * \returns true if the network is already allocated
<    */
<   static bool IsNetworkAllocated (const Ipv4Address addr, const Ipv4Mask mask);
< 
<   /**
diff ../../NS3-WiGig/src/internet/model/ipv4-end-point-demux.cc ../../ns-3-dev/src/internet/model/ipv4-end-point-demux.cc
63c63
< Ipv4EndPointDemux::LookupLocal (Ptr<NetDevice> boundNetDevice, Ipv4Address addr, uint16_t port)
---
> Ipv4EndPointDemux::LookupLocal (Ipv4Address addr, uint16_t port)
69,70c69
<           (*i)->GetLocalAddress () == addr &&
<           (*i)->GetBoundNetDevice () == boundNetDevice)
---
>           (*i)->GetLocalAddress () == addr) 
111c110
< Ipv4EndPointDemux::Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port)
---
> Ipv4EndPointDemux::Allocate (uint16_t port)
113c112
<   NS_LOG_FUNCTION (this <<  port << boundNetDevice);
---
>   NS_LOG_FUNCTION (this <<  port);
115c114
<   return Allocate (boundNetDevice, Ipv4Address::GetAny (), port);
---
>   return Allocate (Ipv4Address::GetAny (), port);
119c118
< Ipv4EndPointDemux::Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port)
---
> Ipv4EndPointDemux::Allocate (Ipv4Address address, uint16_t port)
121,122c120,121
<   NS_LOG_FUNCTION (this << address << port << boundNetDevice);
<   if (LookupLocal (boundNetDevice, address, port) || LookupLocal (0, address, port))
---
>   NS_LOG_FUNCTION (this << address << port);
>   if (LookupLocal (address, port)) 
124c123
<       NS_LOG_WARN ("Duplicated endpoint.");
---
>       NS_LOG_WARN ("Duplicate address/port; failing.");
134,135c133
< Ipv4EndPointDemux::Allocate (Ptr<NetDevice> boundNetDevice,
<                              Ipv4Address localAddress, uint16_t localPort,
---
> Ipv4EndPointDemux::Allocate (Ipv4Address localAddress, uint16_t localPort,
138c136
<   NS_LOG_FUNCTION (this << localAddress << localPort << peerAddress << peerPort << boundNetDevice);
---
>   NS_LOG_FUNCTION (this << localAddress << localPort << peerAddress << peerPort);
144,145c142
<           (*i)->GetPeerAddress () == peerAddress &&
<           ((*i)->GetBoundNetDevice () == boundNetDevice || (*i)->GetBoundNetDevice () == 0))
---
>           (*i)->GetPeerAddress () == peerAddress) 
147c144,145
<           NS_LOG_WARN ("Duplicated endpoint.");
---
>           NS_LOG_WARN ("No way we can allocate this end-point.");
>           /* no way we can allocate this end-point. */
210c208
<   NS_LOG_DEBUG ("Looking up endpoint for destination address " << daddr << ":" << dport);
---
>   NS_LOG_DEBUG ("Looking up endpoint for destination address " << daddr);
246,266c244,246
< 
<       bool localAddressMatchesExact = false;
<       bool localAddressIsAny = false;
<       bool localAddressIsSubnetAny = false;
< 
<       // We have 3 cases:
<       // 1) Exact local / destination address match
<       // 2) Local endpoint bound to Any -> matches anything
<       // 3) Local endpoint bound to x.y.z.0 -> matches Subnet-directed broadcast packet (e.g., x.y.z.255 in a /24 net) and direct destination match.
< 
<       if (endP->GetLocalAddress () == daddr)
<         {
<           // Case 1:
<           localAddressMatchesExact = true;
<         }
<       else if (endP->GetLocalAddress () == Ipv4Address::GetAny ())
<         {
<           // Case 2:
<           localAddressIsAny = true;
<         }
<       else
---
>       bool subnetDirected = false;
>       Ipv4Address incomingInterfaceAddr = daddr;  // may be a broadcast
>       for (uint32_t i = 0; i < incomingInterface->GetNAddresses (); i++)
268,269c248,250
<           // Case 3:
<           for (uint32_t i = 0; i < incomingInterface->GetNAddresses (); i++)
---
>           Ipv4InterfaceAddress addr = incomingInterface->GetAddress (i);
>           if (addr.GetLocal ().CombineMask (addr.GetMask ()) == daddr.CombineMask (addr.GetMask ()) &&
>               daddr.IsSubnetDirectedBroadcast (addr.GetMask ()))
271,283c252,253
<               Ipv4InterfaceAddress addr = incomingInterface->GetAddress (i);
< 
<               Ipv4Address addrNetpart = addr.GetLocal ().CombineMask (addr.GetMask ());
<               if (endP->GetLocalAddress () == addrNetpart)
<                 {
<                   NS_LOG_LOGIC ("Endpoint is SubnetDirectedAny " << endP->GetLocalAddress () << "/" << addr.GetMask ().GetPrefixLength ());
< 
<                   Ipv4Address daddrNetPart = daddr.CombineMask (addr.GetMask ());
<                   if (addrNetpart == daddrNetPart)
<                     {
<                       localAddressIsSubnetAny = true;
<                     }
<                 }
---
>               subnetDirected = true;
>               incomingInterfaceAddr = addr.GetLocal ();
284a255,260
>         }
>       bool isBroadcast = (daddr.IsBroadcast () || subnetDirected == true);
>       NS_LOG_DEBUG ("dest addr " << daddr << " broadcast? " << isBroadcast);
>       bool localAddressMatchesWildCard = 
>         endP->GetLocalAddress () == Ipv4Address::GetAny ();
>       bool localAddressMatchesExact = endP->GetLocalAddress () == daddr;
286,288c262,264
<           // if no match here, keep looking
<           if (!localAddressIsSubnetAny)
<             continue;
---
>       if (isBroadcast)
>         {
>           NS_LOG_DEBUG ("Found bcast, localaddr " << endP->GetLocalAddress ());
291,292c267,276
<       bool remotePortMatchesExact = endP->GetPeerPort () == sport;
<       bool remotePortMatchesWildCard = endP->GetPeerPort () == 0;
---
>       if (isBroadcast && (endP->GetLocalAddress () != Ipv4Address::GetAny ()))
>         {
>           localAddressMatchesExact = (endP->GetLocalAddress () ==
>                                       incomingInterfaceAddr);
>         }
>       // if no match here, keep looking
>       if (!(localAddressMatchesExact || localAddressMatchesWildCard))
>         continue; 
>       bool remotePeerMatchesExact = endP->GetPeerPort () == sport;
>       bool remotePeerMatchesWildCard = endP->GetPeerPort () == 0;
294,295c278,279
<       bool remoteAddressMatchesWildCard = endP->GetPeerAddress () == Ipv4Address::GetAny ();
< 
---
>       bool remoteAddressMatchesWildCard = endP->GetPeerAddress () ==
>         Ipv4Address::GetAny ();
298c282
<       if (!(remotePortMatchesExact || remotePortMatchesWildCard))
---
>       if (!(remotePeerMatchesExact || remotePeerMatchesWildCard))
303,313c287,292
<       bool localAddressMatchesWildCard = localAddressIsAny || localAddressIsSubnetAny;
< 
<       if (localAddressMatchesExact && remoteAddressMatchesExact && remotePortMatchesExact)
<         { // All 4 match - this is the case of an open TCP connection, for example.
<           NS_LOG_LOGIC ("Found an endpoint for case 4, adding " << endP->GetLocalAddress () << ":" << endP->GetLocalPort ());
<           retval4.push_back (endP);
<         }
<       if (localAddressMatchesWildCard && remoteAddressMatchesExact && remotePortMatchesExact)
<         { // All but local address - no idea what this case could be.
<           NS_LOG_LOGIC ("Found an endpoint for case 3, adding " << endP->GetLocalAddress () << ":" << endP->GetLocalPort ());
<           retval3.push_back (endP);
---
>       // Now figure out which return list to add this one to
>       if (localAddressMatchesWildCard &&
>           remotePeerMatchesWildCard &&
>           remoteAddressMatchesWildCard)
>         { // Only local port matches exactly
>           retval1.push_back (endP);
315,317c294,297
<       if (localAddressMatchesExact && remoteAddressMatchesWildCard && remotePortMatchesWildCard)
<         { // Only local port and local address matches exactly - Not yet opened connection
<           NS_LOG_LOGIC ("Found an endpoint for case 2, adding " << endP->GetLocalAddress () << ":" << endP->GetLocalPort ());
---
>       if ((localAddressMatchesExact || (isBroadcast && localAddressMatchesWildCard))&&
>           remotePeerMatchesWildCard &&
>           remoteAddressMatchesWildCard)
>         { // Only local port and local address matches exactly
320,323c300,310
<       if (localAddressMatchesWildCard && remoteAddressMatchesWildCard && remotePortMatchesWildCard)
<         { // Only local port matches exactly - Endpoint open to "any" connection
<           NS_LOG_LOGIC ("Found an endpoint for case 1, adding " << endP->GetLocalAddress () << ":" << endP->GetLocalPort ());
<           retval1.push_back (endP);
---
>       if (localAddressMatchesWildCard &&
>           remotePeerMatchesExact &&
>           remoteAddressMatchesExact)
>         { // All but local address
>           retval3.push_back (endP);
>         }
>       if (localAddressMatchesExact &&
>           remotePeerMatchesExact &&
>           remoteAddressMatchesExact)
>         { // All 4 match
>           retval4.push_back (endP);
328,335c315,318
<   EndPoints retval;
<   if (!retval4.empty ()) retval = retval4;
<   else if (!retval3.empty ()) retval = retval3;
<   else if (!retval2.empty ()) retval = retval2;
<   else retval = retval1;
< 
<   NS_ABORT_MSG_IF (retval.size () > 1, "Too many endpoints - perhaps you created too many sockets without binding them to different NetDevices.");
<   return retval;  // might be empty if no matches
---
>   if (!retval4.empty ()) return retval4;
>   if (!retval3.empty ()) return retval3;
>   if (!retval2.empty ()) return retval2;
>   return retval1;  // might be empty if no matches
diff ../../NS3-WiGig/src/internet/model/ipv4-end-point-demux.h ../../ns-3-dev/src/internet/model/ipv4-end-point-demux.h
75d74
<    * \param boundNetDevice Bound NetDevice (if any)
80c79
<   bool LookupLocal (Ptr<NetDevice> boundNetDevice, Ipv4Address addr, uint16_t port);
---
>   bool LookupLocal (Ipv4Address addr, uint16_t port);
134d132
<    * \param boundNetDevice Bound NetDevice (if any)
138c136
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port);
---
>   Ipv4EndPoint *Allocate (uint16_t port);
142d139
<    * \param boundNetDevice Bound NetDevice (if any)
147c144
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port);
---
>   Ipv4EndPoint *Allocate (Ipv4Address address, uint16_t port);
151d147
<    * \param boundNetDevice Bound NetDevice (if any)
158,160c154,157
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice,
<                           Ipv4Address localAddress, uint16_t localPort,
<                           Ipv4Address peerAddress, uint16_t peerPort);
---
>   Ipv4EndPoint *Allocate (Ipv4Address localAddress, 
>                           uint16_t localPort,
>                           Ipv4Address peerAddress, 
>                           uint16_t peerPort);
diff ../../NS3-WiGig/src/internet/model/ipv4-end-point.h ../../ns-3-dev/src/internet/model/ipv4-end-point.h
90c90
<    * \brief Set the peer information (address and port).
---
>    * \brief Set the peer informations (address and port).
diff ../../NS3-WiGig/src/internet/model/ipv4-global-routing.cc ../../ns-3-dev/src/internet/model/ipv4-global-routing.cc
138,141d137
< bool times[10] = {0};
< Ipv4Address address_list[10];
< bool RoundRobin = true;
< 
159c155
<       if ((*i)->GetDest () == dest)
---
>       if ((*i)->GetDest ().IsEqual (dest)) 
226,228c222,223
<       uint32_t selectIndex = 0;
< 
<         if (m_randomEcmpRouting && RoundRobin == 0)
---
>       uint32_t selectIndex;
>       if (m_randomEcmpRouting)
234,301c229
<           if (allRoutes.size () == 1)
<           {
<             selectIndex = 0;
<           }
<           else
<           {
<             if (dest == address_list[0] && dest!= "10.1.1.1") // packet
<               {
<                 selectIndex = pri[0] > -1 ? !(pri[0]%2) : 0 ; //pri is global
<                 // selectIndex = times[0];
<                 // times[0] = times[0]^1;
<               }
<               else if (dest == address_list[1] && dest!= "10.1.1.1")//packet
<               {
<                 selectIndex = pri[1] > -1 ? !(pri[1]%2) : 0 ; //pri is global
<                 // selectIndex = times[1];
<                 // times[1] = times[1]^1;
<               }
<               else if (dest == address_list[2] && dest!= "10.1.1.1")//packet
<               {
<                 selectIndex = pri[2] > -1 ? !(pri[2]%2) : 0 ; //pri is global
<                 // selectIndex = times[2];
<                 // times[2] = times[2]^1;
<               }
<               else if (dest == address_list[3] && dest!= "10.1.1.1")//packet
<               {
<                 selectIndex = pri[3] > -1 ? !(pri[3]%2) : 0 ; //pri is global
<                 // selectIndex = times[3];
<                 // times[3] = times[3]^1;
<               }
<                else if (dest == address_list[4] && dest!= "10.1.1.1")//packet
<               {
<                 selectIndex = pri[4] > -1 ? !(pri[4]%2) : 0 ; //pri is global
<                 // selectIndex = times[4];
<                 // times[4] = times[4]^1;
<               }
<               else if (dest == address_list[5] && dest!= "10.1.1.1")//packet
<               {
<                 selectIndex = pri[5] > -1 ? !(pri[5]%2) : 0 ; //pri is global
<                 // selectIndex = times[5];
<                 // times[5] = times[5]^1;
<               }
<               else if (dest == address_list[6] && dest!= "10.1.1.1")//packet
<               {
<                 selectIndex = pri[6] > -1 ? !(pri[6]%2) : 0 ; //pri is global
<                 // selectIndex = times[6];
<                 // times[6] = times[6]^1;
<               }
<               else if (dest == address_list[7] && dest!= "10.1.1.1")//packet
<               {
<                 selectIndex = pri[7] > -1 ? !(pri[7]%2) : 0 ; //pri is global
<                 // selectIndex = times[7];
<                 // times[7] = times[7]^1;
<               }
<               else if (dest == "10.1.1.1")//ack
<               {
<                 selectIndex = times[8];
<                 times[8] = times[8]^1;
<               }
<               else 
<               {
<                 // selectIndex = pri[3] > -1 ? pri[3] : 0 ; //pri is global
<                 selectIndex = times[9];
<                 times[9] = times[9]^1;
<                 // selectIndex = 0;
<               }
<               // std::cout << selectIndex << " \n";
<           }
---
>           selectIndex = 0;
473c401
< Ipv4GlobalRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
---
> Ipv4GlobalRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const
479,480c407,408
<       << ", Time: " << Now().As (unit)
<       << ", Local time: " << m_ipv4->GetObject<Node> ()->GetLocalTime ().As (unit)
---
>       << ", Time: " << Now().As (Time::S)
>       << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (Time::S)
555d482
< 
564,582d490
<   // MengHua{
<   for (int list = 0; list < 10; list++) //regist New IP
<   {
<     if (address_list[list] != header.GetDestination() && address_list[list] == "102.102.102.102")  
<     {
< 
<       address_list[list] = header.GetDestination();
<       rout = list;
<       // std::cout << list  << "  "<< header.GetDestination()<< "\n";
<       break;
<     }
<     else if (address_list[list] == header.GetDestination())
<     {
<       rout = list;
<       break;
<     }
<   }
<   pri[rout] = p->GetSize () == 1432 ? header.GetPri() : -1;
<   // }MengHua
612d519
<   // Ptr<Ipv4Route> rtentry = LookupGlobal (header.GetDestination ());
diff ../../NS3-WiGig/src/internet/model/ipv4-global-routing.h ../../ns-3-dev/src/internet/model/ipv4-global-routing.h
101c101
<   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const;
---
>   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const;
231,234d230
<   int pri[10];
<   int rout = 0;
< 
< 
274,275d269
< 
< 
diff ../../NS3-WiGig/src/internet/model/ipv4-header.cc ../../ns-3-dev/src/internet/model/ipv4-header.cc
44,49c44
<     m_headerSize(5*4),
<     //---NC header---
<     NcPri (0),
<     EncodedNumber (0),
<     EncodedLabel (0),
<     EncodedCoeffVector (0)
---
>     m_headerSize(5*4)
387,442d381
< //--------NC Function--------
< std::vector <uint8_t>
< Ipv4Header::GetReceivedHeaderCoeffVector() const
< { 
<   return EncodedCoeffVector;
< }
< void 
< Ipv4Header::SetEncodedLabel(uint32_t label)
< {
<   EncodedLabel = label;
<   NS_LOG_FUNCTION(this << " SetNcLabel:"<<label);
< }
< 
< uint32_t
< Ipv4Header::GetEncodedLabel() const
< { 
<   NS_LOG_FUNCTION(this << " GetNcLabel:"<< EncodedLabel);
<   return EncodedLabel;
< }
< void 
< Ipv4Header::SetEncodedPacketNumber(uint8_t numbers)
< {
<   EncodedNumber = numbers;
< }
< 
< uint8_t 
< Ipv4Header::GetEncodedPacketNumber() const
< {
<   return EncodedNumber;
< }
< 
< void 
< Ipv4Header::SetPri(uint8_t pri)
< {
<   NcPri = pri;
< }
< 
< uint8_t 
< Ipv4Header::GetPri() const
< {
<   return NcPri;
< }
< 
< void 
< Ipv4Header::SetEncodedCoeffVector(const std::vector<uint8_t>& vector)
< { 
<   EncodedCoeffVector = vector;
< }
< 
< const std::vector<uint8_t>& 
< Ipv4Header::GetEncodedCoeffVector() const
< {
<   return EncodedCoeffVector;
< }
< 
< 
448,458c387,388
<   uint8_t verIhl;
<   if (m_ttl > 64 )
<   {
<     verIhl = (4 << 4) | (10);
<   }
<   else
<   {
<     verIhl = (4 << 4) | (5);
<   }
<   // verIhl = (4 << 4) | (5);
<   // verIhl = (4 << 4) | (10);
---
> 
>   uint8_t verIhl = (4 << 4) | (5);
461,470c391
<   if (m_ttl > 64 )
<   {
<     i.WriteHtonU16 (m_payloadSize + 10*4);
<   }
<   else
<   {
<     i.WriteHtonU16 (m_payloadSize + 5*4);
<   }
<   // i.WriteHtonU16 (m_payloadSize + 5*4);
<   // i.WriteHtonU16 (m_payloadSize + 10*4);
---
>   i.WriteHtonU16 (m_payloadSize + 5*4);
500,535d420
< //-----NC Serialize-----
<   if (m_ttl > 64 )
<   {
<     std::vector <uint8_t> headerVector;
<     for(uint8_t i = 0 ; i < 14 ; i++)
<     {   
<       if (i < EncodedCoeffVector.size())
<       {
<         headerVector.push_back(EncodedCoeffVector[i]);
<       }
<       else
<       {
<         headerVector.push_back(0);
<       }
<     }
<     i.WriteU32(EncodedLabel);
<     i.WriteU8(EncodedNumber);
<     i.WriteU8(NcPri);
<     if(EncodedNumber)
<     {
<       for(uint8_t index = 0; index < headerVector.size();index++)
<       {
<         i.WriteU8(headerVector[index]);
<       }
<       // for(uint8_t index = 0; index < 14 ;index++)
<       // {
<       //   i.WriteU8(EncodedCoeffVector[index]);
<       // }
<     }
< 
<   }
< 
< 
< 
< 
< 
588,605d472
<   if (m_ttl > 64)
<   {
<     EncodedLabel = i.ReadU32();
<     EncodedNumber = i.ReadU8();
<     NcPri = i.ReadU8();
< 
<     int temp;
< 
<     if(EncodedNumber)
<     {
<       for(uint8_t index = 0; index < 14 ;index++)
<       {
<         temp = i.ReadU8();
<         EncodedCoeffVector.push_back(temp);
<       }
<     }
<   }
< 
diff ../../NS3-WiGig/src/internet/model/ipv4-header.h ../../ns-3-dev/src/internet/model/ipv4-header.h
58,71d57
<   
< 	void SetEncodedCoeffVector(const std::vector<uint8_t>& vector);
< 	const std::vector<uint8_t>& GetEncodedCoeffVector() const;
< 
< 	std::vector <uint8_t> GetReceivedHeaderCoeffVector() const;
< 
< 	void SetEncodedLabel (uint32_t label);
< 	uint32_t GetEncodedLabel() const;
< 
< 	void SetPri(uint8_t pri);
< 	uint8_t GetPri() const;
< 
< 	void SetEncodedPacketNumber(uint8_t numbers);
< 	uint8_t GetEncodedPacketNumber() const;
75,82c61,65
<    * \brief DiffServ codepoints
<    *
<    * The values correspond to the 6-bit DSCP codepoint within the 8-bit
<    * DS field defined in \RFC {2474}.  ECN bits are separately set with the
<    * SetEcn() method.  Codepoints are defined in
<    * Assured Forwarding (AF) \RFC{2597},
<    * Expedited Forwarding (EF) \RFC{2598}, and
<    * Default and Class Selector (CS) \RFC{2474}.
---
>    * \brief DiffServ Code Points
>    * Code Points defined in
>    * Assured Forwarding (AF) \RFC{2597}
>    * Expedited Forwarding (EF) \RFC{2598}
>    * Default and Class Selector (CS) \RFC{2474}
277,282d259
< 
< 	uint8_t NcPri;
< 	uint8_t EncodedNumber;
< 	uint32_t EncodedLabel;
< 	std::vector <uint8_t> EncodedCoeffVector;
< 	std::vector <uint8_t> ReceivedHeaderCoeffVector;
diff ../../NS3-WiGig/src/internet/model/ipv4-interface.cc ../../ns-3-dev/src/internet/model/ipv4-interface.cc
32d31
< #include "ns3/traffic-control-layer.h"
60c59
<  *  with no IP addresses.  Before becoming usable, the user must 
---
>  *  with no IP addresses.  Before becoming useable, the user must 
diff ../../NS3-WiGig/src/internet/model/ipv4-interface.h ../../ns-3-dev/src/internet/model/ipv4-interface.h
27a28
> #include "ns3/traffic-control-layer.h"
38d38
< class TrafficControlLayer;
172c172
<    * \returns the number of Ipv4InterfaceAddress stored on this interface
---
>    * \returns the number of Ipv4InterfaceAddresss stored on this interface
194,210d193
<   /**
<    * \brief Copy constructor
<    * \param o object to copy
<    *
<    * Defined and unimplemented to avoid misuse
<    */
<   Ipv4Interface (const Ipv4Interface &o);
< 
<   /**
<    * \brief Assignment operator
<    * \param o object to copy
<    * \returns the copied object
<    *
<    * Defined and unimplemented to avoid misuse
<    */
<   Ipv4Interface &operator = (const Ipv4Interface &o);
< 
diff ../../NS3-WiGig/src/internet/model/ipv4-l3-protocol.cc ../../ns-3-dev/src/internet/model/ipv4-l3-protocol.cc
30,31d29
< #include "ns3/string.h"
< #include "ns3/boolean.h"
74,88d71
<     .AddAttribute ("EnableDuplicatePacketDetection",
<                    "Enable multicast duplicate packet detection based on RFC 6621",
<                    BooleanValue (false),
<                    MakeBooleanAccessor (&Ipv4L3Protocol::m_enableDpd),
<                    MakeBooleanChecker ())
<     .AddAttribute ("DuplicateExpire", "Expiration delay for duplicate cache entries",
<                    TimeValue (MilliSeconds (1)),
<                    MakeTimeAccessor (&Ipv4L3Protocol::m_expire),
<                    MakeTimeChecker ())
<     .AddAttribute ("PurgeExpiredPeriod", 
<                    "Time between purges of expired duplicate packet entries, "
<                    "0 means never purge",
<                    TimeValue (Seconds (1)),
<                    MakeTimeAccessor (&Ipv4L3Protocol::m_purge),
<                    MakeTimeChecker (Seconds (0)))
265c248
<  * This method is called by AggregateObject and completes the aggregation
---
>  * This method is called by AddAgregate and completes the aggregation
327,329c310
<   m_fragments.clear ();
<   m_timeoutEventList.clear ();
<   if (m_timeoutEvent.IsRunning ())
---
>   for (MapFragmentsTimers_t::iterator it = m_fragmentsTimers.begin (); it != m_fragmentsTimers.end (); it++)
331c312,315
<       m_timeoutEvent.Cancel ();
---
>       if (it->second.IsRunning ())
>         {
>           it->second.Cancel ();
>         }
334,338c318,319
<   if (m_cleanDpd.IsRunning ())
<     {
<       m_cleanDpd.Cancel ();
<     }
<   m_dups.clear ();
---
>   m_fragments.clear ();
>   m_fragmentsTimers.clear ();
409a391
>   tc->SetupDevice (device);
528c510
<           NS_LOG_LOGIC ("For me (Ipv4Addr multicast address)");
---
>           NS_LOG_LOGIC ("For me (Ipv4Addr multicast address");
604c586
<       // packet->RemoveAtEnd (packet->GetSize () - ipHeader.GetPayloadSize ());
---
>       packet->RemoveAtEnd (packet->GetSize () - ipHeader.GetPayloadSize ());
651,657d632
<   if (m_enableDpd && ipHeader.GetDestination ().IsMulticast () && UpdateDuplicate (packet, ipHeader))
<     {
<       NS_LOG_LOGIC ("Dropping received packet -- duplicate.");
<       m_dropTrace (ipHeader, packet, DROP_DUPLICATE, m_node->GetObject<Ipv4> (), interface);
<       return;
<     }
< 
953c928
<   if (route->GetGateway () != Ipv4Address ("0.0.0.0"))
---
>   if (!route->GetGateway ().IsEqual (Ipv4Address ("0.0.0.0")))
1058,1059c1033,1035
<       // Do not reply to multicast/broadcast IP address
<       if (ipHeader.GetDestination ().IsBroadcast () == false &&
---
>       // Do not reply to ICMP or to multicast/broadcast IP address 
>       if (ipHeader.GetProtocol () != Icmpv4L4Protocol::PROT_NUMBER && 
>           ipHeader.GetDestination ().IsBroadcast () == false &&
1063c1039
<           icmp->SendTimeExceededTtl (ipHeader, packet, false);
---
>           icmp->SendTimeExceededTtl (ipHeader, packet);
1449,1450c1425,1426
<   uint16_t originalOffset = ipv4Header.GetFragmentOffset();
<   bool isLastFragment = ipv4Header.IsLastFragment();
---
>   uint16_t originalOffset = 0;
>   bool alreadyFragmented = false;
1452a1429,1434
>   if (!ipv4Header.IsLastFragment())
>     {
>       alreadyFragmented = true;
>       originalOffset = ipv4Header.GetFragmentOffset();
>     }
> 
1474c1456
<           if (!isLastFragment)
---
>           if (alreadyFragmented)
1506c1488
<       listFragments.emplace_back (fragment, fragmentHeader);
---
>       listFragments.push_back (Ipv4PayloadHeaderPair (fragment, fragmentHeader));
1523c1505
<   FragmentKey_t key;
---
>   std::pair<uint64_t, uint32_t> key;
1537,1539c1519,1521
< 
<       FragmentsTimeoutsListI_t iter = SetTimeout (key, ipHeader, iif);
<       fragments->SetTimeoutIter (iter);
---
>       m_fragmentsTimers[key] = Simulator::Schedule (m_fragmentExpirationTimeout,
>                                                     &Ipv4L3Protocol::HandleFragmentsTimeout, this,
>                                                     key, ipHeader, iif);
1553d1534
<       m_timeoutEventList.erase (fragments->GetTimeoutIter ());
1555a1537,1542
>       if (m_fragmentsTimers[key].IsRunning ())
>         {
>           NS_LOG_LOGIC ("Stopping WaitFragmentsTimer at " << Simulator::Now ().GetSeconds () << " due to complete packet");
>           m_fragmentsTimers[key].Cancel ();
>         }
>       m_fragmentsTimers.erase (key);
1700,1714c1687
< Ipv4L3Protocol::Fragments::SetTimeoutIter (FragmentsTimeoutsListI_t iter)
< {
<   m_timeoutIter = iter;
<   return;
< }
< 
< Ipv4L3Protocol::FragmentsTimeoutsListI_t
< Ipv4L3Protocol::Fragments::GetTimeoutIter ()
< {
<   return m_timeoutIter;
< }
< 
< 
< void
< Ipv4L3Protocol::HandleFragmentsTimeout (FragmentKey_t key, Ipv4Header & ipHeader, uint32_t iif)
---
> Ipv4L3Protocol::HandleFragmentsTimeout (std::pair<uint64_t, uint32_t> key, Ipv4Header & ipHeader, uint32_t iif)
1725c1698
<       icmp->SendTimeExceededTtl (ipHeader, packet, true);
---
>       icmp->SendTimeExceededTtl (ipHeader, packet);
1732a1706
>   m_fragmentsTimers.erase (key);
1734,1880d1707
< 
< bool
< Ipv4L3Protocol::UpdateDuplicate (Ptr<const Packet> p, const Ipv4Header &header)
< {
<   NS_LOG_FUNCTION (this << p << header);
< 
<   // \todo RFC 6621 mandates SHA-1 hash.  For now ns3 hash should be fine.
<   uint8_t proto = header.GetProtocol ();
<   Ipv4Address src = header.GetSource ();
<   Ipv4Address dst = header.GetDestination ();
<   uint64_t id = header.GetIdentification ();
< 
<   // concat hash value onto id
<   uint64_t hash = id << 32;
<   if (header.GetFragmentOffset () || !header.IsLastFragment ())
<     {
<       // use I-DPD (RFC 6621, Sec 6.2.1)
<       hash |= header.GetFragmentOffset ();
<     }
<   else
<     {
<       // use H-DPD (RFC 6621, Sec 6.2.2)
< 
<       // serialize packet
<       Ptr<Packet> pkt = p->Copy ();
<       pkt->AddHeader (header);
< 
<       std::ostringstream oss (std::ios_base::binary);
<       pkt->CopyData (&oss, pkt->GetSize ());
<       std::string bytes = oss.str ();
< 
<       NS_ASSERT_MSG (bytes.size () >= 20, "Degenerate header serialization");
< 
<       // zero out mutable fields
<       bytes[1] = 0;               // DSCP / ECN
<       bytes[6] = bytes[7] = 0;    // Flags / Fragment offset
<       bytes[8] = 0;               // TTL
<       bytes[10] = bytes[11] = 0;  // Header checksum
<       if (header.GetSerializedSize () > 20)     // assume options should be 0'd
<         {
<           std::fill_n (bytes.begin () + 20, header.GetSerializedSize () - 20, 0);
<         }
<         
<       // concat hash onto ID
<       hash |= (uint64_t)Hash32 (bytes);
<     }
< 
<   // set cleanup job for new duplicate entries
<   if (!m_cleanDpd.IsRunning () && m_purge.IsStrictlyPositive ())
<     {
<       m_cleanDpd = Simulator::Schedule (m_expire, &Ipv4L3Protocol::RemoveDuplicates, this);
<     }
< 
<   // assume this is a new entry
<   DupTuple_t key {hash, proto, src, dst};
<   NS_LOG_DEBUG ("Packet " << p->GetUid () << " key = (" <<
<                 std::hex << std::get<0> (key) << ", " <<
<                 std::dec << +std::get<1> (key) << ", " <<
<                 std::get<2> (key) << ", " <<
<                 std::get<3> (key) << ")");
< 
<   // place a new entry, on collision the existing entry iterator is returned
<   DupMap_t::iterator iter;
<   bool inserted, isDup;
<   std::tie (iter, inserted) = m_dups.emplace (key, Seconds (0));
<   isDup = !inserted && iter->second > Simulator::Now ();
< 
<   // set the expiration event
<   iter->second = Simulator::Now () + m_expire;
<   return isDup;
< }
< 
< void
< Ipv4L3Protocol::RemoveDuplicates (void)
< {
<   NS_LOG_FUNCTION (this);
< 
<   DupMap_t::size_type n = 0;
<   Time expire = Simulator::Now ();
<   auto iter = m_dups.cbegin ();
<   while (iter != m_dups.cend ())
<     {
<       if (iter->second < expire)
<         {
<           NS_LOG_LOGIC ("Remove key = (" <<
<                         std::hex << std::get<0> (iter->first) << ", " <<
<                         std::dec << +std::get<1> (iter->first) << ", " <<
<                         std::get<2> (iter->first) << ", " <<
<                         std::get<3> (iter->first) << ")");
<           iter = m_dups.erase (iter);
<           ++n;
<         }
<       else
<         {
<           ++iter;
<         }
<     }
<   
<   NS_LOG_DEBUG ("Purged " << n << " expired duplicate entries out of " << (n + m_dups.size ()));
<   
<   // keep cleaning up if necessary
<   if (!m_dups.empty () && m_purge.IsStrictlyPositive ())
<     {
<       m_cleanDpd = Simulator::Schedule (m_purge, &Ipv4L3Protocol::RemoveDuplicates, this);
<     }
< }
< 
< Ipv4L3Protocol::FragmentsTimeoutsListI_t
< Ipv4L3Protocol::SetTimeout (FragmentKey_t key, Ipv4Header ipHeader, uint32_t iif)
< {
<   Time now = Simulator::Now () + m_fragmentExpirationTimeout;
< 
<   if (m_timeoutEventList.empty ())
<     {
<       m_timeoutEvent = Simulator::Schedule (m_fragmentExpirationTimeout, &Ipv4L3Protocol::HandleTimeout, this);
<     }
<   m_timeoutEventList.emplace_back (now, key, ipHeader, iif);
< 
<   Ipv4L3Protocol::FragmentsTimeoutsListI_t iter = --m_timeoutEventList.end();
< 
<   return (iter);
< }
< 
< void
< Ipv4L3Protocol::HandleTimeout (void)
< {
<   Time now = Simulator::Now ();
< 
<   while (!m_timeoutEventList.empty () && std::get<0> (*m_timeoutEventList.begin ()) == now)
<     {
<       HandleFragmentsTimeout (std::get<1> (*m_timeoutEventList.begin ()),
<                               std::get<2> (*m_timeoutEventList.begin ()),
<                               std::get<3> (*m_timeoutEventList.begin ()));
<       m_timeoutEventList.pop_front ();
<     }
< 
<   if (m_timeoutEventList.empty ())
<     {
<       return;
<     }
< 
<   Time difference = std::get<0> (*m_timeoutEventList.begin ()) - now;
<   m_timeoutEvent = Simulator::Schedule (difference, &Ipv4L3Protocol::HandleTimeout, this);
< 
<   return;
< }
< 
diff ../../NS3-WiGig/src/internet/model/ipv4-l3-protocol.h ../../ns-3-dev/src/internet/model/ipv4-l3-protocol.h
54a55
> 
104,105c105
<     DROP_FRAGMENT_TIMEOUT, /**< Fragment timeout exceeded */
<     DROP_DUPLICATE  /**< Duplicate packet received */
---
>     DROP_FRAGMENT_TIMEOUT /**< Fragment timeout exceeded */
233,234c233,234
<       (const Ipv4Header & header, Ptr<const Packet> packet, uint32_t interface);
< 
---
>     (const Ipv4Header & header, Ptr<const Packet> packet, uint32_t interface);
>    
246c246
<       (Ptr<const Packet> packet, Ptr<Ipv4> ipv4, uint32_t interface);
---
>     (Ptr<const Packet> packet, Ptr<Ipv4> ipv4, uint32_t interface);
260,263c260,263
<       (const Ipv4Header & header, Ptr<const Packet> packet,
<           DropReason reason, Ptr<Ipv4> ipv4,
<           uint32_t interface);
< 
---
>     (const Ipv4Header & header, Ptr<const Packet> packet,
>      DropReason reason, Ptr<Ipv4> ipv4,
>      uint32_t interface);
>    
273,276d272
<   /**
<    * \brief Ipv4L3ProtocolTestCase test case.
<    * \relates Ipv4L3ProtocolTestCase
<    */
312,318c308,314
<       Ipv4Address source,
<       Ipv4Address destination,
<       uint8_t protocol,
<       uint16_t payloadSize,
<       uint8_t ttl,
<       uint8_t tos,
<       bool mayFragment);
---
>     Ipv4Address source,
>     Ipv4Address destination,
>     uint8_t protocol,
>     uint16_t payloadSize,
>     uint8_t ttl,
>     uint8_t tos,
>     bool mayFragment);
418a415,422
>    * \brief Process the timeout for packet fragments
>    * \param key representing the packet fragments
>    * \param ipHeader the IP header of the original packet
>    * \param iif Input Interface
>    */
>   void HandleFragmentsTimeout ( std::pair<uint64_t, uint32_t> key, Ipv4Header & ipHeader, uint32_t iif);
> 
>   /**
488,521d491
<   /// Key identifying a fragmented packet
<   typedef std::pair<uint64_t, uint32_t> FragmentKey_t;
< 
<   /// Container for fragment timeouts.
<   typedef std::list< std::tuple <Time, FragmentKey_t, Ipv4Header, uint32_t > > FragmentsTimeoutsList_t;
<   /// Container Iterator for fragment timeouts..
<   typedef std::list< std::tuple <Time, FragmentKey_t, Ipv4Header, uint32_t > >::iterator FragmentsTimeoutsListI_t;
< 
<   /**
<    * \brief Process the timeout for packet fragments
<    * \param key representing the packet fragments
<    * \param ipHeader the IP header of the original packet
<    * \param iif Input Interface
<    */
<   void HandleFragmentsTimeout (FragmentKey_t key, Ipv4Header & ipHeader, uint32_t iif);
< 
<   /**
<    * \brief Set a new timeout "event" for a fragmented packet
<    * \param key the fragment identification
<    * \param ipHeader the IPv4 header of the fragmented packet
<    * \param iif input interface of the packet
<    * \return an iterator to the inserted "event"
<    */
<   FragmentsTimeoutsListI_t SetTimeout (FragmentKey_t key, Ipv4Header ipHeader, uint32_t iif);
< 
<   /**
<    * \brief Handles a fragmented packet timeout
<    */
<   void HandleTimeout (void);
< 
<   FragmentsTimeoutsList_t m_timeoutEventList;  //!< Timeout "events" container
< 
<   EventId m_timeoutEvent;  //!< Event for the next scheduled timeout
< 
527c497
<   public:
---
> public:
564,576c534
<     /**
<      * \brief Set the Timeout iterator.
<      * \param iter The iterator.
<      */
<     void SetTimeoutIter (FragmentsTimeoutsListI_t iter);
< 
<     /**
<      * \brief Get the Timeout iterator.
<      * \returns The iterator.
<      */
<     FragmentsTimeoutsListI_t GetTimeoutIter ();
< 
<   private:
---
> private:
587,590d544
<     /**
<      * \brief Timeout iterator to "event" handler
<      */
<     FragmentsTimeoutsListI_t m_timeoutIter;
594c548,550
<   typedef std::map< FragmentKey_t, Ptr<Fragments> > MapFragments_t;
---
>   typedef std::map< std::pair<uint64_t, uint32_t>, Ptr<Fragments> > MapFragments_t;
>   /// Container of fragment timeout event, stored as pairs(src+dst addr, src+dst port) / EventId
>   typedef std::map< std::pair<uint64_t, uint32_t>, EventId > MapFragmentsTimers_t;
597a554
>   MapFragmentsTimers_t m_fragmentsTimers; //!< Expiration events.
599,622d555
<   /// IETF RFC 6621, Section 6.2 de-duplication w/o IPSec
<   /// RFC 6621 recommended duplicate packet tuple: {IPV hash, IP protocol, IP source address, IP destination address}
<   typedef std::tuple <uint64_t, uint8_t, Ipv4Address, Ipv4Address> DupTuple_t;
<   /// Maps packet duplicate tuple to expiration time
<   typedef std::map<DupTuple_t, Time> DupMap_t;
< 
<   /**
<    * Registers duplicate entry, return false if new
<    * \param [in] p Possibly duplicate packet.
<    * \param [in] header Packet \pname{p} header.
<    * \return True if this packet is a duplicate
<    */
<   bool UpdateDuplicate (Ptr<const Packet> p, const Ipv4Header &header);
<   /**
<    * Remove duplicate packet entry
<    * \param [in] iter Iterator into duplicate map to remove
<    */
<   void RemoveDuplicates (void);
< 
<   bool                m_enableDpd;    //!< Enable multicast duplicate packet detection
<   DupMap_t            m_dups;         //!< map of packet duplicate tuples to expiry event
<   Time                m_expire;       //!< duplicate entry expiration delay
<   Time                m_purge;        //!< time between purging expired duplicate entries
<   EventId             m_cleanDpd;     //!< event to cleanup expired duplicate entries
diff ../../NS3-WiGig/src/internet/model/ipv4-list-routing.cc ../../ns-3-dev/src/internet/model/ipv4-list-routing.cc
73c73
< Ipv4ListRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
---
> Ipv4ListRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const
77,78c77,78
<                         << ", Time: " << Now().As (unit)
<                         << ", Local time: " << m_ipv4->GetObject<Node> ()->GetLocalTime ().As (unit)
---
>                         << ", Time: " << Now().As (Time::S)
>                         << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (Time::S)
84c84
<       (*i).second->PrintRoutingTable (stream, unit);
---
>       (*i).second->PrintRoutingTable (stream);
diff ../../NS3-WiGig/src/internet/model/ipv4-list-routing.h ../../ns-3-dev/src/internet/model/ipv4-list-routing.h
25d24
< #include "ns3/nstime.h"
92c91
<   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const;
---
>   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const;
diff ../../NS3-WiGig/src/internet/model/ipv4-packet-filter.cc ../../ns-3-dev/src/internet/model/ipv4-packet-filter.cc
26d25
< #include "ns3/uinteger.h"
66a66,148
> NS_OBJECT_ENSURE_REGISTERED (FqCoDelIpv4PacketFilter);
> 
> TypeId
> FqCoDelIpv4PacketFilter::GetTypeId (void)
> {
>   static TypeId tid = TypeId ("ns3::FqCoDelIpv4PacketFilter")
>     .SetParent<Ipv4PacketFilter> ()
>     .SetGroupName ("Internet")
>     .AddConstructor<FqCoDelIpv4PacketFilter> ()
>     .AddAttribute ("Perturbation",
>                    "The salt used as an additional input to the hash function of this filter",
>                    UintegerValue (0),
>                    MakeUintegerAccessor (&FqCoDelIpv4PacketFilter::m_perturbation),
>                    MakeUintegerChecker<uint32_t> ())
>   ;
>   return tid;
> }
> 
> FqCoDelIpv4PacketFilter::FqCoDelIpv4PacketFilter ()
> {
>   NS_LOG_FUNCTION (this);
> }
> 
> FqCoDelIpv4PacketFilter::~FqCoDelIpv4PacketFilter ()
> {
>   NS_LOG_FUNCTION (this);
> }
> 
> int32_t
> FqCoDelIpv4PacketFilter::DoClassify (Ptr<QueueDiscItem> item) const
> {
>   NS_LOG_FUNCTION (this << item);
>   Ptr<Ipv4QueueDiscItem> ipv4Item = DynamicCast<Ipv4QueueDiscItem> (item);
> 
>   NS_ASSERT (ipv4Item != 0);
> 
>   Ipv4Header hdr = ipv4Item->GetHeader ();
>   Ipv4Address src = hdr.GetSource ();
>   Ipv4Address dest = hdr.GetDestination ();
>   uint8_t prot = hdr.GetProtocol ();
>   uint16_t fragOffset = hdr.GetFragmentOffset ();
> 
>   TcpHeader tcpHdr;
>   UdpHeader udpHdr;
>   uint16_t srcPort = 0;
>   uint16_t destPort = 0;
> 
>   Ptr<Packet> pkt = ipv4Item->GetPacket ();
> 
>   if (prot == 6 && fragOffset == 0) // TCP
>     {
>       pkt->PeekHeader (tcpHdr);
>       srcPort = tcpHdr.GetSourcePort ();
>       destPort = tcpHdr.GetDestinationPort ();
>     }
>   else if (prot == 17 && fragOffset == 0) // UDP
>     {
>       pkt->PeekHeader (udpHdr);
>       srcPort = udpHdr.GetSourcePort ();
>       destPort = udpHdr.GetDestinationPort ();
>     }
> 
>   /* serialize the 5-tuple and the perturbation in buf */
>   uint8_t buf[17];
>   src.Serialize (buf);
>   dest.Serialize (buf + 4);
>   buf[8] = prot;
>   buf[9] = (srcPort >> 8) & 0xff;
>   buf[10] = srcPort & 0xff;
>   buf[11] = (destPort >> 8) & 0xff;
>   buf[12] = destPort & 0xff;
>   buf[13] = (m_perturbation >> 24) & 0xff;
>   buf[14] = (m_perturbation >> 16) & 0xff;
>   buf[15] = (m_perturbation >> 8) & 0xff;
>   buf[16] = m_perturbation & 0xff;
> 
>   /* Linux calculates the jhash2 (jenkins hash), we calculate the murmur3 */
>   uint32_t hash = Hash32 ((char*) buf, 17);
> 
>   NS_LOG_DEBUG ("Found Ipv4 packet; hash value " << hash);
> 
>   return hash;
> }
diff ../../NS3-WiGig/src/internet/model/ipv4-packet-filter.h ../../ns-3-dev/src/internet/model/ipv4-packet-filter.h
53a54,78
> 
> /**
>  * \ingroup internet
>  *
>  * FqCoDelIpv4PacketFilter is the filter to be added to the FQCoDel
>  * queue disc to simulate the behavior of the fq-codel Linux queue disc.
>  *
>  */
> class FqCoDelIpv4PacketFilter : public Ipv4PacketFilter {
> public:
>   /**
>    * \brief Get the type ID.
>    * \return the object TypeId
>    */
>   static TypeId GetTypeId (void);
> 
>   FqCoDelIpv4PacketFilter ();
>   virtual ~FqCoDelIpv4PacketFilter ();
> 
> private:
>   virtual int32_t DoClassify (Ptr<QueueDiscItem> item) const;
> 
>   uint32_t m_perturbation; //!< hash perturbation value
> };
> 
diff ../../NS3-WiGig/src/internet/model/ipv4-queue-disc-item.cc ../../ns-3-dev/src/internet/model/ipv4-queue-disc-item.cc
21,22d20
< #include "ns3/tcp-header.h"
< #include "ns3/udp-header.h"
36c34
< Ipv4QueueDiscItem::~Ipv4QueueDiscItem ()
---
> Ipv4QueueDiscItem::~Ipv4QueueDiscItem()
41c39
< uint32_t Ipv4QueueDiscItem::GetSize (void) const
---
> uint32_t Ipv4QueueDiscItem::GetPacketSize(void) const
43d40
<   NS_LOG_FUNCTION (this);
60c57
< void Ipv4QueueDiscItem::AddHeader (void)
---
> void Ipv4QueueDiscItem::AddHeader(void)
86,98d82
< Ipv4QueueDiscItem::Mark (void)
< {
<   NS_LOG_FUNCTION (this);
<   if (!m_headerAdded && m_header.GetEcn () != Ipv4Header::ECN_NotECT)
<     {
<       m_header.SetEcn (Ipv4Header::ECN_CE);
<       return true;
<     }
<   return false;
< }
< 
< 
< bool
112,166d95
< }
< 
< uint32_t
< Ipv4QueueDiscItem::Hash (uint32_t perturbation) const
< {
<   NS_LOG_FUNCTION (this << perturbation);
< 
<   Ipv4Address src = m_header.GetSource ();
<   Ipv4Address dest = m_header.GetDestination ();
<   uint8_t prot = m_header.GetProtocol ();
<   uint16_t fragOffset = m_header.GetFragmentOffset ();
< 
<   TcpHeader tcpHdr;
<   UdpHeader udpHdr;
<   uint16_t srcPort = 0;
<   uint16_t destPort = 0;
< 
<   if (prot == 6 && fragOffset == 0) // TCP
<     {
<       GetPacket ()->PeekHeader (tcpHdr);
<       srcPort = tcpHdr.GetSourcePort ();
<       destPort = tcpHdr.GetDestinationPort ();
<     }
<   else if (prot == 17 && fragOffset == 0) // UDP
<     {
<       GetPacket ()->PeekHeader (udpHdr);
<       srcPort = udpHdr.GetSourcePort ();
<       destPort = udpHdr.GetDestinationPort ();
<     }
<   if (prot != 6 && prot != 17)
<     {
<       NS_LOG_WARN ("Unknown transport protocol, no port number included in hash computation");
<     }
< 
<   /* serialize the 5-tuple and the perturbation in buf */
<   uint8_t buf[17];
<   src.Serialize (buf);
<   dest.Serialize (buf + 4);
<   buf[8] = prot;
<   buf[9] = (srcPort >> 8) & 0xff;
<   buf[10] = srcPort & 0xff;
<   buf[11] = (destPort >> 8) & 0xff;
<   buf[12] = destPort & 0xff;
<   buf[13] = (perturbation >> 24) & 0xff;
<   buf[14] = (perturbation >> 16) & 0xff;
<   buf[15] = (perturbation >> 8) & 0xff;
<   buf[16] = perturbation & 0xff;
< 
<   // Linux calculates jhash2 (jenkins hash), we calculate murmur3 because it is
<   // already available in ns-3
<   uint32_t hash = Hash32 ((char*) buf, 17);
< 
<   NS_LOG_DEBUG ("Hash value " << hash);
< 
<   return hash;
diff ../../NS3-WiGig/src/internet/model/ipv4-queue-disc-item.h ../../ns-3-dev/src/internet/model/ipv4-queue-disc-item.h
23c23,26
< #include "ns3/queue-item.h"
---
> #include "ns3/object.h"
> #include "ns3/net-device.h"
> #include "ns3/traced-value.h"
> #include "ns3/queue-disc.h"
52c55
<   virtual uint32_t GetSize (void) const;
---
>   virtual uint32_t GetPacketSize (void) const;
78,95d80
< 
<   /**
<    * \brief Marks the packet by setting ECN_CE bits if the packet has ECN_ECT0 or ECN_ECT1 bits set
<    * \return true if the packet gets marked, false otherwise
<    */
<   virtual bool Mark (void);
< 
<   /**
<    * \brief Computes the hash of the packet's 5-tuple
<    *
<    * Computes the hash of the source and destination IP addresses, protocol
<    * number and, if the transport protocol is either UDP or TCP, the source
<    * and destination port
<    *
<    * \param perturbation hash perturbation value
<    * \return the hash of the packet's 5-tuple
<    */
<   virtual uint32_t Hash (uint32_t perturbation) const;
diff ../../NS3-WiGig/src/internet/model/ipv4-raw-socket-impl.cc ../../ns-3-dev/src/internet/model/ipv4-raw-socket-impl.cc
254,310d253
<   bool subnetDirectedBroadcast = false;
<   if (m_boundnetdevice)
<     {
<       uint32_t iif = ipv4->GetInterfaceForDevice (m_boundnetdevice);
<       for (uint32_t j = 0; j < ipv4->GetNAddresses (iif); j++)
<         {
<           Ipv4InterfaceAddress ifAddr = ipv4->GetAddress (iif, j);
<           if (dst.IsSubnetDirectedBroadcast (ifAddr.GetMask ()))
<             {
<               subnetDirectedBroadcast = true;
<             }
<         }
<     }
< 
<   if (dst.IsBroadcast () || subnetDirectedBroadcast)
<     {
<       Ptr <NetDevice> boundNetDevice = m_boundnetdevice;
<       if (ipv4->GetNInterfaces () == 1)
<         {
<           boundNetDevice = ipv4->GetNetDevice (0);
<         }
<       if (boundNetDevice == 0)
<         {
<           NS_LOG_DEBUG ("dropped because no outgoing route.");
<           return -1;
<         }
< 
<       Ipv4Header header;
<       uint32_t pktSize = p->GetSize ();
<       if (!m_iphdrincl)
<         {
<           header.SetDestination (dst);
<           header.SetProtocol (m_protocol);
<           Ptr<Ipv4Route> route = Create <Ipv4Route> ();
<           route->SetSource (src);
<           route->SetDestination (dst);
<           route->SetOutputDevice (boundNetDevice);
<           ipv4->Send (p, route->GetSource (), dst, m_protocol, route);
<         }
<       else
<         {
<           p->RemoveHeader (header);
<           dst = header.GetDestination ();
<           src = header.GetSource ();
<           pktSize += header.GetSerializedSize ();
<           Ptr<Ipv4Route> route = Create <Ipv4Route> ();
<           route->SetSource (src);
<           route->SetDestination (dst);
<           route->SetOutputDevice (boundNetDevice);
<           ipv4->SendWithHeader (p, header, route);
<         }
<       NotifyDataSent (pktSize);
<       NotifySend (GetTxAvailable ());
<       return pktSize;
<     }
< 
< 
diff ../../NS3-WiGig/src/internet/model/ipv4-routing-protocol.h ../../ns-3-dev/src/internet/model/ipv4-routing-protocol.h
29d28
< #include "ns3/nstime.h"
169,170c168
<    * \param stream The ostream the Routing table is printed to
<    * \param unit The time unit to be used in the report
---
>    * \param stream the ostream the Routing table is printed to
172,173c170
<   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const = 0;
< 
---
>   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const = 0;
diff ../../NS3-WiGig/src/internet/model/ipv4-routing-table-entry.cc ../../ns-3-dev/src/internet/model/ipv4-routing-table-entry.cc
99c99
<   if (m_destNetworkMask == Ipv4Mask::GetOnes ())
---
>   if (m_destNetworkMask.IsEqual (Ipv4Mask::GetOnes ()))
124c124
<   if (m_dest == Ipv4Address::GetZero ())
---
>   if (m_dest.IsEqual (Ipv4Address::GetZero ()))
149c149
<   if (m_gateway == Ipv4Address::GetZero ())
---
>   if (m_gateway.IsEqual (Ipv4Address::GetZero ()))
210c210
<   return Ipv4RoutingTableEntry (Ipv4Address::GetZero (), Ipv4Mask::GetZero (), nextHop, interface);
---
>   return Ipv4RoutingTableEntry (Ipv4Address::GetZero (), nextHop, interface);
258,265d257
< bool operator== (const Ipv4RoutingTableEntry a, const Ipv4RoutingTableEntry b)
< {
<   return (a.GetDest () == b.GetDest () && 
<           a.GetDestNetworkMask () == b.GetDestNetworkMask () &&
<           a.GetGateway () == b.GetGateway () &&
<           a.GetInterface () == b.GetInterface ());
< }
< 
379,386d370
< }
< 
< bool operator== (const Ipv4MulticastRoutingTableEntry a, const Ipv4MulticastRoutingTableEntry b)
< {
<   return (a.GetOrigin () == b.GetOrigin () && 
<           a.GetGroup () == b.GetGroup () &&
<           a.GetInputInterface () == b.GetInputInterface () &&
<           a.GetOutputInterfaces () == b.GetOutputInterfaces ());
diff ../../NS3-WiGig/src/internet/model/ipv4-routing-table-entry.h ../../ns-3-dev/src/internet/model/ipv4-routing-table-entry.h
191,199d190
<  * \brief Equality operator.
<  *
<  * \param a lhs
<  * \param b rhs
<  * \returns true if operands are equal, false otherwise
<  */
< bool operator== (const Ipv4RoutingTableEntry a, const Ipv4RoutingTableEntry b);
< 
< /**
282,290d272
< 
< /**
<  * \brief Equality operator.
<  *
<  * \param a lhs
<  * \param b rhs
<  * \returns true if operands are equal, false otherwise
<  */
< bool operator== (const Ipv4MulticastRoutingTableEntry a, const Ipv4MulticastRoutingTableEntry b);
diff ../../NS3-WiGig/src/internet/model/ipv4-static-routing.cc ../../ns-3-dev/src/internet/model/ipv4-static-routing.cc
360c360
<   return m_networkRoutes.size ();
---
>   return m_networkRoutes.size ();;
693c693
< Ipv4StaticRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
---
> Ipv4StaticRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const
699,700c699,700
<       << ", Time: " << Now().As (unit)
<       << ", Local time: " << m_ipv4->GetObject<Node> ()->GetLocalTime ().As (unit)
---
>       << ", Time: " << Now().As (Time::S)
>       << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (Time::S)
diff ../../NS3-WiGig/src/internet/model/ipv4-static-routing.h ../../ns-3-dev/src/internet/model/ipv4-static-routing.h
88c88
<   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const;
---
>   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const;
diff ../../NS3-WiGig/src/internet/model/ipv6-address-generator.cc ../../ns-3-dev/src/internet/model/ipv6-address-generator.cc
132,148d131
<    * \brief Check the Ipv6Address allocation in the list of IPv6 entries
<    *
<    * \param addr The Ipv6Address to be checked in the list of Ipv4 entries
<    * \returns true if the network is already allocated
<    */
<   bool IsAddressAllocated (const Ipv6Address addr);
< 
<   /**
<    * \brief Check if a network has already allocated addresses
<    *
<    * \param addr The Ipv6 network to be checked
<    * \param prefix The Ipv6 network prefix
<    * \returns true if the network is already allocated
<    */
<   bool IsNetworkAllocated (const Ipv6Address addr, const Ipv6Prefix prefix);
< 
<   /**
304c287
<   uint8_t nw[16] = { 0 };
---
>   uint8_t nw[16];
311a295,298
>   for (uint32_t j = 16 - a; j < 16; ++j)
>     {
>       nw[j] = 0;
>     }
396c383
<   uint8_t nw[16] = { 0 };
---
>   uint8_t nw[16];
402a390,393
>   for (uint32_t j = 16 - a; j < 16; ++j)
>     {
>       nw[j] = 0;
>     }
424c415
<   uint8_t ad[16] = { 0 };
---
>   uint8_t ad[16];
430a422,425
>   for (uint32_t j = 16 - a; j < 16; ++j)
>     {
>       ad[j] = 0;
>     }
551c546
<       // block down to include the new address.
---
>       // block down to includ the new address.
578,632d572
< bool
< Ipv6AddressGeneratorImpl::IsAddressAllocated (const Ipv6Address address)
< {
<   NS_LOG_FUNCTION (this << address);
< 
<   uint8_t addr[16];
<   address.GetBytes (addr);
< 
<   std::list<Entry>::iterator i;
< 
<   for (i = m_entries.begin (); i != m_entries.end (); ++i)
<     {
<       NS_LOG_LOGIC ("examine entry: " << Ipv6Address ((*i).addrLow) <<
<                     " to " << Ipv6Address ((*i).addrHigh));
< 
<       if (!(Ipv6Address (addr) < Ipv6Address ((*i).addrLow))
<           && ((Ipv6Address (addr) < Ipv6Address ((*i).addrHigh))
<               || (Ipv6Address (addr) == Ipv6Address ((*i).addrHigh))))
<         {
<           NS_LOG_LOGIC ("Ipv6AddressGeneratorImpl::IsAddressAllocated(): Address Collision: " << Ipv6Address (addr));
<           return false;
<         }
<     }
<   return true;
< }
< 
< bool
< Ipv6AddressGeneratorImpl::IsNetworkAllocated (const Ipv6Address address, const Ipv6Prefix prefix)
< {
<   NS_LOG_FUNCTION (this << address << prefix);
< 
<   Ipv6Address addr = address;
<   NS_ABORT_MSG_UNLESS (address == addr.CombinePrefix (prefix),
<                        "Ipv6AddressGeneratorImpl::IsNetworkAllocated(): network address and mask don't match " << address << " " << prefix);
< 
<   std::list<Entry>::iterator i;
< 
<   for (i = m_entries.begin (); i != m_entries.end (); ++i)
<     {
<       NS_LOG_LOGIC ("examine entry: " << Ipv6Address ((*i).addrLow) << " to " << Ipv6Address ((*i).addrHigh));
<       Ipv6Address low = Ipv6Address ((*i).addrLow);
<       Ipv6Address high = Ipv6Address ((*i).addrHigh);
< 
<       if (address == low.CombinePrefix (prefix) || address == high.CombinePrefix (prefix))
<         {
<           NS_LOG_LOGIC ("Ipv6AddressGeneratorImpl::IsNetworkAllocated(): Network already allocated: " <<
<                         address << " " << low << "-" << high);
<           return false;
<         }
< 
<     }
<   return true;
< }
< 
< 
749,766d688
< }
< 
< bool
< Ipv6AddressGenerator::IsAddressAllocated (const Ipv6Address addr)
< {
<   NS_LOG_FUNCTION_NOARGS ();
< 
<   return SimulationSingleton<Ipv6AddressGeneratorImpl>::Get ()
<          ->IsAddressAllocated (addr);
< }
< 
< bool
< Ipv6AddressGenerator::IsNetworkAllocated (const Ipv6Address addr, const Ipv6Prefix prefix)
< {
<   NS_LOG_FUNCTION_NOARGS ();
< 
<   return SimulationSingleton<Ipv6AddressGeneratorImpl>::Get ()
<          ->IsNetworkAllocated (addr, prefix);
diff ../../NS3-WiGig/src/internet/model/ipv6-address-generator.h ../../ns-3-dev/src/internet/model/ipv6-address-generator.h
150,166d149
<    * \brief Check the Ipv6Address allocation in the list of IPv6 entries
<    *
<    * \param addr The Ipv6Address to be checked in the list of Ipv4 entries
<    * \returns true if the address is already allocated
<    */
<   static bool IsAddressAllocated (const Ipv6Address addr);
< 
<   /**
<    * \brief Check if a network has already allocated addresses
<    *
<    * \param addr The Ipv6 network to be checked
<    * \param prefix The Ipv6 network prefix
<    * \returns true if the network is already allocated
<    */
<   static bool IsNetworkAllocated (const Ipv6Address addr, const Ipv6Prefix prefix);
< 
<   /**
diff ../../NS3-WiGig/src/internet/model/ipv6-end-point-demux.cc ../../ns-3-dev/src/internet/model/ipv6-end-point-demux.cc
61c61
< bool Ipv6EndPointDemux::LookupLocal (Ptr<NetDevice> boundNetDevice, Ipv6Address addr, uint16_t port)
---
> bool Ipv6EndPointDemux::LookupLocal (Ipv6Address addr, uint16_t port)
66,68c66,67
<       if ((*i)->GetLocalPort () == port &&
<           (*i)->GetLocalAddress () == addr &&
<           (*i)->GetBoundNetDevice () == boundNetDevice)
---
>       if ((*i)->GetLocalPort () == port
>           && (*i)->GetLocalAddress () == addr)
78c77
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION_NOARGS ();
106c105
< Ipv6EndPoint* Ipv6EndPointDemux::Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port)
---
> Ipv6EndPoint* Ipv6EndPointDemux::Allocate (uint16_t port)
108c107
<   NS_LOG_FUNCTION (this << boundNetDevice << port);
---
>   NS_LOG_FUNCTION (this <<  port);
110c109
<   return Allocate (boundNetDevice, Ipv6Address::GetAny (), port);
---
>   return Allocate (Ipv6Address::GetAny (), port);
113c112
< Ipv6EndPoint* Ipv6EndPointDemux::Allocate (Ptr<NetDevice> boundNetDevice, Ipv6Address address, uint16_t port)
---
> Ipv6EndPoint* Ipv6EndPointDemux::Allocate (Ipv6Address address, uint16_t port)
115,116c114,115
<   NS_LOG_FUNCTION (this << boundNetDevice << address << port);
<   if (LookupLocal (boundNetDevice, address, port) || LookupLocal (0, address, port))
---
>   NS_LOG_FUNCTION (this << address << port);
>   if (LookupLocal (address, port))
118c117
<       NS_LOG_WARN ("Duplicated endpoint.");
---
>       NS_LOG_WARN ("Duplicate address/port; failing.");
127,128c126
< Ipv6EndPoint* Ipv6EndPointDemux::Allocate (Ptr<NetDevice> boundNetDevice,
<                                            Ipv6Address localAddress, uint16_t localPort,
---
> Ipv6EndPoint* Ipv6EndPointDemux::Allocate (Ipv6Address localAddress, uint16_t localPort,
131c129
<   NS_LOG_FUNCTION (this << boundNetDevice << localAddress << localPort << peerAddress << peerPort);
---
>   NS_LOG_FUNCTION (this << localAddress << localPort << peerAddress << peerPort);
134,138c132,135
<       if ((*i)->GetLocalPort () == localPort &&
<           (*i)->GetLocalAddress () == localAddress &&
<           (*i)->GetPeerPort () == peerPort &&
<           (*i)->GetPeerAddress () == peerAddress &&
<           ((*i)->GetBoundNetDevice () == boundNetDevice || (*i)->GetBoundNetDevice () == 0))
---
>       if ((*i)->GetLocalPort () == localPort
>           && (*i)->GetLocalAddress () == localAddress
>           && (*i)->GetPeerPort () == peerPort
>           && (*i)->GetPeerAddress () == peerAddress)
140c137,138
<           NS_LOG_WARN ("Duplicated endpoint.");
---
>           NS_LOG_WARN ("No way we can allocate this end-point.");
>           /* no way we can allocate this end-point. */
155c153
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION_NOARGS ();
280,288c278,291
<   // Here we find the most exact match
<   EndPoints retval;
<   if (!retval4.empty ()) retval = retval4;
<   else if (!retval3.empty ()) retval = retval3;
<   else if (!retval2.empty ()) retval = retval2;
<   else retval = retval1;
< 
<   NS_ABORT_MSG_IF (retval.size () > 1, "Too many endpoints - perhaps you created too many sockets without binding them to different NetDevices.");
<   return retval;  // might be empty if no matches
---
>   /* Here we find the most exact match */
>   if (!retval4.empty ())
>     {
>       return retval4;
>     }
>   if (!retval3.empty ())
>     {
>       return retval3;
>     }
>   if (!retval2.empty ())
>     {
>       return retval2;
>     }
>   return retval1;  /* might be empty if no matches */
333c336
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION_NOARGS ();
diff ../../NS3-WiGig/src/internet/model/ipv6-end-point-demux.h ../../ns-3-dev/src/internet/model/ipv6-end-point-demux.h
63d62
<    * \param boundNetDevice Bound NetDevice (if any)
68c67
<   bool LookupLocal (Ptr<NetDevice> boundNetDevice, Ipv6Address addr, uint16_t port);
---
>   bool LookupLocal (Ipv6Address addr, uint16_t port);
115d113
<    * \param boundNetDevice Bound NetDevice (if any)
119c117
<   Ipv6EndPoint * Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port);
---
>   Ipv6EndPoint * Allocate (uint16_t port);
123d120
<    * \param boundNetDevice Bound NetDevice (if any)
128c125
<   Ipv6EndPoint * Allocate (Ptr<NetDevice> boundNetDevice, Ipv6Address address, uint16_t port);
---
>   Ipv6EndPoint * Allocate (Ipv6Address address, uint16_t port);
132d128
<    * \param boundNetDevice Bound NetDevice (if any)
139,141c135
<   Ipv6EndPoint * Allocate (Ptr<NetDevice> boundNetDevice,
<                            Ipv6Address localAddress, uint16_t localPort,
<                            Ipv6Address peerAddress, uint16_t peerPort);
---
>   Ipv6EndPoint * Allocate (Ipv6Address localAddress, uint16_t localPort, Ipv6Address peerAddress, uint16_t peerPort);
diff ../../NS3-WiGig/src/internet/model/ipv6-end-point.h ../../ns-3-dev/src/internet/model/ipv6-end-point.h
99c99
<    * \brief Set the peer information (address and port).
---
>    * \brief Set the peer informations (address and port).
diff ../../NS3-WiGig/src/internet/model/ipv6-extension.cc ../../ns-3-dev/src/internet/model/ipv6-extension.cc
318,323d317
<     .AddAttribute ("FragmentExpirationTimeout",
<                    "When this timeout expires, the fragments "
<                    "will be cleared from the buffer.",
<                    TimeValue (Seconds (60)),
<                    MakeTimeAccessor (&Ipv6ExtensionFragment::m_fragmentExpirationTimeout),
<                    MakeTimeChecker ())
348,352d341
<   m_timeoutEventList.clear ();
<   if (m_timeoutEvent.IsRunning ())
<     {
<       m_timeoutEvent.Cancel ();
<     }
390c379
<   FragmentKey_t fragmentsId = FragmentKey_t (src, identification);
---
>   std::pair<Ipv6Address, uint32_t> fragmentsId = std::pair<Ipv6Address, uint32_t> (src, identification);
401,402c390,393
<       FragmentsTimeoutsListI_t iter = SetTimeout (fragmentsId, ipHeader);
<       fragments->SetTimeoutIter (iter);
---
>       EventId timeout = Simulator::Schedule (Seconds (60),
>                                              &Ipv6ExtensionFragment::HandleFragmentsTimeout, this,
>                                              fragmentsId, ipHeader);
>       fragments->SetTimeoutEventId (timeout);
421,422c412
< 
<       m_timeoutEventList.erase (fragments->GetTimeoutIter ());
---
>       fragments->CancelTimeout ();
479c469
<           unfragmentablePart.emplace_back (hopbyhopHeader, Ipv6Header::IPV6_EXT_HOP_BY_HOP);
---
>           unfragmentablePart.push_back (std::pair<Ipv6ExtensionHeader *, uint8_t> (hopbyhopHeader, Ipv6Header::IPV6_EXT_HOP_BY_HOP));
503c493
<           unfragmentablePart.emplace_back (routingHeader, Ipv6Header::IPV6_EXT_ROUTING);
---
>           unfragmentablePart.push_back (std::pair<Ipv6ExtensionHeader *, uint8_t> (routingHeader, Ipv6Header::IPV6_EXT_ROUTING));
523c513
<           unfragmentablePart.emplace_back (destinationHeader, Ipv6Header::IPV6_EXT_DESTINATION);
---
>           unfragmentablePart.push_back (std::pair<Ipv6ExtensionHeader *, uint8_t> (destinationHeader, Ipv6Header::IPV6_EXT_DESTINATION));
594c584
<       listFragments.emplace_back (fragment, ipv6Header);
---
>       listFragments.push_back (Ipv6PayloadHeaderPair (fragment, ipv6Header));
607c597
< void Ipv6ExtensionFragment::HandleFragmentsTimeout (FragmentKey_t fragmentsId,
---
> void Ipv6ExtensionFragment::HandleFragmentsTimeout (std::pair<Ipv6Address, uint32_t> fragmentsId,
634,671d623
< 
< Ipv6ExtensionFragment::FragmentsTimeoutsListI_t Ipv6ExtensionFragment::SetTimeout (FragmentKey_t key, Ipv6Header ipHeader)
< {
<   if (m_timeoutEventList.empty ())
<     {
<       m_timeoutEvent = Simulator::Schedule (m_fragmentExpirationTimeout, &Ipv6ExtensionFragment::HandleTimeout, this);
<     }
<   m_timeoutEventList.emplace_back (Simulator::Now () + m_fragmentExpirationTimeout, key, ipHeader);
< 
<   Ipv6ExtensionFragment::FragmentsTimeoutsListI_t iter = --m_timeoutEventList.end();
< 
<   return (iter);
< }
< 
< void Ipv6ExtensionFragment::HandleTimeout (void)
< {
<   Time now = Simulator::Now ();
< 
<   while (!m_timeoutEventList.empty () && std::get<0> (*m_timeoutEventList.begin ()) == now)
<     {
<       HandleFragmentsTimeout (std::get<1> (*m_timeoutEventList.begin ()),
<                               std::get<2> (*m_timeoutEventList.begin ()));
<       m_timeoutEventList.pop_front ();
<     }
< 
<   if (m_timeoutEventList.empty ())
<     {
<       return;
<     }
< 
<   Time difference = std::get<0> (*m_timeoutEventList.begin ()) - now;
<   m_timeoutEvent = Simulator::Schedule (difference, &Ipv6ExtensionFragment::HandleTimeout, this);
< 
<   return;
< }
< 
< 
< 
769c721
< void Ipv6ExtensionFragment::Fragments::SetTimeoutIter (FragmentsTimeoutsListI_t iter)
---
> void Ipv6ExtensionFragment::Fragments::SetTimeoutEventId (EventId event)
771c723
<   m_timeoutIter = iter;
---
>   m_timeoutEventId = event;
775c727
< Ipv6ExtensionFragment::FragmentsTimeoutsListI_t Ipv6ExtensionFragment::Fragments::GetTimeoutIter ()
---
> void Ipv6ExtensionFragment::Fragments::CancelTimeout ()
777c729,730
<   return m_timeoutIter;
---
>   m_timeoutEventId.Cancel ();
>   return;
diff ../../NS3-WiGig/src/internet/model/ipv6-extension.h ../../ns-3-dev/src/internet/model/ipv6-extension.h
26d25
< #include <tuple>
320,334d318
< 
<   /**
<    * Key identifying a fragmented packet
<    */
<   typedef std::pair<Ipv6Address, uint32_t> FragmentKey_t;
< 
<   /**
<    * Container for fragment timeouts.
<    */
<   typedef std::list< std::tuple <Time, FragmentKey_t, Ipv6Header > > FragmentsTimeoutsList_t;
<   /**
<    * Container Iterator for fragment timeouts.
<    */
<   typedef std::list< std::tuple <Time, FragmentKey_t, Ipv6Header > >::iterator FragmentsTimeoutsListI_t;
< 
386,387c370
<      * \brief Set the Timeout iterator.
<      * \param iter The iterator.
---
>      * \brief Set the Timeout EventId.
389c372
<     void SetTimeoutIter (FragmentsTimeoutsListI_t iter);
---
>     void SetTimeoutEventId (EventId event);
392,393c375
<      * \brief Get the Timeout iterator.
<      * \returns The iterator.
---
>      * \brief Cancel the timeout event
395c377
<     FragmentsTimeoutsListI_t GetTimeoutIter ();
---
>     void CancelTimeout ();
414c396
<      * \brief Timeout iterator to "event" handler
---
>      * \brief Timeout handler event
416c398
<     FragmentsTimeoutsListI_t m_timeoutIter;
---
>     EventId m_timeoutEventId;
424c406
<   void HandleFragmentsTimeout (FragmentKey_t key, Ipv6Header ipHeader);
---
>   void HandleFragmentsTimeout (std::pair<Ipv6Address, uint32_t> key, Ipv6Header ipHeader);
434d415
<    * \param event The event.
446c427
<   typedef std::map<FragmentKey_t, Ptr<Fragments> > MapFragments_t;
---
>   typedef std::map<std::pair<Ipv6Address, uint32_t>, Ptr<Fragments> > MapFragments_t;
452,468d432
< 
<   /**
<    * \brief Set a new timeout "event" for a fragmented packet
<    * \param key the fragment identification
<    * \param ipHeader the IPv6 header of the fragmented packet
<    * \return an iterator to the inserted "event"
<    */
<   FragmentsTimeoutsListI_t SetTimeout (FragmentKey_t key, Ipv6Header ipHeader);
< 
<   /**
<    * \brief Handles a fragmented packet timeout
<    */
<   void HandleTimeout (void);
< 
<   FragmentsTimeoutsList_t m_timeoutEventList;  //!< Timeout "events" container
<   EventId m_timeoutEvent;  //!< Event for the next scheduled timeout
<   Time m_fragmentExpirationTimeout; //!< Expiration timeout
diff ../../NS3-WiGig/src/internet/model/ipv6-extension-header.h ../../ns-3-dev/src/internet/model/ipv6-extension-header.h
90c90
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
249c249
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
306c306
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
399c399
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
491c491
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
591c591
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
659c659
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
716c716
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
diff ../../NS3-WiGig/src/internet/model/ipv6-header.cc ../../ns-3-dev/src/internet/model/ipv6-header.cc
195,201d194
< void Ipv6Header::SetEcn (EcnType ecn)
< {
<   NS_LOG_FUNCTION (this << ecn);
<   m_trafficClass &= 0xFC; // Clear out the ECN part, retain 6 bits of DSCP
<   m_trafficClass |= ecn;
< }
< 
261,285d253
< Ipv6Header::EcnType
< Ipv6Header::GetEcn (void) const
< {
<   NS_LOG_FUNCTION (this);
<   // Extract only last 2 bits of Traffic Class byte, i.e 0x3
<   return EcnType (m_trafficClass & 0x3);
< }
< 
< std::string Ipv6Header::EcnTypeToString (EcnType ecn) const
< {
<   NS_LOG_FUNCTION (this << ecn);
<   switch (ecn)
<     {
<       case ECN_NotECT:
<         return "Not-ECT";
<       case ECN_ECT1:
<         return "ECT (1)";
<       case ECN_ECT0:
<         return "ECT (0)";
<       case ECN_CE:
<         return "CE";
<       default:
<         return "Unknown ECN codepoint";
<     };
< }
diff ../../NS3-WiGig/src/internet/model/ipv6-header.h ../../ns-3-dev/src/internet/model/ipv6-header.h
148,177d147
<    * \enum EcnType
<    * \brief ECN field bits
<    */
<   enum EcnType
<    {
<      // Prefixed with "ECN" to avoid name clash
<      ECN_NotECT = 0x00,
<      ECN_ECT1 = 0x01,
<      ECN_ECT0 = 0x02,
<      ECN_CE = 0x03
<    };
< 
<   /**
<    * \brief Set ECN field bits
<    * \param ecn ECN field bits
<    */
<   void SetEcn (EcnType ecn);
< 
<   /**
<    * \return the ECN field bits of this packet.
<    */
<   EcnType GetEcn (void) const;
< 
<   /**
<    * \param ecn the ECNType
<    * \return std::string of ECNType
<    */
<   std::string EcnTypeToString (EcnType ecn) const;
< 
<   /**
250c220
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
diff ../../NS3-WiGig/src/internet/model/ipv6-interface.cc ../../ns-3-dev/src/internet/model/ipv6-interface.cc
27d26
< #include "ns3/traffic-control-layer.h"
116,121d114
<       else if (Mac8Address::IsMatchingType (addr))
<         {
<           Ipv6InterfaceAddress ifaddr = Ipv6InterfaceAddress (Ipv6Address::MakeAutoconfiguredLinkLocalAddress (Mac8Address::ConvertFrom (addr)), Ipv6Prefix (64));
<           AddAddress (ifaddr);
<           m_linkLocalAddress = ifaddr;
<         }
131,132d123
<   int32_t interfaceId = m_node->GetObject<Ipv6> ()->GetInterfaceForDevice (m_device);
<   Ptr<Icmpv6L4Protocol> icmpv6 = DynamicCast<Icmpv6L4Protocol> (m_node->GetObject<Ipv6> ()->GetProtocol (Icmpv6L4Protocol::GetStaticProtocolNumber (), interfaceId));
133a125,130
>   Ptr<IpL4Protocol> proto = m_node->GetObject<Ipv6> ()->GetProtocol (Icmpv6L4Protocol::GetStaticProtocolNumber ());
>   Ptr<Icmpv6L4Protocol> icmpv6;
>   if (proto)
>     {
>       icmpv6 = proto->GetObject <Icmpv6L4Protocol> ();
>     }
143a141
>   DoSetup ();
149a148
>   DoSetup ();
243,245c242,247
< 
<           int32_t interfaceId = m_node->GetObject<Ipv6> ()->GetInterfaceForDevice (m_device);
<           Ptr<Icmpv6L4Protocol> icmpv6 = DynamicCast<Icmpv6L4Protocol> (m_node->GetObject<Ipv6> ()->GetProtocol (Icmpv6L4Protocol::GetStaticProtocolNumber (), interfaceId));
---
>           Ptr<IpL4Protocol> proto = m_node->GetObject<Ipv6> ()->GetProtocol (Icmpv6L4Protocol::GetStaticProtocolNumber ());
>           Ptr<Icmpv6L4Protocol> icmpv6;
>           if (proto)
>             {
>               icmpv6 = proto->GetObject <Icmpv6L4Protocol> ();
>             }
249,257c251,252
<               if (icmpv6->IsAlwaysDad ())
<                 {
<                   Simulator::Schedule (Seconds (0.), &Icmpv6L4Protocol::DoDAD, icmpv6, addr, this);
<                   Simulator::Schedule (Seconds (1.), &Icmpv6L4Protocol::FunctionDadTimeout, icmpv6, this, addr);
<                 }
<               else
<                 {
<                   Simulator::Schedule (Seconds (0.), &Icmpv6L4Protocol::FunctionDadTimeout, icmpv6, this, addr);
<                 }
---
>               Simulator::Schedule (Seconds (0.), &Icmpv6L4Protocol::DoDAD, icmpv6, addr, this);
>               Simulator::Schedule (Seconds (1.), &Icmpv6L4Protocol::FunctionDadTimeout, icmpv6, this, addr);
431,435c426,427
<       NS_LOG_LOGIC ("Needs NDISC " << dest);
< 
<       int32_t interfaceId = m_node->GetObject<Ipv6> ()->GetInterfaceForDevice (m_device);
<       Ptr<Icmpv6L4Protocol> icmpv6 = DynamicCast<Icmpv6L4Protocol> (m_node->GetObject<Ipv6> ()->GetProtocol (Icmpv6L4Protocol::GetStaticProtocolNumber (), interfaceId));
< 
---
>       NS_LOG_LOGIC ("Needs ARP" << " " << dest);
>       Ptr<Icmpv6L4Protocol> icmpv6 = ipv6->GetIcmpv6 ();
463c455
<       NS_LOG_LOGIC ("Doesn't need NDISC");
---
>       NS_LOG_LOGIC ("Doesn't need ARP");
diff ../../NS3-WiGig/src/internet/model/ipv6-interface.h ../../ns-3-dev/src/internet/model/ipv6-interface.h
27a28
> #include "ns3/traffic-control-layer.h"
39d39
< class TrafficControlLayer;
282,298d281
<   /**
<    * \brief Copy constructor
<    * \param o object to copy
<    *
<    * Defined and unimplemented to avoid misuse
<    */
<   Ipv6Interface (const Ipv6Interface &o);
< 
<   /**
<    * \brief Assignment operator
<    * \param o object to copy
<    * \returns the copied object
<    *
<    * Defined and unimplemented to avoid misuse
<    */
<   Ipv6Interface &operator = (const Ipv6Interface &o);
< 
diff ../../NS3-WiGig/src/internet/model/ipv6-l3-protocol.cc ../../ns-3-dev/src/internet/model/ipv6-l3-protocol.cc
47d46
< #include "ipv6-raw-socket-factory-impl.h"
131,133d129
<   
<   Ptr<Ipv6RawSocketFactoryImpl> rawFactoryImpl = CreateObject<Ipv6RawSocketFactoryImpl> ();
<   AggregateObject (rawFactoryImpl);
213a210
>   tc->SetupDevice (device);
230a228
>   uint32_t tmp = 0;
232c230
<   if (index < m_interfaces.size ())
---
>   for (Ipv6InterfaceList::const_iterator it = m_interfaces.begin (); it != m_interfaces.end (); it++)
234c232,236
<       return m_interfaces[index];
---
>       if (index == tmp)
>         {
>           return *it;
>         }
>       tmp++;
709d710
<   
902c903,904
<       NS_LOG_LOGIC ("Ipv6L3Protocol::Send case 2: probably sent to machine on same IPv6 network");
---
>       NS_LOG_LOGIC ("Ipv6L3Protocol::Send case 1: probably sent to machine on same IPv6 network");
>       /* NS_FATAL_ERROR ("This case is not yet implemented"); */
1067c1069
<               if (addr == hdr.GetDestinationAddress ())
---
>               if (addr.IsEqual (hdr.GetDestinationAddress ()))
1167c1169
<   if (route->GetGateway () != Ipv6Address::GetAny ())
---
>   if (!route->GetGateway ().IsEqual (Ipv6Address::GetAny ()))
diff ../../NS3-WiGig/src/internet/model/ipv6-l3-protocol.h ../../ns-3-dev/src/internet/model/ipv6-l3-protocol.h
465,468c465
<   /**
<    * \brief Ipv6L3ProtocolTestCase test case.
<    * \relates Ipv6L3ProtocolTestCase
<    */
---
>   /* for unit-tests */
470,473d466
<   /**
<    * \brief Ipv6ExtensionLooseRouting.
<    * \relates Ipv6ExtensionLooseRouting
<    */
diff ../../NS3-WiGig/src/internet/model/ipv6-list-routing.cc ../../ns-3-dev/src/internet/model/ipv6-list-routing.cc
213c213
< Ipv6ListRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
---
> Ipv6ListRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const
218,219c218,219
<                         << ", Time: " << Now().As (unit)
<                         << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (unit)
---
>                         << ", Time: " << Now().As (Time::S)
>                         << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (Time::S)
225c225
<       (*i).second->PrintRoutingTable (stream, unit);
---
>       (*i).second->PrintRoutingTable (stream);
diff ../../NS3-WiGig/src/internet/model/ipv6-list-routing.h ../../ns-3-dev/src/internet/model/ipv6-list-routing.h
101c101,107
<   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const;
---
> 
>   /**
>    * \brief Print the Routing Table entries
>    *
>    * \param stream the ostream the Routing table is printed to
>    */
>   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const;
diff ../../NS3-WiGig/src/internet/model/ipv6-option-header.h ../../ns-3-dev/src/internet/model/ipv6-option-header.h
100c100
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
182c182
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
240c240
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
309c309
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
379d378
<    * \param value the value to be set.
390c389
<    * \brief Print some information about the packet.
---
>    * \brief Print some informations about the packet.
diff ../../NS3-WiGig/src/internet/model/ipv6-packet-filter.cc ../../ns-3-dev/src/internet/model/ipv6-packet-filter.cc
26d25
< #include "ns3/uinteger.h"
66a66,147
> NS_OBJECT_ENSURE_REGISTERED (FqCoDelIpv6PacketFilter);
> 
> TypeId
> FqCoDelIpv6PacketFilter::GetTypeId (void)
> {
>   static TypeId tid = TypeId ("ns3::FqCoDelIpv6PacketFilter")
>     .SetParent<Ipv6PacketFilter> ()
>     .SetGroupName ("Internet")
>     .AddConstructor<FqCoDelIpv6PacketFilter> ()
>     .AddAttribute ("Perturbation",
>                    "The salt used as an additional input to the hash function of this filter",
>                    UintegerValue (0),
>                    MakeUintegerAccessor (&FqCoDelIpv6PacketFilter::m_perturbation),
>                    MakeUintegerChecker<uint32_t> ())
>   ;
>   return tid;
> }
> 
> FqCoDelIpv6PacketFilter::FqCoDelIpv6PacketFilter ()
> {
>   NS_LOG_FUNCTION (this);
> }
> 
> FqCoDelIpv6PacketFilter::~FqCoDelIpv6PacketFilter ()
> {
>   NS_LOG_FUNCTION (this);
> }
> 
> int32_t
> FqCoDelIpv6PacketFilter::DoClassify (Ptr< QueueDiscItem > item) const
> {
>   NS_LOG_FUNCTION (this << item);
>   Ptr<Ipv6QueueDiscItem> ipv6Item = DynamicCast<Ipv6QueueDiscItem> (item);
> 
>   NS_ASSERT (ipv6Item != 0);
> 
>   Ipv6Header hdr = ipv6Item->GetHeader ();
>   Ipv6Address src = hdr.GetSourceAddress ();
>   Ipv6Address dest = hdr.GetDestinationAddress ();
>   uint8_t prot = hdr.GetNextHeader ();
> 
>   TcpHeader tcpHdr;
>   UdpHeader udpHdr;
>   uint16_t srcPort = 0;
>   uint16_t destPort = 0;
> 
>   Ptr<Packet> pkt = ipv6Item->GetPacket ();
> 
>   if (prot == 6) // TCP
>     {
>       pkt->PeekHeader (tcpHdr);
>       srcPort = tcpHdr.GetSourcePort ();
>       destPort = tcpHdr.GetDestinationPort ();
>     }
>   else if (prot == 17) // UDP
>     {
>       pkt->PeekHeader (udpHdr);
>       srcPort = udpHdr.GetSourcePort ();
>       destPort = udpHdr.GetDestinationPort ();
>     }
> 
>   /* serialize the 5-tuple and the perturbation in buf */
>   uint8_t buf[41];
>   src.Serialize (buf);
>   dest.Serialize (buf + 16);
>   buf[32] = prot;
>   buf[33] = (srcPort >> 8) & 0xff;
>   buf[34] = srcPort & 0xff;
>   buf[35] = (destPort >> 8) & 0xff;
>   buf[36] = destPort & 0xff;
>   buf[37] = (m_perturbation >> 24) & 0xff;
>   buf[38] = (m_perturbation >> 16) & 0xff;
>   buf[39] = (m_perturbation >> 8) & 0xff;
>   buf[40] = m_perturbation & 0xff;
> 
>   /* Linux calculates the jhash2 (jenkins hash), we calculate the murmur3 */
>   uint32_t hash = Hash32 ((char*) buf, 41);
> 
>   NS_LOG_DEBUG ("Found Ipv6 packet; hash of the five tuple " << hash);
> 
>   return hash;
> }
diff ../../NS3-WiGig/src/internet/model/ipv6-packet-filter.h ../../ns-3-dev/src/internet/model/ipv6-packet-filter.h
53a54,78
> 
> /**
>  * \ingroup internet
>  *
>  * FqCoDelIpv6PacketFilter is the filter to be added to the FQCoDel
>  * queue disc to simulate the behavior of the fq-codel Linux queue disc.
>  *
>  */
> class FqCoDelIpv6PacketFilter : public Ipv6PacketFilter {
> public:
>   /**
>    * \brief Get the type ID.
>    * \return the object TypeId
>    */
>   static TypeId GetTypeId (void);
> 
>   FqCoDelIpv6PacketFilter ();
>   virtual ~FqCoDelIpv6PacketFilter ();
> 
> private:
>   virtual int32_t DoClassify (Ptr<QueueDiscItem> item) const;
> 
>   uint32_t m_perturbation; //!< hash perturbation value
> };
> 
diff ../../NS3-WiGig/src/internet/model/ipv6-queue-disc-item.cc ../../ns-3-dev/src/internet/model/ipv6-queue-disc-item.cc
21,22d20
< #include "ns3/tcp-header.h"
< #include "ns3/udp-header.h"
36c34
< Ipv6QueueDiscItem::~Ipv6QueueDiscItem ()
---
> Ipv6QueueDiscItem::~Ipv6QueueDiscItem()
41c39
< uint32_t Ipv6QueueDiscItem::GetSize (void) const
---
> uint32_t Ipv6QueueDiscItem::GetPacketSize(void) const
43d40
<   NS_LOG_FUNCTION (this);
60c57
< void Ipv6QueueDiscItem::AddHeader (void)
---
> void Ipv6QueueDiscItem::AddHeader(void)
86,97d82
< Ipv6QueueDiscItem::Mark (void)
< {
<   NS_LOG_FUNCTION (this);
<   if (!m_headerAdded && m_header.GetEcn () != Ipv6Header::ECN_NotECT)
<     {
<       m_header.SetEcn (Ipv6Header::ECN_CE);
<       return true;
<     }
<   return false;
< }
< 
< bool
111,164d95
< }
< 
< uint32_t
< Ipv6QueueDiscItem::Hash (uint32_t perturbation) const
< {
<   NS_LOG_FUNCTION (this << perturbation);
< 
<   Ipv6Address src = m_header.GetSourceAddress ();
<   Ipv6Address dest = m_header.GetDestinationAddress ();
<   uint8_t prot = m_header.GetNextHeader ();
< 
<   TcpHeader tcpHdr;
<   UdpHeader udpHdr;
<   uint16_t srcPort = 0;
<   uint16_t destPort = 0;
< 
<   if (prot == 6) // TCP
<     {
<       GetPacket ()->PeekHeader (tcpHdr);
<       srcPort = tcpHdr.GetSourcePort ();
<       destPort = tcpHdr.GetDestinationPort ();
<     }
<   else if (prot == 17) // UDP
<     {
<       GetPacket ()->PeekHeader (udpHdr);
<       srcPort = udpHdr.GetSourcePort ();
<       destPort = udpHdr.GetDestinationPort ();
<     }
<   if (prot != 6 && prot != 17)
<     {
<       NS_LOG_WARN ("Unknown transport protocol, no port number included in hash computation");
<     }
< 
<   /* serialize the 5-tuple and the perturbation in buf */
<   uint8_t buf[41];
<   src.Serialize (buf);
<   dest.Serialize (buf + 16);
<   buf[32] = prot;
<   buf[33] = (srcPort >> 8) & 0xff;
<   buf[34] = srcPort & 0xff;
<   buf[35] = (destPort >> 8) & 0xff;
<   buf[36] = destPort & 0xff;
<   buf[37] = (perturbation >> 24) & 0xff;
<   buf[38] = (perturbation >> 16) & 0xff;
<   buf[39] = (perturbation >> 8) & 0xff;
<   buf[40] = perturbation & 0xff;
< 
<   // Linux calculates jhash2 (jenkins hash), we calculate murmur3 because it is
<   // already available in ns-3
<   uint32_t hash = Hash32 ((char*) buf, 41);
< 
<   NS_LOG_DEBUG ("Found Ipv6 packet; hash of the five tuple " << hash);
< 
<   return hash;
diff ../../NS3-WiGig/src/internet/model/ipv6-queue-disc-item.h ../../ns-3-dev/src/internet/model/ipv6-queue-disc-item.h
23c23,26
< #include "ns3/queue-item.h"
---
> #include "ns3/object.h"
> #include "ns3/net-device.h"
> #include "ns3/traced-value.h"
> #include "ns3/queue-disc.h"
52c55
<   virtual uint32_t GetSize (void) const;
---
>   virtual uint32_t GetPacketSize (void) const;
78,95d80
< 
<   /**
<    * \brief Marks the packet by setting ECN_CE bits if the packet has ECN_ECT0 or ECN_ECT1 bits set
<    * \return true if the packet gets marked, false otherwise
<    */
<   virtual bool Mark (void);
< 
<   /**
<    * \brief Computes the hash of the packet's 5-tuple
<    *
<    * Computes the hash of the source and destination IP addresses, protocol
<    * number and, if the transport protocol is either UDP or TCP, the source
<    * and destination port
<    *
<    * \param perturbation hash perturbation value
<    * \return the hash of the packet's 5-tuple
<    */
<   virtual uint32_t Hash (uint32_t perturbation) const;
diff ../../NS3-WiGig/src/internet/model/ipv6-raw-socket-factory-impl.h ../../ns-3-dev/src/internet/model/ipv6-raw-socket-factory-impl.h
40d39
<    * \returns A new RAW IPv6 socket.
diff ../../NS3-WiGig/src/internet/model/ipv6-raw-socket-impl.cc ../../ns-3-dev/src/internet/model/ipv6-raw-socket-impl.cc
248c248
<       Ptr<NetDevice> oif = m_boundnetdevice; //specify non-zero if bound to a specific device
---
>       Ptr<NetDevice> oif (0); /*specify non-zero if bound to a source address */
diff ../../NS3-WiGig/src/internet/model/ipv6-routing-protocol.h ../../ns-3-dev/src/internet/model/ipv6-routing-protocol.h
33d32
< #include "ns3/nstime.h"
195,196c194
<    * \param stream The ostream the Routing table is printed to
<    * \param unit The time unit to be used in the report
---
>    * \param stream the ostream the Routing table is printed to
198,199c196
<   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const = 0;
< 
---
>   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const = 0;
diff ../../NS3-WiGig/src/internet/model/ipv6-routing-table-entry.cc ../../ns-3-dev/src/internet/model/ipv6-routing-table-entry.cc
111c111
<   if (m_destNetworkPrefix == Ipv6Prefix::GetOnes ())
---
>   if (m_destNetworkPrefix.IsEqual (Ipv6Prefix::GetOnes ()))
140c140
<   if (m_dest == Ipv6Address::GetZero ())
---
>   if (m_dest.IsEqual (Ipv6Address::GetZero ()))
159c159
<   if (m_gateway == Ipv6Address::GetZero ())
---
>   if (m_gateway.IsEqual (Ipv6Address::GetZero ()))
diff ../../NS3-WiGig/src/internet/model/ipv6-static-routing.cc ../../ns-3-dev/src/internet/model/ipv6-static-routing.cc
82c82
< Ipv6StaticRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
---
> Ipv6StaticRouting::PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const
88,89c88,89
<       << ", Time: " << Now().As (unit)
<       << ", Local time: " << m_ipv6->GetObject<Node> ()->GetLocalTime ().As (unit)
---
>       << ", Time: " << Now().As (Time::S)
>       << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (Time::S)
diff ../../NS3-WiGig/src/internet/model/ipv6-static-routing.h ../../ns-3-dev/src/internet/model/ipv6-static-routing.h
240c240,246
<   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const;
---
> 
>   /**
>    * \brief Print the Routing Table entries
>    *
>    * \param stream the ostream the Routing table is printed to
>    */
>   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const;
diff ../../NS3-WiGig/src/internet/model/ndisc-cache.cc ../../ns-3-dev/src/internet/model/ndisc-cache.cc
69d68
<   m_icmpv6 = 0;
73c72
< void NdiscCache::SetDevice (Ptr<NetDevice> device, Ptr<Ipv6Interface> interface, Ptr<Icmpv6L4Protocol> icmpv6)
---
> void NdiscCache::SetDevice (Ptr<NetDevice> device, Ptr<Ipv6Interface> interface)
78d76
<   m_icmpv6 = icmpv6;
100d97
<       NS_LOG_LOGIC ("Found an entry:" << dst << " to " << entry->GetMacAddress ());
103d99
<   NS_LOG_LOGIC ("Nothing found");
117d112
<           NS_LOG_LOGIC ("Found an entry:" << (*i).first << " to " << (*i).second);
278a274
>   Ptr<Icmpv6L4Protocol> icmpv6 = m_ndCache->GetDevice ()->GetNode ()->GetObject<Ipv6L3Protocol> ()->GetIcmpv6 ();
284c280
<       addr = m_ndCache->GetInterface ()->GetLinkLocalAddress ().GetAddress ();
---
>       addr = m_ndCache->GetInterface ()->GetLinkLocalAddress ().GetAddress ();;
298c294
<   if (m_nsRetransmit < m_ndCache->m_icmpv6->GetMaxMulticastSolicit ())
---
>   if (m_nsRetransmit < icmpv6->MAX_MULTICAST_SOLICIT)
302c298
<       m_ndCache->m_icmpv6->SendNS (addr, Ipv6Address::MakeSolicitedAddress (m_ipv6Address), m_ipv6Address, m_ndCache->GetDevice ()->GetAddress ());
---
>       icmpv6->SendNS (addr, Ipv6Address::MakeSolicitedAddress (m_ipv6Address), m_ipv6Address, m_ndCache->GetDevice ()->GetAddress ());
318c314
<       m_ndCache->m_icmpv6->SendErrorDestinationUnreachable (malformedPacket.first, addr, Icmpv6Header::ICMPV6_ADDR_UNREACHABLE);
---
>       icmpv6->SendErrorDestinationUnreachable (malformedPacket.first, addr, Icmpv6Header::ICMPV6_ADDR_UNREACHABLE);
327a324,325
>   Ptr<Ipv6L3Protocol> ipv6 = m_ndCache->GetDevice ()->GetNode ()->GetObject<Ipv6L3Protocol> ();
>   Ptr<Icmpv6L4Protocol> icmpv6 = ipv6->GetIcmpv6 ();
352c350
<   Ipv6PayloadHeaderPair p = m_ndCache->m_icmpv6->ForgeNS (addr, m_ipv6Address, m_ipv6Address, m_ndCache->GetDevice ()->GetAddress ());
---
>   Ipv6PayloadHeaderPair p = icmpv6->ForgeNS (addr, m_ipv6Address, m_ipv6Address, m_ndCache->GetDevice ()->GetAddress ());
362a361,362
>   Ptr<Ipv6L3Protocol> ipv6 = m_ndCache->GetDevice ()->GetNode ()->GetObject<Ipv6L3Protocol> ();
>   Ptr<Icmpv6L4Protocol> icmpv6 = ipv6->GetIcmpv6 ();
364c364
<   if (m_nsRetransmit < m_ndCache->m_icmpv6->GetMaxUnicastSolicit ())
---
>   if (m_nsRetransmit < icmpv6->MAX_UNICAST_SOLICIT)
391c391
<       Ipv6PayloadHeaderPair p = m_ndCache->m_icmpv6->ForgeNS (addr, m_ipv6Address, m_ipv6Address, m_ndCache->GetDevice ()->GetAddress ());
---
>       Ipv6PayloadHeaderPair p = icmpv6->ForgeNS (addr, m_ipv6Address, m_ipv6Address, m_ndCache->GetDevice ()->GetAddress ());
427c427
<   m_nudTimer.SetDelay (m_ndCache->m_icmpv6->GetReachableTime ());
---
>   m_nudTimer.SetDelay (MilliSeconds (Icmpv6L4Protocol::REACHABLE_TIME));
453d452
< 
455c454
<   m_nudTimer.SetDelay (m_ndCache->m_icmpv6->GetRetransmissionTime ());
---
>   m_nudTimer.SetDelay (MilliSeconds (Icmpv6L4Protocol::RETRANS_TIMER));
466d464
< 
468c466
<   m_nudTimer.SetDelay (m_ndCache->m_icmpv6->GetDelayFirstProbe ());
---
>   m_nudTimer.SetDelay (Seconds (Icmpv6L4Protocol::DELAY_FIRST_PROBE_TIME));
479d476
< 
481c478
<   m_nudTimer.SetDelay (m_ndCache->m_icmpv6->GetRetransmissionTime ());
---
>   m_nudTimer.SetDelay (MilliSeconds (Icmpv6L4Protocol::RETRANS_TIMER));
diff ../../NS3-WiGig/src/internet/model/ndisc-cache.h ../../ns-3-dev/src/internet/model/ndisc-cache.h
42d41
< class Icmpv6L4Protocol;
83d81
<    * \returns The Ipv6Interface.
135d132
<    * \param icmpv6 the ICMPv6 protocol
137c134
<   void SetDevice (Ptr<NetDevice> device, Ptr<Ipv6Interface> interface, Ptr<Icmpv6L4Protocol> icmpv6);
---
>   void SetDevice (Ptr<NetDevice> device, Ptr<Ipv6Interface> interface);
444,448d440
< 
<   /**
<    * \brief the icmpv6 L4 protocol for this cache.
<    */
<   Ptr<Icmpv6L4Protocol> m_icmpv6;
diff ../../NS3-WiGig/src/internet/model/nsc-sysctl.h ../../ns-3-dev/src/internet/model/nsc-sysctl.h
51,54d50
<   /**
<    * \brief NscStackStringAccessor friend class.
<    * \relates NscStackStringAccessor
<    */
diff ../../NS3-WiGig/src/internet/model/nsc-tcp-l4-protocol.cc ../../ns-3-dev/src/internet/model/nsc-tcp-l4-protocol.cc
312c312
< NscTcpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port)
---
> NscTcpL4Protocol::Allocate (uint16_t port)
314,315c314,315
<   NS_LOG_FUNCTION (this << boundNetDevice << port);
<   return m_endPoints->Allocate (boundNetDevice, port);
---
>   NS_LOG_FUNCTION (this << port);
>   return m_endPoints->Allocate (port);
319c319
< NscTcpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port)
---
> NscTcpL4Protocol::Allocate (Ipv4Address address, uint16_t port)
321,322c321,322
<   NS_LOG_FUNCTION (this << boundNetDevice << address << port);
<   return m_endPoints->Allocate (boundNetDevice, address, port);
---
>   NS_LOG_FUNCTION (this << address << port);
>   return m_endPoints->Allocate (address, port);
326,327c326
< NscTcpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, 
<                             Ipv4Address localAddress, uint16_t localPort,
---
> NscTcpL4Protocol::Allocate (Ipv4Address localAddress, uint16_t localPort,
330,332c329,330
<   NS_LOG_FUNCTION (this << boundNetDevice << localAddress << localPort << peerAddress << peerPort);
<   return m_endPoints->Allocate (boundNetDevice,
<                                 localAddress, localPort,
---
>   NS_LOG_FUNCTION (this << localAddress << localPort << peerAddress << peerPort);
>   return m_endPoints->Allocate (localAddress, localPort,
diff ../../NS3-WiGig/src/internet/model/nsc-tcp-l4-protocol.h ../../ns-3-dev/src/internet/model/nsc-tcp-l4-protocol.h
40d39
< class NetDevice;
103d101
<    * \param boundNetDevice Bound NetDevice (if any)
107c105
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port);
---
>   Ipv4EndPoint *Allocate (uint16_t port);
110d107
<    * \param boundNetDevice Bound NetDevice (if any)
115c112
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port);
---
>   Ipv4EndPoint *Allocate (Ipv4Address address, uint16_t port);
118d114
<    * \param boundNetDevice Bound NetDevice (if any)
125,126c121
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice,
<                           Ipv4Address localAddress, uint16_t localPort,
---
>   Ipv4EndPoint *Allocate (Ipv4Address localAddress, uint16_t localPort,
208,211d202
<   /**
<    * \brief NscInterfaceImpl friend class.
<    * \relates NscInterfaceImpl
<    */
213,216d203
<   /**
<    * \brief NscTcpSocketImpl friend class.
<    * \relates NscTcpSocketImpl
<    */
diff ../../NS3-WiGig/src/internet/model/nsc-tcp-socket-impl.cc ../../ns-3-dev/src/internet/model/nsc-tcp-socket-impl.cc
253c253
<       m_endPoint = m_tcp->Allocate (GetBoundNetDevice (), port);
---
>       m_endPoint = m_tcp->Allocate (port);
263c263
<       m_endPoint = m_tcp->Allocate (GetBoundNetDevice (), ipv4, port);
---
>       m_endPoint = m_tcp->Allocate (ipv4, port);
271,283d270
< /* Inherit from Socket class: Bind this socket to the specified NetDevice */
< void
< NscTcpSocketImpl::BindToNetDevice (Ptr<NetDevice> netdevice)
< {
<   NS_LOG_FUNCTION (this << netdevice);
<   Socket::BindToNetDevice (netdevice); // Includes sanity check
<   if (m_endPoint != 0)
<     {
<       m_endPoint->BindToNetDevice (netdevice);
<     }
<   return;
< }
< 
427d413
<   NS_LOG_FUNCTION (this);
437,446c423
<         {
<           Simulator::ScheduleNow (&NscTcpSocketImpl::SendPendingData, this);
<         }
<       else
<         {
<           if (GetTxAvailable ())
<             {
<               NotifySend (GetTxAvailable ());
<             }
<         }
---
>         Simulator::ScheduleNow (&NscTcpSocketImpl::SendPendingData, this);
712d688
<       NS_LOG_DEBUG ("Notifying data sent, remaining txbuffer size: " << m_txBufferSize);
716,719d691
<   else
<     {
<       NS_LOG_DEBUG ("Not notifying data sent, return value " << ret);
<     }
900c872
<     case NSC_EINPROGRESS:   // Although nsc sockets are nonblocking, we pretend they're not.
---
>     case NSC_EINPROGRESS:   // Altough nsc sockets are nonblocking, we pretend they're not.
diff ../../NS3-WiGig/src/internet/model/nsc-tcp-socket-impl.h ../../ns-3-dev/src/internet/model/nsc-tcp-socket-impl.h
108d107
<   virtual void BindToNetDevice (Ptr<NetDevice> netdevice); // NetDevice with my m_endPoint
117,120d115
<   /**
<    * \brief Tcp friend class.
<    * \relates Tcp
<    */
diff ../../NS3-WiGig/src/internet/model/pending-data.cc ../../ns-3-dev/src/internet/model/pending-data.cc
250c250
< } //namespace ns3
---
> } //namepsace ns3
diff ../../NS3-WiGig/src/internet/model/pending-data.h ../../ns-3-dev/src/internet/model/pending-data.h
182c182
< } //namespace ns3
---
> } //namepsace ns3
diff ../../NS3-WiGig/src/internet/model/rip.cc ../../ns-3-dev/src/internet/model/rip.cc
147d146
<               socket->BindToNetDevice (m_ipv4->GetNetDevice (i));
150,151c149
< 
<               socket->SetRecvCallback (MakeCallback (&Rip::Receive, this));
---
>               socket->BindToNetDevice (m_ipv4->GetNetDevice (i));
153,155c151
<               socket->SetRecvPktInfo (true);
< 
<               m_unicastSocketList[socket] = i;
---
>               m_sendSocketList[socket] = i;
164c160
<   if (!m_multicastRecvSocket)
---
>   if (!m_recvSocket)
169c165
<       m_multicastRecvSocket = Socket::CreateSocket (theNode, tid);
---
>       m_recvSocket = Socket::CreateSocket (theNode, tid);
171,174c167,170
<       m_multicastRecvSocket->Bind (local);
<       m_multicastRecvSocket->SetRecvCallback (MakeCallback (&Rip::Receive, this));
<       m_multicastRecvSocket->SetIpRecvTtl (true);
<       m_multicastRecvSocket->SetRecvPktInfo (true);
---
>       m_recvSocket->Bind (local);
>       m_recvSocket->SetRecvCallback (MakeCallback (&Rip::Receive, this));
>       m_recvSocket->SetIpRecvTtl (true);
>       m_recvSocket->SetRecvPktInfo (true);
323c319
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
350d345
<           socket->BindToNetDevice (m_ipv4->GetNetDevice (i));
352c347
<           socket->SetRecvCallback (MakeCallback (&Rip::Receive, this));
---
>           socket->BindToNetDevice (m_ipv4->GetNetDevice (i));
354,356c349,350
<           socket->SetRecvPktInfo (true);
<           m_unicastSocketList[socket] = i;
<        }
---
>           m_sendSocketList[socket] = i;
>         }
363c357
<   if (!m_multicastRecvSocket)
---
>   if (!m_recvSocket)
368c362
<       m_multicastRecvSocket = Socket::CreateSocket (theNode, tid);
---
>       m_recvSocket = Socket::CreateSocket (theNode, tid);
370,373c364,367
<       m_multicastRecvSocket->Bind (local);
<       m_multicastRecvSocket->SetRecvCallback (MakeCallback (&Rip::Receive, this));
<       m_multicastRecvSocket->SetIpRecvTtl (true);
<       m_multicastRecvSocket->SetRecvPktInfo (true);
---
>       m_recvSocket->Bind (local);
>       m_recvSocket->SetRecvCallback (MakeCallback (&Rip::Receive, this));
>       m_recvSocket->SetIpRecvTtl (true);
>       m_recvSocket->SetRecvPktInfo (true);
390c384
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
397c391
<           m_unicastSocketList.erase (iter);
---
>           m_sendSocketList.erase (iter);
491c485
< void Rip::PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
---
> void Rip::PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const
498,499c492,493
<       << ", Time: " << Now().As (unit)
<       << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (unit)
---
>       << ", Time: " << Now().As (Time::S)
>       << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (Time::S)
564c558
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
568c562
<   m_unicastSocketList.clear ();
---
>   m_sendSocketList.clear ();
570,571c564,565
<   m_multicastRecvSocket->Close ();
<   m_multicastRecvSocket = 0;
---
>   m_recvSocket->Close ();
>   m_recvSocket = 0;
723c717
<   NS_LOG_INFO ("Received " << *packet << " from " << senderAddr.GetIpv4 () << ":" << senderAddr.GetPort ());
---
>   NS_LOG_INFO ("Received " << *packet << " from " << senderAddr);
728,736d721
<   if (socket == m_multicastRecvSocket)
<     {
<       NS_LOG_LOGIC ("Received a packet from the multicast socket");
<     }
<   else
<     {
<       NS_LOG_LOGIC ("Received a packet from one of the unicast sockets");
<     }
< 
766d750
<       NS_LOG_LOGIC ("The message is a Response from " << senderAddr.GetIpv4 () << ":" << senderAddr.GetPort ());
771d754
<       NS_LOG_LOGIC ("The message is a Request from " << senderAddr.GetIpv4 () << ":" << senderAddr.GetPort ());
804,805c787,788
<               Ptr<Socket> sendingSocket;
<               for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>               Ptr<Socket> sendingSoket;
>               for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
809c792
<                       sendingSocket = iter->first;
---
>                       sendingSoket = iter->first;
812c795
<               NS_ASSERT_MSG (sendingSocket, "HandleRequest - Impossible to find a socket to send the reply");
---
>               NS_ASSERT_MSG (sendingSoket, "HandleRequest - Impossible to find a socket to send the reply");
869c852
<                       sendingSocket->SendTo (p, 0, InetSocketAddress (senderAddress, RIP_PORT));
---
>                       sendingSoket->SendTo (p, 0, InetSocketAddress (senderAddress, RIP_PORT));
878c861
<                   sendingSocket->SendTo (p, 0, InetSocketAddress (senderAddress, RIP_PORT));
---
>                   sendingSoket->SendTo (p, 0, InetSocketAddress (senderAddress, RIP_PORT));
938c921
<       m_multicastRecvSocket->SendTo (p, 0, InetSocketAddress (senderAddress, senderPort));
---
>       m_recvSocket->SendTo (p, 0, InetSocketAddress (senderAddress, senderPort));
1087c1070
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
1274c1257
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
diff ../../NS3-WiGig/src/internet/model/rip.h ../../ns-3-dev/src/internet/model/rip.h
197c197
<   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const;
---
>   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const;
343d342
<    * \param periodic true for periodic update, else triggered.
392,393c391,392
<   SocketList m_unicastSocketList; //!< list of sockets for unicast messages (socket, interface index)
<   Ptr<Socket> m_multicastRecvSocket; //!< multicast receive socket
---
>   SocketList m_sendSocketList; //!< list of sockets for sending (socket, interface index)
>   Ptr<Socket> m_recvSocket; //!< receive socket
diff ../../NS3-WiGig/src/internet/model/rip-header.cc ../../ns-3-dev/src/internet/model/rip-header.cc
22d21
< #include "ns3/log.h"
153,155c152,153
< NS_LOG_COMPONENT_DEFINE ("RipHeader");
< NS_OBJECT_ENSURE_REGISTERED (RipHeader);
< 
---
> NS_OBJECT_ENSURE_REGISTERED (RipHeader)
>   ;
198c196
<   i.WriteU8 (2);
---
>   i.WriteU8 (1);
224,228c222,223
<   if (i.ReadU8 () != 2)
<     {
<       NS_LOG_LOGIC ("RIP received a message with mismatch version, ignoring.");
<       return 0;
<     }
---
>   temp = i.ReadU8 ();
>   NS_ASSERT_MSG (temp == 1, "RIP received a message with mismatch version, aborting.");
230,234c225,226
<   if (i.ReadU16 () != 0)
<     {
<       NS_LOG_LOGIC ("RIP received a message with invalid filled flags, ignoring.");
<       return 0;
<     }
---
>   uint16_t temp16 = i.ReadU16 ();
>   NS_ASSERT_MSG (temp16 == 0, "RIP received a message with invalid filled flags, aborting.");
diff ../../NS3-WiGig/src/internet/model/ripng.cc ../../ns-3-dev/src/internet/model/ripng.cc
141d140
<               socket->BindToNetDevice (m_ipv6->GetNetDevice (i));
144c143,144
<               socket->SetRecvCallback (MakeCallback (&RipNg::Receive, this));
---
>               socket->BindToNetDevice (m_ipv6->GetNetDevice (i));
>               socket->ShutdownRecv ();
146,147c146
<               socket->SetRecvPktInfo (true);
<               m_unicastSocketList[socket] = i;
---
>               m_sendSocketList[socket] = i;
156c155
<   if (!m_multicastRecvSocket)
---
>   if (!m_recvSocket)
161c160
<       m_multicastRecvSocket = Socket::CreateSocket (theNode, tid);
---
>       m_recvSocket = Socket::CreateSocket (theNode, tid);
163,166c162,165
<       m_multicastRecvSocket->Bind (local);
<       m_multicastRecvSocket->SetRecvCallback (MakeCallback (&RipNg::Receive, this));
<       m_multicastRecvSocket->SetIpv6RecvHopLimit (true);
<       m_multicastRecvSocket->SetRecvPktInfo (true);
---
>       m_recvSocket->Bind (local);
>       m_recvSocket->SetRecvCallback (MakeCallback (&RipNg::Receive, this));
>       m_recvSocket->SetIpv6RecvHopLimit (true);
>       m_recvSocket->SetRecvPktInfo (true);
291c290
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
318d316
<           socket->BindToNetDevice (m_ipv6->GetNetDevice (i));
320c318,319
<           socket->SetRecvCallback (MakeCallback (&RipNg::Receive, this));
---
>           socket->BindToNetDevice (m_ipv6->GetNetDevice (i));
>           socket->ShutdownRecv ();
322,323c321
<           socket->SetRecvPktInfo (true);
<           m_unicastSocketList[socket] = i;
---
>           m_sendSocketList[socket] = i;
331c329
<   if (!m_multicastRecvSocket)
---
>   if (!m_recvSocket)
336c334
<       m_multicastRecvSocket = Socket::CreateSocket (theNode, tid);
---
>       m_recvSocket = Socket::CreateSocket (theNode, tid);
338,341c336,339
<       m_multicastRecvSocket->Bind (local);
<       m_multicastRecvSocket->SetRecvCallback (MakeCallback (&RipNg::Receive, this));
<       m_multicastRecvSocket->SetIpv6RecvHopLimit (true);
<       m_multicastRecvSocket->SetRecvPktInfo (true);
---
>       m_recvSocket->Bind (local);
>       m_recvSocket->SetRecvCallback (MakeCallback (&RipNg::Receive, this));
>       m_recvSocket->SetIpv6RecvHopLimit (true);
>       m_recvSocket->SetRecvPktInfo (true);
358c356
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
365c363
<           m_unicastSocketList.erase (iter);
---
>           m_sendSocketList.erase (iter);
471c469
< void RipNg::PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit) const
---
> void RipNg::PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const
478,479c476,477
<       << ", Time: " << Now().As (unit)
<       << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (unit)
---
>       << ", Time: " << Now().As (Time::S)
>       << ", Local time: " << GetObject<Node> ()->GetLocalTime ().As (Time::S)
543c541
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
547c545
<   m_unicastSocketList.clear ();
---
>   m_sendSocketList.clear ();
549,550c547,548
<   m_multicastRecvSocket->Close ();
<   m_multicastRecvSocket = 0;
---
>   m_recvSocket->Close ();
>   m_recvSocket = 0;
781,782c779,780
<               Ptr<Socket> sendingSocket;
<               for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>               Ptr<Socket> sendingSoket;
>               for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
786c784
<                       sendingSocket = iter->first;
---
>                       sendingSoket = iter->first;
789c787
<               NS_ASSERT_MSG (sendingSocket, "HandleRequest - Impossible to find a socket to send the reply");
---
>               NS_ASSERT_MSG (sendingSoket, "HandleRequest - Impossible to find a socket to send the reply");
839c837
<                       sendingSocket->SendTo (p, 0, Inet6SocketAddress (senderAddress, RIPNG_PORT));
---
>                       sendingSoket->SendTo (p, 0, Inet6SocketAddress (senderAddress, RIPNG_PORT));
848c846
<                   sendingSocket->SendTo (p, 0, Inet6SocketAddress (senderAddress, RIPNG_PORT));
---
>                   sendingSoket->SendTo (p, 0, Inet6SocketAddress (senderAddress, RIPNG_PORT));
859c857
<       Ptr<Socket> sendingSocket;
---
>       Ptr<Socket> sendingSoket;
862c860
<           for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>           for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
866c864
<                   sendingSocket = iter->first;
---
>                   sendingSoket = iter->first;
872c870
<           sendingSocket = m_multicastRecvSocket;
---
>           sendingSoket = m_recvSocket;
918c916
<       sendingSocket->SendTo (p, 0, Inet6SocketAddress (senderAddress, senderPort));
---
>       sendingSoket->SendTo (p, 0, Inet6SocketAddress (senderAddress, senderPort));
1083c1081
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
1259c1257
<   for (SocketListI iter = m_unicastSocketList.begin (); iter != m_unicastSocketList.end (); iter++ )
---
>   for (SocketListI iter = m_sendSocketList.begin (); iter != m_sendSocketList.end (); iter++ )
diff ../../NS3-WiGig/src/internet/model/ripng.h ../../ns-3-dev/src/internet/model/ripng.h
202c202
<   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit = Time::S) const;
---
>   virtual void PrintRoutingTable (Ptr<OutputStreamWrapper> stream) const;
349d348
<    * \param periodic true for periodic update, else triggered.
398,399c397,398
<   SocketList m_unicastSocketList; //!< list of sockets for unicast messages (socket, interface index)
<   Ptr<Socket> m_multicastRecvSocket; //!< multicast receive socket
---
>   SocketList m_sendSocketList; //!< list of sockets for sending (socket, interface index)
>   Ptr<Socket> m_recvSocket; //!< receive socket
diff ../../NS3-WiGig/src/internet/model/ripng-header.cc ../../ns-3-dev/src/internet/model/ripng-header.cc
22d21
< #include "ns3/log.h"
29c28,29
< NS_OBJECT_ENSURE_REGISTERED (RipNgRte);
---
> NS_OBJECT_ENSURE_REGISTERED (RipNgRte)
>   ;
135,136c135,136
< NS_LOG_COMPONENT_DEFINE ("RipNgHeader");
< NS_OBJECT_ENSURE_REGISTERED (RipNgHeader);
---
> NS_OBJECT_ENSURE_REGISTERED (RipNgHeader)
>   ;
205,209c205,206
<   if (i.ReadU8 () != 1)
<     {
<       NS_LOG_LOGIC ("RIP received a message with mismatch version, ignoring.");
<       return 0;
<     }
---
>   temp = i.ReadU8 ();
>   NS_ASSERT_MSG (temp == 1, "RipNG received a message with mismatch version, aborting.");
211,215c208,209
<   if (i.ReadU16 () != 0)
<     {
<       NS_LOG_LOGIC ("RIP received a message with invalid filled flags, ignoring.");
<       return 0;
<     }
---
>   uint16_t temp16 = i.ReadU16 ();
>   NS_ASSERT_MSG (temp16 == 0, "RipNG received a message with invalid filled flags, aborting.");
diff ../../NS3-WiGig/src/internet/model/sim_interface.h ../../ns-3-dev/src/internet/model/sim_interface.h
116d115
<    * \param size the buffer size.
122d120
<    * \returns A new UDP socket.
127d124
<    * \returns A new TCP socket.
132d128
<    * \returns A new SCTP socket.
145c141
<    * \returns The status code.
---
>    * \returns
277,278d272
<    * \param handler a handler to the INetStreamSocket.
<    * \returns The status code.
280c274
<   virtual int accept (INetStreamSocket **handler) = 0;
---
>   virtual int accept (INetStreamSocket **) = 0;
405,406d398
<    * \param data the data.
<    * \param datalen the data length.
diff ../../NS3-WiGig/src/internet/model/tcp-bic.cc ../../ns-3-dev/src/internet/model/tcp-bic.cc
21c21
< #include "ns3/simulator.h"
---
> #include "ns3/tcp-socket-base.h"
55,57c55,57
<                    UintegerValue (5),
<                    MakeUintegerAccessor (&TcpBic::m_smoothPart),
<                    MakeUintegerChecker <uint32_t> (1))
---
>                    IntegerValue (5),
>                    MakeIntegerAccessor (&TcpBic::m_smoothPart),
>                    MakeIntegerChecker <int> (1))
181c181
<           cnt = static_cast<uint32_t> (segCwnd / dist);
---
>           cnt = segCwnd / dist;
252,253c252,253
<                    " updated to " << static_cast<uint32_t> (m_beta * segCwnd));
<       m_lastMaxCwnd = static_cast<uint32_t> (m_beta * segCwnd);
---
>                    " updated to " << (uint32_t) m_beta * segCwnd);
>       m_lastMaxCwnd = m_beta * segCwnd;
269c269
<       ssThresh = static_cast<uint32_t> (std::max (segCwnd * m_beta, 2.0) * tcb->m_segmentSize);
---
>       ssThresh = std::max (segCwnd * m_beta, 2.0) * tcb->m_segmentSize;
274,281d273
< }
< 
< void
< TcpBic::ReduceCwnd (Ptr<TcpSocketState> tcb)
< {
<   NS_LOG_FUNCTION (this << tcb);
< 
<   tcb->m_cWnd = std::max (tcb->m_cWnd.Get () / 2, tcb->m_segmentSize);
diff ../../NS3-WiGig/src/internet/model/tcp-bic.h ../../ns-3-dev/src/internet/model/tcp-bic.h
24,27c24
< #include "ns3/tcp-recovery-ops.h"
< 
< class TcpBicIncrementTest;
< class TcpBicDecrementTest;
---
> #include "ns3/traced-value.h"
106d102
<   virtual void ReduceCwnd (Ptr<TcpSocketState> tcb);
113,114d108
<    * \param tcb the socket state.
<    * \returns The number of segments acked since the last cwnd increment.
119,128c113,114
<   /**
<    * \brief TcpBicIncrementTest friend class (for tests).
<    * \relates TcpBicIncrementTest
<    */
<   friend class ::TcpBicIncrementTest;
<   /**
<    * \brief TcpBicDecrementTest friend class (for tests).
<    * \relates TcpBicDecrementTest
<    */
<   friend class ::TcpBicDecrementTest;
---
>   friend class TcpBicIncrementTest;
>   friend class TcpBicDecrementTest;
135c121
<   uint32_t m_smoothPart;       //!< Number of RTT needed to reach Wmax from Wmax-B
---
>   int      m_smoothPart;       //!< Number of RTT needed to reach Wmax from Wmax-B
diff ../../NS3-WiGig/src/internet/model/tcp-congestion-ops.cc ../../ns-3-dev/src/internet/model/tcp-congestion-ops.cc
19a20
> #include "tcp-socket-base.h"
50,91d50
< void
< TcpCongestionOps::IncreaseWindow (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)
< {
<   NS_LOG_FUNCTION (this << tcb << segmentsAcked);
< }
< 
< void
< TcpCongestionOps::PktsAcked (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked,
<                              const Time& rtt)
< {
<   NS_LOG_FUNCTION (this << tcb << segmentsAcked << rtt);
< }
< 
< void
< TcpCongestionOps::CongestionStateSet (Ptr<TcpSocketState> tcb,
<                                       const TcpSocketState::TcpCongState_t newState)
< {
<   NS_LOG_FUNCTION (this << tcb << newState);
< }
< 
< void
< TcpCongestionOps::CwndEvent (Ptr<TcpSocketState> tcb,
<                              const TcpSocketState::TcpCAEvent_t event)
< {
<   NS_LOG_FUNCTION (this << tcb << event);
< }
< 
< bool
< TcpCongestionOps::HasCongControl () const
< {
<   return false;
< }
< 
< void
< TcpCongestionOps::CongControl (Ptr<TcpSocketState> tcb,
<                                const TcpRateOps::TcpRateConnection &rc,
<                                const TcpRateOps::TcpRateSample &rs)
< {
<   NS_LOG_FUNCTION (this << tcb);
<   NS_UNUSED (rc);
<   NS_UNUSED (rs);
< }
233c192
<    * // Incorrect assert, I am sorry
---
>    * // Uncorrect assert, I am sorry
251,258d209
< }
< 
< void
< TcpNewReno::ReduceCwnd (Ptr<TcpSocketState> tcb)
< {
<   NS_LOG_FUNCTION (this << tcb);
< 
<   tcb->m_cWnd = std::max (tcb->m_cWnd.Get () / 2, tcb->m_segmentSize);
diff ../../NS3-WiGig/src/internet/model/tcp-congestion-ops.h ../../ns-3-dev/src/internet/model/tcp-congestion-ops.h
22,23c22,24
< #include "tcp-rate-ops.h"
< #include "tcp-socket-state.h"
---
> #include "ns3/object.h"
> #include "ns3/timer.h"
> #include "ns3/tcp-socket-base.h"
39,40c40,41
<  * The design is inspired by what Linux v4.0 does (but it has been
<  * in place for years). The congestion control is split from the main
---
>  * The design is inspired on what Linux v4.0 does (but it has been
>  * in place since years). The congestion control is splitted from the main
45c46
<  * Only three methods have been implemented right now; however, Linux has many others,
---
>  * Only three methods has been utilized right now; however, Linux has many others,
78,87d78
<    * \brief Set configuration required by congestion control algorithm
<    *
<    * \param tcb internal congestion state
<    */
<   virtual void Init (Ptr<TcpSocketState> tcb)
<     {
<       NS_UNUSED (tcb);
<     }
< 
<   /**
90c81
<    * Is guaranteed that the congestion control state (\p TcpAckState_t) is
---
>    * Is guaranteed that the congestion control state (TcpAckState_t) is
107,108c98,99
<    * Mimic the function \pname{cong_avoid} in Linux. New segments have been ACKed,
<    * and the congestion control duty is to update the window.
---
>    * Mimic the function cong_avoid in Linux. New segments have been ACKed,
>    * and the congestion control duty is to set
115c106
<   virtual void IncreaseWindow (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked);
---
>   virtual void IncreaseWindow (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked) = 0;
122c113
<    * optional (congestion controls need not implement it) and the default
---
>    * optional (congestion controls can not implement it) and the default
130c121,123
<                           const Time& rtt);
---
>                           const Time& rtt)
>   {
>   }
135,143c128,129
<    * This function mimics the notification function \pname{set_state} in Linux.
<    * The function does not change the congestion state in the tcb; it notifies
<    * the congestion control algorithm that this state is about to be changed.
<    * The tcb->m_congState variable must be separately set; for example:
<    *
<    * \code
<    *   m_congestionControl->CongestionStateSet (m_tcb, TcpSocketState::CA_RECOVERY);
<    *   m_tcb->m_congState = TcpSocketState::CA_RECOVERY;
<    * \endcode
---
>    * This function mimics the function set_state in Linux.
>    * The function is called before changing congestion state.
149,196c135,137
<                                    const TcpSocketState::TcpCongState_t newState);
< 
<   /**
<    * \brief Trigger events/calculations on occurrence of congestion window event
<    *
<    * This function mimics the function \pname{cwnd_event} in Linux.
<    * The function is called in case of congestion window events.
<    *
<    * \param tcb internal congestion state
<    * \param event the event which triggered this function
<    */
<   virtual void CwndEvent (Ptr<TcpSocketState> tcb,
<                           const TcpSocketState::TcpCAEvent_t event);
< 
<   /**
<    * \brief Returns true when Congestion Control Algorithm implements CongControl
<    *
<    * \return true if CC implements CongControl function
<    *
<    * This function is the equivalent in C++ of the C checks that are used
<    * in the Linux kernel to see if an optional function has been defined.
<    * Since CongControl is optional, not all congestion controls have it. But,
<    * from the perspective of TcpSocketBase, the behavior is different if
<    * CongControl is present. Therefore, this check should return true for any
<    * congestion controls that implements the CongControl optional function.
<    */
<   virtual bool HasCongControl () const;
< 
<   /**
<    * \brief Called when packets are delivered to update cwnd and pacing rate
<    *
<    * This function mimics the function cong_control in Linux. It is allowed to
<    * change directly cWnd and pacing rate.
<    *
<    * \param tcb internal congestion state
<    * \param rc Rate information for the connection
<    * \param rs Rate sample (over a period of time) information
<    */
<   virtual void CongControl (Ptr<TcpSocketState> tcb,
<                             const TcpRateOps::TcpRateConnection &rc,
<                             const TcpRateOps::TcpRateSample &rs);
< 
<   /**
<    * \brief Reduces congestion window on receipt of ECN Echo Flag
<    *
<    * \param tcb internal congestion state
<    */
<   virtual void ReduceCwnd (Ptr<TcpSocketState> tcb) = 0;
---
>                                    const TcpSocketState::TcpCongState_t newState)
>   {
>   }
198a140,141
>   /* call when cwnd event occurs (optional) */
>   // void (*cwnd_event)(struct sock *sk, enum tcp_ca_event ev);
200c143
<   //     void (*in_ack_event)(struct sock *sk, u32 flags);
---
>   // void (*in_ack_event)(struct sock *sk, u32 flags);
202c145
<   //     u32  (*undo_cwnd)(struct sock *sk);
---
>   // u32  (*undo_cwnd)(struct sock *sk);
204c147
<   //     void (*pkts_acked)(struct sock *sk, u32 ext, int *attr, union tcp_cc_info *info);
---
>   // void (*pkts_acked)(struct sock *sk, u32 num_acked, s32 rtt_us);
207c150
<    * \brief Copy the congestion control algorithm across sockets
---
>    * \brief Copy the congestion control algorithm across socket
246c189
<   virtual void ReduceCwnd (Ptr<TcpSocketState> tcb);
---
> 
Only in ../../NS3-WiGig/src/internet/model: tcp-cubic.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-cubic.h
Only in ../../NS3-WiGig/src/internet/model: tcp-dctcp.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-dctcp.h
diff ../../NS3-WiGig/src/internet/model/tcp-header.cc ../../ns-3-dev/src/internet/model/tcp-header.cc
369c369
<   m_flags = field & 0xFF;
---
>   m_flags = field & 0x3F;
463c463
< TcpHeader::AppendOption (Ptr<const TcpOption> option)
---
> TcpHeader::AppendOption (Ptr<TcpOption> option)
488,495c488,489
< const TcpHeader::TcpOptionList&
< TcpHeader::GetOptionList () const
< {
<   return m_options;
< }
< 
< Ptr<const TcpOption>
< TcpHeader::GetOption(uint8_t kind) const
---
> Ptr<TcpOption>
> TcpHeader::GetOption (uint8_t kind) const
diff ../../NS3-WiGig/src/internet/model/tcp-header.h ../../ns-3-dev/src/internet/model/tcp-header.h
50,51d49
<   typedef std::list< Ptr<const TcpOption> > TcpOptionList; //!< List of TcpOption
< 
188,194c186
<   Ptr<const TcpOption> GetOption (uint8_t kind) const;
< 
<   /**
<    * \brief Get the list of option in this header
<    * \return a const reference to the option list
<    */
<   const TcpOptionList& GetOptionList (void) const;
---
>   Ptr<TcpOption> GetOption (uint8_t kind) const;
220c212
<   bool AppendOption (Ptr<const TcpOption> option);
---
>   bool AppendOption (Ptr<TcpOption> option);
351a344
>   typedef std::list< Ptr<TcpOption> > TcpOptionList; //!< List of TcpOption
diff ../../NS3-WiGig/src/internet/model/tcp-highspeed.cc ../../ns-3-dev/src/internet/model/tcp-highspeed.cc
21,22c21
< #include "tcp-socket-state.h"
< 
---
> #include "ns3/tcp-socket-base.h"
43c42
<     m_ackCnt (0)
---
>   m_ackCnt (0)
50c49
<     m_ackCnt (sock.m_ackCnt)
---
>   m_ackCnt (sock.m_ackCnt)
91c90
<  * (1/w + 1/w). That a coefficient is, in other word, the weight of each segment
---
>  * (1/w + 1/w). That a coefficent is, in other word, the weight of each segment
149c148
<   uint32_t ssThresh = static_cast<uint32_t> (std::max (2.0, segCwnd * b));
---
>   uint32_t ssThresh = std::max (2.0, segCwnd * b);
diff ../../NS3-WiGig/src/internet/model/tcp-highspeed.h ../../ns-3-dev/src/internet/model/tcp-highspeed.h
23c23
< #include "tcp-congestion-ops.h"
---
> #include "ns3/tcp-congestion-ops.h"
27,28d26
< class TcpSocketState;
< 
78c76
<    * \brief Lookup table for the coefficient a (from RFC 3649)
---
>    * \brief Lookup table for the coefficent a (from RFC 3649)
82c80
<    * \return the coefficient a
---
>    * \return the coefficent a
87c85
<    * \brief Lookup table for the coefficient b (from RFC 3649)
---
>    * \brief Lookup table for the coefficent b (from RFC 3649)
91c89
<    * \return the coefficient b
---
>    * \return the coefficent b
99c97
<   uint32_t m_ackCnt; //!< Number of received ACK, corrected with the coefficient a
---
>   uint32_t m_ackCnt; //!< Number of received ACK, corrected with the coefficent a
diff ../../NS3-WiGig/src/internet/model/tcp-htcp.cc ../../ns-3-dev/src/internet/model/tcp-htcp.cc
27a28
> 
28a30
> #include "ns3/trace-source-accessor.h"
29a32,38
> #include "ns3/abort.h"
> #include "ns3/node.h"
> #include "math.h"
> #include "ns3/tcp-socket-base.h"
> #include "ns3/sequence-number.h"
> #include "ns3/double.h"
> #include "ns3/nstime.h"
112c121
<                                    uint32_t segmentsAcked)
---
>                                 uint32_t segmentsAcked)
122c131
<                                                     << " ssthresh " << tcb->m_ssThresh);
---
>                                          << " ssthresh " << tcb->m_ssThresh);
141c150
<       m_alpha = (1 + 10 * diffSec + 0.25 * (diffSec * diffSec));
---
>       m_alpha = (1 + 10 * diffSec + 0.25 * (diffSec * diffSec));   
154,158c163
< 
<   // Default value for m_beta
<   m_beta = m_defaultBackoff;
< 
<   if (m_throughput > m_lastThroughput && m_lastThroughput > 0)
---
>   if (m_lastThroughput > 0)
160,161c165,169
<       uint32_t diff = m_throughput - m_lastThroughput;
<       if (diff / m_lastThroughput <= m_throughputRatio)
---
>       if (((m_throughput - m_lastThroughput) / m_lastThroughput) > m_throughputRatio)
>         {
>           m_beta = m_defaultBackoff;
>         }
>       else
165a174,177
>   else
>     {
>       m_beta = m_defaultBackoff;
>     }
170c182
<                                uint32_t bytesInFlight)
---
>                             uint32_t bytesInFlight)
180c192
<   uint32_t bFlight = static_cast<uint32_t> (bytesInFlight * m_beta);
---
>   uint32_t bFlight = bytesInFlight * m_beta;
192c204
<                          const Time &rtt)
---
>                       const Time &rtt)
202,203c214,215
<   m_throughput = static_cast<uint32_t> (m_dataSent
<                                         / (Simulator::Now ().GetSeconds () - m_lastCon.GetSeconds ()));
---
>   m_throughput = m_dataSent
>     / (Simulator::Now ().GetSeconds () - m_lastCon.GetSeconds ());
diff ../../NS3-WiGig/src/internet/model/tcp-htcp.h ../../ns-3-dev/src/internet/model/tcp-htcp.h
30c30,32
< #include "tcp-congestion-ops.h"
---
> #include "ns3/tcp-congestion-ops.h"
> #include "ns3/traced-value.h"
> #include "ns3/sequence-number.h"
34,35d35
< class TcpSocketState;
< 
37c37,38
<  * \ingroup congestionOps
---
>  * \ingroup socket
>  * \ingroup tcp
diff ../../NS3-WiGig/src/internet/model/tcp-hybla.cc ../../ns-3-dev/src/internet/model/tcp-hybla.cc
21,22d20
< #include "tcp-socket-state.h"
< 
23a22
> #include "ns3/tcp-socket-base.h"
44c43
<                      "ns3::TracedValueCallback::Double")
---
>                      "ns3::TracedValue::DoubleCallback")
51a51
>   m_minRtt (Time::Max ()),
59a60
>   m_minRtt (sock.m_minRtt),
71c72
< TcpHybla::RecalcParam (const Ptr<TcpSocketState> &tcb)
---
> TcpHybla::RecalcParam (Ptr<TcpSocketState> tcb, const Time &rtt)
73c74
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION (this << rtt);
75c76
<   m_rho = std::max ((double) tcb->m_minRtt.GetMilliSeconds () / m_rRtt.GetMilliSeconds (), 1.0);
---
>   m_rho = std::max ((double) rtt.GetMilliSeconds () / m_rRtt.GetMilliSeconds (), 1.0);
87c88
<   if (rtt == tcb->m_minRtt)
---
>   if (rtt < m_minRtt)
89,90c90,92
<       RecalcParam (tcb);
<       NS_LOG_DEBUG ("min rtt seen: " << rtt);
---
>       RecalcParam (tcb, rtt);
>       m_minRtt = rtt;
>       NS_LOG_DEBUG ("Updated m_minRtt=" << m_minRtt);
109d110
<       uint32_t incr = static_cast<uint32_t> (increment * tcb->m_segmentSize);
112c113,114
<       tcb->m_cWnd = std::min (tcb->m_cWnd + incr, tcb->m_ssThresh);
---
>       tcb->m_cWnd = std::min (tcb->m_cWnd + (increment * tcb->m_segmentSize),
>                               tcb->m_ssThresh);
139c141
<       increment = std::pow (m_rho, 2) / static_cast<double> (segCwnd);
---
>       increment = std::pow (m_rho, 2) / ((double) segCwnd);
147,148c149,150
<       // double to int truncates every time.
<       uint32_t inc = static_cast<uint32_t> (m_cWndCnt);
---
>       // double to int truncates everytime.
>       uint32_t inc = (uint32_t) m_cWndCnt;
diff ../../NS3-WiGig/src/internet/model/tcp-hybla.h ../../ns-3-dev/src/internet/model/tcp-hybla.h
22c22
< #include "tcp-congestion-ops.h"
---
> #include "ns3/tcp-congestion-ops.h"
27,28d26
< class TcpSocketState;
< 
66c64
<   virtual ~TcpHybla (void) override;
---
>   virtual ~TcpHybla (void);
68d65
<   // Inherited
70,72c67,71
<                           const Time& rtt) override;
<   virtual std::string GetName () const override;
<   virtual Ptr<TcpCongestionOps> Fork () override;
---
>                           const Time& rtt);
> 
>   virtual std::string GetName () const;
> 
>   virtual Ptr<TcpCongestionOps> Fork ();
75,76c74,75
<   virtual uint32_t SlowStart (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked) override;
<   virtual void CongestionAvoidance (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked) override;
---
>   virtual uint32_t SlowStart (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked);
>   virtual void CongestionAvoidance (Ptr<TcpSocketState> tcb, uint32_t segmentsAcked);
79a79
>   Time                m_minRtt;      //!< Minimum smoothed round trip time value seen
85,86c85
<    * \brief Recalculate algorithm parameters
<    * \param tcb the socket state.
---
>    * \brief Recalculate algorithm paramenters
88c87
<   void RecalcParam (const Ptr<TcpSocketState> &tcb);
---
>   void RecalcParam (Ptr<TcpSocketState> tcb, const Time& rtt);
diff ../../NS3-WiGig/src/internet/model/tcp-illinois.cc ../../ns-3-dev/src/internet/model/tcp-illinois.cc
30,31c30
< #include "tcp-socket-state.h"
< 
---
> #include "ns3/tcp-socket-base.h"
188c187
<       TcpNewReno::SlowStart (tcb, segmentsAcked);
---
>       segmentsAcked = TcpNewReno::SlowStart (tcb, segmentsAcked);
247c246
<   uint32_t ssThresh = static_cast<uint32_t> (std::max (2.0, (1.0 - m_beta) * segBytesInFlight));
---
>   uint32_t ssThresh = std::max (2.0, (1.0 - m_beta) * segBytesInFlight);
diff ../../NS3-WiGig/src/internet/model/tcp-illinois.h ../../ns-3-dev/src/internet/model/tcp-illinois.h
31c31
< #include "tcp-congestion-ops.h"
---
> #include "ns3/tcp-congestion-ops.h"
34,35d33
< 
< class TcpSocketState;
diff ../../NS3-WiGig/src/internet/model/tcp-l4-protocol.cc ../../ns-3-dev/src/internet/model/tcp-l4-protocol.cc
45d44
< #include "tcp-recovery-ops.h"
84,88d82
<     .AddAttribute ("RecoveryType",
<                    "Recovery type of TCP objects.",
<                    TypeIdValue (TcpClassicRecovery::GetTypeId ()),
<                    MakeTypeIdAccessor (&TcpL4Protocol::m_recoveryTypeId),
<                    MakeTypeIdChecker ())
186,191d179
<   return CreateSocket (congestionTypeId, m_recoveryTypeId);
< }
< 
< Ptr<Socket>
< TcpL4Protocol::CreateSocket (TypeId congestionTypeId, TypeId recoveryTypeId)
< {
195d182
<   ObjectFactory recoveryAlgorithmFactory;
198d184
<   recoveryAlgorithmFactory.SetTypeId (recoveryTypeId);
203d188
<   Ptr<TcpRecoveryOps> recovery = recoveryAlgorithmFactory.Create<TcpRecoveryOps> ();
209d193
<   socket->SetRecoveryAlgorithm (recovery);
218c202
<   return CreateSocket (m_congestionTypeId, m_recoveryTypeId);
---
>   return CreateSocket (m_congestionTypeId);
224c208
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION_NOARGS ();
236c220
< TcpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port)
---
> TcpL4Protocol::Allocate (uint16_t port)
238,239c222,223
<   NS_LOG_FUNCTION (this << boundNetDevice << port);
<   return m_endPoints->Allocate (boundNetDevice, port);
---
>   NS_LOG_FUNCTION (this << port);
>   return m_endPoints->Allocate (port);
243c227
< TcpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port)
---
> TcpL4Protocol::Allocate (Ipv4Address address, uint16_t port)
245,246c229,230
<   NS_LOG_FUNCTION (this << boundNetDevice << address << port);
<   return m_endPoints->Allocate (boundNetDevice, address, port);
---
>   NS_LOG_FUNCTION (this << address << port);
>   return m_endPoints->Allocate (address, port);
250,251c234
< TcpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice,
<                          Ipv4Address localAddress, uint16_t localPort,
---
> TcpL4Protocol::Allocate (Ipv4Address localAddress, uint16_t localPort,
254,256c237,238
<   NS_LOG_FUNCTION (this << boundNetDevice << localAddress << localPort << peerAddress << peerPort);
<   return m_endPoints->Allocate (boundNetDevice,
<                                 localAddress, localPort,
---
>   NS_LOG_FUNCTION (this << localAddress << localPort << peerAddress << peerPort);
>   return m_endPoints->Allocate (localAddress, localPort,
270c252
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION_NOARGS ();
282c264
< TcpL4Protocol::Allocate6 (Ptr<NetDevice> boundNetDevice, uint16_t port)
---
> TcpL4Protocol::Allocate6 (uint16_t port)
284,285c266,267
<   NS_LOG_FUNCTION (this << boundNetDevice << port);
<   return m_endPoints6->Allocate (boundNetDevice, port);
---
>   NS_LOG_FUNCTION (this << port);
>   return m_endPoints6->Allocate (port);
289c271
< TcpL4Protocol::Allocate6 (Ptr<NetDevice> boundNetDevice, Ipv6Address address, uint16_t port)
---
> TcpL4Protocol::Allocate6 (Ipv6Address address, uint16_t port)
291,292c273,274
<   NS_LOG_FUNCTION (this << boundNetDevice << address << port);
<   return m_endPoints6->Allocate (boundNetDevice, address, port);
---
>   NS_LOG_FUNCTION (this << address << port);
>   return m_endPoints6->Allocate (address, port);
296,297c278
< TcpL4Protocol::Allocate6 (Ptr<NetDevice> boundNetDevice,
<                           Ipv6Address localAddress, uint16_t localPort,
---
> TcpL4Protocol::Allocate6 (Ipv6Address localAddress, uint16_t localPort,
300,302c281,282
<   NS_LOG_FUNCTION (this << boundNetDevice << localAddress << localPort << peerAddress << peerPort);
<   return m_endPoints6->Allocate (boundNetDevice,
<                                  localAddress, localPort,
---
>   NS_LOG_FUNCTION (this << localAddress << localPort << peerAddress << peerPort);
>   return m_endPoints6->Allocate (localAddress, localPort,
319c299
<   NS_LOG_FUNCTION (this << icmpSource << (uint16_t) icmpTtl << (uint16_t) icmpType << (uint16_t) icmpCode << icmpInfo
---
>   NS_LOG_FUNCTION (this << icmpSource << icmpTtl << icmpType << icmpCode << icmpInfo
346c326
<   NS_LOG_FUNCTION (this << icmpSource << (uint16_t) icmpTtl << (uint16_t) icmpType << (uint16_t) icmpCode << icmpInfo
---
>   NS_LOG_FUNCTION (this << icmpSource << icmpTtl << icmpType << icmpCode << icmpInfo
511c491
<   // If we are receiving a v4-mapped packet, we will re-calculate the TCP checksum
---
>   // If we are receving a v4-mapped packet, we will re-calculate the TCP checksum
diff ../../NS3-WiGig/src/internet/model/tcp-l4-protocol.h ../../ns-3-dev/src/internet/model/tcp-l4-protocol.h
98,99d97
<   // NOTE: API from here should not be removed, only added. Be backward-compatible!
< 
117d114
<    * \param recoveryTypeId the recovery algorithm TypeId
119,128d115
<   Ptr<Socket> CreateSocket (TypeId congestionTypeId, TypeId recoveryTypeId);
< 
<   /**
<     * \brief Create a TCP socket using the specified congestion control algorithm
<     * \return A smart Socket pointer to a TcpSocket allocated by this instance
<     * of the TCP protocol
<     *
<     * \param congestionTypeId the congestion control algorithm TypeId
<     *
<     */
144d130
<    * \param boundNetDevice Bound NetDevice (if any)
148c134
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port);
---
>   Ipv4EndPoint *Allocate (uint16_t port);
151d136
<    * \param boundNetDevice Bound NetDevice (if any)
156c141
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port);
---
>   Ipv4EndPoint *Allocate (Ipv4Address address, uint16_t port);
159d143
<    * \param boundNetDevice Bound NetDevice (if any)
166,167c150
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice,
<                           Ipv4Address localAddress, uint16_t localPort,
---
>   Ipv4EndPoint *Allocate (Ipv4Address localAddress, uint16_t localPort,
182d164
<    * \param boundNetDevice Bound NetDevice (if any)
186c168
<   Ipv6EndPoint *Allocate6 (Ptr<NetDevice> boundNetDevice, uint16_t port);
---
>   Ipv6EndPoint *Allocate6 (uint16_t port);
189d170
<    * \param boundNetDevice Bound NetDevice (if any)
194c175
<   Ipv6EndPoint *Allocate6 (Ptr<NetDevice> boundNetDevice, Ipv6Address address, uint16_t port);
---
>   Ipv6EndPoint *Allocate6 (Ipv6Address address, uint16_t port);
197d177
<    * \param boundNetDevice Bound NetDevice (if any)
204,205c184
<   Ipv6EndPoint *Allocate6 (Ptr<NetDevice> boundNetDevice,
<                            Ipv6Address localAddress, uint16_t localPort,
---
>   Ipv6EndPoint *Allocate6 (Ipv6Address localAddress, uint16_t localPort,
322d300
<   TypeId m_recoveryTypeId;         //!< The recovery TypeId
Only in ../../NS3-WiGig/src/internet/model: tcp-ledbat.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-ledbat.h
Only in ../../NS3-WiGig/src/internet/model: tcp-lp.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-lp.h
diff ../../NS3-WiGig/src/internet/model/tcp-option.cc ../../ns-3-dev/src/internet/model/tcp-option.cc
25,26d24
< #include "tcp-option-sack-permitted.h"
< #include "tcp-option-sack.h"
76,82c74,78
<     { TcpOption::END,           TcpOptionEnd::GetTypeId () },
<     { TcpOption::MSS,           TcpOptionMSS::GetTypeId () },
<     { TcpOption::NOP,           TcpOptionNOP::GetTypeId () },
<     { TcpOption::TS,            TcpOptionTS::GetTypeId () },
<     { TcpOption::WINSCALE,      TcpOptionWinScale::GetTypeId () },
<     { TcpOption::SACKPERMITTED, TcpOptionSackPermitted::GetTypeId () },
<     { TcpOption::SACK,          TcpOptionSack::GetTypeId () },
---
>     { TcpOption::END,       TcpOptionEnd::GetTypeId () },
>     { TcpOption::MSS,       TcpOptionMSS::GetTypeId () },
>     { TcpOption::NOP,       TcpOptionNOP::GetTypeId () },
>     { TcpOption::TS,        TcpOptionTS::GetTypeId () },
>     { TcpOption::WINSCALE,  TcpOptionWinScale::GetTypeId () },
107,108d102
<     case SACKPERMITTED:
<     case SACK:
110c104
<       // Do not add UNKNOWN here
---
>     // Do not add UNKNOWN here
169,170c163,164
<   i.WriteU8 (static_cast<uint8_t> (GetSerializedSize ()));
<   i.Write (m_content, m_size - 2);
---
>   i.WriteU8 (GetSerializedSize ());
>   i.Write (m_content, m_size-2);
188c182
<   i.Read (m_content, m_size - 2);
---
>   i.Read (m_content, m_size-2);
diff ../../NS3-WiGig/src/internet/model/tcp-option.h ../../ns-3-dev/src/internet/model/tcp-option.h
57,64c57,62
<     END = 0,                    //!< END
<     NOP = 1,                    //!< NOP
<     MSS = 2,                    //!< MSS
<     WINSCALE = 3,               //!< WINSCALE
<     SACKPERMITTED = 4,          //!< SACKPERMITTED
<     SACK = 5,                   //!< SACK
<     TS = 8,                     //!< TS
<     UNKNOWN = 255               //!< not a standardized value; for unknown recv'd options
---
>     END = 0,      //!< END
>     NOP = 1,      //!< NOP
>     MSS = 2,      //!< MSS
>     WINSCALE = 3, //!< WINSCALE
>     TS = 8,       //!< TS
>     UNKNOWN = 255 //!< not a standardized value; for unknown recv'd options
diff ../../NS3-WiGig/src/internet/model/tcp-option-rfc793.cc ../../ns-3-dev/src/internet/model/tcp-option-rfc793.cc
225a226
> 
234,235c235,236
<   // std::cout << "rfc793 size = "<< size << "\n";
<   NS_ABORT_IF (size != 4);
---
> 
>   NS_ASSERT (size == 4);
Only in ../../NS3-WiGig/src/internet/model: tcp-option-sack.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-option-sack.h
Only in ../../NS3-WiGig/src/internet/model: tcp-option-sack-permitted.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-option-sack-permitted.h
Only in ../../NS3-WiGig/src/internet/model: tcp-prr-recovery.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-prr-recovery.h
Only in ../../NS3-WiGig/src/internet/model: tcp-rate-ops.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-rate-ops.h
Only in ../../NS3-WiGig/src/internet/model: tcp-recovery-ops.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-recovery-ops.h
diff ../../NS3-WiGig/src/internet/model/tcp-rx-buffer.cc ../../ns-3-dev/src/internet/model/tcp-rx-buffer.cc
21a22
> #include "ns3/fatal-error.h"
116c117
<   else if (m_data.size () && m_nextRxSeq > m_data.begin ()->first)
---
>   else if (m_data.size ())
190,191c191,192
<       uint32_t start = static_cast<uint32_t> (headSeq - tcph.GetSequenceNumber ());
<       uint32_t length = static_cast<uint32_t> (tailSeq - headSeq);
---
>       uint32_t start = headSeq - tcph.GetSequenceNumber ();
>       uint32_t length = tailSeq - headSeq;
198,204d198
< 
<   if (headSeq > m_nextRxSeq)
<     {
<       // Generate a new SACK block
<       UpdateSackList (headSeq, tailSeq);
<     }
< 
208c202
<   for (i = m_data.begin (); i != m_data.end (); ++i)
---
>   for (BufIterator i = m_data.begin (); i != m_data.end (); ++i)
220d213
<       ClearSackList (m_nextRxSeq);
230,362d222
< uint32_t
< TcpRxBuffer::GetSackListSize () const
< {
<   NS_LOG_FUNCTION (this);
< 
<   return static_cast<uint32_t> (m_sackList.size ());
< }
< 
< void
< TcpRxBuffer::UpdateSackList (const SequenceNumber32 &head, const SequenceNumber32 &tail)
< {
<   NS_LOG_FUNCTION (this << head << tail);
<   NS_ASSERT (head > m_nextRxSeq);
< 
<   TcpOptionSack::SackBlock current;
<   current.first = head;
<   current.second = tail;
< 
<   // The block "current" has been safely stored. Now we need to build the SACK
<   // list, to be advertised. From RFC 2018:
<   // (a) The first SACK block (i.e., the one immediately following the
<   //     kind and length fields in the option) MUST specify the contiguous
<   //     block of data containing the segment which triggered this ACK,
<   //     unless that segment advanced the Acknowledgment Number field in
<   //     the header.  This assures that the ACK with the SACK option
<   //     reflects the most recent change in the data receiver's buffer
<   //     queue.
<   //
<   // (b) The data receiver SHOULD include as many distinct SACK blocks as
<   //     possible in the SACK option.  Note that the maximum available
<   //     option space may not be sufficient to report all blocks present in
<   //     the receiver's queue.
<   //
<   // (c) The SACK option SHOULD be filled out by repeating the most
<   //     recently reported SACK blocks (based on first SACK blocks in
<   //     previous SACK options) that are not subsets of a SACK block
<   //     already included in the SACK option being constructed.  This
<   //     assures that in normal operation, any segment remaining part of a
<   //     non-contiguous block of data held by the data receiver is reported
<   //     in at least three successive SACK options, even for large-window
<   //     TCP implementations [RFC1323]).  After the first SACK block, the
<   //     following SACK blocks in the SACK option may be listed in
<   //     arbitrary order.
< 
<   m_sackList.push_front (current);
< 
<   // We have inserted the block at the beginning of the list. Now, we should
<   // check if any existing blocks overlap with that.
<   bool updated = false;
<   TcpOptionSack::SackList::iterator it = m_sackList.begin ();
<   TcpOptionSack::SackBlock begin = *it;
<   TcpOptionSack::SackBlock merged;
<   ++it;
< 
<   // Iterates until we examined all blocks in the list (maximum 4)
<   while (it != m_sackList.end ())
<     {
<       current = *it;
< 
<       // This is a left merge:
<       // [current_first; current_second] [beg_first; beg_second]
<       if (begin.first == current.second)
<         {
<           NS_ASSERT (current.first < begin.second);
<           merged = TcpOptionSack::SackBlock (current.first, begin.second);
<           updated = true;
<         }
<       // while this is a right merge
<       // [begin_first; begin_second] [current_first; current_second]
<       else if (begin.second == current.first)
<         {
<           NS_ASSERT (begin.first < current.second);
<           merged = TcpOptionSack::SackBlock (begin.first, current.second);
<           updated = true;
<         }
< 
<       // If we have merged the blocks (and the result is in merged) we should
<       // delete the current block (it), the first block, and insert the merged
<       // one at the beginning.
<       if (updated)
<         {
<           m_sackList.erase (it);
<           m_sackList.pop_front ();
<           m_sackList.push_front (merged);
<           it = m_sackList.begin ();
<           begin = *it;
<           updated = false;
<         }
< 
<       ++it;
<     }
< 
<   // Since the maximum blocks that fits into a TCP header are 4, there's no
<   // point on maintaining the others.
<   if (m_sackList.size () > 4)
<     {
<       m_sackList.pop_back ();
<     }
< 
<   // Please note that, if a block b is discarded and then a block contiguous
<   // to b is received, only that new block (without the b part) is reported.
<   // This is perfectly fine for the RFC point (a), given that we do not report any
<   // overlapping blocks shortly after.
< }
< 
< void
< TcpRxBuffer::ClearSackList (const SequenceNumber32 &seq)
< {
<   NS_LOG_FUNCTION (this << seq);
< 
<   TcpOptionSack::SackList::iterator it;
<   for (it = m_sackList.begin (); it != m_sackList.end (); )
<     {
<       TcpOptionSack::SackBlock block = *it;
<       NS_ASSERT (block.first < block.second);
< 
<       if (block.second <= seq)
<         {
<           it = m_sackList.erase (it);
<         }
<       else
<         {
<           it++;
<         }
<     }
< }
< 
< TcpOptionSack::SackList
< TcpRxBuffer::GetSackList () const
< {
<   return m_sackList;
< }
< 
370c230
<   if (extractSize == 0) return nullptr;  // No contiguous block to return
---
>   if (extractSize == 0) return 0;  // No contiguous block to return
401c261
<       return nullptr;
---
>       return 0;
408c268
< } //namespace ns3
---
> } //namepsace ns3
diff ../../NS3-WiGig/src/internet/model/tcp-rx-buffer.h ../../ns-3-dev/src/internet/model/tcp-rx-buffer.h
30d29
< #include "ns3/tcp-option-sack.h"
38,71c37,38
<  * \brief Rx reordering buffer for TCP
<  *
<  * The class is responsible to safely store the segments, and then
<  * returning them in-order to the application, where "in-order" does not means
<  * "network-order", but "sender-order" : the bytes should be returned in the
<  * same order that the sender application used to push them down on wire.
<  *
<  * The first useful sequence that this class is waiting is returned by the method
<  * NextRxSequence, and could be set at the beginning through MaxRxSequence.
<  *
<  * The max. size of this buffer is managed through SetMaxBufferSize, and could be
<  * retrieved using MaxBufferSize. The current size instead is returned by
<  * Size, while the amount of in-order data that could be extracted is returned
<  * by the method Available.
<  *
<  * To store data, use Add; for retrieving a certain amount of ordered data, use
<  * the method Extract.
<  *
<  * SACK list
<  * ---------
<  *
<  * An interesting feature of this class is the ability to maintain an ordered
<  * SACK list, under the definition of RFC 2018. When a out-of-order segment
<  * reaches this buffer, an ACK will be sent out, and the SACK list is
<  * generated or updated. From RFC 2018:
<  *
<  * > If sent at all, SACK options SHOULD be included in all ACKs which do
<  * > not ACK the highest sequence number in the data receiver's queue.
<  *
<  * For more information about the SACK list, please check the documentation of
<  * the method GetSackList.
<  *
<  * \see GetSackList
<  * \see UpdateSackList
---
>  * \brief class for the reordering buffer that keeps the data from lower layer, i.e.
>  *        TcpL4Protocol, sent to the application
161,183d127
<   /**
<    * \brief Get the sack list
<    *
<    * The sack list can be empty, and it is updated each time Add or Extract
<    * are called through the private method UpdateSackList.
<    *
<    * \return a list of isolated blocks
<    */
<   TcpOptionSack::SackList GetSackList () const;
< 
<   /**
<    * \brief Get the size of Sack list
<    *
<    * \return the size of the sack block list; can be empty
<    */
<   uint32_t GetSackListSize () const;
< 
<   /**
<    * \brief Says if a FIN bit has been received
<    * \return true if we received a FIN bit
<    */
<   bool GotFin () const { return m_gotFin; }
< 
185,219d128
<   /**
<    * \brief Update the sack list, with the block seq starting at the beginning
<    *
<    * Note: the maximum size of the block list is 4. Caller is free to
<    * drop blocks at the end to accommodate header size; from RFC 2018:
<    *
<    * > The data receiver SHOULD include as many distinct SACK blocks as
<    * > possible in the SACK option.  Note that the maximum available
<    * > option space may not be sufficient to report all blocks present in
<    * > the receiver's queue.
<    *
<    * In fact, the maximum amount of blocks is 4, and if we consider the timestamp
<    * (or other) options, it is even less. For more detail about this function,
<    * please see the source code and in-line comments.
<    *
<    * \param head sequence number of the block at the beginning
<    * \param tail sequence number of the block at the end
<    */
<   void UpdateSackList (const SequenceNumber32 &head, const SequenceNumber32 &tail);
< 
<   /**
<    * \brief Remove old blocks from the sack list
<    *
<    * Used to remove blocks already delivered to the application.
<    *
<    * After this call, in the SACK list there will be only blocks with
<    * sequence numbers greater than seq; it is perfectly safe to call this
<    * function with an empty sack list.
<    *
<    * \param seq Last sequence to remove
<    */
<   void ClearSackList (const SequenceNumber32 &seq);
< 
<   TcpOptionSack::SackList m_sackList; //!< Sack list (updated constantly)
< 
231c140
< } //namespace ns3
---
> } //namepsace ns3
diff ../../NS3-WiGig/src/internet/model/tcp-scalable.cc ../../ns-3-dev/src/internet/model/tcp-scalable.cc
31,32c31
< #include "tcp-socket-state.h"
< 
---
> #include "ns3/tcp-socket-base.h"
95,96d93
<   NS_ASSERT (segCwnd >= 1);
< 
137c134
<   uint32_t ssThresh = static_cast<uint32_t> (std::max (2.0, segCwnd * b));
---
>   uint32_t ssThresh = std::max (2.0, segCwnd * b);
diff ../../NS3-WiGig/src/internet/model/tcp-scalable.h ../../ns-3-dev/src/internet/model/tcp-scalable.h
33c33
< #include "tcp-congestion-ops.h"
---
> #include "ns3/tcp-congestion-ops.h"
36,37d35
< 
< class TcpSocketState;
diff ../../NS3-WiGig/src/internet/model/tcp-socket-base.cc ../../ns-3-dev/src/internet/model/tcp-socket-base.cc
44,45d43
< #include "ns3/data-rate.h"
< #include "ns3/object.h"
51,53d48
< #include "tcp-tx-buffer.h"
< #include "tcp-rx-buffer.h"
< #include "rtt-estimator.h"
57,58c52
< #include "tcp-option-sack-permitted.h"
< #include "tcp-option-sack.h"
---
> #include "rtt-estimator.h"
60,61d53
< #include "tcp-recovery-ops.h"
< #include "ns3/tcp-rate-ops.h"
65,69d56
< #include <iostream>
< #include <fstream>
< 
< using namespace ns3;
< using namespace std;
73d59
< 
111,114d96
<     .AddAttribute ("Sack", "Enable or disable Sack option",
<                    BooleanValue (true),
<                    MakeBooleanAccessor (&TcpSocketBase::m_sackEnabled),
<                    MakeBooleanChecker ())
144,145c126
<                    MakeUintegerAccessor (&TcpSocketBase::SetRetxThresh,
<                                          &TcpSocketBase::GetRetxThresh),
---
>                    MakeUintegerAccessor (&TcpSocketBase::m_retxThresh),
151,156d131
<     .AddAttribute ("UseEcn", "Parameter to set ECN functionality",
<                    EnumValue (TcpSocketState::Off),
<                    MakeEnumAccessor (&TcpSocketBase::SetUseEcn),
<                    MakeEnumChecker (TcpSocketState::Off, "Off",
<                                     TcpSocketState::On, "On",
<                                     TcpSocketState::AcceptOnly, "AcceptOnly"))
160c135
<                      "ns3::TracedValueCallback::Time")
---
>                      "ns3::Time::TracedValueCallback")
163,164c138,139
<                      MakeTraceSourceAccessor (&TcpSocketBase::m_lastRttTrace),
<                      "ns3::TracedValueCallback::Time")
---
>                      MakeTraceSourceAccessor (&TcpSocketBase::m_lastRtt),
>                      "ns3::Time::TracedValueCallback")
172c147
<                      "ns3::TracedValueCallback::SequenceNumber32")
---
>                      "ns3::SequenceNumber32TracedValueCallback")
181,188d155
<     .AddTraceSource ("EcnState",
<                      "Trace ECN state change of socket",
<                      MakeTraceSourceAccessor (&TcpSocketBase::m_ecnStateTrace),
<                      "ns3::TcpSocketState::EcnStatesTracedValueCallback")
<     .AddTraceSource ("AdvWND",
<                      "Advertised Window Size",
<                      MakeTraceSourceAccessor (&TcpSocketBase::m_advWnd),
<                      "ns3::TracedValueCallback::Uint32")
195c162
<                      MakeTraceSourceAccessor (&TcpSocketBase::m_bytesInFlightTrace),
---
>                      MakeTraceSourceAccessor (&TcpSocketBase::m_bytesInFlight),
200c167
<                      "ns3::TracedValueCallback::SequenceNumber32")
---
>                      "ns3::SequenceNumber32TracedValueCallback")
204c171
<                      "ns3::TracedValueCallback::SequenceNumber32")
---
>                      "ns3::SequenceNumber32TracedValueCallback")
209,212d175
<     .AddTraceSource ("CongestionWindowInflated",
<                      "The TCP connection's congestion window inflates as in older RFC",
<                      MakeTraceSourceAccessor (&TcpSocketBase::m_cWndInflTrace),
<                      "ns3::TracedValueCallback::Uint32")
225,236d187
<     .AddTraceSource ("EcnEchoSeq",
<                      "Sequence of last received ECN Echo",
<                      MakeTraceSourceAccessor (&TcpSocketBase::m_ecnEchoSeq),
<                      "ns3::SequenceNumber32TracedValueCallback")
<     .AddTraceSource ("EcnCeSeq",
<                      "Sequence of last received CE ",
<                      MakeTraceSourceAccessor (&TcpSocketBase::m_ecnCESeq),
<                      "ns3::SequenceNumber32TracedValueCallback")
<     .AddTraceSource ("EcnCwrSeq",
<                      "Sequence of last received CWR",
<                      MakeTraceSourceAccessor (&TcpSocketBase::m_ecnCWRSeq),
<                      "ns3::SequenceNumber32TracedValueCallback")
246a198,264
> 
> TypeId
> TcpSocketState::GetTypeId (void)
> {
>   static TypeId tid = TypeId ("ns3::TcpSocketState")
>     .SetParent<Object> ()
>     .SetGroupName ("Internet")
>     .AddConstructor <TcpSocketState> ()
>     .AddTraceSource ("CongestionWindow",
>                      "The TCP connection's congestion window",
>                      MakeTraceSourceAccessor (&TcpSocketState::m_cWnd),
>                      "ns3::TracedValue::Uint32Callback")
>     .AddTraceSource ("SlowStartThreshold",
>                      "TCP slow start threshold (bytes)",
>                      MakeTraceSourceAccessor (&TcpSocketState::m_ssThresh),
>                      "ns3::TracedValue::Uint32Callback")
>     .AddTraceSource ("CongState",
>                      "TCP Congestion machine state",
>                      MakeTraceSourceAccessor (&TcpSocketState::m_congState),
>                      "ns3::TracedValue::TcpCongStatesTracedValueCallback")
>     .AddTraceSource ("HighestSequence",
>                      "Highest sequence number received from peer",
>                      MakeTraceSourceAccessor (&TcpSocketState::m_highTxMark),
>                      "ns3::SequenceNumber32TracedValueCallback")
>     .AddTraceSource ("NextTxSequence",
>                      "Next sequence number to send (SND.NXT)",
>                      MakeTraceSourceAccessor (&TcpSocketState::m_nextTxSequence),
>                      "ns3::SequenceNumber32TracedValueCallback")
>   ;
>   return tid;
> }
> 
> TcpSocketState::TcpSocketState (void)
>   : Object (),
>     m_cWnd (0),
>     m_ssThresh (0),
>     m_initialCWnd (0),
>     m_initialSsThresh (0),
>     m_segmentSize (0),
>     m_lastAckedSeq (0),
>     m_congState (CA_OPEN),
>     m_highTxMark (0),
>     // Change m_nextTxSequence for non-zero initial sequence number
>     m_nextTxSequence (0)
> {
> }
> 
> TcpSocketState::TcpSocketState (const TcpSocketState &other)
>   : Object (other),
>     m_cWnd (other.m_cWnd),
>     m_ssThresh (other.m_ssThresh),
>     m_initialCWnd (other.m_initialCWnd),
>     m_initialSsThresh (other.m_initialSsThresh),
>     m_segmentSize (other.m_segmentSize),
>     m_lastAckedSeq (other.m_lastAckedSeq),
>     m_congState (other.m_congState),
>     m_highTxMark (other.m_highTxMark),
>     m_nextTxSequence (other.m_nextTxSequence)
> {
> }
> 
> const char* const
> TcpSocketState::TcpCongStateName[TcpSocketState::CA_LAST_STATE] =
> {
>   "CA_OPEN", "CA_DISORDER", "CA_CWR", "CA_RECOVERY", "CA_LOSS"
> };
> 
248c266,321
<   : TcpSocket ()
---
>   : TcpSocket (),
>     m_retxEvent (),
>     m_lastAckEvent (),
>     m_delAckEvent (),
>     m_persistEvent (),
>     m_timewaitEvent (),
>     m_dupAckCount (0),
>     m_delAckCount (0),
>     m_delAckMaxCount (0),
>     m_noDelay (false),
>     m_synCount (0),
>     m_synRetries (0),
>     m_dataRetrCount (0),
>     m_dataRetries (0),
>     m_rto (Seconds (0.0)),
>     m_minRto (Time::Max ()),
>     m_clockGranularity (Seconds (0.001)),
>     m_lastRtt (Seconds (0.0)),
>     m_delAckTimeout (Seconds (0.0)),
>     m_persistTimeout (Seconds (0.0)),
>     m_cnTimeout (Seconds (0.0)),
>     m_endPoint (0),
>     m_endPoint6 (0),
>     m_node (0),
>     m_tcp (0),
>     m_rtt (0),
>     m_rxBuffer (0),
>     m_txBuffer (0),
>     m_state (CLOSED),
>     m_errno (ERROR_NOTERROR),
>     m_closeNotified (false),
>     m_closeOnEmpty (false),
>     m_shutdownSend (false),
>     m_shutdownRecv (false),
>     m_connected (false),
>     m_msl (0),
>     m_maxWinSize (0),
>     m_rWnd (0),
>     m_highRxMark (0),
>     m_highTxAck (0),
>     m_highRxAckMark (0),
>     m_bytesAckedNotProcessed (0),
>     m_bytesInFlight (0),
>     m_winScalingEnabled (false),
>     m_rcvWindShift (0),
>     m_sndWindShift (0),
>     m_timestampEnabled (true),
>     m_timestampToEcho (0),
>     m_sendPendingDataEvent (),
>     // Set m_recover to the initial sequence number
>     m_recover (0),
>     m_retxThresh (3),
>     m_limitedTx (false),
>     m_retransOut (0),
>     m_congestionControl (0),
>     m_isFirstPartialAck (true)
250a324
>   m_rxBuffer = CreateObject<TcpRxBuffer> ();
253,260d326
<   m_rateOps  = CreateObject <TcpRateLinux> ();
< 
<   m_tcb->m_rxBuffer = CreateObject<TcpRxBuffer> ();
< 
<   m_tcb->m_currentPacingRate = m_tcb->m_maxPacingRate;
<   m_pacingTimer.SetFunction (&TcpSocketBase::NotifyPacingPerformed, this);
< 
<   m_tcb->m_sendEmptyPacketCallback = MakeCallback (&TcpSocketBase::SendEmptyPacket, this);
268,271d333
<   ok = m_tcb->TraceConnectWithoutContext ("CongestionWindowInflated",
<                                           MakeCallback (&TcpSocketBase::UpdateCwndInfl, this));
<   NS_ASSERT (ok == true);
< 
280,283d341
<   ok = m_tcb->TraceConnectWithoutContext ("EcnState",
<                                           MakeCallback (&TcpSocketBase::UpdateEcnState, this));
<   NS_ASSERT (ok == true);
< 
291,298d348
< 
<   ok = m_tcb->TraceConnectWithoutContext ("BytesInFlight",
<                                           MakeCallback (&TcpSocketBase::UpdateBytesInFlight, this));
<   NS_ASSERT (ok == true);
< 
<   ok = m_tcb->TraceConnectWithoutContext ("RTT",
<                                           MakeCallback (&TcpSocketBase::UpdateRtt, this));
<   NS_ASSERT (ok == true);
314a365
>     m_lastRtt (sock.m_lastRtt),
318,319c369,370
<     m_endPoint (nullptr),
<     m_endPoint6 (nullptr),
---
>     m_endPoint (0),
>     m_endPoint6 (0),
331d381
<     m_bytesAckedNotProcessed (sock.m_bytesAckedNotProcessed),
335c385,386
<     m_sackEnabled (sock.m_sackEnabled),
---
>     m_bytesAckedNotProcessed (sock.m_bytesAckedNotProcessed),
>     m_bytesInFlight (sock.m_bytesInFlight),
343a395
>     m_retransOut (sock.m_retransOut),
346,350c398
<     m_rxTrace (sock.m_rxTrace),
<     m_pacingTimer (Timer::REMOVE_ON_DESTROY),
<     m_ecnEchoSeq (sock.m_ecnEchoSeq),
<     m_ecnCESeq (sock.m_ecnCESeq),
<     m_ecnCWRSeq (sock.m_ecnCWRSeq)
---
>     m_rxTrace (sock.m_rxTrace)
367a416
>   m_rxBuffer = CopyObject (sock.m_rxBuffer);
369,373d417
<   m_tcb->m_rxBuffer = CopyObject (sock.m_tcb->m_rxBuffer);
< 
<   m_tcb->m_currentPacingRate = m_tcb->m_maxPacingRate;
<   m_pacingTimer.SetFunction (&TcpSocketBase::NotifyPacingPerformed, this);
< 
377,388d420
<       m_congestionControl->Init (m_tcb);
<     }
< 
<   if (sock.m_recoveryOps)
<     {
<       m_recoveryOps = sock.m_recoveryOps->Fork ();
<     }
< 
<   m_rateOps = CreateObject <TcpRateLinux> ();
<   if (m_tcb->m_sendEmptyPacketCallback.IsNull ())
<     {
<       m_tcb->m_sendEmptyPacketCallback = MakeCallback (&TcpSocketBase::SendEmptyPacket, this);
397,400d428
<   ok = m_tcb->TraceConnectWithoutContext ("CongestionWindowInflated",
<                                           MakeCallback (&TcpSocketBase::UpdateCwndInfl, this));
<   NS_ASSERT (ok == true);
< 
409,412d436
<   ok = m_tcb->TraceConnectWithoutContext ("EcnState",
<                                           MakeCallback (&TcpSocketBase::UpdateEcnState, this));
<   NS_ASSERT (ok == true);
< 
419,427d442
<   NS_ASSERT (ok == true);
< 
<   ok = m_tcb->TraceConnectWithoutContext ("BytesInFlight",
<                                           MakeCallback (&TcpSocketBase::UpdateBytesInFlight, this));
<   NS_ASSERT (ok == true);
< 
<   ok = m_tcb->TraceConnectWithoutContext ("RTT",
<                                           MakeCallback (&TcpSocketBase::UpdateRtt, this));
<   NS_ASSERT (ok == true);
433,434c448,449
<   m_node = nullptr;
<   if (m_endPoint != nullptr)
---
>   m_node = 0;
>   if (m_endPoint != 0)
436c451
<       NS_ASSERT (m_tcp != nullptr);
---
>       NS_ASSERT (m_tcp != 0);
440c455
<        * m_tcp->DeAllocate, it will destroy its Ipv4EndpointDemux::DeAllocate,
---
>        * m_tcp->DeAllocate, it wil destroy its Ipv4EndpointDemux::DeAllocate,
444c459
<       NS_ASSERT (m_endPoint != nullptr);
---
>       NS_ASSERT (m_endPoint != 0);
446c461
<       NS_ASSERT (m_endPoint == nullptr);
---
>       NS_ASSERT (m_endPoint == 0);
448c463
<   if (m_endPoint6 != nullptr)
---
>   if (m_endPoint6 != 0)
450,451c465,466
<       NS_ASSERT (m_tcp != nullptr);
<       NS_ASSERT (m_endPoint6 != nullptr);
---
>       NS_ASSERT (m_tcp != 0);
>       NS_ASSERT (m_endPoint6 != 0);
453c468
<       NS_ASSERT (m_endPoint6 == nullptr);
---
>       NS_ASSERT (m_endPoint6 == 0);
497a513
>   NS_LOG_FUNCTION_NOARGS ();
551c567
<           m_endPoint = m_tcp->Allocate (GetBoundNetDevice (), port);
---
>           m_endPoint = m_tcp->Allocate (port);
559c575
<           m_endPoint = m_tcp->Allocate (GetBoundNetDevice (), ipv4, port);
---
>           m_endPoint = m_tcp->Allocate (ipv4, port);
578c594
<           m_endPoint6 = m_tcp->Allocate6 (GetBoundNetDevice (), port);
---
>           m_endPoint6 = m_tcp->Allocate6 (port);
586c602
<           m_endPoint6 = m_tcp->Allocate6 (GetBoundNetDevice (), ipv6, port);
---
>           m_endPoint6 = m_tcp->Allocate6 (ipv6, port);
644c660
<   if (InetSocketAddress::IsMatchingType (address))
---
>   if (InetSocketAddress::IsMatchingType (address) && m_endPoint6 == 0)
646c662
<       if (m_endPoint == nullptr)
---
>       if (m_endPoint == 0)
650c666
<               NS_ASSERT (m_endPoint == nullptr);
---
>               NS_ASSERT (m_endPoint == 0);
653c669
<           NS_ASSERT (m_endPoint != nullptr);
---
>           NS_ASSERT (m_endPoint != 0);
658c674
<       m_endPoint6 = nullptr;
---
>       m_endPoint6 = 0;
667c683
<   else if (Inet6SocketAddress::IsMatchingType (address))
---
>   else if (Inet6SocketAddress::IsMatchingType (address)  && m_endPoint == 0)
679c695
<       if (m_endPoint6 == nullptr)
---
>       if (m_endPoint6 == 0)
683c699
<               NS_ASSERT (m_endPoint6 == nullptr);
---
>               NS_ASSERT (m_endPoint6 == 0);
686c702
<           NS_ASSERT (m_endPoint6 != nullptr);
---
>           NS_ASSERT (m_endPoint6 != 0);
689c705
<       m_endPoint = nullptr;
---
>       m_endPoint = 0;
693,694c709
<         {
<           NS_LOG_ERROR ("Route to destination does not exist ?!");
---
>         { // Route to destination does not exist
739c754
<   if (m_tcb->m_rxBuffer->Size () != 0)
---
>   if (m_rxBuffer->Size () != 0)
774c789
<           NS_LOG_INFO ("Empty tx buffer, send fin");
---
>           NS_LOG_INFO ("Emtpy tx buffer, send fin");
822,826d836
< 
<       m_rateOps->CalculateAppLimited(m_tcb->m_cWnd, m_tcb->m_bytesInFlight, m_tcb->m_segmentSize,
<                                      m_txBuffer->TailSequence (), m_tcb->m_nextTxSequence,
<                                      m_txBuffer->GetLost (), m_txBuffer->GetRetransmitsCount ());
< 
829,831c839,840
<       if ((m_state == ESTABLISHED || m_state == CLOSE_WAIT) && AvailableWindow () > 0)
<         { // Try to send the data out: Add a little step to allow the application
<           // to fill the buffer
---
>       if (m_state == ESTABLISHED || m_state == CLOSE_WAIT)
>         { // Try to send the data out
852d860
<   NS_UNUSED (address);
863c871
<   if (m_tcb->m_rxBuffer->Size () == 0 && m_state == CLOSE_WAIT)
---
>   if (m_rxBuffer->Size () == 0 && m_state == CLOSE_WAIT)
867c875
<   Ptr<Packet> outPacket = m_tcb->m_rxBuffer->Extract (maxSize);
---
>   Ptr<Packet> outPacket = m_rxBuffer->Extract (maxSize);
878c886
<   if (packet != nullptr && packet->GetSize () != 0)
---
>   if (packet != 0 && packet->GetSize () != 0)
880c888
<       if (m_endPoint != nullptr)
---
>       if (m_endPoint != 0)
884c892
<       else if (m_endPoint6 != nullptr)
---
>       else if (m_endPoint6 != 0)
909c917
<   return m_tcb->m_rxBuffer->Available ();
---
>   return m_rxBuffer->Available ();
917c925
<   if (m_endPoint != nullptr)
---
>   if (m_endPoint != 0)
921c929
<   else if (m_endPoint6 != nullptr)
---
>   else if (m_endPoint6 != 0)
969c977
<   if (m_endPoint != nullptr)
---
>   if (m_endPoint == 0)
971c979,984
<       m_endPoint->BindToNetDevice (netdevice);
---
>       if (Bind () == -1)
>         {
>           NS_ASSERT (m_endPoint == 0);
>           return;
>         }
>       NS_ASSERT (m_endPoint != 0);
972a986
>   m_endPoint->BindToNetDevice (netdevice);
974c988
<   if (m_endPoint6 != nullptr)
---
>   if (m_endPoint6 == 0)
976c990,995
<       m_endPoint6->BindToNetDevice (netdevice);
---
>       if (Bind6 () == -1)
>         {
>           NS_ASSERT (m_endPoint6 == 0);
>           return;
>         }
>       NS_ASSERT (m_endPoint6 != 0);
977a997
>   m_endPoint6->BindToNetDevice (netdevice);
988c1008
<   if (m_endPoint == nullptr && m_endPoint6 == nullptr)
---
>   if (m_endPoint == 0 && m_endPoint6 == 0)
992c1012
<   if (m_endPoint != nullptr)
---
>   if (m_endPoint != 0)
998c1018
<   if (m_endPoint6 != nullptr)
---
>   if (m_endPoint6 != 0)
1017,1025c1037
<       // send a SYN packet with ECE and CWR flags set if sender is ECN capable
<       if (m_tcb->m_useEcn == TcpSocketState::On)
<         {
<           SendEmptyPacket (TcpHeader::SYN | TcpHeader::ECE | TcpHeader::CWR);
<         }
<       else
<         {
<           SendEmptyPacket (TcpHeader::SYN);
<         }
---
>       SendEmptyPacket (TcpHeader::SYN);
1028d1039
<       m_tcb->m_ecnState = TcpSocketState::ECN_DISABLED;    // because sender is not yet aware about receiver's ECN capability
1112c1123
<       return (m_tcb->m_rxBuffer->NextRxSequence () != head);
---
>       return (m_rxBuffer->NextRxSequence () != head);
1116c1127
<   return (tail < m_tcb->m_rxBuffer->NextRxSequence () || m_tcb->m_rxBuffer->MaxRxSequence () <= head);
---
>   return (tail < m_rxBuffer->NextRxSequence () || m_rxBuffer->MaxRxSequence () <= head);
1136,1157d1146
<   TcpHeader tcpHeader;
<   uint32_t bytesRemoved = packet->PeekHeader (tcpHeader);
< 
<   if (!IsValidTcpSegment (tcpHeader.GetSequenceNumber (), bytesRemoved,
<                           packet->GetSize () - bytesRemoved))
<     {
<       return;
<     }
< 
<   if (header.GetEcn() == Ipv4Header::ECN_CE && m_ecnCESeq < tcpHeader.GetSequenceNumber ())
<     {
<       NS_LOG_INFO ("Received CE flag is valid");
<       NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_CE_RCVD");
<       m_ecnCESeq = tcpHeader.GetSequenceNumber ();
<       m_tcb->m_ecnState = TcpSocketState::ECN_CE_RCVD;
<       m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_ECN_IS_CE);
<     }
<   else if (header.GetEcn() != Ipv4Header::ECN_NotECT && m_tcb->m_ecnState != TcpSocketState::ECN_DISABLED)
<     {
<       m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_ECN_NO_CE);
<     }
< 
1175,1196d1163
<   TcpHeader tcpHeader;
<   uint32_t bytesRemoved = packet->PeekHeader (tcpHeader);
< 
<   if (!IsValidTcpSegment (tcpHeader.GetSequenceNumber (), bytesRemoved,
<                           packet->GetSize () - bytesRemoved))
<     {
<       return;
<     }
< 
<   if (header.GetEcn() == Ipv6Header::ECN_CE && m_ecnCESeq < tcpHeader.GetSequenceNumber ())
<     {
<       NS_LOG_INFO ("Received CE flag is valid");
<       NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_CE_RCVD");
<       m_ecnCESeq = tcpHeader.GetSequenceNumber ();
<       m_tcb->m_ecnState = TcpSocketState::ECN_CE_RCVD;
<       m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_ECN_IS_CE);
<     }
<   else if (header.GetEcn() != Ipv6Header::ECN_NotECT)
<     {
<       m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_ECN_NO_CE);
<     }
< 
1205,1207c1172,1173
<   NS_LOG_FUNCTION (this << icmpSource << static_cast<uint32_t> (icmpTtl) <<
<                    static_cast<uint32_t> (icmpType) <<
<                    static_cast<uint32_t> (icmpCode) << icmpInfo);
---
>   NS_LOG_FUNCTION (this << icmpSource << (uint32_t)icmpTtl << (uint32_t)icmpType <<
>                    (uint32_t)icmpCode << icmpInfo);
1219,1221c1185,1186
<   NS_LOG_FUNCTION (this << icmpSource << static_cast<uint32_t> (icmpTtl) <<
<                    static_cast<uint32_t> (icmpType) <<
<                    static_cast<uint32_t> (icmpCode) << icmpInfo);
---
>   NS_LOG_FUNCTION (this << icmpSource << (uint32_t)icmpTtl << (uint32_t)icmpType <<
>                    (uint32_t)icmpCode << icmpInfo);
1228,1251d1192
< bool
< TcpSocketBase::IsValidTcpSegment (const SequenceNumber32 seq, const uint32_t tcpHeaderSize,
<                                   const uint32_t tcpPayloadSize)
< {
<   if (tcpHeaderSize == 0 || tcpHeaderSize > 60)
<     {
<       NS_LOG_ERROR ("Bytes removed: " << tcpHeaderSize << " invalid");
<       return false; // Discard invalid packet
<     }
<   else if (tcpPayloadSize > 0 && OutOfRange (seq, seq + tcpPayloadSize))
<     {
<       // Discard fully out of range data packets
<       NS_LOG_WARN ("At state " << TcpStateName[m_state] <<
<                    " received packet of seq [" << seq <<
<                    ":" << seq + tcpPayloadSize <<
<                    ") out of range [" << m_tcb->m_rxBuffer->NextRxSequence () << ":" <<
<                    m_tcb->m_rxBuffer->MaxRxSequence () << ")");
<       // Acknowledgement should be sent for all unacceptable packets (RFC793, p.69)
<       SendEmptyPacket (TcpHeader::ACK);
<       return false;
<     }
<   return true;
< }
< 
1260c1201
<   // Peel off TCP header
---
>   // Peel off TCP header and do validity checking
1262c1203
<   packet->RemoveHeader (tcpHeader);
---
>   uint32_t bytesRemoved = packet->RemoveHeader (tcpHeader);
1264,1265c1205,1210
< 
<   if (m_state == ESTABLISHED && !(tcpHeader.GetFlags () & TcpHeader::RST))
---
>   if (bytesRemoved == 0 || bytesRemoved > 60)
>     {
>       NS_LOG_ERROR ("Bytes removed: " << bytesRemoved << " invalid");
>       return; // Discard invalid packet
>     }
>   else if (packet->GetSize () > 0 && OutOfRange (seq, seq + packet->GetSize ()))
1267,1268c1212,1219
<       // Check if the sender has responded to ECN echo by reducing the Congestion Window
<       if (tcpHeader.GetFlags () & TcpHeader::CWR )
---
>       // Discard fully out of range data packets
>       NS_LOG_LOGIC ("At state " << TcpStateName[m_state] <<
>                     " received packet of seq [" << seq <<
>                     ":" << seq + packet->GetSize () <<
>                     ") out of range [" << m_rxBuffer->NextRxSequence () << ":" <<
>                     m_rxBuffer->MaxRxSequence () << ")");
>       // Acknowledgement should be sent for all unacceptable packets (RFC793, p.69)
>       if (m_state == ESTABLISHED && !(tcpHeader.GetFlags () & TcpHeader::RST))
1270,1277c1221
<           // Check if a packet with CE bit set is received. If there is no CE bit set, then change the state to ECN_IDLE to
<           // stop sending ECN Echo messages. If there is CE bit set, the packet should continue sending ECN Echo messages
<           //
<           if (m_tcb->m_ecnState != TcpSocketState::ECN_CE_RCVD)
<             {
<               NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_IDLE");
<               m_tcb->m_ecnState = TcpSocketState::ECN_IDLE;
<             }
---
>           SendEmptyPacket (TcpHeader::ACK);
1278a1223
>       return;
1300,1308d1244
<       if (tcpHeader.HasOption (TcpOption::SACKPERMITTED) && m_sackEnabled)
<         {
<           ProcessOptionSackPermitted (tcpHeader.GetOption (TcpOption::SACKPERMITTED));
<         }
<       else
<         {
<           m_sackEnabled = false;
<         }
< 
1322d1257
<       m_tcb->m_cWndInfl = m_tcb->m_cWnd;
1391c1326
<           h.SetAckNumber (m_tcb->m_rxBuffer->NextRxSequence ());
---
>           h.SetAckNumber (m_rxBuffer->NextRxSequence ());
1427c1362,1368
<       SendPendingData (m_connected);
---
>       // Try to send more data, since window has been updated
>       if (!m_sendPendingDataEvent.IsRunning ())
>         {
>           m_sendPendingDataEvent = Simulator::Schedule (TimeStep (1),
>                                                         &TcpSocketBase::SendPendingData,
>                                                         this, m_connected);
>         }
1438,1439c1379,1380
<   // Extract the flags. PSH, URG, CWR and ECE are disregarded.
<   uint8_t tcpflags = tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG | TcpHeader::CWR | TcpHeader::ECE);
---
>   // Extract the flags. PSH and URG are not honoured.
>   uint8_t tcpflags = tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG);
1448,1449c1389,1390
<           NS_LOG_WARN ("Ignored ack of " << tcpHeader.GetAckNumber () <<
<                        " SND.UNA = " << m_txBuffer->HeadSequence ());
---
>           NS_LOG_LOGIC ("Ignored ack of " << tcpHeader.GetAckNumber () <<
>                         " SND.UNA = " << m_txBuffer->HeadSequence ());
1458,1459c1399,1400
<           NS_LOG_WARN ("Ignored ack of " << tcpHeader.GetAckNumber () <<
<                        " HighTxMark = " << m_tcb->m_highTxMark);
---
>           NS_LOG_LOGIC ("Ignored ack of " << tcpHeader.GetAckNumber () <<
>                         " HighTxMark = " << m_tcb->m_highTxMark);
1461,1471c1402
<           // Receiver sets ECE flags when it receives a packet with CE bit on or sender hasn’t responded to ECN echo sent by receiver
<           if (m_tcb->m_ecnState == TcpSocketState::ECN_CE_RCVD || m_tcb->m_ecnState == TcpSocketState::ECN_SENDING_ECE)
<             {
<               SendEmptyPacket (TcpHeader::ACK | TcpHeader::ECE);
<               NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_SENDING_ECE");
<               m_tcb->m_ecnState = TcpSocketState::ECN_SENDING_ECE;
<             }
<           else
<             {
<               SendEmptyPacket (TcpHeader::ACK);
<             }
---
>           SendEmptyPacket (TcpHeader::ACK);
1495c1426
<       if (m_tcb->m_rxBuffer->Finished ())
---
>       if (m_rxBuffer->Finished ())
1511,1530d1441
< bool
< TcpSocketBase::IsTcpOptionEnabled (uint8_t kind) const
< {
<   NS_LOG_FUNCTION (this << static_cast<uint32_t> (kind));
< 
<   switch (kind)
<     {
<     case TcpOption::TS:
<       return m_timestampEnabled;
<     case TcpOption::WINSCALE:
<       return m_winScalingEnabled;
<     case TcpOption::SACKPERMITTED:
<     case TcpOption::SACK:
<       return m_sackEnabled;
<     default:
<       break;
<     }
<   return false;
< }
< 
1532c1443
< TcpSocketBase::ReadOptions (const TcpHeader &tcpHeader, uint32_t *bytesSacked)
---
> TcpSocketBase::LimitedTransmit ()
1534,1540c1445,1447
<   NS_LOG_FUNCTION (this << tcpHeader);
<   TcpHeader::TcpOptionList::const_iterator it;
<   const TcpHeader::TcpOptionList options = tcpHeader.GetOptionList ();
< 
<   for (it = options.begin (); it != options.end (); ++it)
<     {
<       const Ptr<const TcpOption> option = (*it);
---
>   NS_LOG_FUNCTION (this);
>   NS_ASSERT (m_limitedTx);
>   NS_ASSERT (m_txBuffer->SizeFromSequence (m_tcb->m_nextTxSequence) > 0);
1542,1551c1449,1451
<       // Check only for ACK options here
<       switch (option->GetKind ())
<         {
<         case TcpOption::SACK:
<           *bytesSacked = ProcessOptionSack (option);
<           break;
<         default:
<           continue;
<         }
<     }
---
>   NS_LOG_INFO ("Limited transmit");
>   uint32_t sz = SendDataPacket (m_tcb->m_nextTxSequence, m_tcb->m_segmentSize, true);
>   m_tcb->m_nextTxSequence += sz;
1555c1455
< TcpSocketBase::EnterRecovery (uint32_t currentDelivered)
---
> TcpSocketBase::FastRetransmit ()
1560,1582d1459
<   NS_LOG_DEBUG (TcpSocketState::TcpCongStateName[m_tcb->m_congState] <<
<                 " -> CA_RECOVERY");
< 
<   if (!m_sackEnabled)
<     {
<       // One segment has left the network, PLUS the head is lost
<       m_txBuffer->AddRenoSack ();
<       m_txBuffer->MarkHeadAsLost ();
<     }
<   else
<     {
<       if (!m_txBuffer->IsLost (m_txBuffer->HeadSequence ()))
<         {
<           // We received 3 dupacks, but the head is not marked as lost
<           // (received less than 3 SACK block ahead).
<           // Manually set it as lost.
<           m_txBuffer->MarkHeadAsLost ();
<         }
<     }
< 
<   // RFC 6675, point (4):
<   // (4) Invoke fast retransmit and enter loss recovery as follows:
<   // (4.1) RecoveryPoint = HighData
1584d1460
< 
1588,1604c1464,1470
<   // (4.2) ssthresh = cwnd = (FlightSize / 2)
<   // If SACK is not enabled, still consider the head as 'in flight' for
<   // compatibility with old ns-3 versions
<   uint32_t bytesInFlight = m_sackEnabled ? BytesInFlight () : BytesInFlight () + m_tcb->m_segmentSize;
<   m_tcb->m_ssThresh = m_congestionControl->GetSsThresh (m_tcb, bytesInFlight);
< 
<   if (!m_congestionControl->HasCongControl ())
<     {
<       m_recoveryOps->EnterRecovery (m_tcb, m_dupAckCount, UnAckDataCount (), currentDelivered);
<       NS_LOG_INFO (m_dupAckCount << " dupack. Enter fast recovery mode." <<
<                   "Reset cwnd to " << m_tcb->m_cWnd << ", ssthresh to " <<
<                    m_tcb->m_ssThresh << " at fast recovery seqnum " << m_recover <<
<                    " calculated in flight: " << bytesInFlight);
<     }
< 
< 
<   // (4.3) Retransmit the first data segment presumed dropped
---
>   m_tcb->m_ssThresh = m_congestionControl->GetSsThresh (m_tcb,
>                                                         BytesInFlight ());
>   m_tcb->m_cWnd = m_tcb->m_ssThresh + m_dupAckCount * m_tcb->m_segmentSize;
> 
>   NS_LOG_INFO (m_dupAckCount << " dupack. Enter fast recovery mode." <<
>                "Reset cwnd to " << m_tcb->m_cWnd << ", ssthresh to " <<
>                m_tcb->m_ssThresh << " at fast recovery seqnum " << m_recover);
1606,1608d1471
<   // (4.4) Run SetPipe ()
<   // (4.5) Proceed to step (C)
<   // these steps are done after the ProcessAck function (SendPendingData)
1612c1475
< TcpSocketBase::DupAck (uint32_t currentDelivered)
---
> TcpSocketBase::DupAck ()
1615,1633c1478
<   // NOTE: We do not count the DupAcks received in CA_LOSS, because we
<   // don't know if they are generated by a spurious retransmission or because
<   // of a real packet loss. With SACK, it is easy to know, but we do not consider
<   // dupacks. Without SACK, there are some euristics in the RFC 6582, but
<   // for now, we do not implement it, leading to ignoring the dupacks.
<   if (m_tcb->m_congState == TcpSocketState::CA_LOSS)
<     {
<       return;
<     }
< 
<   // RFC 6675, Section 5, 3rd paragraph:
<   // If the incoming ACK is a duplicate acknowledgment per the definition
<   // in Section 2 (regardless of its status as a cumulative
<   // acknowledgment), and the TCP is not currently in loss recovery
<   // the TCP MUST increase DupAcks by one ...
<   if (m_tcb->m_congState != TcpSocketState::CA_RECOVERY)
<     {
<       ++m_dupAckCount;
<     }
---
>   ++m_dupAckCount;
1644c1489
<       NS_LOG_DEBUG ("CA_OPEN -> CA_DISORDER");
---
>       NS_LOG_DEBUG ("OPEN -> DISORDER");
1647c1492
<   if (m_tcb->m_congState == TcpSocketState::CA_RECOVERY)
---
>   if (m_tcb->m_congState == TcpSocketState::CA_DISORDER)
1649,1666d1493
<       if (!m_sackEnabled)
<         {
<           // If we are in recovery and we receive a dupack, one segment
<           // has left the network. This is equivalent to a SACK of one block.
<           m_txBuffer->AddRenoSack ();
<         }
<       if (!m_congestionControl->HasCongControl ())
<         {
<           m_recoveryOps->DoRecovery (m_tcb, currentDelivered);
<           NS_LOG_INFO (m_dupAckCount << " Dupack received in fast recovery mode."
<                        "Increase cwnd to " << m_tcb->m_cWnd);
<         }
<     }
<   else if (m_tcb->m_congState == TcpSocketState::CA_DISORDER)
<     {
<       // RFC 6675, Section 5, continuing:
<       // ... and take the following steps:
<       // (1) If DupAcks >= DupThresh, go to step (4).
1669,1697c1496,1512
<           EnterRecovery (currentDelivered);
<           NS_ASSERT (m_tcb->m_congState == TcpSocketState::CA_RECOVERY);
<         }
<       // (2) If DupAcks < DupThresh but IsLost (HighACK + 1) returns true
<       // (indicating at least three segments have arrived above the current
<       // cumulative acknowledgment point, which is taken to indicate loss)
<       // go to step (4).
<       else if (m_txBuffer->IsLost (m_highRxAckMark + m_tcb->m_segmentSize))
<         {
<           EnterRecovery (currentDelivered);
<           NS_ASSERT (m_tcb->m_congState == TcpSocketState::CA_RECOVERY);
<         }
<       else
<         {
<           // (3) The TCP MAY transmit previously unsent data segments as per
<           // Limited Transmit [RFC5681] ...except that the number of octets
<           // which may be sent is governed by pipe and cwnd as follows:
<           //
<           // (3.1) Set HighRxt to HighACK.
<           // Not clear in RFC. We don't do this here, since we still have
<           // to retransmit the segment.
< 
<           if (!m_sackEnabled && m_limitedTx)
<             {
<               m_txBuffer->AddRenoSack ();
< 
<               // In limited transmit, cwnd Infl is not updated.
<             }
<         }
---
>           // triple duplicate ack triggers fast retransmit (RFC2582 sec.3 bullet #1)
>           NS_LOG_DEBUG (TcpSocketState::TcpCongStateName[m_tcb->m_congState] <<
>                         " -> RECOVERY");
>           FastRetransmit ();
>         }
>       else if (m_limitedTx && m_txBuffer->SizeFromSequence (m_tcb->m_nextTxSequence) > 0)
>         {
>           // RFC3042 Limited transmit: Send a new packet for each duplicated ACK before fast retransmit
>           LimitedTransmit ();
>         }
>     }
>   else if (m_tcb->m_congState == TcpSocketState::CA_RECOVERY)
>     { // Increase cwnd for every additional dupack (RFC2582, sec.3 bullet #3)
>       m_tcb->m_cWnd += m_tcb->m_segmentSize;
>       NS_LOG_INFO (m_dupAckCount << " Dupack received in fast recovery mode."
>                    "Increase cwnd to " << m_tcb->m_cWnd);
>       SendPendingData (m_connected);
1698a1514,1516
> 
>   // Artificially call PktsAcked. After all, one segment has been ACKed.
>   m_congestionControl->PktsAcked (m_tcb, 1, m_lastRtt);
1710,1716d1527
<   // RFC 6675, Section 5, 1st paragraph:
<   // Upon the receipt of any ACK containing SACK information, the
<   // scoreboard MUST be updated via the Update () routine (done in ReadOptions)
<   uint32_t bytesSacked = 0;
<   uint64_t previousDelivered = m_rateOps->GetConnectionRate ().m_delivered;
<   ReadOptions (tcpHeader, &bytesSacked);
< 
1718,1736d1528
<   SequenceNumber32 oldHeadSequence = m_txBuffer->HeadSequence ();
<   m_txBuffer->DiscardUpTo (ackNumber, MakeCallback (&TcpRateOps::SkbDelivered, m_rateOps));
< 
<   uint32_t currentDelivered = static_cast<uint32_t> (m_rateOps->GetConnectionRate ().m_delivered - previousDelivered);
< 
<   if (ackNumber > oldHeadSequence && (m_tcb->m_ecnState != TcpSocketState::ECN_DISABLED) && (tcpHeader.GetFlags () & TcpHeader::ECE))
<     {
<       if (m_ecnEchoSeq < ackNumber)
<         {
<           NS_LOG_INFO ("Received ECN Echo is valid");
<           m_ecnEchoSeq = ackNumber;
<           NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_ECE_RCVD");
<           m_tcb->m_ecnState = TcpSocketState::ECN_ECE_RCVD;
<         }
<     }
<   else if (m_tcb->m_ecnState == TcpSocketState::ECN_ECE_RCVD && !(tcpHeader.GetFlags () & TcpHeader::ECE))
<     {
<       m_tcb->m_ecnState = TcpSocketState::ECN_IDLE;
<     }
1738,1740c1530,1532
<   // Update bytes in flight before processing the ACK for proper calculation of congestion window
<   NS_LOG_INFO ("Update bytes in flight before processing the ACK.");
<   BytesInFlight ();
---
>   NS_LOG_DEBUG ("ACK of " << ackNumber <<
>                 " SND.UNA=" << m_txBuffer->HeadSequence () <<
>                 " SND.NXT=" << m_tcb->m_nextTxSequence);
1742,1744c1534
<   // RFC 6675 Section 5: 2nd, 3rd paragraph and point (A), (B) implementation
<   // are inside the function ProcessAck
<   ProcessAck (ackNumber, (bytesSacked > 0), currentDelivered, oldHeadSequence);
---
>   m_tcb->m_lastAckedSeq = ackNumber;
1746c1536,1538
<   if (m_congestionControl->HasCongControl ())
---
>   if (ackNumber == m_txBuffer->HeadSequence ()
>       && ackNumber < m_tcb->m_nextTxSequence
>       && packet->GetSize () == 0)
1748,1757c1540,1541
<       uint32_t previousLost = m_txBuffer->GetLost ();
<       uint32_t priorInFlight = m_tcb->m_bytesInFlight.Get ();
<       uint32_t currentLost = m_txBuffer->GetLost ();
<       uint32_t lost = (currentLost > previousLost) ?
<             currentLost - previousLost :
<             previousLost - currentLost;
<       auto rateSample = m_rateOps->GenerateSample (currentDelivered, lost,
<                                               false, priorInFlight, m_tcb->m_minRtt);
<       auto rateConn = m_rateOps->GetConnectionRate ();
<       m_congestionControl->CongControl(m_tcb, rateConn, rateSample);
---
>       // There is a DupAck
>       DupAck ();
1759,1824c1543,1544
< 
<   // If there is any data piggybacked, store it into m_rxBuffer
<   if (packet->GetSize () > 0)
<     {
<       ReceivedData (packet, tcpHeader);
<     }
< 
<   // RFC 6675, Section 5, point (C), try to send more data. NB: (C) is implemented
<   // inside SendPendingData
<   SendPendingData (m_connected);
< }
< 
< void
< TcpSocketBase::ProcessAck(const SequenceNumber32 &ackNumber, bool scoreboardUpdated,
<                           uint32_t currentDelivered, const SequenceNumber32 &oldHeadSequence)
< {
<   NS_LOG_FUNCTION (this << ackNumber << scoreboardUpdated);
<   // RFC 6675, Section 5, 2nd paragraph:
<   // If the incoming ACK is a cumulative acknowledgment, the TCP MUST
<   // reset DupAcks to zero.
<   bool exitedFastRecovery = false;
<   uint32_t oldDupAckCount = m_dupAckCount; // remember the old value
<   m_tcb->m_lastAckedSeq = ackNumber; // Update lastAckedSeq
<   uint32_t bytesAcked = 0;
< 
<   /* In RFC 5681 the definition of duplicate acknowledgment was strict:
<    *
<    * (a) the receiver of the ACK has outstanding data,
<    * (b) the incoming acknowledgment carries no data,
<    * (c) the SYN and FIN bits are both off,
<    * (d) the acknowledgment number is equal to the greatest acknowledgment
<    *     received on the given connection (TCP.UNA from [RFC793]),
<    * (e) the advertised window in the incoming acknowledgment equals the
<    *     advertised window in the last incoming acknowledgment.
<    *
<    * With RFC 6675, this definition has been reduced:
<    *
<    * (a) the ACK is carrying a SACK block that identifies previously
<    *     unacknowledged and un-SACKed octets between HighACK (TCP.UNA) and
<    *     HighData (m_highTxMark)
<    */
< 
<   bool isDupack = m_sackEnabled ?
<     scoreboardUpdated
<     : ackNumber == oldHeadSequence &&
<     ackNumber < m_tcb->m_highTxMark;
< 
<   NS_LOG_DEBUG ("ACK of " << ackNumber <<
<                 " SND.UNA=" << oldHeadSequence <<
<                 " SND.NXT=" << m_tcb->m_nextTxSequence <<
<                 " in state: " << TcpSocketState::TcpCongStateName[m_tcb->m_congState] <<
<                 " with m_recover: " << m_recover);
< 
<   // RFC 6675, Section 5, 3rd paragraph:
<   // If the incoming ACK is a duplicate acknowledgment per the definition
<   // in Section 2 (regardless of its status as a cumulative
<   // acknowledgment), and the TCP is not currently in loss recovery
<   if (isDupack)
<     {
<       // loss recovery check is done inside this function thanks to
<       // the congestion state machine
<       DupAck (currentDelivered);
<     }
< 
<   if (ackNumber == oldHeadSequence
<       && ackNumber == m_tcb->m_highTxMark)
---
>   else if (ackNumber == m_txBuffer->HeadSequence ()
>            && ackNumber == m_tcb->m_nextTxSequence)
1827,1835d1546
<       return;
<     }
<   else if (ackNumber == oldHeadSequence
<            && ackNumber > m_tcb->m_highTxMark)
<     {
<       // ACK of the FIN bit ... nextTxSequence is not updated since we
<       // don't have anything to transmit
<       NS_LOG_DEBUG ("Update nextTxSequence manually to " << ackNumber);
<       m_tcb->m_nextTxSequence = ackNumber;
1837,1846c1548,1552
<   else if (ackNumber == oldHeadSequence)
<     {
<       // DupAck. Artificially call PktsAcked: after all, one segment has been ACKed.
<       m_congestionControl->PktsAcked (m_tcb, 1, m_tcb->m_lastRtt);
<     }
<   else if (ackNumber > oldHeadSequence)
<     {
<       // Please remember that, with SACK, we can enter here even if we
<       // received a dupack.
<       bytesAcked = ackNumber - oldHeadSequence;
---
>   else if (ackNumber > m_txBuffer->HeadSequence ())
>     { // Case 3: New ACK, reset m_dupAckCount and update m_txBuffer
>       bool callCongestionControl = true;
>       bool resetRTO = true;
>       uint32_t bytesAcked = ackNumber - m_txBuffer->HeadSequence ();
1849d1554
<       bytesAcked -= bytesAcked % m_tcb->m_segmentSize;
1854d1558
<           bytesAcked += m_tcb->m_segmentSize;
1858,1865c1562,1578
<       // Dupack count is reset to eventually fast-retransmit after 3 dupacks.
<       // Any SACK-ed segment will be cleaned up by DiscardUpTo.
<       // In the case that we advanced SND.UNA, but the ack contains SACK blocks,
<       // we do not reset. At the third one we will retransmit.
<       // If we are already in recovery, this check is useless since dupAcks
<       // are not considered in this phase. When from Recovery we go back
<       // to open, then dupAckCount is reset anyway.
<       if (!isDupack)
---
>       NS_LOG_LOGIC (" Bytes acked: " << bytesAcked <<
>                     " Segments acked: " << segsAcked <<
>                     " bytes left: " << m_bytesAckedNotProcessed);
> 
>       /* The following switch is made because m_dupAckCount can be
>        * "inflated" through out-of-order segments (e.g. from retransmission,
>        * while segments have not been lost but are network-reordered). At
>        * least one segment has been acked; in the luckiest case, an amount
>        * equals to segsAcked-m_dupAckCount has not been processed.
>        *
>        * To be clear: segsAcked will be passed to PktsAcked, and it should take
>        * in considerations the times that it has been already called, while newSegsAcked
>        * will be passed to IncreaseCwnd, and it represents the amount of
>        * segments that are allowed to increase the cWnd value.
>        */
>       uint32_t newSegsAcked = segsAcked;
>       if (segsAcked > m_dupAckCount)
1867c1580
<           m_dupAckCount = 0;
---
>           segsAcked -= m_dupAckCount;
1869,1882c1582
< 
<       // RFC 6675, Section 5, part (B)
<       // (B) Upon receipt of an ACK that does not cover RecoveryPoint, the
<       // following actions MUST be taken:
<       //
<       // (B.1) Use Update () to record the new SACK information conveyed
<       //       by the incoming ACK.
<       // (B.2) Use SetPipe () to re-calculate the number of octets still
<       //       in the network.
<       //
<       // (B.1) is done at the beginning, while (B.2) is delayed to part (C) while
<       // trying to transmit with SendPendingData. We are not allowed to exit
<       // the CA_RECOVERY phase. Just process this partial ack (RFC 5681)
<       if (ackNumber < m_recover && m_tcb->m_congState == TcpSocketState::CA_RECOVERY)
---
>       else
1884,1907c1584,1585
<           if (!m_sackEnabled)
<             {
<               // Manually set the head as lost, it will be retransmitted.
<               NS_LOG_INFO ("Partial ACK. Manually setting head as lost");
<               m_txBuffer->MarkHeadAsLost ();
<             }
<           else
<             {
<               // We received a partial ACK, if we retransmitted this segment
<               // probably is better to retransmit it
<               m_txBuffer->DeleteRetransmittedFlagFromHead ();
<             }
<           DoRetransmit (); // Assume the next seq is lost. Retransmit lost packet
<           m_tcb->m_cWndInfl = SafeSubtraction (m_tcb->m_cWndInfl, bytesAcked);
<           if (!m_congestionControl->HasCongControl () && segsAcked >= 1)
<             {
<               m_recoveryOps->DoRecovery (m_tcb, currentDelivered);
<             }
< 
<           // This partial ACK acknowledge the fact that one segment has been
<           // previously lost and now successfully received. All others have
<           // been processed when they come under the form of dupACKs
<           m_congestionControl->PktsAcked (m_tcb, 1, m_tcb->m_lastRtt);
<           NewAck (ackNumber, m_isFirstPartialAck);
---
>           segsAcked = 1;
>         }
1909,1925c1587,1589
<           if (m_isFirstPartialAck)
<             {
<               NS_LOG_DEBUG ("Partial ACK of " << ackNumber <<
<                             " and this is the first (RTO will be reset);"
<                             " cwnd set to " << m_tcb->m_cWnd <<
<                             " recover seq: " << m_recover <<
<                             " dupAck count: " << m_dupAckCount);
<               m_isFirstPartialAck = false;
<             }
<           else
<             {
<               NS_LOG_DEBUG ("Partial ACK of " << ackNumber <<
<                             " and this is NOT the first (RTO will not be reset)"
<                             " cwnd set to " << m_tcb->m_cWnd <<
<                             " recover seq: " << m_recover <<
<                             " dupAck count: " << m_dupAckCount);
<             }
---
>       if (m_tcb->m_congState == TcpSocketState::CA_OPEN)
>         {
>           m_congestionControl->PktsAcked (m_tcb, segsAcked, m_lastRtt);
1927,1944c1591,1601
<       // From RFC 6675 section 5.1
<       // In addition, a new recovery phase (as described in Section 5) MUST NOT
<       // be initiated until HighACK is greater than or equal to the new value
<       // of RecoveryPoint.
<       else if (ackNumber < m_recover && m_tcb->m_congState == TcpSocketState::CA_LOSS)
<         {
<           m_congestionControl->PktsAcked (m_tcb, segsAcked, m_tcb->m_lastRtt);
<           m_congestionControl->IncreaseWindow (m_tcb, segsAcked);
< 
<           NS_LOG_DEBUG (" Cong Control Called, cWnd=" << m_tcb->m_cWnd <<
<                         " ssTh=" << m_tcb->m_ssThresh);
<           if (!m_sackEnabled)
<             {
<               NS_ASSERT_MSG (m_txBuffer->GetSacked () == 0,
<                              "Some segment got dup-acked in CA_LOSS state: " <<
<                              m_txBuffer->GetSacked ());
<             }
<           NewAck (ackNumber, true);
---
>       else if (m_tcb->m_congState == TcpSocketState::CA_DISORDER)
>         {
>           // The network reorder packets. Linux changes the counting lost
>           // packet algorithm from FACK to NewReno. We simply go back in Open.
>           m_congestionControl->CongestionStateSet (m_tcb, TcpSocketState::CA_OPEN);
>           m_tcb->m_congState = TcpSocketState::CA_OPEN;
>           m_congestionControl->PktsAcked (m_tcb, segsAcked, m_lastRtt);
>           m_dupAckCount = 0;
>           m_retransOut = 0;
> 
>           NS_LOG_DEBUG ("DISORDER -> OPEN");
1946c1603
<       else
---
>       else if (m_tcb->m_congState == TcpSocketState::CA_RECOVERY)
1948,1952c1605
<           if (m_tcb->m_congState == TcpSocketState::CA_OPEN)
<             {
<               m_congestionControl->PktsAcked (m_tcb, segsAcked, m_tcb->m_lastRtt);
<             }
<           else if (m_tcb->m_congState == TcpSocketState::CA_DISORDER)
---
>           if (ackNumber < m_recover)
1954c1607,1624
<               if (segsAcked >= oldDupAckCount)
---
>               /* Partial ACK.
>                * In case of partial ACK, retransmit the first unacknowledged
>                * segment. Deflate the congestion window by the amount of new
>                * data acknowledged by the Cumulative Acknowledgment field.
>                * If the partial ACK acknowledges at least one SMSS of new data,
>                * then add back SMSS bytes to the congestion window.
>                * This artificially inflates the congestion window in order to
>                * reflect the additional segment that has left the network.
>                * Send a new segment if permitted by the new value of cwnd.
>                * This "partial window deflation" attempts to ensure that, when
>                * fast recovery eventually ends, approximately ssthresh amount
>                * of data will be outstanding in the network.  Do not exit the
>                * fast recovery procedure (i.e., if any duplicate ACKs subsequently
>                * arrive, execute step 4 of Section 3.2 of [RFC5681]).
>                 */
>               m_tcb->m_cWnd = SafeSubtraction (m_tcb->m_cWnd, bytesAcked);
> 
>               if (segsAcked >= 1)
1956c1626
<                   m_congestionControl->PktsAcked (m_tcb, segsAcked - oldDupAckCount, m_tcb->m_lastRtt);
---
>                   m_tcb->m_cWnd += m_tcb->m_segmentSize;
1959c1629,1636
<               if (!isDupack)
---
>               callCongestionControl = false; // No congestion control on cWnd show be invoked
>               m_dupAckCount = SafeSubtraction (m_dupAckCount, segsAcked); // Update the dupAckCount
>               m_retransOut  = SafeSubtraction (m_retransOut, 1);  // at least one retransmission
>                                                                   // has reached the other side
>               m_txBuffer->DiscardUpTo (ackNumber);  //Bug 1850:  retransmit before newack
>               DoRetransmit (); // Assume the next seq is lost. Retransmit lost packet
> 
>               if (m_isFirstPartialAck)
1961,1966c1638
<                   // The network reorder packets. Linux changes the counting lost
<                   // packet algorithm from FACK to NewReno. We simply go back in Open.
<                   m_congestionControl->CongestionStateSet (m_tcb, TcpSocketState::CA_OPEN);
<                   m_tcb->m_congState = TcpSocketState::CA_OPEN;
<                   NS_LOG_DEBUG (segsAcked << " segments acked in CA_DISORDER, ack of " <<
<                                 ackNumber << " exiting CA_DISORDER -> CA_OPEN");
---
>                   m_isFirstPartialAck = false;
1970,1971c1642
<                   NS_LOG_DEBUG (segsAcked << " segments acked in CA_DISORDER, ack of " <<
<                                 ackNumber << " but still in CA_DISORDER");
---
>                   resetRTO = false;
1973,1984c1644,1659
<             }
<           // RFC 6675, Section 5:
<           // Once a TCP is in the loss recovery phase, the following procedure
<           // MUST be used for each arriving ACK:
<           // (A) An incoming cumulative ACK for a sequence number greater than
<           // RecoveryPoint signals the end of loss recovery, and the loss
<           // recovery phase MUST be terminated.  Any information contained in
<           // the scoreboard for sequence numbers greater than the new value of
<           // HighACK SHOULD NOT be cleared when leaving the loss recovery
<           // phase.
<           else if (m_tcb->m_congState == TcpSocketState::CA_RECOVERY)
<             {
---
> 
>               /* This partial ACK acknowledge the fact that one segment has been
>                * previously lost and now successfully received. All others have
>                * been processed when they come under the form of dupACKs
>                */
>               m_congestionControl->PktsAcked (m_tcb, 1, m_lastRtt);
> 
>               NS_LOG_INFO ("Partial ACK for seq " << ackNumber <<
>                            " in fast recovery: cwnd set to " << m_tcb->m_cWnd <<
>                            " recover seq: " << m_recover <<
>                            " dupAck count: " << m_dupAckCount);
>             }
>           else if (ackNumber >= m_recover)
>             { // Full ACK (RFC2582 sec.3 bullet #5 paragraph 2, option 1)
>               m_tcb->m_cWnd = std::min (m_tcb->m_ssThresh.Get (),
>                                         BytesInFlight () + m_tcb->m_segmentSize);
1985a1661,1662
>               m_dupAckCount = 0;
>               m_retransOut = 0;
1987,1992c1664,1670
<               // Recalculate the segs acked, that are from m_recover to ackNumber
<               // (which are the ones we have not passed to PktsAcked and that
<               // can increase cWnd)
<               segsAcked = static_cast<uint32_t>(ackNumber - m_recover) / m_tcb->m_segmentSize;
<               m_congestionControl->PktsAcked (m_tcb, segsAcked, m_tcb->m_lastRtt);
<               m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_COMPLETE_CWR);
---
>               /* This FULL ACK acknowledge the fact that one segment has been
>                * previously lost and now successfully received. All others have
>                * been processed when they come under the form of dupACKs,
>                * except the (maybe) new ACKs which come from a new window
>                */
>               m_congestionControl->PktsAcked (m_tcb, segsAcked, m_lastRtt);
>               newSegsAcked = (ackNumber - m_recover) / m_tcb->m_segmentSize;
1995,1996d1672
<               exitedFastRecovery = true;
<               m_dupAckCount = 0; // From recovery to open, reset dupack
1998,1999c1674,1676
<               NS_LOG_DEBUG (segsAcked << " segments acked in CA_RECOVER, ack of " <<
<                             ackNumber << ", exiting CA_RECOVERY -> CA_OPEN");
---
>               NS_LOG_INFO ("Received full ACK for seq " << ackNumber <<
>                            ". Leaving fast recovery with cwnd set to " << m_tcb->m_cWnd);
>               NS_LOG_DEBUG ("RECOVERY -> OPEN");
2001c1678,1686
<           else if (m_tcb->m_congState == TcpSocketState::CA_LOSS)
---
>         }
>       else if (m_tcb->m_congState == TcpSocketState::CA_LOSS)
>         {
>           // Go back in OPEN state
>           m_isFirstPartialAck = true;
>           m_congestionControl->PktsAcked (m_tcb, segsAcked, m_lastRtt);
>           m_dupAckCount = 0;
>           m_retransOut = 0;
>           if(ackNumber >= m_recover + 1)
2003,2011d1687
<               m_isFirstPartialAck = true;
< 
<               // Recalculate the segs acked, that are from m_recover to ackNumber
<               // (which are the ones we have not passed to PktsAcked and that
<               // can increase cWnd)
<               segsAcked = (ackNumber - m_recover) / m_tcb->m_segmentSize;
< 
<               m_congestionControl->PktsAcked (m_tcb, segsAcked, m_tcb->m_lastRtt);
< 
2014,2015c1690
<               NS_LOG_DEBUG (segsAcked << " segments acked in CA_LOSS, ack of" <<
<                             ackNumber << ", exiting CA_LOSS -> CA_OPEN");
---
>               NS_LOG_DEBUG ("LOSS -> OPEN");
2016a1692
>         }
2018,2027c1694,1696
<           if (exitedFastRecovery)
<             {
<               NewAck (ackNumber, true);
<               m_recoveryOps->ExitRecovery (m_tcb);
<               NS_LOG_DEBUG ("Leaving Fast Recovery; BytesInFlight() = " <<
<                             BytesInFlight () << "; cWnd = " << m_tcb->m_cWnd);
<             }
<           else
<             {
<               m_congestionControl->IncreaseWindow (m_tcb, segsAcked);
---
>       if (callCongestionControl)
>         {
>           m_congestionControl->IncreaseWindow (m_tcb, newSegsAcked);
2029c1698,1701
<               m_tcb->m_cWndInfl = m_tcb->m_cWnd;
---
>           NS_LOG_LOGIC ("Congestion control called: " <<
>                         " cWnd: " << m_tcb->m_cWnd <<
>                         " ssTh: " << m_tcb->m_ssThresh);
>         }
2031,2034c1703,1704
<               NS_LOG_LOGIC ("Congestion control called: " <<
<                             " cWnd: " << m_tcb->m_cWnd <<
<                             " ssTh: " << m_tcb->m_ssThresh <<
<                             " segsAcked: " << segsAcked);
---
>       // Reset the data retransmission count. We got a new ACK!
>       m_dataRetrCount = m_dataRetries;
2036,2037c1706,1708
<               NewAck (ackNumber, true);
<             }
---
>       if (m_isFirstPartialAck == false)
>         {
>           NS_ASSERT (m_tcb->m_congState == TcpSocketState::CA_RECOVERY);
2038a1710,1725
> 
>       NewAck (ackNumber, resetRTO);
> 
>       // Try to send more data
>       if (!m_sendPendingDataEvent.IsRunning ())
>         {
>           m_sendPendingDataEvent = Simulator::Schedule (TimeStep (1),
>                                                         &TcpSocketBase::SendPendingData,
>                                                         this, m_connected);
>         }
>     }
> 
>   // If there is any data piggybacked, store it into m_rxBuffer
>   if (packet->GetSize () > 0)
>     {
>       ReceivedData (packet, tcpHeader);
2049,2050c1736,1737
<   // Extract the flags. PSH, URG, CWR and ECE are disregarded.
<   uint8_t tcpflags = tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG | TcpHeader::CWR | TcpHeader::ECE);
---
>   // Extract the flags. PSH and URG are not honoured.
>   uint8_t tcpflags = tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG);
2078c1765
<   // Extract the flags. PSH and URG are disregarded.
---
>   // Extract the flags. PSH and URG are not honoured.
2085d1771
<       m_tcb->m_congState = TcpSocketState::CA_OPEN;
2093c1779
<   else if (tcpflags & TcpHeader::ACK && !(tcpflags & TcpHeader::SYN))
---
>   else if (tcpflags == TcpHeader::ACK)
2096c1782
<   else if (tcpflags & TcpHeader::SYN && !(tcpflags & TcpHeader::ACK))
---
>   else if (tcpflags == TcpHeader::SYN)
2101,2117c1787,1788
<       m_tcb->m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
<       /* Check if we received an ECN SYN packet. Change the ECN state of receiver to ECN_IDLE if the traffic is ECN capable and
<        * sender has sent ECN SYN packet
<        */
< 
<       if (m_tcb->m_useEcn != TcpSocketState::Off && (tcpflags & (TcpHeader::CWR | TcpHeader::ECE)) == (TcpHeader::CWR | TcpHeader::ECE))
<         {
<           NS_LOG_INFO ("Received ECN SYN packet");
<           SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK | TcpHeader::ECE);
<           NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_IDLE");
<           m_tcb->m_ecnState = TcpSocketState::ECN_IDLE;
<         }
<       else
<         {
<           m_tcb->m_ecnState = TcpSocketState::ECN_DISABLED;
<           SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
<         }
---
>       m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
>       SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
2119c1790
<   else if (tcpflags & (TcpHeader::SYN | TcpHeader::ACK)
---
>   else if (tcpflags == (TcpHeader::SYN | TcpHeader::ACK)
2124d1794
<       m_tcb->m_congState = TcpSocketState::CA_OPEN;
2128c1798
<       m_tcb->m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
---
>       m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
2132,2145d1801
< 
<       /* Check if we received an ECN SYN-ACK packet. Change the ECN state of sender to ECN_IDLE if receiver has sent an ECN SYN-ACK
<        * packet and the  traffic is ECN Capable
<        */
<       if (m_tcb->m_useEcn != TcpSocketState::Off && (tcpflags & (TcpHeader::CWR | TcpHeader::ECE)) == (TcpHeader::ECE))
<         {
<           NS_LOG_INFO ("Received ECN SYN-ACK packet.");
<           NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_IDLE");
<           m_tcb->m_ecnState = TcpSocketState::ECN_IDLE;
<         }
<       else
<         {
<           m_tcb->m_ecnState = TcpSocketState::ECN_DISABLED;
<         }
2154c1810
<       if (!(tcpflags & TcpHeader::RST))
---
>       if (tcpflags != TcpHeader::RST)
2156,2157c1812,1813
<           NS_LOG_LOGIC ("Illegal flag combination " << TcpHeader::FlagsToString (tcpHeader.GetFlags ()) <<
<                         " received in SYN_SENT. Reset packet is sent.");
---
>           NS_LOG_LOGIC ("Illegal flag " << TcpHeader::FlagsToString (tcpflags) <<
>                         " received. Reset packet is sent.");
2169d1824
<   NS_UNUSED (toAddress);
2172,2173c1827,1828
<   // Extract the flags. PSH, URG, CWR and ECE are disregarded.
<   uint8_t tcpflags = tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG | TcpHeader::CWR | TcpHeader::ECE);
---
>   // Extract the flags. PSH and URG are not honoured.
>   uint8_t tcpflags = tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG);
2183d1837
<       m_tcb->m_congState = TcpSocketState::CA_OPEN;
2202d1855
<       NotifyNewConnectionCreated (this, fromAddress);
2203a1857
>       NotifyNewConnectionCreated (this, fromAddress);
2212,2227c1866,1867
<       m_tcb->m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
<       /* Check if we received an ECN SYN packet. Change the ECN state of receiver to ECN_IDLE if sender has sent an ECN SYN
<        * packet and the  traffic is ECN Capable
<        */
<       if (m_tcb->m_useEcn != TcpSocketState::Off && (tcpHeader.GetFlags () & (TcpHeader::CWR | TcpHeader::ECE)) == (TcpHeader::CWR | TcpHeader::ECE))
<         {
<           NS_LOG_INFO ("Received ECN SYN packet");
<           SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK |TcpHeader::ECE);
<           NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_IDLE");
<           m_tcb->m_ecnState = TcpSocketState::ECN_IDLE;
<        }
<       else
<         {
<           m_tcb->m_ecnState = TcpSocketState::ECN_DISABLED;
<           SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
<         }
---
>       m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
>       SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
2231c1871
<       if (tcpHeader.GetSequenceNumber () == m_tcb->m_rxBuffer->NextRxSequence ())
---
>       if (tcpHeader.GetSequenceNumber () == m_rxBuffer->NextRxSequence ())
2247d1886
<           NotifyNewConnectionCreated (this, fromAddress);
2279,2280c1918,1919
<   // Extract the flags. PSH, URG, CWR and ECE are disregarded.
<   uint8_t tcpflags = tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG | TcpHeader::CWR | TcpHeader::ECE);
---
>   // Extract the flags. PSH and URG are not honoured.
>   uint8_t tcpflags = tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG);
2282c1921
<   if (packet->GetSize () > 0 && !(tcpflags & TcpHeader::ACK))
---
>   if (packet->GetSize () > 0 && tcpflags != TcpHeader::ACK)
2302c1941
<       m_tcb->m_rxBuffer->SetFinSequence (tcpHeader.GetSequenceNumber ());
---
>       m_rxBuffer->SetFinSequence (tcpHeader.GetSequenceNumber ());
2321c1960
<   if ((m_state == FIN_WAIT_1 || m_state == FIN_WAIT_2) && m_tcb->m_rxBuffer->Finished ())
---
>   if ((m_state == FIN_WAIT_1 || m_state == FIN_WAIT_2) && m_rxBuffer->Finished ())
2351c1990
<   // Extract the flags. PSH and URG are disregarded.
---
>   // Extract the flags. PSH and URG are not honoured.
2356c1995
<       if (tcpHeader.GetSequenceNumber () == m_tcb->m_rxBuffer->NextRxSequence ())
---
>       if (tcpHeader.GetSequenceNumber () == m_rxBuffer->NextRxSequence ())
2383c2022
<   // Extract the flags. PSH and URG are disregarded.
---
>   // Extract the flags. PSH and URG are not honoured.
2392c2031
<       if (tcpHeader.GetSequenceNumber () == m_tcb->m_rxBuffer->NextRxSequence ())
---
>       if (tcpHeader.GetSequenceNumber () == m_rxBuffer->NextRxSequence ())
2420,2421c2059,2060
<   if (tcpHeader.GetSequenceNumber () < m_tcb->m_rxBuffer->NextRxSequence ()
<       || tcpHeader.GetSequenceNumber () > m_tcb->m_rxBuffer->MaxRxSequence ())
---
>   if (tcpHeader.GetSequenceNumber () < m_rxBuffer->NextRxSequence ()
>       || tcpHeader.GetSequenceNumber () > m_rxBuffer->MaxRxSequence ())
2426c2065
<   m_tcb->m_rxBuffer->SetFinSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (p->GetSize ()));
---
>   m_rxBuffer->SetFinSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (p->GetSize ()));
2434c2073
<   if (!m_tcb->m_rxBuffer->Finished ())
---
>   if (!m_rxBuffer->Finished ())
2454,2455c2093
<   NS_ASSERT (m_state == ESTABLISHED || m_state == SYN_RCVD ||
<              m_state == FIN_WAIT_1 || m_state == FIN_WAIT_2);
---
>   NS_ASSERT (m_state == ESTABLISHED || m_state == SYN_RCVD);
2495,2496c2133,2134
<   m_endPoint = nullptr;
<   if (m_tcp != nullptr)
---
>   m_endPoint = 0;
>   if (m_tcp != 0)
2511,2512c2149,2150
<   m_endPoint6 = nullptr;
<   if (m_tcp != nullptr)
---
>   m_endPoint6 = 0;
>   if (m_tcp != 0)
2525c2163,2166
<   NS_LOG_FUNCTION (this << static_cast<uint32_t> (flags));
---
>   NS_LOG_FUNCTION (this << (uint32_t)flags);
>   Ptr<Packet> p = Create<Packet> ();
>   TcpHeader header;
>   SequenceNumber32 s = m_tcb->m_nextTxSequence;
2527c2168,2174
<   if (m_endPoint == nullptr && m_endPoint6 == nullptr)
---
>   /*
>    * Add tags for each socket option.
>    * Note that currently the socket adds both IPv4 tag and IPv6 tag
>    * if both options are set. Once the packet got to layer three, only
>    * the corresponding tags will be read.
>    */
>   if (GetIpTos ())
2529,2530c2176,2178
<       NS_LOG_WARN ("Failed to send empty packet due to null endpoint");
<       return;
---
>       SocketIpTosTag ipTosTag;
>       ipTosTag.SetTos (GetIpTos ());
>       p->AddPacketTag (ipTosTag);
2533,2535c2181,2186
<   Ptr<Packet> p = Create<Packet> ();
<   TcpHeader header;
<   SequenceNumber32 s = m_tcb->m_nextTxSequence;
---
>   if (IsManualIpv6Tclass ())
>     {
>       SocketIpv6TclassTag ipTclassTag;
>       ipTclassTag.SetTclass (GetIpv6Tclass ());
>       p->AddPacketTag (ipTclassTag);
>     }
2536a2188,2214
>   if (IsManualIpTtl ())
>     {
>       SocketIpTtlTag ipTtlTag;
>       ipTtlTag.SetTtl (GetIpTtl ());
>       p->AddPacketTag (ipTtlTag);
>     }
> 
>   if (IsManualIpv6HopLimit ())
>     {
>       SocketIpv6HopLimitTag ipHopLimitTag;
>       ipHopLimitTag.SetHopLimit (GetIpv6HopLimit ());
>       p->AddPacketTag (ipHopLimitTag);
>     }
> 
>   uint8_t priority = GetPriority ();
>   if (priority)
>     {
>       SocketPriorityTag priorityTag;
>       priorityTag.SetPriority (priority);
>       p->ReplacePacketTag (priorityTag);
>     }
> 
>   if (m_endPoint == 0 && m_endPoint6 == 0)
>     {
>       NS_LOG_WARN ("Failed to send empty packet due to null endpoint");
>       return;
>     }
2546,2547d2223
<   AddSocketTags (p);
< 
2550,2551c2226,2227
<   header.SetAckNumber (m_tcb->m_rxBuffer->NextRxSequence ());
<   if (m_endPoint != nullptr)
---
>   header.SetAckNumber (m_rxBuffer->NextRxSequence ());
>   if (m_endPoint != 0)
2577,2581d2252
<       if (m_sackEnabled)
<         {
<           AddOptionSackPermitted (header);
<         }
< 
2609,2623d2279
<   if (flags & TcpHeader::ACK)
<     { // If sending an ACK, cancel the delay ACK as well
<       m_delAckEvent.Cancel ();
<       m_delAckCount = 0;
<       if (m_highTxAck < header.GetAckNumber ())
<         {
<           m_highTxAck = header.GetAckNumber ();
<         }
<       if (m_sackEnabled && m_tcb->m_rxBuffer->GetSackListSize () > 0)
<         {
<           AddOptionSack (header);
<         }
<       NS_LOG_INFO ("Sending a pure ACK, acking seq " << m_tcb->m_rxBuffer->NextRxSequence ());
<     }
< 
2626c2282
<   if (m_endPoint != nullptr)
---
>   if (m_endPoint != 0)
2637c2293,2301
< 
---
>   if (flags & TcpHeader::ACK)
>     { // If sending an ACK, cancel the delay ACK as well
>       m_delAckEvent.Cancel ();
>       m_delAckCount = 0;
>       if (m_highTxAck < header.GetAckNumber ())
>         {
>           m_highTxAck = header.GetAckNumber ();
>         }
>     }
2661c2325
<   if (m_endPoint != nullptr)
---
>   if (m_endPoint != 0)
2666c2330
<       m_endPoint = nullptr;
---
>       m_endPoint = 0;
2669c2333
<   else if (m_endPoint6 != nullptr)
---
>   else if (m_endPoint6 != 0)
2674c2338
<       m_endPoint6 = nullptr;
---
>       m_endPoint6 = 0;
2685,2686c2349,2350
<   NS_ASSERT (ipv4 != nullptr);
<   if (ipv4->GetRoutingProtocol () == nullptr)
---
>   NS_ASSERT (ipv4 != 0);
>   if (ipv4->GetRoutingProtocol () == 0)
2715,2716c2379,2380
<   NS_ASSERT (ipv6 != nullptr);
<   if (ipv6->GetRoutingProtocol () == nullptr)
---
>   NS_ASSERT (ipv6 != 0);
>   if (ipv6->GetRoutingProtocol () == 0)
2728c2392
<   if (route == nullptr)
---
>   if (route == 0)
2747,2748d2410
<   NS_LOG_FUNCTION (this << p << h << fromAddress << toAddress);
<   NS_UNUSED (p);
2752,2753c2414
<       m_endPoint = m_tcp->Allocate (GetBoundNetDevice (),
<                                     InetSocketAddress::ConvertFrom (toAddress).GetIpv4 (),
---
>       m_endPoint = m_tcp->Allocate (InetSocketAddress::ConvertFrom (toAddress).GetIpv4 (),
2757c2418
<       m_endPoint6 = nullptr;
---
>       m_endPoint6 = 0;
2761,2762c2422
<       m_endPoint6 = m_tcp->Allocate6 (GetBoundNetDevice (),
<                                       Inet6SocketAddress::ConvertFrom (toAddress).GetIpv6 (),
---
>       m_endPoint6 = m_tcp->Allocate6 (Inet6SocketAddress::ConvertFrom (toAddress).GetIpv6 (),
2766c2426
<       m_endPoint = nullptr;
---
>       m_endPoint = 0;
2777c2437
<   m_tcb->m_rxBuffer->SetNextRxSequence (h.GetSequenceNumber () + SequenceNumber32 (1));
---
>   m_rxBuffer->SetNextRxSequence (h.GetSequenceNumber () + SequenceNumber32 (1));
2779,2793c2439
<   /* Check if we received an ECN SYN packet. Change the ECN state of receiver to ECN_IDLE if sender has sent an ECN SYN
<    * packet and the traffic is ECN Capable
<    */
<   if (m_tcb->m_useEcn != TcpSocketState::Off &&
<       (h.GetFlags () & (TcpHeader::CWR | TcpHeader::ECE)) == (TcpHeader::CWR | TcpHeader::ECE))
<     {
<       SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK | TcpHeader::ECE);
<       NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_IDLE");
<       m_tcb->m_ecnState = TcpSocketState::ECN_IDLE;
<     }
<   else
<     {
<       SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
<       m_tcb->m_ecnState = TcpSocketState::ECN_DISABLED;
<     }
---
>   SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
2810,2811c2456,2459
< void
< TcpSocketBase::AddSocketTags (const Ptr<Packet> &p) const
---
> /* Extract at most maxSize bytes from the TxBuffer at sequence seq, add the
>     TCP header, and send to TcpL4Protocol */
> uint32_t
> TcpSocketBase::SendDataPacket (SequenceNumber32 seq, uint32_t maxSize, bool withAck)
2812a2461,2479
>   NS_LOG_FUNCTION (this << seq << maxSize << withAck);
> 
>   bool isRetransmission = false;
>   if (seq != m_tcb->m_highTxMark)
>     {
>       isRetransmission = true;
>     }
> 
>   Ptr<Packet> p = m_txBuffer->CopyFromSequence (maxSize, seq);
>   uint32_t sz = p->GetSize (); // Size of packet
>   uint8_t flags = withAck ? TcpHeader::ACK : 0;
>   uint32_t remainingData = m_txBuffer->SizeFromSequence (seq + SequenceNumber32 (sz));
> 
>   if (withAck)
>     {
>       m_delAckEvent.Cancel ();
>       m_delAckCount = 0;
>     }
> 
2822,2830c2489
<       if (m_tcb->m_ecnState != TcpSocketState::ECN_DISABLED && !CheckNoEcn (GetIpTos ()))
<         {
<           ipTosTag.SetTos (MarkEcnCodePoint (GetIpTos (), m_tcb->m_ectCodePoint));
<         }
<       else
<         {
<           // Set the last received ipTos
<           ipTosTag.SetTos (GetIpTos ());
<         }
---
>       ipTosTag.SetTos (GetIpTos ());
2833,2841d2491
<   else
<     {
<       if ((m_tcb->m_ecnState != TcpSocketState::ECN_DISABLED && p->GetSize () > 0) || m_tcb->m_ecnMode == TcpSocketState::DctcpEcn)
<         {
<           SocketIpTosTag ipTosTag;
<           ipTosTag.SetTos (MarkEcnCodePoint (GetIpTos (), m_tcb->m_ectCodePoint));
<           p->AddPacketTag (ipTosTag);
<         }
<     }
2846,2854c2496
<       if (m_tcb->m_ecnState != TcpSocketState::ECN_DISABLED && !CheckNoEcn (GetIpv6Tclass ()))
<         {
<           ipTclassTag.SetTclass (MarkEcnCodePoint (GetIpv6Tclass (), m_tcb->m_ectCodePoint));
<         }
<       else
<         {
<           // Set the last received ipTos
<           ipTclassTag.SetTclass (GetIpv6Tclass ());
<         }
---
>       ipTclassTag.SetTclass (GetIpv6Tclass ());
2857,2865d2498
<   else
<     {
<       if ((m_tcb->m_ecnState != TcpSocketState::ECN_DISABLED && p->GetSize () > 0) || m_tcb->m_ecnMode == TcpSocketState::DctcpEcn)
<         {
<           SocketIpv6TclassTag ipTclassTag;
<           ipTclassTag.SetTclass (MarkEcnCodePoint (GetIpv6Tclass (), m_tcb->m_ectCodePoint));
<           p->AddPacketTag (ipTclassTag);
<         }
<     }
2888,2943d2520
< }
< 
< /* Extract at most maxSize bytes from the TxBuffer at sequence seq, add the
<     TCP header, and send to TcpL4Protocol */
< uint32_t
< TcpSocketBase::SendDataPacket (SequenceNumber32 seq, uint32_t maxSize, bool withAck)
< {
<   NS_LOG_FUNCTION (this << seq << maxSize << withAck);
< 
<   bool isStartOfTransmission = BytesInFlight () == 0U;
<   TcpTxItem *outItem = m_txBuffer->CopyFromSequence (maxSize, seq);
< 
<   m_rateOps->SkbSent(outItem, isStartOfTransmission);
< 
<   bool isRetransmission = outItem->IsRetrans ();
<   Ptr<Packet> p = outItem->GetPacketCopy ();
<   uint32_t sz = p->GetSize (); // Size of packet
<   uint8_t flags = withAck ? TcpHeader::ACK : 0;
<   uint32_t remainingData = m_txBuffer->SizeFromSequence (seq + SequenceNumber32 (sz));
< 
<   if (m_tcb->m_pacing)
<     {
<       NS_LOG_INFO ("Pacing is enabled");
<       if (m_pacingTimer.IsExpired ())
<         {
<           NS_LOG_DEBUG ("Current Pacing Rate " << m_tcb->m_currentPacingRate);
<           NS_LOG_DEBUG ("Timer is in expired state, activate it " << m_tcb->m_currentPacingRate.CalculateBytesTxTime (sz));
<           m_pacingTimer.Schedule (m_tcb->m_currentPacingRate.CalculateBytesTxTime (sz));
<         }
<       else
<         {
<           NS_LOG_INFO ("Timer is already in running state");
<         }
<     }
< 
<   if (withAck)
<     {
<       m_delAckEvent.Cancel ();
<       m_delAckCount = 0;
<     }
< 
<   // Sender should reduce the Congestion Window as a response to receiver's ECN Echo notification only once per window
<   if (m_tcb->m_ecnState == TcpSocketState::ECN_ECE_RCVD && m_ecnEchoSeq.Get() > m_ecnCWRSeq.Get () && !isRetransmission)
<     {
<       NS_LOG_INFO ("Backoff mechanism by reducing CWND  by half because we've received ECN Echo");
<       m_congestionControl->ReduceCwnd (m_tcb);
<       m_tcb->m_ssThresh = m_tcb->m_cWnd;
<       m_tcb->m_cWndInfl = m_tcb->m_cWnd;
<       flags |= TcpHeader::CWR;
<       m_ecnCWRSeq = seq;
<       NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_CWR_SENT");
<       m_tcb->m_ecnState = TcpSocketState::ECN_CWR_SENT;
<       NS_LOG_INFO ("CWR flags set");
<     }
< 
<   AddSocketTags (p);
2962c2539
<   header.SetAckNumber (m_tcb->m_rxBuffer->NextRxSequence ());
---
>   header.SetAckNumber (m_rxBuffer->NextRxSequence ());
2978c2555,2562
<       // Schedules retransmit timeout. m_rto should be already doubled.
---
>       // Schedules retransmit timeout. If this is a retransmission, double the timer
> 
>       if (isRetransmission)
>         { // This is a retransmit
>           // RFC 6298, clause 2.5
>           Time doubledRto = m_rto + m_rto;
>           m_rto = Min (doubledRto, Time::FromDouble (60,  Time::S));
>         }
3007,3012d2590
<   // Update bytes sent during recovery phase
<   if(m_tcb->m_congState == TcpSocketState::CA_RECOVERY)
<     {
<       m_recoveryOps->UpdateBytesSent (sz);
<     }
< 
3014c2592
<   if (!isRetransmission)
---
>   if (seq + sz > m_tcb->m_highTxMark)
3017c2595
<                               (seq + sz - m_tcb->m_highTxMark.Get ()));
---
>                              (seq + sz - m_tcb->m_highTxMark.Get ()));
3037c2615
<       for (std::deque<RttHistory>::iterator i = m_history.begin (); i != m_history.end (); ++i)
---
>       for (RttHistory_t::iterator i = m_history.begin (); i != m_history.end (); ++i)
3049,3050c2627,2630
< // Note that this function did not implement the PSH flag
< uint32_t
---
> /* Send as much pending data as possible according to the Tx window. Note that
>  *  this function did not implement the PSH flag
>  */
> bool
3058c2638
<   if (m_endPoint == nullptr && m_endPoint6 == nullptr)
---
>   if (m_endPoint == 0 && m_endPoint6 == 0)
3063d2642
< 
3065,3072c2644
<   uint32_t availableWindow = AvailableWindow ();
< 
<   // RFC 6675, Section (C)
<   // If cwnd - pipe >= 1 SMSS, the sender SHOULD transmit one or more
<   // segments as follows:
<   // (NOTE: We check > 0, and do the checks for segmentSize in the following
<   // else branch to control silly window syndrome and Nagle)
<   while (availableWindow > 0)
---
>   while (m_txBuffer->SizeFromSequence (m_tcb->m_nextTxSequence))
3074c2646,2648
<       if (m_tcb->m_pacing)
---
>       uint32_t w = AvailableWindow (); // Get available window size
>       // Stop sending if we need to wait for a larger Tx window (prevent silly window syndrome)
>       if (w < m_tcb->m_segmentSize && m_txBuffer->SizeFromSequence (m_tcb->m_nextTxSequence) > w)
3076,3082c2650,2651
<           NS_LOG_INFO ("Pacing is enabled");
<           if (m_pacingTimer.IsRunning ())
<             {
<               NS_LOG_INFO ("Skipping Packet due to pacing" << m_pacingTimer.GetDelayLeft ());
<               break;
<             }
<           NS_LOG_INFO ("Timer is not running");
---
>           NS_LOG_LOGIC ("Preventing Silly Window Syndrome. Wait to send.");
>           break; // No more
3084,3086c2653,2656
< 
<       if (m_tcb->m_congState == TcpSocketState::CA_OPEN
<           && m_state == TcpSocket::FIN_WAIT_1)
---
>       // Nagle's algorithm (RFC896): Hold off sending if there is unacked data
>       // in the buffer and the amount of data to send is less than one segment
>       if (!m_noDelay && UnAckDataCount () > 0
>           && m_txBuffer->SizeFromSequence (m_tcb->m_nextTxSequence) < m_tcb->m_segmentSize)
3088c2658
<           NS_LOG_INFO ("FIN_WAIT and OPEN state; no data to transmit");
---
>           NS_LOG_LOGIC ("Invoking Nagle's algorithm. Wait to send.");
3091,3186c2661,2677
<       // (C.1) The scoreboard MUST be queried via NextSeg () for the
<       //       sequence number range of the next segment to transmit (if
<       //       any), and the given segment sent.  If NextSeg () returns
<       //       failure (no data to send), return without sending anything
<       //       (i.e., terminate steps C.1 -- C.5).
<       SequenceNumber32 next;
<       bool enableRule3 = m_sackEnabled && m_tcb->m_congState == TcpSocketState::CA_RECOVERY;
<       if (!m_txBuffer->NextSeg (&next, enableRule3))
<         {
<           NS_LOG_INFO ("no valid seq to transmit, or no data available");
<           break;
<         }
<       else
<         {
<           // It's time to transmit, but before do silly window and Nagle's check
<           uint32_t availableData = m_txBuffer->SizeFromSequence (next);
< 
<           // If there's less app data than the full window, ask the app for more
<           // data before trying to send
<           if (availableData < availableWindow)
<             {
<               NotifySend (GetTxAvailable ());
<             }
< 
<           // Stop sending if we need to wait for a larger Tx window (prevent silly window syndrome)
<           // but continue if we don't have data
<           if (availableWindow < m_tcb->m_segmentSize && availableData > availableWindow)
<             {
<               NS_LOG_LOGIC ("Preventing Silly Window Syndrome. Wait to send.");
<               break; // No more
<             }
<           // Nagle's algorithm (RFC896): Hold off sending if there is unacked data
<           // in the buffer and the amount of data to send is less than one segment
<           if (!m_noDelay && UnAckDataCount () > 0 && availableData < m_tcb->m_segmentSize)
<             {
<               NS_LOG_DEBUG ("Invoking Nagle's algorithm for seq " << next <<
<                             ", SFS: " << m_txBuffer->SizeFromSequence (next) <<
<                             ". Wait to send.");
<               break;
<             }
< 
<           uint32_t s = std::min (availableWindow, m_tcb->m_segmentSize);
< 
<           // (C.2) If any of the data octets sent in (C.1) are below HighData,
<           //       HighRxt MUST be set to the highest sequence number of the
<           //       retransmitted segment unless NextSeg () rule (4) was
<           //       invoked for this retransmission.
<           // (C.3) If any of the data octets sent in (C.1) are above HighData,
<           //       HighData must be updated to reflect the transmission of
<           //       previously unsent data.
<           //
<           // These steps are done in m_txBuffer with the tags.
<           if (m_tcb->m_nextTxSequence != next)
<             {
<               m_tcb->m_nextTxSequence = next;
<             }
<           if (m_tcb->m_bytesInFlight.Get () == 0)
<             {
<               m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_TX_START);
<             }
<           uint32_t sz = SendDataPacket (m_tcb->m_nextTxSequence, s, withAck);
<           m_tcb->m_nextTxSequence += sz;
< 
<           NS_LOG_LOGIC (" rxwin " << m_rWnd <<
<                         " segsize " << m_tcb->m_segmentSize <<
<                         " highestRxAck " << m_txBuffer->HeadSequence () <<
<                         " pd->Size " << m_txBuffer->Size () <<
<                         " pd->SFS " << m_txBuffer->SizeFromSequence (m_tcb->m_nextTxSequence));
< 
<           NS_LOG_DEBUG ("cWnd: " << m_tcb->m_cWnd <<
<                         " total unAck: " << UnAckDataCount () <<
<                         " sent seq " << m_tcb->m_nextTxSequence <<
<                         " size " << sz);
<           ++nPacketsSent;
<           if (m_tcb->m_pacing)
<             {
<               NS_LOG_INFO ("Pacing is enabled");
<               if (m_pacingTimer.IsExpired ())
<                 {
<                   NS_LOG_DEBUG ("Current Pacing Rate " << m_tcb->m_currentPacingRate);
<                   NS_LOG_DEBUG ("Timer is in expired state, activate it " << m_tcb->m_currentPacingRate.CalculateBytesTxTime (sz));
<                   m_pacingTimer.Schedule (m_tcb->m_currentPacingRate.CalculateBytesTxTime (sz));
<                   break;
<                 }
<             }
<         }
< 
<       // (C.4) The estimate of the amount of data outstanding in the
<       //       network must be updated by incrementing pipe by the number
<       //       of octets transmitted in (C.1).
<       //
<       // Done in BytesInFlight, inside AvailableWindow.
<       availableWindow = AvailableWindow ();
< 
<       // (C.5) If cwnd - pipe >= 1 SMSS, return to (C.1)
<       // loop again!
---
>       NS_LOG_LOGIC ("TcpSocketBase " << this << " SendPendingData" <<
>                     " w " << w <<
>                     " rxwin " << m_rWnd <<
>                     " segsize " << m_tcb->m_segmentSize <<
>                     " nextTxSeq " << m_tcb->m_nextTxSequence <<
>                     " highestRxAck " << m_txBuffer->HeadSequence () <<
>                     " pd->Size " << m_txBuffer->Size () <<
>                     " pd->SFS " << m_txBuffer->SizeFromSequence (m_tcb->m_nextTxSequence));
> 
>       NS_LOG_DEBUG ("Window: " << w <<
>                     " cWnd: " << m_tcb->m_cWnd <<
>                     " unAck: " << UnAckDataCount ());
> 
>       uint32_t s = std::min (w, m_tcb->m_segmentSize);  // Send no more than window
>       uint32_t sz = SendDataPacket (m_tcb->m_nextTxSequence, s, withAck);
>       nPacketsSent++;                             // Count sent this loop
>       m_tcb->m_nextTxSequence += sz;                     // Advance next tx sequence
3188d2678
< 
3191,3199d2680
<       if (!m_sackEnabled)
<         {
<           if (!m_limitedTx)
<             {
<               // We can't transmit in CA_DISORDER without limitedTx active
<               NS_ASSERT (m_tcb->m_congState != TcpSocketState::CA_DISORDER);
<             }
<         }
< 
3202,3206c2683
<   else
<     {
<       NS_LOG_DEBUG ("SendPendingData no segments sent");
<     }
<   return nPacketsSent;
---
>   return (nPacketsSent > 0);
3212c2689,2690
<   return m_tcb->m_highTxMark - m_txBuffer->HeadSequence ();
---
>   NS_LOG_FUNCTION (this);
>   return m_tcb->m_nextTxSequence.Get () - m_txBuffer->HeadSequence ();
3216c2694
< TcpSocketBase::BytesInFlight () const
---
> TcpSocketBase::BytesInFlight ()
3218,3221c2696,2723
<   uint32_t bytesInFlight = m_txBuffer->BytesInFlight ();
<   // Ugly, but we are not modifying the state; m_bytesInFlight is used
<   // only for tracing purpose.
<   m_tcb->m_bytesInFlight = bytesInFlight;
---
>   NS_LOG_FUNCTION (this);
>   // Previous (see bug 1783):
>   // uint32_t bytesInFlight = m_highTxMark.Get () - m_txBuffer->HeadSequence ();
>   // RFC 4898 page 23
>   // PipeSize=SND.NXT-SND.UNA+(retransmits-dupacks)*CurMSS
> 
>   // flightSize == UnAckDataCount (), but we avoid the call to save log lines
>   uint32_t flightSize = m_tcb->m_nextTxSequence.Get () - m_txBuffer->HeadSequence ();
>   uint32_t duplicatedSize;
>   uint32_t bytesInFlight;
> 
>   if (m_retransOut > m_dupAckCount)
>     {
>       duplicatedSize = (m_retransOut - m_dupAckCount)*m_tcb->m_segmentSize;
>       bytesInFlight = flightSize + duplicatedSize;
>     }
>   else
>     {
>       duplicatedSize = (m_dupAckCount - m_retransOut)*m_tcb->m_segmentSize;
>       bytesInFlight = duplicatedSize > flightSize ? 0 : flightSize - duplicatedSize;
>     }
> 
>   // m_bytesInFlight is traced; avoid useless assignments which would fire
>   // fruitlessly the callback
>   if (m_bytesInFlight != bytesInFlight)
>     {
>       m_bytesInFlight = bytesInFlight;
>     }
3223d2724
<   NS_LOG_DEBUG ("Returning calculated bytesInFlight: " << bytesInFlight);
3229a2731
>   NS_LOG_FUNCTION (this);
3236,3239c2738,2743
<   uint32_t win = Window ();             // Number of bytes allowed to be outstanding
<   uint32_t inflight = BytesInFlight (); // Number of outstanding bytes
<   // std::cout << win << ",," << inflight << "\n";
<   return (inflight > win) ? 0 : win - inflight;
---
>   NS_LOG_FUNCTION_NOARGS ();
>   uint32_t unack = UnAckDataCount (); // Number of outstanding bytes
>   uint32_t win = Window ();           // Number of bytes allowed to be outstanding
> 
>   NS_LOG_DEBUG ("UnAckCount=" << unack << ", Win=" << win);
>   return (win < unack) ? 0 : (win - unack);
3246c2750
<   uint32_t w;
---
>   uint32_t w = m_rxBuffer->MaxBufferSize ();
3248,3266d2751
<   // We don't want to advertise 0 after a FIN is received. So, we just use
<   // the previous value of the advWnd.
<   if (m_tcb->m_rxBuffer->GotFin ())
<     {
<       w = m_advWnd;
<     }
<   else
<     {
<       NS_ASSERT_MSG (m_tcb->m_rxBuffer->MaxRxSequence () - m_tcb->m_rxBuffer->NextRxSequence () >= 0,
<                      "Unexpected sequence number values");
<       w = static_cast<uint32_t> (m_tcb->m_rxBuffer->MaxRxSequence () - m_tcb->m_rxBuffer->NextRxSequence ());
<     }
< 
<   // Ugly, but we are not modifying the state, that variable
<   // is used only for tracing purpose.
<   if (w != m_advWnd)
<     {
<       const_cast<TcpSocketBase*> (this)->m_advWnd = w;
<     }
3276c2761
<   NS_LOG_LOGIC ("Returning AdvertisedWindowSize of " << static_cast<uint16_t> (w));
---
>   NS_LOG_DEBUG ("Returning AdvertisedWindowSize of " << static_cast<uint16_t> (w));
3289,3290c2774,2775
<   SequenceNumber32 expectedSeq = m_tcb->m_rxBuffer->NextRxSequence ();
<   if (!m_tcb->m_rxBuffer->Add (p, tcpHeader))
---
>   SequenceNumber32 expectedSeq = m_rxBuffer->NextRxSequence ();
>   if (!m_rxBuffer->Add (p, tcpHeader))
3292c2777,2787
<       if (m_tcb->m_ecnState == TcpSocketState::ECN_CE_RCVD || m_tcb->m_ecnState == TcpSocketState::ECN_SENDING_ECE)
---
>       SendEmptyPacket (TcpHeader::ACK);
>       return;
>     }
>   // Now send a new ACK packet acknowledging all received and delivered data
>   if (m_rxBuffer->Size () > m_rxBuffer->Available () || m_rxBuffer->NextRxSequence () > expectedSeq + p->GetSize ())
>     { // A gap exists in the buffer, or we filled a gap: Always ACK
>       SendEmptyPacket (TcpHeader::ACK);
>     }
>   else
>     { // In-sequence packet: ACK if delayed ack count allows
>       if (++m_delAckCount >= m_delAckMaxCount)
3294,3296c2789,2791
<           SendEmptyPacket (TcpHeader::ACK | TcpHeader::ECE);
<           NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_SENDING_ECE");
<           m_tcb->m_ecnState = TcpSocketState::ECN_SENDING_ECE;
---
>           m_delAckEvent.Cancel ();
>           m_delAckCount = 0;
>           SendEmptyPacket (TcpHeader::ACK);
3298c2793
<       else
---
>       else if (m_delAckEvent.IsExpired ())
3300c2795,2798
<           SendEmptyPacket (TcpHeader::ACK);
---
>           m_delAckEvent = Simulator::Schedule (m_delAckTimeout,
>                                                &TcpSocketBase::DelAckTimeout, this);
>           NS_LOG_LOGIC (this << " scheduled delayed ACK at " <<
>                         (Simulator::Now () + Simulator::GetDelayLeft (m_delAckEvent)).GetSeconds ());
3302d2799
<       return;
3305c2802
<   if (expectedSeq < m_tcb->m_rxBuffer->NextRxSequence ())
---
>   if (expectedSeq < m_rxBuffer->NextRxSequence ())
3318c2815
<       if (m_tcb->m_rxBuffer->Finished () && (tcpHeader.GetFlags () & TcpHeader::FIN) == 0)
---
>       if (m_rxBuffer->Finished () && (tcpHeader.GetFlags () & TcpHeader::FIN) == 0)
3321,3368d2817
<           return;
<         }
<     }
<   // Now send a new ACK packet acknowledging all received and delivered data
<   if (m_tcb->m_rxBuffer->Size () > m_tcb->m_rxBuffer->Available () || m_tcb->m_rxBuffer->NextRxSequence () > expectedSeq + p->GetSize ())
<     { // A gap exists in the buffer, or we filled a gap: Always ACK
<       m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_NON_DELAYED_ACK);
<       if (m_tcb->m_ecnState == TcpSocketState::ECN_CE_RCVD || m_tcb->m_ecnState == TcpSocketState::ECN_SENDING_ECE)
<         {
<           SendEmptyPacket (TcpHeader::ACK | TcpHeader::ECE);
<           NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_SENDING_ECE");
<           m_tcb->m_ecnState = TcpSocketState::ECN_SENDING_ECE;
<         }
<       else
<         {
<           SendEmptyPacket (TcpHeader::ACK);
<         }
<     }
<   else
<     { // In-sequence packet: ACK if delayed ack count allows
<       if (++m_delAckCount >= m_delAckMaxCount)
<         {
<           m_delAckEvent.Cancel ();
<           m_delAckCount = 0;
<           m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_NON_DELAYED_ACK);
<           if (m_tcb->m_ecnState == TcpSocketState::ECN_CE_RCVD || m_tcb->m_ecnState == TcpSocketState::ECN_SENDING_ECE)
<             {
<               NS_LOG_DEBUG("Congestion algo " << m_congestionControl->GetName ());
<               SendEmptyPacket (TcpHeader::ACK | TcpHeader::ECE);
<               NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_SENDING_ECE");
<               m_tcb->m_ecnState = TcpSocketState::ECN_SENDING_ECE;
<             }
<           else
<             {
<               SendEmptyPacket (TcpHeader::ACK);
<             }
<         }
<       else if (!m_delAckEvent.IsExpired ())
<         {
<           m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_DELAYED_ACK);
<         }
<       else if (m_delAckEvent.IsExpired ())
<         {
<           m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_DELAYED_ACK);
<           m_delAckEvent = Simulator::Schedule (m_delAckTimeout,
<                                                &TcpSocketBase::DelAckTimeout, this);
<           NS_LOG_LOGIC (this << " scheduled delayed ACK at " <<
<                         (Simulator::Now () + Simulator::GetDelayLeft (m_delAckEvent)).GetSeconds ());
3396,3397c2845,2846
<               Ptr<const TcpOptionTS> ts;
<               ts = DynamicCast<const TcpOptionTS> (tcpHeader.GetOption (TcpOption::TS));
---
>               Ptr<TcpOptionTS> ts;
>               ts = DynamicCast<TcpOptionTS> (tcpHeader.GetOption (TcpOption::TS));
3423,3425c2872,2873
<       m_tcb->m_lastRtt = m_rtt->GetEstimate ();
<       m_tcb->m_minRtt = std::min (m_tcb->m_lastRtt.Get (), m_tcb->m_minRtt);
<       NS_LOG_INFO (this << m_tcb->m_lastRtt << m_tcb->m_minRtt);
---
>       m_lastRtt = m_rtt->GetEstimate ();
>       NS_LOG_FUNCTION (this << m_lastRtt);
3437,3439d2884
<   // Reset the data retransmission count. We got a new ACK!
<   m_dataRetrCount = m_dataRetries;
< 
3458c2903
< 
---
>   m_txBuffer->DiscardUpTo (ack);
3486,3518d2930
< 
<   if (m_state == SYN_SENT)
<     {
<       if (m_synCount > 0)
<         {
<           if (m_tcb->m_useEcn != TcpSocketState::Off)
<             {
<               SendEmptyPacket (TcpHeader::SYN | TcpHeader::ECE | TcpHeader::CWR);
<             }
<           else
<             {
<               SendEmptyPacket (TcpHeader::SYN);
<             }
<           m_tcb->m_ecnState = TcpSocketState::ECN_DISABLED;
<         }
<       else
<         {
<           NotifyConnectionFailed ();
<         }
<       return;
<     }
< 
<   // Retransmit non-data packet: Only if in FIN_WAIT_1 or CLOSING state
<   if (m_txBuffer->Size () == 0)
<     {
<       if (m_state == FIN_WAIT_1 || m_state == CLOSING)
<         { // Must have lost FIN, re-send
<           SendEmptyPacket (TcpHeader::FIN);
<         }
<       return;
<     }
< 
<   NS_LOG_DEBUG ("Checking if Connection is Established");
3520c2932
<   if (m_state <= ESTABLISHED && m_txBuffer->HeadSequence () >= m_tcb->m_highTxMark && m_txBuffer->Size () == 0)
---
>   if (m_state <= ESTABLISHED && m_txBuffer->HeadSequence () >= m_tcb->m_highTxMark)
3522d2933
<       NS_LOG_DEBUG ("Already Sent full data" << m_txBuffer->HeadSequence () << " " << m_tcb->m_highTxMark);
3526,3567d2936
<   if (m_dataRetrCount == 0)
<     {
<       NS_LOG_INFO ("No more data retries available. Dropping connection");
<       NotifyErrorClose ();
<       DeallocateEndPoint ();
<       return;
<     }
<   else
<     {
<       --m_dataRetrCount;
<     }
< 
<   uint32_t inFlightBeforeRto = BytesInFlight ();
<   bool resetSack = !m_sackEnabled; // Reset SACK information if SACK is not enabled.
<                                    // The information in the TcpTxBuffer is guessed, in this case.
< 
<   // Reset dupAckCount
<   m_dupAckCount = 0;
<   if (!m_sackEnabled)
<     {
<       m_txBuffer->ResetRenoSack ();
<     }
< 
<   // From RFC 6675, Section 5.1
<   // [RFC2018] suggests that a TCP sender SHOULD expunge the SACK
<   // information gathered from a receiver upon a retransmission timeout
<   // (RTO) "since the timeout might indicate that the data receiver has
<   // reneged."  Additionally, a TCP sender MUST "ignore prior SACK
<   // information in determining which data to retransmit."
<   // It has been suggested that, as long as robust tests for
<   // reneging are present, an implementation can retain and use SACK
<   // information across a timeout event [Errata1610].
<   // The head of the sent list will not be marked as sacked, therefore
<   // will be retransmitted, if the receiver renegotiate the SACK blocks
<   // that we received.
<   m_txBuffer->SetSentListLost (resetSack);
< 
<   // From RFC 6675, Section 5.1
<   // If an RTO occurs during loss recovery as specified in this document,
<   // RecoveryPoint MUST be set to HighData.  Further, the new value of
<   // RecoveryPoint MUST be preserved and the loss recovery algorithm
<   // outlined in this document MUST be terminated.
3569,3608c2938
< 
<   // RFC 6298, clause 2.5, double the timer
<   Time doubledRto = m_rto + m_rto;
<   m_rto = Min (doubledRto, Time::FromDouble (60,  Time::S));
< 
<   // Empty RTT history
<   m_history.clear ();
< 
<   // Please don't reset highTxMark, it is used for retransmission detection
< 
<   // When a TCP sender detects segment loss using the retransmission timer
<   // and the given segment has not yet been resent by way of the
<   // retransmission timer, decrease ssThresh
<   if (m_tcb->m_congState != TcpSocketState::CA_LOSS || !m_txBuffer->IsHeadRetransmitted ())
<     {
<       m_tcb->m_ssThresh = m_congestionControl->GetSsThresh (m_tcb, inFlightBeforeRto);
<     }
< 
<   // Cwnd set to 1 MSS
<   m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_LOSS);
<   m_congestionControl->CongestionStateSet (m_tcb, TcpSocketState::CA_LOSS);
<   m_tcb->m_congState = TcpSocketState::CA_LOSS;
<   m_tcb->m_cWnd = m_tcb->m_segmentSize;
<   m_tcb->m_cWndInfl = m_tcb->m_cWnd;
< 
<   m_pacingTimer.Cancel ();
< 
<   NS_LOG_DEBUG ("RTO. Reset cwnd to " <<  m_tcb->m_cWnd << ", ssthresh to " <<
<                 m_tcb->m_ssThresh << ", restart from seqnum " <<
<                 m_txBuffer->HeadSequence () << " doubled rto to " <<
<                 m_rto.Get ().GetSeconds () << " s");
< 
<   NS_ASSERT_MSG (BytesInFlight () == 0, "There are some bytes in flight after an RTO: " <<
<                  BytesInFlight ());
< 
<   SendPendingData (m_connected);
< 
<   NS_ASSERT_MSG (BytesInFlight () <= m_tcb->m_segmentSize,
<                  "In flight (" << BytesInFlight () <<
<                  ") there is more than one segment (" << m_tcb->m_segmentSize << ")");
---
>   Retransmit ();
3615,3624c2945
<   m_congestionControl->CwndEvent (m_tcb, TcpSocketState::CA_EVENT_DELAYED_ACK);
<   if (m_tcb->m_ecnState == TcpSocketState::ECN_CE_RCVD || m_tcb->m_ecnState == TcpSocketState::ECN_SENDING_ECE)
<     {
<       SendEmptyPacket (TcpHeader::ACK | TcpHeader::ECE);
<       m_tcb->m_ecnState = TcpSocketState::ECN_SENDING_ECE;
<     }
<   else
<     {
<       SendEmptyPacket (TcpHeader::ACK);
<     }
---
>   SendEmptyPacket (TcpHeader::ACK);
3651,3652c2972
<   Ptr<Packet> p = m_txBuffer->CopyFromSequence (1, m_tcb->m_nextTxSequence)->GetPacketCopy ();
<   m_txBuffer->ResetLastSegmentSent ();
---
>   Ptr<Packet> p = m_txBuffer->CopyFromSequence (1, m_tcb->m_nextTxSequence);
3655c2975
<   tcpHeader.SetAckNumber (m_tcb->m_rxBuffer->NextRxSequence ());
---
>   tcpHeader.SetAckNumber (m_rxBuffer->NextRxSequence ());
3657c2977
<   if (m_endPoint != nullptr)
---
>   if (m_endPoint != 0)
3668,3673d2987
<   //Send a packet tag for setting ECT bits in IP header
<   if (m_tcb->m_ecnState != TcpSocketState::ECN_DISABLED)
<     {
<       SocketIpTosTag ipTosTag;
<       ipTosTag.SetTos (MarkEcnCodePoint (0, m_tcb->m_ectCodePoint));
<       p->AddPacketTag (ipTosTag);
3675,3678d2988
<       SocketIpv6TclassTag ipTclassTag;
<       ipTclassTag.SetTclass (MarkEcnCodePoint (0, m_tcb->m_ectCodePoint));
<       p->AddPacketTag (ipTclassTag);
<     }
3681c2991
<   if (m_endPoint != nullptr)
---
>   if (m_endPoint != 0)
3698a3009,3069
> TcpSocketBase::Retransmit ()
> {
>   // If erroneous timeout in closed/timed-wait state, just return
>   if (m_state == CLOSED || m_state == TIME_WAIT)
>     {
>       return;
>     }
>   // If all data are received (non-closing socket and nothing to send), just return
>   if (m_state <= ESTABLISHED && m_txBuffer->HeadSequence () >= m_tcb->m_highTxMark)
>     {
>       return;
>     }
> 
>   /*
>    * When a TCP sender detects segment loss using the retransmission timer
>    * and the given segment has not yet been resent by way of the
>    * retransmission timer, the value of ssthresh MUST be set to no more
>    * than the value given in equation (4):
>    *
>    *   ssthresh = max (FlightSize / 2, 2*SMSS)            (4)
>    *
>    * where, as discussed above, FlightSize is the amount of outstanding
>    * data in the network.
>    *
>    * On the other hand, when a TCP sender detects segment loss using the
>    * retransmission timer and the given segment has already been
>    * retransmitted by way of the retransmission timer at least once, the
>    * value of ssthresh is held constant.
>    *
>    * Conditions to decrement slow - start threshold are as follows:
>    *
>    * *) The TCP state should be less than disorder, which is nothing but open.
>    * If we are entering into the loss state from the open state, we have not yet
>    * reduced the slow - start threshold for the window of data. (Nat: Recovery?)
>    * *) If we have entered the loss state with all the data pointed to by high_seq
>    * acknowledged. Once again it means that in whatever state we are (other than
>    * open state), all the data from the window that got us into the state, prior to
>    * retransmission timer expiry, has been acknowledged. (Nat: How this can happen?)
>    * *) If the above two conditions fail, we still have one more condition that can
>    * demand reducing the slow - start threshold: If we are already in the loss state
>    * and have not yet retransmitted anything. The condition may arise in case we
>    * are not able to retransmit anything because of local congestion.
>    */
> 
>   if (m_tcb->m_congState != TcpSocketState::CA_LOSS)
>     {
>       m_congestionControl->CongestionStateSet (m_tcb, TcpSocketState::CA_LOSS);
>       m_tcb->m_congState = TcpSocketState::CA_LOSS;
>       m_tcb->m_ssThresh = m_congestionControl->GetSsThresh (m_tcb, BytesInFlight ());
>       m_tcb->m_cWnd = m_tcb->m_segmentSize;
>     }
> 
>   m_tcb->m_nextTxSequence = m_txBuffer->HeadSequence (); // Restart from highest Ack
>   m_dupAckCount = 0;
> 
>   NS_LOG_DEBUG ("RTO. Reset cwnd to " <<  m_tcb->m_cWnd << ", ssthresh to " <<
>                 m_tcb->m_ssThresh << ", restart from seqnum " << m_tcb->m_nextTxSequence);
>   DoRetransmit ();                          // Retransmit the packet
> }
> 
> void
3702,3703c3073,3085
<   bool res;
<   SequenceNumber32 seq;
---
>   // Retransmit SYN packet
>   if (m_state == SYN_SENT)
>     {
>       if (m_synCount > 0)
>         {
>           SendEmptyPacket (TcpHeader::SYN);
>         }
>       else
>         {
>           NotifyConnectionFailed ();
>         }
>       return;
>     }
3705,3720c3087,3107
<   // Find the first segment marked as lost and not retransmitted. With Reno,
<   // that should be the head
<   res = m_txBuffer->NextSeg (&seq, false);
<   if (!res)
<     {
<       // We have already retransmitted the head. However, we still received
<       // three dupacks, or the RTO expired, but no data to transmit.
<       // Therefore, re-send again the head.
<       seq = m_txBuffer->HeadSequence ();
<     }
<   NS_ASSERT (m_sackEnabled || seq == m_txBuffer->HeadSequence ());
< 
<   NS_LOG_INFO ("Retransmitting " << seq);
<   // Update the trace and retransmit the segment
<   m_tcb->m_nextTxSequence = seq;
<   uint32_t sz = SendDataPacket (m_tcb->m_nextTxSequence, m_tcb->m_segmentSize, true);
---
>   if (m_dataRetrCount == 0)
>     {
>       NS_LOG_INFO ("No more data retries available. Dropping connection");
>       NotifyErrorClose ();
>       DeallocateEndPoint ();
>       return;
>     }
>   else
>     {
>       --m_dataRetrCount;
>     }
> 
>   // Retransmit non-data packet: Only if in FIN_WAIT_1 or CLOSING state
>   if (m_txBuffer->Size () == 0)
>     {
>       if (m_state == FIN_WAIT_1 || m_state == CLOSING)
>         { // Must have lost FIN, re-send
>           SendEmptyPacket (TcpHeader::FIN);
>         }
>       return;
>     }
3722c3109,3116
<   NS_ASSERT (sz > 0);
---
>   // Retransmit a data packet: Call SendDataPacket
>   uint32_t sz = SendDataPacket (m_txBuffer->HeadSequence (), m_tcb->m_segmentSize, true);
>   ++m_retransOut;
> 
>   // In case of RTO, advance m_tcb->m_nextTxSequence
>   m_tcb->m_nextTxSequence = std::max (m_tcb->m_nextTxSequence.Get (), m_txBuffer->HeadSequence () + sz);
> 
>   NS_LOG_DEBUG ("retxing seq " << m_txBuffer->HeadSequence ());
3734d3127
<   m_pacingTimer.Cancel ();
3744,3751d3136
<   if (!m_closeNotified)
<     {
<       // Technically the connection is not fully closed, but we notify now
<       // because an implementation (real socket) would behave as if closed.
<       // Notify normal close when entering TIME_WAIT or leaving LAST_ACK.
<       NotifyNormalClose ();
<       m_closeNotified = true;
<     }
3779c3164
<   m_tcb->m_rxBuffer->SetMaxBufferSize (size);
---
>   m_rxBuffer->SetMaxBufferSize (size);
3786,3795c3171
<       if (m_tcb->m_ecnState == TcpSocketState::ECN_CE_RCVD || m_tcb->m_ecnState == TcpSocketState::ECN_SENDING_ECE)
<         {
<           SendEmptyPacket (TcpHeader::ACK | TcpHeader::ECE);
<           NS_LOG_DEBUG (TcpSocketState::EcnStateName[m_tcb->m_ecnState] << " -> ECN_SENDING_ECE");
<           m_tcb->m_ecnState = TcpSocketState::ECN_SENDING_ECE;
<         }
<       else
<         {
<           SendEmptyPacket (TcpHeader::ACK);
<         }
---
>       SendEmptyPacket (TcpHeader::ACK);
3802c3178
<   return m_tcb->m_rxBuffer->MaxBufferSize ();
---
>   return m_rxBuffer->MaxBufferSize ();
3810d3185
<   m_txBuffer->SetSegmentSize (size);
3962c3337
<   uint32_t maxSpace = m_tcb->m_rxBuffer->MaxBufferSize ();
---
>   uint32_t maxSpace = m_rxBuffer->MaxBufferSize ();
3978c3353
<                static_cast<int> (scale) << " for buffer size " << m_tcb->m_rxBuffer->MaxBufferSize ());
---
>                static_cast<int> (scale) << " for buffer size " << m_rxBuffer->MaxBufferSize ());
4002,4061d3376
< uint32_t
< TcpSocketBase::ProcessOptionSack (const Ptr<const TcpOption> option)
< {
<   NS_LOG_FUNCTION (this << option);
< 
<   Ptr<const TcpOptionSack> s = DynamicCast<const TcpOptionSack> (option);
<   return m_txBuffer->Update (s->GetSackList (), MakeCallback (&TcpRateOps::SkbDelivered, m_rateOps));
< }
< 
< void
< TcpSocketBase::ProcessOptionSackPermitted (const Ptr<const TcpOption> option)
< {
<   NS_LOG_FUNCTION (this << option);
< 
<   Ptr<const TcpOptionSackPermitted> s = DynamicCast<const TcpOptionSackPermitted> (option);
< 
<   NS_ASSERT (m_sackEnabled == true);
<   NS_LOG_INFO (m_node->GetId () << " Received a SACK_PERMITTED option " << s);
< }
< 
< void
< TcpSocketBase::AddOptionSackPermitted (TcpHeader &header)
< {
<   NS_LOG_FUNCTION (this << header);
<   NS_ASSERT (header.GetFlags () & TcpHeader::SYN);
< 
<   Ptr<TcpOptionSackPermitted> option = CreateObject<TcpOptionSackPermitted> ();
<   header.AppendOption (option);
<   NS_LOG_INFO (m_node->GetId () << " Add option SACK-PERMITTED");
< }
< 
< void
< TcpSocketBase::AddOptionSack (TcpHeader& header)
< {
<   NS_LOG_FUNCTION (this << header);
< 
<   // Calculate the number of SACK blocks allowed in this packet
<   uint8_t optionLenAvail = header.GetMaxOptionLength () - header.GetOptionLength ();
<   uint8_t allowedSackBlocks = (optionLenAvail - 2) / 8;
< 
<   TcpOptionSack::SackList sackList = m_tcb->m_rxBuffer->GetSackList ();
<   if (allowedSackBlocks == 0 || sackList.empty ())
<     {
<       NS_LOG_LOGIC ("No space available or sack list empty, not adding sack blocks");
<       return;
<     }
< 
<   // Append the allowed number of SACK blocks
<   Ptr<TcpOptionSack> option = CreateObject<TcpOptionSack> ();
<   TcpOptionSack::SackList::iterator i;
<   for (i = sackList.begin (); allowedSackBlocks > 0 && i != sackList.end (); ++i)
<     {
<       option->AddSackBlock (*i);
<       allowedSackBlocks--;
<     }
< 
<   header.AppendOption (option);
<   NS_LOG_INFO (m_node->GetId () << " Add option SACK " << *option);
< }
< 
4070,4081c3385
<   // This is valid only when no overflow occurs. It happens
<   // when a connection last longer than 50 days.
<   if (m_tcb->m_rcvTimestampValue > ts->GetTimestamp ())
<     {
<       // Do not save a smaller timestamp (probably there is reordering)
<       return;
<     }
< 
<   m_tcb->m_rcvTimestampValue = ts->GetTimestamp ();
<   m_tcb->m_rcvTimestampEchoReply = ts->GetEcho ();
< 
<   if (seq == m_tcb->m_rxBuffer->NextRxSequence () && seq <= m_highTxAck)
---
>   if (seq == m_rxBuffer->NextRxSequence () && seq <= m_highTxAck)
4184,4191c3488
<   return m_tcb->m_rxBuffer;
< }
< 
< void
< TcpSocketBase::SetRetxThresh (uint32_t retxThresh)
< {
<   m_retxThresh = retxThresh;
<   m_txBuffer->SetDupAckThresh (retxThresh);
---
>   return m_rxBuffer;
4201,4206d3497
< TcpSocketBase::UpdateCwndInfl (uint32_t oldValue, uint32_t newValue)
< {
<   m_cWndInflTrace (oldValue, newValue);
< }
< 
< void
4219,4227d3509
<  void
< TcpSocketBase::UpdateEcnState (TcpSocketState::EcnState_t oldValue,
<                                 TcpSocketState::EcnState_t newValue)
< {
<   m_ecnStateTrace (oldValue, newValue);
< }
< 
< 
< 
4231,4238d3512
< {
<   // if (Simulator::Now ().GetSeconds () > 1.4)
<   // {
<   //   ofstream fout;
<   //   fout.open( "1_seq.txt" ,ios::app);
<   //   fout << Simulator::Now ().GetSeconds ()  <<  " "  << newValue << "\n";
<   //   fout.close();
<   // }
4239a3514
> {
4250,4265d3524
< TcpSocketBase::UpdateBytesInFlight (uint32_t oldValue, uint32_t newValue)
< {
<   m_bytesInFlightTrace (oldValue, newValue);
< }
< 
< void
< TcpSocketBase::UpdateRtt (Time oldValue, Time newValue)
< {
<     // ofstream fout;
<     // fout.open( "1_RTT.txt" ,ios::app);
<     // fout << Simulator::Now ().GetSeconds ()  <<  " "  << newValue.GetMicroSeconds() << "\n";
<     // fout.close();
<   m_lastRttTrace (oldValue, newValue);
< }
< 
< void
4270,4277d3528
<   m_congestionControl->Init (m_tcb);
< }
< 
< void
< TcpSocketBase::SetRecoveryAlgorithm (Ptr<TcpRecoveryOps> recovery)
< {
<   NS_LOG_FUNCTION (this << recovery);
<   m_recoveryOps = recovery;
4295,4309d3545
< }
< 
< void
< TcpSocketBase::NotifyPacingPerformed (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   NS_LOG_INFO ("Performing Pacing");
<   SendPendingData (m_connected);
< }
< 
< void
< TcpSocketBase::SetUseEcn (TcpSocketState::UseEcn_t useEcn)
< {
<   NS_LOG_FUNCTION (this << useEcn);
<   m_tcb->m_useEcn = useEcn;
diff ../../NS3-WiGig/src/internet/model/tcp-socket-base.h ../../ns-3-dev/src/internet/model/tcp-socket-base.h
25a26
> #include "ns3/callback.h"
27a29,30
> #include "ns3/ptr.h"
> #include "ns3/ipv4-address.h"
28a32
> #include "ns3/ipv4-interface.h"
30,34c34,38
< #include "ns3/timer.h"
< #include "ns3/sequence-number.h"
< #include "ns3/data-rate.h"
< #include "ns3/node.h"
< #include "ns3/tcp-socket-state.h"
---
> #include "ns3/ipv6-interface.h"
> #include "ns3/event-id.h"
> #include "tcp-tx-buffer.h"
> #include "tcp-rx-buffer.h"
> #include "rtt-estimator.h"
45,52d48
< class TcpRecoveryOps;
< class RttEstimator;
< class TcpRxBuffer;
< class TcpTxBuffer;
< class TcpOption;
< class Ipv4Interface;
< class Ipv6Interface;
< class TcpRateOps;
80a77,187
> /// Container for RttHistory objects
> typedef std::deque<RttHistory> RttHistory_t;
> 
> /**
>  * \brief Data structure that records the congestion state of a connection
>  *
>  * In this data structure, basic informations that should be passed between
>  * socket and the congestion control algorithm are saved. Through the code,
>  * it will be referred as Transmission Control Block (TCB), but there are some
>  * differencies. In the RFCs, the TCB contains all the variables that defines
>  * a connection, while we preferred to maintain in this class only the values
>  * that should be exchanged between socket and other parts, like congestion
>  * control algorithms.
>  *
>  */
> class TcpSocketState : public Object
> {
> public:
>   /**
>    * Get the type ID.
>    * \brief Get the type ID.
>    * \return the object TypeId
>    */
>   static TypeId GetTypeId (void);
> 
>   TcpSocketState ();
> 
>   /**
>    * \brief Copy constructor.
>    * \param other object to copy.
>    */
>   TcpSocketState (const TcpSocketState &other);
> 
>   /**
>    * \brief Definition of the Congestion state machine
>    *
>    * The design of this state machine is taken from Linux v4.0, but it has been
>    * maintained in the Linux mainline from ages. It basically avoids to maintain
>    * a lot of boolean variables, and it allows to check the transitions from
>    * different algorithm in a cleaner way.
>    *
>    * These states represent the situation from a congestion control point of view:
>    * in fact, apart the CA_OPEN state, the other states represent a situation in
>    * which there is a congestion, and different actions should be taken,
>    * depending on the case.
>    *
>    */
>   typedef enum
>   {
>     CA_OPEN,      /**< Normal state, no dubious events */
>     CA_DISORDER,  /**< In all the respects it is "Open",
>                     *  but requires a bit more attention. It is entered when
>                     *  we see some SACKs or dupacks. It is split of "Open" */
>     CA_CWR,       /**< cWnd was reduced due to some Congestion Notification event.
>                     *  It can be ECN, ICMP source quench, local device congestion.
>                     *  Not used in NS-3 right now. */
>     CA_RECOVERY,  /**< CWND was reduced, we are fast-retransmitting. */
>     CA_LOSS,      /**< CWND was reduced due to RTO timeout or SACK reneging. */
>     CA_LAST_STATE /**< Used only in debug messages */
>   } TcpCongState_t;
> 
>   /**
>    * \ingroup tcp
>    * TracedValue Callback signature for TcpCongState_t
>    *
>    * \param [in] oldValue original value of the traced variable
>    * \param [in] newValue new value of the traced variable
>    */
>   typedef void (* TcpCongStatesTracedValueCallback)(const TcpCongState_t oldValue,
>                                                     const TcpCongState_t newValue);
> 
>   /**
>    * \brief Literal names of TCP states for use in log messages
>    */
>   static const char* const TcpCongStateName[TcpSocketState::CA_LAST_STATE];
> 
>   // Congestion control
>   TracedValue<uint32_t>  m_cWnd;            //!< Congestion window
>   TracedValue<uint32_t>  m_ssThresh;        //!< Slow start threshold
>   uint32_t               m_initialCWnd;     //!< Initial cWnd value
>   uint32_t               m_initialSsThresh; //!< Initial Slow Start Threshold value
> 
>   // Segment
>   uint32_t               m_segmentSize;     //!< Segment size
>   SequenceNumber32       m_lastAckedSeq;    //!< Last sequence ACKed
> 
>   TracedValue<TcpCongState_t> m_congState;    //!< State in the Congestion state machine
>   TracedValue<SequenceNumber32> m_highTxMark; //!< Highest seqno ever sent, regardless of ReTx
>   TracedValue<SequenceNumber32> m_nextTxSequence; //!< Next seqnum to be sent (SND.NXT), ReTx pushes it back
> 
>   /**
>    * \brief Get cwnd in segments rather than bytes
>    *
>    * \return Congestion window in segments
>    */
>   uint32_t GetCwndInSegments () const
>   {
>     return m_cWnd / m_segmentSize;
>   }
> 
>   /**
>    * \brief Get slow start thresh in segments rather than bytes
>    *
>    * \return Slow start threshold in segments
>    */
>   uint32_t GetSsThreshInSegments () const
>   {
>     return m_ssThresh / m_segmentSize;
>   }
> };
> 
88,92c195,199
<  * interface for upper layers to call. This class provides connection orientation
<  * and sliding window flow control; congestion control is delegated to subclasses
<  * of TcpCongestionOps. Part of TcpSocketBase is modified from the original
<  * NS-3 TCP socket implementation (TcpSocketImpl) by
<  * Raj Bhattacharjea <raj.b@gatech.edu> of Georgia Tech.
---
>  * interface for upper layers to call. This serves as a base for other TCP
>  * functions where the sliding window mechanism is handled here. This class
>  * provides connection orientation and sliding window flow control. Part of
>  * this class is modified from the original NS-3 TCP socket implementation
>  * (TcpSocketImpl) by Raj Bhattacharjea <raj.b@gatech.edu> of Georgia Tech.
121c228
<  * Congestion control, unlike older releases of ns-3, has been split from
---
>  * Congestion control, unlike older releases of ns-3, has been splitted from
124,130c231
<  * now a matter of setting a pointer into the TcpSocketBase class. The idea
<  * and the interfaces are inspired by the Linux operating system, and in
<  * particular from the structure tcp_congestion_ops. The reference paper is
<  * https://www.sciencedirect.com/science/article/pii/S1569190X15300939.
<  *
<  * Transmission Control Block (TCB)
<  * --------------------------------
---
>  * now a matter of setting a pointer into the TcpSocketBase class.
142c243
<  * ----------------
---
>  * ---------------------------
144,163c245,256
<  * The fast retransmit enhancement is introduced in RFC 2581 and updated in RFC
<  * 5681. It reduces the time a sender waits before retransmitting a lost segment,
<  * through the assumption that if it receives a certain number of duplicate ACKs,
<  * a segment has been lost and it can be retransmitted. Usually, it is coupled
<  * with the Limited Transmit algorithm, defined in RFC 3042. These algorithms
<  * are included in this class, and they are implemented inside the ProcessAck
<  * method. With the SACK option enabled, the LimitedTransmit algorithm will be
<  * always on, as a consequence of how the information in the received SACK block
<  * is managed.
<  *
<  * The attribute which manages the number of dup ACKs necessary to start the
<  * fast retransmit algorithm is named "ReTxThreshold", and by default is 3.
<  * The parameter is also used in TcpTxBuffer to determine if a packet is lost
<  * (please take a look at TcpTxBuffer documentation to see details) but,
<  * right now, it is assumed to be fixed. In future releases this parameter can
<  * be made dynamic, to reflect the reordering degree of the network. With SACK,
<  * the next sequence to transmit is given by the RFC 6675 algorithm. Without
<  * SACK option, the implementation adds "hints" to TcpTxBuffer to make sure it
<  * returns, as next transmittable sequence, the first lost (or presumed lost)
<  * segment.
---
>  * The fast retransmit enhancement is introduced in RFC 2581 and updated in
>  * RFC 5681. It basically reduces the time a sender waits before retransmitting
>  * a lost segment, through the assumption that if it receives a certain number
>  * of duplicate ACKs, a segment has been lost and it can be retransmitted.
>  * Usually it is coupled with the Limited Transmit algorithm, defined in
>  * RFC 3042.
>  *
>  * In ns-3, these algorithms are included in this class, and it is implemented inside
>  * the ReceivedAck method. The attribute which manages the number of dup ACKs
>  * necessary to start the fast retransmit algorithm is named "ReTxThreshold",
>  * and its default value is 3, while the Limited Transmit one can be enabled
>  * by setting the attribute "LimitedTransmit" to true.
166c259,264
<  * -------------
---
>  * --------------------------
>  *
>  * The fast recovery algorithm is introduced RFC 2001, and it basically
>  * avoids to reset cWnd to 1 segment after sensing a loss on the channel. Instead,
>  * the slow start threshold is halved, and the cWnd is set equal to such value,
>  * plus segments for the cWnd inflation.
168,214c266
<  * The fast recovery algorithm is introduced RFC 2001, and it avoids to reset
<  * cWnd to 1 segment after sensing a loss on the channel. Instead, a new slow
<  * start threshold value is asked to the congestion control (for instance,
<  * with NewReno the returned amount is half of the previous), and the cWnd is
<  * set equal to such value. Ns-3 does not implement any inflation/deflation to
<  * the congestion window since it uses an evolved method (borrowed from Linux
<  * operating system) to calculate the number of bytes in flight. The fundamental
<  * idea is to subtract from the total bytes in flight the lost/sacked amount
<  * (the segments that have left the network) and to add the retransmitted count.
<  * In this way, congestion window represents the exact number of bytes that
<  * should be in flight. The implementation then decides what to transmit, it
<  * there is space, between new or already transmitted data portion. If a value
<  * of the congestion window with inflation and deflation is needed, there is a
<  * traced source named "CongestionWindowInflated". However, the variable behind
<  * it is not used in the code, but maintained for backward compatibility.
<  *
<  * RTO expiration
<  * --------------
<  *
<  * When the Retransmission Time Out expires, the TCP faces a significant
<  * performance drop. The expiration event is managed in the ReTxTimeout method,
<  * which set the cWnd to 1 segment and starts "from scratch" again. The list
<  * of sent packet is set as lost entirely, and the transmission is re-started
<  * from the SND.UNA sequence number.
<  *
<  * Options management
<  * ------------------
<  *
<  * SYN and SYN-ACK options, which are allowed only at the beginning of the
<  * connection, are managed in the DoForwardUp and SendEmptyPacket methods.
<  * To read all others, we have set up a cycle inside ReadOptions. For adding
<  * them, there is no a unique place, since the options (and the information
<  * available to build them) are scattered around the code. For instance,
<  * the SACK option is built in SendEmptyPacket only under certain conditions.
<  *
<  * SACK
<  * ----
<  *
<  * The SACK generation/management is delegated to the buffer classes, namely
<  * TcpTxBuffer and TcpRxBuffer. In TcpRxBuffer it is managed the creation
<  * of the SACK option from the receiver point of view. It must provide an
<  * accurate (and efficient) representation of the status of the receiver buffer.
<  * On the other side, inside TcpTxBuffer the received options (that contain
<  * the SACK block) are processed and a particular data structure, called Scoreboard,
<  * is filled. Please take a look at TcpTxBuffer and TcpRxBuffer documentation if
<  * you need more information. The reference paper is
<  * https://dl.acm.org/citation.cfm?id=3067666.
---
>  * The algorithm is implemented in the ReceivedAck method.
233,236d284
<   /**
<    * \brief TcpGeneralTest friend class (for tests).
<    * \relates TcpGeneralTest
<    */
309,320d356
<    * \brief Set the retransmission threshold (dup ack threshold for a fast retransmit)
<    * \param retxThresh the threshold
<    */
<   void SetRetxThresh (uint32_t retxThresh);
< 
<   /**
<    * \brief Get the retransmission threshold (dup ack threshold for a fast retransmit)
<    * \return the threshold
<    */
<   uint32_t GetRetxThresh (void) const { return m_retxThresh; }
< 
<   /**
326,330d361
<    * \brief Callback pointer for cWndInfl trace chaining
<    */
<   TracedCallback<uint32_t, uint32_t> m_cWndInflTrace;
< 
<   /**
340,344d370
<    /**
<    * \brief Callback pointer for ECN state trace chaining
<    */
<   TracedCallback<TcpSocketState::EcnState_t, TcpSocketState::EcnState_t> m_ecnStateTrace;
< 
356,365d381
<    * \brief Callback pointer for bytesInFlight trace chaining
<    */
<   TracedCallback<uint32_t, uint32_t> m_bytesInFlightTrace;
< 
<   /**
<    * \brief Callback pointer for RTT trace chaining
<    */
<   TracedCallback<Time, Time> m_lastRttTrace;
< 
<   /**
373,379d388
<    * \brief Callback function to hook to TcpSocketState inflated congestion window
<    * \param oldValue old cWndInfl value
<    * \param newValue new cWndInfl value
<    */
<   void UpdateCwndInfl (uint32_t oldValue, uint32_t newValue);
< 
<   /**
394,401d402
<    /**
<    * \brief Callback function to hook to EcnState state
<    * \param oldValue old ecn state value
<    * \param newValue new ecn state value
<    */
<   void UpdateEcnState (TcpSocketState::EcnState_t oldValue,
<                         TcpSocketState::EcnState_t newValue);
< 
417,430d417
<    * \brief Callback function to hook to TcpSocketState bytes inflight
<    * \param oldValue old bytesInFlight value
<    * \param newValue new bytesInFlight value
<    */
<   void UpdateBytesInFlight (uint32_t oldValue, uint32_t newValue);
< 
<   /**
<    * \brief Callback function to hook to TcpSocketState rtt
<    * \param oldValue old rtt value
<    * \param newValue new rtt value
<    */
<   void UpdateRtt (Time oldValue, Time newValue);
< 
<   /**
437,540d423
<   /**
<    * \brief Install a recovery algorithm on this socket
<    *
<    * \param recovery Algorithm to be installed
<    */
<   void SetRecoveryAlgorithm (Ptr<TcpRecoveryOps> recovery);
< 
<   /**
<    * \brief Mark ECT(0)
<    *
<    * \return TOS with ECT(0)
<    */
<   inline uint8_t MarkEcnEct0 (uint8_t tos) const
<     {
<       return ((tos & 0xfc) | 0x02);
<     }
< 
<   /**
<    * \brief Mark ECT(1)
<    *
<    * \return TOS with ECT(1)
<    */
<   inline uint8_t MarkEcnEct1 (uint8_t tos) const
<     {
<       return ((tos & 0xfc) | 0x01);
<     }
< 
<   /**
<    * \brief Mark CE
<    *
<    * \return TOS with CE
<    */
<   inline uint8_t MarkEcnCe (uint8_t tos) const
<     {
<       return ((tos & 0xfc) | 0x03);
<     }
< 
<   /**
<    * \brief Clears ECN bits from TOS
<    *
<    * \return TOS without ECN bits
<    */
<   inline uint8_t ClearEcnBits (uint8_t tos) const
<     {
<       return tos & 0xfc;
<     }
< 
<   /**
<    * \brief Checks if TOS has no ECN bits
<    *
<    * \return true if TOS does not have any ECN bits set; otherwise false
<    */
<   inline bool CheckNoEcn (uint8_t tos) const
<     {
<       return ((tos & 0xfc) == 0x00);
<     }
< 
<   /**
<    * \brief Checks for ECT(0) bits
<    *
<    * \return true if TOS has ECT(0) bit set; otherwise false
<    */
<   inline bool CheckEcnEct0 (uint8_t tos) const
<     {
<       return ((tos & 0xfc) == 0x02);
<     }
< 
<   /**
<    * \brief Checks for ECT(1) bits
<    *
<    * \return true if TOS has ECT(1) bit set; otherwise false
<    */
<   inline bool CheckEcnEct1 (uint8_t tos) const
<     {
<       return ((tos & 0xfc) == 0x01);
<     }
< 
<   /**
<    * \brief Checks for CE bits
<    *
<    * \return true if TOS has CE bit set; otherwise false
<    */
<   inline bool CheckEcnCe (uint8_t tos) const
<     {
<       return ((tos & 0xfc) == 0x03);
<     }
< 
<   /**
<    * \brief mark ECN code point
<    *
<    * \return TOS with specified ECN code point
<    */
<   inline uint8_t MarkEcnCodePoint (const uint8_t tos, const TcpSocketState::EcnCodePoint_t codePoint) const
<     {
<       return ((tos & 0xfc) | codePoint);
<     }
< 
<   /**
<    * \brief Set use of ECN on the socket
<    *
<    * \param useEcn Use of ECN. Currently Off and On are supported.
<    */
<   void SetUseEcn (TcpSocketState::UseEcn_t useEcn);
< 
567,568c450,451
<    * \param [in] header The TcpHeader
<    * \param [in] socket This socket
---
>    * \param [in] ipv4
>    * \param [in] interface
661,670d543
<    * \brief Checks whether the given TCP segment is valid or not.
<    *
<    * \param seq the sequence number of packet's TCP header
<    * \param tcpHeaderSize the size of packet's TCP header
<    * \param tcpPayloadSize the size of TCP payload
<    */
<   bool IsValidTcpSegment (const SequenceNumber32 seq, const uint32_t tcpHeaderSize,
<                           const uint32_t tcpPayloadSize);
< 
<   /**
733c606
<    * \returns the number of packets sent
---
>    * \returns true if some data have been sent
735c608
<   uint32_t SendPendingData (bool withAck = false);
---
>   bool SendPendingData (bool withAck = false);
746c619
<   virtual uint32_t SendDataPacket (SequenceNumber32 seq, uint32_t maxSize, bool withAck);
---
>   uint32_t SendDataPacket (SequenceNumber32 seq, uint32_t maxSize, bool withAck);
749c622
<    * \brief Send a empty packet that carries a flag, e.g., ACK
---
>    * \brief Send a empty packet that carries a flag, e.g. ACK
898,900d770
<    *
<    * The difference between SND.UNA and HighTx
<    *
907,909d776
<    *
<    * Does not count segments lost and SACKed (or dupACKed)
<    *
912c779
<   virtual uint32_t BytesInFlight (void) const;
---
>   virtual uint32_t BytesInFlight (void);
965,976d831
<    * \brief Process a received ack
<    * \param ackNumber ack number
<    * \param scoreboardUpdated if true indicates that the scoreboard has been
<    * \param oldHeadSequence value of HeadSequence before ack
<    * updated with SACK information
<    * \param currentDelivered The number of bytes (S)ACKed
<    * \return the number of bytes (newly) acked, or 0 if it was a dupack
<    */
<   virtual void ProcessAck (const SequenceNumber32 &ackNumber, bool scoreboardUpdated,
<                            uint32_t currentDelivered, const SequenceNumber32 &oldHeadSequence);
< 
<   /**
1009,1010d863
<    *
<    * \param currentDelivered Current (S)ACKed bytes
1012c865
<   void DupAck (uint32_t currentDelivered);
---
>   void DupAck ();
1015,1017c868
<    * \brief Enter the CA_RECOVERY, and retransmit the head
<    *
<    * \param currentDelivered Currently (S)ACKed bytes
---
>    * \brief Limited transmit algorithm
1019c870
<   void EnterRecovery (uint32_t currentDelivered);
---
>   void LimitedTransmit ();
1022c873,878
<    * \brief An RTO event happened
---
>    * \brief Enter the FastRetransmit, and retransmit the head
>    */
>   void FastRetransmit ();
> 
>   /**
>    * \brief Call Retransmit() upon RTO event
1026a883,887
>    * \brief Halving cwnd and call DoRetransmit()
>    */
>   virtual void Retransmit (void);
> 
>   /**
1042,1043c903
<    * \brief Retransmit the first segment marked as lost, without considering
<    * available window nor pacing.
---
>    * \brief Retransmit the oldest packet
1045c905
<   void DoRetransmit (void);
---
>   virtual void DoRetransmit (void);
1054,1072c914
<   void AddOptions (TcpHeader& tcpHeader);
< 
<   /**
<    * \brief Read TCP options before Ack processing
<    *
<    * Timestamp and Window scale are managed in other pieces of code.
<    *
<    * \param tcpHeader Header of the segment
<    * \param [out] bytesSacked Number of bytes SACKed, or 0
<    */
<   void ReadOptions (const TcpHeader &tcpHeader, uint32_t *bytesSacked);
< 
<   /**
<    * \brief Return true if the specified option is enabled
<    *
<    * \param kind kind of TCP option
<    * \return true if the option is enabled
<    */
<   bool IsTcpOptionEnabled (uint8_t kind) const;
---
>   virtual void AddOptions (TcpHeader& tcpHeader);
1102,1133d943
<   /**
<    * \brief Read the SACK PERMITTED option
<    *
<    * Currently this is a placeholder, since no operations should be done
<    * on such option.
<    *
<    * \param option SACK PERMITTED option from the header
<    */
<   void ProcessOptionSackPermitted (const Ptr<const TcpOption> option);
< 
<   /**
<    * \brief Read the SACK option
<    *
<    * \param option SACK option from the header
<    * \returns the number of bytes sacked by this option
<    */
<   uint32_t ProcessOptionSack(const Ptr<const TcpOption> option);
< 
<   /**
<    * \brief Add the SACK PERMITTED option to the header
<    *
<    * \param header TcpHeader where the method should add the option
<    */
<   void AddOptionSackPermitted (TcpHeader &header);
< 
<   /**
<    * \brief Add the SACK option to the header
<    *
<    * \param header TcpHeader where the method should add the option
<    */
<   void AddOptionSack (TcpHeader& header);
< 
1167,1177d976
<   /**
<    * \brief Notify Pacing
<    */
<   void NotifyPacingPerformed (void);
< 
<   /**
<    * \brief Add Tags for the Socket
<    * \param p Packet
<    */
<   void AddSocketTags (const Ptr<Packet> &p) const;
< 
1180,1209c979,999
<   EventId           m_retxEvent     {}; //!< Retransmission event
<   EventId           m_lastAckEvent  {}; //!< Last ACK timeout event
<   EventId           m_delAckEvent   {}; //!< Delayed ACK timeout event
<   EventId           m_persistEvent  {}; //!< Persist event: Send 1 byte to probe for a non-zero Rx window
<   EventId           m_timewaitEvent {}; //!< TIME_WAIT expiration event: Move this socket to CLOSED state
< 
<   // ACK management
<   uint32_t          m_dupAckCount {0};     //!< Dupack counter
<   uint32_t          m_delAckCount {0};     //!< Delayed ACK counter
<   uint32_t          m_delAckMaxCount {0};  //!< Number of packet to fire an ACK before delay timeout
< 
<   // Nagle algorithm
<   bool              m_noDelay {false};     //!< Set to true to disable Nagle's algorithm
< 
<   // Retries
<   uint32_t          m_synCount     {0}; //!< Count of remaining connection retries
<   uint32_t          m_synRetries   {0}; //!< Number of connection attempts
<   uint32_t          m_dataRetrCount {0}; //!< Count of remaining data retransmission attempts
<   uint32_t          m_dataRetries  {0}; //!< Number of data retransmission attempts
< 
<   // Timeouts
<   TracedValue<Time> m_rto     {Seconds (0.0)}; //!< Retransmit timeout
<   Time              m_minRto  {Time::Max ()};   //!< minimum value of the Retransmit timeout
<   Time              m_clockGranularity {Seconds (0.001)}; //!< Clock Granularity used in RTO calcs
<   Time              m_delAckTimeout    {Seconds (0.0)};   //!< Time to delay an ACK
<   Time              m_persistTimeout   {Seconds (0.0)};   //!< Time between sending 1-byte probes
<   Time              m_cnTimeout        {Seconds (0.0)};   //!< Timeout for connection retry
< 
<   // History of RTT
<   std::deque<RttHistory>      m_history;         //!< List of sent packet
---
>   EventId           m_retxEvent;       //!< Retransmission event
>   EventId           m_lastAckEvent;    //!< Last ACK timeout event
>   EventId           m_delAckEvent;     //!< Delayed ACK timeout event
>   EventId           m_persistEvent;    //!< Persist event: Send 1 byte to probe for a non-zero Rx window
>   EventId           m_timewaitEvent;   //!< TIME_WAIT expiration event: Move this socket to CLOSED state
>   uint32_t          m_dupAckCount;     //!< Dupack counter
>   uint32_t          m_delAckCount;     //!< Delayed ACK counter
>   uint32_t          m_delAckMaxCount;  //!< Number of packet to fire an ACK before delay timeout
>   bool              m_noDelay;         //!< Set to true to disable Nagle's algorithm
>   uint32_t          m_synCount;        //!< Count of remaining connection retries
>   uint32_t          m_synRetries;      //!< Number of connection attempts
>   uint32_t          m_dataRetrCount;   //!< Count of remaining data retransmission attempts
>   uint32_t          m_dataRetries;     //!< Number of data retransmission attempts
>   TracedValue<Time> m_rto;             //!< Retransmit timeout
>   Time              m_minRto;          //!< minimum value of the Retransmit timeout
>   Time              m_clockGranularity; //!< Clock Granularity used in RTO calcs
>   TracedValue<Time> m_lastRtt;         //!< Last RTT sample collected
>   Time              m_delAckTimeout;   //!< Time to delay an ACK
>   Time              m_persistTimeout;  //!< Time between sending 1-byte probes
>   Time              m_cnTimeout;       //!< Timeout for connection retry
>   RttHistory_t      m_history;         //!< List of sent packet
1212,1215c1002,1005
<   Ipv4EndPoint*       m_endPoint  {nullptr}; //!< the IPv4 endpoint
<   Ipv6EndPoint*       m_endPoint6 {nullptr}; //!< the IPv6 endpoint
<   Ptr<Node>           m_node;                //!< the associated node
<   Ptr<TcpL4Protocol>  m_tcp;                 //!< the associated TCP L4 protocol
---
>   Ipv4EndPoint*       m_endPoint;   //!< the IPv4 endpoint
>   Ipv6EndPoint*       m_endPoint6;  //!< the IPv6 endpoint
>   Ptr<Node>           m_node;       //!< the associated node
>   Ptr<TcpL4Protocol>  m_tcp;        //!< the associated TCP L4 protocol
1221,1222c1011,1013
<   // Tx buffer management
<   Ptr<TcpTxBuffer> m_txBuffer; //!< Tx buffer
---
>   // Rx and Tx buffer management
>   Ptr<TcpRxBuffer>              m_rxBuffer;       //!< Rx buffer (reordering buffer)
>   Ptr<TcpTxBuffer>              m_txBuffer;       //!< Tx buffer
1225,1232c1016,1023
<   TracedValue<TcpStates_t> m_state {CLOSED};         //!< TCP state
<   mutable enum SocketErrno m_errno {ERROR_NOTERROR}; //!< Socket error code
<   bool                     m_closeNotified {false};  //!< Told app to close socket
<   bool                     m_closeOnEmpty  {false};  //!< Close socket upon tx buffer emptied
<   bool                     m_shutdownSend  {false};  //!< Send no longer allowed
<   bool                     m_shutdownRecv  {false};  //!< Receive no longer allowed
<   bool                     m_connected     {false};  //!< Connection established
<   double                   m_msl           {0.0};    //!< Max segment lifetime
---
>   TracedValue<TcpStates_t> m_state;         //!< TCP state
>   mutable enum SocketErrno m_errno;         //!< Socket error code
>   bool                     m_closeNotified; //!< Told app to close socket
>   bool                     m_closeOnEmpty;  //!< Close socket upon tx buffer emptied
>   bool                     m_shutdownSend;  //!< Send no longer allowed
>   bool                     m_shutdownRecv;  //!< Receive no longer allowed
>   bool                     m_connected;     //!< Connection established
>   double                   m_msl;           //!< Max segment lifetime
1235,1241c1026,1032
<   uint16_t         m_maxWinSize              {0};  //!< Maximum window size to advertise
<   uint32_t         m_bytesAckedNotProcessed  {0};  //!< Bytes acked, but not processed
<   SequenceNumber32 m_highTxAck               {0};  //!< Highest ack sent
<   TracedValue<uint32_t> m_rWnd               {0};  //!< Receiver window (RCV.WND in RFC793)
<   TracedValue<uint32_t> m_advWnd             {0};  //!< Advertised Window size
<   TracedValue<SequenceNumber32> m_highRxMark {0};  //!< Highest seqno received
<   TracedValue<SequenceNumber32> m_highRxAckMark {0}; //!< Highest ack received
---
>   uint16_t              m_maxWinSize;  //!< Maximum window size to advertise
>   TracedValue<uint32_t> m_rWnd;        //!< Receiver window (RCV.WND in RFC793)
>   TracedValue<SequenceNumber32> m_highRxMark;     //!< Highest seqno received
>   SequenceNumber32 m_highTxAck;                   //!< Highest ack sent
>   TracedValue<SequenceNumber32> m_highRxAckMark;  //!< Highest ack received
>   uint32_t                      m_bytesAckedNotProcessed;  //!< Bytes acked, but not processed
>   TracedValue<uint32_t>         m_bytesInFlight; //!< Bytes in flight
1244,1249c1035,1040
<   bool    m_sackEnabled       {true}; //!< RFC SACK option enabled
<   bool    m_winScalingEnabled {true}; //!< Window Scale option enabled (RFC 7323)
<   uint8_t m_rcvWindShift      {0};    //!< Window shift to apply to outgoing segments
<   uint8_t m_sndWindShift      {0};    //!< Window shift to apply to incoming segments
<   bool     m_timestampEnabled {true}; //!< Timestamp option enabled
<   uint32_t m_timestampToEcho  {0};    //!< Timestamp to echo
---
>   bool    m_winScalingEnabled; //!< Window Scale option enabled (RFC 7323)
>   uint8_t m_rcvWindShift;      //!< Window shift to apply to outgoing segments
>   uint8_t m_sndWindShift;      //!< Window shift to apply to incoming segments
> 
>   bool     m_timestampEnabled;    //!< Timestamp option enabled
>   uint32_t m_timestampToEcho;     //!< Timestamp to echo
1251c1042
<   EventId m_sendPendingDataEvent {}; //!< micro-delay event to send pending data
---
>   EventId m_sendPendingDataEvent; //!< micro-delay event to send pending data
1254,1256c1045,1048
<   SequenceNumber32       m_recover    {0};   //!< Previous highest Tx seqnum for fast recovery (set it to initial seq number)
<   uint32_t               m_retxThresh {3};   //!< Fast Retransmit threshold
<   bool                   m_limitedTx  {true}; //!< perform limited transmit
---
>   SequenceNumber32       m_recover;      //!< Previous highest Tx seqnum for fast recovery
>   uint32_t               m_retxThresh;   //!< Fast Retransmit threshold
>   bool                   m_limitedTx;    //!< perform limited transmit
>   uint32_t               m_retransOut;   //!< Number of retransmission in this window
1259c1051
<   Ptr<TcpSocketState>    m_tcb;               //!< Congestion control information
---
>   Ptr<TcpSocketState>    m_tcb;               //!< Congestion control informations
1261,1262d1052
<   Ptr<TcpRecoveryOps>    m_recoveryOps;       //!< Recovery Algorithm
<   Ptr<TcpRateOps>        m_rateOps;           //!< Rate operations
1265c1055
<   bool m_isFirstPartialAck {true}; //!< First partial ACK during RECOVERY
---
>   bool m_isFirstPartialAck; //!< First partial ACK during RECOVERY
1273,1280d1062
< 
<   // Pacing related variable
<   Timer m_pacingTimer {Timer::REMOVE_ON_DESTROY}; //!< Pacing Event
< 
<   // Parameters related to Explicit Congestion Notification
<   TracedValue<SequenceNumber32> m_ecnEchoSeq {0};      //!< Sequence number of the last received ECN Echo
<   TracedValue<SequenceNumber32> m_ecnCESeq   {0};      //!< Sequence number of the last received Congestion Experienced
<   TracedValue<SequenceNumber32> m_ecnCWRSeq  {0};      //!< Sequence number of the last sent CWR
1292,1301d1073
< 
< /**
<  * \ingroup tcp
<  * TracedValue Callback signature for ECN state trace
<  *
<  * \param [in] oldValue original value of the traced variable
<  * \param [in] newValue new value of the traced variable
<  */
< typedef void (* EcnStatesTracedValueCallback)(const TcpSocketState::EcnState_t oldValue,
<                                                   const TcpSocketState::EcnState_t newValue);
diff ../../NS3-WiGig/src/internet/model/tcp-socket.h ../../ns-3-dev/src/internet/model/tcp-socket.h
149c149
<    * \param cwnd the initial congestion window (in segments)
---
>    * \param cwnd the initial congestion window (in bytes)
155c155
<    * \returns the initial congestion window (in segments)
---
>    * \returns the initial congestion window (in bytes)
232c232
<    * \brief Set the timeout for persistent connection
---
>    * \brief Set the timout for persistent connection
234c234
<    * When the timeout expires, send 1-byte data to probe for the window
---
>    * When the timout expires, send 1-byte data to probe for the window
238c238
<    * \param timeout the persistent timeout
---
>    * \param timeout the persistent timout
243c243
<    * \brief Get the timeout for persistent connection
---
>    * \brief Get the timout for persistent connection
245c245
<    * When the timeout expires, send 1-byte data to probe for the window
---
>    * When the timout expires, send 1-byte data to probe for the window
249c249
<    * \returns the persistent timeout
---
>    * \returns the persistent timout
Only in ../../NS3-WiGig/src/internet/model: tcp-socket-state.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-socket-state.h
diff ../../NS3-WiGig/src/internet/model/tcp-tx-buffer.cc ../../ns-3-dev/src/internet/model/tcp-tx-buffer.cc
3,4c3
<  * Copyright (c) 2010-2015 Adrian Sai-wah Tam
<  * Copyright (c) 2016 Natale Patriciello <natale.patriciello@gmail.com>
---
>  * Copyright (c) 2010 Adrian Sai-wah Tam
19c18
<  * Original author: Adrian Sai-wah Tam <adrian.sw.tam@gmail.com>
---
>  * Author: Adrian Sai-wah Tam <adrian.sw.tam@gmail.com>
22d20
< #include <algorithm>
23a22,23
> #include <algorithm>
> #include <cstring>
25a26
> #include "ns3/fatal-error.h"
27,28d27
< #include "ns3/abort.h"
< #include "ns3/tcp-option-ts.h"
34a34
> 
37d36
< Callback<void, TcpTxItem *> TcpTxBuffer::m_nullCb = MakeNullCallback<void, TcpTxItem*> ();
61c60
<   : m_maxBuffer (32768), m_size (0), m_sentSize (0), m_firstByteSeq (n)
---
>   : m_firstByteSeq (n), m_size (0), m_maxBuffer (32768), m_data (0)
67,81d65
<   PacketList::iterator it;
< 
<   for (it = m_sentList.begin (); it != m_sentList.end (); ++it)
<     {
<       TcpTxItem *item = *it;
<       m_sentSize -= item->m_packet->GetSize ();
<       delete item;
<     }
< 
<   for (it = m_appList.begin (); it != m_appList.end (); ++it)
<     {
<       TcpTxItem *item = *it;
<       m_size -= item->m_packet->GetSize ();
<       delete item;
<     }
120,165d103
< void
< TcpTxBuffer::SetDupAckThresh (uint32_t dupAckThresh)
< {
<   m_dupAckThresh = dupAckThresh;
< }
< 
< void
< TcpTxBuffer::SetSegmentSize (uint32_t segmentSize)
< {
<   m_segmentSize = segmentSize;
< }
< 
< uint32_t
< TcpTxBuffer::GetRetransmitsCount (void) const
< {
<   return m_retrans;
< }
< 
< uint32_t
< TcpTxBuffer::GetLost (void) const
< {
<   return m_lostOut;
< }
< 
< uint32_t
< TcpTxBuffer::GetSacked (void) const
< {
<   return m_sackedOut;
< }
< 
< void
< TcpTxBuffer::SetHeadSequence (const SequenceNumber32& seq)
< {
<   NS_LOG_FUNCTION (this << seq);
<   m_firstByteSeq = seq;
< 
<   if (m_sentList.size () > 0)
<     {
<       m_sentList.front ()->m_startSeq = seq;
<     }
< 
<   // if you change the head with data already sent, something bad will happen
<   NS_ASSERT (m_sentList.size () == 0);
<   m_highestSack = std::make_pair (m_sentList.end (), SequenceNumber32 (0));
< }
< 
170,171c108,109
<   NS_LOG_LOGIC ("Try to append " << p->GetSize () << " bytes to window starting at "
<                                 << m_firstByteSeq << ", availSize=" << Available ());
---
>   NS_LOG_LOGIC ("Packet of size " << p->GetSize () << " appending to window starting at "
>                                   << m_firstByteSeq << ", availSize="<< Available ());
176,178c114
<           TcpTxItem *item = new TcpTxItem ();
<           item->m_packet = p->Copy ();
<           m_appList.insert (m_appList.end (), item);
---
>           m_data.push_back (p);
180,182c116
< 
<           NS_LOG_LOGIC ("Updated size=" << m_size << ", lastSeq=" <<
<                         m_firstByteSeq + SequenceNumber32 (m_size));
---
>           NS_LOG_LOGIC ("Updated size=" << m_size << ", lastSeq=" << m_firstByteSeq + SequenceNumber32 (m_size));
195,204c129,133
<   SequenceNumber32 lastSeq = TailSequence ();
< 
<   if (lastSeq >= seq)
<     {
<       return static_cast<uint32_t> (lastSeq - seq);
<     }
< 
<   NS_LOG_ERROR ("Requested a sequence beyond our space (" << seq << " > " << lastSeq <<
<                 "). Returning 0 for convenience.");
<   return 0;
---
>   SequenceNumber32 lastSeq = m_firstByteSeq + SequenceNumber32 (m_size);
>   // Non-negative size
>   NS_LOG_LOGIC ("HeadSeq=" << m_firstByteSeq << ", lastSeq=" << lastSeq << ", size=" << m_size <<
>                 ", returns " << lastSeq - seq);
>   return lastSeq - seq;
207c136
< TcpTxItem *
---
> Ptr<Packet>
211,218c140
< 
<   NS_ABORT_MSG_IF (m_firstByteSeq > seq,
<                    "Requested a sequence number which is not in the buffer anymore");
<   ConsistencyCheck ();
< 
<   // Real size to extract. Insure not beyond end of data
<   uint32_t s = std::min (numBytes, SizeFromSequence (seq));
< 
---
>   uint32_t s = std::min (numBytes, SizeFromSequence (seq)); // Real size to extract. Insure not beyond end of data
221,256c143
<       return nullptr;
<     }
< 
<   TcpTxItem *outItem = nullptr;
< 
<   if (m_firstByteSeq + m_sentSize >= seq + s)
<     {
<       // already sent this block completely
<       outItem = GetTransmittedSegment (s, seq);
<       NS_ASSERT (outItem != nullptr);
<       NS_ASSERT (!outItem->m_sacked);
< 
<       NS_LOG_DEBUG ("Returning already sent item " << *outItem << " from " << *this);
<     }
<   else if (m_firstByteSeq + m_sentSize <= seq)
<     {
<       NS_ABORT_MSG_UNLESS (m_firstByteSeq + m_sentSize == seq,
<                            "Requesting a piece of new data with an hole");
< 
<       // this is the first time we transmit this block
<       outItem = GetNewSegment (s);
<       NS_ASSERT (outItem != nullptr);
<       NS_ASSERT (outItem->m_retrans == false);
< 
<       NS_LOG_DEBUG ("Returning new item " << *outItem << " from " << *this);
<     }
<   else if (m_firstByteSeq.Get ().GetValue () + m_sentSize > seq.GetValue ()
<            && m_firstByteSeq.Get ().GetValue () + m_sentSize < seq.GetValue () + s)
<     {
<       // Partial: a part is retransmission, the remaining data is new
<       // Just return the old segment, without taking new data. Hopefully
<       // TcpSocketBase will request new data
< 
<       uint32_t amount = (m_firstByteSeq.Get ().GetValue () + m_sentSize) - seq.GetValue ();
< 
<       return CopyFromSequence (amount, seq);
---
>       return Create<Packet> (); // Empty packet returned
258,317c145,173
< 
<   outItem->m_lastSent = Simulator::Now ();
<   NS_ASSERT_MSG (outItem->m_startSeq >= m_firstByteSeq,
<                  "Returning an item " << *outItem << " with SND.UNA as " <<
<                  m_firstByteSeq);
<   ConsistencyCheck ();
<   return outItem;
< }
< 
< TcpTxItem*
< TcpTxBuffer::GetNewSegment (uint32_t numBytes)
< {
<   NS_LOG_FUNCTION (this << numBytes);
< 
<   SequenceNumber32 startOfAppList = m_firstByteSeq + m_sentSize;
< 
<   NS_LOG_INFO ("AppList start at " << startOfAppList << ", sentSize = " <<
<                m_sentSize << " firstByte: " << m_firstByteSeq);
< 
<   TcpTxItem *item = GetPacketFromList (m_appList, startOfAppList,
<                                        numBytes, startOfAppList);
<   item->m_startSeq = startOfAppList;
< 
<   // Move item from AppList to SentList (should be the first, not too complex)
<   auto it = std::find (m_appList.begin (), m_appList.end (), item);
<   NS_ASSERT (it != m_appList.end ());
< 
<   m_appList.erase (it);
<   m_sentList.insert (m_sentList.end (), item);
<   m_sentSize += item->m_packet->GetSize ();
< 
<   return item;
< }
< 
< TcpTxItem*
< TcpTxBuffer::GetTransmittedSegment (uint32_t numBytes, const SequenceNumber32 &seq)
< {
<   NS_LOG_FUNCTION (this << numBytes << seq);
<   NS_ASSERT (seq >= m_firstByteSeq);
<   NS_ASSERT (numBytes <= m_sentSize);
<   NS_ASSERT (m_sentList.size () >= 1);
< 
<   auto it = m_sentList.begin ();
<   bool listEdited = false;
<   uint32_t s = numBytes;
< 
<   // Avoid to merge different packet for this retransmission if flags are
<   // different.
<   for (; it != m_sentList.end(); ++it)
<     {
<       if ((*it)->m_startSeq == seq)
<         {
<           auto next = it;
<           next++;
<           if (next != m_sentList.end ())
<             {
<               // Next is not sacked... there is the possibility to merge
<               if (! (*next)->m_sacked)
<                 {
<                   s = std::min(s, (*it)->m_packet->GetSize () + (*next)->m_packet->GetSize ());
---
>   if (m_data.size () == 0)
>     { // No actual data, just return dummy-data packet of correct size
>       return Create<Packet> (s);
>     }
> 
>   // Extract data from the buffer and return
>   uint32_t offset = seq - m_firstByteSeq.Get ();
>   uint32_t count = 0;      // Offset of the first byte of a packet in the buffer
>   uint32_t pktSize = 0;
>   bool beginFound = false;
>   int pktCount = 0;
>   Ptr<Packet> outPacket;
>   NS_LOG_LOGIC ("There are " << m_data.size () << " number of packets in buffer");
>   for (BufIterator i = m_data.begin (); i != m_data.end (); ++i)
>     {
>       pktCount++;
>       pktSize = (*i)->GetSize ();
>       if (!beginFound)
>         { // Look for first fragment
>           if (count + pktSize > offset)
>             {
>               NS_LOG_LOGIC ("First byte found in packet #" << pktCount << " at buffer offset " << count
>                                                            << ", packet len=" << pktSize);
>               beginFound = true;
>               uint32_t packetOffset = offset - count;
>               uint32_t fragmentLength = count + pktSize - offset;
>               if (fragmentLength >= s)
>                 { // Data to be copied falls entirely in this packet
>                   return (*i)->CreateFragment (packetOffset, s);
320,322c176,177
<                 {
<                   // Next is sacked... better to retransmit only the first segment
<                   s = std::min(s, (*it)->m_packet->GetSize ());
---
>                 { // This packet only fulfills part of the request
>                   outPacket = (*i)->CreateFragment (packetOffset, fragmentLength);
323a179
>               NS_LOG_LOGIC ("Output packet is now of size " << outPacket->GetSize ());
325,358d180
<           else
<             {
<               s = std::min(s, (*it)->m_packet->GetSize ());
<             }
<           break;
<         }
<     }
< 
<   TcpTxItem *item = GetPacketFromList (m_sentList, m_firstByteSeq, s, seq, &listEdited);
< 
<   if (! item->m_retrans)
<     {
<       m_retrans += item->m_packet->GetSize ();
<       item->m_retrans = true;
<     }
< 
<   return item;
< }
< 
< std::pair <TcpTxBuffer::PacketList::const_iterator, SequenceNumber32>
< TcpTxBuffer::FindHighestSacked () const
< {
<   NS_LOG_FUNCTION (this);
< 
<   SequenceNumber32 beginOfCurrentPacket = m_firstByteSeq;
< 
<   auto ret = std::make_pair (m_sentList.end (), SequenceNumber32 (0));
< 
<   for (auto it = m_sentList.begin (); it != m_sentList.end (); ++it)
<     {
<       const TcpTxItem *item = *it;
<       if (item->m_sacked)
<         {
<           ret = std::make_pair (it, beginOfCurrentPacket);
360,534c182,190
<       beginOfCurrentPacket += item->m_packet->GetSize ();
<     }
< 
<   return ret;
< }
< 
< 
< void
< TcpTxBuffer::SplitItems (TcpTxItem *t1, TcpTxItem *t2, uint32_t size) const
< {
<   NS_ASSERT (t1 != nullptr && t2 != nullptr);
<   NS_LOG_FUNCTION (this << *t2 << size);
< 
<   t1->m_packet = t2->m_packet->CreateFragment (0, size);
<   t2->m_packet->RemoveAtStart (size);
< 
<   t1->m_startSeq = t2->m_startSeq;
<   t1->m_sacked = t2->m_sacked;
<   t1->m_lastSent = t2->m_lastSent;
<   t1->m_retrans = t2->m_retrans;
<   t1->m_lost = t2->m_lost;
< 
<   t2->m_startSeq += size;
< 
<   NS_LOG_INFO ("Split of size " << size << " result: t1 " << *t1 << " t2 " << *t2);
< }
< 
< TcpTxItem*
< TcpTxBuffer::GetPacketFromList (PacketList &list, const SequenceNumber32 &listStartFrom,
<                                 uint32_t numBytes, const SequenceNumber32 &seq,
<                                 bool *listEdited) const
< {
<   NS_LOG_FUNCTION (this << numBytes << seq);
< 
<   /*
<    * Our possibilities are sketched out in the following:
<    *
<    *                    |------|     |----|     |----|
<    * GetList (m_data) = |      | --> |    | --> |    |
<    *                    |------|     |----|     |----|
<    *
<    *                    ^ ^ ^  ^
<    *                    | | |  |         (1)
<    *                  seq | |  numBytes
<    *                      | |
<    *                      | |
<    *                    seq numBytes     (2)
<    *
<    * (1) seq and numBytes are the boundary of some packet
<    * (2) seq and numBytes are not the boundary of some packet
<    *
<    * We can have mixed case (e.g. seq over the boundary while numBytes not).
<    *
<    * If we discover that we are in (2) or in a mixed case, we split
<    * packets accordingly to the requested bounds and re-run the function.
<    *
<    * In (1), things are pretty easy, it's just a matter of walking the list and
<    * defragment packets, if needed (e.g. seq is the beginning of the first packet
<    * while maxBytes is the end of some packet next in the list).
<    */
< 
<   Ptr<Packet> currentPacket = nullptr;
<   TcpTxItem *currentItem = nullptr;
<   TcpTxItem *outItem = nullptr;
<   PacketList::iterator it = list.begin ();
<   SequenceNumber32 beginOfCurrentPacket = listStartFrom;
< 
<   while (it != list.end ())
<     {
<       currentItem = *it;
<       currentPacket = currentItem->m_packet;
<       NS_ASSERT_MSG (list != m_sentList || currentItem->m_startSeq >= m_firstByteSeq,
<                      "start: " << m_firstByteSeq << " currentItem start: " <<
<                      currentItem->m_startSeq);
< 
<       // The objective of this snippet is to find (or to create) the packet
<       // that begin with the sequence seq
< 
<       if (seq < beginOfCurrentPacket + currentPacket->GetSize ())
<         {
<           // seq is inside the current packet
<           if (seq == beginOfCurrentPacket)
<             {
<               // seq is the beginning of the current packet. Hurray!
<               outItem = currentItem;
<               NS_LOG_INFO ("Current packet starts at seq " << seq <<
<                            " ends at " << seq + currentPacket->GetSize ());
<             }
<           else if (seq > beginOfCurrentPacket)
<             {
<               // seq is inside the current packet but seq is not the beginning,
<               // it's somewhere in the middle. Just fragment the beginning and
<               // start again.
<               NS_LOG_INFO ("we are at " << beginOfCurrentPacket <<
<                            " searching for " << seq <<
<                            " and now we recurse because packet ends at "
<                                         << beginOfCurrentPacket + currentPacket->GetSize ());
<               TcpTxItem *firstPart = new TcpTxItem ();
<               SplitItems (firstPart, currentItem, seq - beginOfCurrentPacket);
< 
<               // insert firstPart before currentItem
<               list.insert (it, firstPart);
<               if (listEdited)
<                 {
<                   *listEdited = true;
<                 }
< 
<               return GetPacketFromList (list, listStartFrom, numBytes, seq, listEdited);
<             }
<           else
<             {
<               NS_FATAL_ERROR ("seq < beginOfCurrentPacket: our data is before");
<             }
<         }
<       else
<         {
<           // Walk the list, the current packet does not contain seq
<           beginOfCurrentPacket += currentPacket->GetSize ();
<           it++;
<           continue;
<         }
< 
<       NS_ASSERT (outItem != nullptr);
< 
<       // The objective of this snippet is to find (or to create) the packet
<       // that ends after numBytes bytes. We are sure that outPacket starts
<       // at seq.
< 
<       if (seq + numBytes <= beginOfCurrentPacket + currentPacket->GetSize ())
<         {
<           // the end boundary is inside the current packet
<           if (numBytes == currentPacket->GetSize ())
<             {
<               // the end boundary is exactly the end of the current packet. Hurray!
<               if (currentItem->m_packet == outItem->m_packet)
<                 {
<                   // A perfect match!
<                   return outItem;
<                 }
<               else
<                 {
<                   // the end is exactly the end of current packet, but
<                   // current > outPacket in the list. Merge current with the
<                   // previous, and recurse.
<                   NS_ASSERT (it != list.begin ());
<                   TcpTxItem *previous = *(--it);
< 
<                   list.erase (it);
< 
<                   MergeItems (previous, currentItem);
<                   delete currentItem;
<                   if (listEdited)
<                     {
<                       *listEdited = true;
<                     }
< 
<                   return GetPacketFromList (list, listStartFrom, numBytes, seq, listEdited);
<                 }
<             }
<           else if (numBytes < currentPacket->GetSize ())
<             {
<               // the end is inside the current packet, but it isn't exactly
<               // the packet end. Just fragment, fix the list, and return.
<               TcpTxItem *firstPart = new TcpTxItem ();
<               SplitItems (firstPart, currentItem, numBytes);
< 
<               // insert firstPart before currentItem
<               list.insert (it, firstPart);
<               if (listEdited)
<                 {
<                   *listEdited = true;
<                 }
< 
<               return firstPart;
<             }
---
>       else if (count + pktSize >= offset + s)
>         { // Last packet fragment found
>           NS_LOG_LOGIC ("Last byte found in packet #" << pktCount << " at buffer offset " << count
>                                                       << ", packet len=" << pktSize);
>           uint32_t fragmentLength = offset + s - count;
>           Ptr<Packet> endFragment = (*i)->CreateFragment (0, fragmentLength);
>           outPacket->AddAtEnd (endFragment);
>           NS_LOG_LOGIC ("Output packet is now of size " << outPacket->GetSize ());
>           break;
538,565c194,196
<           // The end isn't inside current packet, but there is an exception for
<           // the merge and recurse strategy...
<           if (++it == list.end ())
<             {
<               // ...current is the last packet we sent. We have not more data;
<               // Go for this one.
<               NS_LOG_WARN ("Cannot reach the end, but this case is covered "
<                            "with conditional statements inside CopyFromSequence."
<                            "Something has gone wrong, report a bug");
<               return outItem;
<             }
< 
<           // The current packet does not contain the requested end. Merge current
<           // with the packet that follows, and recurse
<           TcpTxItem *next = (*it); // Please remember we have incremented it
<                                    // in the previous if
< 
<           MergeItems (currentItem, next);
<           list.erase (it);
< 
<           delete next;
< 
<           if (listEdited)
<             {
<               *listEdited = true;
<             }
< 
<           return GetPacketFromList (list, listStartFrom, numBytes, seq, listEdited);
---
>           NS_LOG_LOGIC ("Appending to output the packet #" << pktCount << " of offset " << count << " len=" << pktSize);
>           outPacket->AddAtEnd (*i);
>           NS_LOG_LOGIC ("Output packet is now of size " << outPacket->GetSize ());
566a198
>       count += pktSize;
568,574c200,201
< 
<   NS_FATAL_ERROR ("This point is not reachable");
< }
< 
< static bool AreEquals (const bool &first, const bool &second)
< {
<   return first ? second : !second;
---
>   NS_ASSERT (outPacket->GetSize () == s);
>   return outPacket;
578c205
< TcpTxBuffer::MergeItems (TcpTxItem *t1, TcpTxItem *t2) const
---
> TcpTxBuffer::SetHeadSequence (const SequenceNumber32& seq)
580,616c207,208
<   NS_ASSERT (t1 != nullptr && t2 != nullptr);
<   NS_LOG_FUNCTION (this << *t1 << *t2);
<   NS_LOG_INFO ("Merging " << *t2 << " into " << *t1);
< 
<   NS_ASSERT_MSG (AreEquals (t1->m_sacked, t2->m_sacked),
<                  "Merging one sacked and another not sacked. Impossible");
<   NS_ASSERT_MSG (AreEquals (t1->m_lost, t2->m_lost),
<                  "Merging one lost and another not lost. Impossible");
< 
<   // If one is retrans and the other is not, cancel the retransmitted flag.
<   // We are merging this segment for the retransmit, so the count will
<   // be updated in MarkTransmittedSegment.
<   if (! AreEquals (t1->m_retrans, t2->m_retrans))
<     {
<       if (t1->m_retrans)
<         {
<           TcpTxBuffer *self = const_cast<TcpTxBuffer*> (this);
<           self->m_retrans -= t1->m_packet->GetSize ();
<           t1->m_retrans = false;
<         }
<       else
<         {
<           NS_ASSERT (t2->m_retrans);
<           TcpTxBuffer *self = const_cast<TcpTxBuffer*> (this);
<           self->m_retrans -= t2->m_packet->GetSize ();
<           t2->m_retrans = false;
<         }
<     }
< 
<   if (t1->m_lastSent < t2->m_lastSent)
<     {
<       t1->m_lastSent = t2->m_lastSent;
<     }
< 
<   t1->m_packet->AddAtEnd (t2->m_packet);
< 
<   NS_LOG_INFO ("Situation after the merge: " << *t1);
---
>   NS_LOG_FUNCTION (this << seq);
>   m_firstByteSeq = seq;
620,642c212
< TcpTxBuffer::RemoveFromCounts (TcpTxItem *item, uint32_t size)
< {
<   NS_LOG_FUNCTION (this << *item << size);
<   if (item->m_sacked)
<     {
<       NS_ASSERT (m_sackedOut >= size);
<       m_sackedOut -= size;
<     }
<   if (item->m_retrans)
<     {
<       NS_ASSERT (m_retrans >= size);
<       m_retrans -= size;
<     }
<   if (item->m_lost)
<     {
<       NS_ASSERT_MSG (m_lostOut >= size, "Trying to remove " << size <<
<                      " bytes from " << m_lostOut);
<       m_lostOut -= size;
<     }
< }
< void
< TcpTxBuffer::DiscardUpTo (const SequenceNumber32& seq,
<                           const Callback<void, TcpTxItem *> &beforeDelCb)
---
> TcpTxBuffer::DiscardUpTo (const SequenceNumber32& seq)
645c215,216
< 
---
>   NS_LOG_LOGIC ("current data size=" << m_size << ", headSeq=" << m_firstByteSeq << ", maxBuffer=" << m_maxBuffer
>                                      << ", numPkts=" << m_data.size ());
647,653c218
<   if (m_firstByteSeq >= seq)
<     {
<       NS_LOG_DEBUG ("Seq " << seq << " already discarded.");
<       return;
<     }
<   NS_LOG_DEBUG ("Remove up to " << seq << " lost: " << m_lostOut <<
<                 " retrans: " << m_retrans << " sacked: " << m_sackedOut);
---
>   if (m_firstByteSeq >= seq) return;
658,659c223,225
<   PacketList::iterator i = m_sentList.begin ();
<   while (m_size > 0 && offset > 0)
---
>   NS_LOG_LOGIC ("Offset=" << offset);
>   BufIterator i = m_data.begin ();
>   while (i != m_data.end ())
661,677c227
<       if (i == m_sentList.end ())
<         {
<           // Move data from app list to sent list, so we can delete the item
<           Ptr<Packet> p = CopyFromSequence (offset, m_firstByteSeq)->GetPacketCopy ();
<           NS_ASSERT (p != nullptr);
<           NS_UNUSED (p);
<           i = m_sentList.begin ();
<           NS_ASSERT (i != m_sentList.end ());
<         }
<       TcpTxItem *item = *i;
<       Ptr<Packet> p = item->m_packet;
<       pktSize = p->GetSize ();
<       NS_ASSERT_MSG (item->m_startSeq == m_firstByteSeq,
<                      "Item starts at " << item->m_startSeq <<
<                      " while SND.UNA is " << m_firstByteSeq << " from " << *this);
< 
<       if (offset >= pktSize)
---
>       if (offset > (*i)->GetSize ())
678a229
>           pktSize = (*i)->GetSize ();
680d230
<           m_sentSize -= pktSize;
683,697c233,234
< 
<           RemoveFromCounts (item, pktSize);
< 
<           i = m_sentList.erase (i);
<           NS_LOG_INFO ("Removed " << *item << " lost: " << m_lostOut <<
<                        " retrans: " << m_retrans << " sacked: " << m_sackedOut <<
<                        ". Remaining data " << m_size);
< 
<           if (!beforeDelCb.IsNull ())
<             {
<               // Inform Rate algorithms only when a full packet is ACKed
<               beforeDelCb (item);
<             }
< 
<           delete item;
---
>           i = m_data.erase (i);
>           NS_LOG_LOGIC ("Removed one packet of size " << pktSize << ", offset=" << offset);
701,705c238,239
<           pktSize -= offset;
<           NS_LOG_INFO (*item);
<           // PacketTags are preserved when fragmenting
<           item->m_packet = item->m_packet->CreateFragment (offset, pktSize);
<           item->m_startSeq += offset;
---
>           pktSize = (*i)->GetSize () - offset;
>           *i = (*i)->CreateFragment (offset, pktSize);
707d240
<           m_sentSize -= offset;
709,714c242
< 
<           RemoveFromCounts (item, offset);
< 
<           NS_LOG_INFO ("Fragmented one packet by size " << offset <<
<                        ", new size=" << pktSize << " resulting item is " <<
<                        *item << " status: " << *this);
---
>           NS_LOG_LOGIC ("Fragmented one packet by size " << offset << ", new size=" << pktSize);
723,1455c251,253
< 
<   if (!m_sentList.empty ())
<     {
<       TcpTxItem *head = m_sentList.front ();
<       if (head->m_sacked)
<         {
<           NS_ASSERT (!head->m_lost);
<           // It is not possible to have the UNA sacked; otherwise, it would
<           // have been ACKed. This is, most likely, our wrong guessing
<           // when adding Reno dupacks in the count.
<           head->m_sacked = false;
<           m_sackedOut -= head->m_packet->GetSize ();
<           NS_LOG_INFO ("Moving the SACK flag from the HEAD to another segment");
<           AddRenoSack ();
<           MarkHeadAsLost ();
<         }
< 
<       NS_ASSERT_MSG (head->m_startSeq == seq,
<                      "While removing up to " << seq << " we get SND.UNA to " <<
<                      m_firstByteSeq << " this is the result: " << *this);
<     }
< 
<   if (m_highestSack.second <= m_firstByteSeq)
<     {
<       m_highestSack = std::make_pair (m_sentList.end (), SequenceNumber32 (0));
<     }
< 
<   NS_LOG_DEBUG ("Discarded up to " << seq << " lost: " << m_lostOut <<
<                 " retrans: " << m_retrans << " sacked: " << m_sackedOut);
<   NS_LOG_LOGIC ("Buffer status after discarding data " << *this);
<   NS_ASSERT (m_firstByteSeq >= seq);
<   NS_ASSERT (m_sentSize >= m_sackedOut + m_lostOut);
<   ConsistencyCheck ();
< }
< 
< uint32_t
< TcpTxBuffer::Update (const TcpOptionSack::SackList &list,
<                      const Callback<void, TcpTxItem *> &sackedCb)
< {
<   NS_LOG_FUNCTION (this);
<   NS_LOG_INFO ("Updating scoreboard, got " << list.size () << " blocks to analyze");
< 
<   uint32_t bytesSacked = 0;
< 
<   for (auto option_it = list.begin (); option_it != list.end (); ++option_it)
<     {
<       PacketList::iterator item_it = m_sentList.begin ();
<       SequenceNumber32 beginOfCurrentPacket = m_firstByteSeq;
< 
<       if (m_firstByteSeq + m_sentSize < (*option_it).first)
<         {
<           NS_LOG_INFO ("Not updating scoreboard, the option block is outside the sent list");
<           return bytesSacked;
<         }
< 
<       while (item_it != m_sentList.end ())
<         {
<           uint32_t pktSize = (*item_it)->m_packet->GetSize ();
< 
<           // Check the boundary of this packet ... only mark as sacked if
<           // it is precisely mapped over the option. It means that if the receiver
<           // is reporting as sacked single range bytes that are not mapped 1:1
<           // in what we have, the option is discarded. There's room for improvement
<           // here.
<           if (beginOfCurrentPacket >= (*option_it).first
<               && beginOfCurrentPacket + pktSize <= (*option_it).second)
<             {
<               if ((*item_it)->m_sacked)
<                 {
<                   NS_ASSERT (!(*item_it)->m_lost);
<                   NS_LOG_INFO ("Received block " << *option_it <<
<                                ", checking sentList for block " << *(*item_it) <<
<                                ", found in the sackboard already sacked");
<                 }
<               else
<                 {
<                   if ((*item_it)->m_lost)
<                     {
<                       (*item_it)->m_lost = false;
<                       m_lostOut -= (*item_it)->m_packet->GetSize ();
<                     }
< 
<                   (*item_it)->m_sacked = true;
<                   m_sackedOut += (*item_it)->m_packet->GetSize ();
<                   bytesSacked += (*item_it)->m_packet->GetSize ();
< 
<                   if (m_highestSack.first == m_sentList.end()
<                       || m_highestSack.second <= beginOfCurrentPacket + pktSize)
<                     {
<                       m_highestSack = std::make_pair (item_it, beginOfCurrentPacket);
<                     }
< 
<                   NS_LOG_INFO ("Received block " << *option_it <<
<                                ", checking sentList for block " << *(*item_it) <<
<                                ", found in the sackboard, sacking, current highSack: " <<
<                                m_highestSack.second);
< 
<                   if (!sackedCb.IsNull ())
<                     {
<                       sackedCb (*item_it);
<                     }
<                 }
<             }
<           else if (beginOfCurrentPacket + pktSize > (*option_it).second)
<             {
<               // We already passed the received block end. Exit from the loop
<               NS_LOG_INFO ("Received block [" << *option_it <<
<                            ", checking sentList for block " << *(*item_it) <<
<                            "], not found, breaking loop");
<               break;
<             }
< 
<           beginOfCurrentPacket += pktSize;
<           ++item_it;
<         }
<     }
< 
<   if (bytesSacked > 0)
<     {
<       NS_ASSERT_MSG (m_highestSack.first != m_sentList.end(), "Buffer status: " << *this);
<       UpdateLostCount ();
<     }
< 
<   NS_ASSERT ((*(m_sentList.begin ()))->m_sacked == false);
<   NS_ASSERT_MSG (m_sentSize >= m_sackedOut + m_lostOut, *this);
<   //NS_ASSERT (list.size () == 0 || modified);   // Assert for duplicated SACK or
<                                                  // impossiblity to map the option into the sent blocks
<   ConsistencyCheck ();
<   return bytesSacked;
< }
< 
< void
< TcpTxBuffer::UpdateLostCount ()
< {
<   NS_LOG_FUNCTION (this);
<   uint32_t sacked = 0;
<   SequenceNumber32 beginOfCurrentPacket = m_highestSack.second;
<   if (m_highestSack.first == m_sentList.end ())
<     {
<       NS_LOG_INFO ("Status before the update: " << *this <<
<                    ", will start from the latest sent item");
<     }
<   else
<     {
<       NS_LOG_INFO ("Status before the update: " << *this <<
<                    ", will start from item " << *(*m_highestSack.first));
<     }
< 
<   for (auto it = m_highestSack.first; it != m_sentList.begin(); --it)
<     {
<       TcpTxItem *item = *it;
<       if (item->m_sacked)
<         {
<           sacked++;
<         }
< 
<       if (sacked >= m_dupAckThresh)
<         {
<           if (!item->m_sacked && !item->m_lost)
<             {
<               item->m_lost = true;
<               m_lostOut += item->m_packet->GetSize ();
<             }
<         }
<       beginOfCurrentPacket -= item->m_packet->GetSize ();
<     }
< 
<   if (sacked >= m_dupAckThresh)
<     {
<       TcpTxItem *item = *m_sentList.begin ();
<       if (!item->m_lost)
<         {
<           item->m_lost = true;
<           m_lostOut += item->m_packet->GetSize ();
<         }
<     }
<   NS_LOG_INFO ("Status after the update: " << *this);
<   ConsistencyCheck ();
< }
< 
< bool
< TcpTxBuffer::IsLost (const SequenceNumber32 &seq) const
< {
<   NS_LOG_FUNCTION (this << seq);
< 
<   SequenceNumber32 beginOfCurrentPacket = m_firstByteSeq;
<   PacketList::const_iterator it;
< 
<   if (seq >= m_highestSack.second)
<     {
<       return false;
<     }
< 
<   // In theory, using a map and hints when inserting elements can improve
<   // performance
<   for (it = m_sentList.begin (); it != m_sentList.end (); ++it)
<     {
<       // Search for the right iterator before calling IsLost()
<       if (beginOfCurrentPacket >= seq)
<         {
<           if ((*it)->m_lost == true)
<             {
<               NS_LOG_INFO ("seq=" << seq << " is lost because of lost flag");
<               return true;
<             }
< 
<           if ((*it)->m_sacked == true)
<             {
<               NS_LOG_INFO ("seq=" << seq << " is not lost because of sacked flag");
<               return false;
<             }
<         }
< 
<       beginOfCurrentPacket += (*it)->m_packet->GetSize ();
<     }
< 
<   return false;
< }
< 
< bool
< TcpTxBuffer::NextSeg (SequenceNumber32 *seq, bool isRecovery) const
< {
<   NS_LOG_FUNCTION (this);
<   /* RFC 6675, NextSeg definition.
<    *
<    * (1) If there exists a smallest unSACKed sequence number 'S2' that
<    *     meets the following three criteria for determining loss, the
<    *     sequence range of one segment of up to SMSS octets starting
<    *     with S2 MUST be returned.
<    *
<    *     (1.a) S2 is greater than HighRxt.
<    *
<    *     (1.b) S2 is less than the highest octet covered by any
<    *           received SACK.
<    *
<    *     (1.c) IsLost (S2) returns true.
<    */
<   PacketList::const_iterator it;
<   TcpTxItem *item;
<   SequenceNumber32 seqPerRule3;
<   bool isSeqPerRule3Valid = false;
<   SequenceNumber32 beginOfCurrentPkt = m_firstByteSeq;
< 
<   for (it = m_sentList.begin (); it != m_sentList.end (); ++it)
<     {
<       item = *it;
< 
<       // Condition 1.a , 1.b , and 1.c
<       if (item->m_retrans == false && item->m_sacked == false)
<         {
<           if (item->m_lost)
<             {
<               NS_LOG_INFO("IsLost, returning" << beginOfCurrentPkt);
<               *seq = beginOfCurrentPkt;
<               return true;
<             }
<           else if (seqPerRule3.GetValue () == 0 && isRecovery)
<             {
<               NS_LOG_INFO ("Saving for rule 3 the seq " << beginOfCurrentPkt);
<               isSeqPerRule3Valid = true;
<               seqPerRule3 = beginOfCurrentPkt;
<             }
<         }
< 
<       // Nothing found, iterate
<       beginOfCurrentPkt += item->m_packet->GetSize ();
<     }
< 
<   /* (2) If no sequence number 'S2' per rule (1) exists but there
<    *     exists available unsent data and the receiver's advertised
<    *     window allows, the sequence range of one segment of up to SMSS
<    *     octets of previously unsent data starting with sequence number
<    *     HighData+1 MUST be returned.
<    */
<   if (SizeFromSequence (m_firstByteSeq + m_sentSize) > 0)
<     {
<       NS_LOG_INFO ("There is unsent data. Send it");
<       *seq = m_firstByteSeq + m_sentSize;
<       return true;
<     }
<   else
<     {
<       NS_LOG_INFO ("There isn't unsent data.");
<     }
< 
<   /* (3) If the conditions for rules (1) and (2) fail, but there exists
<    *     an unSACKed sequence number 'S3' that meets the criteria for
<    *     detecting loss given in steps (1.a) and (1.b) above
<    *     (specifically excluding step (1.c)), then one segment of up to
<    *     SMSS octets starting with S3 SHOULD be returned.
<    */
<   if (isSeqPerRule3Valid)
<     {
<       NS_LOG_INFO ("Rule3 valid. " << seqPerRule3);
<       *seq = seqPerRule3;
<       return true;
<     }
< 
<   /* (4) If the conditions for (1), (2), and (3) fail, but there exists
<    *     outstanding unSACKed data, we provide the opportunity for a
<    *     single "rescue" retransmission per entry into loss recovery.
<    *     If HighACK is greater than RescueRxt (or RescueRxt is
<    *     undefined), then one segment of up to SMSS octets that MUST
<    *     include the highest outstanding unSACKed sequence number
<    *     SHOULD be returned, and RescueRxt set to RecoveryPoint.
<    *     HighRxt MUST NOT be updated.
<    *
<    * This point require too much interaction between us and TcpSocketBase.
<    * We choose to not respect the SHOULD (allowed from RFC MUST/SHOULD definition)
<    */
<   NS_LOG_INFO ("Can't return anything");
<   return false;
< }
< 
< uint32_t
< TcpTxBuffer::BytesInFlight () const
< {
<   NS_ASSERT_MSG (m_sackedOut + m_lostOut <= m_sentSize,
<                  "Count of sacked " << m_sackedOut << " and lost " << m_lostOut <<
<                  " is out of sync with sent list size " << m_sentSize <<
<                  " " << *this);
<   uint32_t leftOut = m_sackedOut + m_lostOut;
<   uint32_t retrans = m_retrans;
< 
<   NS_LOG_INFO ("Sent size: " << m_sentSize << " leftOut: " << leftOut <<
<                " retrans: " << retrans);
<   uint32_t in_flight = m_sentSize - leftOut + retrans;
< 
<   //uint32_t rfc_in_flight = BytesInFlightRFC (3, segmentSize);
<   //NS_ASSERT_MSG(in_flight == rfc_in_flight,
<   //              "Calculated: " << in_flight << " RFC: " << rfc_in_flight <<
<   //              "Sent size: " << m_sentSize << " leftOut: " << leftOut <<
<   //                             " retrans: " << retrans);
<   return in_flight;
< }
< 
< uint32_t
< TcpTxBuffer::BytesInFlightRFC () const
< {
<   PacketList::const_iterator it;
<   TcpTxItem *item;
<   uint32_t size = 0; // "pipe" in RFC
<   SequenceNumber32 beginOfCurrentPkt = m_firstByteSeq;
<   uint32_t sackedOut = 0;
<   uint32_t lostOut = 0;
<   uint32_t retrans = 0;
<   uint32_t totalSize = 0;
< 
<   // After initializing pipe to zero, the following steps are taken for each
<   // octet 'S1' in the sequence space between HighACK and HighData that has not
<   // been SACKed:
<   for (it = m_sentList.begin (); it != m_sentList.end (); ++it)
<     {
<       item = *it;
<       totalSize += item->m_packet->GetSize();
<       if (!item->m_sacked)
<         {
<           bool isLost = IsLostRFC (beginOfCurrentPkt, it);
<           // (a) If IsLost (S1) returns false: Pipe is incremented by 1 octet.
<           if (!isLost)
<             {
<               size += item->m_packet->GetSize ();
<             }
<           // (b) If S1 <= HighRxt: Pipe is incremented by 1 octet.
<           // (NOTE: we use the m_retrans flag instead of keeping and updating
<           // another variable). Only if the item is not marked as lost
<           else if (item->m_retrans)
<             {
<               size += item->m_packet->GetSize ();
<             }
< 
<           if (isLost)
<             {
<               lostOut += item->m_packet->GetSize ();
<             }
<         }
<       else
<         {
<           sackedOut += item->m_packet->GetSize ();
<         }
< 
<       if (item->m_retrans)
<         {
<           retrans += item->m_packet->GetSize ();
<         }
<       beginOfCurrentPkt += item->m_packet->GetSize ();
<     }
< 
<   NS_ASSERT_MSG(lostOut == m_lostOut, "Lost counted: " << lostOut << " " <<
<                 m_lostOut << "\n" << *this);
<   NS_ASSERT_MSG(retrans == m_retrans, "Retrans Counted: " << retrans << " " <<
<                 m_retrans << "\n" << *this);
<   NS_ASSERT_MSG(sackedOut == m_sackedOut, "Sacked counted: " << sackedOut <<
<                 " " << m_sackedOut << *this);
<   NS_ASSERT_MSG(totalSize == m_sentSize,
<                 "Sent size counted: " << totalSize << " " << m_sentSize << *this);
< 
<   return size;
< }
< 
< bool
< TcpTxBuffer::IsLostRFC (const SequenceNumber32 &seq, const PacketList::const_iterator &segment) const
< {
<   NS_LOG_FUNCTION (this << seq);
<   uint32_t count = 0;
<   uint32_t bytes = 0;
<   PacketList::const_iterator it;
<   TcpTxItem *item;
<   Ptr<const Packet> current;
<   SequenceNumber32 beginOfCurrentPacket = seq;
< 
<   if ((*segment)->m_sacked == true)
<     {
<       return false;
<     }
< 
<   // From RFC 6675:
<   // > The routine returns true when either dupThresh discontiguous SACKed
<   // > sequences have arrived above 'seq' or more than (dupThresh - 1) * SMSS bytes
<   // > with sequence numbers greater than 'SeqNum' have been SACKed.  Otherwise, the
<   // > routine returns false.
<   for (it = segment; it != m_sentList.end (); ++it)
<     {
<       item = *it;
<       current = item->m_packet;
< 
<       if (item->m_sacked)
<         {
<           NS_LOG_INFO ("Segment " << *item <<
<                        " found to be SACKed while checking for " << seq);
<           ++count;
<           bytes += current->GetSize ();
<           if ((count >= m_dupAckThresh) || (bytes > (m_dupAckThresh-1) * m_segmentSize))
<             {
<               NS_LOG_INFO ("seq=" << seq << " is lost because of 3 sacked blocks ahead");
<               return true;
<             }
<         }
< 
<       if (beginOfCurrentPacket >= m_highestSack.second)
<         {
<           if (item->m_lost && !item->m_retrans)
<             return true;
< 
<           NS_LOG_INFO ("seq=" << seq << " is not lost because there are no sacked segment ahead");
<           return false;
<         }
< 
<       beginOfCurrentPacket += current->GetSize ();
<     }
<   if (it == m_highestSack.first)
<     {
<       NS_LOG_INFO ("seq=" << seq << " is not lost because there are no sacked segment ahead " << m_highestSack.second);
<     }
<   return false;
< }
< 
< void
< TcpTxBuffer::ResetRenoSack ()
< {
<   NS_LOG_FUNCTION (this);
< 
<   m_sackedOut = 0;
<   for (auto it = m_sentList.begin (); it != m_sentList.end (); ++it)
<     {
<       (*it)->m_sacked = false;
<     }
< 
<   m_highestSack = std::make_pair (m_sentList.end (), SequenceNumber32 (0));
< }
< 
< void
< TcpTxBuffer::ResetSentList ()
< {
<   NS_LOG_FUNCTION (this);
<   TcpTxItem *item;
< 
<   // Keep the head items; they will then marked as lost
<   while (m_sentList.size () > 0)
<     {
<       item = m_sentList.back ();
<       item->m_retrans = item->m_sacked = item->m_lost = false;
<       m_appList.push_front (item);
<       m_sentList.pop_back ();
<     }
< 
<   m_sentSize = 0;
<   m_lostOut = 0;
<   m_retrans = 0;
<   m_sackedOut = 0;
<   m_highestSack = std::make_pair (m_sentList.end (), SequenceNumber32 (0));
< }
< 
< void
< TcpTxBuffer::ResetLastSegmentSent ()
< {
<   NS_LOG_FUNCTION (this);
<   if (!m_sentList.empty ())
<     {
<       TcpTxItem *item = m_sentList.back ();
< 
<       m_sentList.pop_back ();
<       m_sentSize -= item->m_packet->GetSize ();
<       if (item->m_retrans)
<         {
<           m_retrans -= item->m_packet->GetSize ();
<         }
<       m_appList.insert (m_appList.begin (), item);
<     }
<   ConsistencyCheck ();
< }
< 
< void
< TcpTxBuffer::SetSentListLost (bool resetSack)
< {
<   NS_LOG_FUNCTION (this);
<   m_retrans = 0;
< 
<   if (resetSack)
<     {
<       m_sackedOut = 0;
<       m_lostOut = m_sentSize;
<       m_highestSack = std::make_pair (m_sentList.end (), SequenceNumber32 (0));
<     }
<   else
<     {
<       m_lostOut = 0;
<     }
< 
<   for (auto it = m_sentList.begin (); it != m_sentList.end (); ++it)
<     {
<       if (resetSack)
<         {
<           (*it)->m_sacked = false;
<           (*it)->m_lost = true;
<         }
<       else
<         {
<           if ((*it)->m_lost)
<             {
<               // Have to increment it because we set it to 0 at line 1133
<               m_lostOut += (*it)->m_packet->GetSize ();
<             }
<           else if (!(*it)->m_sacked)
<             {
<               // Packet is not marked lost, nor is sacked. Then it becomes lost.
<               (*it)->m_lost = true;
<               m_lostOut += (*it)->m_packet->GetSize ();
<             }
<         }
< 
<       (*it)->m_retrans = false;
<     }
< 
<   NS_LOG_INFO ("Set sent list lost, status: " << *this);
<   NS_ASSERT_MSG (m_sentSize >= m_sackedOut + m_lostOut, *this);
<   ConsistencyCheck ();
< }
< 
< bool
< TcpTxBuffer::IsHeadRetransmitted () const
< {
<   NS_LOG_FUNCTION (this);
< 
<   if (m_sentSize == 0)
<     {
<       return false;
<     }
< 
<   return m_sentList.front ()->m_retrans;
< }
< 
< void
< TcpTxBuffer::DeleteRetransmittedFlagFromHead ()
< {
<   NS_LOG_FUNCTION (this);
< 
<   if (m_sentSize == 0)
<     {
<       return;
<     }
< 
<   if (m_sentList.front ()->m_retrans)
<     {
<       m_sentList.front ()->m_retrans = false;
<       m_retrans -= m_sentList.front ()->m_packet->GetSize ();
<     }
<   ConsistencyCheck ();
< }
< 
< void
< TcpTxBuffer::MarkHeadAsLost ()
< {
<   if (m_sentList.size () > 0)
<     {
<       // If the head is sacked (reneging by the receiver the previously sent
<       // information) we revert the sacked flag.
<       // A sacked head means that we should advance SND.UNA.. so it's an error.
<       if (m_sentList.front ()->m_sacked)
<         {
<           m_sentList.front ()->m_sacked = false;
<           m_sackedOut -= m_sentList.front ()->m_packet->GetSize ();
<         }
< 
<       if (m_sentList.front ()->m_retrans)
<         {
<           m_sentList.front ()->m_retrans = false;
<           m_retrans -= m_sentList.front ()->m_packet->GetSize ();
<         }
< 
<       if (! m_sentList.front()->m_lost)
<         {
<           m_sentList.front()->m_lost = true;
<           m_lostOut += m_sentList.front ()->m_packet->GetSize ();
<         }
<     }
<   ConsistencyCheck ();
< }
< 
< void
< TcpTxBuffer::AddRenoSack (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_ASSERT (m_sentList.size () > 1);
< 
<   m_renoSack = true;
< 
<   // We can _never_ SACK the head, so start from the second segment sent
<   auto it = ++m_sentList.begin ();
< 
<   // Find the "highest sacked" point, that is SND.UNA + m_sackedOut
<   while (it != m_sentList.end () && (*it)->m_sacked)
<     {
<       ++it;
<     }
< 
<   // Add to the sacked size the size of the first "not sacked" segment
<   if (it != m_sentList.end ())
<     {
<       (*it)->m_sacked = true;
<       m_sackedOut += (*it)->m_packet->GetSize ();
<       m_highestSack = std::make_pair (it, (*it)->m_startSeq);
<       NS_LOG_INFO ("Added a Reno SACK, status: " << *this);
<     }
<   else
<     {
<       NS_LOG_INFO ("Can't add a Reno SACK because we miss segments. This dupack"
<                    " should be arrived from spurious retransmissions");
<     }
< 
<   ConsistencyCheck ();
< }
< 
< void
< TcpTxBuffer::ConsistencyCheck () const
< {
<   static const bool enable = false;
< 
<   if (!enable)
<     {
<       return;
<     }
< 
<   uint32_t sacked = 0;
<   uint32_t lost = 0;
<   uint32_t retrans = 0;
< 
<   for (auto it = m_sentList.begin (); it != m_sentList.end (); ++it)
<     {
<       if ((*it)->m_sacked)
<         {
<           sacked += (*it)->m_packet->GetSize ();
<         }
<       if ((*it)->m_lost)
<         {
<           lost += (*it)->m_packet->GetSize ();
<         }
<       if ((*it)->m_retrans)
<         {
<           retrans += (*it)->m_packet->GetSize ();
<         }
<     }
< 
<   NS_ASSERT_MSG (sacked == m_sackedOut, "Counted SACK: " << sacked <<
<                  " stored SACK: " << m_sackedOut);
<   NS_ASSERT_MSG (lost == m_lostOut, " Counted lost: " << lost <<
<                  " stored lost: " << m_lostOut);
<   NS_ASSERT_MSG (retrans == m_retrans, " Counted retrans: " << retrans <<
<                  " stored retrans: " << m_retrans);
< }
< 
< std::ostream &
< operator<< (std::ostream & os, TcpTxItem const & item)
< {
<   item.Print (os);
<   return os;
< }
< 
< std::ostream &
< operator<< (std::ostream & os, TcpTxBuffer const & tcpTxBuf)
< {
<   TcpTxBuffer::PacketList::const_iterator it;
<   std::stringstream ss;
<   SequenceNumber32 beginOfCurrentPacket = tcpTxBuf.m_firstByteSeq;
<   uint32_t sentSize = 0, appSize = 0;
< 
<   Ptr<const Packet> p;
<   for (it = tcpTxBuf.m_sentList.begin (); it != tcpTxBuf.m_sentList.end (); ++it)
<     {
<       p = (*it)->GetPacket ();
<       ss << "{";
<       (*it)->Print (ss);
<       ss << "}";
<       sentSize += p->GetSize ();
<       beginOfCurrentPacket += p->GetSize ();
<     }
< 
<   for (it = tcpTxBuf.m_appList.begin (); it != tcpTxBuf.m_appList.end (); ++it)
<     {
<       appSize += (*it)->GetPacket ()->GetSize ();
<     }
< 
<   os << "Sent list: " << ss.str () << ", size = " << tcpTxBuf.m_sentList.size () <<
<     " Total size: " << tcpTxBuf.m_size <<
<     " m_firstByteSeq = " << tcpTxBuf.m_firstByteSeq <<
<     " m_sentSize = " << tcpTxBuf.m_sentSize <<
<     " m_retransOut = " << tcpTxBuf.m_retrans <<
<     " m_lostOut = " << tcpTxBuf.m_lostOut <<
<     " m_sackedOut = " << tcpTxBuf.m_sackedOut;
< 
<   NS_ASSERT (sentSize == tcpTxBuf.m_sentSize);
<   NS_ASSERT (tcpTxBuf.m_size - tcpTxBuf.m_sentSize == appSize);
<   return os;
---
>   NS_LOG_LOGIC ("size=" << m_size << " headSeq=" << m_firstByteSeq << " maxBuffer=" << m_maxBuffer
>                         <<" numPkts="<< m_data.size ());
>   NS_ASSERT (m_firstByteSeq == seq);
1458c256
< } // namespace ns3
---
> } // namepsace ns3
diff ../../NS3-WiGig/src/internet/model/tcp-tx-buffer.h ../../ns-3-dev/src/internet/model/tcp-tx-buffer.h
3,4c3
<  * Copyright (c) 2010-2015 Adrian Sai-wah Tam
<  * Copyright (c) 2016 Natale Patriciello <natale.patriciello@gmail.com>
---
>  * Copyright (c) 2010 Adrian Sai-wah Tam
19c18
<  * Original author: Adrian Sai-wah Tam <adrian.sw.tam@gmail.com>
---
>  * Author: Adrian Sai-wah Tam <adrian.sw.tam@gmail.com>
25c24
< #include "ns3/object.h"
---
> #include <list>
26a26,27
> #include "ns3/trace-source-accessor.h"
> #include "ns3/object.h"
28,29c29
< #include "ns3/tcp-option-sack.h"
< #include "ns3/tcp-tx-item.h"
---
> #include "ns3/ptr.h"
37,120c37,38
<  * \brief Tcp sender buffer
<  *
<  * The class keeps track of all data that the application wishes to transmit to
<  * the other end. When the data is acknowledged, it is removed from the buffer.
<  * The buffer has a maximum size, and data is not saved if the amount exceeds
<  * the limit. Packets can be added to the class through the method Add(). An
<  * important thing to remember is that all the data managed is strictly
<  * sequential. It can be divided into blocks, but all the data follow a strict
<  * ordering. That order is managed through SequenceNumber.
<  *
<  * In other words, this buffer contains numbered bytes (e.g., 1,2,3), and the
<  * class is allowed to return only ordered (using "<" as operator) subsets
<  * (e.g. 1,2 or 2,3 or 1,2,3).
<  *
<  * The data structure underlying this is composed by two distinct packet lists.
<  * The first (SentList) is initially empty, and it contains the packets
<  * returned by the method CopyFromSequence. The second (AppList) is initially
<  * empty, and it contains the packets coming from the applications, but that
<  * are not transmitted yet as segments. To discover how the chunks are managed
<  * and retrieved from these lists, check CopyFromSequence documentation.
<  *
<  * The head of the data is represented by m_firstByteSeq, and it is returned by
<  * HeadSequence(). The last byte is returned by TailSequence(). In this class,
<  * we also store the size (in bytes) of the packets inside the SentList in the
<  * variable m_sentSize.
<  *
<  * SACK management
<  * ---------------
<  *
<  * The SACK information is usually saved in a data structure referred as
<  * scoreboard. In this implementation, the scoreboard is developed on top of
<  * the existing classes. In particular, instead of keeping raw pointers to
<  * packets in TcpTxBuffer we added the capability to store some flags
<  * associated with every segment sent. This is done through the use of the
<  * class TcpTxItem: instead of storing a list of packets, we store a list of
<  * TcpTxItem. Each item has different flags (check the corresponding
<  * documentation) and maintaining the scoreboard is a matter of travelling the
<  * list and set the SACK flag on the corresponding segment sent.
<  *
<  * Item properties
<  * ---------------
<  *
<  * An item (that represent a segment in flight) is not considered in flight
<  * anymore when it is marked lost or sacked. A sacked item represents an
<  * item which is received by the other end, but it is still impossible
<  * to delete from the list because other pieces are missing at the other
<  * end. A lost item never reached the other end, and retransmission is probably
<  * needed. Other properties are retransmitted, that indicates if an item was
<  * retransmitted, and the sequence number of the first byte of the packet. When
<  * a segment is sent for the first time, only the sequence number is set, and
<  * all the remaining properties are set to false. If an item is explicitly
<  * sacked by the receiver, we mark it as such. Each time we receive updated
<  * sack information from the other end, we perform a check to evaluate the
<  * segments that can be lost (\see UpdateLostCount), and we set the flags
<  * accordingly.
<  *
<  * Management of bytes in flight
<  * -----------------------------
<  *
<  * Since this class manages all the output segments and the scoreboard, we can
<  * do calculations about the number of bytes in flights. Earlier versions of
<  * this class used algorithms copied from RFC 6675. They were inefficient
<  * because they required a complete walk into the list of sent segments each
<  * time a simple question, such as "Is this sequence lost?" or "How many bytes
<  * are in flight?". Therefore, the class has been updated keeping in
<  * consideration the RFCs (including RFC 4898) and the Linux operating
<  * system. As a reference, we kept the older methods for calculating the
<  * bytes in flight and if a segment is lost, renaming them as "RFC" version
<  * of the methods. To have a look how the calculations are made, please see
<  * BytesInFlight method.
<  *
<  * Lost segments
<  * -------------
<  *
<  * After the sender receives a new SACK block, it updates the amount of segment
<  * that it considers as lost, following the specifications made in RFC 6675
<  * (for more detail please see the method UpdateLostCount). In case of SACKless
<  * connection, the TcpSocketImplementation should provide hints through
<  * the MarkHeadAsLost and AddRenoSack methods.
<  *
<  * \see BytesInFlight
<  * \see Size
<  * \see SizeFromSequence
<  * \see CopyFromSequence
---
>  * \brief class for keeping the data sent by the application to the TCP socket, i.e.
>  *        the sending buffer.
140c58
<    * \brief Get the sequence number of the buffer head
---
>    * Returns the first byte's sequence number
146c64
<    * \brief Get the sequence number of the buffer tail (plus one)
---
>    * Returns the last byte's sequence number + 1
152c70
<    * \brief Returns total number of bytes in this buffer
---
>    * Returns total number of bytes in this Tx buffer
158c76
<    * \brief Get the maximum buffer size
---
>    * Returns the Tx window size
164c82
<    * \brief Set the maximum buffer size
---
>    * Set the Tx window size
170c88
<    * \brief Returns the available capacity of this buffer
---
>    * Returns the available capacity in this Tx window
176,213c94
<    * \brief Set the DupAckThresh
<    * \param dupAckThresh the threshold
<    */
<   void SetDupAckThresh (uint32_t dupAckThresh);
< 
<   /**
<    * \brief Set the segment size
<    * \param segmentSize the segment size
<    */
<   void SetSegmentSize (uint32_t segmentSize);
< 
<   /**
<    * \brief Return the number of segments in the sent list that
<    * have been transmitted more than once, without acknowledgment.
<    *
<    * This method is to support the retransmits count for determining PipeSize
<    * in NewReno-style TCP.
<    *
<    * \returns number of segments that have been transmitted more than once, without acknowledgment
<    */
<   uint32_t GetRetransmitsCount (void) const;
< 
<   /**
<    * \brief Get the number of segments that we believe are lost in the network
<    *
<    * It is calculated in UpdateLostCount.
<    * \return the number of lost segment
<    */
<   uint32_t GetLost (void) const;
< 
<   /**
<    * \brief Get the number of segments that have been explicitly sacked by the receiver.
<    * \return the number of sacked segment.
<    */
<   uint32_t GetSacked (void) const;
< 
<   /**
<    * \brief Append a data packet to the end of the buffer
---
>    * Append a data packet to the end of the buffer
221,222c102
<    * \brief Returns the number of bytes from the buffer in the range [seq, tailSequence)
<    *
---
>    * Returns the number of bytes from the buffer in the range [seq, tailSequence)
229,242c109
<    * \brief Copy data from the range [seq, seq+numBytes) into a packet
<    *
<    * In the following, we refer to the block [seq, seq+numBytes) simply as "block".
<    * We check the boundary of the block, and divide the possibilities in three
<    * cases:
<    *
<    * - the block have already been transmitted (managed in GetTransmittedSegment)
<    * - the block have not been transmitted yet (managed in GetNewSegment)
<    *
<    * The last case is when the block is partially transmitted and partially
<    * not transmitted. We trick this case by requesting the portion not transmitted
<    * from GetNewSegment, and then calling GetTransmittedSegment with the full
<    * block range.
<    *
---
>    * Copy data of size numBytes into a packet, data from the range [seq, seq+numBytes)
245,246c112
<    * \returns a pointer to the TcpTxItem that corresponds to what requested.
<    * Please do not delete the pointer, nor modify Packet data or sequence numbers.
---
>    * \returns a packet
248c114
<   TcpTxItem* CopyFromSequence (uint32_t numBytes, const SequenceNumber32& seq);
---
>   Ptr<Packet> CopyFromSequence (uint32_t numBytes, const SequenceNumber32& seq);
251,253c117
<    * \brief Set the head sequence of the buffer
<    *
<    * Set the head (m_firstByteSeq) to seq. Supposed to be called only when the
---
>    * Set the m_firstByteSeq to seq. Supposed to be called only when the
260,363c124
<    * \brief Discard data up to but not including this sequence number.
<    *
<    * \param seq The first sequence number to maintain after discarding all the
<    * previous sequences.
<    * \param beforeDelCb Callback invoked, if it is not null, before the deletion
<    * of an Item (because it was, probably, ACKed)
<    */
<   void DiscardUpTo (const SequenceNumber32& seq,
<                     const Callback<void, TcpTxItem *> &beforeDelCb = m_nullCb);
< 
<   /**
<    * \brief Update the scoreboard
<    * \param list list of SACKed blocks
<    * \param sackedCb Callback invoked, if it is not null, when a segment has been
<    * SACKed by the receiver.
<    * \returns the number of bytes newly sacked by the list of blocks
<    */
<   uint32_t Update (const TcpOptionSack::SackList &list,
<                    const Callback<void, TcpTxItem *> &sackedCb = m_nullCb);
< 
<   /**
<    * \brief Check if a segment is lost
<    *
<    * It does a check on the flags to determine if the segment has to be considered
<    * as lost for an external class
<    *
<    * \param seq sequence to check
<    * \param dupThresh dupAck threshold
<    * \param segmentSize segment size
<    * \return true if the sequence is supposed to be lost, false otherwise
<    */
<   bool IsLost (const SequenceNumber32 &seq) const;
< 
<   /**
<    * \brief Get the next sequence number to transmit, according to RFC 6675
<    *
<    * \param seq Next sequence number to transmit, based on the scoreboard information
<    * \param isRecovery true if the socket congestion state is in recovery mode
<    * \return true is seq is updated, false otherwise
<    */
<   bool NextSeg (SequenceNumber32 *seq, bool isRecovery) const;
< 
<   /**
<    * \brief Return total bytes in flight
<    *
<    * Counting packets in flight is pretty simple:
<    *
<    * \f$in_flight = sentSize - leftOut + retrans\f$
<    *
<    * sentsize is SND.NXT-SND.UNA, retrans is the number of retransmitted segments.
<    * leftOut is the number of segment that left the network without being ACKed:
<    *
<    * \f$leftOut = sacked_out + lost_out\f$
<    *
<    * To see how we define the lost packets, look at the method UpdateLostCount.
<    *
<    * \returns total bytes in flight
<    */
<   uint32_t BytesInFlight () const;
< 
<   /**
<    * \brief Set the entire sent list as lost (typically after an RTO)
<    *
<    * Used to set all the sent list as lost, so the bytes in flight is not counting
<    * them as in flight, but we will continue to use SACK information for
<    * recovering the timeout.
<    *
<    * Moreover, reset the retransmit flag for every item.
<    * \param resetSack True if the function should reset the SACK flags.
<    */
<   void SetSentListLost (bool resetSack = false);
< 
<   /**
<    * \brief Check if the head is retransmitted
<    *
<    * \return true if the head is retransmitted, false in all other cases
<    * (including no segment sent)
<    */
<   bool IsHeadRetransmitted () const;
< 
<   /**
<    * \brief DeleteRetransmittedFlagFromHead
<    */
<   void DeleteRetransmittedFlagFromHead ();
< 
<   /**
<    * \brief Reset the sent list
<    *
<    */
<   void ResetSentList ();
< 
<   /**
<    * \brief Take the last segment sent and put it back into the un-sent list
<    * (at the beginning)
<    */
<   void ResetLastSegmentSent ();
< 
<   /**
<    * \brief Mark the head of the sent list as lost.
<    */
<   void MarkHeadAsLost ();
< 
<   /**
<    * \brief Emulate SACKs for SACKless connection: account for a new dupack.
---
>    * Discard data up to but not including this sequence number.
365,380c126
<    * The method walk the list of the sent segment until it finds a segment
<    * that was not accounted in the sackedOut count. The head will never
<    * be included. To reset the information added with this function (e.g.,
<    * after an RTO) please use ResetRenoSack.
<    *
<    * The method DiscardUpTo, when invoked, will make sure to properly clean any
<    * flag on the discarded item. As example, if the implementation discard an item
<    * that is marked as sacked, the sackedOut count is decreased accordingly.
<    */
<   void AddRenoSack ();
< 
<   /**
<    * \brief Reset the SACKs.
<    *
<    * Reset the Scoreboard from all SACK information. This method also works in
<    * case the SACKs are set by the Update method.
---
>    * \param seq The sequence number of the head byte
382c128
<   void ResetRenoSack ();
---
>   void DiscardUpTo (const SequenceNumber32& seq);
385,581c131,132
<   friend std::ostream & operator<< (std::ostream & os, TcpTxBuffer const & tcpTxBuf);
< 
<   typedef std::list<TcpTxItem*> PacketList; //!< container for data stored in the buffer
< 
<   /**
<    * \brief Update the lost count
<    *
<    * Reset lost to 0, then walk the sent list looking for lost segments.
<    * We have two possible algorithms for detecting lost packets:
<    *
<    * - RFC 6675 algorithm, which says that if more than "Dupack thresh" (e.g., 3)
<    * sacked segments above the sequence, then we can consider the sequence lost;
<    * - NewReno (RFC6582): in Recovery we assume that one segment is lost
<    * (classic Reno). While we are in Recovery and a partial ACK arrives,
<    * we assume that one more packet is lost (NewReno).
<    *
<    * The {New}Reno cases, for now, are managed in TcpSocketBase through the
<    * call to MarkHeadAsLost.
<    * This function is, therefore, called after a SACK option has been received,
<    * and updates the lost count. It can be probably optimized by not walking
<    * the entire list, but a subset.
<    *
<    */
<   void UpdateLostCount ();
< 
<   /**
<    * \brief Remove the size specified from the lostOut, retrans, sacked count
<    *
<    * Used only in DiscardUpTo
<    *
<    * \param item Item that will be discarded
<    * \param size size to remove (can be different from pktSize because of fragmentation)
<    */
<   void RemoveFromCounts (TcpTxItem *item, uint32_t size);
< 
<   /**
<    * \brief Decide if a segment is lost based on RFC 6675 algorithm.
<    * \param seq Sequence
<    * \param segment Iterator to the sequence
<    * \return true if seq is lost per RFC 6675, false otherwise
<    */
<   bool IsLostRFC (const SequenceNumber32 &seq, const PacketList::const_iterator &segment) const;
< 
<   /**
<    * \brief Calculate the number of bytes in flight per RFC 6675
<    * \return the number of bytes in flight
<    */
<   uint32_t BytesInFlightRFC () const;
< 
<   /**
<    * \brief Get a block of data not transmitted yet and move it into SentList
<    *
<    * If the block is not yet transmitted, hopefully, seq is exactly the sequence
<    * number of the first byte of the first packet inside AppList. We extract
<    * the block from AppList and move it into the SentList, before returning the
<    * block itself. We manage possible fragmentation (or merges) inside AppList
<    * through GetPacketFromList.
<    *
<    * \see GetPacketFromList
<    * \param numBytes number of bytes to copy
<    *
<    * \return the item that contains the right packet
<    */
<   TcpTxItem* GetNewSegment (uint32_t numBytes);
< 
<   /**
<    * \brief Get a block of data previously transmitted
<    *
<    * This is clearly a retransmission, and if everything is going well,
<    * the block requested is matching perfectly with another one requested
<    * in the past. If not, fragmentation or merge are required. We manage
<    * both inside GetPacketFromList.
<    *
<    * \see GetPacketFromList
<    *
<    * \param numBytes number of bytes to copy
<    * \param seq sequence requested
<    * \returns the item that contains the right packet
<    */
<   TcpTxItem* GetTransmittedSegment (uint32_t numBytes, const SequenceNumber32 &seq);
< 
<   /**
<    * \brief Get a block (which is returned as Packet) from a list
<    *
<    * This function extract a block [requestedSeq,numBytes) from the list, which
<    * starts at startingSeq.
<    *
<    * The cases we need to manage are two, and they are depicted in the following
<    * image:
<    *
<    *\verbatim
<                        |------|     |----|     |----|
<                 list = |      | --> |    | --> |    |
<                        |------|     |----|     |----|
< 
<                        ^      ^
<                        | ^ ^  |         (1)
<                      seq | |  seq + numBytes
<                          | |
<                          | |
<                       seq   seq + numBytes     (2)
<    \endverbatim
<    *
<    * The case 1 is easy to manage: the requested block is exactly a packet
<    * already stored. If one value (seq or seq + numBytes) does not align
<    * to a packet boundary, or when both values does not align (case 2), it is
<    * a bit more complex.
<    *
<    * Basically, we have two possible operations:
<    *
<    *  - fragment : split an existing packet in two
<    *  - merge    : merge two existing packets in one
<    *
<    * and we reduce case (2) to case (1) through sequentially applying fragment
<    * or merge. For instance:
<    *
<    *\verbatim
<       |------|
<       |      |
<       |------|
< 
<       ^ ^  ^ ^
<       | |  | |
<   start |  | |
<         |  | end
<        seq |
<            seq + numBytes
<    \endverbatim
<    *
<    * To reduce to case (1), we need to perform two fragment operations:
<    *
<    * - fragment (start, seq)
<    * - fragment (seq + numBytes, end)
<    *
<    * After these operations, the requested block is exactly the resulting packet.
<    * Merge operation is required when the requested block span over two (or more)
<    * existing packets.
<    *
<    * While this could be extremely slow in the worst possible scenario (one big
<    * packet which is split in small packets for transmission, and merged for
<    * re-transmission) that scenario is unlikely during a TCP transmission (since
<    * MSS can change, but it is stable, and retransmissions do not happen for
<    * each segment).
<    *
<    * \param list List to extract block from
<    * \param startingSeq Starting sequence of the list
<    * \param numBytes Bytes to extract, starting from requestedSeq
<    * \param requestedSeq Requested sequence
<    * \param listEdited output parameter which indicates if the list has been edited
<    * \return the item that contains the right packet
<    */
<   TcpTxItem* GetPacketFromList (PacketList &list, const SequenceNumber32 &startingSeq,
<                                 uint32_t numBytes, const SequenceNumber32 &requestedSeq,
<                                 bool *listEdited = nullptr) const;
< 
<   /**
<    * \brief Merge two TcpTxItem
<    *
<    * Merge t2 in t1. It consists in copying the lastSent field if t2 is more
<    * recent than t1. Retransmitted field is copied only if it set in t2 but not
<    * in t1. Sacked is copied only if it is true in both items.
<    *
<    * \param t1 first item
<    * \param t2 second item
<    */
<   void MergeItems (TcpTxItem *t1, TcpTxItem *t2) const;
< 
<   /**
<    * \brief Split one TcpTxItem
<    *
<    * Move "size" bytes from t2 into t1, copying all the fields.
<    * Adjust the starting sequence of each item.
<    *
<    * \param t1 first item
<    * \param t2 second item
<    * \param size Size to split
<    */
<   void SplitItems (TcpTxItem *t1, TcpTxItem *t2, uint32_t size) const;
< 
<   /**
<    * \brief Check if the values of sacked, lost, retrans, are in sync
<    * with the sent list.
<    */
<   void ConsistencyCheck () const;
< 
<   /**
<    * \brief Find the highest SACK byte
<    * \return a pair with the highest byte and an iterator inside m_sentList
<    */
<   std::pair <TcpTxBuffer::PacketList::const_iterator, SequenceNumber32>
<   FindHighestSacked () const;
< 
<   PacketList m_appList;  //!< Buffer for application data
<   PacketList m_sentList; //!< Buffer for sent (but not acked) data
<   uint32_t m_maxBuffer;  //!< Max number of data bytes in buffer (SND.WND)
<   uint32_t m_size;       //!< Size of all data in this buffer
<   uint32_t m_sentSize;   //!< Size of sent (and not discarded) segments
---
>   /// container for data stored in the buffer
>   typedef std::list<Ptr<Packet> >::iterator BufIterator;
584,594c135,137
<   std::pair <PacketList::const_iterator, SequenceNumber32> m_highestSack; //!< Highest SACK byte
< 
<   uint32_t m_lostOut   {0}; //!< Number of lost bytes
<   uint32_t m_sackedOut {0}; //!< Number of sacked bytes
<   uint32_t m_retrans   {0}; //!< Number of retransmitted bytes
< 
<   uint32_t m_dupAckThresh {0}; //!< Duplicate Ack threshold from TcpSocketBase
<   uint32_t m_segmentSize {0}; //!< Segment size from TcpSocketBase
<   bool     m_renoSack {false}; //!< Indicates if AddRenoSack was called
< 
<   static Callback<void, TcpTxItem *> m_nullCb; //!< Null callback for an item
---
>   uint32_t m_size;                              //!< Number of data bytes
>   uint32_t m_maxBuffer;                         //!< Max number of data bytes in buffer (SND.WND)
>   std::list<Ptr<Packet> > m_data;               //!< Corresponding data (may be null)
597,613c140
< /**
<  * \brief Output operator.
<  * \param os The output stream.
<  * \param tcpTxBuf the TcpTxBuffer to print.
<  * \returns The output stream.
<  */
< std::ostream & operator<< (std::ostream & os, TcpTxBuffer const & tcpTxBuf);
< 
< /**
<  * \brief Output operator.
<  * \param os The output stream.
<  * \param item the item to print.
<  * \returns The output stream.
<  */
< std::ostream & operator<< (std::ostream & os, TcpTxItem const & item);
< 
< } // namespace ns3
---
> } // namepsace ns3
Only in ../../NS3-WiGig/src/internet/model: tcp-tx-item.cc
Only in ../../NS3-WiGig/src/internet/model: tcp-tx-item.h
diff ../../NS3-WiGig/src/internet/model/tcp-vegas.cc ../../ns-3-dev/src/internet/model/tcp-vegas.cc
28,29c28
< #include "tcp-socket-state.h"
< 
---
> #include "ns3/tcp-socket-base.h"
207c206
<           targetCwnd = static_cast<uint32_t> (segCwnd * tmp);
---
>           targetCwnd = segCwnd * tmp;
237c236
<               TcpNewReno::SlowStart (tcb, segmentsAcked);
---
>               segmentsAcked = TcpNewReno::SlowStart (tcb, segmentsAcked);
278c277
<       TcpNewReno::SlowStart (tcb, segmentsAcked);
---
>       segmentsAcked = TcpNewReno::SlowStart (tcb, segmentsAcked);
diff ../../NS3-WiGig/src/internet/model/tcp-vegas.h ../../ns-3-dev/src/internet/model/tcp-vegas.h
30c30
< #include "tcp-congestion-ops.h"
---
> #include "ns3/tcp-congestion-ops.h"
33,34d32
< 
< class TcpSocketState;
diff ../../NS3-WiGig/src/internet/model/tcp-veno.cc ../../ns-3-dev/src/internet/model/tcp-veno.cc
28,29c28
< #include "tcp-socket-state.h"
< 
---
> #include "ns3/tcp-socket-base.h"
166c165
<   targetCwnd = static_cast<uint32_t> (segCwnd * tmp);
---
>   targetCwnd = segCwnd * tmp;
196c195
<           TcpNewReno::SlowStart (tcb, segmentsAcked);
---
>           segmentsAcked = TcpNewReno::SlowStart (tcb, segmentsAcked);
diff ../../NS3-WiGig/src/internet/model/tcp-veno.h ../../ns-3-dev/src/internet/model/tcp-veno.h
30c30
< #include "tcp-congestion-ops.h"
---
> #include "ns3/tcp-congestion-ops.h"
33,34d32
< 
< class TcpSocketState;
diff ../../NS3-WiGig/src/internet/model/tcp-westwood.cc ../../ns-3-dev/src/internet/model/tcp-westwood.cc
71a72
>   m_minRtt (Time (0)),
82a84
>   m_minRtt (Time (0)),
108a111,125
>   // Update minRtt
>   if (m_minRtt.IsZero ())
>     {
>       m_minRtt = rtt;
>     }
>   else
>     {
>       if (rtt < m_minRtt)
>         {
>           m_minRtt = rtt;
>         }
>     }
> 
>   NS_LOG_LOGIC ("MinRtt: " << m_minRtt.GetMilliSeconds () << "ms");
> 
164c181
<   NS_UNUSED (bytesInFlight);
---
>   (void) bytesInFlight;
166,167c183,184
<                 tcb->m_minRtt << " ssthresh: " <<
<                 m_currentBW * static_cast<double> (tcb->m_minRtt.GetSeconds ()));
---
>                 m_minRtt << " ssthresh: " <<
>                 m_currentBW * static_cast<double> (m_minRtt.GetSeconds ()));
170c187
<                    uint32_t (m_currentBW * static_cast<double> (tcb->m_minRtt.GetSeconds ())));
---
>                    uint32_t (m_currentBW * static_cast<double> (m_minRtt.GetSeconds ())));
diff ../../NS3-WiGig/src/internet/model/tcp-westwood.h ../../ns-3-dev/src/internet/model/tcp-westwood.h
37d36
< #include "ns3/tcp-recovery-ops.h"
40d38
< #include "ns3/event-id.h"
129a128
>   Time                   m_minRtt;                 //!< Minimum RTT
133c132
<   uint32_t               m_ackedSegments;          //!< The number of segments ACKed between RTTs
---
>   int                    m_ackedSegments;          //!< The number of segments ACKed between RTTs
diff ../../NS3-WiGig/src/internet/model/tcp-yeah.cc ../../ns-3-dev/src/internet/model/tcp-yeah.cc
27a28
> #include "ns3/tcp-socket-base.h"
89c90
<     m_stcp (nullptr),
---
>     m_stcp (0),
102c103
<   m_stcp->SetAttribute ("AIFactor", static_cast<UintegerValue> (m_stcpAiFactor));
---
>   m_stcp->SetAttribute ("AIFactor", (UintegerValue) m_stcpAiFactor);
205c206
<       TcpNewReno::SlowStart (tcb, segmentsAcked);
---
>       segmentsAcked = TcpNewReno::SlowStart (tcb, segmentsAcked);
246c247
<           uint32_t queue = static_cast<uint32_t> (bw * rttQueue.GetSeconds ());
---
>           uint32_t queue = bw * rttQueue.GetSeconds ();
274c275
<                   m_renoCount = std::max (segCwnd >> 1, static_cast<uint32_t> (2));
---
>                   m_renoCount = std::max (segCwnd >> 1, (uint32_t) 2);
328c329
<       reduction = std::min (reduction, std::max (segBytesInFlight >> 1, 2U));
---
>       reduction = std::min (reduction, std::max (segBytesInFlight >> 1, (uint32_t) 2));
333c334
<       reduction = std::max (segBytesInFlight >> 1, static_cast<uint32_t> (2));
---
>       reduction = std::max (segBytesInFlight >> 1, (uint32_t) 2);
339c340
<   m_renoCount = std::max (m_renoCount >> 1, static_cast<uint32_t> (2));
---
>   m_renoCount = std::max (m_renoCount >> 1, (uint32_t) 2);
341,344c342
<   // Allow, at least, 2 segment to go out
<   uint32_t ret = std::max (bytesInFlight - (reduction * tcb->m_segmentSize),
<                            2U * tcb->m_segmentSize);
<   return ret;
---
>   return (bytesInFlight - (reduction * tcb->m_segmentSize));
diff ../../NS3-WiGig/src/internet/model/tcp-yeah.h ../../ns-3-dev/src/internet/model/tcp-yeah.h
29a30
> #include "ns3/tcp-congestion-ops.h"
31d31
< #include "ns3/tcp-recovery-ops.h"
diff ../../NS3-WiGig/src/internet/model/udp-l4-protocol.cc ../../ns-3-dev/src/internet/model/udp-l4-protocol.cc
85c85
<  * This method is called by AggregateObject and completes the aggregation
---
>  * This method is called by AddAgregate and completes the aggregation
176c176
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION_NOARGS ();
188c188
< UdpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port)
---
> UdpL4Protocol::Allocate (uint16_t port)
190,191c190,191
<   NS_LOG_FUNCTION (this << boundNetDevice << port);
<   return m_endPoints->Allocate (boundNetDevice, port);
---
>   NS_LOG_FUNCTION (this << port);
>   return m_endPoints->Allocate (port);
195c195
< UdpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port)
---
> UdpL4Protocol::Allocate (Ipv4Address address, uint16_t port)
197,198c197,198
<   NS_LOG_FUNCTION (this << boundNetDevice << address << port);
<   return m_endPoints->Allocate (boundNetDevice, address, port);
---
>   NS_LOG_FUNCTION (this << address << port);
>   return m_endPoints->Allocate (address, port);
201,202c201
< UdpL4Protocol::Allocate (Ptr<NetDevice> boundNetDevice,
<                          Ipv4Address localAddress, uint16_t localPort,
---
> UdpL4Protocol::Allocate (Ipv4Address localAddress, uint16_t localPort,
205,207c204,205
<   NS_LOG_FUNCTION (this << boundNetDevice << localAddress << localPort << peerAddress << peerPort);
<   return m_endPoints->Allocate (boundNetDevice,
<                                 localAddress, localPort,
---
>   NS_LOG_FUNCTION (this << localAddress << localPort << peerAddress << peerPort);
>   return m_endPoints->Allocate (localAddress, localPort,
221c219
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION_NOARGS ();
233c231
< UdpL4Protocol::Allocate6 (Ptr<NetDevice> boundNetDevice, uint16_t port)
---
> UdpL4Protocol::Allocate6 (uint16_t port)
235,236c233,234
<   NS_LOG_FUNCTION (this << boundNetDevice << port);
<   return m_endPoints6->Allocate (boundNetDevice, port);
---
>   NS_LOG_FUNCTION (this << port);
>   return m_endPoints6->Allocate (port);
240c238
< UdpL4Protocol::Allocate6 (Ptr<NetDevice> boundNetDevice, Ipv6Address address, uint16_t port)
---
> UdpL4Protocol::Allocate6 (Ipv6Address address, uint16_t port)
242,243c240,241
<   NS_LOG_FUNCTION (this << boundNetDevice << address << port);
<   return m_endPoints6->Allocate (boundNetDevice, address, port);
---
>   NS_LOG_FUNCTION (this << address << port);
>   return m_endPoints6->Allocate (address, port);
246,253c244,249
< UdpL4Protocol::Allocate6 (Ptr<NetDevice> boundNetDevice,
<                           Ipv6Address localAddress, uint16_t localPort,
<                           Ipv6Address peerAddress, uint16_t peerPort)
< {
<   NS_LOG_FUNCTION (this << boundNetDevice << localAddress << localPort << peerAddress << peerPort);
<   return m_endPoints6->Allocate (boundNetDevice,
<                                  localAddress, localPort,
<                                  peerAddress, peerPort);
---
> UdpL4Protocol::Allocate6 (Ipv6Address localAddress, uint16_t localPort,
>                          Ipv6Address peerAddress, uint16_t peerPort)
> {
>   NS_LOG_FUNCTION (this << localAddress << localPort << peerAddress << peerPort);
>   return m_endPoints6->Allocate (localAddress, localPort,
>                                 peerAddress, peerPort);
diff ../../NS3-WiGig/src/internet/model/udp-l4-protocol.h ../../ns-3-dev/src/internet/model/udp-l4-protocol.h
39d38
< class NetDevice;
100d98
<    * \param boundNetDevice Bound NetDevice (if any)
104c102
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, uint16_t port);
---
>   Ipv4EndPoint *Allocate (uint16_t port);
107d104
<    * \param boundNetDevice Bound NetDevice (if any)
112c109
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice, Ipv4Address address, uint16_t port);
---
>   Ipv4EndPoint *Allocate (Ipv4Address address, uint16_t port);
115d111
<    * \param boundNetDevice Bound NetDevice (if any)
122,123c118
<   Ipv4EndPoint *Allocate (Ptr<NetDevice> boundNetDevice,
<                           Ipv4Address localAddress, uint16_t localPort,
---
>   Ipv4EndPoint *Allocate (Ipv4Address localAddress, uint16_t localPort,
139d133
<    * \param boundNetDevice Bound NetDevice (if any)
143c137
<   Ipv6EndPoint *Allocate6 (Ptr<NetDevice> boundNetDevice, uint16_t port);
---
>   Ipv6EndPoint *Allocate6 (uint16_t port);
146d139
<    * \param boundNetDevice Bound NetDevice (if any)
151c144
<   Ipv6EndPoint *Allocate6 (Ptr<NetDevice> boundNetDevice, Ipv6Address address, uint16_t port);
---
>   Ipv6EndPoint *Allocate6 (Ipv6Address address, uint16_t port);
154d146
<    * \param boundNetDevice Bound NetDevice (if any)
161,162c153
<   Ipv6EndPoint *Allocate6 (Ptr<NetDevice> boundNetDevice,
<                            Ipv6Address localAddress, uint16_t localPort,
---
>   Ipv6EndPoint *Allocate6 (Ipv6Address localAddress, uint16_t localPort,
diff ../../NS3-WiGig/src/internet/model/udp-socket-impl.cc ../../ns-3-dev/src/internet/model/udp-socket-impl.cc
236,239d235
<   if (m_boundnetdevice)
<     {
<       m_endPoint->BindToNetDevice (m_boundnetdevice);
<     }
248,251d243
<   if (m_boundnetdevice)
<     {
<       m_endPoint6->BindToNetDevice (m_boundnetdevice);
<     }
262c254
<       NS_ASSERT_MSG (m_endPoint == 0, "Endpoint already allocated.");
---
>       NS_ASSERT_MSG (m_endPoint == 0, "Endpoint already allocated (maybe you used BindToNetDevice before Bind).");
274c266
<           m_endPoint = m_udp->Allocate (GetBoundNetDevice (), port);
---
>           m_endPoint = m_udp->Allocate (port);
282c274
<           m_endPoint = m_udp->Allocate (GetBoundNetDevice (), ipv4, port);
---
>           m_endPoint = m_udp->Allocate (ipv4, port);
289,293d280
<       if (m_boundnetdevice)
<         {
<           m_endPoint->BindToNetDevice (m_boundnetdevice);
<         }
< 
297c284
<       NS_ASSERT_MSG (m_endPoint == 0, "Endpoint already allocated.");
---
>       NS_ASSERT_MSG (m_endPoint == 0, "Endpoint already allocated (maybe you used BindToNetDevice before Bind).");
308c295
<           m_endPoint6 = m_udp->Allocate6 (GetBoundNetDevice (), port);
---
>           m_endPoint6 = m_udp->Allocate6 (port);
316c303
<           m_endPoint6 = m_udp->Allocate6 (GetBoundNetDevice (), ipv6, port);
---
>           m_endPoint6 = m_udp->Allocate6 (ipv6, port);
323,327d309
<       if (m_boundnetdevice)
<         {
<           m_endPoint6->BindToNetDevice (m_boundnetdevice);
<         }
< 
333,341c315
<               if (m_boundnetdevice == 0)
<                 {
<                   ipv6l3->AddMulticastAddress (ipv6);
<                 }
<               else
<                 {
<                   uint32_t index = ipv6l3->GetInterfaceForDevice (m_boundnetdevice);
<                   ipv6l3->AddMulticastAddress (m_endPoint6->GetLocalAddress (), index);
<                 }
---
>               ipv6l3->AddMulticastAddress (ipv6);
571,572c545,551
< 
<   // Note that some systems will only send limited broadcast packets
---
>   //
>   // If dest is set to the limited broadcast address (all ones),
>   // convert it to send a copy of the packet out of every 
>   // interface as a subnet-directed broadcast.
>   // Exception:  if the interface has a /32 address, there is no
>   // valid subnet-directed broadcast, so send it as limited broadcast
>   // Note also that some systems will only send limited broadcast packets
573a553
>   //
595,599c575,596
<           NS_LOG_LOGIC ("Sending one copy from " << addri << " to " << dest);
<           m_udp->Send (p->Copy (), addri, dest,
<                        m_endPoint->GetLocalPort (), port);
<           NotifyDataSent (p->GetSize ());
<           NotifySend (GetTxAvailable ());
---
>           Ipv4Mask maski = iaddr.GetMask ();
>           if (maski == Ipv4Mask::GetOnes ())
>             {
>               // if the network mask is 255.255.255.255, do not convert dest
>               NS_LOG_LOGIC ("Sending one copy from " << addri << " to " << dest
>                                                      << " (mask is " << maski << ")");
>               m_udp->Send (p->Copy (), addri, dest,
>                            m_endPoint->GetLocalPort (), port);
>               NotifyDataSent (p->GetSize ());
>               NotifySend (GetTxAvailable ());
>             }
>           else
>             {
>               // Convert to subnet-directed broadcast
>               Ipv4Address bcast = addri.GetSubnetDirectedBroadcast (maski);
>               NS_LOG_LOGIC ("Sending one copy from " << addri << " to " << bcast
>                                                      << " (mask is " << maski << ")");
>               m_udp->Send (p->Copy (), addri, bcast,
>                            m_endPoint->GetLocalPort (), port);
>               NotifyDataSent (p->GetSize ());
>               NotifySend (GetTxAvailable ());
>             }
627d623
<               // Here we try to route subnet-directed broadcasts
952,953d947
<   Ptr<NetDevice> oldBoundNetDevice = m_boundnetdevice;
< 
955c949
<   if (m_endPoint != 0)
---
>   if (m_endPoint == 0)
957c951,956
<       m_endPoint->BindToNetDevice (netdevice);
---
>       if (Bind () == -1)
>         {
>           NS_ASSERT (m_endPoint == 0);
>           return;
>         }
>       NS_ASSERT (m_endPoint != 0);
958a958
>   m_endPoint->BindToNetDevice (netdevice);
960c960
<   if (m_endPoint6 != 0)
---
>   if (m_endPoint6 == 0)
962c962,969
<       m_endPoint6->BindToNetDevice (netdevice);
---
>       if (Bind6 () == -1)
>         {
>           NS_ASSERT (m_endPoint6 == 0);
>           return;
>         }
>       NS_ASSERT (m_endPoint6 != 0);
>     }
>   m_endPoint6->BindToNetDevice (netdevice);
964,966c971,974
<       // The following is to fix the multicast distribution inside the node
<       // and to upgrade it to the actual bound NetDevice.
<       if (m_endPoint6->GetLocalAddress ().IsMulticast ())
---
>   if (m_endPoint6->GetLocalAddress ().IsMulticast ())
>     {
>       Ptr<Ipv6L3Protocol> ipv6l3 = m_node->GetObject <Ipv6L3Protocol> ();
>       if (ipv6l3)
968,991c976,978
<           Ptr<Ipv6L3Protocol> ipv6l3 = m_node->GetObject <Ipv6L3Protocol> ();
<           if (ipv6l3)
<             {
<               // Cleanup old one
<               if (oldBoundNetDevice)
<                 {
<                   uint32_t index = ipv6l3->GetInterfaceForDevice (oldBoundNetDevice);
<                   ipv6l3->RemoveMulticastAddress (m_endPoint6->GetLocalAddress (), index);
<                 }
<               else
<                 {
<                   ipv6l3->RemoveMulticastAddress (m_endPoint6->GetLocalAddress ());
<                 }
<               // add new one
<               if (netdevice)
<                 {
<                   uint32_t index = ipv6l3->GetInterfaceForDevice (netdevice);
<                   ipv6l3->AddMulticastAddress (m_endPoint6->GetLocalAddress (), index);
<                 }
<               else
<                 {
<                   ipv6l3->AddMulticastAddress (m_endPoint6->GetLocalAddress ());
<                 }
<             }
---
>           uint32_t index = ipv6l3->GetInterfaceForDevice (netdevice);
>           ipv6l3->RemoveMulticastAddress (m_endPoint6->GetLocalAddress ());
>           ipv6l3->AddMulticastAddress (m_endPoint6->GetLocalAddress (), index);
diff ../../NS3-WiGig/src/internet/model/udp-socket-impl.h ../../ns-3-dev/src/internet/model/udp-socket-impl.h
135,138d134
<   /**
<    * \brief UdpSocketFactory friend class.
<    * \relates UdpSocketFactory
<    */
