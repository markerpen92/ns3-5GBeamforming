diff ../../NS3-WiGig/src/wifi/model/aarfcd-wifi-manager.cc ../../ns-3-dev/src/wifi/model/aarfcd-wifi-manager.cc
21,22d20
< #include "ns3/log.h"
< #include "ns3/packet.h"
24c22,28
< #include "wifi-tx-vector.h"
---
> #include "ns3/assert.h"
> #include "ns3/log.h"
> #include "ns3/simulator.h"
> #include "ns3/boolean.h"
> #include "ns3/double.h"
> #include "ns3/uinteger.h"
> #include <algorithm>
31c35
< NS_LOG_COMPONENT_DEFINE ("AarfcdWifiManager");
---
> NS_LOG_COMPONENT_DEFINE ("Aarfcd");
41,52c45,57
<   uint32_t m_timer; ///< timer
<   uint32_t m_success; ///< success
<   uint32_t m_failed; ///< failed
<   bool m_recovery; ///< recovery
<   bool m_justModifyRate; ///< just modify rate
<   uint32_t m_successThreshold; ///< success threshold
<   uint32_t m_timerTimeout; ///< timer timeout
<   uint8_t m_rate; ///< rate
<   bool m_rtsOn; ///< RTS on
<   uint32_t m_rtsWnd; ///< RTS window
<   uint32_t m_rtsCounter; ///< RTS counter
<   bool m_haveASuccess; ///< have a success
---
>   uint32_t m_timer;
>   uint32_t m_success;
>   uint32_t m_failed;
>   bool m_recovery;
>   bool m_justModifyRate;
>   uint32_t m_retry;
>   uint32_t m_successThreshold;
>   uint32_t m_timerTimeout;
>   uint32_t m_rate;
>   bool m_rtsOn;
>   uint32_t m_rtsWnd;
>   uint32_t m_rtsCounter;
>   bool m_haveASuccess;
89c94
<                    "Minimum value for RTS window of AARF-CD",
---
>                    "Minimum value for Rts window of Aarf-CD",
94c99
<                    "Maximum value for RTS window of AARF-CD",
---
>                    "Maximum value for Rts window of Aarf-CD",
108,111d112
<     .AddTraceSource ("Rate",
<                      "Traced value for rate changes (b/s)",
<                      MakeTraceSourceAccessor (&AarfcdWifiManager::m_currentRate),
<                      "ns3::TracedValueCallback::Uint64")
117,118c118
<   : WifiRemoteStationManager (),
<     m_currentRate (0)
---
>   : WifiRemoteStationManager ()
128,145d127
< void
< AarfcdWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
152c134
<   //AARF fields below
---
>   //aarf fields below
158a141
>   station->m_retry = 0;
161c144
<   //AARF-CD specific fields below
---
>   //aarf-cd specific fields below
181c164
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *)st;
183a167
>   station->m_retry++;
198c182
<       if (station->m_failed >= 2)
---
>       if (station->m_retry >= 2)
205c189
<       NS_ASSERT (station->m_failed >= 1);
---
>       NS_ASSERT (station->m_retry >= 1);
208c192
<       if (station->m_failed == 1)
---
>       if (station->m_retry == 1)
229c213
<       NS_ASSERT (station->m_failed >= 1);
---
>       NS_ASSERT (station->m_retry >= 1);
232c216
<       if (((station->m_failed - 1) % 2) == 1)
---
>       if (((station->m_retry - 1) % 2) == 1)
247c231
<       if (station->m_failed >= 2)
---
>       if (station->m_retry >= 2)
267c251
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
273,274c257,258
< AarfcdWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                    double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> AarfcdWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                    double ackSnr, WifiMode ackMode, double dataSnr)
276,277c260,261
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
281a266
>   station->m_retry = 0;
321,322c306,307
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
324a310
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
327,333c313
<   WifiMode mode = GetSupported (station, station->m_rate);
<   if (m_currentRate != mode.GetDataRate (channelWidth))
<     {
<       NS_LOG_DEBUG ("New datarate: " << mode.GetDataRate (channelWidth));
<       m_currentRate = mode.GetDataRate (channelWidth);
<     }
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, station->m_rate), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
340c320
<   /// \todo we could/should implement the AARF algorithm for
---
>   /// \todo we could/should implement the Aarf algorithm for
342,343c322,323
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
345a326
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
349d329
<   WifiMode mode;
352c332
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
356c336
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
358d337
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
364c343
<                               uint32_t size, bool normally)
---
>                               Ptr<const Packet> packet, bool normally)
366,367c345,346
<   NS_LOG_FUNCTION (this << st << size << normally);
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << packet << normally);
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
372a352,358
> bool
> AarfcdWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
> }
> 
419a406,427
> 
> void
> AarfcdWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> AarfcdWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> 
diff ../../NS3-WiGig/src/wifi/model/aarfcd-wifi-manager.h ../../ns-3-dev/src/wifi/model/aarfcd-wifi-manager.h
24d23
< #include "ns3/traced-value.h"
40,42c39,41
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
---
>  * This RAA does not support HT or VHT modes and will error exit
>  * if the user tries to configure this RAA with a Wi-Fi MAC that
>  * has VhtSupported or HtSupported set.
47,50d45
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
54a50,52
>   // Inherited from WifiRemoteStationManager
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
57,61c55,58
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
---
>   // overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
63c60
<   void DoReportRtsFailed (WifiRemoteStation *station);
---
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
73c70
<    * \param station the station that we failed to send Data
---
>    * \param station the station that we failed to send DATA
75,85c72,83
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
<   bool DoNeedRts (WifiRemoteStation *station,
<                   uint32_t size, bool normally);
---
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool DoNeedRts (WifiRemoteStation *station,
>                           Ptr<const Packet> packet, bool normally);
>   virtual bool IsLowLatency (void) const;
118,131c116,127
<   //AARF fields below
<   uint32_t m_minTimerThreshold;   ///< minimum timer threshold
<   uint32_t m_minSuccessThreshold; ///< minimum success threshold
<   double m_successK;              ///< Multiplication factor for the success threshold
<   uint32_t m_maxSuccessThreshold; ///< maximum success threshold
<   double m_timerK;                ///< Multiplication factor for the timer threshold
< 
<   //AARF-CD fields below
<   uint32_t m_minRtsWnd;               ///< minimum RTS window
<   uint32_t m_maxRtsWnd;               ///< maximum RTS window
<   bool m_turnOffRtsAfterRateDecrease; ///< turn off RTS after rate decrease
<   bool m_turnOnRtsAfterRateIncrease;  ///< turn on RTS after rate increase
< 
<   TracedValue<uint64_t> m_currentRate; //!< Trace rate changes
---
>   //aarf fields below
>   uint32_t m_minTimerThreshold;
>   uint32_t m_minSuccessThreshold;
>   double m_successK;
>   uint32_t m_maxSuccessThreshold;
>   double m_timerK;
> 
>   //aarf-cd fields below
>   uint32_t m_minRtsWnd;
>   uint32_t m_maxRtsWnd;
>   bool m_turnOffRtsAfterRateDecrease;
>   bool m_turnOnRtsAfterRateIncrease;
diff ../../NS3-WiGig/src/wifi/model/aarf-wifi-manager.cc ../../ns-3-dev/src/wifi/model/aarf-wifi-manager.cc
21d20
< #include "ns3/log.h"
23c22,24
< #include "wifi-tx-vector.h"
---
> #include "ns3/double.h"
> #include "ns3/uinteger.h"
> #include "ns3/log.h"
40,46c41,48
<   uint32_t m_timer; ///< timer
<   uint32_t m_success; ///< success
<   uint32_t m_failed; ///< failed
<   bool m_recovery; ///< recovery
<   uint32_t m_timerTimeout; ///< timer timeout
<   uint32_t m_successThreshold; ///< success threshold
<   uint8_t m_rate; ///< rate
---
>   uint32_t m_timer;
>   uint32_t m_success;
>   uint32_t m_failed;
>   bool m_recovery;
>   uint32_t m_retry;
>   uint32_t m_timerTimeout;
>   uint32_t m_successThreshold;
>   uint32_t m_rate;
82,85d83
<     .AddTraceSource ("Rate",
<                      "Traced value for rate changes (b/s)",
<                      MakeTraceSourceAccessor (&AarfWifiManager::m_currentRate),
<                      "ns3::TracedValueCallback::Uint64")
91,92d88
<   : WifiRemoteStationManager (),
<     m_currentRate (0)
102,119d97
< void
< AarfWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
131a110
>   station->m_retry = 0;
151c130
<  * \param st the station that we failed to send Data
---
>  * \param st the station that we failed to send DATA
157c136
<   AarfWifiRemoteStation *station = static_cast<AarfWifiRemoteStation*> (st);
---
>   AarfWifiRemoteStation *station = (AarfWifiRemoteStation *)st;
159a139
>   station->m_retry++;
164,165c144,145
<       NS_ASSERT (station->m_failed >= 1);
<       if (station->m_failed == 1)
---
>       NS_ASSERT (station->m_retry >= 1);
>       if (station->m_retry == 1)
181,182c161,162
<       NS_ASSERT (station->m_failed >= 1);
<       if (((station->m_failed - 1) % 2) == 1)
---
>       NS_ASSERT (station->m_retry >= 1);
>       if (((station->m_retry - 1) % 2) == 1)
192c172
<       if (station->m_failed >= 2)
---
>       if (station->m_retry >= 2)
215,216c195,196
< AarfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> AarfWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                  double ackSnr, WifiMode ackMode, double dataSnr)
218,219c198,199
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   AarfWifiRemoteStation *station = static_cast<AarfWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   AarfWifiRemoteStation *station = (AarfWifiRemoteStation *) st;
223a204
>   station->m_retry = 0;
253,254c234,235
<   AarfWifiRemoteStation *station = static_cast<AarfWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   AarfWifiRemoteStation *station = (AarfWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
256a238
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
259,265c241
<   WifiMode mode = GetSupported (station, station->m_rate);
<   if (m_currentRate != mode.GetDataRate (channelWidth))
<     {
<       NS_LOG_DEBUG ("New datarate: " << mode.GetDataRate (channelWidth));
<       m_currentRate = mode.GetDataRate (channelWidth);
<     }
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, station->m_rate), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
272c248
<   /// \todo we could/should implement the AARF algorithm for
---
>   /// \todo we could/should implement the Aarf algorithm for
274,275c250,251
<   AarfWifiRemoteStation *station = static_cast<AarfWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   AarfWifiRemoteStation *station = (AarfWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
277a254
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
281d257
<   WifiMode mode;
284c260
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (station, 0), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
288c264
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (station, 0), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
290d265
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
291a267,293
> }
> 
> bool
> AarfWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
> }
> 
> void
> AarfWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> AarfWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/aarf-wifi-manager.h ../../ns-3-dev/src/wifi/model/aarf-wifi-manager.h
24,25c24
< #include "ns3/traced-value.h"
< #include "wifi-remote-station-manager.h"
---
> #include "arf-wifi-manager.h"
38,40c37,39
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
---
>  * This RAA does not support HT or VHT modes and will error exit
>  * if the user tries to configure this RAA with a Wi-Fi MAC that
>  * has VhtSupported or HtSupported set.
45,48d43
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
53c48,50
< 
---
>   // Inherited from WifiRemoteStationManager
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
55,77c52,72
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
< 
<   uint32_t m_minTimerThreshold;   ///< minimum timer threshold
<   uint32_t m_minSuccessThreshold; ///< minimum success threshold
<   double m_successK;              ///< Multiplication factor for the success threshold
<   uint32_t m_maxSuccessThreshold; ///< maximum success threshold
<   double m_timerK;                ///< Multiplication factor for the timer threshold
< 
<   TracedValue<uint64_t> m_currentRate; //!< Trace rate changes
---
>   //overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool IsLowLatency (void) const;
> 
>   uint32_t m_minTimerThreshold;
>   uint32_t m_minSuccessThreshold;
>   double m_successK;
>   uint32_t m_maxSuccessThreshold;
>   double m_timerK;
diff ../../NS3-WiGig/src/wifi/model/adhoc-wifi-mac.cc ../../ns-3-dev/src/wifi/model/adhoc-wifi-mac.cc
23,24d22
< #include "ns3/log.h"
< #include "ns3/packet.h"
26,28c24,28
< #include "ht-capabilities.h"
< #include "vht-capabilities.h"
< #include "he-capabilities.h"
---
> #include "ns3/pointer.h"
> #include "ns3/log.h"
> #include "ns3/string.h"
> #include "ns3/boolean.h"
> #include "ns3/trace-source-accessor.h"
29a30,35
> #include "dcf-manager.h"
> #include "mac-rx-middle.h"
> #include "mac-tx-middle.h"
> #include "msdu-aggregator.h"
> #include "amsdu-subframe-header.h"
> #include "mgt-headers.h"
75c81
< AdhocWifiMac::Enqueue (Ptr<Packet> packet, Mac48Address to)
---
> AdhocWifiMac::Enqueue (Ptr<const Packet> packet, Mac48Address to)
80,81c86,88
<       //In ad hoc mode, we assume that every destination supports all the rates we support.
<       if (GetHtSupported ())
---
>       //In ad hoc mode, we assume that every destination supports all
>       //the rates we support.
>       if (m_htSupported || m_vhtSupported)
84c91
<           m_stationManager->AddStationHtCapabilities (to, GetHtCapabilities ());
---
>           m_stationManager->AddStationHtCapabilities (to, GetHtCapabilities());
86c93
<       if (GetVhtSupported ())
---
>       if (m_vhtSupported)
88,92c95
<           m_stationManager->AddStationVhtCapabilities (to, GetVhtCapabilities ());
<         }
<       if (GetHeSupported ())
<         {
<           m_stationManager->AddStationHeCapabilities (to, GetHeCapabilities ());
---
>           m_stationManager->AddStationVhtCapabilities (to, GetVhtCapabilities());
110c113
<   if (GetQosSupported ())
---
>   if (m_qosSupported)
133c136
<       hdr.SetType (WIFI_MAC_DATA);
---
>       hdr.SetTypeData ();
136c139
<   if (GetHtSupported ())
---
>   if (m_htSupported || m_vhtSupported)
138c141
<       hdr.SetNoOrder (); // explicitly set to 0 for the time being since HT control field is not yet implemented (set it to 1 when implemented)
---
>       hdr.SetNoOrder ();
146c149
<   if (GetQosSupported ())
---
>   if (m_qosSupported)
154c157
<       m_txop->Queue (packet, hdr);
---
>       m_dca->Queue (packet, hdr);
170,184d172
< Ptr<MultiBandElement>
< AdhocWifiMac::GetMultiBandElement (void) const
< {
<   Ptr<MultiBandElement> multiband = Create<MultiBandElement> ();
<   multiband->SetStaRole (ROLE_IBSS_STA);
<   multiband->SetStaMacAddressPresent (false); /* The same MAC address is used across all the bands */
<   multiband->SetBandID (Band_60GHz);
<   multiband->SetOperatingClass (18);          /* Europe */
<   multiband->SetChannelNumber (1);
<   multiband->SetBssID (GetAddress ());
<   multiband->SetConnectionCapability (1);     /* AP */
<   multiband->SetFstSessionTimeout (1);
<   return multiband;
< }
< 
186c174
< AdhocWifiMac::Receive (Ptr<WifiMacQueueItem> mpdu)
---
> AdhocWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
188,189c176
<   NS_LOG_FUNCTION (this << *mpdu);
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
---
>   NS_LOG_FUNCTION (this << packet << hdr);
195,196c182,184
<       //In ad hoc mode, we assume that every destination supports all the rates we support.
<       if (GetHtSupported ())
---
>       //In ad hoc mode, we assume that every destination supports all
>       //the rates we support.
>       if (m_htSupported || m_vhtSupported)
199,203c187
<           m_stationManager->AddStationHtCapabilities (from, GetHtCapabilities ());
<         }
<       if (GetVhtSupported ())
<         {
<           m_stationManager->AddStationVhtCapabilities (from, GetVhtCapabilities ());
---
>           m_stationManager->AddStationHtCapabilities (from, GetHtCapabilities());
205c189
<       if (GetHeSupported ())
---
>       if (m_vhtSupported)
207c191
<           m_stationManager->AddStationHeCapabilities (from, GetHeCapabilities ());
---
>           m_stationManager->AddStationVhtCapabilities (from, GetVhtCapabilities());
217c201
<           DeaggregateAmsduAndForward (mpdu);
---
>           DeaggregateAmsduAndForward (packet, hdr);
221c205
<           ForwardUp (mpdu->GetPacket ()->Copy (), from, to);
---
>           ForwardUp (packet, from, to);
229c213
<   RegularWifiMac::Receive (mpdu);
---
>   RegularWifiMac::Receive (packet, hdr);
diff ../../NS3-WiGig/src/wifi/model/adhoc-wifi-mac.h ../../ns-3-dev/src/wifi/model/adhoc-wifi-mac.h
22d21
< 
26a26
> #include "amsdu-subframe-header.h"
33c33
<  * \brief Wifi MAC high model for an ad-hoc Wifi MAC
---
>  *
38,41d37
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
47,50c43,61
<   // Implementations of pure virtual methods, or overridden from base class.
<   void SetAddress (Mac48Address address);
<   void SetLinkUpCallback (Callback<void> linkUp);
<   void Enqueue (Ptr<Packet> packet, Mac48Address to);
---
>   /**
>    * \param address the current address of this MAC layer.
>    */
>   virtual void SetAddress (Mac48Address address);
> 
>   /**
>    * \param linkUp the callback to invoke when the link becomes up.
>    */
>   virtual void SetLinkUpCallback (Callback<void> linkUp);
> 
>   /**
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
>    *
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.
>    */
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to);
52,53d62
< protected:
<   Ptr<MultiBandElement> GetMultiBandElement (void) const;
56c65
<   void Receive (Ptr<WifiMacQueueItem> mpdu);
---
>   virtual void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
diff ../../NS3-WiGig/src/wifi/model/ampdu-subframe-header.cc ../../ns-3-dev/src/wifi/model/ampdu-subframe-header.cc
21a22
> #include "ns3/address-utils.h"
47,48c48
<     m_eof (0),
<     m_signature (0x4E) // Per 802.11 standard, the unique pattern is set to the value 0x4E.
---
>     m_eof (0)
66,67c66,67
<   i.WriteU8 (1); //not used, CRC always set to 1
<   i.WriteU8 (m_signature);
---
>   i.WriteU8 (m_crc);
>   i.WriteU8 (m_sig);
77,78c77,78
<   i.ReadU8 (); //CRC
<   m_signature = i.ReadU8 (); //SIG
---
>   m_crc = i.ReadU8 ();
>   m_sig = i.ReadU8 ();
85,86c85,101
<   os << "EOF = " << m_eof << ", length = " << m_length
<      << ", signature = 0x" << std::hex << m_signature;
---
>   os << "EOF = " << m_eof << ", length = " << m_length;
>   char previousFillChar = os.fill ('0');
>   os << ", CRC = 0x" << std::hex << std::setw (2) << (uint16_t) m_crc << ", Signature = 0x" << (uint16_t) m_sig << std::dec;
>   os.fill (previousFillChar);
> }
> 
> void
> AmpduSubframeHeader::SetCrc (uint8_t crc)
> {
>   m_crc = crc;
> }
> 
> void
> AmpduSubframeHeader::SetSig ()
> {
>   // Per 802.11 standard, the unique pattern is set to the value 0x4E.
>   m_sig = 0x4E;
100a116,127
> uint8_t
> AmpduSubframeHeader::GetCrc (void) const
> {
>   return m_crc;
> }
> 
> uint8_t
> AmpduSubframeHeader::GetSig (void) const
> {
>   return m_sig;
> }
> 
111,116d137
< }
< 
< bool
< AmpduSubframeHeader::IsSignatureValid (void) const
< {
<   return m_signature == 0x4E;
diff ../../NS3-WiGig/src/wifi/model/ampdu-subframe-header.h ../../ns-3-dev/src/wifi/model/ampdu-subframe-header.h
1,91c1,105
< /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
< /*
<  * Copyright (c) 2013
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License version 2 as
<  * published by the Free Software Foundation;
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
<  *
<  * Author: Ghada Badawy <gbadawy@gmail.com>
<  */
< 
< #ifndef AMPDU_SUBFRAME_HEADER_H
< #define AMPDU_SUBFRAME_HEADER_H
< 
< #include "ns3/header.h"
< 
< namespace ns3 {
< 
< /**
<  * \ingroup wifi
<  * \brief Headers for A-MPDU subframes
<  */
< class AmpduSubframeHeader : public Header
< {
< public:
<   AmpduSubframeHeader ();
<   virtual ~AmpduSubframeHeader ();
< 
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
<   static TypeId GetTypeId (void);
< 
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the length field.
<    *
<    * \param length in bytes
<    */
<   void SetLength (uint16_t length);
<   /**
<   * Set the EOF field.
<   *
<   * \param eof set EOF field if true
<   */
<   void SetEof (bool eof);
<   /**
<    * Return the length field.
<    *
<    * \return the length field in bytes
<    */
<   uint16_t GetLength (void) const;
<   /**
<    * Return the EOF field.
<    *
<    * \return the EOF field
<    */
<   bool GetEof (void) const;
<   /**
<    * Return whether the pattern stored in the delimiter
<    * signature field is correct, i.e. corresponds to the
<    * unique pattern 0x4E.
<    *
<    * \return true if the signature is valid, false otherwise
<    */
<   bool IsSignatureValid (void) const;
< 
< private:
<   uint16_t m_length;   //!< length field in bytes
<   bool m_eof;          //!< EOF field
<   uint8_t m_signature; //!< delimiter signature (should correspond to pattern 0x4E in order to be assumed valid)
< };
< 
< } //namespace ns3
< 
< #endif /* AMPDU_SUBFRAME_HEADER_H */
---
> /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
> /*
>  * Copyright (c) 2013
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License version 2 as
>  * published by the Free Software Foundation;
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
>  *
>  * Author: Ghada Badawy <gbadawy@gmail.com>
>  */
> 
> #ifndef AMPDU_SUBFRAME_HEADER_H
> #define AMPDU_SUBFRAME_HEADER_H
> 
> #include "ns3/header.h"
> #include "ns3/mac48-address.h"
> 
> namespace ns3 {
> 
> /**
>  * \ingroup wifi
>  *
>  *
>  */
> class AmpduSubframeHeader : public Header
> {
> public:
>   AmpduSubframeHeader ();
>   virtual ~AmpduSubframeHeader ();
> 
>   static TypeId GetTypeId (void);
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
> 
>   /**
>    * Set the CRC field.
>    *
>    * \param crc
>    */
>   void SetCrc (uint8_t crc);
>   /**
>    * Set the SIG field.
>    *
>    * \param crc
>    */
>   void SetSig ();
>   /**
>    * Set the length field.
>    *
>    * \param length
>    */
>   void SetLength (uint16_t length);
>   /**
>   * Set the EOF field.
>   *
>   * \param eof
>   */
>   void SetEof (bool eof);
>   /**
>    * Return the CRC field.
>    *
>    * \return the CRC field
>    */
>   uint8_t GetCrc (void) const;
>   /**
>    * Return the SIG field.
>    *
>    * \return the SIG field
>    */
>   uint8_t GetSig (void) const;
>   /**
>    * Return the length field.
>    *
>    * \return the length field
>    */
>   uint16_t GetLength (void) const;
>   /**
>    * Return the EOF field.
>    *
>    * \return the EOF field
>    */
>   bool GetEof (void) const;
> 
> protected:
>   uint8_t m_crc;     //!< CRC field
>   uint8_t m_sig;     //!< SIG field
>   uint16_t m_length; //!< length field
>   bool m_eof;        //!< EOF field
> };
> 
> } //namespace ns3
> 
> #endif /* AMPDU_SUBFRAME_HEADER_H */
diff ../../NS3-WiGig/src/wifi/model/ampdu-tag.cc ../../ns-3-dev/src/wifi/model/ampdu-tag.cc
22a23,24
> #include "ns3/tag.h"
> #include "ns3/uinteger.h"
34a37,40
>     .AddAttribute ("AmpduExists", "The value that indicates that the packet contains an AMPDU",
>                    UintegerValue (false),
>                    MakeUintegerAccessor (&AmpduTag::GetAmpdu),
>                    MakeUintegerChecker<uint8_t> ())
46c52,53
<   : m_nbOfMpdus (0),
---
>   : m_ampdu (0),
>     m_nbOfMpdus (0),
52c59
< AmpduTag::SetRemainingNbOfMpdus (uint8_t nbOfMpdus)
---
> AmpduTag::SetAmpdu (bool supported)
54c61,68
<   m_nbOfMpdus = nbOfMpdus;
---
>   m_ampdu = supported;
> }
> 
> void
> AmpduTag::SetRemainingNbOfMpdus (uint8_t nbofmpdus)
> {
>   NS_ASSERT (nbofmpdus <= 64);
>   m_nbOfMpdus = nbofmpdus;
67c81
<   return (1 + sizeof (Time));
---
>   return (2 + sizeof (Time));
72a87
>   i.WriteU8 (m_ampdu);
80a96
>   m_ampdu = i.ReadU8 ();
83c99
<   i.Read ((uint8_t *)&duration, sizeof(int64_t));
---
>   i.Read ((uint8_t *)&duration, 8);
86a103,108
> bool
> AmpduTag::GetAmpdu () const
> {
>   return (m_ampdu == 1) ? true : false;
> }
> 
102c124,125
<   os << "Remaining number of MPDUs=" << m_nbOfMpdus
---
>   os << "A-MPDU exists=" << m_ampdu
>      << " Remaining number of MPDUs=" << m_nbOfMpdus
diff ../../NS3-WiGig/src/wifi/model/ampdu-tag.h ../../ns-3-dev/src/wifi/model/ampdu-tag.h
1,89c1,99
< /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
< /*
<  * Copyright (c) 2013
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License version 2 as
<  * published by the Free Software Foundation;
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
<  *
<  * Authors: Ghada Badawy <gbadawy@gmail.com>
<  *          Sébastien Deronne <sebastien.deronne@gmail.com>
<  */
< 
< #ifndef AMPDU_TAG_H
< #define AMPDU_TAG_H
< 
< #include "ns3/nstime.h"
< #include "ns3/tag.h"
< 
< namespace ns3 {
< 
< /**
<  * \ingroup wifi
<  *
<  * The aim of the AmpduTag is to provide means for a MAC to specify that a packet includes A-MPDU
<  * since this is done in HT-SIG and there is no HT-SIG representation in ns-3
<  */
< class AmpduTag : public Tag
< {
< public:
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
<   static TypeId GetTypeId (void);
<   TypeId GetInstanceTypeId (void) const;
< 
<   /**
<    * Create a AmpduTag with the default =0 no A-MPDU
<    */
<   AmpduTag ();
<   /**
<    * \param nbOfMpdus the remaining number of MPDUs
<    *
<    * Set the remaining number of MPDUs in the A-MPDU.
<    */
<   void SetRemainingNbOfMpdus (uint8_t nbOfMpdus);
<   /**
<    * \param duration the remaining duration of the A-MPDU
<    *
<    * Set the remaining duration of the A-MPDU.
<    */
<   void SetRemainingAmpduDuration (Time duration);
< 
<   void Serialize (TagBuffer i) const;
<   void Deserialize (TagBuffer i);
<   uint32_t GetSerializedSize () const;
<   void Print (std::ostream &os) const;
< 
<   /**
<    * \return the remaining number of MPDUs in an A-MPDU
<    *
<    * Returns the remaining number of MPDUs in an A-MPDU
<    */
<   uint8_t GetRemainingNbOfMpdus (void) const;
<   /**
<    * \return the remaining duration of an A-MPDU
<    *
<    * Returns the remaining duration of an A-MPDU
<    */
<   Time GetRemainingAmpduDuration (void) const;
< 
< 
< private:
<   uint8_t m_nbOfMpdus; //!< Remaining number of MPDUs in the A-MPDU
<   Time m_duration;     //!< Remaining duration of the A-MPDU
< };
< 
< } //namespace ns3
< 
< #endif /* AMPDU_TAG_H */
---
> /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
> /*
>  * Copyright (c) 2013
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License version 2 as
>  * published by the Free Software Foundation;
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
>  *
>  * Authors: Ghada Badawy <gbadawy@gmail.com>
>  *          Sébastien Deronne <sebastien.deronne@gmail.com>
>  */
> 
> #ifndef AMPDU_TAG_H
> #define AMPDU_TAG_H
> 
> #include "ns3/packet.h"
> #include "ns3/nstime.h"
> 
> namespace ns3 {
> 
> class Tag;
> 
> /**
>  * \ingroup wifi
>  *
>  * The aim of the AmpduTag is to provide means for a MAC to specify that a packet includes A-MPDU
>  * since this is done in HT-SIG and there is no HT-SIG representation in ns-3
>  */
> class AmpduTag : public Tag
> {
> public:
>   static TypeId GetTypeId (void);
>   virtual TypeId GetInstanceTypeId (void) const;
> 
>   /**
>    * Create a AmpduTag with the default =0 no Ampdu
>    */
>   AmpduTag ();
>   /**
>    * Set m_ampdu to 1.
>    */
>   void SetAmpdu (bool supported);
>   /**
>    * \param nbofmpdus the remaining number of MPDUs
>    *
>    * Set the remaining number of MPDUs in the A-MPDU.
>    */
>   void SetRemainingNbOfMpdus (uint8_t nbofmpdus);
>   /**
>    * \param duration the remaining duration of the A-MPDU
>    *
>    * Set the remaining duration of the A-MPDU.
>    */
>   void SetRemainingAmpduDuration (Time duration);
> 
>   virtual void Serialize (TagBuffer i) const;
>   virtual void Deserialize (TagBuffer i);
>   virtual uint32_t GetSerializedSize () const;
>   virtual void Print (std::ostream &os) const;
> 
>   /**
>    * \return true if it is an A-MPDU,
>    *         false otherwise.
>    *
>    * Returns m_ampdu
>    */
>   bool GetAmpdu (void) const;
>   /**
>    * \return the remaining number of MPDUs in an A-MPDU
>    *
>    * Returns the remaining number of MPDUs in an A-MPDU
>    */
>   uint8_t GetRemainingNbOfMpdus (void) const;
>   /**
>    * \return the remaining duration of an A-MPDU
>    *
>    * Returns the remaining duration of an A-MPDU
>    */
>   Time GetRemainingAmpduDuration (void) const;
> 
> private:
>   uint8_t m_ampdu;     //!< Flag whether it is an A-MPDU
>   uint8_t m_nbOfMpdus; //!< Remaining number of MPDUs in the A-MPDU
>   Time m_duration;     //!< Remaining duration of the A-MPDU in nanoseconds
> };
> 
> } //namespace ns3
> 
> #endif /* AMPDU_TAG_H */
> 
diff ../../NS3-WiGig/src/wifi/model/amrr-wifi-manager.cc ../../ns-3-dev/src/wifi/model/amrr-wifi-manager.cc
21,22d20
< #include "ns3/log.h"
< #include "ns3/simulator.h"
24c22,25
< #include "wifi-tx-vector.h"
---
> #include "ns3/simulator.h"
> #include "ns3/log.h"
> #include "ns3/uinteger.h"
> #include "ns3/double.h"
30c31
< NS_LOG_COMPONENT_DEFINE ("AmrrWifiManager");
---
> NS_LOG_COMPONENT_DEFINE ("AmrrWifiRemoteStation");
40,48c41,49
<   Time m_nextModeUpdate; ///< next mode update time
<   uint32_t m_tx_ok;      ///< transmit OK
<   uint32_t m_tx_err;     ///< transmit error
<   uint32_t m_tx_retr;    ///< transmit retry
<   uint32_t m_retry;      ///< retry
<   uint8_t m_txrate;      ///< transmit rate
<   uint32_t m_successThreshold; ///< success threshold
<   uint32_t m_success;    ///< success
<   bool m_recovery;       ///< recovery
---
>   Time m_nextModeUpdate;
>   uint32_t m_tx_ok;
>   uint32_t m_tx_err;
>   uint32_t m_tx_retr;
>   uint32_t m_retry;
>   uint32_t m_txrate;
>   uint32_t m_successThreshold;
>   uint32_t m_success;
>   bool m_recovery;
86,89d86
<     .AddTraceSource ("Rate",
<                      "Traced value for rate changes (b/s)",
<                      MakeTraceSourceAccessor (&AmrrWifiManager::m_currentRate),
<                      "ns3::TracedValueCallback::Uint64")
95,107d91
<   : WifiRemoteStationManager (),
<     m_currentRate (0)
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< AmrrWifiManager::~AmrrWifiManager ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< void
< AmrrWifiManager::DoInitialize ()
110,121d93
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
158c130
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
---
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
171,172c143,144
< AmrrWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> AmrrWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                  double ackSnr, WifiMode ackMode, double dataSnr)
174,175c146,147
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
190c162
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
---
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
273c245
<                     " rate=" << +station->m_txrate << " n-supported-rates=" << +GetNSupported (station));
---
>                     " rate=" << station->m_txrate << " n-supported-rates=" << GetNSupported (station));
292c264
<                     " rate=" << +station->m_txrate << " n-supported-rates=" << +GetNSupported (station));
---
>                     " rate=" << station->m_txrate << " n-supported-rates=" << GetNSupported (station));
325c297
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
---
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
328c300
<   uint8_t rateIndex;
---
>   uint32_t rateIndex;
366c338
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   uint32_t channelWidth = GetChannelWidth (station);
368a341
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
371,377c344
<   WifiMode mode = GetSupported (station, rateIndex);
<   if (m_currentRate != mode.GetDataRate (channelWidth))
<     {
<       NS_LOG_DEBUG ("New datarate: " << mode.GetDataRate (channelWidth));
<       m_currentRate = mode.GetDataRate (channelWidth);
<     }
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, rateIndex), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
384,385c351,352
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
>   uint32_t channelWidth = GetChannelWidth (station);
387a355
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
392d359
<   WifiMode mode;
395c362
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (station, 0), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
399c366
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (station, 0), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
401d367
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
403a370,397
> 
> bool
> AmrrWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
> }
> 
> void
> AmrrWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> AmrrWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
diff ../../NS3-WiGig/src/wifi/model/amrr-wifi-manager.h ../../ns-3-dev/src/wifi/model/amrr-wifi-manager.h
24d23
< #include "ns3/traced-value.h"
25a25
> #include "ns3/nstime.h"
40,42c40,42
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
---
>  * This RAA does not support HT or VHT modes and will error exit
>  * if the user tries to configure this RAA with a Wi-Fi MAC that
>  * has VhtSupported or HtSupported set.
47,50d46
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
54d49
<   virtual ~AmrrWifiManager ();
55a51,53
>   // Inherited from WifiRemoteStationManager
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
58,72c56,70
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
---
>   //overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool IsLowLatency (void) const;
73a72
>   //void UpdateRetry (AmrrWifiRemoteStation *station);
77c76
<    * \param station the remote station state
---
>    * \param station
83c82
<    * \param station the remote station state
---
>    * \param station
89c88
<    * \param station the remote station state
---
>    * \param station
95c94
<    * \param station the remote station state
---
>    * \param station
102c101
<    * \param station the remote station state
---
>    * \param station
112c111
<    * \param station the remote station state
---
>    * \param station
122c121
<    * \param station the remote station state
---
>    * \param station
133c132
<    * \param station the remote station state
---
>    * \param station
144c143
<    * \param station the remote station state
---
>    * \param station
151,157c150,154
<   Time m_updatePeriod;            ///< update period
<   double m_failureRatio;          ///< failure ratio
<   double m_successRatio;          ///< success ratio
<   uint32_t m_maxSuccessThreshold; ///< maximum success threshold
<   uint32_t m_minSuccessThreshold; ///< minimum success threshold
< 
<   TracedValue<uint64_t> m_currentRate; //!< Trace rate changes
---
>   Time m_updatePeriod;
>   double m_failureRatio;
>   double m_successRatio;
>   uint32_t m_maxSuccessThreshold;
>   uint32_t m_minSuccessThreshold;
diff ../../NS3-WiGig/src/wifi/model/amsdu-subframe-header.cc ../../ns-3-dev/src/wifi/model/amsdu-subframe-header.cc
21d20
< #include "ns3/address-utils.h"
22a22,23
> #include "ns3/address-utils.h"
> #include "ns3/log.h"
25a27,28
> NS_LOG_COMPONENT_DEFINE ("AmsduSubframeHeader");
> 
47a51
>   NS_LOG_FUNCTION (this);
51a56
>   NS_LOG_FUNCTION (this);
56a62
>   NS_LOG_FUNCTION (this);
62a69
>   NS_LOG_FUNCTION (this << &i);
70a78
>   NS_LOG_FUNCTION (this << &start);
80a89
>   NS_LOG_FUNCTION (this << &os);
86a96
>   NS_LOG_FUNCTION (this << to);
92a103
>   NS_LOG_FUNCTION (this << from);
98a110
>   NS_LOG_FUNCTION (this << length);
104a117
>   NS_LOG_FUNCTION (this);
110a124
>   NS_LOG_FUNCTION (this);
116a131
>   NS_LOG_FUNCTION (this);
diff ../../NS3-WiGig/src/wifi/model/amsdu-subframe-header.h ../../ns-3-dev/src/wifi/model/amsdu-subframe-header.h
31c31,32
<  * \brief Headers for A-MSDU subframes
---
>  *
>  *
39,42d39
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
44,48c41,45
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
50,53d46
<   /**
<    * Set destination address function
<    * \param to the destination MAC address
<    */
55,58d47
<   /**
<    * Set source address function
<    * \param to the source MAC address
<    */
60,68c49
<   /**
<    * Set length function
<    * \param length the length in bytes
<    */
<   void SetLength (uint16_t length);
<   /**
<    * Get destination address function
<    * \returns the destination MAC address
<    */
---
>   void SetLength (uint16_t);
70,73d50
<   /**
<    * Get source address function
<    * \returns the source MAC address
<    */
75,78d51
<   /**
<    * Get length function
<    * \returns the length in bytes
<    */
82,84c55,57
<   Mac48Address m_da; ///< destination address
<   Mac48Address m_sa; ///< source address
<   uint16_t m_length; ///< length in bytes
---
>   Mac48Address m_da;
>   Mac48Address m_sa;
>   uint16_t m_length;
diff ../../NS3-WiGig/src/wifi/model/aparf-wifi-manager.cc ../../ns-3-dev/src/wifi/model/aparf-wifi-manager.cc
21,23d20
< #include "ns3/log.h"
< #include "ns3/uinteger.h"
< #include "ns3/data-rate.h"
25a23,26
> #include "ns3/assert.h"
> #include "ns3/log.h"
> #include "ns3/uinteger.h"
> #include "ns3/trace-source-accessor.h"
29c30
< namespace ns3 {
---
> NS_LOG_COMPONENT_DEFINE ("ns3::AparfWifiManager");
31c32
< NS_LOG_COMPONENT_DEFINE ("AparfWifiManager");
---
> namespace ns3 {
47,52c48,51
<   uint8_t m_prevRateIndex;              //!< Rate index of the previous transmission.
<   uint8_t m_rateIndex;                  //!< Current rate index.
<   uint8_t m_critRateIndex;              //!< Critical rate.
<   uint8_t m_prevPowerLevel;             //!< Power level of the previous transmission.
<   uint8_t m_powerLevel;                 //!< Current power level.
<   uint8_t m_nSupported;                 //!< Number of supported rates by the remote station.
---
>   uint32_t m_rate;                      //!< Current rate.
>   uint32_t m_rateCrit;                  //!< Critical rate.
>   uint8_t m_power;                      //!< Current power.
>   uint32_t m_nSupported;                //!< Number of supported rates by the remote station.
90c89
<                    MakeUintegerChecker<uint8_t> ())
---
>                    MakeUintegerChecker<uint32_t> ())
95c94
<                    MakeUintegerChecker<uint8_t> ())
---
>                    MakeUintegerChecker<uint32_t> ())
100c99
<                    MakeUintegerChecker<uint8_t> ())
---
>                    MakeUintegerChecker<uint32_t> ())
105c104
<                    MakeUintegerChecker<uint8_t> ())
---
>                    MakeUintegerChecker<uint32_t> ())
129c128
< AparfWifiManager::SetupPhy (const Ptr<WifiPhy> phy)
---
> AparfWifiManager::SetupPhy (Ptr<WifiPhy> phy)
131,133c130,131
<   NS_LOG_FUNCTION (this << phy);
<   m_minPower = 0;
<   m_maxPower = phy->GetNTxPower () - 1;
---
>   m_minPower = phy->GetTxPowerStart ();
>   m_maxPower = phy->GetTxPowerEnd ();
137,154d134
< void
< AparfWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
169,170c149,150
<   NS_LOG_DEBUG ("create station=" << station << ", rate=" << +station->m_rateIndex
<                                   << ", power=" << +station->m_powerLevel);
---
>   NS_LOG_DEBUG ("create station=" << station << ", rate=" << station->m_rate
>                                   << ", power=" << (int)station->m_power);
181,191c161,165
<       station->m_rateIndex = station->m_nSupported - 1;
<       station->m_prevRateIndex = station->m_nSupported - 1;
<       station->m_powerLevel = m_maxPower;
<       station->m_prevPowerLevel = m_maxPower;
<       station->m_critRateIndex = 0;
<       WifiMode mode = GetSupported (station, station->m_rateIndex);
<       uint16_t channelWidth = GetChannelWidth (station);
<       DataRate rate = DataRate (mode.GetDataRate (channelWidth));
<       double power = GetPhy ()->GetPowerDbm (m_maxPower);
<       m_powerChange (power, power, station->m_state->m_address);
<       m_rateChange (rate, rate, station->m_state->m_address);
---
>       station->m_rate = station->m_nSupported - 1;
>       station->m_power = m_maxPower;
>       station->m_rateCrit = 0;
>       m_powerChange (station->m_power, station->m_state->m_address);
>       m_rateChange (station->m_rate, station->m_state->m_address);
204c178
<   AparfWifiRemoteStation *station = static_cast<AparfWifiRemoteStation*> (st);
---
>   AparfWifiRemoteStation *station = (AparfWifiRemoteStation *) st;
208,209c182,183
<   NS_LOG_DEBUG ("station=" << station << ", rate=" << station->m_rateIndex
<                            << ", power=" << (int)station->m_powerLevel);
---
>   NS_LOG_DEBUG ("station=" << station << ", rate=" << station->m_rate
>                            << ", power=" << (int)station->m_power);
227c201
<       if (station->m_powerLevel == m_maxPower)
---
>       if (station->m_power == m_maxPower)
229,230c203,204
<           station->m_critRateIndex = station->m_rateIndex;
<           if (station->m_rateIndex != 0)
---
>           station->m_rateCrit = station->m_rate;
>           if (station->m_rate != 0)
233c207,208
<               station->m_rateIndex -= m_rateDec;
---
>               station->m_rate -= m_rateDec;
>               m_rateChange (station->m_rate, station->m_state->m_address);
239c214,215
<           station->m_powerLevel += m_powerInc;
---
>           station->m_power += m_powerInc;
>           m_powerChange (station->m_power, station->m_state->m_address);
254a231
>   NS_LOG_DEBUG ("station=" << station << " rts ok");
258,259c235,236
< AparfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                   double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> AparfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr,
>                                   WifiMode ackMode, double dataSnr)
261,262c238,239
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   AparfWifiRemoteStation *station = static_cast<AparfWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   AparfWifiRemoteStation *station = (AparfWifiRemoteStation *) st;
266c243
<   NS_LOG_DEBUG ("station=" << station << " data ok success=" << station->m_nSuccess << ", rate=" << +station->m_rateIndex << ", power=" << +station->m_powerLevel);
---
>   NS_LOG_DEBUG ("station=" << station << " data ok success=" << station->m_nSuccess << ", rate=" << station->m_rate << ", power=" << (int)station->m_power);
286c263
<       if (station->m_rateIndex == (station->m_state->m_operationalRateSet.size () - 1))
---
>       if (station->m_rate == (station->m_state->m_operationalRateSet.size () - 1))
288c265
<           if (station->m_powerLevel != m_minPower)
---
>           if (station->m_power != m_minPower)
291c268,269
<               station->m_powerLevel -= m_powerDec;
---
>               station->m_power -= m_powerDec;
>               m_powerChange (station->m_power, station->m_state->m_address);
296c274
<           if (station->m_critRateIndex == 0)
---
>           if (station->m_rateCrit == 0)
298c276
<               if (station->m_rateIndex != (station->m_state->m_operationalRateSet.size () - 1))
---
>               if (station->m_rate != (station->m_state->m_operationalRateSet.size () - 1))
301c279,280
<                   station->m_rateIndex += m_rateInc;
---
>                   station->m_rate += m_rateInc;
>                   m_rateChange (station->m_rate, station->m_state->m_address);
308,309c287,290
<                   station->m_powerLevel = m_maxPower;
<                   station->m_rateIndex = station->m_critRateIndex;
---
>                   station->m_power = m_maxPower;
>                   m_powerChange (station->m_power, station->m_state->m_address);
>                   station->m_rate = station->m_rateCrit;
>                   m_rateChange (station->m_rate, station->m_state->m_address);
311c292
<                   station->m_critRateIndex = 0;
---
>                   station->m_rateCrit = 0;
315c296
<                   if (station->m_powerLevel != m_minPower)
---
>                   if (station->m_power != m_minPower)
317c298,299
<                       station->m_powerLevel -= m_powerDec;
---
>                       station->m_power -= m_powerDec;
>                       m_powerChange (station->m_power, station->m_state->m_address);
342,343c324,325
<   AparfWifiRemoteStation *station = static_cast<AparfWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   AparfWifiRemoteStation *station = (AparfWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
345a328
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
349,364c332
<   WifiMode mode = GetSupported (station, station->m_rateIndex);
<   DataRate rate = DataRate (mode.GetDataRate (channelWidth));
<   DataRate prevRate = DataRate (GetSupported (station, station->m_prevRateIndex).GetDataRate (channelWidth));
<   double power = GetPhy ()->GetPowerDbm (station->m_powerLevel);
<   double prevPower = GetPhy ()->GetPowerDbm (station->m_prevPowerLevel);
<   if (station->m_prevPowerLevel != station->m_powerLevel)
<     {
<       m_powerChange (prevPower, power, station->m_state->m_address);
<       station->m_prevPowerLevel = station->m_powerLevel;
<     }
<   if (station->m_prevRateIndex != station->m_rateIndex)
<     {
<       m_rateChange (prevRate, rate, station->m_state->m_address);
<       station->m_prevRateIndex = station->m_rateIndex;
<     }
<   return WifiTxVector (mode, station->m_powerLevel, GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, station->m_rate), station->m_power, GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
371c339
<   /// \todo we could/should implement the ARF algorithm for
---
>   /// \todo we could/should implement the Arf algorithm for
373,374c341,342
<   AparfWifiRemoteStation *station = static_cast<AparfWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   AparfWifiRemoteStation *station = (AparfWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
376a345
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
380d348
<   WifiMode mode;
383c351
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
387c355
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
389d356
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
390a358,384
> }
> 
> bool
> AparfWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
> }
> 
> void
> AparfWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> AparfWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/aparf-wifi-manager.h ../../ns-3-dev/src/wifi/model/aparf-wifi-manager.h
41,43c41,43
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
---
>  * This RAA does not support HT or VHT modes and will error exit
>  * if the user tries to configure this RAA with a Wi-Fi MAC that
>  * has VhtSupported or HtSupported set.
57c57,59
<   void SetupPhy (const Ptr<WifiPhy> phy);
---
>   virtual void SetupPhy (Ptr<WifiPhy> phy);
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
69d70
< 
71,85c72,86
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
---
>   //overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool IsLowLatency (void) const;
97,100c98,101
<   uint8_t m_powerInc;    //!< Step size for increment the power.
<   uint8_t m_powerDec;    //!< Step size for decrement the power.
<   uint8_t m_rateInc;     //!< Step size for increment the rate.
<   uint8_t m_rateDec;     //!< Step size for decrement the rate.
---
>   uint32_t m_powerInc;   //!< Step size for increment the power.
>   uint32_t m_powerDec;   //!< Step size for decrement the power.
>   uint32_t m_rateInc;    //!< Step size for increment the rate.
>   uint32_t m_rateDec;    //!< Step size for decrement the rate.
107c108
<   uint8_t m_minPower;
---
>   uint32_t m_minPower;  
112c113
<   uint8_t m_maxPower;
---
>   uint32_t m_maxPower;
115c116
<    * The trace source fired when the transmission power changes.
---
>    * The trace source fired when the transmission power change
117c118
<   TracedCallback<double, double, Mac48Address> m_powerChange;
---
>   TracedCallback<uint8_t, Mac48Address> m_powerChange;
119c120
<    * The trace source fired when the transmission rate changes.
---
>    * The trace source fired when the transmission rate change
121c122,123
<   TracedCallback<DataRate, DataRate, Mac48Address> m_rateChange;
---
>   TracedCallback<uint32_t, Mac48Address> m_rateChange;
> 
diff ../../NS3-WiGig/src/wifi/model/ap-wifi-mac.cc ../../ns-3-dev/src/wifi/model/ap-wifi-mac.cc
22a23,24
> #include "ap-wifi-mac.h"
> #include "ns3/assert.h"
24d25
< #include "ns3/packet.h"
26d26
< #include "ns3/pointer.h"
28,31c28,31
< #include "ns3/random-variable-stream.h"
< #include "ap-wifi-mac.h"
< #include "mac-low.h"
< #include "mac-tx-middle.h"
---
> #include "ns3/pointer.h"
> #include "ns3/boolean.h"
> #include "wifi-phy.h"
> #include "dcf-manager.h"
32a33
> #include "mac-tx-middle.h"
34c35
< #include "msdu-aggregator.h"
---
> #include "mac-low.h"
36,39c37
< #include "wifi-phy.h"
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "he-configuration.h"
---
> #include "msdu-aggregator.h"
51c49
<     .SetParent<InfrastructureWifiMac> ()
---
>     .SetParent<RegularWifiMac> ()
60,64d57
<     .AddAttribute ("CfpMaxDuration", "The maximum size of the CFP (used when AP supports PCF)",
<                    TimeValue (MicroSeconds (51200)),
<                    MakeTimeAccessor (&ApWifiMac::GetCfpMaxDuration,
<                                      &ApWifiMac::SetCfpMaxDuration),
<                    MakeTimeChecker ())
73c66
<                    BooleanValue (true),
---
>                    BooleanValue (false),
79c72,73
<                    MakeBooleanAccessor (&ApWifiMac::SetBeaconGeneration),
---
>                    MakeBooleanAccessor (&ApWifiMac::SetBeaconGeneration,
>                                         &ApWifiMac::GetBeaconGeneration),
86,90d79
<     .AddAttribute ("RifsMode", "If non-HT STAs are detected, whether to force RIFS to be disabled within the BSS."
<                    "This parameter is only used when HT is supported by the AP.",
<                    BooleanValue (true),
<                    MakeBooleanAccessor (&ApWifiMac::m_disableRifs),
<                    MakeBooleanChecker ())
96d84
<   : m_enableBeaconGeneration (false)
99,107c87,93
<   m_beaconTxop = CreateObject<Txop> ();
<   m_beaconTxop->SetAifsn (1);
<   m_beaconTxop->SetMinCw (0);
<   m_beaconTxop->SetMaxCw (0);
<   m_beaconTxop->SetMacLow (m_low);
<   m_beaconTxop->SetChannelAccessManager (m_channelAccessManager);
<   m_beaconTxop->SetTxMiddle (m_txMiddle);
<   m_beaconTxop->SetTxOkCallback (MakeCallback (&ApWifiMac::TxOk, this));
<   m_rxMiddle->SetPcfCallback (MakeCallback (&ApWifiMac::SendNextCfFrame, this));
---
>   m_beaconDca = CreateObject<DcaTxop> ();
>   m_beaconDca->SetAifsn (1);
>   m_beaconDca->SetMinCw (0);
>   m_beaconDca->SetMaxCw (0);
>   m_beaconDca->SetLow (m_low);
>   m_beaconDca->SetManager (m_dcfManager);
>   m_beaconDca->SetTxMiddle (m_txMiddle);
112c98
<   m_itCfPollingList = m_cfPollingList.begin ();
---
>   m_enableBeaconGeneration = false;
118c104
<   m_staList.clear ();
---
>   m_staList.clear();
121d106
<   m_cfPollingList.clear ();
128,129c113
<   m_beaconTxop->Dispose ();
<   m_beaconTxop = 0;
---
>   m_beaconDca = 0;
132d115
<   m_cfpEvent.Cancel ();
161,162c144,145
< Time
< ApWifiMac::GetBeaconInterval (void) const
---
> bool
> ApWifiMac::GetBeaconGeneration (void) const
165c148
<   return m_low->GetBeaconInterval ();
---
>   return m_enableBeaconGeneration;
169c152
< ApWifiMac::GetCfpMaxDuration (void) const
---
> ApWifiMac::GetBeaconInterval (void) const
172c155
<   return m_low->GetCfpMaxDuration ();
---
>   return m_beaconInterval;
176c159
< ApWifiMac::SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> stationManager)
---
> ApWifiMac::SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> stationManager)
179c162
<   m_beaconTxop->SetWifiRemoteStationManager (stationManager);
---
>   m_beaconDca->SetWifiRemoteStationManager (stationManager);
181d163
<   m_stationManager->SetPcfSupported (GetPcfSupported ());
202,206c184
<       NS_FATAL_ERROR ("beacon interval should be multiple of 1024us (802.11 time unit), see IEEE Std. 802.11-2012");
<     }
<   if (interval.GetMicroSeconds () > (1024 * 65535))
<     {
<       NS_FATAL_ERROR ("beacon interval should be smaller then or equal to 65535 * 1024us (802.11 time unit)");
---
>       NS_LOG_WARN ("beacon interval should be multiple of 1024us (802.11 time unit), see IEEE Std. 802.11-2012");
208c186
<   m_low->SetBeaconInterval (interval);
---
>   m_beaconInterval = interval;
212c190
< ApWifiMac::SetCfpMaxDuration (Time duration)
---
> ApWifiMac::StartBeaconing (void)
214,219c192,193
<   NS_LOG_FUNCTION (this << duration);
<   if ((duration.GetMicroSeconds () % 1024) != 0)
<     {
<       NS_LOG_WARN ("CFP max duration should be multiple of 1024us (802.11 time unit)");
<     }
<   m_low->SetCfpMaxDuration (duration);
---
>   NS_LOG_FUNCTION (this);
>   SendOneBeacon ();
237c211
<   if (GetErpSupported () && GetShortSlotTimeSupported ())
---
>   if (m_erpSupported == true && GetShortSlotTimeSupported () == true)
239,245c213,219
<       for (std::map<uint16_t, Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); i++)
<         {
<           if (!m_stationManager->GetShortSlotTimeSupported (i->second))
<             {
<               return false;
<             }
<         }
---
>       for (std::list<Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); i++)
>       {
>         if (m_stationManager->GetShortSlotTimeSupported (*i) == false)
>           {
>             return false;
>           }
>       }
254c228
<   if (GetErpSupported () && m_phy->GetShortPhyPreambleSupported ())
---
>   if (m_erpSupported || m_phy->GetShortPlcpPreambleSupported ())
257,262c231,236
<         {
<           if (!m_stationManager->GetShortPreambleSupported (*i))
<             {
<               return false;
<             }
<         }
---
>       {
>         if (m_stationManager->GetShortPreambleSupported (*i) == false)
>           {
>             return false;
>           }
>       }
268,300d241
< bool
< ApWifiMac::IsNonGfHtStasPresent (void) const
< {
<   bool isNonGfHtStasPresent = false;
<   for (std::map<uint16_t, Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); i++)
<     {
<       if (!m_stationManager->GetGreenfieldSupported (i->second))
<         {
<           isNonGfHtStasPresent = true;
<           break;
<         }
<     }
<   m_stationManager->SetUseGreenfieldProtection (isNonGfHtStasPresent);
<   return isNonGfHtStasPresent;
< }
< 
< uint16_t
< ApWifiMac::GetVhtOperationalChannelWidth (void) const
< {
<   uint16_t channelWidth = m_phy->GetChannelWidth ();
<   for (std::map<uint16_t, Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); i++)
<     {
<       if (m_stationManager->GetVhtSupported (i->second))
<         {
<           if (m_stationManager->GetChannelWidthSupported (i->second) < channelWidth)
<             {
<               channelWidth = m_stationManager->GetChannelWidthSupported (i->second);
<             }
<         }
<     }
<   return channelWidth;
< }
< 
302c243
< ApWifiMac::ForwardDown (Ptr<Packet> packet, Mac48Address from,
---
> ApWifiMac::ForwardDown (Ptr<const Packet> packet, Mac48Address from,
312c253
<   if (GetQosSupported ())
---
>   if (m_qosSupported)
328c269
< ApWifiMac::ForwardDown (Ptr<Packet> packet, Mac48Address from,
---
> ApWifiMac::ForwardDown (Ptr<const Packet> packet, Mac48Address from,
331c272
<   NS_LOG_FUNCTION (this << packet << from << to << +tid);
---
>   NS_LOG_FUNCTION (this << packet << from << to << static_cast<uint32_t> (tid));
339c280
<   if (GetQosSupported ())
---
>   if (m_qosSupported)
352c293
<       hdr.SetType (WIFI_MAC_DATA);
---
>       hdr.SetTypeData ();
355c296
<   if (GetQosSupported ())
---
>   if (m_htSupported || m_vhtSupported)
357c298
<       hdr.SetNoOrder (); // explicitly set to 0 for the time being since HT control field is not yet implemented (set it to 1 when implemented)
---
>       hdr.SetNoOrder ();
365c306
<   if (GetQosSupported ())
---
>   if (m_qosSupported)
373c314
<       m_txop->Queue (packet, hdr);
---
>       m_dca->Queue (packet, hdr);
378c319
< ApWifiMac::Enqueue (Ptr<Packet> packet, Mac48Address to, Mac48Address from)
---
> ApWifiMac::Enqueue (Ptr<const Packet> packet, Mac48Address to, Mac48Address from)
385,388d325
<   else
<     {
<       NotifyTxDrop (packet);
<     }
392c329
< ApWifiMac::Enqueue (Ptr<Packet> packet, Mac48Address to)
---
> ApWifiMac::Enqueue (Ptr<const Packet> packet, Mac48Address to)
412a350,362
>   //If it is an HT-AP or VHT-AP, then add the BSSMembershipSelectorSet
>   //The standard says that the BSSMembershipSelectorSet
>   //must have its MSB set to 1 (must be treated as a Basic Rate)
>   //Also the standard mentioned that at least 1 element should be included in the SupportedRates the rest can be in the ExtendedSupportedRates
>   if (m_htSupported || m_vhtSupported)
>     {
>       for (uint32_t i = 0; i < m_phy->GetNBssMembershipSelectors (); i++)
>         {
>           rates.AddBssMembershipSelectorRate (m_phy->GetBssMembershipSelector (i));
>         }
>     }
>   // 
>   uint8_t nss = 1;  // Number of spatial streams is 1 for non-MIMO modes
415c365
<   for (uint8_t i = 0; i < m_phy->GetNModes (); i++)
---
>   for (uint32_t i = 0; i < m_phy->GetNModes (); i++)
418c368
<       uint64_t modeDataRate = mode.GetDataRate (m_phy->GetChannelWidth ());
---
>       uint64_t modeDataRate = mode.GetDataRate (m_phy->GetChannelWidth (), false, nss);
431c381
<   for (uint8_t j = 0; j < m_stationManager->GetNBasicModes (); j++)
---
>   for (uint32_t j = 0; j < m_stationManager->GetNBasicModes (); j++)
434c384
<       uint64_t modeDataRate = mode.GetDataRate (m_phy->GetChannelWidth ());
---
>       uint64_t modeDataRate = mode.GetDataRate (m_phy->GetChannelWidth (), false, nss);
438,448c388
<   //If it is a HT AP, then add the BSSMembershipSelectorSet
<   //The standard says that the BSSMembershipSelectorSet
<   //must have its MSB set to 1 (must be treated as a Basic Rate)
<   //Also the standard mentioned that at least 1 element should be included in the SupportedRates the rest can be in the ExtendedSupportedRates
<   if (GetHtSupported ())
<     {
<       for (uint8_t i = 0; i < m_phy->GetNBssMembershipSelectors (); i++)
<         {
<           rates.AddBssMembershipSelectorRate (m_phy->GetBssMembershipSelector (i));
<         }
<     }
---
> 
452c392
< Ptr<DsssParameterSet>
---
> DsssParameterSet
455,457c395,396
<   NS_LOG_FUNCTION (this);
<   Ptr<DsssParameterSet> dsssParameters = Create<DsssParameterSet> ();
<   if (GetDsssSupported ())
---
>   DsssParameterSet dsssParameters;
>   if (m_dsssSupported)
459,460c398,399
<       dsssParameters->SetDsssSupported (1);
<       dsssParameters->SetCurrentChannel (m_phy->GetChannelNumber ());
---
>       dsssParameters.SetDsssSupported (1);
>       dsssParameters.SetCurrentChannel (m_phy->GetChannelNumber ());
468d406
<   NS_LOG_FUNCTION (this);
472,476d409
<   capabilities.SetEss ();
<   if (GetPcfSupported ())
<     {
<       capabilities.SetCfPollable ();
<     }
480c413
< Ptr<ErpInformation>
---
> ErpInformation
483,486c416,418
<   NS_LOG_FUNCTION (this);
<   Ptr<ErpInformation> information = Create<ErpInformation> ();
<   information->SetErpSupported (1);
<   if (GetErpSupported ())
---
>   ErpInformation information;
>   information.SetErpSupported (1);
>   if (m_erpSupported)
488,489c420,421
<       information->SetNonErpPresent (!m_nonErpStations.empty ());
<       information->SetUseProtection (GetUseNonErpProtection ());
---
>       information.SetNonErpPresent (!m_nonErpStations.empty ());
>       information.SetUseProtection (GetUseNonErpProtection ());
492c424
<           information->SetBarkerPreambleMode (0);
---
>           information.SetBarkerPreambleMode (0);
496c428
<           information->SetBarkerPreambleMode (1);
---
>           information.SetBarkerPreambleMode (1);
502c434
< Ptr<EdcaParameterSet>
---
> EdcaParameterSet
505,507c437,439
<   NS_LOG_FUNCTION (this);
<   Ptr<EdcaParameterSet> edcaParameters = Create<EdcaParameterSet> ();
<   if (GetQosSupported ())
---
>   EdcaParameterSet edcaParameters;
>   edcaParameters.SetQosSupported (1);
>   if (m_qosSupported)
509,510c441
<       edcaParameters->SetQosSupported (1);
<       Ptr<QosTxop> edca;
---
>       Ptr<EdcaTxopN> edca;
515,520c446,451
<       edcaParameters->SetBeAci (0);
<       edcaParameters->SetBeCWmin (edca->GetMinCw ());
<       edcaParameters->SetBeCWmax (edca->GetMaxCw ());
<       edcaParameters->SetBeAifsn (edca->GetAifsn ());
<       edcaParameters->SetBeTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
< 
---
>       edcaParameters.SetBeAci(0);
>       edcaParameters.SetBeCWmin(edca->GetMinCw ());
>       edcaParameters.SetBeCWmax(edca->GetMaxCw ());
>       edcaParameters.SetBeAifsn(edca->GetAifsn ());
>       edcaParameters.SetBeTXOPLimit(txopLimit.GetMicroSeconds () / 32);
>       
523,528c454,459
<       edcaParameters->SetBkAci (1);
<       edcaParameters->SetBkCWmin (edca->GetMinCw ());
<       edcaParameters->SetBkCWmax (edca->GetMaxCw ());
<       edcaParameters->SetBkAifsn (edca->GetAifsn ());
<       edcaParameters->SetBkTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
< 
---
>       edcaParameters.SetBkAci(1);
>       edcaParameters.SetBkCWmin(edca->GetMinCw ());
>       edcaParameters.SetBkCWmax(edca->GetMaxCw ());
>       edcaParameters.SetBkAifsn(edca->GetAifsn ());
>       edcaParameters.SetBkTXOPLimit(txopLimit.GetMicroSeconds () / 32);
>       
531,536c462,467
<       edcaParameters->SetViAci (2);
<       edcaParameters->SetViCWmin (edca->GetMinCw ());
<       edcaParameters->SetViCWmax (edca->GetMaxCw ());
<       edcaParameters->SetViAifsn (edca->GetAifsn ());
<       edcaParameters->SetViTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
< 
---
>       edcaParameters.SetViAci(2);
>       edcaParameters.SetViCWmin(edca->GetMinCw ());
>       edcaParameters.SetViCWmax(edca->GetMaxCw ());
>       edcaParameters.SetViAifsn(edca->GetAifsn ());
>       edcaParameters.SetViTXOPLimit(txopLimit.GetMicroSeconds () / 32);
>       
539,545c470,474
<       edcaParameters->SetVoAci (3);
<       edcaParameters->SetVoCWmin (edca->GetMinCw ());
<       edcaParameters->SetVoCWmax (edca->GetMaxCw ());
<       edcaParameters->SetVoAifsn (edca->GetAifsn ());
<       edcaParameters->SetVoTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
< 
<       edcaParameters->SetQosInfo (0);
---
>       edcaParameters.SetVoAci(3);
>       edcaParameters.SetVoCWmin(edca->GetMinCw ());
>       edcaParameters.SetVoCWmax(edca->GetMaxCw ());
>       edcaParameters.SetVoAifsn(edca->GetAifsn ());
>       edcaParameters.SetVoTXOPLimit(txopLimit.GetMicroSeconds () / 32);
550,551c479,480
< Ptr<CfParameterSet>
< ApWifiMac::GetCfParameterSet (void) const
---
> HtOperations
> ApWifiMac::GetHtOperations (void) const
553,554c482,484
<   Ptr<CfParameterSet> cfParameterSet = Create<CfParameterSet> ();
<   if (GetPcfSupported () && !m_cfPollingList.empty ())
---
>   HtOperations operations;
>   operations.SetHtSupported (1);
>   if (m_htSupported)
556,576c486
<       cfParameterSet->SetPcfSupported (1);
<       cfParameterSet->SetCFPCount (0);
<       cfParameterSet->SetCFPPeriod (1);
<       cfParameterSet->SetCFPMaxDurationUs (GetCfpMaxDuration ().GetMicroSeconds ());
<       cfParameterSet->SetCFPDurRemainingUs (GetCfpMaxDuration ().GetMicroSeconds ());
<     }
<   return cfParameterSet;
< }
< 
< Ptr<HtOperation>
< ApWifiMac::GetHtOperation (void) const
< {
<   NS_LOG_FUNCTION (this);
<   Ptr<HtOperation> operation = Create<HtOperation> ();
<   if (GetHtSupported ())
<     {
<       operation->SetHtSupported (1);
<       operation->SetPrimaryChannel (m_phy->GetChannelNumber ());
<       operation->SetRifsMode (GetRifsMode ());
<       operation->SetNonGfHtStasPresent (IsNonGfHtStasPresent ());
<       if (m_phy->GetChannelWidth () > 20)
---
>       if (!m_nonHtStations.empty ())
578,583c488
<           operation->SetSecondaryChannelOffset (1);
<           operation->SetStaChannelWidth (1);
<         }
<       if (m_nonHtStations.empty ())
<         {
<           operation->SetHtProtection (NO_PROTECTION);
---
>           operations.SetHtProtection (MIXED_MODE_PROTECTION);
587,695c492
<           operation->SetHtProtection (MIXED_MODE_PROTECTION);
<         }
<       uint64_t maxSupportedRate = 0; //in bit/s
<       for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<         {
<           WifiMode mcs = m_phy->GetMcs (i);
<           if (mcs.GetModulationClass () != WIFI_MOD_CLASS_HT)
<             {
<               continue;
<             }
<           uint8_t nss = (mcs.GetMcsValue () / 8) + 1;
<           NS_ASSERT (nss > 0 && nss < 5);
<           uint64_t dataRate = mcs.GetDataRate (m_phy->GetChannelWidth (), GetHtConfiguration ()->GetShortGuardIntervalSupported () ? 400 : 800, nss);
<           if (dataRate > maxSupportedRate)
<             {
<               maxSupportedRate = dataRate;
<               NS_LOG_DEBUG ("Updating maxSupportedRate to " << maxSupportedRate);
<             }
<         }
<       uint8_t maxSpatialStream = m_phy->GetMaxSupportedTxSpatialStreams ();
<       uint8_t nMcs = m_phy->GetNMcs ();
<       for (std::map<uint16_t, Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); i++)
<         {
<           if (m_stationManager->GetHtSupported (i->second))
<             {
<               uint64_t maxSupportedRateByHtSta = 0; //in bit/s
<               for (uint8_t j = 0; j < (std::min (nMcs, m_stationManager->GetNMcsSupported (i->second))); j++)
<                 {
<                   WifiMode mcs = m_phy->GetMcs (j);
<                   if (mcs.GetModulationClass () != WIFI_MOD_CLASS_HT)
<                     {
<                       continue;
<                     }
<                   uint8_t nss = (mcs.GetMcsValue () / 8) + 1;
<                   NS_ASSERT (nss > 0 && nss < 5);
<                   uint64_t dataRate = mcs.GetDataRate (m_stationManager->GetChannelWidthSupported (i->second), m_stationManager->GetShortGuardIntervalSupported (i->second) ? 400 : 800, nss);
<                   if (dataRate > maxSupportedRateByHtSta)
<                     {
<                       maxSupportedRateByHtSta = dataRate;
<                     }
<                 }
<               if (maxSupportedRateByHtSta < maxSupportedRate)
<                 {
<                   maxSupportedRate = maxSupportedRateByHtSta;
<                 }
<               if (m_stationManager->GetNMcsSupported (i->second) < nMcs)
<                 {
<                   nMcs = m_stationManager->GetNMcsSupported (i->second);
<                 }
<               if (m_stationManager->GetNumberOfSupportedStreams (i->second) < maxSpatialStream)
<                 {
<                   maxSpatialStream = m_stationManager->GetNumberOfSupportedStreams (i->second);
<                 }
<             }
<         }
<       operation->SetRxHighestSupportedDataRate (static_cast<uint16_t> (maxSupportedRate / 1e6)); //in Mbit/s
<       operation->SetTxMcsSetDefined (nMcs > 0);
<       operation->SetTxMaxNSpatialStreams (maxSpatialStream);
<       //To be filled in once supported
<       operation->SetObssNonHtStasPresent (0);
<       operation->SetDualBeacon (0);
<       operation->SetDualCtsProtection (0);
<       operation->SetStbcBeacon (0);
<       operation->SetLSigTxopProtectionFullSupport (0);
<       operation->SetPcoActive (0);
<       operation->SetPhase (0);
<       operation->SetRxMcsBitmask (0);
<       operation->SetTxRxMcsSetUnequal (0);
<       operation->SetTxUnequalModulation (0);
<     }
<   return operation;
< }
< 
< Ptr<VhtOperation>
< ApWifiMac::GetVhtOperation (void) const
< {
<   NS_LOG_FUNCTION (this);
<   Ptr<VhtOperation> operation = Create<VhtOperation> ();
<   if (GetVhtSupported ())
<     {
<       operation->SetVhtSupported (1);
<       uint16_t channelWidth = GetVhtOperationalChannelWidth ();
<       if (channelWidth == 160)
<         {
<           operation->SetChannelWidth (2);
<         }
<       else if (channelWidth == 80)
<         {
<           operation->SetChannelWidth (1);
<         }
<       else
<         {
<           operation->SetChannelWidth (0);
<         }
<       uint8_t maxSpatialStream = m_phy->GetMaxSupportedRxSpatialStreams ();
<       for (std::map<uint16_t, Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); i++)
<         {
<           if (m_stationManager->GetVhtSupported (i->second))
<             {
<               if (m_stationManager->GetNumberOfSupportedStreams (i->second) < maxSpatialStream)
<                 {
<                   maxSpatialStream = m_stationManager->GetNumberOfSupportedStreams (i->second);
<                 }
<             }
<         }
<       for (uint8_t nss = 1; nss <= maxSpatialStream; nss++)
<         {
<           uint8_t maxMcs = 9; //TBD: hardcode to 9 for now since we assume all MCS values are supported
<           operation->SetMaxVhtMcsPerNss (nss, maxMcs);
---
>           operations.SetHtProtection (NO_PROTECTION);
698,728c495
<   return operation;
< }
< 
< Ptr<HeOperation>
< ApWifiMac::GetHeOperation (void) const
< {
<   NS_LOG_FUNCTION (this);
<   Ptr<HeOperation> operation = Create<HeOperation> ();
<   if (GetHeSupported ())
<     {
<       operation->SetHeSupported (1);
<       uint8_t maxSpatialStream = m_phy->GetMaxSupportedRxSpatialStreams ();
<       for (std::map<uint16_t, Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); i++)
<         {
<           if (m_stationManager->GetHeSupported (i->second))
<             {
<               if (m_stationManager->GetNumberOfSupportedStreams (i->second) < maxSpatialStream)
<                 {
<                   maxSpatialStream = m_stationManager->GetNumberOfSupportedStreams (i->second);
<                 }
<             }
<         }
<       for (uint8_t nss = 1; nss <= maxSpatialStream; nss++)
<         {
<           operation->SetMaxHeMcsPerNss (nss, 11); //TBD: hardcode to 11 for now since we assume all MCS values are supported
<         }
<       UintegerValue bssColor;
<       GetHeConfiguration ()->GetAttribute ("BssColor", bssColor);
<       operation->SetBssColor (bssColor.Get ());
<     }
<   return operation;
---
>   return operations;
736c503
<   hdr.SetType (WIFI_MAC_MGT_PROBE_RESPONSE);
---
>   hdr.SetProbeResp ();
746c513
<   probe.SetBeaconIntervalUs (GetBeaconInterval ().GetMicroSeconds ());
---
>   probe.SetBeaconIntervalUs (m_beaconInterval.GetMicroSeconds ());
750,754c517
<   if (GetDsssSupported ())
<     {
<       probe.AddWifiInformationElement (GetDsssParameterSet ());
<     }
<   if (GetErpSupported ())
---
>   if (m_dsssSupported)
756c519
<       probe.AddWifiInformationElement (GetErpInformation ());
---
>       probe.SetDsssParameterSet (GetDsssParameterSet ());
758c521
<   if (GetQosSupported ())
---
>   if (m_erpSupported)
760c523
<       probe.AddWifiInformationElement (GetEdcaParameterSet ());
---
>       probe.SetErpInformation (GetErpInformation ());
762c525
<   if (GetHtSupported ())
---
>   if (m_qosSupported)
764,766c527
<       probe.AddWifiInformationElement (GetExtendedCapabilities ());
<       probe.AddWifiInformationElement (GetHtCapabilities ());
<       probe.AddWifiInformationElement (GetHtOperation ());
---
>       probe.SetEdcaParameterSet (GetEdcaParameterSet ());
768c529
<   if (GetVhtSupported ())
---
>   if (m_htSupported || m_vhtSupported)
770,771c531,533
<       probe.AddWifiInformationElement (GetVhtCapabilities ());
<       probe.AddWifiInformationElement (GetVhtOperation ());
---
>       probe.SetHtCapabilities (GetHtCapabilities ());
>       probe.SetHtOperations (GetHtOperations ());
>       hdr.SetNoOrder ();
773c535
<   if (GetHeSupported ())
---
>   if (m_vhtSupported)
775,776c537
<       probe.AddWifiInformationElement (GetHeCapabilities ());
<       probe.AddWifiInformationElement (GetHeOperation ());
---
>       probe.SetVhtCapabilities (GetVhtCapabilities ());
784c545
<   m_txop->Queue (packet, hdr);
---
>   m_dca->Queue (packet, hdr);
788c549
< ApWifiMac::SendAssocResp (Mac48Address to, bool success, bool isReassoc)
---
> ApWifiMac::SendAssocResp (Mac48Address to, bool success)
790c551
<   NS_LOG_FUNCTION (this << to << success << isReassoc);
---
>   NS_LOG_FUNCTION (this << to << success);
792c553
<   hdr.SetType (isReassoc ? WIFI_MAC_MGT_REASSOCIATION_RESPONSE : WIFI_MAC_MGT_ASSOCIATION_RESPONSE);
---
>   hdr.SetAssocResp ();
804,823c565
<       uint16_t aid = 0;
<       bool found = false;
<       if (isReassoc)
<         {
<           for (std::map<uint16_t, Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); ++i)
<             {
<               if (i->second == to)
<                 {
<                   aid = i->first;
<                   found = true;
<                   break;
<                 }
<             }
<         }
<       if (!found)
<         {
<           aid = GetNextAssociationId ();
<           m_staList.insert (std::make_pair (aid, to));
<         }
<       assoc.SetAssociationId (aid);
---
>       m_staList.push_back (to);
832c574
<   if (GetErpSupported ())
---
>   if (m_erpSupported)
834c576
<       assoc.AddWifiInformationElement (GetErpInformation ());
---
>       assoc.SetErpInformation (GetErpInformation ());
836c578
<   if (GetQosSupported ())
---
>   if (m_qosSupported)
838c580
<       assoc.AddWifiInformationElement (GetEdcaParameterSet ());
---
>       assoc.SetEdcaParameterSet (GetEdcaParameterSet ());
840c582
<   if (GetHtSupported ())
---
>   if (m_htSupported || m_vhtSupported)
842,844c584,586
<       assoc.AddWifiInformationElement (GetExtendedCapabilities ());
<       assoc.AddWifiInformationElement (GetHtCapabilities ());
<       assoc.AddWifiInformationElement (GetHtOperation ());
---
>       assoc.SetHtCapabilities (GetHtCapabilities ());
>       assoc.SetHtOperations (GetHtOperations ());
>       hdr.SetNoOrder ();
846c588
<   if (GetVhtSupported ())
---
>   if (m_vhtSupported)
848,854c590
<       assoc.AddWifiInformationElement (GetVhtCapabilities ());
<       assoc.AddWifiInformationElement (GetVhtOperation ());
<     }
<   if (GetHeSupported ())
<     {
<       assoc.AddWifiInformationElement (GetHeCapabilities ());
<       assoc.AddWifiInformationElement (GetHeOperation ());
---
>       assoc.SetVhtCapabilities (GetVhtCapabilities ());
862c598
<   m_txop->Queue (packet, hdr);
---
>   m_dca->Queue (packet, hdr);
870c606
<   hdr.SetType (WIFI_MAC_MGT_BEACON);
---
>   hdr.SetBeacon ();
880c616
<   beacon.SetBeaconIntervalUs (GetBeaconInterval ().GetMicroSeconds ());
---
>   beacon.SetBeaconIntervalUs (m_beaconInterval.GetMicroSeconds ());
884,888c620
<   if (GetPcfSupported ())
<     {
<       beacon.AddWifiInformationElement (GetCfParameterSet ());
<     }
<   if (GetDsssSupported ())
---
>   if (m_dsssSupported)
890c622
<       beacon.AddWifiInformationElement (GetDsssParameterSet ());
---
>       beacon.SetDsssParameterSet (GetDsssParameterSet ());
892c624
<   if (GetErpSupported ())
---
>   if (m_erpSupported)
894c626
<       beacon.AddWifiInformationElement (GetErpInformation ());
---
>       beacon.SetErpInformation (GetErpInformation ());
896c628
<   if (GetQosSupported ())
---
>   if (m_qosSupported)
898c630
<       beacon.AddWifiInformationElement (GetEdcaParameterSet ());
---
>       beacon.SetEdcaParameterSet (GetEdcaParameterSet ());
900c632
<   if (GetHtSupported ())
---
>   if (m_htSupported || m_vhtSupported)
902,904c634,636
<       beacon.AddWifiInformationElement (GetExtendedCapabilities ());
<       beacon.AddWifiInformationElement (GetHtCapabilities ());
<       beacon.AddWifiInformationElement (GetHtOperation ());
---
>       beacon.SetHtCapabilities (GetHtCapabilities ());
>       beacon.SetHtOperations (GetHtOperations ());
>       hdr.SetNoOrder ();
906c638
<   if (GetVhtSupported ())
---
>   if (m_vhtSupported)
908,918c640
<       beacon.AddWifiInformationElement (GetVhtCapabilities ());
<       beacon.AddWifiInformationElement (GetVhtOperation ());
<     }
<   if (GetHeSupported ())
<     {
<       beacon.AddWifiInformationElement (GetHeCapabilities ());
<       beacon.AddWifiInformationElement (GetHeOperation ());
<     }
<   if (m_supportMultiBand)
<     {
<       beacon.AddWifiInformationElement (GetMultiBandElement ());
---
>       beacon.SetVhtCapabilities (GetVhtCapabilities ());
923,925c645,647
<   m_beaconTxop->Queue (packet, hdr);
<   m_beaconEvent = Simulator::Schedule (GetBeaconInterval (), &ApWifiMac::SendOneBeacon, this);
< 
---
>   m_beaconDca->Queue (packet, hdr);
>   m_beaconEvent = Simulator::Schedule (m_beaconInterval, &ApWifiMac::SendOneBeacon, this);
>   
929c651
<   if (GetErpSupported ())
---
>   if (m_erpSupported)
931,940c653,662
<       if (GetShortSlotTimeEnabled () == true)
<         {
<           //Enable short slot time
<           SetSlot (MicroSeconds (9));
<         }
<       else
<         {
<           //Disable short slot time
<           SetSlot (MicroSeconds (20));
<         }
---
>     if (GetShortSlotTimeEnabled () == true)
>       {
>         //Enable short slot time
>         SetSlot (MicroSeconds (9));
>       }
>     else
>       {
>         //Disable short slot time
>         SetSlot (MicroSeconds (20));
>       }
945,962c667
< ApWifiMac::SendNextCfFrame (void)
< {
<   if (!GetPcfSupported ())
<     {
<       return;
<     }
<   if (m_txop->CanStartNextPolling ())
<     {
<       SendCfPoll ();
<     }
<   else if (m_low->IsCfPeriod ())
<     {
<       SendCfEnd ();
<     }
< }
< 
< void
< ApWifiMac::SendCfPoll (void)
---
> ApWifiMac::TxOk (const WifiMacHeader &hdr)
965,975c670
<   NS_ASSERT (GetPcfSupported ());
<   m_txop->SendCfFrame (WIFI_MAC_DATA_NULL_CFPOLL, *m_itCfPollingList);
< }
< 
< void
< ApWifiMac::SendCfEnd (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_ASSERT (GetPcfSupported ());
<   m_txop->SendCfFrame (WIFI_MAC_CTL_END, Mac48Address::GetBroadcast ());
< }
---
>   RegularWifiMac::TxOk (hdr);
977,982c672
< void
< ApWifiMac::TxOk (Ptr<const Packet> packet, const WifiMacHeader &hdr)
< {
<   NS_LOG_FUNCTION (this);
<   RegularWifiMac::TxOk (packet, hdr);
<   if ((hdr.IsAssocResp () || hdr.IsReassocResp ())
---
>   if (hdr.IsAssocResp ()
988,1002d677
<   else if (hdr.IsBeacon () && GetPcfSupported ())
<     {
<       if (!m_cfPollingList.empty ())
<         {
<           SendCfPoll ();
<         }
<       else
<         {
<           SendCfEnd ();
<         }
<     }
<   else if (hdr.IsCfPoll ())
<     {
<       IncrementPollingListIterator ();
<     }
1011c686
<   if ((hdr.IsAssocResp () || hdr.IsReassocResp ())
---
>   if (hdr.IsAssocResp ()
1014c689
<       NS_LOG_DEBUG ("association failed with sta=" << hdr.GetAddr1 ());
---
>       NS_LOG_DEBUG ("assoc failed with sta=" << hdr.GetAddr1 ());
1017,1037d691
<   else if (hdr.IsCfPoll ())
<     {
<       IncrementPollingListIterator ();
<       SendNextCfFrame ();
<     }
< }
< 
< Ptr<MultiBandElement>
< ApWifiMac::GetMultiBandElement (void) const
< {
<   Ptr<MultiBandElement> multiband = Create<MultiBandElement> ();
<   multiband->SetStaRole (ROLE_AP);
<   multiband->SetStaMacAddressPresent (false); /* The same MAC address is used across all the bands */
<   multiband->SetBandID (Band_2_4GHz);
<   multiband->SetOperatingClass (18);          /* Europe */
<   multiband->SetChannelNumber (m_phy->GetChannelNumber ());
<   multiband->SetBssID (GetAddress ());
< //  multiband->SetBeaconInterval (m_beaconInterval.GetMicroSeconds ());
<   multiband->SetConnectionCapability (1);     /* AP */
<   multiband->SetFstSessionTimeout (m_fstTimeout);
<   return multiband;
1041c695
< ApWifiMac::Receive (Ptr<WifiMacQueueItem> mpdu)
---
> ApWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
1043,1045c697,698
<   NS_LOG_FUNCTION (this << *mpdu);
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
<   Ptr<const Packet> packet = mpdu->GetPacket ();
---
>   NS_LOG_FUNCTION (this << packet << hdr);
> 
1046a700
> 
1064c718
<                       DeaggregateAmsduAndForward (mpdu);
---
>                       DeaggregateAmsduAndForward (packet, hdr);
1072c726
<               else if (hdr->HasData ())
---
>               else
1088c742
<                   ForwardDown (copy, from, to, hdr->GetQosTid ());
---
>                   ForwardDown (packet, from, to, hdr->GetQosTid ());
1092c746
<                   ForwardDown (copy, from, to);
---
>                   ForwardDown (packet, from, to);
1094c748
<               ForwardUp (packet, from, to);
---
>               ForwardUp (copy, from, to);
1121,1128c775
<           MgtProbeRequestHeader probeRequestHeader;
<           packet->PeekHeader (probeRequestHeader);
<           Ssid ssid = probeRequestHeader.GetSsid ();
<           if (ssid == GetSsid () || ssid.IsBroadcast ())
<             {
<               NS_LOG_DEBUG ("Probe request received from " << from << ": send probe response");
<               SendProbeResp (from);
<             }
---
>           SendProbeResp (from);
1135d781
<               NS_LOG_DEBUG ("Association request received from " << from);
1139c785
<               packet->PeekHeader (assocReq);
---
>               packet->RemoveHeader (assocReq);
1141c787
<               m_stationManager->AddSupportedPhyPreamble (from, capabilities.IsShortPreamble ());
---
>               m_stationManager->AddSupportedPlcpPreamble (from, capabilities.IsShortPreamble ());
1148c794
<               for (uint8_t i = 0; i < m_stationManager->GetNBasicModes (); i++)
---
>               for (uint32_t i = 0; i < m_stationManager->GetNBasicModes (); i++)
1151c797,798
<                   if (!rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
---
>                   uint8_t nss = 1; // Assume 1 spatial stream in basic mode
>                   if (!rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth (), false, nss)))
1188c835
<               if (GetHtSupported ())
---
>               if (m_htSupported)
1191,1193c838,839
<                   Ptr<HtCapabilities> htcapabilities =
<                       StaticCast<HtCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_HT_CAPABILITIES, 0)));
<                   if (htcapabilities->IsSupportedMcs (0))
---
>                   HtCapabilities htcapabilities = assocReq.GetHtCapabilities ();
>                   if (htcapabilities.GetHtCapabilitiesInfo () != 0)
1196c842
<                       for (uint8_t i = 0; i < m_stationManager->GetNBasicMcs (); i++)
---
>                       for (uint32_t i = 0; i < m_stationManager->GetNBasicMcs (); i++)
1199c845
<                           if (!htcapabilities->IsSupportedMcs (mcs.GetMcsValue ()))
---
>                           if (!htcapabilities.IsSupportedMcs (mcs.GetMcsValue ()))
1207c853
<               if (GetVhtSupported ())
---
>               if (m_vhtSupported)
1210,1212c856,857
<                   Ptr<VhtCapabilities> vhtCapabilities =
<                       StaticCast<VhtCapabilities> (assocReq.GetInformationElement (std::make_pair(IE_VHT_CAPABILITIES,0)));
<                   if (vhtCapabilities->GetVhtCapabilitiesInfo () != 0)
---
>                   VhtCapabilities vhtcapabilities = assocReq.GetVhtCapabilities ();
>                   if (vhtcapabilities.GetVhtCapabilitiesInfo () != 0)
1214c859
<                       for (uint8_t i = 0; i < m_stationManager->GetNBasicMcs (); i++)
---
>                       for (uint32_t i = 0; i < m_stationManager->GetNBasicMcs (); i++)
1217,1235c862
<                           if (!vhtCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
<                             {
<                               problem = true;
<                               break;
<                             }
<                         }
<                     }
<                 }
<               if (GetHeSupported ())
<                 {
<                   //check whether the HE STA supports all MCSs in Basic MCS Set
<                   Ptr<HeCapabilities> hecapabilities =
<                       StaticCast<HeCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<                   if (hecapabilities->GetSupportedMcsAndNss () != 0)
<                     {
<                       for (uint8_t i = 0; i < m_stationManager->GetNBasicMcs (); i++)
<                         {
<                           WifiMode mcs = m_stationManager->GetBasicMcs (i);
<                           if (!hecapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
---
>                           if (!vhtcapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1245,1246c872,875
<                   NS_LOG_DEBUG ("One of the Basic Rate set mode is not supported by the station: send association response with an error status");
<                   SendAssocResp (hdr->GetAddr2 (), false, false);
---
>                   //One of the Basic Rate set mode is not
>                   //supported by the station. So, we return an assoc
>                   //response with an error status.
>                   SendAssocResp (hdr->GetAddr2 (), false);
1250c879
<                   NS_LOG_DEBUG ("The Basic Rate set modes are supported by the station");
---
>                   //station supports all rates in Basic Rate Set.
1252,1455c881
<                   for (uint8_t j = 0; j < m_phy->GetNModes (); j++)
<                     {
<                       WifiMode mode = m_phy->GetMode (j);
<                       if (rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
<                         {
<                           m_stationManager->AddSupportedMode (from, mode);
<                         }
<                     }
<                   if (GetPcfSupported () && capabilities.IsCfPollable ())
<                     {
<                       m_cfPollingList.push_back (from);
<                       if (m_itCfPollingList == m_cfPollingList.end ())
<                         {
<                           IncrementPollingListIterator ();
<                         }
<                     }
<                   if (GetHtSupported ())
<                     {
<                       Ptr<HtCapabilities> htCapabilities =
<                           StaticCast<HtCapabilities> (assocReq.GetInformationElement (std::make_pair(IE_HT_CAPABILITIES,0)));
<                       if (htCapabilities->IsSupportedMcs (0))
<                         {
<                           m_stationManager->AddStationHtCapabilities (from, htCapabilities);
<                         }
<                     }
<                   if (GetVhtSupported ())
<                     {
<                       Ptr<VhtCapabilities> vhtCapabilities =
<                           StaticCast<VhtCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_VHT_CAPABILITIES, 0)));
<                       //we will always fill in RxHighestSupportedLgiDataRate field at TX, so this can be used to check whether it supports VHT
<                       if (vhtCapabilities->GetRxHighestSupportedLgiDataRate () > 0)
<                         {
<                           m_stationManager->AddStationVhtCapabilities (from, vhtCapabilities);
<                           for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<                             {
<                               WifiMode mcs = m_phy->GetMcs (i);
<                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
<                                 {
<                                   m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
<                                   //here should add a control to add basic MCS when it is implemented
<                                 }
<                             }
<                         }
<                     }
<                   if (GetHtSupported ())
<                     {
<                       Ptr<ExtendedCapabilities> extendedCapabilities =
<                           StaticCast<ExtendedCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_EXTENDED_CAPABILITIES, 0)));
<                       //TODO: to be completed
<                     }
<                   if (GetHeSupported ())
<                     {
<                       Ptr<HeCapabilities> heCapabilities =
<                           StaticCast<HeCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<                       if (heCapabilities->GetSupportedMcsAndNss () != 0)
<                         {
<                           m_stationManager->AddStationHeCapabilities (from, heCapabilities);
<                           for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<                             {
<                               WifiMode mcs = m_phy->GetMcs (i);
<                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
<                                 {
<                                   m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
<                                   //here should add a control to add basic MCS when it is implemented
<                                 }
<                             }
<                         }
<                     }
<                   m_stationManager->RecordWaitAssocTxOk (from);
<                   if (!isHtStation)
<                     {
<                       m_nonHtStations.push_back (hdr->GetAddr2 ());
<                       m_nonHtStations.unique ();
<                     }
<                   if (!isErpStation && isDsssStation)
<                     {
<                       m_nonErpStations.push_back (hdr->GetAddr2 ());
<                       m_nonErpStations.unique ();
<                     }
<                   NS_LOG_DEBUG ("Send association response with success status");
<                   SendAssocResp (hdr->GetAddr2 (), true, false);
<                 }
<               return;
<             }
<           else if (hdr->IsReassocReq ())
<             {
<               NS_LOG_DEBUG ("Reassociation request received from " << from);
<               //first, verify that the the station's supported
<               //rate set is compatible with our Basic Rate set
<               MgtReassocRequestHeader reassocReq;
<               packet->PeekHeader (reassocReq);
<               CapabilityInformation capabilities = reassocReq.GetCapabilities ();
<               m_stationManager->AddSupportedPhyPreamble (from, capabilities.IsShortPreamble ());
<               SupportedRates rates = reassocReq.GetSupportedRates ();
<               bool problem = false;
<               bool isHtStation = false;
<               bool isOfdmStation = false;
<               bool isErpStation = false;
<               bool isDsssStation = false;
<               for (uint8_t i = 0; i < m_stationManager->GetNBasicModes (); i++)
<                 {
<                   WifiMode mode = m_stationManager->GetBasicMode (i);
<                   if (!rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
<                     {
<                       if ((mode.GetModulationClass () == WIFI_MOD_CLASS_DSSS) || (mode.GetModulationClass () == WIFI_MOD_CLASS_HR_DSSS))
<                         {
<                           isDsssStation = false;
<                         }
<                       else if (mode.GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM)
<                         {
<                           isErpStation = false;
<                         }
<                       else if (mode.GetModulationClass () == WIFI_MOD_CLASS_OFDM)
<                         {
<                           isOfdmStation = false;
<                         }
<                       if (isDsssStation == false && isErpStation == false && isOfdmStation == false)
<                         {
<                           problem = true;
<                           break;
<                         }
<                     }
<                   else
<                     {
<                       if ((mode.GetModulationClass () == WIFI_MOD_CLASS_DSSS) || (mode.GetModulationClass () == WIFI_MOD_CLASS_HR_DSSS))
<                         {
<                           isDsssStation = true;
<                         }
<                       else if (mode.GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM)
<                         {
<                           isErpStation = true;
<                         }
<                       else if (mode.GetModulationClass () == WIFI_MOD_CLASS_OFDM)
<                         {
<                           isOfdmStation = true;
<                         }
<                     }
<                 }
<               m_stationManager->AddSupportedErpSlotTime (from, capabilities.IsShortSlotTime () && isErpStation);
<               if (GetHtSupported ())
<                 {
<                   //check whether the HT STA supports all MCSs in Basic MCS Set
<                   Ptr<HtCapabilities> htcapabilities
<                       = StaticCast<HtCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_HT_CAPABILITIES,0)));
<                   if (htcapabilities->IsSupportedMcs (0))
<                     {
<                       isHtStation = true;
<                       for (uint8_t i = 0; i < m_stationManager->GetNBasicMcs (); i++)
<                         {
<                           WifiMode mcs = m_stationManager->GetBasicMcs (i);
<                           if (!htcapabilities->IsSupportedMcs (mcs.GetMcsValue ()))
<                             {
<                               problem = true;
<                               break;
<                             }
<                         }
<                     }
<                 }
<               if (GetVhtSupported ())
<                 {
<                   //check whether the VHT STA supports all MCSs in Basic MCS Set
<                   Ptr<VhtCapabilities> vhtcapabilities
<                       = StaticCast<VhtCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_VHT_CAPABILITIES,0)));
<                   if (vhtcapabilities->GetVhtCapabilitiesInfo () != 0)
<                     {
<                       for (uint8_t i = 0; i < m_stationManager->GetNBasicMcs (); i++)
<                         {
<                           WifiMode mcs = m_stationManager->GetBasicMcs (i);
<                           if (!vhtcapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
<                             {
<                               problem = true;
<                               break;
<                             }
<                         }
<                     }
<                 }
<               if (GetHeSupported ())
<                 {
<                   //check whether the HE STA supports all MCSs in Basic MCS Set
<                   Ptr<HeCapabilities> hecapabilities
<                       = StaticCast<HeCapabilities> (reassocReq.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<                   if (hecapabilities->GetSupportedMcsAndNss () != 0)
<                     {
<                       for (uint8_t i = 0; i < m_stationManager->GetNBasicMcs (); i++)
<                         {
<                           WifiMode mcs = m_stationManager->GetBasicMcs (i);
<                           if (!hecapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
<                             {
<                               problem = true;
<                               break;
<                             }
<                         }
<                     }
<                 }
<               if (problem)
<                 {
<                   NS_LOG_DEBUG ("One of the Basic Rate set mode is not supported by the station: send reassociation response with an error status");
<                   SendAssocResp (hdr->GetAddr2 (), false, true);
<                 }
<               else
<                 {
<                   NS_LOG_DEBUG ("The Basic Rate set modes are supported by the station");
<                   //update all its supported modes in its associated WifiRemoteStation
<                   for (uint8_t j = 0; j < m_phy->GetNModes (); j++)
---
>                   for (uint32_t j = 0; j < m_phy->GetNModes (); j++)
1458c884,885
<                       if (rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
---
>                       uint8_t nss = 1; // Assume 1 spatial stream in basic mode
>                       if (rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth (), false, nss)))
1463c890
<                   if (GetHtSupported ())
---
>                   if (m_htSupported)
1465,1467c892,894
<                       Ptr<HtCapabilities> htCapabilities
<                           = StaticCast<HtCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_HT_CAPABILITIES,0)));
<                       if (htCapabilities->IsSupportedMcs (0))
---
>                       HtCapabilities htcapabilities = assocReq.GetHtCapabilities ();
>                       m_stationManager->AddStationHtCapabilities (from, htcapabilities);
>                       for (uint32_t j = 0; j < m_phy->GetNMcs (); j++)
1469,1480c896,897
<                           m_stationManager->AddStationHtCapabilities (from, htCapabilities);
<                         }
<                     }
<                   if (GetVhtSupported ())
<                     {
<                       Ptr<VhtCapabilities> vhtCapabilities
<                           = StaticCast<VhtCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_VHT_CAPABILITIES,0)));
<                       //we will always fill in RxHighestSupportedLgiDataRate field at TX, so this can be used to check whether it supports VHT
<                       if (vhtCapabilities->GetRxHighestSupportedLgiDataRate () > 0)
<                         {
<                           m_stationManager->AddStationVhtCapabilities (from, vhtCapabilities);
<                           for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
---
>                           WifiMode mcs = m_phy->GetMcs (j);
>                           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HT && htcapabilities.IsSupportedMcs (mcs.GetMcsValue ()))
1482,1487c899
<                               WifiMode mcs = m_phy->GetMcs (i);
<                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
<                                 {
<                                   m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
<                                   //here should add a control to add basic MCS when it is implemented
<                                 }
---
>                               m_stationManager->AddSupportedMcs (from, mcs);
1491c903
<                   if (GetHtSupported ())
---
>                   if (m_vhtSupported)
1493,1501c905,907
<                       Ptr<ExtendedCapabilities> extendedCapabilities
<                           = StaticCast<ExtendedCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_EXTENDED_CAPABILITIES,0)));
<                       //TODO: to be completed
<                     }
<                   if (GetHeSupported ())
<                     {
<                       Ptr<HeCapabilities> heCapabilities
<                           = StaticCast<HeCapabilities> (reassocReq.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<                       if (heCapabilities->GetSupportedMcsAndNss () != 0)
---
>                       VhtCapabilities vhtCapabilities = assocReq.GetVhtCapabilities ();
>                       m_stationManager->AddStationVhtCapabilities (from, vhtCapabilities);
>                       for (uint32_t i = 0; i < m_phy->GetNMcs (); i++)
1503,1504c909,910
<                           m_stationManager->AddStationHeCapabilities (from, heCapabilities);
<                           for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
---
>                           WifiMode mcs = m_phy->GetMcs (i);
>                           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1506,1511c912,913
<                               WifiMode mcs = m_phy->GetMcs (i);
<                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
<                                 {
<                                   m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
<                                   //here should add a control to add basic MCS when it is implemented
<                                 }
---
>                               m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
>                               //here should add a control to add basic MCS when it is implemented
1519d920
<                       m_nonHtStations.unique ();
1524d924
<                       m_nonErpStations.unique ();
1526,1527c926,927
<                   NS_LOG_DEBUG ("Send reassociation response with success status");
<                   SendAssocResp (hdr->GetAddr2 (), true, true);
---
>                   // send assoc response with success status.
>                   SendAssocResp (hdr->GetAddr2 (), true);
1533d932
<               NS_LOG_DEBUG ("Disassociation received from " << from);
1535,1566c934,957
<               for (std::map<uint16_t, Mac48Address>::const_iterator j = m_staList.begin (); j != m_staList.end (); j++)
<                 {
<                   if (j->second == from)
<                     {
<                       m_staList.erase (j);
<                       break;
<                     }
<                 }
<               for (std::list<Mac48Address>::const_iterator j = m_nonErpStations.begin (); j != m_nonErpStations.end (); j++)
<                 {
<                   if ((*j) == from)
<                     {
<                       m_nonErpStations.erase (j);
<                       break;
<                     }
<                 }
<               for (std::list<Mac48Address>::const_iterator j = m_nonHtStations.begin (); j != m_nonHtStations.end (); j++)
<                 {
<                   if ((*j) == from)
<                     {
<                       m_nonHtStations.erase (j);
<                       break;
<                     }
<                 }
<               for (std::list<Mac48Address>::const_iterator j = m_cfPollingList.begin (); j != m_cfPollingList.end (); ++j)
<                 {
<                   if ((*j) == from)
<                     {
<                       m_cfPollingList.erase (j);
<                       break;
<                     }
<                 }
---
>               for (std::list<Mac48Address>::iterator i = m_staList.begin (); i != m_staList.end (); i++)
>               {
>                 if ((*i) == from)
>                   {
>                     m_staList.erase (i);
>                     break;
>                   }
>               }
>               for (std::list<Mac48Address>::iterator j = m_nonErpStations.begin (); j != m_nonErpStations.end (); j++)
>               {
>                 if ((*j) == from)
>                   {
>                     m_nonErpStations.erase (j);
>                     break;
>                   }
>               }
>               for (std::list<Mac48Address>::iterator j = m_nonHtStations.begin (); j != m_nonHtStations.end (); j++)
>               {
>                 if ((*j) == from)
>                   {
>                     m_nonHtStations.erase (j);
>                     break;
>                   }
>               }
1575c966
<   RegularWifiMac::Receive (Create<WifiMacQueueItem> (packet, *hdr));
---
>   RegularWifiMac::Receive (packet, hdr);
1579c970,971
< ApWifiMac::DeaggregateAmsduAndForward (Ptr<WifiMacQueueItem> mpdu)
---
> ApWifiMac::DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket,
>                                        const WifiMacHeader *hdr)
1581,1582c973,978
<   NS_LOG_FUNCTION (this << *mpdu);
<   for (auto& i : *PeekPointer (mpdu))
---
>   NS_LOG_FUNCTION (this << aggregatedPacket << hdr);
>   MsduAggregator::DeaggregatedMsdus packets =
>     MsduAggregator::Deaggregate (aggregatedPacket);
> 
>   for (MsduAggregator::DeaggregatedMsdusCI i = packets.begin ();
>        i != packets.end (); ++i)
1584c980
<       if (i.second.GetDestinationAddr () == GetAddress ())
---
>       if ((*i).second.GetDestinationAddr () == GetAddress ())
1586,1587c982,983
<           ForwardUp (i.first, i.second.GetSourceAddr (),
<                      i.second.GetDestinationAddr ());
---
>           ForwardUp ((*i).first, (*i).second.GetSourceAddr (),
>                      (*i).second.GetDestinationAddr ());
1591,1592c987,988
<           Mac48Address from = i.second.GetSourceAddr ();
<           Mac48Address to = i.second.GetDestinationAddr ();
---
>           Mac48Address from = (*i).second.GetSourceAddr ();
>           Mac48Address to = (*i).second.GetDestinationAddr ();
1594c990
<           ForwardDown (i.first->Copy (), from, to, mpdu->GetHeader ().GetQosTid ());
---
>           ForwardDown ((*i).first, from, to, hdr->GetQosTid ());
1603c999
<   m_beaconTxop->Initialize ();
---
>   m_beaconDca->Initialize ();
1609,1611c1005,1007
<           Time jitter = MicroSeconds (static_cast<int64_t> (m_beaconJitter->GetValue (0, 1) * (GetBeaconInterval ().GetMicroSeconds ())));
<           NS_LOG_DEBUG ("Scheduling initial beacon for access point " << GetAddress () << " at time " << jitter);
<           m_beaconEvent = Simulator::Schedule (jitter, &ApWifiMac::SendOneBeacon, this);
---
>           int64_t jitter = m_beaconJitter->GetValue (0, m_beaconInterval.GetMicroSeconds ());
>           NS_LOG_DEBUG ("Scheduling initial beacon for access point " << GetAddress () << " at time " << jitter << " microseconds");
>           m_beaconEvent = Simulator::Schedule (MicroSeconds (jitter), &ApWifiMac::SendOneBeacon, this);
1628,1675d1023
< }
< 
< bool
< ApWifiMac::GetRifsMode (void) const
< {
<   bool rifsMode = false;
<   if (GetHtSupported () && !GetVhtSupported ()) //RIFS mode is no longer allowed with 802.11ac or higher
<     {
<       if (m_nonHtStations.empty () || !m_disableRifs)
<         {
<           rifsMode = true;
<         }
<     }
<   if (GetHtSupported () && GetHtConfiguration ()->GetRifsSupported () && rifsMode)
<     {
<       m_stationManager->SetRifsPermitted (true);
<     }
<   else
<     {
<       m_stationManager->SetRifsPermitted (false);
<     }
<   return rifsMode;
< }
< 
< uint16_t
< ApWifiMac::GetNextAssociationId (void)
< {
<   //Return the first free AID value between 1 and 2007
<   for (uint16_t nextAid = 1; nextAid <= 2007; nextAid++)
<     {
<       if (m_staList.find (nextAid) == m_staList.end ())
<         {
<           return nextAid;
<         }
<     }
<   NS_FATAL_ERROR ("No free association ID available!");
<   return 0;
< }
< 
< void
< ApWifiMac::IncrementPollingListIterator (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_itCfPollingList++;
<   if (m_itCfPollingList == m_cfPollingList.end ())
<     {
<       m_itCfPollingList = m_cfPollingList.begin ();
<     }
diff ../../NS3-WiGig/src/wifi/model/ap-wifi-mac.h ../../ns-3-dev/src/wifi/model/ap-wifi-mac.h
26c26,36
< #include "infrastructure-wifi-mac.h"
---
> #include "regular-wifi-mac.h"
> #include "capability-information.h"
> #include "ht-capabilities.h"
> #include "ht-operations.h"
> #include "vht-capabilities.h"
> #include "amsdu-subframe-header.h"
> #include "supported-rates.h"
> #include "dsss-parameter-set.h"
> #include "erp-information.h"
> #include "edca-parameter-set.h"
> #include "ns3/random-variable-stream.h"
30,39d39
< class SupportedRates;
< class CapabilityInformation;
< class DsssParameterSet;
< class ErpInformation;
< class EdcaParameterSet;
< class HtOperation;
< class VhtOperation;
< class HeOperation;
< class CfParameterSet;
< 
47c47
< class ApWifiMac : public InfrastructureWifiMac
---
> class ApWifiMac : public RegularWifiMac
50,53d49
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
59,65c55,88
<   // Implementations of pure virtual methods, or overridden from base class.
<   void SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> stationManager);
<   void SetLinkUpCallback (Callback<void> linkUp);
<   void Enqueue (Ptr<Packet> packet, Mac48Address to);
<   void Enqueue (Ptr<Packet> packet, Mac48Address to, Mac48Address from);
<   bool SupportsSendFrom (void) const;
<   void SetAddress (Mac48Address address);
---
>   /**
>    * \param stationManager the station manager attached to this MAC.
>    */
>   virtual void SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> stationManager);
> 
>   /**
>    * \param linkUp the callback to invoke when the link becomes up.
>    */
>   virtual void SetLinkUpCallback (Callback<void> linkUp);
> 
>   /**
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
>    *
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.
>    */
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to);
> 
>   /**
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
>    * \param from the address from which the packet should be sent.
>    *
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.  The extra parameter "from" allows
>    * this device to operate in a bridged mode, forwarding received
>    * frames without altering the source address.
>    */
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to, Mac48Address from);
> 
>   virtual bool SupportsSendFrom (void) const;
67a91,94
>    * \param address the current address of this MAC layer.
>    */
>   virtual void SetAddress (Mac48Address address);
>   /**
76,80c103
<    * \param duration the maximum duration for the CF period.
<    */
<   void SetCfpMaxDuration (Time duration);
<   /**
<    * \return the maximum duration for the CF period.
---
>    * Start beacon transmission immediately.
82c105
<   Time GetCfpMaxDuration (void) const;
---
>   void StartBeaconing (void);
85c108
<    * Typically, true is returned only when there is no non-ERP stations associated
---
>    * Typically, true is returned only when there is no non-erp stations associated
88,89d110
<    *
<    * \returns whether short slot time should be enabled or not in the BSS.
94,97c115,116
<    * Typically, true is returned only when the AP and all associated
<    * stations support short PHY preamble.
<    *
<    * \returns whether short preamble should be enabled or not in the BSS.
---
>    * Typically, true is returned only when the AP and all associated 
>    * stations support short PLCP preamble.
100,111d118
<   /**
<    * Determine whether non-Greenfield HT stations are present or not.
<    *
<    * \returns whether non-Greenfield HT stations are present or not.
<    */
<   bool IsNonGfHtStasPresent (void) const;
<   /**
<    * Determine the VHT operational channel width (in MHz).
<    *
<    * \returns the VHT operational channel width (in MHz).
<    */
<   uint16_t GetVhtOperationalChannelWidth (void) const;
124,125d130
< protected:
<   Ptr<MultiBandElement> GetMultiBandElement (void) const;
128c133
<   void Receive (Ptr<WifiMacQueueItem> mpdu);
---
>   virtual void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
131c136
<    * (i.e. we received an Ack from the receiver).  If the packet
---
>    * (i.e. we received an ACK from the receiver).  If the packet
137c142
<   void TxOk (Ptr<const Packet> packet, const WifiMacHeader &hdr);
---
>   virtual void TxOk (const WifiMacHeader &hdr);
140c145
<    * (i.e. we did not receive an Ack from the receiver).  If the packet
---
>    * (i.e. we did not receive an ACK from the receiver).  If the packet
146c151
<   void TxFailed (const WifiMacHeader &hdr);
---
>   virtual void TxFailed (const WifiMacHeader &hdr);
154c159,160
<    * \param mpdu the MPDU containing the A-MSDU.
---
>    * \param aggregatedPacket the Packet containing the A-MSDU.
>    * \param hdr a pointer to the MAC header for \c aggregatedPacket.
156c162,163
<   void DeaggregateAmsduAndForward (Ptr<WifiMacQueueItem> mpdu);
---
>   virtual void DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket,
>                                            const WifiMacHeader *hdr);
165c172
<   void ForwardDown (Ptr<Packet> packet, Mac48Address from, Mac48Address to);
---
>   void ForwardDown (Ptr<const Packet> packet, Mac48Address from, Mac48Address to);
174c181
<   void ForwardDown (Ptr<Packet> packet, Mac48Address from, Mac48Address to, uint8_t tid);
---
>   void ForwardDown (Ptr<const Packet> packet, Mac48Address from, Mac48Address to, uint8_t tid);
183,185c190,191
<    * Forward an association or a reassociation response packet to the DCF.
<    * The standard is not clear on the correct queue for management frames if QoS is supported.
<    * We always use the DCF.
---
>    * Forward an association response packet to the DCF. The standard is not clear on the correct
>    * queue for management frames if QoS is supported. We always use the DCF.
189d194
<    * \param isReassoc indicates whether it is a reassociation response
191c196
<   void SendAssocResp (Mac48Address to, bool success, bool isReassoc);
---
>   void SendAssocResp (Mac48Address to, bool success);
197,209d201
<    * Determine what is the next PCF frame and trigger its transmission.
<    */
<   void SendNextCfFrame (void);
<   /**
<    * Send a CF-Poll packet to the next polling STA.
<    */
<   void SendCfPoll (void);
<   /**
<    * Send a CF-End packet.
<    */
<   void SendCfEnd (void);
< 
<   /**
220c212
<   Ptr<ErpInformation> GetErpInformation (void) const;
---
>   ErpInformation GetErpInformation (void) const;
226,244c218
<   Ptr<EdcaParameterSet> GetEdcaParameterSet (void) const;
<   /**
<    * Return the CF parameter set of the current AP.
<    *
<    * \return the CF parameter set that we support
<    */
<   Ptr<CfParameterSet> GetCfParameterSet (void) const;
<   /**
<    * Return the HT operation of the current AP.
<    *
<    * \return the HT operation that we support
<    */
<   Ptr<HtOperation> GetHtOperation (void) const;
<   /**
<    * Return the VHT operation of the current AP.
<    *
<    * \return the VHT operation that we support
<    */
<   Ptr<VhtOperation> GetVhtOperation (void) const;
---
>   EdcaParameterSet GetEdcaParameterSet (void) const;
246c220
<    * Return the HE operation of the current AP.
---
>    * Return the HT operations of the current AP.
248c222
<    * \return the HE operation that we support
---
>    * \return the HT operations that we support
250c224
<   Ptr<HeOperation> GetHeOperation (void) const;
---
>   HtOperations GetHtOperations (void) const;
263c237
<   Ptr<DsssParameterSet> GetDsssParameterSet (void) const;
---
>   DsssParameterSet GetDsssParameterSet (void) const;
271c245
<    * Return whether protection for non-ERP stations is used in the BSS.
---
>    * Return whether the AP is generating beacons.
273,274c247
<    * \return true if protection for non-ERP stations is used in the BSS,
<    *         false otherwise
---
>    * \return true if beacons are periodically generated, false otherwise
276c249
<   bool GetUseNonErpProtection (void) const;
---
>   bool GetBeaconGeneration (void) const;
278c251
<    * Return whether RIFS is allowed in the BSS.
---
>    * Return whether protection for non-ERP stations is used in the BSS.
280c253
<    * \return true if RIFS is allowed in the BSS,
---
>    * \return true if protection for non-ERP stations is used in the BSS, 
283,291c256
<   bool GetRifsMode (void) const;
<   /**
<    * Increment the PCF polling list iterator to indicate
<    * that the next polling station can be polled.
<    */
<   void IncrementPollingListIterator (void);
< 
<   void DoDispose (void);
<   void DoInitialize (void);
---
>   bool GetUseNonErpProtection (void) const;
293,296c258,259
<   /**
<    * \return the next Association ID to be allocated by the AP
<    */
<   uint16_t GetNextAssociationId (void);
---
>   virtual void DoDispose (void);
>   virtual void DoInitialize (void);
298c261,262
<   Ptr<Txop> m_beaconTxop;                    //!< Dedicated Txop for beacons
---
>   Ptr<DcaTxop> m_beaconDca;                  //!< Dedicated DcaTxop for beacons
>   Time m_beaconInterval;                     //!< Interval between beacons
301d264
<   EventId m_cfpEvent;                        //!< Event to generate one PCF frame
304c267
<   std::map<uint16_t, Mac48Address> m_staList; //!< Map of all stations currently associated to the AP with their association ID
---
>   std::list<Mac48Address> m_staList;         //!< List of all stations currently associated to the AP
307,308d269
<   std::list<Mac48Address> m_cfPollingList;   //!< List of all PCF stations currently associated to the AP
<   std::list<Mac48Address>::iterator m_itCfPollingList; //!< Iterator to the list of all PCF stations currently associated to the AP
310d270
<   bool m_disableRifs;                        //!< Flag whether to force RIFS to be disabled within the BSS If non-HT STAs are detected
diff ../../NS3-WiGig/src/wifi/model/arf-wifi-manager.cc ../../ns-3-dev/src/wifi/model/arf-wifi-manager.cc
21d20
< #include "ns3/log.h"
23c22,24
< #include "wifi-tx-vector.h"
---
> #include "ns3/assert.h"
> #include "ns3/log.h"
> #include "ns3/uinteger.h"
39,45c40,47
<   uint32_t m_timer; ///< timer value
<   uint32_t m_success; ///< success count
<   uint32_t m_failed; ///< failed count
<   bool m_recovery; ///< recovery
<   uint32_t m_timerTimeout; ///< timer timeout
<   uint32_t m_successThreshold; ///< success threshold
<   uint8_t m_rate; ///< rate
---
>   uint32_t m_timer;
>   uint32_t m_success;
>   uint32_t m_failed;
>   bool m_recovery;
>   uint32_t m_retry;
>   uint32_t m_timerTimeout;
>   uint32_t m_successThreshold;
>   uint32_t m_rate;
62c64
<                    "The minimum number of successful transmissions to try a new rate.",
---
>                    "The minimum number of sucessfull transmissions to try a new rate.",
66,69d67
<     .AddTraceSource ("Rate",
<                      "Traced value for rate changes (b/s)",
<                      MakeTraceSourceAccessor (&ArfWifiManager::m_currentRate),
<                      "ns3::TracedValueCallback::Uint64")
75,76d72
<   : WifiRemoteStationManager (),
<     m_currentRate (0)
86,103d81
< void
< ArfWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
115a94
>   station->m_retry = 0;
126d104
< 
136c114
<  * \param st the station that we failed to send Data
---
>  * \param st the station that we failed to send DATA
142c120
<   ArfWifiRemoteStation *station = static_cast<ArfWifiRemoteStation*> (st);
---
>   ArfWifiRemoteStation *station = (ArfWifiRemoteStation *)st;
144a123
>   station->m_retry++;
149,150c128,129
<       NS_ASSERT (station->m_failed >= 1);
<       if (station->m_failed == 1)
---
>       NS_ASSERT (station->m_retry >= 1);
>       if (station->m_retry == 1)
162,163c141,142
<       NS_ASSERT (station->m_failed >= 1);
<       if (((station->m_failed - 1) % 2) == 1)
---
>       NS_ASSERT (station->m_retry >= 1);
>       if (((station->m_retry - 1) % 2) == 1)
171c150
<       if (station->m_failed >= 2)
---
>       if (station->m_retry >= 2)
192,193c171,172
< void ArfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                      double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> void ArfWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                      double ackSnr, WifiMode ackMode, double dataSnr)
195,196c174,175
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   ArfWifiRemoteStation *station = static_cast<ArfWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   ArfWifiRemoteStation *station = (ArfWifiRemoteStation *) st;
200a180
>   station->m_retry = 0;
230,231c210,211
<   ArfWifiRemoteStation *station = static_cast<ArfWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   ArfWifiRemoteStation *station = (ArfWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
233a214
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
236,242c217
<   WifiMode mode = GetSupported (station, station->m_rate);
<   if (m_currentRate != mode.GetDataRate (channelWidth))
<     {
<       NS_LOG_DEBUG ("New datarate: " << mode.GetDataRate (channelWidth));
<       m_currentRate = mode.GetDataRate (channelWidth);
<     }
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, station->m_rate), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 1, channelWidth, GetAggregation (station), false);
249c224
<   /// \todo we could/should implement the ARF algorithm for
---
>   /// \todo we could/should implement the Arf algorithm for
251,252c226,227
<   ArfWifiRemoteStation *station = static_cast<ArfWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   ArfWifiRemoteStation *station = (ArfWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
254a230
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
258d233
<   WifiMode mode;
261c236
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (station, 0), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
265c240
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (station, 0), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
267d241
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
268a243,269
> }
> 
> bool
> ArfWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
> }
> 
> void
> ArfWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> ArfWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/arf-wifi-manager.h ../../ns-3-dev/src/wifi/model/arf-wifi-manager.h
24d23
< #include "ns3/traced-value.h"
44,46c43,45
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
---
>  * This RAA does not support HT or VHT modes and will error exit
>  * if the user tries to configure this RAA with a Wi-Fi MAC that
>  * has VhtSupported or HtSupported set.
51,54d49
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
58a54,56
>   // Inherited from WifiRemoteStationManager
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
61,75c59,73
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
---
>   //overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool IsLowLatency (void) const;
77,80c75,76
<   uint32_t m_timerThreshold;   ///< timer threshold
<   uint32_t m_successThreshold; ///< success threshold
< 
<   TracedValue<uint64_t> m_currentRate; //!< Trace rate changes
---
>   uint32_t m_timerThreshold;
>   uint32_t m_successThreshold;
Only in ../../NS3-WiGig/src/wifi/model: association-state-machine.cc
Only in ../../NS3-WiGig/src/wifi/model: association-state-machine.h
Only in ../../NS3-WiGig/src/wifi/model: bft-id-tag.cc
Only in ../../NS3-WiGig/src/wifi/model: bft-id-tag.h
diff ../../NS3-WiGig/src/wifi/model/block-ack-agreement.cc ../../ns-3-dev/src/wifi/model/block-ack-agreement.cc
21d20
< #include "ns3/log.h"
23c22
< #include "wifi-utils.h"
---
> #include "ns3/log.h"
28a28,36
> BlockAckAgreement::BlockAckAgreement ()
>   : m_amsduSupported (0),
>     m_blockAckPolicy (1),
>     m_htSupported (0),
>     m_inactivityEvent ()
> {
>   NS_LOG_FUNCTION (this);
> }
> 
30,31c38
<   : m_peer (peer),
<     m_amsduSupported (0),
---
>   : m_amsduSupported (0),
33d39
<     m_tid (tid),
37c43,45
<   NS_LOG_FUNCTION (this << peer << +tid);
---
>   NS_LOG_FUNCTION (this << peer << static_cast<uint32_t> (tid));
>   m_tid = tid;
>   m_peer = peer;
50d57
<   //// WIGIG ////
52d58
<   //// WIGIG ////
103a110
>   NS_LOG_FUNCTION (this);
116a124
>   NS_LOG_FUNCTION (this);
122a131
>   NS_LOG_FUNCTION (this);
128a138
>   NS_LOG_FUNCTION (this);
134a145
>   NS_LOG_FUNCTION (this);
141a153
>   NS_LOG_FUNCTION (this);
147a160
>   NS_LOG_FUNCTION (this);
154c167,173
<   return (GetStartingSequence () + GetBufferSize () - 1) % SEQNO_SPACE_SIZE;
---
>   return m_winEnd;
> }
> 
> void
> BlockAckAgreement::SetWinEnd (uint16_t seq)
> {
>   m_winEnd = seq;
166a186
>   NS_LOG_FUNCTION (this);
diff ../../NS3-WiGig/src/wifi/model/block-ack-agreement.h ../../ns-3-dev/src/wifi/model/block-ack-agreement.h
34d33
<   /// Provide access to MacLow class
38a38
>   BlockAckAgreement ();
42,43c42,43
<    * \param peer the peer station
<    * \param tid the TID
---
>    * \param peer
>    * \param tid
50c50
<    * \param bufferSize the buffer size (in number of MPDUs)
---
>    * \param bufferSize
56c56
<    * \param timeout the timeout value
---
>    * \param timeout
72c72
<    * Set block ack policy to immediate Ack.
---
>    * Set Block ACK policy to immediate ACK.
76c76
<    * Set block ack policy to delayed Ack.
---
>    * Set Block ACK policy to delayed ACK.
85a86,91
>    * Set ending sequence number.
>    *
>    * \param seq the ending sequence number
>    */
>   void SetWinEnd (uint16_t seq);
>   /**
94c100
<    * \return the peer MAC address
---
>    * \return Mac48Address
100c106
<    * \return the buffer size (in number of MPDUs)
---
>    * \return buffer size
106c112
<    * \return the timeout
---
>    * \return timeout
110c116
<    * Return the starting sequence number.
---
>    * Return the starting squence number.
122c128
<    * Return the last sequence number covered by the ack window
---
>    * Return the ending sequence number
128c134
<    * Check whether the current ack policy is immediate BlockAck.
---
>    * Check whether the current ACK policy is immediate block ACK.
130c136
<    * \return true if the current ack policy is immediate BlockAck,
---
>    * \return true if the current ACK policy is immediate block ACK,
163c169
<   uint16_t m_startingSeq;    //!< Starting sequence control
---
>   uint16_t m_startingSeq;    //!< Starting squence control
166c172
<   EventId m_inactivityEvent; //!< inactivity event
---
>   EventId m_inactivityEvent;
diff ../../NS3-WiGig/src/wifi/model/block-ack-cache.cc ../../ns-3-dev/src/wifi/model/block-ack-cache.cc
21d20
< #include "ns3/log.h"
23,25d21
< #include "qos-utils.h"
< #include "wifi-utils.h"
< #include "wifi-mac-header.h"
26a23,25
> #include "wifi-mac-header.h"
> #include "qos-utils.h"
> #include "ns3/log.h"
39c38
<   m_winSize = winSize;
---
>   m_winSize = winSize <= 64 ? winSize : 64;
45c44
< BlockAckCache::GetWinStart () const
---
> BlockAckCache::GetWinStart ()
57c56
<       if (!IsInWindow (seqNumber, m_winStart, m_winSize))
---
>       if (!IsInWindow (seqNumber))
79c78
<       if (IsInWindow (startingSeq, m_winStart, m_winSize))
---
>       if (IsInWindow (startingSeq))
106c105
<   uint16_t i = start;
---
>   uint32_t i = start;
113a113,119
> bool
> BlockAckCache::IsInWindow (uint16_t seq)
> {
>   NS_LOG_FUNCTION (this << seq);
>   return ((seq - m_winStart + 4096) % 4096) < m_winSize;
> }
> 
122,125c128
<   else if (blockAckHeader->IsCompressed () || blockAckHeader->IsExtendedCompressed ()
<            //// WIGIG ////
<            || blockAckHeader->IsEdmgCompressed ())
<            //// WIGIG ////
---
>   else if (blockAckHeader->IsCompressed ())
127,128c130,131
<       uint16_t i = blockAckHeader->GetStartingSequence ();
<       uint16_t end = (i + m_winSize - 1) % 4096;
---
>       uint32_t i = blockAckHeader->GetStartingSequence ();
>       uint32_t end = (i + m_winSize - 1) % 4096;
diff ../../NS3-WiGig/src/wifi/model/block-ack-cache.h ../../ns-3-dev/src/wifi/model/block-ack-cache.h
24c24
< //#include <stdint.h>
---
> #include <stdint.h>
33c33
<  * \brief BlockAckCache cache
---
>  *
39,43d38
<   /**
<    * Initialization function
<    * \param winStart the window start
<    * \param winSize the window size
<    */
46,49d40
<   /**
<    * Update with MPDU function
<    * \param hdr the wifi MAC header
<    */
51,54d41
<   /**
<    * Update with block ack request function
<    * \param startingSeq the starting sequence
<    */
60d46
<    * \returns window start
62c48
<   uint16_t GetWinStart (void) const;
---
>   uint16_t GetWinStart (void);
64,67d49
<   /**
<    * Fill block ack bitmap function
<    * \param blockAckHeader the block ack bitmap
<    */
72,76d53
<   /**
<    * Reset portion of bitmap function
<    * \param start the starting position
<    * \param end the ending position
<    */
77a55
>   bool IsInWindow (uint16_t seq);
79,81c57,59
<   uint16_t m_winStart; ///< window start
<   uint16_t m_winSize;  ///< window size
<   uint16_t m_winEnd;   ///< window end
---
>   uint16_t m_winStart;
>   uint8_t m_winSize;
>   uint16_t m_winEnd;
83c61
<   uint16_t m_bitmap[4096]; ///< bitmap
---
>   uint16_t m_bitmap[4096];
diff ../../NS3-WiGig/src/wifi/model/block-ack-manager.cc ../../ns-3-dev/src/wifi/model/block-ack-manager.cc
21a22
> #include "ns3/assert.h"
22a24
> #include "ns3/fatal-error.h"
24,25d25
< #include "wifi-remote-station-manager.h"
< #include "ctrl-headers.h"
26a27,30
> #include "ctrl-headers.h"
> #include "wifi-mac-header.h"
> #include "edca-txop-n.h"
> #include "mac-low.h"
30d33
< #include "wifi-tx-vector.h"
36c39
< Bar::Bar ()
---
> BlockAckManager::Item::Item ()
41,44c44,47
< Bar::Bar (Ptr<const WifiMacQueueItem> bar, uint8_t tid, bool skipIfNoDataQueued)
<   : bar (bar),
<     tid (tid),
<     skipIfNoDataQueued (skipIfNoDataQueued)
---
> BlockAckManager::Item::Item (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp)
>   : packet (packet),
>     hdr (hdr),
>     timestamp (tStamp)
46c49
<   NS_LOG_FUNCTION (this << *bar << +tid << skipIfNoDataQueued);
---
>   NS_LOG_FUNCTION (this << packet << hdr << tStamp);
49c52,55
< NS_OBJECT_ENSURE_REGISTERED (BlockAckManager);
---
> Bar::Bar ()
> {
>   NS_LOG_FUNCTION (this);
> }
51,63c57,63
< TypeId
< BlockAckManager::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::BlockAckManager")
<     .SetParent<Object> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<BlockAckManager> ()
<     .AddTraceSource ("AgreementState",
<                      "The state of the ADDBA handshake",
<                      MakeTraceSourceAccessor (&BlockAckManager::m_agreementState),
<                      "ns3::BlockAckManager::AgreementStateTracedCallback")
<   ;
<   return tid;
---
> Bar::Bar (Ptr<const Packet> bar, Mac48Address recipient, uint8_t tid, bool immediate)
>   : bar (bar),
>     recipient (recipient),
>     tid (tid),
>     immediate (immediate)
> {
>   NS_LOG_FUNCTION (this << bar << recipient << static_cast<uint32_t> (tid) << immediate);
69,70d68
<   m_retryPackets = CreateObject<WifiMacQueue> ();
<   m_retryPackets->TraceConnectWithoutContext ("Expired", MakeCallback (&BlockAckManager::NotifyDiscardedMpdu, this));
78,116c76
<   m_retryPackets = 0;
< }
< 
< void
< BlockAckManager::CopyAgreements (Mac48Address recipient, Ptr<BlockAckManager> manager)
< {
<   NS_LOG_FUNCTION (this << recipient << manager);
< //  std::pair<Mac48Address, uint8_t> key;
< //  std::pair<OriginatorBlockAckAgreement, PacketQueue> value;
< //  OriginatorBlockAckAgreement agreement;  /* The existing agreement */
< //  for (AgreementsI iter = m_agreements.begin (); iter != m_agreements.end (); iter++)
< //    {
< //      key = iter->first;
< //      value = iter->second;
< //      /* Check if there is already an existing agreement */
< //      if (!ExistsAgreement (recipient, key.second))
< //        {
< //          agreement = value.first;
< //          OriginatorBlockAckAgreement clonedAgreement (recipient, key.second);
< //          clonedAgreement.SetStartingSequence (agreement.GetStartingSequence ());
< //          clonedAgreement.SetBufferSize (agreement.GetBufferSize ());
< //          clonedAgreement.SetWinEnd (agreement.GetWinEnd ());
< //          clonedAgreement.SetTimeout (agreement.GetTimeout ());
< //          clonedAgreement.SetAmsduSupport (agreement.IsAmsduSupported ());
< //          clonedAgreement.SetHtSupported (agreement.IsHtSupported ());
< //          if (agreement.IsImmediateBlockAck ())
< //            {
< //              clonedAgreement.SetImmediateBlockAck ();
< //            }
< //          else
< //            {
< //              clonedAgreement.SetDelayedBlockAck ();
< //            }
< //          clonedAgreement.SetState (agreement.GetState ());
< //          std::pair<OriginatorBlockAckAgreement, PacketQueue> clonedValue (clonedAgreement, value.second);
< //          manager->m_agreements.insert (std::make_pair (key, clonedValue));
< //          manager->m_blockPackets (recipient, key.second);
< //        }
< //    }
---
>   m_retryPackets.clear ();
122c82
<   NS_LOG_FUNCTION (this << recipient << +tid);
---
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid));
128c88
<                                          OriginatorBlockAckAgreement::State state) const
---
>                                          enum OriginatorBlockAckAgreement::State state) const
129a90
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid) << state);
135a97,98
>         case OriginatorBlockAckAgreement::INACTIVE:
>           return it->second.first.IsInactive ();
140,145c103,104
<         case OriginatorBlockAckAgreement::REJECTED:
<           return it->second.first.IsRejected ();
<         case OriginatorBlockAckAgreement::NO_REPLY:
<           return it->second.first.IsNoReply ();
<         case OriginatorBlockAckAgreement::RESET:
<           return it->second.first.IsReset ();
---
>         case OriginatorBlockAckAgreement::UNSUCCESSFUL:
>           return it->second.first.IsUnsuccessful ();
162c121,122
<   agreement.SetBufferSize (reqHdr->GetBufferSize());
---
>   agreement.SetBufferSize (64);
>   agreement.SetWinEnd ((agreement.GetStartingSequence () + agreement.GetBufferSize () - 1) % 4096);
165,166c125
<   agreement.SetHtSupported (m_stationManager->GetHtSupported ()
<                             || m_stationManager->HasDmgSupported () || m_stationManager->HasEdmgSupported ());
---
>   agreement.SetHtSupported (m_stationManager->HasHtSupported ());
175,176d133
<   uint8_t tid = reqHdr->GetTid ();
<   m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::PENDING);
178c135
<   PacketQueue queue;
---
>   PacketQueue queue (0);
180,185d136
<   if (ExistsAgreement (recipient, tid))
<     {
<       // Delete agreement if it exists and in RESET state
<       NS_ASSERT (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::RESET));
<       m_agreements.erase (key);
<     }
193c144
<   NS_LOG_FUNCTION (this << recipient << +tid);
---
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid));
197c148
<       for (WifiMacQueue::ConstIterator i = m_retryPackets->begin (); i != m_retryPackets->end (); )
---
>       for (std::list<PacketQueueI>::iterator i = m_retryPackets.begin (); i != m_retryPackets.end (); )
199c150
<           if ((*i)->GetHeader ().GetAddr1 () == recipient && (*i)->GetHeader ().GetQosTid () == tid)
---
>           if ((*i)->hdr.GetAddr1 () == recipient && (*i)->hdr.GetQosTid () == tid)
201c152
<               i = m_retryPackets->Remove (i);
---
>               i = m_retryPackets.erase (i);
209,210c160,161
<       //remove scheduled BAR
<       for (std::list<Bar>::const_iterator i = m_bars.begin (); i != m_bars.end (); )
---
>       //remove scheduled bar
>       for (std::list<Bar>::iterator i = m_bars.begin (); i != m_bars.end (); )
212c163
<           if (i->bar->GetHeader ().GetAddr1 () == recipient && i->tid == tid)
---
>           if (i->recipient == recipient && i->tid == tid)
236,252d186
<       // When the Add BA Response is received, there may be a packet transmitted
<       // under the normal ack policy that needs to be retransmitted. If so, such
<       // packet is placed in the retransmit queue. If this is the case, the starting
<       // sequence number is the sequence number of such packet. Otherwise, it is
<       // the sequence number that will be assigned to the next packet to be transmitted.
<       uint16_t startSeq;
<       WifiMacQueue::ConstIterator mpduIt = m_retryPackets->PeekByTidAndAddress (tid, recipient);
<       if (mpduIt != m_retryPackets->end ())
<         {
<           startSeq = (*mpduIt)->GetHeader ().GetSequenceNumber ();
<         }
<       else
<         {
<           startSeq = m_txMiddle->GetNextSeqNumberByTidAndAddress (tid, recipient);
<         }
<       agreement.SetStartingSequence (startSeq);
<       agreement.InitTxWindow ();
261,264d194
<       if (!it->second.first.IsEstablished ())
<       {
<         m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED);
<       }
278,283d207
< Ptr<WifiMacQueue>
< BlockAckManager::GetRetransmitQueue (void)
< {
<   return m_retryPackets;
< }
< 
285c209
< BlockAckManager::StorePacket (Ptr<WifiMacQueueItem> mpdu)
---
> BlockAckManager::StorePacket (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp)
287,291c211,212
<   NS_LOG_FUNCTION (this << *mpdu);
<   NS_ASSERT (mpdu->GetHeader ().IsQosData ());
< 
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
---
>   NS_LOG_FUNCTION (this << packet << hdr << tStamp);
>   NS_ASSERT (hdr.IsQosData ());
293,294c214,215
<   AgreementsI agreementIt = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (agreementIt != m_agreements.end ());
---
>   uint8_t tid = hdr.GetQosTid ();
>   Mac48Address recipient = hdr.GetAddr1 ();
296,307c217,221
<   uint16_t mpduDist = agreementIt->second.first.GetDistance (mpdu->GetHeader ().GetSequenceNumber ());
< 
<   if (mpduDist >= SEQNO_SPACE_HALF_SIZE)
<     {
<       NS_LOG_DEBUG ("Got an old packet. Do nothing");
<       return;
<     }
< 
<   // store the packet and keep the list sorted in increasing order of sequence number
<   // with respect to the starting sequence number
<   PacketQueueI it = agreementIt->second.second.begin ();
<   while (it != agreementIt->second.second.end ())
---
>   Item item (packet, hdr, tStamp);
>   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
>   NS_ASSERT (it != m_agreements.end ());
>   PacketQueueI queueIt = it->second.second.begin ();
>   for (; queueIt != it->second.second.end (); )
309c223
<       if (mpdu->GetHeader ().GetSequenceControl () == (*it)->GetHeader ().GetSequenceControl ())
---
>       if (((hdr.GetSequenceNumber () - queueIt->hdr.GetSequenceNumber () + 4096) % 4096) > 2047)
311,312c225,226
<           NS_LOG_DEBUG ("Packet already in the queue of the BA agreement");
<           return;
---
>           queueIt = it->second.second.insert (queueIt, item);
>           break;
313a228,237
>       else
>         {
>           queueIt++;
>         }
>     }
>   if (queueIt == it->second.second.end ())
>     {
>       it->second.second.push_back (item);
>     }
> }
315c239,246
<       uint16_t dist = agreementIt->second.first.GetDistance ((*it)->GetHeader ().GetSequenceNumber ());
---
> void
> BlockAckManager::CompleteAmpduExchange (Mac48Address recipient, uint8_t tid)
> {
>   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
>   NS_ASSERT (it != m_agreements.end ());
>   OriginatorBlockAckAgreement &agreement = (*it).second.first;
>   agreement.CompleteExchange ();
> }
317,318c248,260
<       if (mpduDist < dist ||
<           (mpduDist == dist && mpdu->GetHeader ().GetFragmentNumber () < (*it)->GetHeader ().GetFragmentNumber ()))
---
> Ptr<const Packet>
> BlockAckManager::GetNextPacket (WifiMacHeader &hdr)
> {
>   NS_LOG_FUNCTION (this << &hdr);
>   Ptr<const Packet> packet = 0;
>   uint8_t tid;
>   Mac48Address recipient;
>   CleanupBuffers ();
>   if (!m_retryPackets.empty ())
>     {
>       NS_LOG_DEBUG ("Retry buffer size is " << m_retryPackets.size ());
>       std::list<PacketQueueI>::iterator it = m_retryPackets.begin ();
>       while (it != m_retryPackets.end ())
319a262,318
>           if ((*it)->hdr.IsQosData ())
>             {
>               tid = (*it)->hdr.GetQosTid ();
>             }
>           else
>             {
>               NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>             }
>           recipient = (*it)->hdr.GetAddr1 ();
>           AgreementsI agreement = m_agreements.find (std::make_pair (recipient, tid));
>           NS_ASSERT (agreement != m_agreements.end ());
>           if (QosUtilsIsOldPacket (agreement->second.first.GetStartingSequence (),(*it)->hdr.GetSequenceNumber ()))
>             {
>               //Standard says the originator should not send a packet with seqnum < winstart
>               NS_LOG_DEBUG ("The Retry packet have sequence number < WinStartO --> Discard " << (*it)->hdr.GetSequenceNumber () << " " << agreement->second.first.GetStartingSequence ());
>               agreement->second.second.erase ((*it));
>               it = m_retryPackets.erase (it);
>               continue;
>             }
>           else if ((*it)->hdr.GetSequenceNumber () > (agreement->second.first.GetStartingSequence () + 63) % 4096)
>             {
>               agreement->second.first.SetStartingSequence ((*it)->hdr.GetSequenceNumber ());
>             }
>           packet = (*it)->packet->Copy ();
>           hdr = (*it)->hdr;
>           hdr.SetRetry ();
>           NS_LOG_INFO ("Retry packet seq = " << hdr.GetSequenceNumber ());
>           if (hdr.IsQosData ())
>             {
>               tid = hdr.GetQosTid ();
>             }
>           else
>             {
>               NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>             }
>           recipient = hdr.GetAddr1 ();
>           if (!agreement->second.first.IsHtSupported ()
>               && (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED)
>                   || SwitchToBlockAckIfNeeded (recipient, tid, hdr.GetSequenceNumber ())))
>             {
>               hdr.SetQosAckPolicy (WifiMacHeader::BLOCK_ACK);
>             }
>           else
>             {
>               /* From section 9.10.3 in IEEE802.11e standard:
>                * In order to improve efficiency, originators using the Block Ack facility
>                * may send MPDU frames with the Ack Policy subfield in QoS control frames
>                * set to Normal Ack if only a few MPDUs are available for transmission.[...]
>                * When there are sufficient number of MPDUs, the originator may switch back to
>                * the use of Block Ack.
>                */
>               hdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
>               AgreementsI i = m_agreements.find (std::make_pair (recipient, tid));
>               i->second.second.erase (*it);
>             }
>           it = m_retryPackets.erase (it);
>           NS_LOG_DEBUG ("Removed one packet, retry buffer size = " << m_retryPackets.size () );
322,323d320
< 
<       it++;
325,326c322
<   agreementIt->second.second.insert (it, mpdu);
<   agreementIt->second.first.NotifyTransmittedMpdu (mpdu);
---
>   return packet;
329,330c325,326
< Ptr<const WifiMacQueueItem>
< BlockAckManager::GetBar (bool remove)
---
> Ptr<const Packet>
> BlockAckManager::PeekNextPacket (WifiMacHeader &hdr)
332,339c328,333
<   Ptr<const WifiMacQueueItem> bar;
<   // remove all expired MPDUs in the retransmission queue, so that Block Ack Requests
<   // (if needed) are scheduled
<   m_retryPackets->Remove (WifiMacQueue::EMPTY, true);
< 
<   auto nextBar = m_bars.begin ();
< 
<   while (nextBar != m_bars.end ())
---
>   NS_LOG_FUNCTION (this << &hdr);
>   Ptr<const Packet> packet = 0;
>   uint8_t tid;
>   Mac48Address recipient;
>   CleanupBuffers ();
>   if (!m_retryPackets.empty ())
341c335,337
<       if (nextBar->bar->GetHeader ().IsBlockAckReq ())
---
>       NS_LOG_DEBUG ("Retry buffer size is " << m_retryPackets.size ());
>       std::list<PacketQueueI>::iterator it = m_retryPackets.begin ();
>       while (it != m_retryPackets.end ())
343,345c339
<           Mac48Address recipient = nextBar->bar->GetHeader ().GetAddr1 ();
<           AgreementsI it = m_agreements.find (std::make_pair (recipient, nextBar->tid));
<           if (it == m_agreements.end ())
---
>           if ((*it)->hdr.IsQosData ())
347,349c341,359
<               // BA agreement was torn down; remove this BAR and continue
<               nextBar = m_bars.erase (nextBar);
<               continue;
---
>               tid = (*it)->hdr.GetQosTid ();
>             }
>           else
>             {
>               NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>             }
>           recipient = (*it)->hdr.GetAddr1 ();
>           AgreementsI agreement = m_agreements.find (std::make_pair (recipient, tid));
>           NS_ASSERT (agreement != m_agreements.end ());
>           packet = (*it)->packet->Copy ();
>           hdr = (*it)->hdr;
>           hdr.SetRetry ();
>           if (hdr.IsQosData ())
>             {
>               tid = hdr.GetQosTid ();
>             }
>           else
>             {
>               NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
351,353c361,364
<           if (nextBar->skipIfNoDataQueued
<               && m_retryPackets->PeekByTidAndAddress (nextBar->tid, recipient) == m_retryPackets->end ()
<               && m_queue->PeekByTidAndAddress (nextBar->tid, recipient) == m_queue->end ())
---
>           recipient = hdr.GetAddr1 ();
>           if (!agreement->second.first.IsHtSupported ()
>               && (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED)
>                   || SwitchToBlockAckIfNeeded (recipient, tid, hdr.GetSequenceNumber ())))
355,356c366,408
<               // skip this BAR as there is no data queued
<               nextBar++;
---
>               hdr.SetQosAckPolicy (WifiMacHeader::BLOCK_ACK);
>             }
>           else
>             {
>               /* From section 9.10.3 in IEEE802.11e standard:
>                * In order to improve efficiency, originators using the Block Ack facility
>                * may send MPDU frames with the Ack Policy subfield in QoS control frames
>                * set to Normal Ack if only a few MPDUs are available for transmission.[...]
>                * When there are sufficient number of MPDUs, the originator may switch back to
>                * the use of Block Ack.
>                */
>               hdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
>             }
>           break;
>         }
>     }
>   return packet;
> }
> 
> Ptr<const Packet>
> BlockAckManager::PeekNextPacketByTidAndAddress (WifiMacHeader &hdr, Mac48Address recipient, uint8_t tid, Time *tstamp)
> {
>   NS_LOG_FUNCTION (this);
>   Ptr<const Packet> packet = 0;
>   CleanupBuffers ();
>   AgreementsI agreement = m_agreements.find (std::make_pair (recipient, tid));
>   NS_ASSERT (agreement != m_agreements.end ());
>   std::list<PacketQueueI>::iterator it = m_retryPackets.begin ();
>   for (; it != m_retryPackets.end (); it++)
>     {
>       if (!(*it)->hdr.IsQosData ())
>         {
>           NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>         }
>       if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid)
>         {
>           if (QosUtilsIsOldPacket (agreement->second.first.GetStartingSequence (),(*it)->hdr.GetSequenceNumber ()))
>             {
>               //standard says the originator should not send a packet with seqnum < winstart
>               NS_LOG_DEBUG ("The Retry packet have sequence number < WinStartO --> Discard " << (*it)->hdr.GetSequenceNumber () << " " << agreement->second.first.GetStartingSequence ());
>               agreement->second.second.erase ((*it));
>               it = m_retryPackets.erase (it);
>               it--;
359,360c411
<           // remove expired outstanding MPDUs and update the starting sequence number
<           for (auto mpduIt = it->second.second.begin (); mpduIt != it->second.second.end (); )
---
>           else if ((*it)->hdr.GetSequenceNumber () > (agreement->second.first.GetStartingSequence () + 63) % 4096)
362,371c413,425
<               if ((*mpduIt)->GetTimeStamp () + m_queue->GetMaxDelay () <= Simulator::Now ())
<                 {
<                   // MPDU expired
<                   it->second.first.NotifyDiscardedMpdu (*mpduIt);
<                   mpduIt = it->second.second.erase (mpduIt);
<                 }
<               else
<                 {
<                   mpduIt++;
<                 }
---
>               agreement->second.first.SetStartingSequence ((*it)->hdr.GetSequenceNumber ());
>             }
>           packet = (*it)->packet->Copy ();
>           hdr = (*it)->hdr;
>           hdr.SetRetry ();
>           *tstamp = (*it)->timestamp;
>           NS_LOG_INFO ("Retry packet seq = " << hdr.GetSequenceNumber ());
>           Mac48Address recipient = hdr.GetAddr1 ();
>           if (!agreement->second.first.IsHtSupported ()
>               && (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED)
>                   || SwitchToBlockAckIfNeeded (recipient, tid, hdr.GetSequenceNumber ())))
>             {
>               hdr.SetQosAckPolicy (WifiMacHeader::BLOCK_ACK);
373,376c427
<           // update BAR if the starting sequence number changed
<           CtrlBAckRequestHeader reqHdr;
<           nextBar->bar->GetPacket ()->PeekHeader (reqHdr);
<           if (reqHdr.GetStartingSequence () != it->second.first.GetStartingSequence ())
---
>           else
378,381c429,436
<               reqHdr.SetStartingSequence (it->second.first.GetStartingSequence ());
<               Ptr<Packet> packet = Create<Packet> ();
<               packet->AddHeader (reqHdr);
<               nextBar->bar = Create<const WifiMacQueueItem> (packet, nextBar->bar->GetHeader ());
---
>               /* From section 9.10.3 in IEEE802.11e standard:
>                * In order to improve efficiency, originators using the Block Ack facility
>                * may send MPDU frames with the Ack Policy subfield in QoS control frames
>                * set to Normal Ack if only a few MPDUs are available for transmission.[...]
>                * When there are sufficient number of MPDUs, the originator may switch back to
>                * the use of Block Ack.
>                */
>               hdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
382a438,439
>           NS_LOG_DEBUG ("Peeked one packet from retry buffer size = " << m_retryPackets.size () );
>           return packet;
383a441,443
>     }
>   return packet;
> }
385,386c445,452
<       bar = nextBar->bar;
<       if (remove)
---
> bool
> BlockAckManager::RemovePacket (uint8_t tid, Mac48Address recipient, uint16_t seqnumber)
> {
> 
>   std::list<PacketQueueI>::iterator it = m_retryPackets.begin ();
>   for (; it != m_retryPackets.end (); it++)
>     {
>       if (!(*it)->hdr.IsQosData ())
388c454,467
<           m_bars.erase (nextBar);
---
>           NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>         }
>       if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid && (*it)->hdr.GetSequenceNumber () == seqnumber)
>         {
>           WifiMacHeader hdr = (*it)->hdr;
>           uint8_t tid = hdr.GetQosTid ();
>           Mac48Address recipient = hdr.GetAddr1 ();
> 
>           AgreementsI i = m_agreements.find (std::make_pair (recipient, tid));
>           i->second.second.erase ((*it));
> 
>           m_retryPackets.erase (it);
>           NS_LOG_DEBUG ("Removed Packet from retry queue = " << hdr.GetSequenceNumber () << " " << (uint32_t) tid << " " << recipient << " Buffer Size = " << m_retryPackets.size ());
>           return true;
390d468
<       break;
392c470
<   return bar;
---
>   return false;
396c474,487
< BlockAckManager::HasPackets (void)
---
> BlockAckManager::HasBar (struct Bar &bar)
> {
>   NS_LOG_FUNCTION (this << &bar);
>   if (m_bars.size () > 0)
>     {
>       bar = m_bars.front ();
>       m_bars.pop_front ();
>       return true;
>     }
>   return false;
> }
> 
> bool
> BlockAckManager::HasPackets (void) const
399c490
<   return (!m_retryPackets->IsEmpty () || GetBar (false) != 0);
---
>   return (m_retryPackets.size () > 0 || m_bars.size () > 0);
405,407c496,498
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   AgreementsCI it = m_agreements.find (std::make_pair (recipient, tid));
<   if (it == m_agreements.end ())
---
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid));
>   uint32_t nPackets = 0;
>   if (ExistsAgreement (recipient, tid))
409c500,513
<       return 0;
---
>       AgreementsCI it = m_agreements.find (std::make_pair (recipient, tid));
>       PacketQueueCI queueIt = (*it).second.second.begin ();
>       uint16_t currentSeq = 0;
>       while (queueIt != (*it).second.second.end ())
>         {
>           currentSeq = (*queueIt).hdr.GetSequenceNumber ();
>           nPackets++;
>           /* a fragmented packet must be counted as one packet */
>           while (queueIt != (*it).second.second.end () && (*queueIt).hdr.GetSequenceNumber () == currentSeq)
>             {
>               queueIt++;
>             }
>         }
>       return nPackets;
410a515,521
>   return 0;
> }
> 
> uint32_t
> BlockAckManager::GetNRetryNeededPackets (Mac48Address recipient, uint8_t tid) const
> {
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid));
412,413c523,524
<   PacketQueueCI queueIt = (*it).second.second.begin ();
<   while (queueIt != (*it).second.second.end ())
---
>   uint16_t currentSeq = 0;
>   if (ExistsAgreement (recipient, tid))
415,418c526,527
<       uint16_t currentSeq = (*queueIt)->GetHeader ().GetSequenceNumber ();
<       nPackets++;
<       /* a fragmented packet must be counted as one packet */
<       while (queueIt != (*it).second.second.end () && (*queueIt)->GetHeader ().GetSequenceNumber () == currentSeq)
---
>       std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>       while (it != m_retryPackets.end ())
420c529,547
<           queueIt++;
---
>           if (!(*it)->hdr.IsQosData ())
>             {
>               NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>             }
>           if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid)
>             {
>               currentSeq = (*it)->hdr.GetSequenceNumber ();
>               nPackets++;
>               /* a fragmented packet must be counted as one packet */
>               while (it != m_retryPackets.end () && (*it)->hdr.GetSequenceNumber () == currentSeq)
>                 {
>                   it++;
>                 }
>             }
>           //go to next packet
>           if (it != m_retryPackets.end ())
>             {
>               it++;
>             }
429c556
<   NS_LOG_FUNCTION (this << +nPackets);
---
>   NS_LOG_FUNCTION (this << static_cast<uint32_t> (nPackets));
434c561
< BlockAckManager::SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> manager)
---
> BlockAckManager::SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> manager)
440,441c567,568
< void
< BlockAckManager::NotifyGotAck (Ptr<const WifiMacQueueItem> mpdu)
---
> bool
> BlockAckManager::AlreadyExists (uint16_t currentSeq, Mac48Address recipient, uint8_t tid)
443,455c570,571
<   NS_LOG_FUNCTION (this << *mpdu);
<   NS_ASSERT (mpdu->GetHeader ().IsQosData ());
< 
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   NS_ASSERT (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED));
< 
<   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (it != m_agreements.end ());
< 
<   // remove the acknowledged frame from the queue of outstanding packets
<   PacketQueueI queueIt = it->second.second.begin ();
<   while (queueIt != it->second.second.end ())
---
>   std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>   while (it != m_retryPackets.end ())
457c573,574
<       if ((*queueIt)->GetHeader ().GetSequenceNumber () == mpdu->GetHeader ().GetSequenceNumber ())
---
>       NS_LOG_FUNCTION (this << (*it)->hdr.GetType ());
>       if (!(*it)->hdr.IsQosData ())
459c576
<           queueIt = it->second.second.erase (queueIt);
---
>           NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
461,488c578
<       else
<       {
<         queueIt++;
<       }
<     }
< 
<   it->second.first.NotifyAckedMpdu (mpdu);
< }
< 
< void
< BlockAckManager::NotifyMissedAck (Ptr<WifiMacQueueItem> mpdu)
< {
<   NS_LOG_FUNCTION (this << *mpdu);
<   NS_ASSERT (mpdu->GetHeader ().IsQosData ());
< 
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   NS_ASSERT (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED));
< 
<   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (it != m_agreements.end ());
< 
<   // remove the frame from the queue of outstanding packets (it will be re-inserted
<   // if retransmitted)
<   PacketQueueI queueIt = it->second.second.begin ();
<   while (queueIt != it->second.second.end ())
<     {
<       if ((*queueIt)->GetHeader ().GetSequenceNumber () == mpdu->GetHeader ().GetSequenceNumber ())
---
>       if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid && currentSeq == (*it)->hdr.GetSequenceNumber ())
490c580
<           queueIt = it->second.second.erase (queueIt);
---
>           return true;
492,495c582
<       else
<       {
<         queueIt++;
<       }
---
>       it++;
497,499c584
< 
<   // insert in the retransmission queue
<   InsertInRetryQueue (mpdu);
---
>   return false;
503c588
< BlockAckManager::NotifyGotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, double dataSnr, WifiTxVector dataTxVector)
---
> BlockAckManager::NotifyGotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, WifiMode txMode, double dataSnr)
505c590,591
<   NS_LOG_FUNCTION (this << blockAck << recipient << rxSnr << dataSnr << dataTxVector);
---
>   NS_LOG_FUNCTION (this << blockAck << recipient << rxSnr << txMode.GetUniqueName () << dataSnr);
>   uint16_t sequenceFirstLost = 0;
512,513c598,599
<           uint8_t nSuccessfulMpdus = 0;
<           uint8_t nFailedMpdus = 0;
---
>           uint32_t nSuccessfulMpdus = 0;
>           uint32_t nFailedMpdus = 0;
519c605
<               /* Upon reception of a BlockAck frame, the inactivity timer at the
---
>               /* Upon reception of a block ack frame, the inactivity timer at the
529,532d614
< 
<           uint16_t currentStartingSeq = it->second.first.GetStartingSequence ();
<           uint16_t currentSeq = SEQNO_SPACE_SIZE;   // invalid value
< 
537,539c619,620
<                   currentSeq = (*queueIt)->GetHeader ().GetSequenceNumber ();
<                   if (blockAck->IsFragmentReceived (currentSeq,
<                                                     (*queueIt)->GetHeader ().GetFragmentNumber ()))
---
>                   if (blockAck->IsFragmentReceived ((*queueIt).hdr.GetSequenceNumber (),
>                                                     (*queueIt).hdr.GetFragmentNumber ()))
541a623
>                       queueIt = it->second.second.erase (queueIt);
543c625
<                   else if (!QosUtilsIsOldPacket (currentStartingSeq, currentSeq))
---
>                   else
548c630,631
<                           RemoveOldPackets (recipient, tid, currentSeq);
---
>                           sequenceFirstLost = (*queueIt).hdr.GetSequenceNumber ();
>                           (*it).second.first.SetStartingSequence (sequenceFirstLost);
551c634,638
<                       InsertInRetryQueue (*queueIt);
---
>                       if (!AlreadyExists ((*queueIt).hdr.GetSequenceNumber (),recipient,tid))
>                         {
>                           InsertInRetryQueue (queueIt);
>                         }
>                       queueIt++;
553,559d639
<                   // in any case, this packet is no longer outstanding
<                   queueIt = it->second.second.erase (queueIt);
<                 }
<               // If all frames were acknowledged, move the transmit window past the last one
<               if (!foundFirstLost && currentSeq != SEQNO_SPACE_SIZE)
<                 {
<                   RemoveOldPackets (recipient, tid, (currentSeq + 1) % SEQNO_SPACE_SIZE);
562,564c642
<           //// WIGIG ////
<           else if (blockAck->IsCompressed () || blockAck->IsExtendedCompressed () || blockAck->IsEdmgCompressed ())
<           //// WIGIG ////
---
>           else if (blockAck->IsCompressed ())
568,569c646
<                   currentSeq = (*queueIt)->GetHeader ().GetSequenceNumber ();
<                   if (blockAck->IsPacketReceived (currentSeq))
---
>                   if (blockAck->IsPacketReceived ((*queueIt).hdr.GetSequenceNumber ()))
571,573c648,650
<                       it->second.first.NotifyAckedMpdu (*queueIt);
<                       nSuccessfulMpdus++;
<                       if (!m_txOkCallback.IsNull ())
---
>                       uint16_t currentSeq = (*queueIt).hdr.GetSequenceNumber ();
>                       while (queueIt != queueEnd
>                              && (*queueIt).hdr.GetSequenceNumber () == currentSeq)
575c652,657
<                           m_txOkCallback ((*queueIt)->GetHeader ());
---
>                           nSuccessfulMpdus++;
>                           if (!m_txOkCallback.IsNull ())
>                             {
>                               m_txOkCallback ((*queueIt).hdr);
>                             }
>                           queueIt = it->second.second.erase (queueIt);
578c660
<                   else if (!QosUtilsIsOldPacket (currentStartingSeq, currentSeq))
---
>                   else
579a662,667
>                       if (!foundFirstLost)
>                         {
>                           foundFirstLost = true;
>                           sequenceFirstLost = (*queueIt).hdr.GetSequenceNumber ();
>                           (*it).second.first.SetStartingSequence (sequenceFirstLost);
>                         }
583c671,675
<                           m_txFailedCallback ((*queueIt)->GetHeader ());
---
>                           m_txFailedCallback ((*queueIt).hdr);
>                         }
>                       if (!AlreadyExists ((*queueIt).hdr.GetSequenceNumber (),recipient,tid))
>                         {
>                           InsertInRetryQueue (queueIt);
585c677
<                       InsertInRetryQueue (*queueIt);
---
>                       queueIt++;
587,588d678
<                   // in any case, this packet is no longer outstanding
<                   queueIt = it->second.second.erase (queueIt);
591c681,687
<           m_stationManager->ReportAmpduTxStatus (recipient, nSuccessfulMpdus, nFailedMpdus, rxSnr, dataSnr, dataTxVector);
---
>           m_stationManager->ReportAmpduTxStatus (recipient, tid, nSuccessfulMpdus, nFailedMpdus, rxSnr, dataSnr);
>           uint16_t newSeq = m_txMiddle->GetNextSeqNumberByTidAndAddress (tid, recipient);
>           if ((foundFirstLost && !SwitchToBlockAckIfNeeded (recipient, tid, sequenceFirstLost))
>               || (!foundFirstLost && !SwitchToBlockAckIfNeeded (recipient, tid, newSeq)))
>             {
>               it->second.first.CompleteExchange ();
>             }
600,640d695
<   
< void
< BlockAckManager::NotifyMissedBlockAck (Mac48Address recipient, uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   if (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
<     {
<       AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<       for (auto& item : it->second.second)
<         {
<           // Queue previously transmitted packets that do not already exist in the retry queue.
<           InsertInRetryQueue (item);
<         }
<       // remove all packets from the queue of outstanding packets (they will be
<       // re-inserted if retransmitted)
<       it->second.second.clear ();
<     }
< }
< 
< void
< BlockAckManager::DiscardOutstandingMpdus (Mac48Address recipient, uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   if (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
<     {
<       AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<       while (!it->second.second.empty ())
<         {
<           Ptr<WifiMacQueueItem> mpdu = it->second.second.front ();
<           if (it->second.first.GetDistance (mpdu->GetHeader ().GetSequenceNumber ()) >= SEQNO_SPACE_HALF_SIZE)
<             {
<               // old packet
<               it->second.second.pop_front ();
<             }
<           else
<             {
<               NotifyDiscardedMpdu (mpdu);
<             }
<         }
<     }
< }
643c698
< BlockAckManager::SetBlockAckType (BlockAckType bAckType)
---
> BlockAckManager::SetBlockAckType (enum BlockAckType bAckType)
649,650c704,705
< void
< BlockAckManager::NotifyDiscardedMpdu (Ptr<const WifiMacQueueItem> mpdu)
---
> Ptr<Packet>
> BlockAckManager::ScheduleBlockAckReqIfNeeded (Mac48Address recipient, uint8_t tid)
652,667c707,712
<   NS_LOG_FUNCTION (this << *mpdu);
< 
<   if (!mpdu->GetHeader ().IsQosData ())
<     {
<       NS_LOG_DEBUG ("Not a QoS Data frame");
<       return;
<     }
< 
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   if (!ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
<     {
<       NS_LOG_DEBUG ("No established Block Ack agreement");
<       return;
<     }
< 
---
>   /* This method checks if a BlockAckRequest frame should be send to the recipient station.
>      Number of packets under block ack is specified in OriginatorBlockAckAgreement object but sometimes
>      this number could be incorrect. In fact is possible that a block ack agreement exists for n
>      packets but some of these packets are dropped due to MSDU lifetime expiration.
>    */
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid));
669,704d713
<   uint16_t currStartingSeq = it->second.first.GetStartingSequence ();
<   if (QosUtilsIsOldPacket (currStartingSeq, mpdu->GetHeader ().GetSequenceNumber ()))
<     {
<       NS_LOG_DEBUG ("Discarded an old frame");
<       return;
<     }
< 
<   // remove outstanding frames and frames in the retransmit queue with a sequence
<   // number less than or equal to the discarded MPDU
<   RemoveOldPackets (recipient, tid, (mpdu->GetHeader ().GetSequenceNumber () + 1) % SEQNO_SPACE_SIZE);
<   // actually advance the transmit window
<   it->second.first.NotifyDiscardedMpdu (mpdu);
< 
<   // schedule a BlockAckRequest
<   NS_LOG_DEBUG ("Schedule a Block Ack Request for agreement (" << recipient << ", " << +tid << ")");
<   Ptr<Packet> bar = Create<Packet> ();
<   bar->AddHeader (GetBlockAckReqHeader (recipient, tid));
< 
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_CTL_BACKREQ);
<   hdr.SetAddr1 (recipient);
<   hdr.SetAddr2 (mpdu->GetHeader ().GetAddr2 ());
<   hdr.SetAddr3 (mpdu->GetHeader ().GetAddr3 ());
<   hdr.SetDsNotTo ();
<   hdr.SetDsNotFrom ();
<   hdr.SetNoRetry ();
<   hdr.SetNoMoreFragments ();
< 
<   ScheduleBar (Create<const WifiMacQueueItem> (bar, hdr));
< }
< 
< CtrlBAckRequestHeader
< BlockAckManager::GetBlockAckReqHeader (Mac48Address recipient, uint8_t tid) const
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   AgreementsCI it = m_agreements.find (std::make_pair (recipient, tid));
707,726c716,718
<   CtrlBAckRequestHeader reqHdr;
<   reqHdr.SetType (m_blockAckType);
<   reqHdr.SetTidInfo (tid);
<   reqHdr.SetStartingSequence ((*it).second.first.GetStartingSequence ());
<   return reqHdr;
< }
< 
< void
< BlockAckManager::ScheduleBar (Ptr<const WifiMacQueueItem> bar, bool skipIfNoDataQueued)
< {
<   NS_LOG_FUNCTION (this << *bar);
<   NS_ASSERT (bar->GetHeader ().IsBlockAckReq ());
< 
<   CtrlBAckRequestHeader reqHdr;
<   bar->GetPacket ()->PeekHeader (reqHdr);
<   uint8_t tid = reqHdr.GetTidInfo ();
<   Bar request (bar, tid, skipIfNoDataQueued);
< 
<   // if a BAR for the given agreement is present, replace it with the new one
<   for (std::list<Bar>::const_iterator i = m_bars.begin (); i != m_bars.end (); i++)
---
>   if ((*it).second.first.IsBlockAckRequestNeeded ()
>       || (GetNRetryNeededPackets (recipient, tid) == 0
>           && m_queue->GetNPacketsByTidAndAddress (tid, WifiMacHeader::ADDR1, recipient) == 0))
728c720,724
<       if (i->bar->GetHeader ().GetAddr1 () == bar->GetHeader ().GetAddr1 () && i->tid == tid)
---
>       OriginatorBlockAckAgreement &agreement = (*it).second.first;
>       agreement.CompleteExchange ();
> 
>       CtrlBAckRequestHeader reqHdr;
>       if (m_blockAckType == BASIC_BLOCK_ACK || m_blockAckType == COMPRESSED_BLOCK_ACK)
730,732c726,728
<           i = m_bars.erase (i);
<           m_bars.insert (i, request);
<           return;
---
>           reqHdr.SetType (m_blockAckType);
>           reqHdr.SetTidInfo (agreement.GetTid ());
>           reqHdr.SetStartingSequence (agreement.GetStartingSequence ());
733a730,740
>       else if (m_blockAckType == MULTI_TID_BLOCK_ACK)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Invalid block ack type.");
>         }
>       Ptr<Packet> bar = Create<Packet> ();
>       bar->AddHeader (reqHdr);
>       return bar;
735,743c742
< 
<   if (bar->GetHeader ().IsRetry ())
<     {
<       m_bars.push_front (request);
<     }
<   else
<     {
<       m_bars.push_back (request);
<     }
---
>   return 0;
749c748
<   NS_LOG_FUNCTION (this << recipient << +tid);
---
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid));
756c755
<   NS_LOG_FUNCTION (this << recipient << +tid << startingSeq);
---
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid) << startingSeq);
759,762c758
<   if (!it->second.first.IsEstablished ())
<   {
<     m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED);
<   }
---
> 
768c764
< BlockAckManager::NotifyAgreementRejected (Mac48Address recipient, uint8_t tid)
---
> BlockAckManager::NotifyAgreementUnsuccessful (Mac48Address recipient, uint8_t tid)
770c766
<   NS_LOG_FUNCTION (this << recipient << +tid);
---
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid));
773c769
<   if (!it->second.first.IsRejected ())
---
>   if (it != m_agreements.end ())
775c771
<       m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::REJECTED);
---
>       it->second.first.SetState (OriginatorBlockAckAgreement::UNSUCCESSFUL);
777d772
<   it->second.first.SetState (OriginatorBlockAckAgreement::REJECTED);
781c776
< BlockAckManager::NotifyAgreementNoReply (Mac48Address recipient, uint8_t tid)
---
> BlockAckManager::NotifyMpduTransmission (Mac48Address recipient, uint8_t tid, uint16_t nextSeqNumber, enum WifiMacHeader::QosAckPolicy policy)
783c778,779
<   NS_LOG_FUNCTION (this << recipient << +tid);
---
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid) << nextSeqNumber);
>   Ptr<Packet> bar = 0;
786c782,784
<   if (!it->second.first.IsNoReply ())
---
> 
>   uint16_t nextSeq;
>   if (GetNRetryNeededPackets (recipient, tid) > 0)
788c786
<       m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::NO_REPLY);
---
>       nextSeq = GetSeqNumOfNextRetryPacket (recipient, tid);
790,800c788
<   it->second.first.SetState (OriginatorBlockAckAgreement::NO_REPLY);
<   m_unblockPackets (recipient, tid);
< }
< 
< void
< BlockAckManager::NotifyAgreementReset (Mac48Address recipient, uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (it != m_agreements.end ());
<   if (!it->second.first.IsReset ())
---
>   else
802c790,800
<       m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::RESET);
---
>       nextSeq = nextSeqNumber;
>     }
>   it->second.first.NotifyMpduTransmission (nextSeq);
>   if (policy == WifiMacHeader::BLOCK_ACK)
>     {
>       bar = ScheduleBlockAckReqIfNeeded (recipient, tid);
>       if (bar != 0)
>         {
>           Bar request (bar, recipient, tid, it->second.first.IsImmediateBlockAck ());
>           m_bars.push_back (request);
>         }
804d801
<   it->second.first.SetState (OriginatorBlockAckAgreement::RESET);
808c805
< BlockAckManager::SetQueue (const Ptr<WifiMacQueue> queue)
---
> BlockAckManager::SetQueue (Ptr<WifiMacQueue> queue)
817c814
<   NS_LOG_FUNCTION (this << recipient << +tid << startingSeq);
---
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid) << startingSeq);
819c816
<   if (!ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::REJECTED) && ExistsAgreement (recipient, tid))
---
>   if (!ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::UNSUCCESSFUL) && ExistsAgreement (recipient, tid))
821c818
<       uint32_t packets = m_queue->GetNPacketsByTidAndAddress (tid, recipient) +
---
>       uint32_t packets = m_queue->GetNPacketsByTidAndAddress (tid, WifiMacHeader::ADDR1, recipient) +
832c829,830
< bool BlockAckManager::NeedBarRetransmission (uint8_t tid, Mac48Address recipient)
---
> void
> BlockAckManager::TearDownBlockAck (Mac48Address recipient, uint8_t tid)
834,837c832,834
<   if (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
<     {
<       AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<       NS_ASSERT (it != m_agreements.end ());
---
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid));
>   DestroyAgreement (recipient, tid);
> }
839,840c836,844
<       // A BAR needs to be retransmitted if there is at least a non-expired outstanding MPDU
<       for (auto& mpdu : it->second.second)
---
> bool
> BlockAckManager::HasOtherFragments (uint16_t sequenceNumber) const
> {
>   NS_LOG_FUNCTION (this << sequenceNumber);
>   bool retVal = false;
>   if (m_retryPackets.size () > 0)
>     {
>       Item next = *(m_retryPackets.front ());
>       if (next.hdr.GetSequenceNumber () == sequenceNumber)
842,845c846
<           if (mpdu->GetTimeStamp () + m_queue->GetMaxDelay () > Simulator::Now ())
<             {
<               return true;
<             }
---
>           retVal = true;
848,851c849
< 
<   // If the inactivity timer has expired, QosTxop::SendDelbaFrame has been called and
<   // has destroyed the agreement, hence we get here and correctly return false
<   return false;
---
>   return retVal;
854,855c852,853
< void
< BlockAckManager::RemoveFromRetryQueue (Mac48Address address, uint8_t tid, uint16_t seq)
---
> uint32_t
> BlockAckManager::GetNextPacketSize (void) const
857c855,862
<   RemoveFromRetryQueue (address, tid, seq, seq);
---
>   NS_LOG_FUNCTION (this);
>   uint32_t size = 0;
>   if (m_retryPackets.size () > 0)
>     {
>       Item next = *(m_retryPackets.front ());
>       size = next.packet->GetSize ();
>     }
>   return size;
860,861c865
< void
< BlockAckManager::RemoveFromRetryQueue (Mac48Address address, uint8_t tid, uint16_t startSeq, uint16_t endSeq)
---
> bool BlockAckManager::NeedBarRetransmission (uint8_t tid, uint16_t seqNumber, Mac48Address recipient)
863,871c867,871
<   NS_LOG_FUNCTION (this << address << +tid << startSeq << endSeq);
< 
<   AgreementsI agreementIt = m_agreements.find (std::make_pair (address, tid));
<   NS_ASSERT (agreementIt != m_agreements.end ());
< 
<   /* remove retry packet iterators if they are present in retry queue */
<   WifiMacQueue::ConstIterator it = m_retryPackets->PeekByTidAndAddress (tid, address);
< 
<   while (it != m_retryPackets->end ())
---
>   //The standard says the BAR gets discarded when all MSDUs lifetime expires
>   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
>   NS_ASSERT (it != m_agreements.end ());
>   CleanupBuffers ();
>   if ((seqNumber + 63) < it->second.first.GetStartingSequence ())
873,885c873,877
<       uint16_t itSeq = (*it)->GetHeader ().GetSequenceNumber ();
< 
<       if (agreementIt->second.first.GetDistance (itSeq) >= agreementIt->second.first.GetDistance (startSeq)
<           && agreementIt->second.first.GetDistance (itSeq) <= agreementIt->second.first.GetDistance (endSeq))
<         {
<           NS_LOG_DEBUG ("Removing frame with seqnum = " << itSeq);
<           it = m_retryPackets->Remove (it);
<           it = m_retryPackets->PeekByTidAndAddress (tid, address, it);
<         }
<       else
<         {
<           it = m_retryPackets->PeekByTidAndAddress (tid, address, ++it);
<         }
---
>       return false;
>     }
>   else
>     {
>       return true;
890c882
< BlockAckManager::RemoveOldPackets (Mac48Address recipient, uint8_t tid, uint16_t startingSeq)
---
> BlockAckManager::CleanupBuffers (void)
892,912c884,885
<   NS_LOG_FUNCTION (this << recipient << +tid << startingSeq);
< 
<   AgreementsI agreementIt = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (agreementIt != m_agreements.end ());
<   uint16_t currStartingSeq = agreementIt->second.first.GetStartingSequence ();
< 
<   NS_ABORT_MSG_IF (agreementIt->second.first.GetDistance (startingSeq) >= SEQNO_SPACE_HALF_SIZE,
<                    "The new starting sequence number is an old sequence number");
< 
<   if (startingSeq == currStartingSeq)
<     {
<       return;
<     }
< 
<   // remove packets that will become old from the retransmission queue
<   uint16_t lastRemovedSeq = (startingSeq - 1 + SEQNO_SPACE_SIZE) % SEQNO_SPACE_SIZE;
<   RemoveFromRetryQueue (recipient, tid, currStartingSeq, lastRemovedSeq);
< 
<   // remove packets that will become old from the queue of outstanding packets
<   PacketQueueI it = agreementIt->second.second.begin ();
<   while (it != agreementIt->second.second.end ())
---
>   NS_LOG_FUNCTION (this);
>   for (AgreementsI j = m_agreements.begin (); j != m_agreements.end (); j++)
914,916c887
<       uint16_t itSeq = (*it)->GetHeader ().GetSequenceNumber ();
< 
<       if (agreementIt->second.first.GetDistance (itSeq) <= agreementIt->second.first.GetDistance (lastRemovedSeq))
---
>       if (j->second.second.empty ())
918,919c889
<           NS_LOG_DEBUG ("Removing frame with seqnum = " << itSeq);
<           it = agreementIt->second.second.erase (it);
---
>           continue;
921c891,893
<       else
---
>       Time now = Simulator::Now ();
>       PacketQueueI end = j->second.second.begin ();
>       for (PacketQueueI i = j->second.second.begin (); i != j->second.second.end (); i++)
923c895,916
<           it++;
---
>           if (i->timestamp + m_maxDelay > now)
>             {
>               end = i;
>               break;
>             }
>           else
>             {
>               /* remove retry packet iterator if it's present in retry queue */
>               for (std::list<PacketQueueI>::iterator it = m_retryPackets.begin (); it != m_retryPackets.end (); )
>                 {
>                   if ((*it)->hdr.GetAddr1 () == j->second.first.GetPeer ()
>                       && (*it)->hdr.GetQosTid () == j->second.first.GetTid ()
>                       && (*it)->hdr.GetSequenceNumber () == i->hdr.GetSequenceNumber ())
>                     {
>                       it = m_retryPackets.erase (it);
>                     }
>                   else
>                     {
>                       it++;
>                     }
>                 }
>             }
924a918,919
>       j->second.second.erase (j->second.second.begin (), end);
>       j->second.first.SetStartingSequence (end->hdr.GetSequenceNumber ());
928a924,930
> BlockAckManager::SetMaxPacketDelay (Time maxDelay)
> {
>   NS_LOG_FUNCTION (this << maxDelay);
>   m_maxDelay = maxDelay;
> }
> 
> void
950c952
< BlockAckManager::SetTxMiddle (const Ptr<MacTxMiddle> txMiddle)
---
> BlockAckManager::SetTxMiddle (MacTxMiddle* txMiddle)
955a958,977
> uint16_t
> BlockAckManager::GetSeqNumOfNextRetryPacket (Mac48Address recipient, uint8_t tid) const
> {
>   NS_LOG_FUNCTION (this << recipient << static_cast<uint32_t> (tid));
>   std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>   while (it != m_retryPackets.end ())
>     {
>       if (!(*it)->hdr.IsQosData ())
>         {
>           NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>         }
>       if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid)
>         {
>           return (*it)->hdr.GetSequenceNumber ();
>         }
>       it++;
>     }
>   return 4096;
> }
> 
969c991
< BlockAckManager::InsertInRetryQueue (Ptr<WifiMacQueueItem> mpdu)
---
> BlockAckManager::InsertInRetryQueue (PacketQueueI item)
971,982c993,994
<   NS_LOG_INFO ("Adding to retry queue " << *mpdu);
<   NS_ASSERT (mpdu->GetHeader ().IsQosData ());
< 
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
< 
<   AgreementsI agreementIt = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (agreementIt != m_agreements.end ());
< 
<   uint16_t mpduDist = agreementIt->second.first.GetDistance (mpdu->GetHeader ().GetSequenceNumber ());
< 
<   if (mpduDist >= SEQNO_SPACE_HALF_SIZE)
---
>   NS_LOG_INFO ("Adding to retry queue " << (*item).hdr.GetSequenceNumber ());
>   if (m_retryPackets.size () == 0)
984,985c996
<       NS_LOG_DEBUG ("Got an old packet. Do nothing");
<       return;
---
>       m_retryPackets.push_back (item);
987,990c998
< 
<   WifiMacQueue::ConstIterator it = m_retryPackets->PeekByTidAndAddress (tid, recipient);
< 
<   while (it != m_retryPackets->end ())
---
>   else
992c1000
<       if (mpdu->GetHeader ().GetSequenceControl () == (*it)->GetHeader ().GetSequenceControl ())
---
>       for (std::list<PacketQueueI>::iterator it = m_retryPackets.begin (); it != m_retryPackets.end (); )
994,1003c1002,1014
<           NS_LOG_DEBUG ("Packet already in the retransmit queue");
<           return;
<         }
< 
<       uint16_t dist = agreementIt->second.first.GetDistance ((*it)->GetHeader ().GetSequenceNumber ());
< 
<       if (mpduDist < dist ||
<           (mpduDist == dist && mpdu->GetHeader ().GetFragmentNumber () < (*it)->GetHeader ().GetFragmentNumber ()))
<         {
<           break;
---
>           if (((item->hdr.GetSequenceNumber () - (*it)->hdr.GetSequenceNumber () + 4096) % 4096) > 2047)
>             {
>               it = m_retryPackets.insert (it, item);
>               break;
>             }
>           else
>             {
>               it++;
>               if (it == m_retryPackets.end ())
>                 {
>                   m_retryPackets.push_back (item);
>                 }
>             }
1005,1031d1015
< 
<       it = m_retryPackets->PeekByTidAndAddress (tid, recipient, ++it);
<     }
<   mpdu->GetHeader ().SetRetry ();
<   m_retryPackets->Insert (it, mpdu);
< }
< 
< uint16_t
< BlockAckManager::GetRecipientBufferSize (Mac48Address recipient, uint8_t tid) const
< {
<   uint16_t size = 0;
<   AgreementsCI it = m_agreements.find (std::make_pair (recipient, tid));
<   if (it != m_agreements.end ())
<     {
<       size = it->second.first.GetBufferSize ();
<     }
<   return size;
< }
< 
< uint16_t
< BlockAckManager::GetOriginatorStartingSequence (Mac48Address recipient, uint8_t tid) const
< {
<   uint16_t seqNum = 0;
<   AgreementsCI it = m_agreements.find (std::make_pair (recipient, tid));
<   if (it != m_agreements.end ())
<     {
<       seqNum = it->second.first.GetStartingSequence ();
1033d1016
<   return seqNum;
diff ../../NS3-WiGig/src/wifi/model/block-ack-manager.h ../../ns-3-dev/src/wifi/model/block-ack-manager.h
25,26c25,27
< #include "ns3/nstime.h"
< #include "ns3/traced-callback.h"
---
> #include <list>
> #include <deque>
> #include "ns3/packet.h"
28a30,32
> #include "ctrl-headers.h"
> #include "qos-utils.h"
> #include "wifi-mode.h"
30,31d33
< #include "block-ack-type.h"
< #include "wifi-mac-queue-item.h"
35d36
< class WifiRemoteStationManager;
38,39c39
< class CtrlBAckResponseHeader;
< class CtrlBAckRequestHeader;
---
> class MgtDelBaHeader;
42,43d41
< class WifiMode;
< class Packet;
47c45
<  * \brief BlockAckRequest frame information
---
>  * \brief Block Ack Request
54c52,53
<    * Store a BlockAckRequest along with the corresponding TID.
---
>    * Construct Block ACK request for a given packet,
>    * receiver address, Traffic ID, and ACK policy.
56,63c55,67
<    * \param bar the BAR
<    * \param tid the Traffic ID
<    * \param skipIfNoDataQueued true to hold this BAR if there is no data queued
<    */
<   Bar (Ptr<const WifiMacQueueItem> bar, uint8_t tid, bool skipIfNoDataQueued = false);
<   Ptr<const WifiMacQueueItem> bar;  ///< BlockAckRequest
<   uint8_t tid;                      ///< TID
<   bool skipIfNoDataQueued;          ///< do not send if there is no data queued
---
>    * \param packet
>    * \param recipient
>    * \param tid
>    * \param immediate
>    */
>   Bar (Ptr<const Packet> packet,
>        Mac48Address recipient,
>        uint8_t tid,
>        bool immediate);
>   Ptr<const Packet> bar;
>   Mac48Address recipient;
>   uint8_t tid;
>   bool immediate;
71c75
< class BlockAckManager : public Object
---
> class BlockAckManager
74d77
<   /// type conversion operator
76,81c79
<   /**
<    * assignment operator
<    * \param block BlockAckManager to assign
<    * \returns the assigned BlockAckManager
<    */
<   BlockAckManager& operator= (const BlockAckManager& block);
---
>   BlockAckManager& operator= (const BlockAckManager&);
85,90d82
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
<   static TypeId GetTypeId (void);
< 
99,106c91
<   void SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> manager);
<   /**
<    * \param recipient Address of peer station involved in block ack mechanism.
<    *
<    * Copy all block ack agreement exists with station addressed by
<    * <i>recipient</i> for tid <i>tid</i>.
<    */
<   void CopyAgreements (Mac48Address recipient, Ptr<BlockAckManager> manager);
---
>   void SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> manager);
114c99
<    * <i>recipient</i> for TID <i>tid</i>.
---
>    * <i>recipient</i> for tid <i>tid</i>.
125c110
<    * station addressed by <i>recipient</i> for TID <i>tid</i>.
---
>    * station addressed by <i>recipient</i> for tid <i>tid</i>.
128c113
<                                OriginatorBlockAckAgreement::State state) const;
---
>                                enum OriginatorBlockAckAgreement::State state) const;
139c124
<    * \param tid traffic ID of transmitted packet.
---
>    * \param tid Tid Traffic id of transmitted packet.
141c126
<    * Invoked when a recipient reject a block ack agreement or when a DELBA frame
---
>    * Invoked when a recipient reject a block ack agreement or when a Delba frame
153c138,140
<    * \param mpdu MPDU to store.
---
>    * \param packet Packet to store.
>    * \param hdr 802.11 header for packet.
>    * \param tStamp time stamp for packet
155,156c142,143
<    * Stores <i>mpdu</i> for a possible future retransmission. Retransmission occurs
<    * if the packet, in a BlockAck frame, is indicated by recipient as not received.
---
>    * Stores <i>packet</i> for a possible future retransmission. Retransmission occurs
>    * if the packet, in a block ack frame, is indicated by recipient as not received.
158c145
<   void StorePacket (Ptr<WifiMacQueueItem> mpdu);
---
>   void StorePacket (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp);
160c147
<    * Returns the next BlockAckRequest to send, if any.
---
>    * \param hdr 802.11 header of returned packet (if exists).
162c149
<    * \param remove true if the BAR has to be removed from the queue
---
>    * \return the packet
164c151,152
<    * \return the next BAR to be sent, if any
---
>    * This methods returns a packet (if exists) indicated as not received in
>    * corresponding block ack bitmap.
166c154
<   Ptr<const WifiMacQueueItem> GetBar (bool remove = true);
---
>   Ptr<const Packet> GetNextPacket (WifiMacHeader &hdr);
168,169c156
<    * Returns true if there are packets that need of retransmission or at least a
<    * BAR is scheduled. Returns false otherwise.
---
>    * \param hdr 802.11 header of returned packet (if exists).
171,179c158
<    * \return true if there are packets that need of retransmission or at least a BAR is scheduled,
<    *         false otherwise
<    */
<   bool HasPackets (void);
<   /**
<    * Invoked upon receipt of an Ack frame after the transmission of a QoS data frame
<    * sent under an established block ack agreement. Remove the acknowledged frame
<    * from the outstanding packets and update the starting sequence number of the
<    * transmit window, if needed.
---
>    * \return the packet
181c160,161
<    * \param mpdu The acknowledged MPDU.
---
>    * This methods returns a packet (if exists) indicated as not received in
>    * corresponding block ack bitmap. This method doesn't remove the packet from this queue.
183c163,164
<   void NotifyGotAck (Ptr<const WifiMacQueueItem> mpdu);
---
>   Ptr<const Packet> PeekNextPacket (WifiMacHeader &hdr);
>   bool HasBar (struct Bar &bar);
185,188c166,167
<    * Invoked upon missed reception of an Ack frame after the transmission of a
<    * QoS data frame sent under an established block ack agreement. Remove the
<    * acknowledged frame from the outstanding packets and insert it in the
<    * retransmission queue.
---
>    * Returns true if there are packets that need of retransmission or at least a
>    * BAR is scheduled. Returns false otherwise.
190c169,170
<    * \param mpdu The unacknowledged MPDU.
---
>    * \return true if there are packets that need of retransmission or at least a BAR is scheduled,
>    *         false otherwise
192c172
<   void NotifyMissedAck (Ptr<WifiMacQueueItem> mpdu);
---
>   bool HasPackets (void) const;
194,196c174,177
<    * \param blockAck The received BlockAck frame.
<    * \param recipient Sender of BlockAck frame.
<    * \param rxSnr received SNR of the BlockAck frame itself
---
>    * \param blockAck The received block ack frame.
>    * \param recipient Sender of block ack frame.
>    * \param rxSnr received SNR of the block ack frame itself
>    * \param txMode mode of block ack frame.
198d178
<    * \param dataTxVector the TXVECTOR used to send the Data
200,202c180,182
<    * Invoked upon receipt of a BlockAck frame. Typically, this function, is called
<    * by ns3::QosTxop object. Performs a check on which MPDUs, previously sent
<    * with Ack Policy set to Block Ack, were correctly received by the recipient.
---
>    * Invoked upon receipt of a block ack frame. Typically, this function, is called
>    * by ns3::EdcaTxopN object. Performs a check on which MPDUs, previously sent
>    * with ack policy set to Block Ack, were correctly received by the recipient.
205,206c185
<   void NotifyGotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient,
<                           double rxSnr, double dataSnr, WifiTxVector dataTxVector);
---
>   void NotifyGotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, WifiMode txMode, double dataSnr);
208c187
<    * \param recipient Sender of the expected BlockAck frame.
---
>    * \param recipient Address of peer station involved in block ack mechanism.
211,218c190
<    * Invoked upon missed reception of a block ack frame. Typically, this function, is called
<    * by ns3::QosTxop object. Performs a check on which MPDUs, previously sent
<    * with ack policy set to Block Ack, should be placed in the retransmission queue.
<    */
<   void NotifyMissedBlockAck (Mac48Address recipient, uint8_t tid);
<   /**
<    * \param recipient outstanding frames' receiver.
<    * \param tid Traffic ID.
---
>    * \return the number of packets buffered for a specified agreement
220,222c192,193
<    * Discard all the outstanding MPDUs destined to the given receiver and belonging
<    * to the given TID. Typically, this function is called by ns3::QosTxop object
<    * when it gives up retransmitting either a BlockAckRequest or the Data frames.
---
>    * Returns number of packets buffered for a specified agreement. This methods doesn't return
>    * number of buffered MPDUs but number of buffered MSDUs.
224c195
<   void DiscardOutstandingMpdus (Mac48Address recipient, uint8_t tid);
---
>   uint32_t GetNBufferedPackets (Mac48Address recipient, uint8_t tid) const;
229c200
<    * \return the number of packets buffered for a specified agreement
---
>    * \return the number of packets for a specific agreement that need retransmission
231,232c202,203
<    * Returns the number of packets buffered for a specified agreement. This methods doesn't return
<    * the number of buffered MPDUs but the number of buffered MSDUs.
---
>    * Returns number of packets for a specific agreement that need retransmission.
>    * This method doesn't return number of MPDUs that need retransmission but number of MSDUs.
234c205
<   uint32_t GetNBufferedPackets (Mac48Address recipient, uint8_t tid) const;
---
>   uint32_t GetNRetryNeededPackets (Mac48Address recipient, uint8_t tid) const;
248c219
<    * Marks an agreement as rejected. This happens if <i>recipient</i> station reject block ack setup
---
>    * Marks an agreement as unsuccessful. This happens if <i>recipient</i> station reject block ack setup
252c223
<   void NotifyAgreementRejected (Mac48Address recipient, uint8_t tid);
---
>   void NotifyAgreementUnsuccessful (Mac48Address recipient, uint8_t tid);
255a227,228
>    * \param nextSeqNumber Sequence number of the next packet that would be trasmitted by EdcaTxopN.
>    * \param policy ack policy of the transmitted packet.
257,259c230,232
<    * Marks an agreement after not receiving response to ADDBA request. During this state
<    * any packets in queue will be transmitted using normal MPDU. This also unblock
<    * recipient address.
---
>    * This method is typically invoked by ns3::EdcaTxopN object every time that a MPDU
>    * with ack policy subfield in Qos Control field set to Block Ack is transmitted.
>    * The <i>nextSeqNumber</i> parameter is used to block transmission of packets that are out of bitmap.
261c234
<   void NotifyAgreementNoReply (Mac48Address recipient, uint8_t tid);
---
>   void NotifyMpduTransmission (Mac48Address recipient, uint8_t tid, uint16_t nextSeqNumber, WifiMacHeader::QosAckPolicy policy);
266c239
<    * Set BA agreement to a transitory state to reset it after not receiving response to ADDBA request.
---
>    * This method to set the number of packets waitin for blockAck = 0 since the receiver will send the blockAck right away
268c241
<   void NotifyAgreementReset (Mac48Address recipient, uint8_t tid);
---
>   void CompleteAmpduExchange (Mac48Address recipient, uint8_t tid);
272c245
<    * Upon receipt of a BlockAck frame, if total number of packets (packets in WifiMacQueue
---
>    * Upon receipt of a block ack frame, if total number of packets (packets in WifiMacQueue
276,281d248
<   /**
<    * \return the retransmit queue.
<    *
<    * Return the retransmit queue.
<    */
<   Ptr<WifiMacQueue> GetRetransmitQueue (void);
286,291c253,254
<   void SetQueue (const Ptr<WifiMacQueue> queue);
<   /**
<    * Set the MacTxMiddle
<    * \param txMiddle the MacTxMiddle
<    */
<   void SetTxMiddle (const Ptr<MacTxMiddle> txMiddle);
---
>   void SetQueue (Ptr<WifiMacQueue> queue);
>   void SetTxMiddle (MacTxMiddle* txMiddle);
294c257
<    * \param bAckType Type of BlockAck
---
>    * \param bAckType Type of block ack
298,299c261
<   void SetBlockAckType (BlockAckType bAckType);
< 
---
>   void SetBlockAckType (enum BlockAckType bAckType);
301,302c263,267
<    * Set BlockAck inactivity callback
<    * \param callback the BlockAck inactivity callback function
---
>    * \param recipient Address of station involved in block ack mechanism.
>    * \param tid Traffic ID.
>    *
>    * This method is invoked by EdcaTxopN object upon receipt of a DELBA frame
>    * from recipient. The relative block ack agreement is destroyed.
304c269
<   void SetBlockAckInactivityCallback (Callback<void, Mac48Address, uint8_t, bool> callback);
---
>   void TearDownBlockAck (Mac48Address recipient, uint8_t tid);
306,307c271,277
<    * Set block destination callback
<    * \param callback the block destination callback
---
>    * \param sequenceNumber Sequence number of the packet which fragment is
>    * part of.
>    * \return true if another fragment with the given sequence number is scheduled
>    * for retransmission.
>    *
>    * Returns true if another fragment with sequence number <i>sequenceNumber</i> is scheduled
>    * for retransmission.
309c279
<   void SetBlockDestinationCallback (Callback<void, Mac48Address, uint8_t> callback);
---
>   bool HasOtherFragments (uint16_t sequenceNumber) const;
311,312c281,283
<    * Set unblock destination callback
<    * \param callback the unblock destination callback
---
>    * \return the size of the next packet that needs retransmission
>    *
>    * Returns size of the next packet that needs retransmission.
313a285,295
>   uint32_t GetNextPacketSize (void) const;
>   /**
>    * \param maxDelay Max delay for a buffered packet.
>    *
>    * This method is always called by ns3::WifiMacQueue object and sets max delay equals
>    * to ns3:WifiMacQueue delay value.
>    */
>   void SetMaxPacketDelay (Time maxDelay);
> 
>   void SetBlockAckInactivityCallback (Callback<void, Mac48Address, uint8_t, bool> callback);
>   void SetBlockDestinationCallback (Callback<void, Mac48Address, uint8_t> callback);
317,319c299,301
<    * \param recipient the destination address
<    * \param tid the Traffic ID
<    * \param startingSeq the starting sequence number
---
>    * \param recipient
>    * \param tid
>    * \param startingSeq
321c303
<    * \return true if there are packets in the queue that could be sent under block ack,
---
>    * \return true if there are packets in the queue that could be sent under block ACK,
331,333c313,314
<    * This function returns true if a block ack agreement is established with the
<    * given recipient for the given TID and there is at least an outstanding MPDU
<    * for such agreement whose lifetime is not expired.
---
>    * \param recipient
>    * \param tid
335,336c316
<    * \param tid Traffic ID
<    * \param recipient MAC address of the recipient
---
>    * \return the sequence number of the next retry packet for a specific agreement
338c318,320
<    * \returns true if BAR retransmission needed
---
>    * Returns the sequence number of the next retry packet for a specific agreement.
>    * If there are no packets that need retransmission for the specified agreement or
>    * the agreement doesn't exist the function returns 4096;
340c322
<   bool NeedBarRetransmission (uint8_t tid, Mac48Address recipient);
---
>   uint16_t GetSeqNumOfNextRetryPacket (Mac48Address recipient, uint8_t tid) const;
342,347c324
<    * This function returns the buffer size negotiated with the recipient.
<    *
<    * \param tid Traffic ID
<    * \param recipient MAC address of the recipient
<    *
<    * \returns the buffer size negotiated with the recipient
---
>    * Checks if the packet already exists in the retransmit queue or not if it does then it doesn't add it again
349c326
<   uint16_t GetRecipientBufferSize (Mac48Address recipient, uint8_t tid) const;
---
>   bool AlreadyExists (uint16_t currentSeq, Mac48Address recipient, uint8_t tid);
351,356c328
<    * This function returns the starting sequence number of the transmit window.
<    *
<    * \param tid Traffic ID
<    * \param recipient MAC address of the recipient
<    *
<    * \returns the starting sequence number of the transmit window (WinStartO)
---
>    * Remove a packet after you peek in the queue and get it
358c330,341
<   uint16_t GetOriginatorStartingSequence (Mac48Address recipient, uint8_t tid) const;
---
>   bool RemovePacket (uint8_t tid, Mac48Address recipient, uint16_t seqnumber);
>   /*
>    * Peek in retransmit queue and get the next packet having address indicated
>    * by <i>type</i> equals to <i>addr</i>, and tid equals to <i>tid</i>.
>    * This method doesn't remove the packet from this queue.
>    */
>   Ptr<const Packet> PeekNextPacketByTidAndAddress (WifiMacHeader &hdr, Mac48Address recipient, uint8_t tid, Time *timestamp);
>   /**
>    * This function returns true if the lifetime of the packets a BAR refers to didn't expire yet else it returns false.
>    * If it return false then the BAR will be discarded (i.e. will not be re-transmitted)
>    */
>   bool NeedBarRetransmission (uint8_t tid, uint16_t seqNumber, Mac48Address recipient);
381,401d363
<   /**
<    * TracedCallback signature for state changes.
<    *
<    * \param [in] now Time when the \pname{state} changed.
<    * \param [in] recipient MAC address of the recipient.
<    * \param [in] tid the TID.
<    * \param [in] state The state.
<    */
<   typedef void (* AgreementStateTracedCallback)(Time now, Mac48Address recipient, uint8_t tid, OriginatorBlockAckAgreement::State state);
< 
<   /**
<    * \param mpdu the discarded frame
<    *
<    * Notify the block ack manager that an MPDU has been discarded, e.g., because
<    * the MSDU lifetime expired. If there is an established block ack agreement,
<    * make the transmit window advance beyond the discarded frame. This also
<    * involves (i) the removal of frames that consequently become old from the
<    * retransmit queue and from the queue of the block ack agreement, and (ii) the
<    * scheduling of a BlockAckRequest.
<    */
<   void NotifyDiscardedMpdu (Ptr<const WifiMacQueueItem> mpdu);
402a365
> private:
404,405c367,368
<    * \param recipient the recipient
<    * \param tid the TID
---
>    * \param recipient
>    * \param tid
407,414c370
<    * Get the BlockAckRequest header for the established BA agreement
<    * (<i>recipient</i>,<i>tid</i>).
<    */
<   CtrlBAckRequestHeader GetBlockAckReqHeader (Mac48Address recipient, uint8_t tid) const;
< 
<   /**
<    * \param bar the BlockAckRequest to enqueue
<    * \param skipIfNoDataQueued do not send if there is no data queued
---
>    * \return a packet
416,427c372,375
<    * Enqueue the given BlockAckRequest into the queue storing the next BAR
<    * frames to transmit. If a BAR for the same recipient and TID is already present
<    * in the queue, it is replaced by the new one. If the given BAR is retransmitted,
<    * it is placed at the head of the queue, otherwise at the tail.
<    */
<   void ScheduleBar (Ptr<const WifiMacQueueItem> bar, bool skipIfNoDataQueued = false);
< 
< private:
<   /**
<    * Inactivity timeout function
<    * \param recipient the recipient MAC address
<    * \param tid Traffic ID
---
>    * Checks if all packets, for which a block ack agreement was established or refreshed,
>    * have been transmitted. If yes, adds a pair in m_bAckReqs to indicate that
>    * at next channel access a block ack request (for established agreement
>    * <i>recipient</i>,<i>tid</i>) is needed.
429c377
<   void InactivityTimeout (Mac48Address recipient, uint8_t tid);
---
>   Ptr<Packet> ScheduleBlockAckReqIfNeeded (Mac48Address recipient, uint8_t tid);
432,439c380
<    * Remove packets from the retransmit queue and from the queue of outstanding
<    * packets that become old after setting the starting sequence number for the
<    * agreement with recipient equal to <i>recipient</i> and TID equal to <i>tid</i>
<    * to the given <i>startingSeq</i>.
<    *
<    * \param recipient the recipient MAC address
<    * \param tid Traffic ID
<    * \param startingSeq the new starting sequence number
---
>    * This method removes packets whose lifetime was exceeded.
441c382,383
<   void RemoveOldPackets (Mac48Address recipient, uint8_t tid, uint16_t startingSeq);
---
>   void CleanupBuffers (void);
>   void InactivityTimeout (Mac48Address, uint8_t);
442a385
>   struct Item;
444c387
<    * typedef for a list of WifiMacQueueItem.
---
>    * typedef for a list of Item struct.
446c389
<   typedef std::list<Ptr<WifiMacQueueItem>> PacketQueue;
---
>   typedef std::list<Item> PacketQueue;
450c393
<   typedef std::list<Ptr<WifiMacQueueItem>>::iterator PacketQueueI;
---
>   typedef std::list<Item>::iterator PacketQueueI;
454c397
<   typedef std::list<Ptr<WifiMacQueueItem>>::const_iterator PacketQueueCI;
---
>   typedef std::list<Item>::const_iterator PacketQueueCI;
456c399
<    * typedef for a map between MAC address and block ack agreement.
---
>    * typedef for a map between MAC address and block ACK agreement.
472,485c415,416
<    * \param mpdu the packet to insert in the retransmission queue
<    *
<    * Insert <i>mpdu</i> in retransmission queue.
<    * This method ensures packets are retransmitted in the correct order.
<    */
<   void InsertInRetryQueue (Ptr<WifiMacQueueItem> mpdu);
< 
<   /**
<    * Remove an item from retransmission queue.
<    * This method should be called when packets are acknowledged.
<    *
<    * \param address recipient MAC address of the packet to be removed
<    * \param tid Traffic ID of the packet to be removed
<    * \param seq sequence number of the packet to be removed
---
>    * A struct for packet, Wifi header, and timestamp.
>    * Used in queue by block ACK manager.
487,488c418,427
<   void RemoveFromRetryQueue (Mac48Address address, uint8_t tid, uint16_t seq);
< 
---
>   struct Item
>   {
>     Item ();
>     Item (Ptr<const Packet> packet,
>           const WifiMacHeader &hdr,
>           Time tStamp);
>     Ptr<const Packet> packet;
>     WifiMacHeader hdr;
>     Time timestamp;
>   };
490,491c429
<    * Remove a range of items from retransmission queue.
<    * This method should be called when packets are acknowledged.
---
>    * \param item
493,496c431,432
<    * \param address recipient MAC address of the packet to be removed
<    * \param tid Traffic ID of the packet to be removed
<    * \param startSeq sequence number of the first packet to be removed
<    * \param endSeq sequence number of the last packet to be removed
---
>    * Insert item in retransmission queue.
>    * This method ensures packets are retransmitted in the correct order.
498c434
<   void RemoveFromRetryQueue (Mac48Address address, uint8_t tid, uint16_t startSeq, uint16_t endSeq);
---
>   void InsertInRetryQueue (PacketQueueI item);
501c437
<    * This data structure contains, for each block ack agreement (recipient, TID), a set of packets
---
>    * This data structure contains, for each block ack agreement (recipient, tid), a set of packets
503c439
<    * Every packet or fragment indicated as correctly received in BlockAck frame is
---
>    * Every packet or fragment indicated as correctly received in block ack frame is
510c446
<    * A packet needs retransmission if it's indicated as not correctly received in a BlockAck
---
>    * A packet needs retransmission if it's indicated as not correctly received in a block ack
513,526c449,450
<   Ptr<WifiMacQueue> m_retryPackets;
<   std::list<Bar> m_bars; ///< list of BARs
< 
<   uint8_t m_blockAckThreshold; ///< block ack threshold
<   BlockAckType m_blockAckType; ///< BlockAck type
<   Ptr<MacTxMiddle> m_txMiddle; ///< the MacTxMiddle
<   Mac48Address m_address;      ///< address
<   Ptr<WifiMacQueue> m_queue;   ///< queue
<   Callback<void, Mac48Address, uint8_t, bool> m_blockAckInactivityTimeout; ///< BlockAck inactivity timeout callback
<   Callback<void, Mac48Address, uint8_t> m_blockPackets;   ///< block packets callback
<   Callback<void, Mac48Address, uint8_t> m_unblockPackets; ///< unblock packets callback
<   TxOk m_txOkCallback;                                    ///< transmit OK callback
<   TxFailed m_txFailedCallback;                            ///< transmit failed callback
<   Ptr<WifiRemoteStationManager> m_stationManager;         ///< the station manager
---
>   std::list<PacketQueueI> m_retryPackets;
>   std::list<Bar> m_bars;
528,531c452,463
<   /**
<    * The trace source fired when a state transition occurred.
<    */
<   TracedCallback<Time, Mac48Address, uint8_t, OriginatorBlockAckAgreement::State> m_agreementState;
---
>   uint8_t m_blockAckThreshold;
>   enum BlockAckType m_blockAckType;
>   Time m_maxDelay;
>   MacTxMiddle* m_txMiddle;
>   Mac48Address m_address;
>   Ptr<WifiMacQueue> m_queue;
>   Callback<void, Mac48Address, uint8_t, bool> m_blockAckInactivityTimeout;
>   Callback<void, Mac48Address, uint8_t> m_blockPackets;
>   Callback<void, Mac48Address, uint8_t> m_unblockPackets;
>   TxOk m_txOkCallback;
>   TxFailed m_txFailedCallback;
>   Ptr<WifiRemoteStationManager> m_stationManager;
Only in ../../NS3-WiGig/src/wifi/model: block-ack-type.h
Only in ../../NS3-WiGig/src/wifi/model: block-ack-window.cc
Only in ../../NS3-WiGig/src/wifi/model: block-ack-window.h
diff ../../NS3-WiGig/src/wifi/model/capability-information.cc ../../ns-3-dev/src/wifi/model/capability-information.cc
21a22
> #include "ns3/log.h"
24a26,27
> NS_LOG_COMPONENT_DEFINE ("CapabilityInformation");
> 
27a31
>   NS_LOG_FUNCTION (this);
32a37
>   NS_LOG_FUNCTION (this);
39a45
>   NS_LOG_FUNCTION (this);
46a53
>   NS_LOG_FUNCTION (this);
55a63
>   NS_LOG_FUNCTION (this);
62,67d69
< void
< CapabilityInformation::SetCfPollable (void)
< {
<   Set (2);
< }
< 
70a73
>   NS_LOG_FUNCTION (this);
76a80
>   NS_LOG_FUNCTION (this);
82a87
>   NS_LOG_FUNCTION (this);
88a94
>   NS_LOG_FUNCTION (this);
92,97d97
< bool
< CapabilityInformation::IsCfPollable (void) const
< {
<   return Is (2);
< }
< 
100a101
>   NS_LOG_FUNCTION (this << static_cast<uint32_t> (n));
107a109
>   NS_LOG_FUNCTION (this << static_cast<uint32_t> (n));
114a117
>   NS_LOG_FUNCTION (this << static_cast<uint32_t> (n));
121a125
>   NS_LOG_FUNCTION (this);
127a132
>   NS_LOG_FUNCTION (this << &start);
134a140
>   NS_LOG_FUNCTION (this << &start);
diff ../../NS3-WiGig/src/wifi/model/capability-information.h ../../ns-3-dev/src/wifi/model/capability-information.h
23a24
> #include <stdint.h>
52c53
<    * \param shortPreamble the short preamble bit
---
>    * /param shortPreamble the short preamble bit
60c61
<    * \param shortSlotTime the short preamble bit
---
>    * /param shortslotTime the short preamble bit
64,68d64
<   /**
<    * Set the CF-Pollable bit
<    * in the capability information field.
<    */
<   void SetCfPollable (void);
102,109d97
<   /**
<    * Check if the CF-Pollable bit
<    * in the capability information field is set to 1.
<    *
<    * \return CF-Pollable bit in the capability information
<    *         field is set to 1
<    */
<   bool IsCfPollable (void) const;
158,159c146
< 
<   uint16_t m_capability; ///< capability
---
>   uint16_t m_capability;
diff ../../NS3-WiGig/src/wifi/model/cara-wifi-manager.cc ../../ns-3-dev/src/wifi/model/cara-wifi-manager.cc
21d20
< #include "ns3/log.h"
23c22,26
< #include "wifi-tx-vector.h"
---
> #include "ns3/assert.h"
> #include "ns3/log.h"
> #include "ns3/double.h"
> #include "ns3/uinteger.h"
> #include "ns3/simulator.h"
29c32
< NS_LOG_COMPONENT_DEFINE ("CaraWifiManager");
---
> NS_LOG_COMPONENT_DEFINE ("Cara");
39,42c42,45
<   uint32_t m_timer;   ///< timer count
<   uint32_t m_success; ///< success count
<   uint32_t m_failed;  ///< failed count
<   uint8_t m_rate;     ///< rate in bps
---
>   uint32_t m_timer;
>   uint32_t m_success;
>   uint32_t m_failed;
>   uint32_t m_rate;
65c68
<                    "The minimum number of successful transmissions to try a new rate.",
---
>                    "The minimum number of sucessfull transmissions to try a new rate.",
74,77d76
<     .AddTraceSource ("Rate",
<                      "Traced value for rate changes (b/s)",
<                      MakeTraceSourceAccessor (&CaraWifiManager::m_currentRate),
<                      "ns3::TracedValueCallback::Uint64")
83,84c82
<   : WifiRemoteStationManager (),
<     m_currentRate (0)
---
>   : WifiRemoteStationManager ()
94,111d91
< void
< CaraWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
134c114
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
---
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
161a142
>   NS_LOG_DEBUG ("self=" << st << " rts ok");
165,166c146,147
< CaraWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> CaraWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                  double ackSnr, WifiMode ackMode, double dataSnr)
168,169c149,150
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
181c162
<       NS_LOG_DEBUG ("self=" << station << " inc rate=" << +station->m_rate);
---
>       NS_LOG_DEBUG ("self=" << station << " inc rate=" << station->m_rate);
203,204c184,185
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
206a188
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
209,215c191
<   WifiMode mode = GetSupported (station, station->m_rate);
<   if (m_currentRate != mode.GetDataRate (channelWidth))
<     {
<       NS_LOG_DEBUG ("New datarate: " << mode.GetDataRate (channelWidth));
<       m_currentRate = mode.GetDataRate (channelWidth);
<     }
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, station->m_rate), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
222c198
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
---
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
225c201
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   uint32_t channelWidth = GetChannelWidth (station);
227a204
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
231d207
<   WifiMode mode;
234c210
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (station, 0), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
238c214
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (station, 0), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
240d215
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
246c221
<                             uint32_t size, bool normally)
---
>                             Ptr<const Packet> packet, bool normally)
248,249c223,224
<   NS_LOG_FUNCTION (this << st << size << normally);
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << normally);
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
250a226,252
> }
> 
> bool
> CaraWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
> }
> 
> void
> CaraWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> CaraWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/cara-wifi-manager.h ../../ns-3-dev/src/wifi/model/cara-wifi-manager.h
24d23
< #include "ns3/traced-value.h"
40,42c39,41
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
---
>  * This RAA does not support HT or VHT modes and will error exit
>  * if the user tries to configure this RAA with a Wi-Fi MAC that
>  * has VhtSupported or HtSupported set.
47,50d45
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
54a50,52
>   // Inherited from WifiRemoteStationManager
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
57,80c55,76
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
<   bool DoNeedRts (WifiRemoteStation *station,
<                   uint32_t size, bool normally);
< 
<   uint32_t m_timerTimeout;     ///< timer threshold
<   uint32_t m_successThreshold; ///< success threshold
<   uint32_t m_failureThreshold; ///< failure threshold
<   uint32_t m_probeThreshold;   ///< probe threshold
< 
<   TracedValue<uint64_t> m_currentRate; //!< Trace rate changes
---
>   //overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool DoNeedRts (WifiRemoteStation *station,
>                           Ptr<const Packet> packet, bool normally);
>   virtual bool IsLowLatency (void) const;
> 
>   uint32_t m_timerTimeout;
>   uint32_t m_successThreshold;
>   uint32_t m_failureThreshold;
>   uint32_t m_probeThreshold;
Only in ../../NS3-WiGig/src/wifi/model: cbtraa-dmg-wifi-manager.cc
Only in ../../NS3-WiGig/src/wifi/model: cbtraa-dmg-wifi-manager.h
Only in ../../NS3-WiGig/src/wifi/model: cf-parameter-set.cc
Only in ../../NS3-WiGig/src/wifi/model: cf-parameter-set.h
Only in ../../NS3-WiGig/src/wifi/model: channel-access-manager.cc
Only in ../../NS3-WiGig/src/wifi/model: channel-access-manager.h
Only in ../../NS3-WiGig/src/wifi/model: codebook-analytical.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook-analytical.h
Only in ../../NS3-WiGig/src/wifi/model: codebook.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook.h
Only in ../../NS3-WiGig/src/wifi/model: codebook-numerical.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook-numerical.h
Only in ../../NS3-WiGig/src/wifi/model: codebook-parametric-2d.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook-parametric-2d.h
Only in ../../NS3-WiGig/src/wifi/model: codebook-parametric.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook-parametric.h
Only in ../../NS3-WiGig/src/wifi/model: common-header.cc
Only in ../../NS3-WiGig/src/wifi/model: common-header.h
Only in ../../NS3-WiGig/src/wifi/model: constant-obss-pd-algorithm.cc
Only in ../../NS3-WiGig/src/wifi/model: constant-obss-pd-algorithm.h
diff ../../NS3-WiGig/src/wifi/model/constant-rate-wifi-manager.cc ../../ns-3-dev/src/wifi/model/constant-rate-wifi-manager.cc
20a21
> #include "constant-rate-wifi-manager.h"
21a23
> #include "ns3/assert.h"
23,25d24
< #include "constant-rate-wifi-manager.h"
< #include "wifi-tx-vector.h"
< #include "wifi-utils.h"
54,65d52
< void
< ConstantRateWifiManager::SetDataMode (WifiMode mode)
< {
<   m_dataMode = mode;
< }
< 
< void
< ConstantRateWifiManager::SetControlMode (WifiMode mode)
< {
<   m_ctlMode = mode;
< }
< 
111,112c98,99
< ConstantRateWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                          double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> ConstantRateWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                          double ackSnr, WifiMode ackMode, double dataSnr)
114c101
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
133,138c120
<   uint8_t nss = Min (GetMaxNumberOfTransmitStreams (), GetNumberOfSupportedStreams (st));
<   if (m_dataMode.GetModulationClass () == WIFI_MOD_CLASS_HT)
<     {
<       nss = 1 + (m_dataMode.GetMcsValue () / 8);
<     }
<   return WifiTxVector (m_dataMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (m_dataMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), ConvertGuardIntervalToNanoSeconds (m_dataMode, GetShortGuardIntervalSupported (st), NanoSeconds (GetGuardInterval (st))), GetNumberOfAntennas (), nss, 0, GetChannelWidthForTransmission (m_dataMode, GetChannelWidth (st)), GetAggregation (st), false);
---
>   return WifiTxVector (m_dataMode, GetDefaultTxPowerLevel (), GetLongRetryCount (st), GetShortGuardInterval (st), Min(GetNumberOfTransmitAntennas (), GetNumberOfSupportedRxAntennas (st)), 0, GetChannelWidth (st), GetAggregation (st), false);
145c127,134
<   return WifiTxVector (m_ctlMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (m_ctlMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), ConvertGuardIntervalToNanoSeconds (m_ctlMode, GetShortGuardIntervalSupported (st), NanoSeconds (GetGuardInterval (st))), 1, 1, 0, GetChannelWidthForTransmission (m_ctlMode, GetChannelWidth (st)), GetAggregation (st), false);
---
>   return WifiTxVector (m_ctlMode, GetDefaultTxPowerLevel (), GetShortRetryCount (st), GetShortGuardInterval (st), 1, 0, GetChannelWidth (st), GetAggregation (st), false);
> }
> 
> bool
> ConstantRateWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
diff ../../NS3-WiGig/src/wifi/model/constant-rate-wifi-manager.h ../../ns-3-dev/src/wifi/model/constant-rate-wifi-manager.h
23a24
> #include <stdint.h>
38,41d38
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
45,46c42
<   virtual void SetDataMode (WifiMode mode);
<   virtual void SetControlMode (WifiMode mode);
---
> 
49,62c45,59
<   //overridden from base class
<   WifiRemoteStation* DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
---
>   //overriden from base class
>   virtual WifiRemoteStation* DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool IsLowLatency (void) const;
64c61
<   WifiMode m_dataMode; //!< Wifi mode for unicast Data frames
---
>   WifiMode m_dataMode; //!< Wifi mode for unicast DATA frames
Only in ../../NS3-WiGig/src/wifi/model: constant-wifi-ack-policy-selector.cc
Only in ../../NS3-WiGig/src/wifi/model: constant-wifi-ack-policy-selector.h
Only in ../../NS3-WiGig/src/wifi/model: control-trailer.cc
Only in ../../NS3-WiGig/src/wifi/model: control-trailer.h
diff ../../NS3-WiGig/src/wifi/model/ctrl-headers.cc ../../ns-3-dev/src/wifi/model/ctrl-headers.cc
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
19,20c18
<  * Authors: Mirko Banchi <mk.banchi@gmail.com>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mirko Banchi <mk.banchi@gmail.com>
22c20,21
< #include "ns3/address-utils.h"
---
> 
> #include "ns3/fatal-error.h"
38c37,38
<     m_baType (BASIC_BLOCK_ACK)
---
>     m_multiTid (false),
>     m_compressed (false)
39a40
>   NS_LOG_FUNCTION (this);
43a45
>   NS_LOG_FUNCTION (this);
48a51
>   NS_LOG_FUNCTION_NOARGS ();
59a63
>   NS_LOG_FUNCTION (this);
65a70
>   NS_LOG_FUNCTION (this << &os);
71a77
>   NS_LOG_FUNCTION (this);
74c80
<   switch (m_baType)
---
>   if (!m_multiTid)
76,86c82,93
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         size += 2;
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         size += (2 + 2) * (m_tidInfo + 1);
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       size += 2; //Starting sequence control
>     }
>   else
>     {
>       if (m_compressed)
>         {
>           size += (2 + 2) * (m_tidInfo + 1);  //Multi-tid block ack
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
93a101
>   NS_LOG_FUNCTION (this << &start);
96c104
<   switch (m_baType)
---
>   if (!m_multiTid)
98,108c106,117
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         i.WriteHtolsbU16 (GetStartingSequenceControl ());
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       i.WriteHtolsbU16 (GetStartingSequenceControl ());
>     }
>   else
>     {
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
114a124
>   NS_LOG_FUNCTION (this << &start);
117c127,131
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       SetStartingSequenceControl (i.ReadLsbtohU16 ());
>     }
>   else
119,129c133,140
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         SetStartingSequenceControl (i.ReadLsbtohU16 ());
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
136a148
>   NS_LOG_FUNCTION (this);
138c150
<   switch (m_baType)
---
>   if (m_barAckPolicy)
140,153c152,160
<       case BASIC_BLOCK_ACK:
<         break;
<       case COMPRESSED_BLOCK_ACK:
<         res |= (0x02 << 1);
<         break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         res |= (0x01 << 1);
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         res |= (0x03 << 1);
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       res |= 0x1;
>     }
>   if (m_multiTid)
>     {
>       res |= (0x1 << 1);
>     }
>   if (m_compressed)
>     {
>       res |= (0x1 << 2);
161a169
>   NS_LOG_FUNCTION (this << bar);
163,178c171,172
<   if (((bar >> 1) & 0x0f) == 0x03)
<     {
<       m_baType = MULTI_TID_BLOCK_ACK;
<     }
<   else if (((bar >> 1) & 0x0f) == 0x01)
<     {
<       m_baType = EXTENDED_COMPRESSED_BLOCK_ACK;
<     }
<   else if (((bar >> 1) & 0x0f) == 0x02)
<     {
<       m_baType = COMPRESSED_BLOCK_ACK;
<     }
<   else
<     {
<       m_baType = BASIC_BLOCK_ACK;
<     }
---
>   m_multiTid = (((bar >> 1) & 0x01) == 1) ? true : false;
>   m_compressed = (((bar >> 2) & 0x01) == 1) ? true : false;
184a179
>   NS_LOG_FUNCTION (this);
190a186
>   NS_LOG_FUNCTION (this << seqControl);
196a193
>   NS_LOG_FUNCTION (this << immediateAck);
201,207c198
< CtrlBAckRequestHeader::SetType (BlockAckType type)
< {
<   m_baType = type;
< }
< 
< BlockAckType
< CtrlBAckRequestHeader::GetType (void) const
---
> CtrlBAckRequestHeader::SetType (enum BlockAckType type)
209c200,218
<   return m_baType;
---
>   NS_LOG_FUNCTION (this << type);
>   switch (type)
>     {
>     case BASIC_BLOCK_ACK:
>       m_multiTid = false;
>       m_compressed = false;
>       break;
>     case COMPRESSED_BLOCK_ACK:
>       m_multiTid = false;
>       m_compressed = true;
>       break;
>     case MULTI_TID_BLOCK_ACK:
>       m_multiTid = true;
>       m_compressed = true;
>       break;
>     default:
>       NS_FATAL_ERROR ("Invalid variant type");
>       break;
>     }
214a224
>   NS_LOG_FUNCTION (this << static_cast<uint32_t> (tid));
220a231
>   NS_LOG_FUNCTION (this << seq);
226a238
>   NS_LOG_FUNCTION (this);
232a245
>   NS_LOG_FUNCTION (this);
239a253
>   NS_LOG_FUNCTION (this);
246c260,261
<   return (m_baType == BASIC_BLOCK_ACK) ? true : false;
---
>   NS_LOG_FUNCTION (this);
>   return (!m_multiTid && !m_compressed) ? true : false;
252,258c267,268
<   return (m_baType == COMPRESSED_BLOCK_ACK) ? true : false;
< }
< 
< bool
< CtrlBAckRequestHeader::IsExtendedCompressed (void) const
< {
<   return (m_baType == EXTENDED_COMPRESSED_BLOCK_ACK) ? true : false;
---
>   NS_LOG_FUNCTION (this);
>   return (!m_multiTid && m_compressed) ? true : false;
264c274,275
<   return (m_baType == MULTI_TID_BLOCK_ACK) ? true : false;
---
>   NS_LOG_FUNCTION (this);
>   return (m_multiTid && m_compressed) ? true : false;
276,279c287,288
<     m_baType (BASIC_BLOCK_ACK),
<     //// WIGIG ////
<     m_edmgCompressedBlockAckSize (EDMG_COMPRESSED_BLOCK_ACK_BITMAP_1024)
<     //// WIGIG ////
---
>     m_multiTid (false),
>     m_compressed (false)
280a290
>   NS_LOG_FUNCTION (this);
285a296
>   NS_LOG_FUNCTION (this);
307a319
>   NS_LOG_FUNCTION (this << &os);
313a326
>   NS_LOG_FUNCTION (this);
316c329,340
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       if (!m_compressed)
>         {
>           size += (2 + 128); //Basic block ack
>         }
>       else
>         {
>           size += (2 + 8); //Compressed block ack
>         }
>     }
>   else
318,337c342,349
<       case BASIC_BLOCK_ACK:
<         size += (2 + 128);
<         break;
<       case COMPRESSED_BLOCK_ACK:
<         size += (2 + 8);
<         break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         size += (2 + 32);
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         size += (2 + 2 + 8) * (m_tidInfo + 1); //Multi-TID block ack
<         break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         size += (2 + 128 + 1); // Consider that the compressed BlockAckBitmap is 1024 bits
<         break;
<       //// WIGIG ////
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       if (m_compressed)
>         {
>           size += (2 + 2 + 8) * (m_tidInfo + 1); //Multi-tid block ack
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
344a357
>   NS_LOG_FUNCTION (this << &start);
347c360,365
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       i.WriteHtolsbU16 (GetStartingSequenceControl ());
>       i = SerializeBitmap (i);
>     }
>   else
349,367c367,374
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         i.WriteHtolsbU16 (GetStartingSequenceControl ());
<         i = SerializeBitmap (i);
<         break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         i.WriteHtolsbU16 (GetStartingSequenceControl ());
<         i = SerializeBitmap (i);
<         i.WriteU8 (m_rbufcapValue);
<         break;
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
373a381
>   NS_LOG_FUNCTION (this << &start);
376c384,389
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       SetStartingSequenceControl (i.ReadLsbtohU16 ());
>       i = DeserializeBitmap (i);
>     }
>   else
378,396c391,398
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         SetStartingSequenceControl (i.ReadLsbtohU16 ());
<         i = DeserializeBitmap (i);
<         break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         SetStartingSequenceControl (i.ReadLsbtohU16 ());
<         i = DeserializeBitmap (i);
<         m_rbufcapValue = i.ReadU8 ();
<         break;
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
403a406
>   NS_LOG_FUNCTION (this << immediateAck);
408,414c411
< CtrlBAckResponseHeader::SetType (BlockAckType type)
< {
<   m_baType = type;
< }
< 
< BlockAckType
< CtrlBAckResponseHeader::GetType (void) const
---
> CtrlBAckResponseHeader::SetType (enum BlockAckType type)
416c413,431
<   return m_baType;
---
>   NS_LOG_FUNCTION (this << type);
>   switch (type)
>     {
>     case BASIC_BLOCK_ACK:
>       m_multiTid = false;
>       m_compressed = false;
>       break;
>     case COMPRESSED_BLOCK_ACK:
>       m_multiTid = false;
>       m_compressed = true;
>       break;
>     case MULTI_TID_BLOCK_ACK:
>       m_multiTid = true;
>       m_compressed = true;
>       break;
>     default:
>       NS_FATAL_ERROR ("Invalid variant type");
>       break;
>     }
421a437
>   NS_LOG_FUNCTION (this << static_cast<uint32_t> (tid));
427a444
>   NS_LOG_FUNCTION (this << seq);
433a451
>   NS_LOG_FUNCTION (this);
439a458
>   NS_LOG_FUNCTION (this);
446a466
>   NS_LOG_FUNCTION (this);
453c473,474
<   return (m_baType == BASIC_BLOCK_ACK) ? true : false;
---
>   NS_LOG_FUNCTION (this);
>   return (!m_multiTid && !m_compressed) ? true : false;
459,465c480,481
<   return (m_baType == COMPRESSED_BLOCK_ACK) ? true : false;
< }
< 
< bool
< CtrlBAckResponseHeader::IsExtendedCompressed (void) const
< {
<   return (m_baType == EXTENDED_COMPRESSED_BLOCK_ACK) ? true : false;
---
>   NS_LOG_FUNCTION (this);
>   return (!m_multiTid && m_compressed) ? true : false;
471,477c487,488
<   return (m_baType == MULTI_TID_BLOCK_ACK) ? true : false;
< }
< //// WIGIG ////
< bool
< CtrlBAckResponseHeader::IsEdmgCompressed (void) const
< {
<   return (m_baType == EDMG_COMPRESSED_BLOCK_ACK) ? true : false;
---
>   NS_LOG_FUNCTION (this);
>   return (m_multiTid && m_compressed) ? true : false;
479d489
< //// WIGIG ////
483a494
>   NS_LOG_FUNCTION (this);
489c500,504
<   switch (m_baType)
---
>   if (m_multiTid)
>     {
>       res |= (0x1 << 1);
>     }
>   if (m_compressed)
491,509c506
<       case BASIC_BLOCK_ACK:
<         break;
<       case COMPRESSED_BLOCK_ACK:
<         res |= (0x02 << 1);
<         break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         res |= (0x01 << 1);
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         res |= (0x03 << 1);
<         break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         res |= (0x08 << 1);
<         break;
<       //// WIGIG ////
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       res |= (0x1 << 2);
517a515
>   NS_LOG_FUNCTION (this << ba);
519,540c517,518
<   if (((ba >> 1) & 0x0f) == 0x03)
<     {
<       m_baType = MULTI_TID_BLOCK_ACK;
<     }
<   else if (((ba >> 1) & 0x0f) == 0x01)
<     {
<       m_baType = EXTENDED_COMPRESSED_BLOCK_ACK;
<     }
<   else if (((ba >> 1) & 0x0f) == 0x02)
<     {
<       m_baType = COMPRESSED_BLOCK_ACK;
<     }
<   //// WIGIG ////
<   else if (((ba >> 1) & 0x0f) == 0x08)
<     {
<       m_baType = EDMG_COMPRESSED_BLOCK_ACK;
<     }
<   //// WIGIG ////
<   else
<     {
<       m_baType = BASIC_BLOCK_ACK;
<     }
---
>   m_multiTid = (((ba >> 1) & 0x01) == 1) ? true : false;
>   m_compressed = (((ba >> 2) & 0x01) == 1) ? true : false;
546a525
>   NS_LOG_FUNCTION (this);
552a532
>   NS_LOG_FUNCTION (this << seqControl);
555,573d534
< //// WIGIG ////
< void
< CtrlBAckResponseHeader::SetCompresssedBlockAckSize (EDMG_COMPRESSED_BLOCK_ACK_BITMAP_SIZE size)
< {
<   m_edmgCompressedBlockAckSize = size;
< }
< 
< void
< CtrlBAckResponseHeader::SetReceiveBufferCapability (uint8_t capability)
< {
<   m_rbufcapValue = capability;
< }
< 
< uint8_t
< CtrlBAckResponseHeader::GetReceiveBufferCapability (void) const
< {
<   return m_rbufcapValue;
< }
< //// WIGIG ////
577a539
>   NS_LOG_FUNCTION (this << &start);
579c541
<   switch (m_baType)
---
>   if (!m_multiTid)
581,582c543,545
<       case BASIC_BLOCK_ACK:
<           for (uint8_t j = 0; j < 64; j++)
---
>       if (!m_compressed)
>         {
>           for (uint32_t j = 0; j < 64; j++)
586,587c549,551
<           break;
<       case COMPRESSED_BLOCK_ACK:
---
>         }
>       else
>         {
589,609c553,564
<           break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<           i.WriteHtolsbU64 (bitmap.m_extendedCompressedBitmap[0]);
<           i.WriteHtolsbU64 (bitmap.m_extendedCompressedBitmap[1]);
<           i.WriteHtolsbU64 (bitmap.m_extendedCompressedBitmap[2]);
<           i.WriteHtolsbU64 (bitmap.m_extendedCompressedBitmap[3]);
<           break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<           for (uint8_t j = 0; j < m_edmgCompressedBlockAckSize; j++)
<             {
<               i.WriteHtolsbU64 (bitmap.m_edmgCompressedBitmap[j]);
<             }
<           break;
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>         }
>     }
>   else
>     {
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
616a572
>   NS_LOG_FUNCTION (this << &start);
618c574
<   switch (m_baType)
---
>   if (!m_multiTid)
620,621c576,578
<       case BASIC_BLOCK_ACK:
<           for (uint8_t j = 0; j < 64; j++)
---
>       if (!m_compressed)
>         {
>           for (uint32_t j = 0; j < 64; j++)
625,626c582,584
<           break;
<       case COMPRESSED_BLOCK_ACK:
---
>         }
>       else
>         {
628,648c586,597
<           break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<           bitmap.m_extendedCompressedBitmap[0] = i.ReadLsbtohU64 ();
<           bitmap.m_extendedCompressedBitmap[1] = i.ReadLsbtohU64 ();
<           bitmap.m_extendedCompressedBitmap[2] = i.ReadLsbtohU64 ();
<           bitmap.m_extendedCompressedBitmap[3] = i.ReadLsbtohU64 ();
<           break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<           for (uint8_t j = 0; j < m_edmgCompressedBlockAckSize; j++)
<             {
<               bitmap.m_edmgCompressedBitmap[j] = i.ReadLsbtohU64 ();
<             }
<           break;
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>         }
>     }
>   else
>     {
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
655a605
>   NS_LOG_FUNCTION (this << seq);
660c610
<   switch (m_baType)
---
>   if (!m_multiTid)
662c612
<       case BASIC_BLOCK_ACK:
---
>       if (!m_compressed)
667d616
<           break;
669c618
<       case COMPRESSED_BLOCK_ACK:
---
>       else
672d620
<           break;
674,688c622,625
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         {
<           uint16_t index = IndexInBitmap (seq);
<           bitmap.m_extendedCompressedBitmap[index/64] |= (uint64_t (0x0000000000000001) << index);
<           break;
<         }
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         {
<           uint16_t index = IndexInBitmap (seq);
<           bitmap.m_edmgCompressedBitmap[index/64] |= (uint64_t (0x0000000000000001) << index);
<           break;
<         }
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
---
>     }
>   else
>     {
>       if (m_compressed)
691d627
<           break;
693c629
<       default:
---
>       else
695,696c631
<           NS_FATAL_ERROR ("Invalid BA type");
<           break;
---
>           NS_FATAL_ERROR ("Reserved configuration.");
703a639
>   NS_LOG_FUNCTION (this << seq << static_cast<uint32_t> (frag));
709c645,657
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       if (!m_compressed)
>         {
>           bitmap.m_bitmap[IndexInBitmap (seq)] |= (0x0001 << frag);
>         }
>       else
>         {
>           /* We can ignore this...compressed block ack doesn't support
>              acknowledgement of single fragments */
>         }
>     }
>   else
711,727c659,666
<       case BASIC_BLOCK_ACK:
<         bitmap.m_bitmap[IndexInBitmap (seq)] |= (0x0001 << frag);
<         break;
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<       //// WIGIG //// /* WIGIG: To check */
<       case EDMG_COMPRESSED_BLOCK_ACK:
<       //// WIGIG ////
<         /* We can ignore this...compressed block ack doesn't support
<            acknowledgment of single fragments */
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
733a673
>   NS_LOG_FUNCTION (this << seq);
738c678
<   switch (m_baType)
---
>   if (!m_multiTid)
740c680
<       case BASIC_BLOCK_ACK:
---
>       if (!m_compressed)
745c685
<       case COMPRESSED_BLOCK_ACK:
---
>       else
747,749d686
<           /* Although this could make no sense, if packet with sequence number
<              equal to <i>seq</i> was correctly received, also all of its fragments
<              were correctly received. */
753,767c690,693
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         {
<           uint64_t mask = uint64_t (0x0000000000000001);
<           uint16_t index = IndexInBitmap (seq);
<           return (((bitmap.m_extendedCompressedBitmap[index/64] >> index) & mask) == 1) ? true : false;
<         }
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         {
<           uint64_t mask = uint64_t (0x0000000000000001);
<           uint16_t index = IndexInBitmap (seq);
<           return (((bitmap.m_edmgCompressedBitmap[index/64] >> index) & mask) == 1) ? true : false;
<         }
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
---
>     }
>   else
>     {
>       if (m_compressed)
770d695
<           break;
772c697
<       default:
---
>       else
774,775c699
<           NS_FATAL_ERROR ("Invalid BA type");
<           break;
---
>           NS_FATAL_ERROR ("Reserved configuration.");
783a708
>   NS_LOG_FUNCTION (this << seq << static_cast<uint32_t> (frag));
789c714
<   switch (m_baType)
---
>   if (!m_multiTid)
791c716
<       case BASIC_BLOCK_ACK:
---
>       if (!m_compressed)
795c720
<       case COMPRESSED_BLOCK_ACK:
---
>       else
803,812c728,731
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         {
<           uint64_t mask = uint64_t (0x0000000000000001);
<           uint16_t index = IndexInBitmap (seq);
<           return (((bitmap.m_extendedCompressedBitmap[index/64] >> index) & mask) == 1) ? true : false;
<         }
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
---
>     }
>   else
>     {
>       if (m_compressed)
815d733
<           break;
817c735
<       default:
---
>       else
819,820c737
<           NS_FATAL_ERROR ("Invalid BA type");
<           break;
---
>           NS_FATAL_ERROR ("Reserved configuration.");
826c743
< uint16_t
---
> uint8_t
829c746,747
<   uint16_t index;
---
>   NS_LOG_FUNCTION (this << seq);
>   uint8_t index;
838,851c756
<   //// WIGIG ////
<   if (m_baType == EDMG_COMPRESSED_BLOCK_ACK)
<     {
<       NS_ASSERT (index <= 1023);
<     }
<   //// WIGIG ////
<   else if (m_baType == EXTENDED_COMPRESSED_BLOCK_ACK)
<     {
<       NS_ASSERT (index <= 255);
<     }
<   else
<     {
<       NS_ASSERT (index <= 63);
<     }
---
>   NS_ASSERT (index <= 63);
858,871c763,764
<   //// WIGIG ////
<   if (m_baType == EDMG_COMPRESSED_BLOCK_ACK)
<     {
<       return (seq - m_startingSeq + 4096) % 4096 < 1024;
<     }
<   //// WIGIG ////
<   else if (m_baType == EXTENDED_COMPRESSED_BLOCK_ACK)
<     {
<       return (seq - m_startingSeq + 4096) % 4096 < 256;
<     }
<   else
<     {
<       return (seq - m_startingSeq + 4096) % 4096 < 64;
<     }
---
>   NS_LOG_FUNCTION (this << seq);
>   return (seq - m_startingSeq + 4096) % 4096 < 64;
876a770
>   NS_LOG_FUNCTION (this);
882a777
>   NS_LOG_FUNCTION (this);
886,897d780
< const uint64_t*
< CtrlBAckResponseHeader::GetExtendedCompressedBitmap (void) const
< {
<   return bitmap.m_extendedCompressedBitmap;
< }
< 
< const uint64_t*
< CtrlBAckResponseHeader::GetEdmgCompressedBitmap (void) const
< {
<   return bitmap.m_edmgCompressedBitmap;
< }
< 
901,1964d783
<   memset (&bitmap, 0, sizeof (bitmap));
< }
< 
< /*************************
<  *  Poll Frame (8.3.1.11)
<  *************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDmgPoll);
< 
< CtrlDmgPoll::CtrlDmgPoll ()
<     : m_responseOffset (0)
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDmgPoll::~CtrlDmgPoll ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDmgPoll::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDmgPoll")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDmgPoll> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDmgPoll::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlDmgPoll::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   os << "Response Offset=" << m_responseOffset;
< }
< 
< uint32_t
< CtrlDmgPoll::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 2;  // Response Offset Field.
< }
< 
< void
< CtrlDmgPoll::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   i.WriteHtolsbU16 (m_responseOffset);
< }
< 
< uint32_t
< CtrlDmgPoll::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   m_responseOffset = i.ReadLsbtohU16 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< CtrlDmgPoll::SetResponseOffset (uint16_t value)
< {
<   NS_LOG_FUNCTION (this << value);
<   m_responseOffset = value;
< }
< 
< uint16_t
< CtrlDmgPoll::GetResponseOffset (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return m_responseOffset;
< }
< 
< /*************************************************
<  *  Service Period Request (SPR) Frame (8.3.1.12)
<  *************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_SPR);
< 
< CtrlDMG_SPR::CtrlDMG_SPR ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_SPR::~CtrlDMG_SPR ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_SPR::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_SPR")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDMG_SPR> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_SPR::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlDMG_SPR::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   m_dynamic.Print (os);
<   m_bfControl.Print (os);
< }
< 
< uint32_t
< CtrlDMG_SPR::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 7;  // Dynamic Allocation Info Field + BF Control.
< }
< 
< void
< CtrlDMG_SPR::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_dynamic.Serialize (i);
<   i = m_bfControl.Serialize (i);
< }
< 
< uint32_t
< CtrlDMG_SPR::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_dynamic.Deserialize (i);
<   i = m_bfControl.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< CtrlDMG_SPR::SetDynamicAllocationInfo (DynamicAllocationInfoField field)
< {
<   m_dynamic = field;
< }
< 
< void
< CtrlDMG_SPR::SetBFControl (BF_Control_Field value)
< {
<   m_bfControl = value;
< }
< 
< DynamicAllocationInfoField
< CtrlDMG_SPR::CtrlDMG_SPR::GetDynamicAllocationInfo (void) const
< {
<   return m_dynamic;
< }
< 
< BF_Control_Field
< CtrlDMG_SPR::GetBFControl (void) const
< {
<   return m_bfControl;
< }
< 
< /*************************
<  * Grant Frame (8.3.1.13)
<  *************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_Grant);
< 
< CtrlDMG_Grant::CtrlDMG_Grant ()
< {
<   NS_LOG_FUNCTION(this);
< }
< 
< CtrlDMG_Grant::~CtrlDMG_Grant ()
< {
<   NS_LOG_FUNCTION(this);
< }
< 
< TypeId
< CtrlDMG_Grant::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_Grant")
<       .SetParent<Header>()
<       .AddConstructor<CtrlDMG_Grant> ()
<       ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_Grant::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< /********************************************
<  * DMG Denial to Send (DTS) Frame (8.3.1.15)
<  ********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_DTS);
< 
< CtrlDMG_DTS::CtrlDMG_DTS ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_DTS::~CtrlDMG_DTS ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_DTS::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_DTS")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDMG_DTS> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_DTS::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlDMG_DTS::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< CtrlDMG_DTS::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 12;  // NAV-SA + NAV-DA
< }
< 
< void
< CtrlDMG_DTS::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   WriteTo (i, m_navSA);
<   WriteTo (i, m_navDA);
< }
< 
< uint32_t
< CtrlDMG_DTS::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   ReadFrom (i, m_navSA);
<   ReadFrom (i, m_navDA);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< /****************************************
<  *  Sector Sweep (SSW) Frame (8.3.1.16)
<  ****************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_SSW);
< 
< CtrlDMG_SSW::CtrlDMG_SSW ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_SSW::~CtrlDMG_SSW ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_SSW::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_SSW")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDMG_SSW> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_SSW::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void CtrlDMG_SSW::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   m_ssw.Print (os);
<   m_sswFeedback.Print (os);
< }
< 
< uint32_t
< CtrlDMG_SSW::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 6;  // SSW Field + SSW Feedback Field.
< }
< 
< void
< CtrlDMG_SSW::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_ssw.Serialize (i);
<   i = m_sswFeedback.Serialize (i);
< }
< 
< uint32_t
< CtrlDMG_SSW::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_ssw.Deserialize (i);
<   i = m_sswFeedback.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< CtrlDMG_SSW::SetSswField (DMG_SSW_Field &field)
< {
<   m_ssw = field;
< }
< 
< void
< CtrlDMG_SSW::SetSswFeedbackField (DMG_SSW_FBCK_Field &field)
< {
<   m_sswFeedback = field;
< }
< 
< DMG_SSW_Field
< CtrlDMG_SSW::GetSswField (void) const
< {
<   return m_ssw;
< }
< 
< DMG_SSW_FBCK_Field
< CtrlDMG_SSW::GetSswFeedbackField (void) const
< {
<   return m_sswFeedback;
< }
< 
< /*********************************************************
<  *  Sector Sweep Feedback (SSW-Feedback) Frame (8.3.1.17)
<  *********************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_SSW_FBCK);
< 
< CtrlDMG_SSW_FBCK::CtrlDMG_SSW_FBCK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_SSW_FBCK::~CtrlDMG_SSW_FBCK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_SSW_FBCK::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_SSW_FBCK")
<     .SetParent<Header>()
<     .AddConstructor<CtrlDMG_SSW_FBCK> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_SSW_FBCK::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlDMG_SSW_FBCK::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   m_sswFeedback.Print (os);
<   m_brpRequest.Print (os);
<   m_linkMaintenance.Print (os);
< }
< 
< uint32_t
< CtrlDMG_SSW_FBCK::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 8;  // SSW Feedback Field + BRP Request + Beamformed Link Maintenance.
< }
< 
< void
< CtrlDMG_SSW_FBCK::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_sswFeedback.Serialize (i);
<   i = m_brpRequest.Serialize (i);
<   i = m_linkMaintenance.Serialize (i);
< }
< 
< uint32_t
< CtrlDMG_SSW_FBCK::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION(this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_sswFeedback.Deserialize (i);
<   i = m_brpRequest.Deserialize (i);
<   i = m_linkMaintenance.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< CtrlDMG_SSW_FBCK::SetSswFeedbackField (DMG_SSW_FBCK_Field &field)
< {
<   m_sswFeedback = field;
< }
< 
< void
< CtrlDMG_SSW_FBCK::SetBrpRequestField (BRP_Request_Field &field)
< {
<   m_brpRequest = field;
< }
< 
< void
< CtrlDMG_SSW_FBCK::SetBfLinkMaintenanceField (BF_Link_Maintenance_Field &field)
< {
<   m_linkMaintenance = field;
< }
< 
< DMG_SSW_FBCK_Field
< CtrlDMG_SSW_FBCK::GetSswFeedbackField (void) const
< {
<   return m_sswFeedback;
< }
< 
< BRP_Request_Field
< CtrlDMG_SSW_FBCK::GetBrpRequestField (void) const
< {
<   return m_brpRequest;
< }
< 
< BF_Link_Maintenance_Field
< CtrlDMG_SSW_FBCK::GetBfLinkMaintenanceField (void) const
< {
<   return m_linkMaintenance;
< }
< 
< /**********************************************
<  * Sector Sweep ACK (SSW-ACK) Frame (8.3.1.18)
<  **********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_SSW_ACK);
< 
< CtrlDMG_SSW_ACK::CtrlDMG_SSW_ACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_SSW_ACK::~CtrlDMG_SSW_ACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_SSW_ACK::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_SSW_ACK")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDMG_SSW_ACK> ()
<   ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_SSW_ACK::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< /*******************************
<  *  Grant ACK Frame (8.3.1.19)
<  *******************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlGrantAck);
< 
< CtrlGrantAck::CtrlGrantAck ()
< {
<   NS_LOG_FUNCTION (this);
<   memset (m_reserved, 0, sizeof (uint8_t) * 5);
< }
< 
< CtrlGrantAck::~CtrlGrantAck ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlGrantAck::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlGrantAck")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlGrantAck> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlGrantAck::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlGrantAck::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   m_bfControl.Print (os);
< }
< 
< uint32_t
< CtrlGrantAck::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 7;  // Reserved + BF Control.
< }
< 
< void
< CtrlGrantAck::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i.Write (m_reserved, 5);
<   i = m_bfControl.Serialize (i);
< }
< 
< uint32_t
< CtrlGrantAck::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i.Read (m_reserved, 5);
<   i = m_bfControl.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< /***********************************************
<  *   TDD Beamforming frame format (9.3.1.24.1)
<  ***********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (TDD_Beamforming);
< 
< TDD_Beamforming::TDD_Beamforming ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TDD_Beamforming::~TDD_Beamforming ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< TDD_Beamforming::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::TDD_Beamforming")
<     .SetParent<Header> ()
<     .AddConstructor<TDD_Beamforming> ()
<     ;
<   return tid;
< }
< 
< TypeId
< TDD_Beamforming::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void TDD_Beamforming::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< TDD_Beamforming::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 1;
< }
< 
< void
< TDD_Beamforming::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   uint8_t controlField = 0;
<   controlField |= m_groupBeamforming & 0x1;
<   controlField |= (m_beamMeasurement & 0x1) << 1;
<   controlField |= (m_beamformingFrameType & 0x3) << 2;
<   controlField |= (m_endOfTraining & 0x1) << 4;
<   i.WriteU8 (controlField);
< }
< 
< uint32_t
< TDD_Beamforming::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   uint8_t controlField = i.ReadU8 ();
<   m_groupBeamforming = controlField & 0x1;
<   m_beamMeasurement = (controlField >> 1) & 0x1;
<   m_beamformingFrameType = static_cast<TDD_Beamforming_Frame_Type> ((controlField << 2) & 0x3);
<   m_endOfTraining = (controlField >> 4) & 0x1;
<   return i.GetDistanceFrom (start);
< }
< 
< void
< TDD_Beamforming::SetGroup_Beamforming (bool value)
< {
<   m_groupBeamforming = value;
< }
< 
< void
< TDD_Beamforming::SetBeam_Measurement (bool value)
< {
<   m_beamMeasurement = value;
< }
< 
< void
< TDD_Beamforming::SetBeamformingFrameType (TDD_Beamforming_Frame_Type type)
< {
<   m_beamformingFrameType = type;
< }
< 
< void
< TDD_Beamforming::SetEndOfTraining (bool value)
< {
<   m_endOfTraining = value;
< }
< 
< bool
< TDD_Beamforming::GetGroup_Beamforming (void) const
< {
<   return m_groupBeamforming;
< }
< 
< bool
< TDD_Beamforming::GetBeam_Measurement (void) const
< {
<   return m_beamMeasurement;
< }
< 
< TDD_Beamforming_Frame_Type
< TDD_Beamforming::GetBeamformingFrameType (void) const
< {
<   return m_beamformingFrameType;
< }
< 
< bool
< TDD_Beamforming::GetEndOfTraining (void) const
< {
<   return m_endOfTraining;
< }
< 
< TDD_BEAMFORMING_PROCEDURE
< TDD_Beamforming::GetBeamformingProcedure (Mac48Address receiver) const
< {
<   return TDD_BEAMFORMING_INDIVIDUAL;
< }
< 
< /*********************************************
<  * TDD Sector Sweep (SSW) format (9.3.1.24.2)
<  *********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (TDD_Beamforming_SSW);
< 
< TDD_Beamforming_SSW::TDD_Beamforming_SSW ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TDD_Beamforming_SSW::~TDD_Beamforming_SSW ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< TDD_Beamforming_SSW::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::TDD_Beamforming_SSW")
<     .SetParent<TDD_Beamforming> ()
<     .AddConstructor<TDD_Beamforming_SSW> ()
<     ;
<   return tid;
< }
< 
< TypeId
< TDD_Beamforming_SSW::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void TDD_Beamforming_SSW::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< TDD_Beamforming_SSW::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 6;
< }
< 
< void
< TDD_Beamforming_SSW::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
< //  Buffer::Iterator i = start;
< }
< 
< uint32_t
< TDD_Beamforming_SSW::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   return i.GetDistanceFrom (start);
< }
< 
< void
< TDD_Beamforming_SSW::SetTxSectorID (uint16_t sectorID)
< {
<   m_sectorID = sectorID;
< }
< 
< void
< TDD_Beamforming_SSW::SetTxAntennaID (uint8_t antennaID)
< {
<   m_antennaID = antennaID;
< }
< 
< void
< TDD_Beamforming_SSW::SetCountIndex (uint8_t index)
< {
<   m_countIndex = index;
< }
< 
< void
< TDD_Beamforming_SSW::SetBeamformingTimeUnit (uint8_t unit)
< {
<   m_beamformingTimeUnit = unit;
< }
< 
< void
< TDD_Beamforming_SSW::SetTransmitPeriod (uint8_t period)
< {
<   m_transmitPeriod = period;
< }
< 
< void
< TDD_Beamforming_SSW::SetResponderFeedbackOffset (uint16_t offset)
< {
<   m_responderFeedbackOffset = offset;
< }
< 
< void
< TDD_Beamforming_SSW::SetInitiatorAckOffset (uint16_t offset)
< {
<   m_initiatorAckOffset = offset;
< }
< 
< void
< TDD_Beamforming_SSW::SetNumberOfRequestedFeedback (uint8_t feedback)
< {
<   m_numRequestedFeedback = feedback;
< }
< 
< 
< void
< TDD_Beamforming_SSW::SetTDDSlotCDOWN (uint16_t cdown)
< {
<   m_tddSlotCDOWN = cdown;
< }
< 
< void
< TDD_Beamforming_SSW::SetFeedbackRequested (bool feedback)
< {
<   m_feedbackRequested = feedback;
< }
< 
< uint16_t
< TDD_Beamforming_SSW::GetTxSectorID (void) const
< {
<   return m_sectorID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetTxAntennaID (void) const
< {
<   return m_antennaID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetCountIndex (void) const
< {
<   return m_countIndex;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetBeamformingTimeUnit (void) const
< {
<   return m_beamformingTimeUnit;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetTransmitPeriod (void) const
< {
<   return m_transmitPeriod;
< }
< 
< uint16_t
< TDD_Beamforming_SSW::GetResponderFeedbackOffset (void) const
< {
<   return m_responderFeedbackOffset;
< }
< 
< uint16_t
< TDD_Beamforming_SSW::GetInitiatorAckOffset (void) const
< {
<   return m_initiatorAckOffset;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetNumberOfRequestedFeedback (void) const
< {
<   return m_numRequestedFeedback;
< }
< 
< uint16_t
< TDD_Beamforming_SSW::GetTDDSlotCDOWN (void) const
< {
<   return m_tddSlotCDOWN;
< }
< 
< bool
< TDD_Beamforming_SSW::GetFeedbackRequested (void) const
< {
<   return m_feedbackRequested;
< }
< 
< /*********************************************
<  *     TDD SSW Feedback format (9.3.1.24.3)
<  *********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (TDD_Beamforming_SSW_FEEDBACK);
< 
< TDD_Beamforming_SSW_FEEDBACK::TDD_Beamforming_SSW_FEEDBACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TDD_Beamforming_SSW_FEEDBACK::~TDD_Beamforming_SSW_FEEDBACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< TDD_Beamforming_SSW_FEEDBACK::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::TDD_Beamforming_SSW_FEEDBACK")
<     .SetParent<TDD_Beamforming> ()
<     .AddConstructor<TDD_Beamforming_SSW_FEEDBACK> ()
<     ;
<   return tid;
< }
< 
< TypeId
< TDD_Beamforming_SSW_FEEDBACK::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void TDD_Beamforming_SSW_FEEDBACK::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< TDD_Beamforming_SSW_FEEDBACK::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return TDD_Beamforming::GetSerializedSize () + 6;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   TDD_Beamforming::Serialize (i);
<   uint32_t value1 = 0;
<   uint16_t value2 = 0;
<   value1 |= (m_sectorID & 0x1FF);
<   value1 |= (m_antennaID & 0x7) << 9;
<   value1 |= (m_decodedSectorID & 0x1FF) << 12;
<   value1 |= (m_decodedAntennaID & 0x7) << 21;
<   value1 |= (m_snrReport & 0xFF) << 24;
<   value2 |= (m_feedbackCountIndex & 0x33);
<   i.WriteHtolsbU32 (value1);
<   i.WriteHtolsbU16 (value2);
< }
< 
< uint32_t
< TDD_Beamforming_SSW_FEEDBACK::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< //  i += TDD_Beamforming::Deserialize (i);
<   uint32_t value1 = i.ReadLsbtohU32 ();
<   uint16_t value2 = i.ReadLsbtohU16 ();
<   m_sectorID = (value1 & 0x1FF);
<   m_antennaID = (value1 >> 9) & 0x7;
<   m_decodedSectorID = (value1 >> 12) & 0x1FF;
<   m_decodedAntennaID = (value1 >> 21) & 0x7;
<   m_snrReport = (value1 >> 24) & 0xFF;
<   m_feedbackCountIndex = (value2 & 0x33);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetTxSectorID (uint16_t sectorID)
< {
<   m_sectorID = sectorID;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetTxAntennaID (uint8_t antennaID)
< {
<   m_antennaID = antennaID;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetDecodedTxSectorID (uint16_t sectorID)
< {
<   m_decodedSectorID = sectorID;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetDecodedTxAntennaID (uint8_t antennaID)
< {
<   m_decodedAntennaID = antennaID;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetSnrReport (uint8_t snr)
< {
<   m_snrReport = snr;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetFeedbackCountIndex (uint8_t index)
< {
<   m_feedbackCountIndex = index;
< }
< 
< uint16_t
< TDD_Beamforming_SSW_FEEDBACK::GetTxSectorID (void) const
< {
<   return m_sectorID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_FEEDBACK::GetTxAntennaID (void) const
< {
<   return m_antennaID;
< }
< 
< uint16_t
< TDD_Beamforming_SSW_FEEDBACK::GetDecodedTxSectorID (void) const
< {
<   return m_decodedSectorID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_FEEDBACK::GetDecodedTxAntennaID (void) const
< {
<   return m_decodedAntennaID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_FEEDBACK::GetSnrReport (void) const
< {
<   return m_snrReport;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_FEEDBACK::GetFeedbackCountIndex (void) const
< {
<   return m_feedbackCountIndex;
< }
< 
< /*********************************************
<  *      TDD SSW ACK format (9.3.1.24.3)
<  *********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (TDD_Beamforming_SSW_ACK);
< 
< TDD_Beamforming_SSW_ACK::TDD_Beamforming_SSW_ACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TDD_Beamforming_SSW_ACK::~TDD_Beamforming_SSW_ACK ()
< {
1965a785
>   memset (&bitmap, 0, sizeof (bitmap));
1968,2118c788
< TypeId
< TDD_Beamforming_SSW_ACK::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::TDD_Beamforming_SSW_ACK")
<     .SetParent<TDD_Beamforming> ()
<     .AddConstructor<TDD_Beamforming_SSW_ACK> ()
<   ;
<   return tid;
< }
< 
< TypeId
< TDD_Beamforming_SSW_ACK::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void TDD_Beamforming_SSW_ACK::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< TDD_Beamforming_SSW_ACK::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 6;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
< //  Buffer::Iterator i = start;
<   if (m_beamformingFrameType == TDD_SSW)
<     {
< 
<     }
<   else if (m_beamformingFrameType == TDD_SSW_Feedback)
<     {
< 
<     }
< }
< 
< uint32_t
< TDD_Beamforming_SSW_ACK::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetDecodedTxSectorID (uint16_t sectorID)
< {
<   m_sectorID = sectorID;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetDecodedTxAntennaID (uint8_t antennaID)
< {
<   m_antennaID = antennaID;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetCountIndex (uint8_t index)
< {
<   m_countIndex = index;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetTransmitPeriod (uint8_t period)
< {
<   m_transmitPeriod = period;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetSnrReport (uint8_t snr)
< {
<   m_snrReport = snr;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetInitiatorTransmitOffset (uint16_t offset)
< {
<   m_InitiatorTransmitOffset = offset;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetResponderTransmitOffset (uint8_t offset)
< {
<   m_responderTransmitOffset = offset;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetAckCountIndex (uint8_t count)
< {
<   m_ackCountIndex = count;
< }
< 
< uint16_t
< TDD_Beamforming_SSW_ACK::GetDecodedTxSectorID (void) const
< {
<   return m_sectorID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetDecodedTxAntennaID (void) const
< {
<   return m_antennaID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetCountIndex (void) const
< {
<   return m_countIndex;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetTransmitPeriod (void) const
< {
<   return m_transmitPeriod;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetSnrReport (void) const
< {
<   return m_snrReport;
< }
< 
< uint16_t
< TDD_Beamforming_SSW_ACK::GetInitiatorTransmitOffGet (void) const
< {
<   return m_InitiatorTransmitOffset;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetResponderTransmitOffGet (void) const
< {
<   return m_responderTransmitOffset;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetAckCountIndex (void) const
< {
<   return m_ackCountIndex;
< }
< 
< }  // namespace ns3
---
> }  //namespace ns3
diff ../../NS3-WiGig/src/wifi/model/ctrl-headers.h ../../ns-3-dev/src/wifi/model/ctrl-headers.h
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
19,20c18
<  * Authors: Mirko Banchi <mk.banchi@gmail.com>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mirko Banchi <mk.banchi@gmail.com>
27,28d24
< #include "block-ack-type.h"
< #include "fields-headers.h"
32a29,38
>  * Enumeration for different block ACK policies.
>  */
> enum BlockAckType
> {
>   BASIC_BLOCK_ACK,
>   COMPRESSED_BLOCK_ACK,
>   MULTI_TID_BLOCK_ACK
> };
> 
> /**
34c40
<  * \brief Headers for BlockAckRequest.
---
>  * \brief Headers for Block ack request.
36,40c42,46
<  *  802.11n standard includes three types of BlockAck:
<  *    - Basic BlockAck (unique type in 802.11e)
<  *    - Compressed BlockAck
<  *    - Multi-TID BlockAck
<  *  For now only basic BlockAck and compressed BlockAck
---
>  *  802.11n standard includes three types of block ack:
>  *    - Basic block ack (unique type in 802.11e)
>  *    - Compressed block ack
>  *    - Multi-TID block ack
>  *  For now only basic block ack and compressed block ack
42c48
<  *  Basic BlockAck is also default variant.
---
>  *  Basic block ack is also default variant.
49,52d54
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
54,58c56,60
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
61c63
<    * Enable or disable HT immediate Ack.
---
>    * Enable or disable HT immediate ACK.
63c65
<    * \param immediateAck enable or disable HT immediate Ack
---
>    * \param immediateAck enable or disable HT immediate ACK
67c69
<    * Set the block ack type.
---
>    * Set the block ACK type.
69c71
<    * \param type the BA type
---
>    * \param type
71c73
<   void SetType (BlockAckType type);
---
>   void SetType (enum BlockAckType type);
75c77
<    * \param tid the TID
---
>    * \param tid
87c89
<    * Check if the current Ack Policy is immediate.
---
>    * Check if the current ACK policy is immediate.
89c91
<    * \return true if the current Ack Policy is immediate,
---
>    * \return true if the current ACK policy is immediate,
94,99d95
<    * Return the Block Ack type ID.
<    *
<    * \return the BA type
<    */
<   BlockAckType GetType (void) const;
<   /**
112,113c108,109
<    * Check if the current Ack Policy is Basic Block Ack
<    * (i.e. not multi-TID nor compressed).
---
>    * Check if the current ACK policy is basic
>    * (i.e. not multiple TID and not compressed ACK).
115c111
<    * \return true if the current Ack Policy is Basic Block Ack,
---
>    * \return true if the current ACK policy is basic,
120,121c116,117
<    * Check if the current Ack Policy is Compressed Block Ack
<    * and not multi-TID.
---
>    * Check if the current ACK policy is compressed ACK
>    * and not multiple TID.
123c119
<    * \return true if the current Ack Policy is Compressed Block Ack,
---
>    * \return true if the current ACK policy is compressed ACK,
128c124
<    * Check if the current Ack Policy is Extended Compressed Block Ack.
---
>    * Check if the current ACK policy has multiple TID.
130,137c126
<    * \return true if the current Ack Policy is Extended Compressed Block Ack,
<    *         false otherwise
<    */
<   bool IsExtendedCompressed (void) const;
<   /**
<    * Check if the current Ack Policy has Multi-TID Block Ack.
<    *
<    * \return true if the current Ack Policy has Multi-TID Block Ack,
---
>    * \return true if the current ACK policy has multiple TID,
155c144
<    * \param seqControl the sequence control value
---
>    * \param seqControl
159c148
<    * Return the Block Ack control.
---
>    * Return the Block ACK control.
161c150
<    * \return the Block Ack control
---
>    * \return the Block ACK control
165c154
<    * Set the Block Ack control.
---
>    * Set the Block ACK control.
167c156
<    * \param bar the BAR control value
---
>    * \param bar
172c161
<    * The LSB bit of the BAR control field is used only for the
---
>    * The lsb bit of the BAR control field is used only for the
174c163
<    * For now only non HT immediate BlockAck is implemented so this field
---
>    * For now only non HT immediate block ack is implemented so this field
177,180c166,170
<   bool m_barAckPolicy;    ///< BAR Ack Policy
<   BlockAckType m_baType;  ///< BA type
<   uint16_t m_tidInfo;     ///< TID info
<   uint16_t m_startingSeq; ///< starting sequence number
---
>   bool m_barAckPolicy;
>   bool m_multiTid;
>   bool m_compressed;
>   uint16_t m_tidInfo;
>   uint16_t m_startingSeq;
183,189d172
< enum EDMG_COMPRESSED_BLOCK_ACK_BITMAP_SIZE {
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_64   = 1,
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_128  = 2,
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_256  = 4,
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_512  = 8,
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_1024 = 16,
< };
193c176
<  * \brief Headers for BlockAck response.
---
>  * \brief Headers for Block ack response.
195,199c178,182
<  *  802.11n standard includes three types of BlockAck:
<  *    - Basic BlockAck (unique type in 802.11e)
<  *    - Compressed BlockAck
<  *    - Multi-TID BlockAck
<  *  For now only basic BlockAck and compressed BlockAck
---
>  *  802.11n standard includes three types of block ack:
>  *    - Basic block ack (unique type in 802.11e)
>  *    - Compressed block ack
>  *    - Multi-TID block ack
>  *  For now only basic block ack and compressed block ack
201c184
<  *  Basic BlockAck is also default variant.
---
>  *  Basic block ack is also default variant.
208,211d190
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
213,217c192,196
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
220c199
<    * Enable or disable HT immediate Ack.
---
>    * Enable or disable HT immediate ACK.
222c201
<    * \param immediateAck enable or disable HT immediate Ack
---
>    * \param immediateAck enable or disable HT immediate ACK
226c205
<    * Set the block ack type.
---
>    * Set the block ACK type.
228c207
<    * \param type the BA type
---
>    * \param type
230c209
<   void SetType (BlockAckType type);
---
>   void SetType (enum BlockAckType type);
234c213
<    * \param tid the TID
---
>    * \param tid
246c225
<    * Check if the current Ack Policy is immediate.
---
>    * Check if the current ACK policy is immediate.
248c227
<    * \return true if the current Ack Policy is immediate,
---
>    * \return true if the current ACK policy is immediate,
253,258d231
<    * Return the block ack type ID.
<    *
<    * \return type
<    */
<   BlockAckType GetType (void) const;
<   /**
271c244,245
<    * Check if the current BA policy is Basic Block Ack.
---
>    * Check if the current ACK policy is basic
>    * (i.e. not multiple TID and not compressed ACK).
273c247
<    * \return true if the current BA policy is Basic Block Ack,
---
>    * \return true if the current ACK policy is basic,
278c252,253
<    * Check if the current BA policy is Compressed Block Ack.
---
>    * Check if the current ACK policy is compressed ACK
>    * and not multiple TID.
280c255
<    * \return true if the current BA policy is Compressed Block Ack,
---
>    * \return true if the current ACK policy is compressed ACK,
285,292c260
<    * Check if the current BA policy is Extended Compressed Block Ack.
<    *
<    * \return true if the current BA policy is Extended Compressed Block Ack,
<    *         false otherwise
<    */
<   bool IsExtendedCompressed (void) const;
<   /**
<    * Check if the current BA policy is Multi-TID Block Ack.
---
>    * Check if the current ACK policy has multiple TID.
294c262
<    * \return true if the current BA policy is Multi-TID Block Ack,
---
>    * \return true if the current ACK policy has multiple TID,
298,304d265
<   /**
<    * Check if the current BA policy is EDMG compressed block ACK.
<    *
<    * \return true if the current BA policy is EDMG compressed block ACK,
<    *         false otherwise
<    */
<   bool IsEdmgCompressed (void) const;
310c271
<    * \param seq the sequence number
---
>    * \param seq
317,318c278,279
<    * \param seq the sequence number
<    * \param frag the fragment number
---
>    * \param seq
>    * \param frag
323c284
<    * was acknowledged in this BlockAck response.
---
>    * was ACKed in this Block ACK response.
325c286
<    * \param seq the sequence number
---
>    * \param seq
327c288
<    *         was ACKed in this BlockAck response, false otherwise
---
>    *         was ACKed in this Block ACK response, false otherwise
332c293
<    * and fragment number was acknowledged in this BlockAck response.
---
>    * and fragment number was ACKed in this Block ACK response.
334,335c295,296
<    * \param seq the sequence number
<    * \param frag the fragment number
---
>    * \param seq
>    * \param frag
337c298
<    *         and sequence number was acknowledged in this BlockAck response,
---
>    *         and sequence number was ACKed in this Block ACK response,
352c313
<    * \param seqControl the raw sequence control value
---
>    * \param seqControl
356,374c317
<    * Return the bitmap from the BlockAck response header.
<    *
<    * \param size
<    */
<   void SetCompresssedBlockAckSize (EDMG_COMPRESSED_BLOCK_ACK_BITMAP_SIZE size);
<   /**
<    * Set receive buffer capability.
<    *
<    * \param capability
<    */
<   void SetReceiveBufferCapability (uint8_t capability);
<   /**
<    * Get receive buffer capability.
<    *
<    * \return capability
<    */
<   uint8_t GetReceiveBufferCapability (void) const;
<   /**
<    * Return the bitmap from the BlockAck response header.
---
>    * Return the bitmap from the block ACK response header.
376c319
<    * \return the bitmap from the BlockAck response header
---
>    * \return the bitmap from the block ACK response header
380c323
<    * Return the compressed bitmap from the BlockAck response header.
---
>    * Return the compressed bitmap from the block ACK response header.
382c325
<    * \return the compressed bitmap from the BlockAck response header
---
>    * \return the compressed bitmap from the block ACK response header
385,396d327
<   /**
<    * Return the extended compressed bitmap from the BlockAck response header.
<    *
<    * \return the extended compressed bitmap from the BlockAck response header
<    */
<   const uint64_t* GetExtendedCompressedBitmap (void) const;
<   /**
<    * Return the EDMG compressed bitmap from the block ACK response header.
<    *
<    * \return the EDMG compressed bitmap from the block ACK response header
<    */
<   const uint64_t* GetEdmgCompressedBitmap (void) const;
406c337
<    * Return the Block Ack control.
---
>    * Return the block ACK control.
408c339
<    * \return the Block Ack control
---
>    * \return the block ACK control
412c343
<    * Set the Block Ack control.
---
>    * Set the block ACK control.
414c345
<    * \param ba the BA control to set
---
>    * \param bar
416c347
<   void SetBaControl (uint16_t ba);
---
>   void SetBaControl (uint16_t bar);
421c352
<    * \param start the iterator
---
>    * \param start
428c359
<    * \param start the iterator
---
>    * \param start
447c378
<   uint16_t IndexInBitmap (uint16_t seq) const;
---
>   uint8_t IndexInBitmap (uint16_t seq) const;
454c385
<    * \return true if the sequence number is concerned by the bitmap
---
>    * \return
459c390
<    * The LSB bit of the BA control field is used only for the
---
>    * The lsb bit of the BA control field is used only for the
464,467c395,399
<   bool m_baAckPolicy;     ///< BA Ack Policy
<   BlockAckType m_baType;  ///< BA type
<   uint16_t m_tidInfo;     ///< TID info
<   uint16_t m_startingSeq; ///< starting sequence number
---
>   bool m_baAckPolicy;
>   bool m_multiTid;
>   bool m_compressed;
>   uint16_t m_tidInfo;
>   uint16_t m_startingSeq;
471,1067c403,405
<     uint16_t m_bitmap[64]; ///< the basic BlockAck bitmap
<     uint64_t m_compressedBitmap; ///< the compressed BlockAck bitmap
<     uint64_t m_extendedCompressedBitmap[4]; ///< the extended compressed BlockAck bitmap
<     //// WIGIG ////
<     uint64_t m_edmgCompressedBitmap[16]; ///< the EDMG compressed block ack bitmap
<     //// WIGIG ////
<   } bitmap; ///< bitmap union type
< 
<   //// WIGIG ////
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_SIZE m_edmgCompressedBlockAckSize;
<   uint8_t m_rbufcapValue; ///< Receive buffer capacity.
<   //// WIGIG ////
< };
< 
< 
< /*************************
<  *  Poll Frame (8.3.1.11)
<  *************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Poll Frame.
<  */
< class CtrlDmgPoll : public Header
< {
< public:
<   CtrlDmgPoll ();
<   ~CtrlDmgPoll ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the offset in units of 1 microseconds.
<    *
<    * \param value The offset in units of 1 microseconds.
<    */
<    void SetResponseOffset (uint16_t value);
< 
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   uint16_t GetResponseOffset (void) const;
< 
< private:
<   uint16_t m_responseOffset;
< 
< };
< 
< /***********************************************
<  * Service Period Request (SPR) Frame (8.3.1.12)
<  ***********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Service Period Request (SPR) Frame.
<  */
< class CtrlDMG_SPR : public Header
< {
< public:
<   CtrlDMG_SPR ();
<   ~CtrlDMG_SPR ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the Dynamic Allocation Information Field.
<    *
<    * \param value The Dynamic Allocation Information Field.
<    */
<   void SetDynamicAllocationInfo (DynamicAllocationInfoField field);
<   /**
<    * Set the offset in units of 1 microseconds.
<    *
<    * \param value The offset in units of 1 microseconds.
<    */
<   void SetBFControl (BF_Control_Field value);
< 
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   DynamicAllocationInfoField GetDynamicAllocationInfo (void) const;
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   BF_Control_Field GetBFControl (void) const;
< 
< private:
<   DynamicAllocationInfoField m_dynamic;
<   BF_Control_Field m_bfControl;
< 
< };
< 
< /*************************
<  * Grant Frame (8.3.1.13)
<  *************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Grant Frame.
<  */
< class CtrlDMG_Grant : public CtrlDMG_SPR
< {
< public:
<   CtrlDMG_Grant ();
<   ~CtrlDMG_Grant ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
< 
< };
< 
< /********************************************
<  * DMG Denial to Send (DTS) Frame (8.3.1.15)
<  ********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Denial to Send (DTS) Frame.
<  */
< class CtrlDMG_DTS: public Header
< {
< public:
<   CtrlDMG_DTS ();
<   ~CtrlDMG_DTS ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the Dynamic Allocation Information Field.
<    *
<    * \param value The Dynamic Allocation Information Field.
<    */
<   void SetNAV_SA (Mac48Address value);
<   /**
<    * Set the offset in units of 1 microseconds.
<    *
<    * \param value The offset in units of 1 microseconds.
<    */
<   void SetNAV_DA (Mac48Address value);
< 
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   Mac48Address GetNAV_SA (void) const;
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   Mac48Address GetNAV_DA (void) const;
< 
< private:
<     Mac48Address m_navSA;
<     Mac48Address m_navDA;
< 
< };
< 
< /****************************************
<  *  Sector Sweep (SSW) Frame (8.3.1.16)
<  ****************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Sector Sweep (SSW) Frame.
<  */
< class CtrlDMG_SSW : public Header
< {
< public:
<   CtrlDMG_SSW ();
<   ~CtrlDMG_SSW ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetSswField (DMG_SSW_Field &field);
<   void SetSswFeedbackField (DMG_SSW_FBCK_Field &field);
<   DMG_SSW_Field GetSswField (void) const;
<   DMG_SSW_FBCK_Field GetSswFeedbackField (void) const;
< 
< private:
<   DMG_SSW_Field m_ssw;
<   DMG_SSW_FBCK_Field m_sswFeedback;
< 
< };
< 
< /*********************************************************
<  *  Sector Sweep Feedback (SSW-Feedback) Frame (8.3.1.17)
<  *********************************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Sector Sweep Feedback (SSW-Feedback) Frame.
<  */
< class CtrlDMG_SSW_FBCK : public Header
< {
< public:
<   CtrlDMG_SSW_FBCK ();
<   virtual ~CtrlDMG_SSW_FBCK ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetSswFeedbackField (DMG_SSW_FBCK_Field &field);
<   void SetBrpRequestField (BRP_Request_Field &field);
<   void SetBfLinkMaintenanceField (BF_Link_Maintenance_Field &field);
< 
<   DMG_SSW_FBCK_Field GetSswFeedbackField (void) const;
<   BRP_Request_Field GetBrpRequestField (void) const;
<   BF_Link_Maintenance_Field GetBfLinkMaintenanceField (void) const;
< 
< private:
<   DMG_SSW_FBCK_Field m_sswFeedback;
<   BRP_Request_Field m_brpRequest;
<   BF_Link_Maintenance_Field m_linkMaintenance;
< 
< };
< 
< /**********************************************
<  * Sector Sweep ACK (SSW-ACK) Frame (8.3.1.18)
<  **********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Sector Sweep ACK (SSW-ACK) Frame.
<  */
< class CtrlDMG_SSW_ACK : public CtrlDMG_SSW_FBCK
< {
< public:
<   CtrlDMG_SSW_ACK (void);
<   virtual ~CtrlDMG_SSW_ACK (void);
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
< 
< };
< 
< /******************************
<  *  Grant ACK Frame (8.3.1.19)
<  ******************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Grant ACK Frame.
<  * The Grant ACK frame is sent only in CBAPs as a response to the reception of a Grant frame
<  * that has the Beamforming Training field equal to 1.
<  */
< class CtrlGrantAck : public Header
< {
< public:
<   CtrlGrantAck ();
<   ~CtrlGrantAck ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
< private:
<   uint8_t m_reserved[5];
<   BF_Control_Field m_bfControl;
< 
< };
< 
< /*********************************************
<  *  TDD Beamforming frame format (9.3.1.24.1)
<  *********************************************/
< 
< enum TDD_Beamforming_Frame_Type {
<   TDD_SSW = 0,
<   TDD_SSW_Feedback = 1,
<   TDD_SSW_ACK = 2,
< };
< 
< enum TDD_BEAMFORMING_PROCEDURE {
<   TDD_BEAMFORMING_INDIVIDUAL = 0,
<   TDD_BEAMFORMING_GROUP = 1,
<   TDD_BEAMFORMING_MEASUREMENT = 2,
< };
< 
< /**
<  * \ingroup wifi
<  * \brief Header for TDD Beamforming Frame.
<  */
< class TDD_Beamforming : public Header
< {
< public:
<   TDD_Beamforming ();
<   ~TDD_Beamforming ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /** TDD Beamforming Control field **/
<   void SetGroup_Beamforming (bool value);
<   void SetBeam_Measurement (bool value);
<   void SetBeamformingFrameType (TDD_Beamforming_Frame_Type type);
<   /**
<    * The End of Training subfield is set as follows:
<    *  A. The End of Training subfield is set to 1 in a TDD SSW frame to indicate that the initiator intends to
<    *  end the TDD individual beamforming training or the TDD beam measurement after the transmission
<    *  of the remaining TDD SSW frames with the current Sector ID; this subfield is set to 0 otherwise.
<    *  B. The End of Training subfield is set to 1 in a TDD SSW Feedback frame sent as part of a TDD
<    *  individual beamforming training if the TDD SSW Feedback frame is sent in response to a TDD SSW
<    *  frame in which its End of Training subfield was set to 1; this subfield is set to 0 otherwise.
<    *  C. The End of Training subfield is set to 1 in a TDD SSW Ack frame to indicate that the TDD individual
<    *  beamforming training has completed; otherwise, this subfield is set to 0.
<    * For TDD group BF, the End of Training subfield is reserved.
<    * \param value
<    */
<   void SetEndOfTraining (bool value);
< 
<   bool GetGroup_Beamforming (void) const;
<   bool GetBeam_Measurement (void) const;
<   TDD_Beamforming_Frame_Type GetBeamformingFrameType (void) const;
<   bool GetEndOfTraining (void) const;
< 
<   TDD_BEAMFORMING_PROCEDURE GetBeamformingProcedure (Mac48Address receiver) const;
< 
< protected:
<   bool m_groupBeamforming;
<   bool m_beamMeasurement;
<   TDD_Beamforming_Frame_Type m_beamformingFrameType;
<   bool m_endOfTraining;
< 
< };
< 
< /*********************************************
<  * TDD Sector Sweep (SSW) format (9.3.1.24.2)
<  *********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for TDD Beamforming Frame of a TDD SSW frame.
<  */
< class TDD_Beamforming_SSW : public TDD_Beamforming
< {
< public:
<   TDD_Beamforming_SSW ();
<   ~TDD_Beamforming_SSW ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /* TDD Beamforming Information field format (TDD individual BF) */
<   void SetTxSectorID (uint16_t sectorID);
<   void SetTxAntennaID (uint8_t antennaID);
<   void SetCountIndex (uint8_t index);
<   void SetBeamformingTimeUnit (uint8_t unit);
<   void SetTransmitPeriod (uint8_t period);
<   void SetResponderFeedbackOffset (uint16_t offset);
<   void SetInitiatorAckOffset (uint16_t offset);
<   void SetNumberOfRequestedFeedback (uint8_t feedback);
< 
<   uint16_t GetTxSectorID (void) const;
<   uint8_t GetTxAntennaID (void) const;
<   uint8_t GetCountIndex (void) const;
<   uint8_t GetBeamformingTimeUnit (void) const;
<   uint8_t GetTransmitPeriod (void) const;
<   uint16_t GetResponderFeedbackOffset (void) const;
<   uint16_t GetInitiatorAckOffset (void) const;
<   uint8_t GetNumberOfRequestedFeedback (void) const;
< 
<   /* TDD Beamforming Information field format (TDD beam measurement) */
<   void SetTDDSlotCDOWN (uint16_t cdown);
<   void SetFeedbackRequested (bool feedback);
< 
<   uint16_t GetTDDSlotCDOWN (void) const;
<   bool GetFeedbackRequested (void) const;
< 
< private:
<   /* TDD Beamforming Information field format (TDD individual BF) */
<   uint16_t m_sectorID;
<   uint8_t m_antennaID;
<   uint8_t m_countIndex;
<   uint8_t m_beamformingTimeUnit;
<   uint8_t m_transmitPeriod;
<   uint16_t m_responderFeedbackOffset;
<   uint16_t m_initiatorAckOffset;
<   uint8_t m_numRequestedFeedback;
< 
<   /* TDD Beamforming Information field format (TDD beam measurement) */
<   uint16_t m_tddSlotCDOWN;
<   bool m_feedbackRequested;
< 
< };
< 
< /*********************************************
<  *     TDD SSW Feedback format (9.3.1.24.3)
<  *********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for TDD Beamforming Frame.
<  */
< class TDD_Beamforming_SSW_FEEDBACK : public TDD_Beamforming
< {
< public:
<   TDD_Beamforming_SSW_FEEDBACK ();
<   ~TDD_Beamforming_SSW_FEEDBACK ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The TX Sector ID subfield is set to indicate the sector through which the TDD SSW Feedback frame is transmitted.
<    * \param sectorID
<    */
<   void SetTxSectorID (uint16_t sectorID);
<   /**
<    * The TX Antenna ID subfield indicates the DMG antenna ID through which the TDD SSW Feedback frame is transmitted.
<    * \param antennaID
<    */
<   void SetTxAntennaID (uint8_t antennaID);
<   /**
<    * The Decoded TX Sector ID subfield contains the value of the TX Sector ID subfield from the TDD SSW
<    * frame that the feedback frame is sent in response to and that the TDD SSW frame was received from the
<    * initiator with the best quality.
<    * \param sectorID
<    */
<   void SetDecodedTxSectorID (uint16_t sectorID);
<   /**
<    * The Decoded TX Antenna ID subfield contains the value of the TX Antenna ID subfield from the TDD SSW
<    * frame that the feedback frame is sent in response to and that was received with the best quality.
<    * \param antennaID
<    */
<   void SetDecodedTxAntennaID (uint8_t antennaID);
<   /**
<    * The SNR Report subfield is set to the value of the SNR achieved while decoding the TDD SSW frame
<    * received with the best quality and which is indicated in the Decoded TX Sector ID subfield. The value of the
<    * SNR Report subfield is an unsigned integer referenced to a level of –8 dB. Each step is 0.25 dB. SNR values
<    * less than or equal to –8 dB are represented as 0. SNR values greater than or equal to 55.75 dB are represented
<    * as 0xFF.
<    * \param snr
<    */
<   void SetSnrReport (uint8_t snr);
<   /**
<    * The Feedback Count Index subfield is counter indicating the index of the TDD SSW Feedback frame
<    * transmission during a TDD slot. Value 0 is used in the first transmitted TDD SSW Feedback frame and this
<    * subfield value is increased by 1 for each subsequent transmitted frame.
<    * \param index
<    */
<   void SetFeedbackCountIndex (uint8_t index);
< 
<   uint16_t GetTxSectorID (void) const;
<   uint8_t GetTxAntennaID (void) const;
<   uint16_t GetDecodedTxSectorID (void) const;
<   uint8_t GetDecodedTxAntennaID (void) const;
<   uint8_t GetSnrReport (void) const;
<   uint8_t GetFeedbackCountIndex (void) const;
< 
< private:
<   uint16_t m_sectorID;
<   uint8_t m_antennaID;
<   uint16_t m_decodedSectorID;
<   uint8_t m_decodedAntennaID;
<   uint8_t m_snrReport;
<   uint8_t m_feedbackCountIndex;
< 
< };
< 
< /*********************************************
<  *     TDD SSW ACK format (9.3.1.24.4)
<  *********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for TDD Beamforming SSW ACK Frame.
<  */
< class TDD_Beamforming_SSW_ACK : public TDD_Beamforming
< {
< public:
<   TDD_Beamforming_SSW_ACK ();
<   ~TDD_Beamforming_SSW_ACK ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Decoded TX Sector ID subfield contains the value of the TX Sector ID subfield from the TDD SSW
<    * Feedback frame that was received from the responder.
<    * \param sectorID
<    */
<   void SetDecodedTxSectorID (uint16_t sectorID);
<   /**
<    * The Decoded TX Antenna ID subfield contains the value of the TX Antenna ID subfield from the TDD SSW
<    * Feedback frame that was received from the responder.
<    * \param antennaID
<    */
<   void SetDecodedTxAntennaID (uint8_t antennaID);
<   /**
<    * The Count Index subfield indicates the index of the TDD Beamforming frame transmitted by the initiator
<    * within a TDD slot, with the subfield set to 0 for the first frame transmission and increased by one for each
<    * successive frame transmission within a TDD slot.
<    * \param index
<    */
<   void SetCountIndex (uint8_t index);
<   /**
<    * The Transmit Period subfield indicates the interval, in units of BTUs, between successive TDD SSW
<    * transmissions with the same Count Index subfield value in different TDD slots.
<    * \param period
<    */
<   void SetTransmitPeriod (uint8_t period);
<   /**
<    * The SNR Report subfield is set to the value of the SNR achieved while decoding the TDD SSW Feedback
<    * frame. The value of the SNR Report subfield is an unsigned integer referenced to a level of –8 dB. Each step
<    * is 0.25 dB. SNR values less than or equal to –8 dB are represented as 0. SNR values greater than or equal to
<    * 55.75 dB are represented as 0xFF.
<    * \param snr
<    */
<   void SetSnrReport (uint8_t snr);
<   /**
<    * The Initiator Transmit Offset subfield indicates the offset, in units of BTUs, beginning immediately after the
<    * end of the TDD SSW Ack frame, to the TDD slot in which the initiator is expected to transmit an additional
<    * frame (e.g., an Announce frame) to the responder. When the Initiator Transmit Offset subfield is set to 0, no
<    * time offset indication is specified by the initiator.
<    * \param offset
<    */
<   void SetInitiatorTransmitOffset (uint16_t offset);
<   /**
<    * The Responder Transmit Offset subfield indicates the offset, in units of BTUs, beginning immediately after
<    * the TDD SSW Ack frame, to the TDD slot in which the responder is expected to respond to frames sent by
<    * the initiator. When the Responder Transmit Offset subfield is set to 0, no time offset indication is specified
<    * by the initiator.
<    * \param offset
<    */
<   void SetResponderTransmitOffset (uint8_t offset);
<   /**
<    * The Ack Count Index subfield indicates the number of the TDD SSW Ack frames that have been sent before
<    * the current TDD SSW Ack frame within the same TDD slot. The Ack Count Index subfield is set to 0 if no
<    * TDD SSW Ack frame is transmitted before the current TDD SSW Ack frame in the same TDD slot, and
<    * increases by one for each transmission of a TDD SSW Ack frame within the same TDD slot.
<    * \param count
<    */
<   void SetAckCountIndex (uint8_t count);
< 
<   uint16_t GetDecodedTxSectorID (void) const;
<   uint8_t GetDecodedTxAntennaID (void) const;
<   uint8_t GetCountIndex (void) const;
<   uint8_t GetTransmitPeriod (void) const;
<   uint8_t GetSnrReport (void) const;
<   uint16_t GetInitiatorTransmitOffGet (void) const;
<   uint8_t GetResponderTransmitOffGet (void) const;
<   uint8_t GetAckCountIndex (void) const;
< 
< private:
<   uint16_t m_sectorID;
<   uint8_t m_antennaID;
<   uint8_t m_countIndex;
<   uint8_t m_transmitPeriod;
<   uint8_t m_snrReport;
<   uint16_t m_InitiatorTransmitOffset;
<   uint8_t m_responderTransmitOffset;
<   uint8_t m_ackCountIndex;
< 
---
>     uint16_t m_bitmap[64];
>     uint64_t m_compressedBitmap;
>   } bitmap;
1070c408
< } // namespace ns3
---
> } //namespace ns3
Only in ../../ns-3-dev/src/wifi/model: dca-txop.cc
Only in ../../ns-3-dev/src/wifi/model: dca-txop.h
Only in ../../ns-3-dev/src/wifi/model: dcf.cc
Only in ../../ns-3-dev/src/wifi/model: dcf.h
Only in ../../ns-3-dev/src/wifi/model: dcf-manager.cc
Only in ../../ns-3-dev/src/wifi/model: dcf-manager.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-adhoc-wifi-mac.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-adhoc-wifi-mac.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-ap-wifi-mac.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-ap-wifi-mac.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-ati-txop.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-ati-txop.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-beacon-txop.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-beacon-txop.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-capabilities.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-capabilities.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-error-model.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-error-model.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-information-elements.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-information-elements.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-sls-txop.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-sls-txop.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-sta-wifi-mac.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-sta-wifi-mac.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-channel.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-channel.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-mac.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-mac.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-phy.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-phy.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-phy-header.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-phy-header.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-spectrum-phy-interface.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-spectrum-phy-interface.h
diff ../../NS3-WiGig/src/wifi/model/dsss-error-rate-model.cc ../../ns-3-dev/src/wifi/model/dsss-error-rate-model.cc
43c43
< DsssErrorRateModel::GetDsssDbpskSuccessRate (double sinr, uint64_t nbits)
---
> DsssErrorRateModel::GetDsssDbpskSuccessRate (double sinr, uint32_t nbits)
52c52
< DsssErrorRateModel::GetDsssDqpskSuccessRate (double sinr, uint64_t nbits)
---
> DsssErrorRateModel::GetDsssDqpskSuccessRate (double sinr, uint32_t nbits)
61c61
< DsssErrorRateModel::GetDsssDqpskCck5_5SuccessRate (double sinr, uint64_t nbits)
---
> DsssErrorRateModel::GetDsssDqpskCck5_5SuccessRate (double sinr, uint32_t nbits)
68c68
<   return std::min (1.0, std::pow (1.0 - sep, nbits / 4.0));
---
>   return std::pow (1.0 - sep, nbits / 4.0);
71c71
<   //The Matlab model
---
>   //The matlab model
83c83
<       //fitprops.coeff from Matlab berfit
---
>       //fitprops.coeff from matlab berfit
90c90
<   return std::min (1.0, std::pow ((1.0 - ber), static_cast<double> (nbits)));
---
>   return std::pow ((1.0 - ber), static_cast<double> (nbits));
95c95
< DsssErrorRateModel::GetDsssDqpskCck11SuccessRate (double sinr, uint64_t nbits)
---
> DsssErrorRateModel::GetDsssDqpskCck11SuccessRate (double sinr, uint32_t nbits)
103c103
<   return std::min (1.0, std::pow (1.0 - sep, nbits / 8.0));
---
>   return std::pow (1.0 - sep, nbits / 8.0);
106c106
<   //The Matlab model
---
>   //The matlab model
118c118
<       //fitprops.coeff from Matlab berfit
---
>       //fitprops.coeff from matlab berfit
127c127
<   return std::min (1.0, std::pow ((1.0 - ber), static_cast<double> (nbits)));
---
>   return std::pow ((1.0 - ber), static_cast<double> (nbits));
diff ../../NS3-WiGig/src/wifi/model/dsss-error-rate-model.h ../../ns-3-dev/src/wifi/model/dsss-error-rate-model.h
23a24
> #include <stdint.h>
34,36d34
< /**
<  * Structure for integral function parameters
<  */
39,40c37,38
<   double beta; ///< Beta parameter
<   double n;    ///< n parameter
---
>   double beta;
>   double n;
43,50d40
< /**
<  * Integral function using GSL library
<  *
<  * \param x the input x variable
<  * \param params a pointer to FunctionParameters struct
<  *
<  * \return the integral function
<  */
60c50
<  *      Digital Communications, 2001 edition
---
>  *      Digitial Communications, 2001 edition
62c52
<  *      approximations for DQPSK transmission bit error rate", G. Ferrari and G.E. Corazza
---
>  *      approximations for dqpsk transmission bit error rate", G. Ferrari and G.E. Corazza
65c55
<  *      performance of the IEEE 802.11b complementarycode-key signal sets",
---
>  *      performance of the ieee 802.11b complementarycode-key signal sets",
69c59
<  *  This model is designed to run with highest accuracy using the GNU
---
>  *  This model is designed to run with highest accuracy using the Gnu
83c73
<    * \param x the input variable
---
>    * \param x x
96c86
<   static double GetDsssDbpskSuccessRate (double sinr, uint64_t nbits);
---
>   static double GetDsssDbpskSuccessRate (double sinr, uint32_t nbits);
105c95
<   static double GetDsssDqpskSuccessRate (double sinr,uint64_t nbits);
---
>   static double GetDsssDqpskSuccessRate (double sinr,uint32_t nbits);
115c105
<   static double GetDsssDqpskCck5_5SuccessRate (double sinr,uint64_t nbits);
---
>   static double GetDsssDqpskCck5_5SuccessRate (double sinr,uint32_t nbits);
125c115
<   static double GetDsssDqpskCck11SuccessRate (double sinr,uint64_t nbits);
---
>   static double GetDsssDqpskCck11SuccessRate (double sinr,uint32_t nbits);
133d122
<   /// WLAN perfect
135d123
<   /// WLAN impossible
142a131
> 
diff ../../NS3-WiGig/src/wifi/model/dsss-parameter-set.cc ../../ns-3-dev/src/wifi/model/dsss-parameter-set.cc
21a22,24
> #include "ns3/assert.h"
> #include "ns3/log.h"
> #include <cmath>
24a28,29
> NS_LOG_COMPONENT_DEFINE ("DsssParameterSet");
> 
34c39
<   return IE_DSSS_PARAMETER_SET;
---
>   return IE_DS_PARAMETER_SET;
49a55,60
> DsssParameterSet::GetCurrentChannel (void) const
> {
>   return m_currentChannel;
> }
> 
> uint8_t
52c63
<   NS_ASSERT (m_dsssSupported);
---
>   NS_ASSERT (m_dsssSupported > 0);
59c70
<   if (!m_dsssSupported)
---
>   if (m_dsssSupported < 1)
69c80
<   if (!m_dsssSupported)
---
>   if (m_dsssSupported < 1)
79c90
<   if (m_dsssSupported)
---
>   if (m_dsssSupported == 1)
90a102,113
> }
> 
> ATTRIBUTE_HELPER_CPP (DsssParameterSet);
> 
> std::ostream & operator << (std::ostream &os, const DsssParameterSet &DsssParameterSet)
> {
>   return os;
> }
> 
> std::istream &operator >> (std::istream &is, DsssParameterSet &DsssParameterSet)
> {
>   return is;
diff ../../NS3-WiGig/src/wifi/model/dsss-parameter-set.h ../../ns-3-dev/src/wifi/model/dsss-parameter-set.h
24c24,27
< #include "wifi-information-element.h"
---
> #include <stdint.h>
> #include <ostream>
> #include "ns3/buffer.h"
> #include "ns3/wifi-information-element.h"
38,39c41,56
< 
<   // Implementations of pure virtual methods of WifiInformationElement
---
>   void SetDsssSupported (uint8_t DsssSupported);
>   
>   /**
>    * Set the Current Channel field in the DsssParameterSet information element.
>    *
>    * \param qosInfo the CurrentChannel field in the DsssParameterSet information element
>    */
>   void SetCurrentChannel (uint8_t currentChannel);
>   
>   /*
>    * Return the Current Channel field in the DsssParameterSet information element.
>    *
>    * \return the Current Channel field in the DsssParameterSet information element
>    */
>   uint8_t GetCurrentChannel (void) const;
>   
44,50c61
<   /* This information element is a bit special in that it is only
<      included if the STA does support DSSS. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
---
>     
52,53c63,70
<    * Set DSSS supported
<    * \param dsssSupported the DSSS supported indicator
---
>    * This information element is a bit special in that it is only
>    * included if the STA does support DSSS. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
55,56c72
<   void SetDsssSupported (uint8_t dsssSupported);
< 
---
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
58c74
<    * Set the Current Channel field in the DsssParameterSet information element.
---
>    * Return the serialized size of this DSSS Parameter Set.
60c76
<    * \param currentChannel the CurrentChannel field in the DsssParameterSet information element
---
>    * \return the serialized size of this DSSS Parameter Set
62,63c78
<   void SetCurrentChannel (uint8_t currentChannel);
< 
---
>   uint16_t GetSerializedSize () const;
66c81
<   uint8_t m_currentChannel; ///< current channel number
---
>   uint8_t m_currentChannel;
68c83
<   /// This is used to decide whether this element should be added to the frame or not
---
>   //This is used to decide whether this element should be added to the frame or not
70a86,90
> 
> std::ostream &operator << (std::ostream &os, const DsssParameterSet &dsssParameterSet);
> std::istream &operator >> (std::istream &is, DsssParameterSet &dsssParameterSet);
> 
> ATTRIBUTE_HELPER_HEADER (DsssParameterSet);
diff ../../NS3-WiGig/src/wifi/model/edca-parameter-set.cc ../../ns-3-dev/src/wifi/model/edca-parameter-set.cc
21a22,23
> #include "ns3/assert.h"
> #include "ns3/log.h"
25a28,29
> NS_LOG_COMPONENT_DEFINE ("EdcaParameterSet");
> 
49,54d52
< uint8_t
< EdcaParameterSet::IsQosSupported (void) const
< {
<   return ((m_acBE != 0) || (m_acBK != 0) || (m_acVI != 0) || (m_acVO != 0));
< }
< 
67a66,71
> EdcaParameterSet::SetBeAcm (uint8_t acm)
> {
>   m_acBE |= (acm & 0x01) << 4;
> }
> 
> void
74c78
< EdcaParameterSet::SetBeCWmin (uint32_t cwMin)
---
> EdcaParameterSet::SetBeCWmin (uint8_t cwMin)
76c80
<   uint8_t ECWmin = static_cast<uint8_t> (log2 (cwMin + 1));
---
>   uint8_t ECWmin = log2 (cwMin + 1);
81c85
< EdcaParameterSet::SetBeCWmax (uint32_t cwMax)
---
> EdcaParameterSet::SetBeCWmax (uint8_t cwMax)
83c87
<   uint8_t ECWmax = static_cast<uint8_t> (log2 (cwMax + 1));
---
>   uint8_t ECWmax = log2 (cwMax + 1);
88c92
< EdcaParameterSet::SetBeTxopLimit (uint16_t txop)
---
> EdcaParameterSet::SetBeTXOPLimit (uint16_t txop)
99a104,109
> EdcaParameterSet::SetBkAcm (uint8_t acm)
> {
>   m_acBK |= (acm & 0x01) << 4;
> }
> 
> void
106c116
< EdcaParameterSet::SetBkCWmin (uint32_t cwMin)
---
> EdcaParameterSet::SetBkCWmin (uint8_t cwMin)
108c118
<   uint8_t ECWmin = static_cast<uint8_t> (log2 (cwMin + 1));
---
>   uint8_t ECWmin = log2 (cwMin + 1);
113c123
< EdcaParameterSet::SetBkCWmax (uint32_t cwMax)
---
> EdcaParameterSet::SetBkCWmax (uint8_t cwMax)
115c125
<   uint8_t ECWmax = static_cast<uint8_t> (log2 (cwMax + 1));
---
>   uint8_t ECWmax = log2 (cwMax + 1);
120c130
< EdcaParameterSet::SetBkTxopLimit (uint16_t txop)
---
> EdcaParameterSet::SetBkTXOPLimit (uint16_t txop)
131a142,147
> EdcaParameterSet::SetViAcm (uint8_t acm)
> {
>   m_acVI |= (acm & 0x01) << 4;
> }
> 
> void
138c154
< EdcaParameterSet::SetViCWmin (uint32_t cwMin)
---
> EdcaParameterSet::SetViCWmin (uint8_t cwMin)
140c156
<   uint8_t ECWmin = static_cast<uint8_t> (log2 (cwMin + 1));
---
>   uint8_t ECWmin = log2 (cwMin + 1);
145c161
< EdcaParameterSet::SetViCWmax (uint32_t cwMax)
---
> EdcaParameterSet::SetViCWmax (uint8_t cwMax)
147c163
<   uint8_t ECWmax = static_cast<uint8_t> (log2 (cwMax + 1));
---
>   uint8_t ECWmax = log2 (cwMax + 1);
152c168
< EdcaParameterSet::SetViTxopLimit (uint16_t txop)
---
> EdcaParameterSet::SetViTXOPLimit (uint16_t txop)
163a180,185
> EdcaParameterSet::SetVoAcm (uint8_t acm)
> {
>   m_acVO |= (acm & 0x01) << 4;
> }
> 
> void
170c192
< EdcaParameterSet::SetVoCWmin (uint32_t cwMin)
---
> EdcaParameterSet::SetVoCWmin (uint8_t cwMin)
172c194
<   uint8_t ECWmin = static_cast<uint8_t> (log2 (cwMin + 1));
---
>   uint8_t ECWmin = log2 (cwMin + 1);
177c199
< EdcaParameterSet::SetVoCWmax (uint32_t cwMax)
---
> EdcaParameterSet::SetVoCWmax (uint8_t cwMax)
179c201
<   uint8_t ECWmax = static_cast<uint8_t> (log2 (cwMax + 1));
---
>   uint8_t ECWmax = log2 (cwMax + 1);
184c206
< EdcaParameterSet::SetVoTxopLimit (uint16_t txop)
---
> EdcaParameterSet::SetVoTXOPLimit (uint16_t txop)
201c223,235
< uint32_t
---
> uint8_t
> EdcaParameterSet::GetBeAcm (void) const
> {
>   return ((m_acBE >> 4) & 0x01);
> }
> 
> uint8_t
> EdcaParameterSet::GetBeAci (void) const
> {
>   return ((m_acBE >> 5) & 0x03);
> }
> 
> uint8_t
205c239
<   return static_cast<uint32_t> (exp2 (ECWmin) - 1);
---
>   return (exp2 (ECWmin) - 1);
208c242
< uint32_t
---
> uint8_t
212c246
<   return static_cast<uint32_t> (exp2 (ECWmax) - 1);
---
>   return (exp2 (ECWmax) - 1);
216c250
< EdcaParameterSet::GetBeTxopLimit (void) const
---
> EdcaParameterSet::GetBeTXOPLimit (void) const
227c261,273
< uint32_t
---
> uint8_t
> EdcaParameterSet::GetBkAcm (void) const
> {
>   return ((m_acBK >> 4) & 0x01);
> }
> 
> uint8_t
> EdcaParameterSet::GetBkAci (void) const
> {
>   return ((m_acBK >> 5) & 0x03);
> }
> 
> uint8_t
231c277
<   return static_cast<uint32_t> (exp2 (ECWmin) - 1);
---
>   return (exp2 (ECWmin) - 1);
234c280
< uint32_t
---
> uint8_t
238c284
<   return static_cast<uint32_t> (exp2 (ECWmax) - 1);
---
>   return (exp2 (ECWmax) - 1);
242c288
< EdcaParameterSet::GetBkTxopLimit (void) const
---
> EdcaParameterSet::GetBkTXOPLimit (void) const
253c299,311
< uint32_t
---
> uint8_t
> EdcaParameterSet::GetViAcm (void) const
> {
>   return ((m_acVI >> 4) & 0x01);
> }
> 
> uint8_t
> EdcaParameterSet::GetViAci (void) const
> {
>   return ((m_acVI >> 5) & 0x03);
> }
> 
> uint8_t
257c315
<   return static_cast<uint32_t> (exp2 (ECWmin) - 1);
---
>   return (exp2 (ECWmin) - 1);
260c318
< uint32_t
---
> uint8_t
264c322
<   return static_cast<uint32_t> (exp2 (ECWmax) - 1);
---
>   return (exp2 (ECWmax) - 1);
268c326
< EdcaParameterSet::GetViTxopLimit (void) const
---
> EdcaParameterSet::GetViTXOPLimit (void) const
279c337,349
< uint32_t
---
> uint8_t
> EdcaParameterSet::GetVoAcm (void) const
> {
>   return ((m_acVO >> 4) & 0x01);
> }
> 
> uint8_t
> EdcaParameterSet::GetVoAci (void) const
> {
>   return ((m_acVO >> 5) & 0x03);
> }
> 
> uint8_t
283c353
<   return static_cast<uint32_t> (exp2 (ECWmin) - 1);
---
>   return (exp2 (ECWmin) - 1);
286c356
< uint32_t
---
> uint8_t
290c360
<   return static_cast<uint32_t> (exp2 (ECWmax) - 1);
---
>   return (exp2 (ECWmax) - 1);
294c364
< EdcaParameterSet::GetVoTxopLimit (void) const
---
> EdcaParameterSet::GetVoTXOPLimit (void) const
302c372
<   NS_ASSERT (m_qosSupported);
---
>   NS_ASSERT (m_qosSupported > 0);
309c379
<   if (!m_qosSupported)
---
>   if (m_qosSupported < 1)
319c389
<   if (!m_qosSupported)
---
>   if (m_qosSupported < 1)
329c399
<   if (m_qosSupported)
---
>   if (m_qosSupported == 1)
331c401
<       start.WriteU8 (GetQosInfo ());
---
>       start.WriteU8 (m_qosInfo);
350a421,432
> }
> 
> ATTRIBUTE_HELPER_CPP (EdcaParameterSet);
> 
> std::ostream & operator << (std::ostream &os, const EdcaParameterSet &edcaParameterSet)
> {
>   return os;
> }
> 
> std::istream &operator >> (std::istream &is, EdcaParameterSet &edcaParameterSet)
> {
>   return is;
diff ../../NS3-WiGig/src/wifi/model/edca-parameter-set.h ../../ns-3-dev/src/wifi/model/edca-parameter-set.h
24c24,27
< #include "wifi-information-element.h"
---
> #include <stdint.h>
> #include <ostream>
> #include "ns3/buffer.h"
> #include "ns3/wifi-information-element.h"
38,54d40
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is a QoS STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
<   /**
<    * Set QOS supported function
<    * \param qosSupported the QOS supported indicator
<    */
56,61c42
<   /**
<    * Is QOS supported function
<    * \returns the is QOS supported indicator
<    */
<   uint8_t IsQosSupported (void) const;
< 
---
>   
74a56,61
>    * Set the AC_BE ACM field in the EdcaParameterSet information element.
>    *
>    * \param aifsn the AC_BE ACM field in the EdcaParameterSet information element
>    */
>   void SetBeAcm (uint8_t acm);
>   /**
77c64
<    * \param aci the AC_BE ACI field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_BE ACI field in the EdcaParameterSet information element
83c70
<    * \param cwMin the AC_BE CWmin field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_BE CWmin field in the EdcaParameterSet information element
85c72
<   void SetBeCWmin (uint32_t cwMin);
---
>   void SetBeCWmin (uint8_t cwMin);
89c76
<    * \param cwMax the AC_BE CWmax field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_BE CWmax field in the EdcaParameterSet information element
91c78
<   void SetBeCWmax (uint32_t cwMax);
---
>   void SetBeCWmax (uint8_t cwMax);
95c82
<    * \param txop the AC_BE TXOP Limit field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_BE TXOP Limit field in the EdcaParameterSet information element
97c84
<   void SetBeTxopLimit (uint16_t txop);
---
>   void SetBeTXOPLimit (uint16_t txop);
104a92,97
>    * Set the AC_BK ACM field in the EdcaParameterSet information element.
>    *
>    * \param aifsn the AC_BK ACM field in the EdcaParameterSet information element
>    */
>   void SetBkAcm (uint8_t acm);
>   /**
107c100
<    * \param aci the AC_BK ACI field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_BK ACI field in the EdcaParameterSet information element
113c106
<    * \param cwMin the AC_BK CWmin field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_BK CWmin field in the EdcaParameterSet information element
115c108
<   void SetBkCWmin (uint32_t cwMin);
---
>   void SetBkCWmin (uint8_t cwMin);
119c112
<    * \param cwMax the AC_BK CWmax field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_BK CWmax field in the EdcaParameterSet information element
121c114
<   void SetBkCWmax (uint32_t cwMax);
---
>   void SetBkCWmax (uint8_t cwMax);
125c118
<    * \param txop the AC_BK TXOP Limit field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_BK TXOP Limit field in the EdcaParameterSet information element
127c120
<   void SetBkTxopLimit (uint16_t txop);
---
>   void SetBkTXOPLimit (uint16_t txop);
134a128,133
>    * Set the AC_VI ACM field in the EdcaParameterSet information element.
>    *
>    * \param aifsn the AC_VI ACM field in the EdcaParameterSet information element
>    */
>   void SetViAcm (uint8_t acm);
>   /**
137c136
<    * \param aci the AC_VI ACI field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_VI ACI field in the EdcaParameterSet information element
143c142
<    * \param cwMin the AC_VI CWmin field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_VI CWmin field in the EdcaParameterSet information element
145c144
<   void SetViCWmin (uint32_t cwMin);
---
>   void SetViCWmin (uint8_t cwMin);
149c148
<    * \param cwMax the AC_VI CWmax field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_VI CWmax field in the EdcaParameterSet information element
151c150
<   void SetViCWmax (uint32_t cwMax);
---
>   void SetViCWmax (uint8_t cwMax);
155c154
<    * \param txop the AC_VI TXOP Limit field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_VI TXOP Limit field in the EdcaParameterSet information element
157c156
<   void SetViTxopLimit (uint16_t txop);
---
>   void SetViTXOPLimit (uint16_t txop);
164a164,169
>    * Set the AC_VO ACM field in the EdcaParameterSet information element.
>    *
>    * \param aifsn the AC_VO ACM field in the EdcaParameterSet information element
>    */
>   void SetVoAcm (uint8_t acm);
>   /**
167c172
<    * \param aci the AC_VO ACI field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_VO ACI field in the EdcaParameterSet information element
173c178
<    * \param cwMin the AC_VO CWmin field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_VO CWmin field in the EdcaParameterSet information element
175c180
<   void SetVoCWmin (uint32_t cwMin);
---
>   void SetVoCWmin (uint8_t cwMin);
179c184
<    * \param cwMax the AC_VO CWmax field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_VO CWmax field in the EdcaParameterSet information element
181c186
<   void SetVoCWmax (uint32_t cwMax);
---
>   void SetVoCWmax (uint8_t cwMax);
185c190
<    * \param txop the AC_VO TXOP Limit field in the EdcaParameterSet information element
---
>    * \param aifsn the AC_VO TXOP Limit field in the EdcaParameterSet information element
187,189c192,194
<   void SetVoTxopLimit (uint16_t txop);
< 
<   /**
---
>   void SetVoTXOPLimit (uint16_t txop);
>   
>   /*
195c200
<   /**
---
>   /*
201c206,218
<   /**
---
>   /*
>    * Return the AC_BE ACM field in the EdcaParameterSet information element.
>    *
>    * \return the AC_BE ACM field in the EdcaParameterSet information element
>    */
>   uint8_t GetBeAcm (void) const;
>   /*
>    * Return the AC_BE ACI field in the EdcaParameterSet information element.
>    *
>    * \return the AC_BE ACI field in the EdcaParameterSet information element
>    */
>   uint8_t GetBeAci (void) const;
>   /*
206,207c223,224
<   uint32_t GetBeCWmin (void) const;
<   /**
---
>   uint8_t GetBeCWmin (void) const;
>   /*
212,213c229,230
<   uint32_t GetBeCWmax (void) const;
<   /**
---
>   uint8_t GetBeCWmax (void) const;
>   /*
218,219c235,236
<   uint16_t GetBeTxopLimit (void) const;
<   /**
---
>   uint16_t GetBeTXOPLimit (void) const;
>   /*
225c242,254
<   /**
---
>   /*
>    * Return the AC_BK ACM field in the EdcaParameterSet information element.
>    *
>    * \return the AC_BK ACM field in the EdcaParameterSet information element
>    */
>   uint8_t GetBkAcm (void) const;
>   /*
>    * Return the AC_BK ACI field in the EdcaParameterSet information element.
>    *
>    * \return the AC_BK ACI field in the EdcaParameterSet information element
>    */
>   uint8_t GetBkAci (void) const;
>   /*
230,231c259,260
<   uint32_t GetBkCWmin (void) const;
<   /**
---
>   uint8_t GetBkCWmin (void) const;
>   /*
236,237c265,266
<   uint32_t GetBkCWmax (void) const;
<   /**
---
>   uint8_t GetBkCWmax (void) const;
>   /*
242,243c271,272
<   uint16_t GetBkTxopLimit (void) const;
<   /**
---
>   uint16_t GetBkTXOPLimit (void) const;
>   /*
249c278,290
<   /**
---
>   /*
>    * Return the AC_VI ACM field in the EdcaParameterSet information element.
>    *
>    * \return the AC_VI ACM field in the EdcaParameterSet information element
>    */
>   uint8_t GetViAcm (void) const;
>   /*
>    * Return the AC_VI ACI field in the EdcaParameterSet information element.
>    *
>    * \return the AC_VI ACI field in the EdcaParameterSet information element
>    */
>   uint8_t GetViAci (void) const;
>   /*
254,255c295,296
<   uint32_t GetViCWmin (void) const;
<   /**
---
>   uint8_t GetViCWmin (void) const;
>   /*
260,261c301,302
<   uint32_t GetViCWmax (void) const;
<   /**
---
>   uint8_t GetViCWmax (void) const;
>   /*
266,267c307,308
<   uint16_t GetViTxopLimit (void) const;
<   /**
---
>   uint16_t GetViTXOPLimit (void) const;
>   /*
273c314,326
<   /**
---
>   /*
>    * Return the AC_VO ACM field in the EdcaParameterSet information element.
>    *
>    * \return the AC_VO ACM field in the EdcaParameterSet information element
>    */
>   uint8_t GetVoAcm (void) const;
>   /*
>    * Return the AC_VO ACI field in the EdcaParameterSet information element.
>    *
>    * \return the AC_VO ACI field in the EdcaParameterSet information element
>    */
>   uint8_t GetVoAci (void) const;
>   /*
278,279c331,332
<   uint32_t GetVoCWmin (void) const;
<   /**
---
>   uint8_t GetVoCWmin (void) const;
>   /*
284,285c337,338
<   uint32_t GetVoCWmax (void) const;
<   /**
---
>   uint8_t GetVoCWmax (void) const;
>   /*
290,291c343,366
<   uint16_t GetVoTxopLimit (void) const;
< 
---
>   uint16_t GetVoTXOPLimit (void) const;
>   
>   WifiInformationElementId ElementId () const;
>   uint8_t GetInformationFieldSize () const;
>   void SerializeInformationField (Buffer::Iterator start) const;
>   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
>     
>   /**
>    * This information element is a bit special in that it is only
>    * included if the STA is a QoS STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this EDCA Parameter Set.
>    *
>    * \return the serialized size of this EDCA Parameter Set
>    */
>   uint16_t GetSerializedSize () const;
294,299c369,374
<   uint8_t m_qosInfo;  ///< QOS info
<   uint8_t m_reserved; ///< reserved
<   uint32_t m_acBE;    ///< AC_BE
<   uint32_t m_acBK;    ///< AC_BK
<   uint32_t m_acVI;    ///< AC_VI
<   uint32_t m_acVO;    ///< AC_VO
---
>   uint8_t m_qosInfo;
>   uint8_t m_reserved;
>   uint32_t m_acBE;
>   uint32_t m_acBK;
>   uint32_t m_acVI;
>   uint32_t m_acVO;
301c376
<   /// This is used to decide whether this element should be added to the frame or not
---
>   //This is used to decide whether this element should be added to the frame or not
303a379,383
> 
> std::ostream &operator << (std::ostream &os, const EdcaParameterSet &edcaParameterSet);
> std::istream &operator >> (std::istream &is, EdcaParameterSet &edcaParameterSet);
> 
> ATTRIBUTE_HELPER_HEADER (EdcaParameterSet);
Only in ../../ns-3-dev/src/wifi/model: edca-txop-n.cc
Only in ../../ns-3-dev/src/wifi/model: edca-txop-n.h
Only in ../../NS3-WiGig/src/wifi/model: edmg-capabilities.cc
Only in ../../NS3-WiGig/src/wifi/model: edmg-capabilities.h
Only in ../../NS3-WiGig/src/wifi/model: edmg-short-ssw.cc
Only in ../../NS3-WiGig/src/wifi/model: edmg-short-ssw.h
diff ../../NS3-WiGig/src/wifi/model/erp-information.cc ../../ns-3-dev/src/wifi/model/erp-information.cc
21a22,23
> #include "ns3/assert.h"
> #include "ns3/log.h"
24a27,28
> NS_LOG_COMPONENT_DEFINE ("ErpInformation");
> 
82c86
<   NS_ASSERT (m_erpSupported);
---
>   NS_ASSERT (m_erpSupported > 0);
89c93
<   if (!m_erpSupported)
---
>   if (m_erpSupported < 1)
99c103
<   if (!m_erpSupported)
---
>   if (m_erpSupported < 1)
109c113
<   if (m_erpSupported)
---
>   if (m_erpSupported == 1)
123a128,129
> ATTRIBUTE_HELPER_CPP (ErpInformation);
> 
125c131
< operator << (std::ostream &os, const ErpInformation &erpInformation)
---
> operator << (std::ostream &os, const ErpInformation &erpinformation)
127,129c133,135
<   os <<  bool (erpInformation.GetBarkerPreambleMode ())
<      << "|" << bool (erpInformation.GetUseProtection ())
<      << "|" << bool (erpInformation.GetNonErpPresent ());
---
>   os <<  bool (erpinformation.GetBarkerPreambleMode ())
>      << "|" << bool (erpinformation.GetUseProtection ())
>      << "|" << bool (erpinformation.GetNonErpPresent ());
131a138,148
> }
> 
> std::istream &operator >> (std::istream &is, ErpInformation &erpinformation)
> {
>   bool c1, c2, c3;
>   is >> c1 >> c2 >> c3;
>   erpinformation.SetBarkerPreambleMode (c1);
>   erpinformation.SetUseProtection (c2);
>   erpinformation.SetNonErpPresent (c3);
> 
>   return is;
diff ../../NS3-WiGig/src/wifi/model/erp-information.h ../../ns-3-dev/src/wifi/model/erp-information.h
24c24,27
< #include "wifi-information-element.h"
---
> #include <stdint.h>
> #include <ostream>
> #include "ns3/buffer.h"
> #include "ns3/wifi-information-element.h"
38,57d40
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
< 
<   /* This information element is a bit special in that it is only
<      included if the STA is an ERP STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
<   /**
<    * Set the ERP supported field.
<    *
<    * \param erpSupported the ERP supported field in the ErpInformation information element
<    */
59c42
< 
---
>   
79c62
<   /**
---
>   /*
85c68
<   /**
---
>   /*
91c74
<   /**
---
>   /*
97a81,103
>   WifiInformationElementId ElementId () const;
>   uint8_t GetInformationFieldSize () const;
>   void SerializeInformationField (Buffer::Iterator start) const;
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
>     
>   /**
>    * This information element is a bit special in that it is only
>    * included if the STA is an ERP STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this ErpInformation information element.
>    *
>    * \return the serialized size of this ErpInformation information element
>    */
>   uint16_t GetSerializedSize () const;
100c106
<   uint8_t m_erpInformation; ///< ERP information
---
>   uint8_t m_erpInformation;
102c108
<   /// This is used to decide whether this element should be added to the frame or not
---
>   //This is used to decide whether this element should be added to the frame or not
106,114c112,115
< /**
<  * output stream output operator
<  *
<  * \param os output stream
<  * \param erpInformation the ERP Information
<  *
<  * \returns output stream
<  */
< std::ostream &operator << (std::ostream &os, const ErpInformation &erpInformation);
---
> std::ostream &operator << (std::ostream &os, const ErpInformation &erpinformation);
> std::istream &operator >> (std::istream &is, ErpInformation &erpinformation);
> 
> ATTRIBUTE_HELPER_HEADER (ErpInformation);
diff ../../NS3-WiGig/src/wifi/model/error-rate-model.cc ../../ns-3-dev/src/wifi/model/error-rate-model.cc
22d21
< #include "ns3/wifi-tx-vector.h"
diff ../../NS3-WiGig/src/wifi/model/error-rate-model.h ../../ns-3-dev/src/wifi/model/error-rate-model.h
23a24,26
> #include <stdint.h>
> #include "wifi-mode.h"
> #include "wifi-tx-vector.h"
27,30d29
< 
< class WifiTxVector;
< class WifiMode;
< 
39,42d37
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
47c42
<    * \param ber a target BER
---
>    * \param ber a target ber
49c44
<    * \return the SNR which corresponds to the requested BER
---
>    * \return the snr which corresponds to the requested ber
64c59
<    * contains multiple modes (e.g. PHY header sent differently from PHY
---
>    * contains multiple modes (e.g. PLCP header sent differently from PLCP
66c61
<    * to calculate the chunk error rate, and the txVector is used for
---
>    * to calculate the chunk error rate, and the txVector is used for 
70c65
<    * \param txVector TXVECTOR of the overall transmission
---
>    * \param txvector TXVECTOR of the overall transmission
76c71
<   virtual double GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint64_t nbits) const = 0;
---
>   virtual double GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint32_t nbits) const = 0;
Only in ../../NS3-WiGig/src/wifi/model: extended-capabilities.cc
Only in ../../NS3-WiGig/src/wifi/model: extended-capabilities.h
Only in ../../NS3-WiGig/src/wifi/model: ext-headers.cc
Only in ../../NS3-WiGig/src/wifi/model: ext-headers.h
Only in ../../NS3-WiGig/src/wifi/model: fields-headers.cc
Only in ../../NS3-WiGig/src/wifi/model: fields-headers.h
Only in ../../NS3-WiGig/src/wifi/model: frame-capture-model.cc
Only in ../../NS3-WiGig/src/wifi/model: frame-capture-model.h
Only in ../../NS3-WiGig/src/wifi/model: he-capabilities.cc
Only in ../../NS3-WiGig/src/wifi/model: he-capabilities.h
Only in ../../NS3-WiGig/src/wifi/model: he-configuration.cc
Only in ../../NS3-WiGig/src/wifi/model: he-configuration.h
Only in ../../NS3-WiGig/src/wifi/model: he-operation.cc
Only in ../../NS3-WiGig/src/wifi/model: he-operation.h
diff ../../NS3-WiGig/src/wifi/model/ht-capabilities.cc ../../ns-3-dev/src/wifi/model/ht-capabilities.cc
22a23,24
> #include "ns3/assert.h"
> #include "ns3/log.h"
25a28,29
> NS_LOG_COMPONENT_DEFINE ("HtCapabilities");
> 
41c45
<     m_maxAmpduLengthExponent (0),
---
>     m_maxAmpduLength (0),
57c61
<     m_reverseDirectionResponder (0),
---
>     m_reverzeDirectionResponder (0),
89c93
<   for (uint8_t i = 0; i < MAX_SUPPORTED_MCS; i++)
---
>   for (uint32_t k = 0; k < MAX_SUPPORTED_MCS; k++)
91c95
<       m_rxMcsBitmask[i] = 0;
---
>       m_rxMcsBitmask[k] = 0;
102c106
< HtCapabilities::SetHtSupported (uint8_t htSupported)
---
> HtCapabilities::SetHtSupported (uint8_t htsupported)
104c108
<   m_htSupported = htSupported;
---
>   m_htSupported = htsupported;
114c118
< HtCapabilities::SetSupportedChannelWidth (uint8_t supportedChannelWidth)
---
> HtCapabilities::SetSupportedChannelWidth (uint8_t supportedchannelwidth)
116c120
<   m_supportedChannelWidth = supportedChannelWidth;
---
>   m_supportedChannelWidth = supportedchannelwidth;
126c130
< HtCapabilities::SetShortGuardInterval20 (uint8_t shortGuardInterval)
---
> HtCapabilities::SetShortGuardInterval20 (uint8_t shortguardinterval)
128c132
<   m_shortGuardInterval20 = shortGuardInterval;
---
>   m_shortGuardInterval20 = shortguardinterval;
132c136
< HtCapabilities::SetShortGuardInterval40 (uint8_t shortGuardInterval)
---
> HtCapabilities::SetShortGuardInterval40 (uint8_t shortguardinterval)
134c138
<   m_shortGuardInterval40 = shortGuardInterval;
---
>   m_shortGuardInterval40 = shortguardinterval;
138c142
< HtCapabilities::SetMaxAmsduLength (uint16_t maxAmsduLength)
---
> HtCapabilities::SetMaxAmsduLength (uint8_t maxamsdulength)
140,142c144
<   NS_ABORT_MSG_IF (maxAmsduLength != 3839 && maxAmsduLength != 7935,
<                    "Invalid A-MSDU Max Length value");
<   m_maxAmsduLength = (maxAmsduLength == 3839 ? 0 : 1);
---
>   m_maxAmsduLength = maxamsdulength;
146c148
< HtCapabilities::SetLSigProtectionSupport (uint8_t lSigProtection)
---
> HtCapabilities::SetLSigProtectionSupport (uint8_t lsigprotection)
148c150
<   m_lsigProtectionSupport = lSigProtection;
---
>   m_lsigProtectionSupport = lsigprotection;
152c154
< HtCapabilities::SetMaxAmpduLength (uint32_t maxAmpduLength)
---
> HtCapabilities::SetMaxAmpduLength (uint8_t maxampdulength)
154,162c156
<   for (uint8_t i = 0; i <= 3; i++)
<     {
<       if ((1ul << (13 + i)) - 1 == maxAmpduLength)
<         {
<           m_maxAmpduLengthExponent = i;
<           return;
<         }
<     }
<   NS_ABORT_MSG ("Invalid A-MPDU Max Length value");
---
>   m_maxAmpduLength = maxampdulength;
172c166
< HtCapabilities::SetRxHighestSupportedDataRate (uint16_t maxSupportedRate)
---
> HtCapabilities::SetRxHighestSupportedDataRate (uint16_t maxsupportedrate)
174c168
<   m_rxHighestSupportedDataRate = maxSupportedRate;
---
>   m_rxHighestSupportedDataRate = maxsupportedrate;
178c172
< HtCapabilities::SetTxMcsSetDefined (uint8_t txMcsSetDefined)
---
> HtCapabilities::SetTxMcsSetDefined (uint8_t txmcssetdefined)
180c174
<   m_txMcsSetDefined = txMcsSetDefined;
---
>   m_txMcsSetDefined = txmcssetdefined;
184c178
< HtCapabilities::SetTxRxMcsSetUnequal (uint8_t txRxMcsSetUnequal)
---
> HtCapabilities::SetTxRxMcsSetUnequal (uint8_t txrxmcssetunequal)
186c180
<   m_txRxMcsSetUnequal = txRxMcsSetUnequal;
---
>   m_txRxMcsSetUnequal = txrxmcssetunequal;
190c184
< HtCapabilities::SetTxMaxNSpatialStreams (uint8_t maxTxSpatialStreams)
---
> HtCapabilities::SetTxMaxNSpatialStreams (uint8_t maxtxspatialstreams)
192c186
<   m_txMaxNSpatialStreams = maxTxSpatialStreams - 1; //0 for 1 SS, 1 for 2 SSs, etc
---
>   m_txMaxNSpatialStreams = maxtxspatialstreams;
196c190
< HtCapabilities::SetTxUnequalModulation (uint8_t txUnequalModulation)
---
> HtCapabilities::SetTxUnequalModulation (uint8_t txunequalmodulation)
198c192
<   m_txUnequalModulation = txUnequalModulation;
---
>   m_txUnequalModulation = txunequalmodulation;
225c219,225
< uint16_t
---
> uint8_t
> HtCapabilities::GetShortGuardInterval40 (void) const
> {
>   return m_shortGuardInterval40;
> }
> 
> uint8_t
228,232c228
<   if (m_maxAmsduLength == 0)
<     {
<       return 3839;
<     }
<   return 7935;
---
>   return m_maxAmsduLength;
235c231,237
< uint32_t
---
> uint8_t
> HtCapabilities::GetLSigProtectionSupport (void) const
> {
>   return m_lsigProtectionSupport;
> }
> 
> uint8_t
238c240,248
<   return (1ul << (13 + m_maxAmpduLengthExponent)) - 1;
---
>   return m_maxAmpduLength;
> }
> 
> uint8_t*
> HtCapabilities::GetRxMcsBitmask ()
> {
>   uint8_t* p;
>   p = m_rxMcsBitmask;
>   return p;
254a265,266
>   {
>     for (uint8_t mcs = (nRx - 1) * 8; mcs <= ((7 * nRx) + (nRx - 1)); mcs++)
256c268
<       for (uint8_t mcs = (nRx - 1) * 8; mcs <= ((7 * nRx) + (nRx - 1)); mcs++)
---
>       if (IsSupportedMcs (mcs) == false)
258,261c270
<           if (IsSupportedMcs (mcs) == false)
<             {
<               return (nRx - 1);
<             }
---
>           return (nRx - 1);
263a273
>   }
266a277,307
> uint16_t
> HtCapabilities::GetRxHighestSupportedDataRate (void) const
> {
>   return m_rxHighestSupportedDataRate;
> }
> 
> uint8_t
> HtCapabilities::GetTxMcsSetDefined (void) const
> {
>   return m_txMcsSetDefined;
> }
> 
> uint8_t
> HtCapabilities::GetTxRxMcsSetUnequal (void) const
> {
>   return m_txRxMcsSetUnequal;
> }
> 
> 
> uint8_t
> HtCapabilities::GetTxMaxNSpatialStreams (void) const
> {
>   return m_txMaxNSpatialStreams;
> }
> 
> uint8_t
> HtCapabilities::GetTxUnequalModulation (void) const
> {
>   return m_txUnequalModulation;
> }
> 
270c311
<   //we should not be here if HT is not supported
---
>   //we should not be here if ht is not supported
338c379
<   m_maxAmpduLengthExponent = ctrl & 0x03;
---
>   m_maxAmpduLength = ctrl & 0x03;
347c388
<   val |=  m_maxAmpduLengthExponent & 0x03;
---
>   val |=  m_maxAmpduLength & 0x03;
418c459
<   val |= (m_reverseDirectionResponder & 0x01) << 11;
---
>   val |= (m_reverzeDirectionResponder & 0x01) << 11;
431c472
<   m_reverseDirectionResponder = (ctrl >> 11) & 0x01;
---
>   m_reverzeDirectionResponder = (ctrl >> 11) & 0x01;
551a593,594
> ATTRIBUTE_HELPER_CPP (HtCapabilities);
> 
555c598
<   os << bool (htcapabilities.GetLdpc ())
---
>   os <<  bool (htcapabilities.GetLdpc ())
558,562c601,602
<      << "|" << bool (htcapabilities.GetShortGuardInterval20 ()) << "|";
<   for (uint8_t i = 0; i < MAX_SUPPORTED_MCS; i++)
<     {
<       os << htcapabilities.IsSupportedMcs (i) << " ";
<     }
---
>      << "|" << bool (htcapabilities.GetShortGuardInterval20 ());
> 
563a604,615
> }
> 
> std::istream &operator >> (std::istream &is, HtCapabilities &htcapabilities)
> {
>   bool c1, c2, c3, c4;
>   is >> c1 >> c2 >> c3 >> c4;
>   htcapabilities.SetLdpc (c1);
>   htcapabilities.SetSupportedChannelWidth (c2);
>   htcapabilities.SetGreenfield (c3);
>   htcapabilities.SetShortGuardInterval20 (c4);
> 
>   return is;
diff ../../NS3-WiGig/src/wifi/model/ht-capabilities.h ../../ns-3-dev/src/wifi/model/ht-capabilities.h
25c25,28
< #include "wifi-information-element.h"
---
> #include <stdint.h>
> #include "ns3/buffer.h"
> #include "ns3/attribute-helper.h"
> #include "ns3/wifi-information-element.h"
39a43,44
>  *
>  * \see attribute_HtCapabilities
45,64c50
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is an HT STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
<   /**
<    * Set the HT supported field.
<    *
<    * \param htSupported the HT supported field
<    */
<   void SetHtSupported (uint8_t htSupported);
---
>   void SetHtSupported (uint8_t htsupported);
67c53
<    * Set the HT Capabilities Info field in the HT Capabilities information element.
---
>    * Set the HT Capabilties Info field in the HT Capabilities information element.
69c55
<    * \param ctrl the HT Capabilities Info field in the HT Capabilities information element
---
>    * \param ctrl the HT Capabilties Info field in the HT Capabilities information element
86c72
<    * Set the Extended HT Capabilities field in the HT Capabilities information element.
---
>    * Set the Extended HT Capabilties field in the HT Capabilities information element.
88c74
<    * \param ctrl the Extended HT Capabilities field in the HT Capabilities information element
---
>    * \param ctrl the Extended HT Capabilties field in the HT Capabilities information element
92c78
<    * Set the Transmit Beamforming (TxBF) Capabilities field in the HT Capabilities information element.
---
>    * Set the Transmit Beamforming (TxBF) Capabilties field in the HT Capabilities information element.
94c80
<    * \param ctrl the Transmit Beamforming (TxBF) Capabilities field in the HT Capabilities information element
---
>    * \param ctrl the Transmit Beamforming (TxBF) Capabilties field in the HT Capabilities information element
98c84
<    * Set the the Antenna Selection (ASEL) Capabilities field in the HT Capabilities information element.
---
>    * Set the the Antenna Selection (ASEL) Capabilties field in the HT Capabilities information element.
100c86
<    * \param ctrl the Antenna Selection (ASEL) Capabilities field in the HT Capabilities information element
---
>    * \param ctrl the Antenna Selection (ASEL) Capabilties field in the HT Capabilities information element
104,108d89
<   /**
<    * Set the LDPC field.
<    *
<    * \param ldpc the LDPC field
<    */
110,120c91
<   /**
<    * Set the supported channel width field.
<    *
<    * \param supportedChannelWidth the supported channel width field
<    */
<   void SetSupportedChannelWidth (uint8_t supportedChannelWidth);
<   /**
<    * Set the Greenfield field.
<    *
<    * \param greenfield the Greenfield field
<    */
---
>   void SetSupportedChannelWidth (uint8_t supportedchannelwidth);
122,145c93,96
<   /**
<    * Set the short guard interval 20 field.
<    *
<    * \param shortGuardInterval the short guard interval
<    */
<   void SetShortGuardInterval20 (uint8_t shortGuardInterval);
<   /**
<    * Set the short guard interval 40 field.
<    *
<    * \param shortGuardInterval the short guard interval
<    */
<   void SetShortGuardInterval40 (uint8_t shortGuardInterval);
<   /**
<    * Set the maximum AMSDU length.
<    *
<    * \param maxAmsduLength Either 3839 or 7935
<    */
<   void SetMaxAmsduLength (uint16_t maxAmsduLength);
<   /**
<    * Set the LSIG protection support.
<    *
<    * \param lSigProtection the LSIG protection support field
<    */
<   void SetLSigProtectionSupport (uint8_t lSigProtection);
---
>   void SetShortGuardInterval20 (uint8_t shortguardinterval);
>   void SetShortGuardInterval40 (uint8_t shortguardinterval);
>   void SetMaxAmsduLength (uint8_t maxamsdulength);
>   void SetLSigProtectionSupport (uint8_t lsigprotection);
147,152c98
<   /**
<    * Set the maximum AMPDU length.
<    *
<    * \param maxAmpduLength 2^(13 + x) - 1, x in the range 0 to 3
<    */
<   void SetMaxAmpduLength (uint32_t maxAmpduLength);
---
>   void SetMaxAmpduLength (uint8_t maxampdulength);
154,158d99
<   /**
<    * Set the receive MCS bitmask.
<    *
<    * \param index the index of the receive MCS
<    */
160,189c101,105
<   /**
<    * Set the receive highest supported data rate.
<    *
<    * \param maxSupportedRate the maximum supported data rate
<    */
<   void SetRxHighestSupportedDataRate (uint16_t maxSupportedRate);
<   /**
<    * Set the transmit MCS set defined.
<    *
<    * \param txMcsSetDefined the TX MCS set defined
<    */
<   void SetTxMcsSetDefined (uint8_t txMcsSetDefined);
<   /**
<    * Set the transmit / receive MCS set unequal.
<    *
<    * \param txRxMcsSetUnequal the TX/RX MCS set unequal field
<    */
<   void SetTxRxMcsSetUnequal (uint8_t txRxMcsSetUnequal);
<   /**
<    * Set the transmit maximum N spatial streams.
<    *
<    * \param maxTxSpatialStreams the maximum number of TX SSs
<    */
<   void SetTxMaxNSpatialStreams (uint8_t maxTxSpatialStreams);
<   /**
<    * Set the transmit unequal modulation.
<    *
<    * \param txUnequalModulation the TX unequal modulation field
<    */
<   void SetTxUnequalModulation (uint8_t txUnequalModulation);
---
>   void SetRxHighestSupportedDataRate (uint16_t maxsupportedrate);
>   void SetTxMcsSetDefined (uint8_t txmcssetdefined);
>   void SetTxRxMcsSetUnequal (uint8_t txrxmcssetunequal);
>   void SetTxMaxNSpatialStreams (uint8_t maxtxspatialstreams);
>   void SetTxUnequalModulation (uint8_t txunequalmodulation);
191,192c107,108
<   /**
<    * Return the HT Capabilities Info field in the HT Capabilities information element.
---
>   /*
>    * Return the HT Capabilties Info field in the HT Capabilities information element.
194c110
<    * \return the HT Capabilities Info field in the HT Capabilities information element
---
>    * \return the HT Capabilties Info field in the HT Capabilities information element
197c113
<   /**
---
>   /*
203c119
<   /**
---
>   /*
209c125
<   /**
---
>   /*
215,216c131,132
<   /**
<    * Return the Extended HT Capabilities field in the HT Capabilities information element.
---
>   /*
>    * Return the Extended HT Capabilties field in the HT Capabilities information element.
218c134
<    * \return the Extended HT Capabilities field in the HT Capabilities information element
---
>    * \return the Extended HT Capabilties field in the HT Capabilities information element
221,222c137,138
<   /**
<    * Return the Transmit Beamforming (TxBF) Capabilities field in the HT Capabilities information element.
---
>   /*
>    * Return the Transmit Beamforming (TxBF) Capabilties field in the HT Capabilities information element.
224c140
<    * \return the Transmit Beamforming (TxBF) Capabilities field in the HT Capabilities information element
---
>    * \return the Transmit Beamforming (TxBF) Capabilties field in the HT Capabilities information element
227,228c143,144
<   /**
<    * Return the Antenna Selection (ASEL) Capabilities field in the HT Capabilities information element.
---
>   /*
>    * Return the Antenna Selection (ASEL) Capabilties field in the HT Capabilities information element.
230c146
<    * \return the Antenna Selection (ASEL) Capabilities field in the HT Capabilities information element
---
>    * \return the Antenna Selection (ASEL) Capabilties field in the HT Capabilities information element
234,238d149
<   /**
<    * Return LDPC.
<    *
<    * \return the LDPC value
<    */
240,244d150
<   /**
<    * Return the supported channel width.
<    *
<    * \return the supported channel width
<    */
246,250d151
<   /**
<    * Return the Greenfield field.
<    *
<    * \return the Greenfield field
<    */
252,256d152
<   /**
<    * Return the short guard interval 20 value.
<    *
<    * \return the short guard interval 20 value
<    */
257a154,173
>   uint8_t GetShortGuardInterval40 (void) const;
>   uint8_t GetMaxAmsduLength (void) const;
>   uint8_t GetLSigProtectionSupport (void) const;
> 
>   uint8_t GetMaxAmpduLength (void) const;
> 
>   uint8_t* GetRxMcsBitmask ();
>   bool IsSupportedMcs (uint8_t mcs) const;
>   uint8_t GetRxHighestSupportedAntennas (void) const;
>   uint16_t GetRxHighestSupportedDataRate (void) const;
>   uint8_t GetTxMcsSetDefined (void) const;
>   uint8_t GetTxRxMcsSetUnequal (void) const;
>   uint8_t GetTxMaxNSpatialStreams (void) const;
>   uint8_t GetTxUnequalModulation (void) const;
> 
>   WifiInformationElementId ElementId () const;
>   uint8_t GetInformationFieldSize () const;
>   void SerializeInformationField (Buffer::Iterator start) const;
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
259,271c175,178
<    * Return the maximum A-MSDU length.
<    *
<    * \return the maximum A-MSDU length
<    */
<   uint16_t GetMaxAmsduLength (void) const;
<   /**
<    * Return the maximum A-MPDU length.
<    *
<    * \return the maximum A-MPDU length
<    */
<   uint32_t GetMaxAmpduLength (void) const;
<   /**
<    * Return the is MCS supported flag.
---
>    * This information element is a bit special in that it is only
>    * included if the STA is an HT STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
273c180
<    * \param mcs is MCS supported flag
---
>    * \param start
275c182
<    * \return true if successful
---
>    * \return an iterator
277c184
<   bool IsSupportedMcs (uint8_t mcs) const;
---
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
279c186,187
<    * Return the receive highest supported antennas.
---
>    * Return the serialized size of this HT capability
>    * information element.
281c189
<    * \return the receive highest supported antennas
---
>    * \return the serialized size of this HT capability information element
283c191
<   uint8_t GetRxHighestSupportedAntennas (void) const;
---
>   uint16_t GetSerializedSize () const;
287,301c195,209
<   //HT Capabilities Info field
<   uint8_t m_ldpc;                  ///< LDPC
<   uint8_t m_supportedChannelWidth; ///< supported channel width
<   uint8_t m_smPowerSave;           ///< SM power save
<   uint8_t m_greenField;            ///< Greenfield
<   uint8_t m_shortGuardInterval20;  ///< short guard interval 20 MHz
<   uint8_t m_shortGuardInterval40;  ///< short guard interval 40 MHz
<   uint8_t m_txStbc;                ///< transmit STBC
<   uint8_t m_rxStbc;                ///< receive STBC
<   uint8_t m_htDelayedBlockAck;     ///< HT delayed block ack
<   uint8_t m_maxAmsduLength;        ///< maximum A-MSDU length
<   uint8_t m_dssMode40;             ///< DSS mode 40
<   uint8_t m_psmpSupport;           ///< PSMP support
<   uint8_t m_fortyMhzIntolerant;    ///< 40 MHz intolerant
<   uint8_t m_lsigProtectionSupport; ///< L-SIG protection support
---
>   //HT Capabilties Info field
>   uint8_t m_ldpc;
>   uint8_t m_supportedChannelWidth;
>   uint8_t m_smPowerSave;
>   uint8_t m_greenField;
>   uint8_t m_shortGuardInterval20;
>   uint8_t m_shortGuardInterval40;
>   uint8_t m_txStbc;
>   uint8_t m_rxStbc;
>   uint8_t m_htDelayedBlockAck;
>   uint8_t m_maxAmsduLength;
>   uint8_t m_dssMode40;
>   uint8_t m_psmpSupport;
>   uint8_t m_fortyMhzIntolerant;
>   uint8_t m_lsigProtectionSupport;
304,306c212,214
<   uint8_t m_maxAmpduLengthExponent; ///< maximum A-MPDU length
<   uint8_t m_minMpduStartSpace;      ///< minimum MPDU start space
<   uint8_t m_ampduReserved;          ///< A-MPDU reserved
---
>   uint8_t m_maxAmpduLength;
>   uint8_t m_minMpduStartSpace;
>   uint8_t m_ampduReserved;
309,326c217,234
<   uint8_t m_reservedMcsSet1;                 ///< reserved MCS set 1
<   uint16_t m_rxHighestSupportedDataRate;     ///< receive highest supported data rate
<   uint8_t m_reservedMcsSet2;                 ///< reserved MCS set 2
<   uint8_t m_txMcsSetDefined;                 ///< transmit MCS set defined
<   uint8_t m_txRxMcsSetUnequal;               ///< transmit / receive MCS set unequal
<   uint8_t m_txMaxNSpatialStreams;            ///< transmit maximum number spatial streams
<   uint8_t m_txUnequalModulation;             ///< transmit unequal modulation
<   uint32_t m_reservedMcsSet3;                ///< reserved MCS set 3
<   uint8_t m_rxMcsBitmask[MAX_SUPPORTED_MCS]; ///< receive MCS bitmask
< 
<   //HT Extended Capabilities field
<   uint8_t m_pco;                           ///< PCO
<   uint8_t m_pcoTransitionTime;             ///< PCO transition time
<   uint8_t m_reservedExtendedCapabilities;  ///< reserved extended capabilities
<   uint8_t m_mcsFeedback;                   ///< MCS feedback
<   uint8_t m_htcSupport;                    ///< HTC support
<   uint8_t m_reverseDirectionResponder;     ///< reverse direction responder
<   uint8_t m_reservedExtendedCapabilities2; ///< reserver extended capabilities 2
---
>   uint8_t m_reservedMcsSet1;
>   uint16_t m_rxHighestSupportedDataRate;
>   uint8_t m_reservedMcsSet2;
>   uint8_t m_txMcsSetDefined;
>   uint8_t m_txRxMcsSetUnequal;
>   uint8_t m_txMaxNSpatialStreams;
>   uint8_t m_txUnequalModulation;
>   uint32_t m_reservedMcsSet3;
>   uint8_t m_rxMcsBitmask[MAX_SUPPORTED_MCS];
> 
>   //HT Extended Capabilties field
>   uint8_t m_pco;
>   uint8_t m_pcoTransitionTime;
>   uint8_t m_reservedExtendedCapabilities;
>   uint8_t m_mcsFeedback;
>   uint8_t m_htcSupport;
>   uint8_t m_reverzeDirectionResponder;
>   uint8_t m_reservedExtendedCapabilities2;
329,348c237,256
<   uint8_t m_implicitRxBfCapable;                       ///< implicit receive BF capable
<   uint8_t m_rxStaggeredSoundingCapable;                ///< receive staggered sounding capable
<   uint8_t m_txStaggeredSoundingCapable;                ///< transmit staggered sounding capable
<   uint8_t m_rxNdpCapable;                              ///< receive NDP capable
<   uint8_t m_txNdpCapable;                              ///< transmit NDP capable
<   uint8_t m_implicitTxBfCapable;                       ///< implicit transmit BF capable
<   uint8_t m_calibration;                               ///< calibration
<   uint8_t m_explicitCsiTxBfCapable;                    ///< explicit CSI transmit BF capable
<   uint8_t m_explicitNoncompressedSteeringCapable;      ///< explicit non compressed steeering capable
<   uint8_t m_explicitCompressedSteeringCapable;         ///< explicit compressed steeering capable
<   uint8_t m_explicitTxBfCsiFeedback;                   ///< explicit transmit BF CSI feedback
<   uint8_t m_explicitNoncompressedBfFeedbackCapable;    ///< explicit non compressed BF feedback capable
<   uint8_t m_explicitCompressedBfFeedbackCapable;       ///< explicit compressed BF feedback capable
<   uint8_t m_minimalGrouping;                           ///< minimal grouping
<   uint8_t m_csiNBfAntennasSupported;                   ///< CSI NBF antenna supported
<   uint8_t m_noncompressedSteeringNBfAntennasSupported; ///< non compressed steering NBF antenna supported
<   uint8_t m_compressedSteeringNBfAntennasSupported;    ///< compressed steering NBF antenna supported
<   uint8_t m_csiMaxNRowsBfSupported;                    ///< CSI maximum number rows BF supported
<   uint8_t m_channelEstimationCapability;               ///< channel estimation capability
<   uint8_t m_reservedTxBf;                              ///< reserved  transmit BF
---
>   uint8_t m_implicitRxBfCapable;
>   uint8_t m_rxStaggeredSoundingCapable;
>   uint8_t m_txStaggeredSoundingCapable;
>   uint8_t m_rxNdpCapable;
>   uint8_t m_txNdpCapable;
>   uint8_t m_implicitTxBfCapable;
>   uint8_t m_calibration;
>   uint8_t m_explicitCsiTxBfCapable;
>   uint8_t m_explicitNoncompressedSteeringCapable;
>   uint8_t m_explicitCompressedSteeringCapable;
>   uint8_t m_explicitTxBfCsiFeedback;
>   uint8_t m_explicitNoncompressedBfFeedbackCapable;
>   uint8_t m_explicitCompressedBfFeedbackCapable;
>   uint8_t m_minimalGrouping;
>   uint8_t m_csiNBfAntennasSupported;
>   uint8_t m_noncompressedSteeringNBfAntennasSupported;
>   uint8_t m_compressedSteeringNBfAntennasSupported;
>   uint8_t m_csiMaxNRowsBfSupported;
>   uint8_t m_channelEstimationCapability;
>   uint8_t m_reservedTxBf;
351,358c259,266
<   uint8_t m_antennaSelectionCapability;               ///< antenna selection capability
<   uint8_t m_explicitCsiFeedbackBasedTxASelCapable;    ///< explicit CSI feedback based transmit antenna selection capable
<   uint8_t m_antennaIndicesFeedbackBasedTxASelCapable; ///< antenna indices feedback based transmit antenna selection capable
<   uint8_t m_explicitCsiFeedbackCapable;               ///< explicit CSI feedback capable
<   uint8_t m_antennaIndicesFeedbackCapable;            ///< antenna indices feedback capable
<   uint8_t m_rxASelCapable;                            ///< receive antenna selection capable
<   uint8_t m_txSoundingPpdusCapable;                   ///< sounding PPDUS capable
<   uint8_t m_reservedASel;                             ///< reserved ASEL
---
>   uint8_t m_antennaSelectionCapability;
>   uint8_t m_explicitCsiFeedbackBasedTxASelCapable;
>   uint8_t m_antennaIndicesFeedbackBasedTxASelCapable;
>   uint8_t m_explicitCsiFeedbackCapable;
>   uint8_t m_antennaIndicesFeedbackCapable;
>   uint8_t m_rxASelCapable;
>   uint8_t m_txSoundingPpdusCapable;
>   uint8_t m_reservedASel;
360c268
<   /// This is used to decide whether this element should be added to the frame or not
---
>   //This is used to decide whether this element should be added to the frame or not
364,371d271
< /**
<  * output stream output operator
<  *
<  * \param os output stream
<  * \param htcapabilities the HT capabilities
<  *
<  * \returns output stream
<  */
372a273,275
> std::istream &operator >> (std::istream &is, HtCapabilities &htcapabilities);
> 
> ATTRIBUTE_HELPER_HEADER (HtCapabilities);
Only in ../../NS3-WiGig/src/wifi/model: ht-configuration.cc
Only in ../../NS3-WiGig/src/wifi/model: ht-configuration.h
Only in ../../NS3-WiGig/src/wifi/model: ht-operation.cc
Only in ../../NS3-WiGig/src/wifi/model: ht-operation.h
Only in ../../ns-3-dev/src/wifi/model: ht-operations.cc
Only in ../../ns-3-dev/src/wifi/model: ht-operations.h
Only in ../../NS3-WiGig/src/wifi/model: ideal-dmg-wifi-manager.cc
Only in ../../NS3-WiGig/src/wifi/model: ideal-dmg-wifi-manager.h
diff ../../NS3-WiGig/src/wifi/model/ideal-wifi-manager.cc ../../ns-3-dev/src/wifi/model/ideal-wifi-manager.cc
21,22d20
< #include <algorithm>
< #include "ns3/log.h"
25c23,26
< #include <algorithm>
---
> #include "ns3/assert.h"
> #include "ns3/double.h"
> #include "ns3/log.h"
> #include <cmath>
37,43c38,41
<   double m_lastSnrObserved;            //!< SNR of most recently reported packet sent to the remote station
<   uint16_t m_lastChannelWidthObserved; //!< Channel width (in MHz) of most recently reported packet sent to the remote station
<   uint16_t m_lastNssObserved;          //!<  Number of spatial streams of most recently reported packet sent to the remote station
<   double m_lastSnrCached;              //!< SNR most recently used to select a rate
<   uint8_t m_lastNss;                   //!< Number of spatial streams most recently used to the remote station
<   WifiMode m_lastMode;                 //!< Mode most recently used to the remote station
<   uint16_t m_lastChannelWidth;         //!< Channel width (in MHz) most recently used to the remote station
---
>   double m_lastSnrObserved;  //!< SNR of most recently reported packet sent to the remote station
>   double m_lastSnrCached;    //!< SNR most recently used to select a rate
>   double m_nss;          //!< SNR most recently used to select a rate
>   WifiMode m_lastMode;       //!< Mode most recently used to the remote station
46,48d43
< /// To avoid using the cache before a valid value has been cached
< static const double CACHE_INITIAL_VALUE = -100;
< 
74c69
<   : m_currentRate (0)
---
>  : m_currentRate (0)
76d70
<   NS_LOG_FUNCTION (this);
81d74
<   NS_LOG_FUNCTION (this);
85c78
< IdealWifiManager::SetupPhy (const Ptr<WifiPhy> phy)
---
> IdealWifiManager::SetupPhy (Ptr<WifiPhy> phy)
91,92c84,85
< uint16_t
< IdealWifiManager::GetChannelWidthForNonHtMode (WifiMode mode) const
---
> uint32_t
> IdealWifiManager::GetChannelWidthForMode (WifiMode mode) const
94,98c87,90
<   NS_ASSERT (mode.GetModulationClass () != WIFI_MOD_CLASS_HT
<              && mode.GetModulationClass () != WIFI_MOD_CLASS_VHT
<              && mode.GetModulationClass () != WIFI_MOD_CLASS_HE);
<   if (mode.GetModulationClass () == WIFI_MOD_CLASS_DSSS
<       || mode.GetModulationClass () == WIFI_MOD_CLASS_HR_DSSS)
---
>   NS_ASSERT (mode.GetModulationClass () != WIFI_MOD_CLASS_HT);
>   NS_ASSERT (mode.GetModulationClass () != WIFI_MOD_CLASS_VHT);
>   if (mode.GetModulationClass () == WIFI_MOD_CLASS_DSSS || 
>       mode.GetModulationClass () == WIFI_MOD_CLASS_HR_DSSS)
102c94
<   else
---
>   else 
112,118d103
<   BuildSnrThresholds ();
< }
< 
< void
< IdealWifiManager::BuildSnrThresholds (void)
< {
<   m_thresholds.clear ();
122,123c107,109
<   uint8_t nModes = GetPhy ()->GetNModes ();
<   for (uint8_t i = 0; i < nModes; i++)
---
>   uint32_t nModes = GetPhy ()->GetNModes ();
>   txVector.SetShortGuardInterval (GetPhy ()->GetGuardInterval ());
>   for (uint32_t i = 0; i < nModes; i++)
126c112
<       txVector.SetChannelWidth (GetChannelWidthForNonHtMode (mode));
---
>       txVector.SetChannelWidth (GetChannelWidthForMode (mode)); 
129c115,118
<       NS_LOG_DEBUG ("Adding mode = " << mode.GetUniqueName ());
---
>       NS_LOG_DEBUG ("Initialize, adding mode = " << mode.GetUniqueName () <<
>                     " channel width " << txVector.GetChannelWidth () << 
>                     " nss " << (uint16_t) nss << 
>                     " short GI " << GetPhy ()->GetGuardInterval ());
132,133c121,123
<   // Add all MCSes
<   if (GetHtSupported ())
---
>   // Add all Ht and Vht MCSes 
>   txVector.SetChannelWidth (GetPhy ()->GetChannelWidth ());
>   if (HasVhtSupported () == true || HasHtSupported () == true )
136c126
<       for (uint8_t i = 0; i < nModes; i++)
---
>       for (uint32_t i = 0; i < nModes; i++)
138c128,129
<           for (uint16_t j = 20; j <= GetPhy ()->GetChannelWidth (); j *= 2)
---
>           mode = GetPhy ()->GetMcs (i);
>           if (mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
140,185c131,136
<               txVector.SetChannelWidth (j);
<               mode = GetPhy ()->GetMcs (i);
<               if (mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
<                 {
<                   uint16_t guardInterval = GetShortGuardIntervalSupported () ? 400 : 800;
<                   txVector.SetGuardInterval (guardInterval);
<                   //derive NSS from the MCS index
<                   nss = (mode.GetMcsValue () / 8) + 1;
<                   NS_LOG_DEBUG ("Adding mode = " << mode.GetUniqueName () <<
<                                 " channel width " << j <<
<                                 " nss " << +nss <<
<                                 " GI " << guardInterval);
<                   txVector.SetNss (nss);
<                   txVector.SetMode (mode);
<                   AddSnrThreshold (txVector, GetPhy ()->CalculateSnr (txVector, m_ber));
<                 }
<               else //VHT or HE
<                 {
<                   uint16_t guardInterval;
<                   if (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
<                     {
<                       guardInterval = GetShortGuardIntervalSupported () ? 400 : 800;
<                     }
<                   else
<                     {
<                       guardInterval = GetGuardInterval ();
<                     }
<                   txVector.SetGuardInterval (guardInterval);
<                   for (uint8_t k = 1; k <= GetPhy ()->GetMaxSupportedTxSpatialStreams (); k++)
<                     {
<                       if (mode.IsAllowed (j, k))
<                         {
<                           NS_LOG_DEBUG ("Adding mode = " << mode.GetUniqueName () <<
<                                         " channel width " << j <<
<                                         " nss " << +k <<
<                                         " GI " << guardInterval);
<                           txVector.SetNss (k);
<                           txVector.SetMode (mode);
<                           AddSnrThreshold (txVector, GetPhy ()->CalculateSnr (txVector, m_ber));
<                         }
<                       else
<                         {
<                           NS_LOG_DEBUG ("Mode = " << mode.GetUniqueName () << " disallowed");
<                         }
<                     }
<                 }
---
>               //derive NSS from the Mcs index
>               nss = (mode.GetMcsValue () / 8) + 1;
>             }
>           else
>             {
>               nss = GetPhy ()->GetSupportedTxSpatialStreams ();
186a138,145
>           NS_LOG_DEBUG ("Initialize, adding mode = " << mode.GetUniqueName () <<
>                         " channel width " << GetPhy ()->GetChannelWidth () <<
>                         " nss " << (uint16_t) nss << 
>                         " short GI " << GetPhy ()->GetGuardInterval ());
>           NS_LOG_DEBUG ("In SetupPhy, adding mode = " << mode.GetUniqueName ());
>           txVector.SetNss (nss);
>           txVector.SetMode (mode);
>           AddSnrThreshold (txVector, GetPhy ()->CalculateSnr (txVector, m_ber));
192c151
< IdealWifiManager::GetSnrThreshold (WifiTxVector txVector)
---
> IdealWifiManager::GetSnrThreshold (WifiTxVector txVector) const
194,211c153,171
<   NS_LOG_FUNCTION (this << txVector);
<   auto it = std::find_if (m_thresholds.begin (), m_thresholds.end (),
<       [&txVector] (const std::pair<double, WifiTxVector>& p) -> bool {
<           return ((txVector.GetMode () == p.second.GetMode ()) && (txVector.GetNss () == p.second.GetNss ()) && (txVector.GetChannelWidth () == p.second.GetChannelWidth ()));
<       }
<   );
<   if (it == m_thresholds.end ())
<     {
<       //This means capabilities have changed in runtime, hence rebuild SNR thresholds
<       BuildSnrThresholds ();
<       it = std::find_if (m_thresholds.begin (), m_thresholds.end (),
<           [&txVector] (const std::pair<double, WifiTxVector>& p) -> bool {
<               return ((txVector.GetMode () == p.second.GetMode ()) && (txVector.GetNss () == p.second.GetNss ()) && (txVector.GetChannelWidth () == p.second.GetChannelWidth ()));
<           }
<       );
<       NS_ASSERT_MSG (it != m_thresholds.end (), "SNR threshold not found");
<   }
<   return it->first;
---
>   NS_LOG_FUNCTION (this << txVector.GetMode().GetUniqueName ());
>   for (Thresholds::const_iterator i = m_thresholds.begin (); i != m_thresholds.end (); i++)
>     {
>       NS_LOG_DEBUG ("Checking " << i->second.GetMode ().GetUniqueName () <<
>                     " nss " << (uint16_t) i->second.GetNss () <<
>                     " width " << i->second.GetChannelWidth ());
>       NS_LOG_DEBUG ("against TxVector " << txVector.GetMode ().GetUniqueName () <<
>                     " nss " << (uint16_t) txVector.GetNss () <<
>                     " width " << txVector.GetChannelWidth ());
>       if (txVector.GetMode () == i->second.GetMode () &&
>           txVector.GetNss () == i->second.GetNss () &&
>           txVector.IsShortGuardInterval () == i->second.IsShortGuardInterval () &&
>           txVector.GetChannelWidth () == i->second.GetChannelWidth ())
>         {
>           return i->first;
>         }
>     }
>   NS_ASSERT (false);
>   return 0.0;
217c177
<   NS_LOG_FUNCTION (this << txVector.GetMode ().GetUniqueName () << txVector.GetChannelWidth () << snr);
---
>   NS_LOG_FUNCTION (this << txVector.GetMode ().GetUniqueName () << snr);
226c186,189
<   Reset (station);
---
>   station->m_lastSnrObserved = 0.0;
>   station->m_lastSnrCached = 0.0;
>   station->m_lastMode = GetDefaultMode ();
>   station->m_nss = 1;
230,242d192
< void
< IdealWifiManager::Reset (WifiRemoteStation *station) const
< {
<   NS_LOG_FUNCTION (this << station);
<   IdealWifiRemoteStation *st = static_cast<IdealWifiRemoteStation*> (station);
<   st->m_lastSnrObserved = 0.0;
<   st->m_lastChannelWidthObserved = 0;
<   st->m_lastNssObserved = 1;
<   st->m_lastSnrCached = CACHE_INITIAL_VALUE;
<   st->m_lastMode = GetDefaultMode ();
<   st->m_lastChannelWidth = 0;
<   st->m_lastNss = 1;
< }
245c195,196
< IdealWifiManager::DoReportRxOk (WifiRemoteStation *station, double rxSnr, WifiMode txMode)
---
> IdealWifiManager::DoReportRxOk (WifiRemoteStation *station,
>                                 double rxSnr, WifiMode txMode)
247d197
<   NS_LOG_FUNCTION (this << station << rxSnr << txMode);
253d202
<   NS_LOG_FUNCTION (this << station);
259d207
<   NS_LOG_FUNCTION (this << station);
267c215
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
269,270d216
<   station->m_lastChannelWidthObserved = GetPhy ()->GetChannelWidth () >= 40 ? 20 : GetPhy ()->GetChannelWidth ();
<   station->m_lastNssObserved = 1;
274,275c220,221
< IdealWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                   double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> IdealWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                   double ackSnr, WifiMode ackMode, double dataSnr)
277,278c223,224
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode.GetUniqueName () << dataSnr << dataChannelWidth << +dataNss);
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode.GetUniqueName () << dataSnr);
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
285,286d230
<   station->m_lastChannelWidthObserved = dataChannelWidth;
<   station->m_lastNssObserved = dataNss;
289,291c233,234
< void
< IdealWifiManager::DoReportAmpduTxStatus (WifiRemoteStation *st, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                                          double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> void 
> IdealWifiManager::DoReportAmpduTxStatus (WifiRemoteStation *st, uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus, double rxSnr, double dataSnr)
293,294c236,237
<   NS_LOG_FUNCTION (this << st << +nSuccessfulMpdus << +nFailedMpdus << rxSnr << dataSnr << dataChannelWidth << +dataNss);
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << nSuccessfulMpdus << nFailedMpdus << rxSnr << dataSnr);
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
301,302d243
<   station->m_lastChannelWidthObserved = dataChannelWidth;
<   station->m_lastNssObserved = dataNss;
304a246
> 
308,309d249
<   NS_LOG_FUNCTION (this << station);
<   Reset (station);
315,316d254
<   NS_LOG_FUNCTION (this << station);
<   Reset (station);
323c261
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
325c263
<   //highest data rate for which the SNR threshold is smaller than m_lastSnr
---
>   //highest snr threshold possible which is smaller than m_lastSnr
326a265
>   double maxThreshold = 0.0;
327a267
>   std::vector<WifiTxVector> candidateTxVectors;
330,339c270,278
<   uint64_t bestRate = 0;
<   uint8_t selectedNss = 1;
<   uint16_t guardInterval;
<   uint16_t channelWidth = std::min (GetChannelWidth (station), GetPhy ()->GetChannelWidth ());
<   txVector.SetChannelWidth (channelWidth);
<   if ((station->m_lastSnrCached != CACHE_INITIAL_VALUE) && (station->m_lastSnrObserved == station->m_lastSnrCached) && (channelWidth == station->m_lastChannelWidth))
<     {
<       // SNR has not changed, so skip the search and use the last mode selected
<       maxMode = station->m_lastMode;
<       selectedNss = station->m_lastNss;
---
>   uint8_t nss = 1;
>   txVector.SetChannelWidth (GetPhy ()->GetChannelWidth ());
>   txVector.SetShortGuardInterval (GetPhy ()->GetGuardInterval ());
>   if (station->m_lastSnrObserved == station->m_lastSnrCached)
>     {
>       // SNR has not changed, so skip the search and use the last
>       // mode selected
>       maxMode = station->m_lastMode;      
>       nss = station->m_nss;
342,344c281
<                     " cached " << station->m_lastSnrCached <<
<                     " channel width " << station->m_lastChannelWidth <<
<                     " nss " << +selectedNss);
---
>                     " cached " << station->m_lastSnrCached);
348c285
<       if (GetHtSupported () && GetHtSupported (st))
---
>       if (HasVhtSupported () == true || HasHtSupported () == true)
350c287
<           for (uint8_t i = 0; i < GetNMcsSupported (station); i++)
---
>           for (uint32_t i = 0; i < GetNMcsSupported (station); i++)
356,397c293,294
<                   guardInterval = static_cast<uint16_t> (std::max (GetShortGuardIntervalSupported (station) ? 400 : 800, GetShortGuardIntervalSupported () ? 400 : 800));
<                   txVector.SetGuardInterval (guardInterval);
<                   // If the node and peer are both VHT capable, only search VHT modes
<                   if (GetVhtSupported () && GetVhtSupported (station))
<                     {
<                       continue;
<                     }
<                   // If the node and peer are both HE capable, only search HE modes
<                   if (GetHeSupported () && GetHeSupported (station))
<                     {
<                       continue;
<                     }
<                   // Derive NSS from the MCS index. There is a different mode for each possible NSS value.
<                   uint8_t nss = (mode.GetMcsValue () / 8) + 1;
<                   txVector.SetNss (nss);
<                   if (!txVector.IsValid ()
<                       || nss > std::min (GetMaxNumberOfTransmitStreams (), GetNumberOfSupportedStreams (st)))
<                     {
<                       NS_LOG_DEBUG ("Skipping mode " << mode.GetUniqueName () <<
<                                     " nss " << +nss <<
<                                     " width " << txVector.GetChannelWidth ());
<                       continue;
<                     }
<                   double threshold = GetSnrThreshold (txVector);
<                   uint64_t dataRate = mode.GetDataRate (txVector.GetChannelWidth (), txVector.GetGuardInterval (), nss);
<                   NS_LOG_DEBUG ("Testing mode " << mode.GetUniqueName () <<
<                                 " data rate " << dataRate <<
<                                 " threshold " << threshold  << " last snr observed " <<
<                                 station->m_lastSnrObserved << " cached " <<
<                                 station->m_lastSnrCached);
<                   double snr = GetLastObservedSnr (station, channelWidth, nss);
<                   if (dataRate > bestRate && threshold < snr)
<                     {
<                       NS_LOG_DEBUG ("Candidate mode = " << mode.GetUniqueName () <<
<                                     " data rate " << dataRate <<
<                                     " threshold " << threshold  <<
<                                     " channel width " << channelWidth <<
<                                     " snr " << snr);
<                       bestRate = dataRate;
<                       maxMode = mode;
<                       selectedNss = nss;
<                     }
---
>                   //derive NSS from the Mcs index
>                   nss = (mode.GetMcsValue () / 8) + 1;
399c296
<               else if (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
---
>               else
401,441c298
<                   guardInterval = static_cast<uint16_t> (std::max (GetShortGuardIntervalSupported (station) ? 400 : 800, GetShortGuardIntervalSupported () ? 400 : 800));
<                   txVector.SetGuardInterval (guardInterval);
<                   // If the node and peer are both HE capable, only search HE modes
<                   if (GetHeSupported () && GetHeSupported (station))
<                     {
<                       continue;
<                     }
<                   // If the node and peer are not both VHT capable, only search HT modes
<                   if (!GetVhtSupported () || !GetVhtSupported (station))
<                     {
<                       continue;
<                     }
<                   for (uint8_t nss = 1; nss <= std::min (GetMaxNumberOfTransmitStreams (), GetNumberOfSupportedStreams (station)); nss++)
<                     {
<                       txVector.SetNss (nss);
<                       if (!txVector.IsValid ())
<                         {
<                           NS_LOG_DEBUG ("Skipping mode " << mode.GetUniqueName () <<
<                                         " nss " << +nss <<
<                                         " width " << txVector.GetChannelWidth ());
<                           continue;
<                         }
<                       double threshold = GetSnrThreshold (txVector);
<                       uint64_t dataRate = mode.GetDataRate (txVector.GetChannelWidth (), txVector.GetGuardInterval (), nss);
<                       NS_LOG_DEBUG ("Testing mode = " << mode.GetUniqueName () <<
<                                     " data rate " << dataRate <<
<                                     " threshold " << threshold << " last snr observed " <<
<                                     station->m_lastSnrObserved << " cached " <<
<                                     station->m_lastSnrCached);
<                       double snr = GetLastObservedSnr (station, channelWidth, nss);
<                       if (dataRate > bestRate && threshold < snr)
<                         {
<                           NS_LOG_DEBUG ("Candidate mode = " << mode.GetUniqueName () <<
<                                         " data rate " << dataRate <<
<                                         " channel width " << channelWidth <<
<                                         " snr " << snr);
<                           bestRate = dataRate;
<                           maxMode = mode;
<                           selectedNss = nss;
<                         }
<                     }
---
>                   nss = GetPhy ()->GetSupportedTxSpatialStreams ();
443c300,324
<               else //HE
---
>               txVector.SetNss (nss);
>               if (WifiPhy::IsValidTxVector (txVector) == false)
>                  {
>                    NS_LOG_DEBUG ("Skipping mode " << mode.GetUniqueName () <<
>                                  " nss " << nss << " width " << 
>                                  txVector.GetChannelWidth());
>                    continue;       
>                  }
>               double threshold = GetSnrThreshold (txVector);
>               // If the node and peer are both VHT capable, only search VHT modes 
>               if (mode.GetModulationClass () == WIFI_MOD_CLASS_HT && HasVhtSupported () && GetVhtSupported (st))
>                 { 
>                   continue;
>                 }
>               // If the node and peer are not both VHT capable, only search HT modes 
>               if (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT && (!HasVhtSupported () || !GetVhtSupported (st)))
>                 { 
>                   continue;
>                 }
>               NS_LOG_DEBUG ("Testing mode = " << mode.GetUniqueName () <<
>                             " threshold " << threshold  << " maxThreshold " <<
>                             maxThreshold << " last snr observed " <<
>                             station->m_lastSnrObserved << " cached " <<
>                             station->m_lastSnrCached);
>               if (threshold > maxThreshold && threshold < station->m_lastSnrObserved)
445,481c326,331
<                   guardInterval = std::max (GetGuardInterval (station), GetGuardInterval ());
<                   txVector.SetGuardInterval (guardInterval);
<                   // If the node and peer are not both HE capable, only search (V)HT modes
<                   if (!GetHeSupported () || !GetHeSupported (station))
<                     {
<                       continue;
<                     }
<                   for (uint8_t nss = 1; nss <= std::min (GetMaxNumberOfTransmitStreams (), GetNumberOfSupportedStreams (station)); nss++)
<                     {
<                       txVector.SetNss (nss);
<                       if (!txVector.IsValid ())
<                         {
<                           NS_LOG_DEBUG ("Skipping mode " << mode.GetUniqueName () <<
<                                         " nss " << +nss <<
<                                         " width " << +txVector.GetChannelWidth ());
<                           continue;
<                         }
<                       double threshold = GetSnrThreshold (txVector);
<                       uint64_t dataRate = mode.GetDataRate (txVector.GetChannelWidth (), txVector.GetGuardInterval (), nss);
<                       NS_LOG_DEBUG ("Testing mode = " << mode.GetUniqueName () <<
<                                     " data rate " << dataRate <<
<                                     " threshold " << threshold  << " last snr observed " <<
<                                     station->m_lastSnrObserved << " cached " <<
<                                     station->m_lastSnrCached);
<                       double snr = GetLastObservedSnr (station, channelWidth, nss);
<                       if (dataRate > bestRate && threshold < snr)
<                         {
<                           NS_LOG_DEBUG ("Candidate mode = " << mode.GetUniqueName () <<
<                                         " data rate " << dataRate <<
<                                         " threshold " << threshold  <<
<                                         " channel width " << channelWidth <<
<                                         " snr " << snr);
<                           bestRate = dataRate;
<                           maxMode = mode;
<                           selectedNss = nss;
<                         }
<                     }
---
>                   NS_LOG_DEBUG ("Candidate mode = " << mode.GetUniqueName () <<
>                                 " threshold " << threshold  <<
>                                 " last snr observed " <<
>                                 station->m_lastSnrObserved);
>                   maxThreshold = threshold;
>                   maxMode = mode;
485c335
<       else
---
>       else 
488,489c338,339
<           selectedNss = 1;
<           for (uint8_t i = 0; i < GetNSupported (station); i++)
---
>           nss = 1;
>           for (uint32_t i = 0; i < GetNSupported (station); i++)
493,495c343,344
<               txVector.SetNss (selectedNss);
<               uint16_t channelWidth = GetChannelWidthForNonHtMode (mode);
<               txVector.SetChannelWidth (channelWidth);
---
>               txVector.SetNss (nss);
>               txVector.SetChannelWidth (GetChannelWidthForMode (mode));
497d345
<               uint64_t dataRate = mode.GetDataRate (txVector.GetChannelWidth (), txVector.GetGuardInterval (), txVector.GetNss ());
502,503c350
<               double snr = GetLastObservedSnr (station, channelWidth, 1);
<               if (dataRate > bestRate && threshold < snr)
---
>               if (threshold > maxThreshold && threshold < station->m_lastSnrObserved)
506d352
<                                 " data rate " << dataRate <<
508,509c354,356
<                                 " snr " << snr);
<                   bestRate = dataRate;
---
>                                 " last snr observed " <<
>                                 station->m_lastSnrObserved);
>                   maxThreshold = threshold;
517c364
<       station->m_lastNss = selectedNss;
---
>       station->m_nss = nss;
519,521c366,368
<   NS_LOG_DEBUG ("Found maxMode: " << maxMode << " channelWidth: " << channelWidth << " nss: " << +selectedNss);
<   station->m_lastChannelWidth = channelWidth;
<   if (maxMode.GetModulationClass () == WIFI_MOD_CLASS_HE)
---
>   uint32_t channelWidth = GetChannelWidth (station);
>   NS_LOG_DEBUG ("Found maxMode: " << maxMode << " channelWidth: " << channelWidth);
>   if (m_currentRate != maxMode.GetDataRate (channelWidth, GetPhy ()->GetGuardInterval (), nss))
523c370,371
<       guardInterval = std::max (GetGuardInterval (station), GetGuardInterval ());
---
>       NS_LOG_DEBUG ("New datarate: " << maxMode.GetDataRate (channelWidth, GetPhy ()->GetGuardInterval (), nss));
>       m_currentRate = maxMode.GetDataRate (channelWidth, GetPhy ()->GetGuardInterval (), nss);
525,538c373
<   else if ((maxMode.GetModulationClass () == WIFI_MOD_CLASS_HT) || (maxMode.GetModulationClass () == WIFI_MOD_CLASS_VHT))
<     {
<       guardInterval = static_cast<uint16_t> (std::max (GetShortGuardIntervalSupported (station) ? 400 : 800, GetShortGuardIntervalSupported () ? 400 : 800));
<     }
<   else
<     {
<       guardInterval = 800;
<     }
<   if (m_currentRate != maxMode.GetDataRate (channelWidth, guardInterval, selectedNss))
<     {
<       NS_LOG_DEBUG ("New datarate: " << maxMode.GetDataRate (channelWidth, guardInterval, selectedNss));
<       m_currentRate = maxMode.GetDataRate (channelWidth, guardInterval, selectedNss);
<     }
<   return WifiTxVector (maxMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (maxMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), guardInterval, GetNumberOfAntennas (), selectedNss, 0, GetChannelWidthForTransmission (maxMode, channelWidth), GetAggregation (station), false);
---
>   return WifiTxVector (maxMode, GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, nss, 0, channelWidth, GetAggregation (station), false);
545c380
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
547c382
<   //SNR threshold possible which is smaller than m_lastSnr to
---
>   //snr threshold possible which is smaller than m_lastSnr to
554,555c389,392
<   //RTS is sent in a non-HT frame
<   for (uint8_t i = 0; i < GetNBasicModes (); i++)
---
>   //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
>   // RTS is sent in a non-HT frame; RTS with (V)HT is not yet supported
>   txVector.SetShortGuardInterval (GetPhy ()->GetGuardInterval ());
>   for (uint32_t i = 0; i < GetNBasicModes (); i++)
560c397
<       txVector.SetChannelWidth (GetChannelWidthForNonHtMode (mode));
---
>       txVector.SetChannelWidth (GetChannelWidthForMode (mode));
568c405
<   return WifiTxVector (maxMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (maxMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, GetNumberOfAntennas (), nss, 0, GetChannelWidthForNonHtMode (maxMode), GetAggregation (station), false);
---
>   return WifiTxVector (maxMode, GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, nss, 0, GetChannelWidthForMode (maxMode), GetAggregation (station), false);
571,572c408,409
< double
< IdealWifiManager::GetLastObservedSnr (IdealWifiRemoteStation *station, uint16_t channelWidth, uint8_t nss) const
---
> bool
> IdealWifiManager::IsLowLatency (void) const
574,589c411
<   double snr = station->m_lastSnrObserved;
<   if (channelWidth != station->m_lastChannelWidthObserved)
<     {
<       snr /= (static_cast<double> (channelWidth) / station->m_lastChannelWidthObserved);
<     }
<   if (nss != station->m_lastNssObserved)
<     {
<       snr /= (static_cast<double> (nss) / station->m_lastNssObserved);
<     }
<   NS_LOG_DEBUG ("Last observed SNR is " << station->m_lastSnrObserved <<
<                 " for channel width " << station->m_lastChannelWidthObserved <<
<                 " and nss " << +station->m_lastNssObserved <<
<                 "; computed SNR is " << snr <<
<                 " for channel width " << channelWidth <<
<                 " and nss " << +nss);
<   return snr;
---
>   return true;
diff ../../NS3-WiGig/src/wifi/model/ideal-wifi-manager.h ../../ns-3-dev/src/wifi/model/ideal-wifi-manager.h
23a24,25
> #include <stdint.h>
> #include <vector>
24a27
> #include "wifi-mode.h"
29,30d31
< struct IdealWifiRemoteStation;
< 
39c40
<  * SNR of every packet received and sends back this SNR to the
---
>  * snr of every packet received and sends back this snr to the
41c42
<  * transmitter keeps track of the last SNR sent back by a receiver
---
>  * transmitter keeps track of the last snr sent back by a receiver
43,44c44,45
<  * of SNR thresholds built from a target BER and transmission
<  * mode-specific SNR/BER curves.
---
>  * of snr thresholds built from a target ber and transmission
>  * mode-specific snr/ber curves.
49,52d49
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
57c54
<   void SetupPhy (const Ptr<WifiPhy> phy);
---
>   virtual void SetupPhy (Ptr<WifiPhy> phy);
61,89c58,74
<   //overridden from base class
<   void DoInitialize (void);
<   WifiRemoteStation* DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                               double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
< 
<   /**
<    * Reset the station, invoked if the maximum amount of retries has failed.
<    */
<   void Reset (WifiRemoteStation *station) const;
< 
<   /**
<    * Construct the vector of minimum SNRs needed to successfully transmit for
<    * all possible combinations (rate, channel width, nss) based on PHY capabilities.
<    * This is called at initialization and if PHY capabilities changed.
<    */
<   void BuildSnrThresholds (void);
---
>   //overriden from base class
>   virtual void DoInitialize (void);
>   virtual WifiRemoteStation* DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportAmpduTxStatus (WifiRemoteStation *station, uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus, double rxSnr, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool IsLowLatency (void) const;
95c80
<    * \param txVector WifiTxVector (containing valid mode, width, and Nss)
---
>    * \param txVector WifiTxVector (containing valid mode, width, and nss)
97c82
<    * \return the minimum SNR for the given WifiTxVector in linear scale
---
>    * \return the minimum SNR for the given WifiTxVector
99c84
<   double GetSnrThreshold (WifiTxVector txVector);
---
>   double GetSnrThreshold (WifiTxVector txVector) const;
104,105c89,90
<    * \param txVector the WifiTxVector storing mode, channel width, and Nss
<    * \param snr the minimum SNR for the given txVector in linear scale
---
>    * \param txVector the WifiTxVector storing mode, channel width, and nss
>    * \param snr the minimum SNR for the given txVector
110,111c95,96
<    * Convenience function for selecting a channel width for non-HT mode
<    * \param mode non-HT WifiMode
---
>    * Convenience function for selecting a channel width for legacy mode
>    * \param non-(V)HT WifiMode
114,126c99
<   uint16_t GetChannelWidthForNonHtMode (WifiMode mode) const;
< 
<   /**
<    * Convenience function to get the last observed SNR from a given station for a given channel width and a given NSS.
<    * Since the previously received SNR information might be related to a different channel width than the requested one,
<    * and/or a different NSS,  the function does some computations to get the corresponding SNR.
<    *
<    * \param station the station being queried
<    * \param channelWidth the channel width (in MHz)
<    * \param nss the number of spatial streams
<    * \return the SNR in linear scale
<    */
<   double GetLastObservedSnr (IdealWifiRemoteStation *station, uint16_t channelWidth, uint8_t nss) const;
---
>   uint32_t GetChannelWidthForMode (WifiMode mode) const;
129c102
<    * A vector of <snr, WifiTxVector> pair holding the minimum SNR for the
---
>    * A vector of <snr, WifiTxVector> pair holding the minimum SNR for the 
Only in ../../NS3-WiGig/src/wifi/model: infrastructure-wifi-mac.cc
Only in ../../NS3-WiGig/src/wifi/model: infrastructure-wifi-mac.h
diff ../../NS3-WiGig/src/wifi/model/interference-helper.cc ../../ns-3-dev/src/wifi/model/interference-helper.cc
22,24d21
< #include "ns3/simulator.h"
< #include "ns3/log.h"
< #include "ns3/packet.h"
28,30c25,26
< #include "wifi-utils.h"
< #include "wifi-ppdu.h"
< #include "wifi-psdu.h"
---
> #include "ns3/simulator.h"
> #include "ns3/log.h"
33d28
< 
39c34
<  *       PHY event class
---
>  *       Phy event class
42,51c37,40
< Event::Event (WifiTxVector txVector, Time duration, double rxPower)
<   : m_txVector (txVector),
<     m_startTime (Simulator::Now ()),
<     m_endTime (m_startTime + duration),
<     m_rxPowerW (rxPower)
< {
< }
< 
< Event::Event (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower)
<   : m_ppdu (ppdu),
---
> InterferenceHelper::Event::Event (uint32_t size, WifiTxVector txVector,
>                                   enum WifiPreamble preamble,
>                                   Time duration, double rxPower)
>   : m_size (size),
52a42
>     m_preamble (preamble),
59,69c49
< Event::Event (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower, std::vector<double> mimoRxPower)
<   : m_ppdu (ppdu),
<     m_txVector (txVector),
<     m_startTime (Simulator::Now ()),
<     m_endTime (m_startTime + duration),
<     m_rxPowerW (rxPower),
<     m_mimoRxPowerW (mimoRxPower)
< {
< }
< 
< Event::~Event ()
---
> InterferenceHelper::Event::~Event ()
73,80c53,54
< Ptr<const WifiPsdu>
< Event::GetPsdu (void) const
< {
<   return m_ppdu->GetPsdu ();
< }
< 
< Ptr<const WifiPpdu>
< Event::GetPpdu (void) const
---
> Time
> InterferenceHelper::Event::GetDuration (void) const
82c56
<   return m_ppdu;
---
>   return m_endTime - m_startTime;
86c60
< Event::GetStartTime (void) const
---
> InterferenceHelper::Event::GetStartTime (void) const
92c66
< Event::GetEndTime (void) const
---
> InterferenceHelper::Event::GetEndTime (void) const
97,98c71,72
< Time
< Event::GetDuration (void) const
---
> double
> InterferenceHelper::Event::GetRxPowerW (void) const
100c74
<   return m_endTime - m_startTime;
---
>   return m_rxPowerW;
103,104c77,78
< double
< Event::GetRxPowerW (void) const
---
> uint32_t
> InterferenceHelper::Event::GetSize (void) const
106c80
<   return m_rxPowerW;
---
>   return m_size;
110c84
< Event::GetTxVector (void) const
---
> InterferenceHelper::Event::GetTxVector (void) const
116c90
< Event::GetPayloadMode (void) const
---
> InterferenceHelper::Event::GetPayloadMode (void) const
121,122c95,96
< std::vector<double>
< Event::GetMimoRxPowerW (void) const
---
> enum WifiPreamble
> InterferenceHelper::Event::GetPreambleType (void) const
124c98
<   return m_mimoRxPowerW;
---
>   return m_preamble;
127,193d100
< std::vector<double>
< Event::GetMimoInterStreamInterference (void) const
< {
<   uint8_t numTxAntennas = m_txVector.GetNumberOfTxChains ();
<   uint8_t numRxAntennas = m_mimoRxPowerW.size ()/numTxAntennas;
<   double interference;
<   std::vector<double> interferenceList;
<   uint8_t index = 0;
<   for (uint8_t tx = 0; tx < numTxAntennas; tx++)
<     {
<       for (uint8_t rx = 0; rx < numRxAntennas; rx++)
<         {
<           interference = 0;
<           for (uint8_t txInterferer = 0; txInterferer < numTxAntennas; txInterferer++)
<             {
<               if (txInterferer != tx)
<                 {
<                   interference += m_mimoRxPowerW.at (rx + txInterferer * numRxAntennas);
<                 }
<             }
<           index++;
<           interferenceList.push_back (interference);
<         }
<     }
<   return interferenceList;
< }
< 
< std::vector<uint8_t>
< Event::GetMimoRxSignalLocation (void) const
< {
<   uint8_t numTxAntennas = m_txVector.GetNumberOfTxChains ();
<   uint8_t numRxAntennas = m_mimoRxPowerW.size ()/numTxAntennas;
<   std::vector<uint8_t> rxLocationList;
<   for (uint8_t rx = 0; rx < numRxAntennas; rx++)
<     {
<       double maxRxPower = m_mimoRxPowerW.at (rx);
<       uint8_t maxTxIdx = 0;
<       for (uint8_t tx = 0; tx < numTxAntennas; tx++)
<         {
<           /* Find the Tx signal at each Rx antenna that is received with the maximum Rx power under the constraint
<            * that it has already not been received by a previous antenna */
<           if ((std::find (rxLocationList.begin (), rxLocationList.end (), tx) == rxLocationList.end ())
<               && (m_mimoRxPowerW.at (rx + tx * numRxAntennas) > maxRxPower))
<             {
<               maxRxPower = m_mimoRxPowerW.at (rx + tx * numRxAntennas);
<               maxTxIdx = tx;
<             }
<         }
<       rxLocationList.push_back (maxTxIdx);
<     }
<   /* Find the location of the Rx power in m_mimoRxPowerW that is associated with the signal we try to decode at each antenna */
<   for (uint8_t rx = 0; rx < numRxAntennas; rx++)
<     {
<       uint8_t txIdx = rxLocationList.at (rx);
<       rxLocationList[rx] = rx + txIdx * numRxAntennas;
<     }
<   return rxLocationList;
< }
< 
< std::ostream & operator << (std::ostream &os, const Event &event)
< {
<   os << "start=" << event.GetStartTime () << ", end=" << event.GetEndTime ()
<      << ", TXVECTOR=" << event.GetTxVector ()
<      << ", power=" << event.GetRxPowerW () << "W"
<      << ", PPDU=" << event.GetPpdu ();
<   return os;
< }
200,202c107,109
< InterferenceHelper::NiChange::NiChange (double power, Ptr<Event> event)
<   : m_power (power),
<     m_event (event)
---
> InterferenceHelper::NiChange::NiChange (Time time, double delta)
>   : m_time (time),
>     m_delta (delta)
206,207c113,114
< double
< InterferenceHelper::NiChange::GetPower (void) const
---
> Time
> InterferenceHelper::NiChange::GetTime (void) const
209c116
<   return m_power;
---
>   return m_time;
212,213c119,120
< void
< InterferenceHelper::NiChange::AddPower (double power)
---
> double
> InterferenceHelper::NiChange::GetDelta (void) const
215c122
<   m_power += power;
---
>   return m_delta;
218,219c125,126
< Ptr<Event>
< InterferenceHelper::NiChange::GetEvent (void) const
---
> bool
> InterferenceHelper::NiChange::operator < (const InterferenceHelper::NiChange& o) const
221c128
<   return m_event;
---
>   return (m_time < o.m_time);
231,232c138
<     m_numRxAntennas (1),
<     m_firstPower (0),
---
>     m_firstPower (0.0),
235,236d140
<   // Always have a zero power noise event in the list
<   AddNiChangeEvent (Time (0), NiChange (0.0, 0));
245,270c149,160
< void
< InterferenceHelper::SetWifiPhy (Ptr<WifiPhy> wifiPhy)
< {
<   m_wifiPhy = wifiPhy;
< }
< 
< Ptr<Event>
< InterferenceHelper::Add (WifiTxVector txVector, Time duration, double rxPowerW)
< {
<   Ptr<Event> event = Create<Event> (txVector, duration, rxPowerW);
<   AppendEvent (event);
<   return event;
< }
< 
< Ptr<Event>
< InterferenceHelper::Add (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPowerW)
< {
<   Ptr<Event> event = Create<Event> (ppdu, txVector, duration, rxPowerW);
<   AppendEvent (event);
<   return event;
< }
< 
< Ptr<Event>
< InterferenceHelper::Add (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPowerW, std::vector<double> mimoRxPower)
< {
<   Ptr<Event> event = Create<Event> (ppdu, txVector, duration, rxPowerW, mimoRxPower);
---
> Ptr<InterferenceHelper::Event>
> InterferenceHelper::Add (uint32_t size, WifiTxVector txVector,
>                          enum WifiPreamble preamble,
>                          Time duration, double rxPowerW)
> {
>   Ptr<InterferenceHelper::Event> event;
> 
>   event = Create<InterferenceHelper::Event> (size,
>                                              txVector,
>                                              preamble,
>                                              duration,
>                                              rxPowerW);
280,284c170,171
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_QOSDATA);
<   Ptr<WifiPpdu> fakePpdu = Create<WifiPpdu> (Create<WifiPsdu> (Create<Packet> (0), hdr),
<                                              WifiTxVector (), duration, 0);
<   Add (fakePpdu, WifiTxVector (), duration, rxPowerW);
---
>   WifiTxVector fakeTxVector;
>   Add (0, fakeTxVector, WIFI_PREAMBLE_NONE, duration, rxPowerW);
293,298d179
< void
< InterferenceHelper::SetErrorRateModel (const Ptr<ErrorRateModel> rate)
< {
<   m_errorRateModel = rate;
< }
< 
305,306c186,187
< Ptr<ErrorRateModel>
< InterferenceHelper::GetErrorRateModel (void) const
---
> void
> InterferenceHelper::SetErrorRateModel (Ptr<ErrorRateModel> rate)
308c189
<   return m_errorRateModel;
---
>   m_errorRateModel = rate;
311,312c192,193
< void
< InterferenceHelper::SetNumberOfReceiveAntennas (uint8_t rx)
---
> Ptr<ErrorRateModel>
> InterferenceHelper::GetErrorRateModel (void) const
314c195
<   m_numRxAntennas = rx;
---
>   return m_errorRateModel;
318c199
< InterferenceHelper::GetEnergyDuration (double energyW) const
---
> InterferenceHelper::GetEnergyDuration (double energyW)
321,326c202,212
<   auto i = GetPreviousPosition (now);
<   Time end = i->first;
<   for (; i != m_niChanges.end (); ++i)
<     {
<       double noiseInterferenceW = i->second.GetPower ();
<       end = i->first;
---
>   double noiseInterferenceW = 0.0;
>   Time end = now;
>   noiseInterferenceW = m_firstPower;
>   for (NiChanges::const_iterator i = m_niChanges.begin (); i != m_niChanges.end (); i++)
>     {
>       noiseInterferenceW += i->GetDelta ();
>       end = i->GetTime ();
>       if (end < now)
>         {
>           continue;
>         }
336c222
< InterferenceHelper::AppendEvent (Ptr<Event> event)
---
> InterferenceHelper::AppendEvent (Ptr<InterferenceHelper::Event> event)
338,343c224
<   NS_LOG_FUNCTION (this);
<   double previousPowerStart = 0;
<   double previousPowerEnd = 0;
<   previousPowerStart = GetPreviousPosition (event->GetStartTime ())->second.GetPower ();
<   previousPowerEnd = GetPreviousPosition (event->GetEndTime ())->second.GetPower ();
< 
---
>   Time now = Simulator::Now ();
346,349c227,233
<       m_firstPower = previousPowerStart;
<       // Always leave the first zero power noise event in the list
<       m_niChanges.erase (++(m_niChanges.begin ()),
<                          GetNextPosition (event->GetStartTime ()));
---
>       NiChanges::iterator nowIterator = GetPosition (now);
>       for (NiChanges::iterator i = m_niChanges.begin (); i != nowIterator; i++)
>         {
>           m_firstPower += i->GetDelta ();
>         }
>       m_niChanges.erase (m_niChanges.begin (), nowIterator);
>       m_niChanges.insert (m_niChanges.begin (), NiChange (event->GetStartTime (), event->GetRxPowerW ()));
351,353c235
<   auto first = AddNiChangeEvent (event->GetStartTime (), NiChange (previousPowerStart, event));
<   auto last = AddNiChangeEvent (event->GetEndTime (), NiChange (previousPowerEnd, event));
<   for (auto i = first; i != last; ++i)
---
>   else
355c237
<       i->second.AddPower (event->GetRxPowerW ());
---
>       AddNiChangeEvent (NiChange (event->GetStartTime (), event->GetRxPowerW ()));
356a239,240
>   AddNiChangeEvent (NiChange (event->GetEndTime (), -event->GetRxPowerW ()));
> 
358a243
> 
360c245
< InterferenceHelper::CalculateSnr (double signal, double noiseInterference, WifiTxVector txVector) const
---
> InterferenceHelper::CalculateSnr (double signal, double noiseInterference, uint32_t channelWidth) const
364d248
<   uint16_t channelWidth = txVector.GetChannelWidth ();
366c250
<   double Nt = BOLTZMANN * 290 * channelWidth * 1e6;
---
>   double Nt = BOLTZMANN * 290.0 * channelWidth * 1000000;
371,378c255
<   NS_LOG_DEBUG ("bandwidth(MHz)=" << channelWidth << ", signal(W)= " << signal << ", noise(W)=" << noiseFloor << ", interference(W)=" << noiseInterference << ", snr=" << RatioToDb(snr) << "dB");
<   double gain = 1;
<   if (m_numRxAntennas > txVector.GetNss ())
<     {
<       gain = static_cast<double>(m_numRxAntennas) / txVector.GetNss (); //compute gain offered by diversity for AWGN
<     }
<   NS_LOG_DEBUG ("SNR improvement thanks to diversity: " << 10 * std::log10 (gain) << "dB");
<   snr *= gain;
---
>   NS_LOG_DEBUG ("bandwidth(MHz)=" << channelWidth << ", signal(W)= " << signal << ", noise(W)=" << noiseFloor << ", interference(W)=" << noiseInterference << ", snr(linear)=" << snr);
382,400d258
< std::vector<double>
< InterferenceHelper::CalculateSnr (std::vector<double> signalList, double noiseInterference, WifiTxVector txVector) const
< {
<   //thermal noise at 290K in J/s = W
<   static const double BOLTZMANN = 1.3803e-23;
<   uint16_t channelWidth = txVector.GetChannelWidth ();
<   //Nt is the power of thermal noise in W
<   double Nt = BOLTZMANN * 290 * channelWidth * 1e6;
<   //receiver noise Floor (W) which accounts for thermal noise and non-idealities of the receiver
<   double noiseFloor = m_noiseFigure * Nt;
<   double noise = noiseFloor + noiseInterference;
<   std::vector<double> snrValues;
<   for (const auto& signal: signalList)
<     {
<       snrValues.push_back (signal / noise); //linear scale
<     }
<   return snrValues;
< }
< 
402c260
< InterferenceHelper::CalculateNoiseInterferenceW (Ptr<Event> event, NiChanges *ni) const
---
> InterferenceHelper::CalculateNoiseInterferenceW (Ptr<InterferenceHelper::Event> event, NiChanges *ni) const
404,406c262,264
<   double noiseInterferenceW = m_firstPower;
<   auto it = m_niChanges.find (event->GetStartTime ());
<   for (; it != m_niChanges.end () && it->first < Simulator::Now (); ++it)
---
>   double noiseInterference = m_firstPower;
>   NS_ASSERT (m_rxing);
>   for (NiChanges::const_iterator i = m_niChanges.begin () + 1; i != m_niChanges.end (); i++)
408,409c266
<       //// WIGIG ////
<       if (it->second.GetEvent ()->GetEndTime () == event->GetStartTime ())
---
>       if ((event->GetEndTime () == i->GetTime ()) && event->GetRxPowerW () == -i->GetDelta ())
411,412c268
<           /* This is to handle IEEE 802.11ad AGC and TRN Subfields */
<           continue;
---
>           break;
414,415c270
<       //// WIGIG ////
<       noiseInterferenceW = it->second.GetPower () - event->GetRxPowerW ();
---
>       ni->push_back (*i);
417,426c272,274
<   it = m_niChanges.find (event->GetStartTime ());
<   for (; it != m_niChanges.end () && it->second.GetEvent () != event; ++it);
<   ni->emplace (event->GetStartTime (), NiChange (0, event));
<   while (++it != m_niChanges.end () && it->second.GetEvent () != event)
<     {
<       ni->insert (*it);
<     }
<   ni->emplace (event->GetEndTime (), NiChange (0, event));
<   NS_ASSERT_MSG (noiseInterferenceW >= 0, "CalculateNoiseInterferenceW returns negative value " << noiseInterferenceW);
<   return noiseInterferenceW;
---
>   ni->insert (ni->begin (), NiChange (event->GetStartTime (), noiseInterference));
>   ni->push_back (NiChange (event->GetEndTime (), 0));
>   return noiseInterference;
432,445c280
<   if (duration.IsZero ())
<     {
<       return 1.0;
<     }
<   uint64_t rate = mode.GetDataRate (txVector.GetChannelWidth ());
<   uint64_t nbits = static_cast<uint64_t> (rate * duration.GetSeconds ());
<   double csr = m_errorRateModel->GetChunkSuccessRate (mode, txVector, snir, nbits);
<   return csr;
< }
< 
< double
< InterferenceHelper::CalculatePayloadChunkSuccessRate (double snir, Time duration, WifiTxVector txVector) const
< {
<   if (duration.IsZero ())
---
>   if (duration == NanoSeconds (0))
449,453c284,286
<   WifiMode mode = txVector.GetMode ();
<   uint64_t rate = mode.GetDataRate (txVector);
<   uint64_t nbits = static_cast<uint64_t> (rate * duration.GetSeconds ());
<   nbits /= txVector.GetNss (); //divide effective number of bits by NSS to achieve same chunk error rate as SISO for AWGN
<   double csr = m_errorRateModel->GetChunkSuccessRate (mode, txVector, snir, nbits);
---
>   uint32_t rate = mode.GetPhyRate (txVector);
>   uint64_t nbits = (uint64_t)(rate * duration.GetSeconds ());
>   double csr = m_errorRateModel->GetChunkSuccessRate (mode, txVector, snir, (uint32_t)nbits);
458,509c291
< InterferenceHelper::CalculatePayloadPer (Ptr<const Event> event, NiChanges *ni, std::pair<Time, Time> window) const
< {
<   NS_LOG_FUNCTION (this << window.first << window.second);
<   const WifiTxVector txVector = event->GetTxVector ();
<   double psr = 1.0; /* Packet Success Rate */
<   auto j = ni->begin ();
<   Time previous = j->first;
<   WifiMode payloadMode = event->GetTxVector ().GetMode ();
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   Time phyHeaderStart = j->first + WifiPhy::GetPhyPreambleDuration (txVector); //PPDU start time + preamble
<   Time phyLSigHeaderEnd = phyHeaderStart + WifiPhy::GetPhyHeaderDuration (txVector); //PPDU start time + preamble + L-SIG
<   Time phyTrainingSymbolsStart = phyLSigHeaderEnd + WifiPhy::GetPhyHtSigHeaderDuration (preamble) + WifiPhy::GetPhySigA1Duration (preamble) + WifiPhy::GetPhySigA2Duration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A
<   Time phyPayloadStart = phyTrainingSymbolsStart + WifiPhy::GetPhyTrainingSymbolDuration (txVector) + WifiPhy::GetPhySigBDuration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A + Training + SIG-B
<   Time windowStart = phyPayloadStart + window.first;
<   Time windowEnd = phyPayloadStart + window.second;
<   double noiseInterferenceW = m_firstPower;
<   double powerW = event->GetRxPowerW ();
<   while (++j != ni->end ())
<     {
<       Time current = j->first;
<       NS_LOG_DEBUG ("previous= " << previous << ", current=" << current);
<       NS_ASSERT (current >= previous);
<       /* Get a vector of per stream SNRs (in the case of SISO there is only value in it) and calculate the chunk success rate per stream */
<       std::vector<double> snrPerStream = CalculatePerStreamSnr (event, noiseInterferenceW);
<       //Case 1: Both previous and current point to the windowed payload
<       if (previous >= windowStart)
<         {
<           for (auto snr:snrPerStream)
<             psr *= CalculatePayloadChunkSuccessRate (snr, Min (windowEnd, current) - previous, txVector);
<           NS_LOG_DEBUG ("Both previous and current point to the windowed payload: mode=" << payloadMode << ", psr=" << psr);
<         }
<       //Case 2: previous is before windowed payload and current is in the windowed payload
<       else if (current >= windowStart)
<         {
<           for (auto snr:snrPerStream)
<             psr *= CalculatePayloadChunkSuccessRate (snr, Min (windowEnd, current) - windowStart, txVector);
<           NS_LOG_DEBUG ("previous is before windowed payload and current is in the windowed payload: mode=" << payloadMode << ", psr=" << psr);
<         }
<       noiseInterferenceW = j->second.GetPower () - powerW;
<       previous = j->first;
<       if (previous > windowEnd)
<         {
<           NS_LOG_DEBUG ("Stop: new previous=" << previous << " after time window end=" << windowEnd);
<           break;
<         }
<     }
<   double per = 1 - psr;
<   return per;
< }
< 
< double
< InterferenceHelper::CalculateNonHtPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const
---
> InterferenceHelper::CalculatePlcpPayloadPer (Ptr<const InterferenceHelper::Event> event, NiChanges *ni) const
512d293
<   const WifiTxVector txVector = event->GetTxVector ();
514,522c295,303
<   auto j = ni->begin ();
<   Time previous = j->first;
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   WifiMode headerMode = WifiPhy::GetPhyHeaderMode (txVector);
<   Time phyHeaderStart = j->first + WifiPhy::GetPhyPreambleDuration (txVector); //PPDU start time + preamble
<   Time phyLSigHeaderEnd = phyHeaderStart + WifiPhy::GetPhyHeaderDuration (txVector); //PPDU start time + preamble + L-SIG
<   Time phyTrainingSymbolsStart = phyLSigHeaderEnd + WifiPhy::GetPhyHtSigHeaderDuration (preamble) + WifiPhy::GetPhySigA1Duration (preamble) + WifiPhy::GetPhySigA2Duration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A
<   Time phyPayloadStart = phyTrainingSymbolsStart + WifiPhy::GetPhyTrainingSymbolDuration (txVector) + WifiPhy::GetPhySigBDuration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A + Training + SIG-B
<   double noiseInterferenceW = m_firstPower;
---
>   NiChanges::iterator j = ni->begin ();
>   Time previous = (*j).GetTime ();
>   WifiMode payloadMode = event->GetPayloadMode ();
>   WifiPreamble preamble = event->GetPreambleType ();
>   Time plcpHeaderStart = (*j).GetTime () + WifiPhy::GetPlcpPreambleDuration (event->GetTxVector (), preamble); //packet start time + preamble
>   Time plcpHsigHeaderStart = plcpHeaderStart + WifiPhy::GetPlcpHeaderDuration (event->GetTxVector (), preamble); //packet start time + preamble + L-SIG
>   Time plcpHtTrainingSymbolsStart = plcpHsigHeaderStart + WifiPhy::GetPlcpHtSigHeaderDuration (preamble) + WifiPhy::GetPlcpVhtSigA1Duration (preamble) + WifiPhy::GetPlcpVhtSigA2Duration (preamble); //packet start time + preamble + L-SIG + HT-SIG or VHT-SIG-A (A1 + A2)
>   Time plcpPayloadStart = plcpHtTrainingSymbolsStart + WifiPhy::GetPlcpHtTrainingSymbolDuration (preamble, event->GetTxVector ()) + WifiPhy::GetPlcpVhtSigBDuration (preamble); //packet start time + preamble + L-SIG + HT-SIG or VHT-SIG-A (A1 + A2) + (V)HT Training + VHT-SIG-B
>   double noiseInterferenceW = (*j).GetDelta ();
524c305,306
<   while (++j != ni->end ())
---
>   j++;
>   while (ni->end () != j)
526c308
<       Time current = j->first;
---
>       Time current = (*j).GetTime ();
529,551c311,312
<       double snr = CalculateSnr (powerW, noiseInterferenceW, txVector);
<       //Case 1: previous and current after payload start
<       if (previous >= phyPayloadStart)
<         {
<           psr *= 1;
<           NS_LOG_DEBUG ("Case 1 - previous and current after payload start: nothing to do");
<         }
<       //Case 2: previous is in training or in SIG-B: non-HT will not enter here since it didn't enter in the last two and they are all the same for non-HT
<       else if (previous >= phyTrainingSymbolsStart)
<         {
<           NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<           psr *= 1;
<           NS_LOG_DEBUG ("Case 2 - previous is in training or in SIG-B: nothing to do");
<         }
<       //Case 3: previous is in HT-SIG or SIG-A: non-HT will not enter here since it didn't enter in the last two and they are all the same for non-HT
<       else if (previous >= phyLSigHeaderEnd)
<         {
<           NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<           psr *= 1;
<           NS_LOG_DEBUG ("Case 3cii - previous is in HT-SIG or SIG-A: nothing to do");
<         }
<       //Case 4: previous in L-SIG: HT GF will not reach here because it will execute the previous if and exit
<       else if (previous >= phyHeaderStart)
---
>       //Case 1: Both previous and current point to the payload
>       if (previous >= plcpPayloadStart)
553,614c314,335
<           NS_ASSERT (preamble != WIFI_PREAMBLE_HT_GF);
<           //Case 4a: current after payload start
<           if (current >= phyPayloadStart)
<             {
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 4a - previous in L-SIG and current after payload start: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 4b: current is in training or in SIG-B. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyTrainingSymbolsStart)
<             {
<               NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 4a - previous in L-SIG and current is in training or in SIG-B: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 4c: current in HT-SIG or in SIG-A. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyLSigHeaderEnd)
<             {
<               NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 4ci - previous is in L-SIG and current in HT-SIG or in SIG-A: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 4d: current with previous in L-SIG
<           else
<             {
<               psr *= CalculateChunkSuccessRate (snr, current - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 4d - current with previous in L-SIG: mode=" << headerMode << ", psr=" << psr);
<             }
<         }
<       //Case 5: previous is in the preamble works for all cases
<       else
<         {
<           //Case 5a: current after payload start
<           if (current >= phyPayloadStart)
<             {
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 5aii - previous is in the preamble and current is after payload start: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 5b: current is in training or in SIG-B. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyTrainingSymbolsStart)
<             {
<               NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 5b - previous is in the preamble and current is in training or in SIG-B: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 5c: current in HT-SIG or in SIG-A. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyLSigHeaderEnd)
<             {
<               NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 5b - previous is in the preamble and current in HT-SIG or in SIG-A: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 5d: current is in L-SIG.
<           else if (current >= phyHeaderStart)
<             {
<               NS_ASSERT (preamble != WIFI_PREAMBLE_HT_GF);
<               psr *= CalculateChunkSuccessRate (snr, current - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 5d - previous is in the preamble and current is in L-SIG: mode=" << headerMode << ", psr=" << psr);
<             }
<         }
< 
<       noiseInterferenceW = j->second.GetPower () - powerW;
<       previous = j->first;
---
>           psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                           noiseInterferenceW,
>                                                           event->GetTxVector ().GetChannelWidth ()),
>                                             current - previous,
>                                             payloadMode, event->GetTxVector ());
> 
>           NS_LOG_DEBUG ("Both previous and current point to the payload: mode=" << payloadMode << ", psr=" << psr);
>         }
>       //Case 2: previous is before payload and current is in the payload
>       else if (current >= plcpPayloadStart)
>         {
>           psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                           noiseInterferenceW,
>                                                           event->GetTxVector ().GetChannelWidth ()),
>                                             current - plcpPayloadStart,
>                                             payloadMode, event->GetTxVector ());
>           NS_LOG_DEBUG ("previous is before payload and current is in the payload: mode=" << payloadMode << ", psr=" << psr);
>         }
> 
>       noiseInterferenceW += (*j).GetDelta ();
>       previous = (*j).GetTime ();
>       j++;
622c343
< InterferenceHelper::CalculateHtPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const
---
> InterferenceHelper::CalculatePlcpHeaderPer (Ptr<const InterferenceHelper::Event> event, NiChanges *ni) const
625d345
<   const WifiTxVector txVector = event->GetTxVector ();
627,651c347,367
<   auto j = ni->begin ();
<   Time previous = j->first;
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   WifiMode mcsHeaderMode;
<   if (preamble == WIFI_PREAMBLE_HT_MF || preamble == WIFI_PREAMBLE_HT_GF)
<     {
<       //mode for PHY header fields sent with HT modulation
<       mcsHeaderMode = WifiPhy::GetHtPhyHeaderMode ();
<     }
<   else if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_VHT_MU)
<     {
<       //mode for PHY header fields sent with VHT modulation
<       mcsHeaderMode = WifiPhy::GetVhtPhyHeaderMode ();
<     }
<   else if (preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_HE_MU)
<     {
<       //mode for PHY header fields sent with HE modulation
<       mcsHeaderMode = WifiPhy::GetHePhyHeaderMode ();
<     }
<   WifiMode headerMode = WifiPhy::GetPhyHeaderMode (txVector);
<   Time phyHeaderStart = j->first + WifiPhy::GetPhyPreambleDuration (txVector); //PPDU start time + preamble
<   Time phyLSigHeaderEnd = phyHeaderStart + WifiPhy::GetPhyHeaderDuration (txVector); //PPDU start time + preamble + L-SIG
<   Time phyTrainingSymbolsStart = phyLSigHeaderEnd + WifiPhy::GetPhyHtSigHeaderDuration (preamble) + WifiPhy::GetPhySigA1Duration (preamble) + WifiPhy::GetPhySigA2Duration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A
<   Time phyPayloadStart = phyTrainingSymbolsStart + WifiPhy::GetPhyTrainingSymbolDuration (txVector) + WifiPhy::GetPhySigBDuration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A + Training + SIG-B
<   double noiseInterferenceW = m_firstPower;
---
>   NiChanges::iterator j = ni->begin ();
>   Time previous = (*j).GetTime ();
>   WifiMode payloadMode = event->GetPayloadMode ();
>   WifiPreamble preamble = event->GetPreambleType ();
>   WifiMode htHeaderMode;
>   if (preamble == WIFI_PREAMBLE_HT_MF)
>     {
>       //mode for PLCP header fields sent with HT modulation
>       htHeaderMode = WifiPhy::GetHtPlcpHeaderMode (payloadMode);
>     }
>   else if (preamble == WIFI_PREAMBLE_VHT)
>     {
>       //mode for PLCP header fields sent with VHT modulation
>       htHeaderMode = WifiPhy::GetVhtPlcpHeaderMode (payloadMode);
>     }
>   WifiMode headerMode = WifiPhy::GetPlcpHeaderMode (payloadMode, preamble, event->GetTxVector ());
>   Time plcpHeaderStart = (*j).GetTime () + WifiPhy::GetPlcpPreambleDuration (event->GetTxVector (), preamble); //packet start time + preamble
>   Time plcpHsigHeaderStart = plcpHeaderStart + WifiPhy::GetPlcpHeaderDuration (event->GetTxVector (), preamble); //packet start time + preamble + L-SIG
>   Time plcpHtTrainingSymbolsStart = plcpHsigHeaderStart + WifiPhy::GetPlcpHtSigHeaderDuration (preamble) + WifiPhy::GetPlcpVhtSigA1Duration (preamble) + WifiPhy::GetPlcpVhtSigA2Duration (preamble); //packet start time + preamble + L-SIG + HT-SIG or VHT-SIG-A (A1 + A2)
>   Time plcpPayloadStart = plcpHtTrainingSymbolsStart + WifiPhy::GetPlcpHtTrainingSymbolDuration (preamble, event->GetTxVector ()) + WifiPhy::GetPlcpVhtSigBDuration (preamble); //packet start time + preamble + L-SIG + HT-SIG or VHT-SIG-A (A1 + A2) + (V)HT Training + VHT-SIG-B
>   double noiseInterferenceW = (*j).GetDelta ();
653c369,370
<   while (++j != ni->end ())
---
>   j++;
>   while (ni->end () != j)
655c372
<       Time current = j->first;
---
>       Time current = (*j).GetTime ();
658,660c375,376
<       double snr = CalculateSnr (powerW, noiseInterferenceW, txVector);
<       //Case 1: previous and current after payload start: nothing to do
<       if (previous >= phyPayloadStart)
---
>       //Case 1: previous and current after playload start: nothing to do
>       if (previous >= plcpPayloadStart)
663c379
<           NS_LOG_DEBUG ("Case 1 - previous and current after payload start: nothing to do");
---
>           NS_LOG_DEBUG ("Case 1 - previous and current after playload start: nothing to do");
665,666c381,382
<       //Case 2: previous is in training or in SIG-B: non-HT will not enter here since it didn't enter in the last two and they are all the same for non-HT
<       else if (previous >= phyTrainingSymbolsStart)
---
>       //Case 2: previous is in (V)HT training or in VHT-SIG-B: Non (V)HT will not enter here since it didn't enter in the last two and they are all the same for non (V)HT
>       else if (previous >= plcpHtTrainingSymbolsStart)
670c386
<           if (current >= phyPayloadStart)
---
>           if (current >= plcpPayloadStart)
672,673c388,394
<               psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - previous, mcsHeaderMode, txVector);
<               NS_LOG_DEBUG ("Case 2a - previous is in training or in SIG-B and current after payload start: mode=" << mcsHeaderMode << ", psr=" << psr);
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               event->GetTxVector ().GetChannelWidth ()),
>                                                 plcpPayloadStart - previous,
>                                                 htHeaderMode, event->GetTxVector ());
> 
>               NS_LOG_DEBUG ("Case 2a - previous is in (V)HT training or in VHT-SIG-B and current after payload start: mode=" << htHeaderMode << ", psr=" << psr);
675c396
<           //Case 2b: current is in training or in SIG-B
---
>           //Case 2b: current is in (V)HT training or in VHT-SIG-B
678,679c399,405
<               psr *= CalculateChunkSuccessRate (snr, current - previous, mcsHeaderMode, txVector);
<               NS_LOG_DEBUG ("Case 2b - previous is in training or in SIG-B and current is in training or in SIG-B: mode=" << mcsHeaderMode << ", psr=" << psr);
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               event->GetTxVector ().GetChannelWidth ()),
>                                                 current - previous,
>                                                 htHeaderMode, event->GetTxVector ());
> 
>               NS_LOG_DEBUG ("Case 2b - previous is in (V)HT training or in VHT-SIG-B and current is in (V)HT training or in VHT-SIG-B: mode=" << htHeaderMode << ", psr=" << psr);
682,683c408,409
<       //Case 3: previous is in HT-SIG or SIG-A: non-HT will not enter here since it didn't enter in the last two and they are all the same for non-HT
<       else if (previous >= phyLSigHeaderEnd)
---
>       //Case 3: previous is in HT-SIG or VHT-SIG-A: Non (V)HT will not enter here since it didn't enter in the last two and they are all the same for non (V)HT
>       else if (previous >= plcpHsigHeaderStart)
687c413
<           if (current >= phyPayloadStart)
---
>           if (current >= plcpPayloadStart)
689,695c415,431
<               psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<               //Case 3ai: VHT or HE format
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
<                 {
<                   //SIG-A is sent using non-HT OFDM modulation
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - previous, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 3ai - previous is in SIG-A and current after payload start: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               event->GetTxVector ().GetChannelWidth ()),
>                                                 plcpPayloadStart - plcpHtTrainingSymbolsStart,
>                                                 htHeaderMode, event->GetTxVector ());
> 
>               //Case 3ai: VHT format
>               if (preamble == WIFI_PREAMBLE_VHT)
>                 {
>                   //VHT-SIG-A is sent using legacy OFDM modulation
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHtTrainingSymbolsStart - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 3ai - previous is in VHT-SIG-A and current after payload start: VHT mode=" << htHeaderMode << ", non-VHT mode=" << headerMode << ", psr=" << psr);
697c433
<               //Case 3aii: HT formats
---
>               //Case 3aii: HT mixed format of HT greenfield
700,701c436,442
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - previous, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 3aii - previous is in HT-SIG and current after payload start: mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHtTrainingSymbolsStart - previous,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 3aii - previous is in HT-SIG and current after payload start: mode=" << htHeaderMode << ", psr=" << psr);
704,705c445,446
<           //Case 3b: current is in training or in SIG-B
<           else if (current >= phyTrainingSymbolsStart)
---
>           //Case 3b: current is in (V)HT training or in VHT-SIG-B
>           else if (current >= plcpHtTrainingSymbolsStart)
707,709c448,455
<               psr *= CalculateChunkSuccessRate (snr, current - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<               //Case 3bi: VHT or HE format
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               event->GetTxVector ().GetChannelWidth ()),
>                                                 current - plcpHtTrainingSymbolsStart,
>                                                 htHeaderMode, event->GetTxVector ());
> 
>               //Case 3bi: VHT format
>               if (preamble == WIFI_PREAMBLE_VHT)
711,713c457,464
<                   //SIG-A is sent using non-HT OFDM modulation
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - previous, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 3bi - previous is in SIG-A and current is in training or in SIG-B: mode=" << headerMode << ", psr=" << psr);
---
>                   //VHT-SIG-A is sent using legacy OFDM modulation
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHtTrainingSymbolsStart - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 3bi - previous is in VHT-SIG-A and current is in VHT training or in VHT-SIG-B: VHT mode=" << htHeaderMode << ", non-VHT mode=" << headerMode << ", psr=" << psr);
715c466
<               //Case 3bii: HT formats
---
>               //Case 3bii: HT mixed format of HT greenfield
718,719c469,475
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - previous, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 3bii - previous is in HT-SIG and current is in HT training: mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHtTrainingSymbolsStart - previous,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 3bii - previous is in HT-SIG and current is in HT training: mode=" << htHeaderMode << ", psr=" << psr);
722c478
<           //Case 3c: current with previous in HT-SIG or SIG-A
---
>           //Case 3c: current with previous in HT-SIG or VHT-SIG-A
725,726c481,482
<               //Case 3ci: VHT or HE format
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               //Case 3bi: VHT format
>               if (preamble == WIFI_PREAMBLE_VHT)
728,730c484,491
<                   //SIG-A is sent using non-HT OFDM modulation
<                   psr *= CalculateChunkSuccessRate (snr, current - previous, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 3ci - previous with current in SIG-A: mode=" << headerMode << ", psr=" << psr);
---
>                   //VHT-SIG-A is sent using legacy OFDM modulation
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 3ci - previous with current in VHT-SIG-A: VHT mode=" << htHeaderMode << ", non-VHT mode=" << headerMode << ", psr=" << psr);
732c493
<               //Case 3cii: HT mixed format or HT greenfield
---
>               //Case 3bii: HT mixed format of HT greenfield
735,736c496,502
<                   psr *= CalculateChunkSuccessRate (snr, current - previous, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 3cii - previous with current in HT-SIG: mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - previous,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 3cii - previous with current in HT-SIG: mode=" << htHeaderMode << ", psr=" << psr);
741c507
<       else if (previous >= phyHeaderStart)
---
>       else if (previous >= plcpHeaderStart)
745c511
<           if (current >= phyPayloadStart)
---
>           if (current >= plcpPayloadStart)
747c513
<               //Case 4ai: non-HT format
---
>               //Case 4ai: Non (V)HT format
750,758c516,539
<                   psr *= 1;
<                   NS_LOG_DEBUG ("Case 4ai - previous in L-SIG and current after payload start: nothing to do");
<                 }
<               //Case 4aii: VHT or HE format
<               else if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
<                 {
<                   psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 4aii - previous is in L-SIG and current after payload start: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpPayloadStart - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 4ai - previous in L-SIG and current after payload start: mode=" << headerMode << ", psr=" << psr);
>                 }
>               //Case 4aii: VHT format
>               else if (preamble == WIFI_PREAMBLE_VHT)
>                 {
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpHtTrainingSymbolsStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHtTrainingSymbolsStart - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 4aii - previous is in L-SIG and current after payload start: VHT mode=" << htHeaderMode << ", non-VHT mode=" << headerMode << ", psr=" << psr);
763,764c544,556
<                   psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 4aiii - previous in L-SIG and current after payload start: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpHsigHeaderStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 4aiii - previous in L-SIG and current after payload start: HT mode=" << htHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
767,768c559,560
<           //Case 4b: current is in training or in SIG-B. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyTrainingSymbolsStart)
---
>           //Case 4b: current is in (V)HT training or in VHT-SIG-B. Non (V)HT will not come here since it went in previous if or if the previous if is not true this will be not true
>           else if (current >= plcpHtTrainingSymbolsStart)
771,772c563,565
<               //Case 4bi: VHT or HE format
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
> 
>               //Case 4bi: VHT format
>               if (preamble == WIFI_PREAMBLE_VHT)
774,776c567,579
<                   psr *= CalculateChunkSuccessRate (snr, current - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 4bi - previous is in L-SIG and current in training or in SIG-B: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - plcpHtTrainingSymbolsStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHtTrainingSymbolsStart - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 4bi - previous is in L-SIG and current in VHT training or in VHT-SIG-B: VHT mode=" << htHeaderMode << ", non-VHT mode=" << headerMode << ", psr=" << psr);
781,782c584,596
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 4bii - previous in L-SIG and current in HT training: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - plcpHsigHeaderStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 4bii - previous in L-SIG and current in HT training: HT mode=" << htHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
785,786c599,600
<           //Case 4c: current in HT-SIG or in SIG-A. Non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyLSigHeaderEnd)
---
>           //Case 4c: current in HT-SIG or in VHT-SIG-A. Non (V)HT will not come here since it went in previous if or if the previous if is not true this will be not true
>           else if (current >= plcpHsigHeaderStart)
788a603
> 
790c605
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               if (preamble == WIFI_PREAMBLE_VHT)
792,793c607,613
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 4ci - previous is in L-SIG and current in SIG-A: mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 4ci - previous is in L-SIG and current in VHT-SIG-A: mode=" << headerMode << ", psr=" << psr);
798,799c618,630
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 4cii - previous in L-SIG and current in HT-SIG: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - plcpHsigHeaderStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - previous,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 4cii - previous in L-SIG and current in HT-SIG: HT mode=" << htHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
805,806c636,642
<               psr *= 1;
<               NS_LOG_DEBUG ("Case 4d - current with previous in L-SIG: nothing to do");
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               event->GetTxVector ().GetChannelWidth ()),
>                                                 current - previous,
>                                                 headerMode, event->GetTxVector ());
> 
>               NS_LOG_DEBUG ("Case 3c - current with previous in L-SIG: mode=" << headerMode << ", psr=" << psr);
813c649
<           if (current >= phyPayloadStart)
---
>           if (current >= plcpPayloadStart)
815c651
<               //Case 5ai: non-HT format (No HT-SIG or Training Symbols)
---
>               //Case 5ai: Non HT format (No HT-SIG or Training Symbols)
818,819c654,660
<                   psr *= 1;
<                   NS_LOG_DEBUG ("Case 5ai - previous is in the preamble and current is after payload start: nothing to do");
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpHeaderStart,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 5a - previous is in the preamble and current is after payload start: mode=" << headerMode << ", psr=" << psr);
821,822c662,663
<               //Case 5aii: VHT or HE format
<               else if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               //Case 5aii: VHT format
>               else if (preamble == WIFI_PREAMBLE_VHT)
824,826c665,677
<                   psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 5aii - previous is in the preamble and current is after payload start: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpHtTrainingSymbolsStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHtTrainingSymbolsStart - plcpHeaderStart,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 5aii - previous is in the preamble and current is after payload start: VHT mode=" << htHeaderMode << ", non-VHT mode=" << headerMode << ", psr=" << psr);
828c679,680
<               //Case 5aiii: HT formats
---
> 
>               //Case 5aiii: HT format
831,832c683,695
<                   psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 5aiii - previous is in the preamble and current is after payload start: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpHsigHeaderStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - plcpHeaderStart, //HT GF: plcpHsigHeaderStart - plcpHeaderStart = 0
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 4a - previous is in the preamble and current is after payload start: HT mode=" << htHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
835,836c698,699
<           //Case 5b: current is in training or in SIG-B. Non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyTrainingSymbolsStart)
---
>           //Case 5b: current is in (V)HT training or in VHT-SIG-B. Non (V)HT will not come here since it went in previous if or if the previous if is not true this will be not true
>           else if (current >= plcpHtTrainingSymbolsStart)
839,840c702,704
<               //Case 5bi: VHT or HE format
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
> 
>               //Case 5bi: VHT format
>               if (preamble == WIFI_PREAMBLE_VHT)
842,844c706,718
<                   psr *= CalculateChunkSuccessRate (snr, current - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 5bi - previous is in the preamble and current in training or in SIG-B: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - plcpHtTrainingSymbolsStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHtTrainingSymbolsStart - plcpHeaderStart,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 5bi - previous is in the preamble and current in VHT training or in VHT-SIG-B: VHT mode=" << htHeaderMode << ", non-VHT mode=" << headerMode << ", psr=" << psr);
846c720
<               //Case 5bii: HT mixed format
---
>               //Case 45ii: HT mixed format
849,850c723,735
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 5bii - previous is in the preamble and current in HT training: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - plcpHsigHeaderStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - plcpHeaderStart,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 5bii - previous is in the preamble and current in HT training: HT mode=" << htHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
853,854c738,739
<           //Case 5c: current in HT-SIG or in SIG-A. Non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyLSigHeaderEnd)
---
>           //Case 5c: current in HT-SIG or in VHT-SIG-A. Non (V)HT will not come here since it went in previous if or if the previous if is not true this will be not true
>           else if (current >= plcpHsigHeaderStart)
857,858c742,744
<               //Case 5ci: VHT or HE format
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
> 
>               //Case 5ci: VHT format
>               if (preamble == WIFI_PREAMBLE_VHT)
860,861c746,752
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 5ci - previous is in preamble and current in SIG-A: mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - plcpHeaderStart,
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 5ci - previous is in preamble and current in VHT-SIG-A: mode=" << headerMode << ", psr=" << psr);
863c754
<               //Case 5cii: HT formats
---
>               //Case 5cii: HT mixed format
866,867c757,769
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 5cii - previous in preamble and current in HT-SIG: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     current - plcpHsigHeaderStart,
>                                                     htHeaderMode, event->GetTxVector ());
> 
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   event->GetTxVector ().GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - plcpHeaderStart, //HT GF: plcpHsigHeaderStart - plcpHeaderStart = 0
>                                                     headerMode, event->GetTxVector ());
> 
>                   NS_LOG_DEBUG ("Case 5cii - previous in preamble and current in HT-SIG: HT mode=" << htHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
870,871c772,773
<           //Case 5d: current is in L-SIG. HT-GF will not come here
<           else if (current >= phyHeaderStart)
---
>           //Case 5d: current is in L-SIG. HT GF will not come here
>           else if (current >= plcpHeaderStart)
874,877d775
<               psr *= 1;
<               NS_LOG_DEBUG ("Case 5d - previous is in the preamble and current is in L-SIG: nothing to do");
<             }
<         }
879,885c777,781
<       noiseInterferenceW = j->second.GetPower () - powerW;
<       previous = j->first;
<     }
< 
<   double per = 1 - psr;
<   return per;
< }
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               event->GetTxVector ().GetChannelWidth ()),
>                                                 current - plcpHeaderStart,
>                                                 headerMode, event->GetTxVector ());
887,941c783
< double
< InterferenceHelper::CalculateDmgPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const
< {
<   NS_LOG_FUNCTION (this);
<   const WifiTxVector txVector = event->GetTxVector ();
<   double psr = 1.0; /* Packet Success Rate */
<   auto j = ni->begin ();
<   Time previous = j->first;
<   WifiMode headerMode = WifiPhy::GetPhyHeaderMode (txVector);
<   Time phyHeaderStart = j->first + WifiPhy::GetPhyPreambleDuration (txVector);  //PPDU start time + preamble
<   Time phyHeaderEnd = phyHeaderStart + WifiPhy::GetPhyHeaderDuration (txVector); //PPDU start time + preamble + header
<   double noiseInterferenceW = m_firstPower;
<   double powerW = event->GetRxPowerW ();
<   while (++j != ni->end ())
<     {
<       Time current = j->first;
<       NS_LOG_DEBUG ("previous= " << previous << ", current=" << current);
<       NS_ASSERT (current >= previous);
<       double snr = CalculateSnr (powerW, noiseInterferenceW, txVector);
<       //Case 1: previous and current after payload start
<       if (previous >= phyHeaderEnd)
<         {
<           psr *= 1;
<           NS_LOG_DEBUG ("Case 1 - previous and current after payload start: nothing to do");
<         }
<       //Case 2: previous in DMG PHY Header
<       else if (previous >= phyHeaderStart)
<         {
<           //Case 2a: current after payload start
<           if (current >= phyHeaderEnd)
<             {
<               psr *= CalculateChunkSuccessRate (snr, phyHeaderEnd - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 2a - previous in DMG PHY Header and current after payload start: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 2b: current with previous in DMG PHY Header
<           else
<             {
<               psr *= CalculateChunkSuccessRate (snr, current - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 2b - current with previous in DMG PHY Header: mode=" << headerMode << ", psr=" << psr);
<             }
<         }
<       //Case 3: previous is in the preamble works for all cases
<       else
<         {
<           //Case 3a: current after payload start/PHY header end
<           if (current >= phyHeaderEnd)
<             {
<               psr *= CalculateChunkSuccessRate (snr, phyHeaderEnd - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 3a - previous is in the preamble and current is after payload start: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 3b: current is in DMG PHY Header.
<           else if (current >= phyHeaderStart)
<             {
<               psr *= CalculateChunkSuccessRate (snr, current - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 3b - previous is in the preamble and current is in DMG PHY Header: mode=" << headerMode << ", psr=" << psr);
---
>               NS_LOG_DEBUG ("Case 5d - previous is in the preamble and current is in L-SIG: mode=" << headerMode << ", psr=" << psr);
945,946c787,789
<       noiseInterferenceW = j->second.GetPower () - powerW;
<       previous = j->first;
---
>       noiseInterferenceW += (*j).GetDelta ();
>       previous = (*j).GetTime ();
>       j++;
954c797
< InterferenceHelper::CalculatePayloadSnrPer (Ptr<Event> event, std::pair<Time, Time> relativeMpduStartStop) const
---
> InterferenceHelper::CalculatePlcpPayloadSnrPer (Ptr<InterferenceHelper::Event> event)
960c803
<                              event->GetTxVector ());
---
>                              event->GetTxVector ().GetChannelWidth ());
962,963c805,806
<   /* calculate the SNIR at the start of the MPDU (located through windowing) and accumulate
<    * all SNIR changes in the SNIR vector.
---
>   /* calculate the SNIR at the start of the packet and accumulate
>    * all SNIR changes in the snir vector.
965c808
<   double per = CalculatePayloadPer (event, &ni, relativeMpduStartStop);
---
>   double per = CalculatePlcpPayloadPer (event, &ni);
973,1085d815
< double
< InterferenceHelper::CalculatePlcpTrnSnr (Ptr<Event> event)
< {
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   double snr = CalculateSnr (event->GetRxPowerW (),
<                              noiseInterferenceW,
<                              event->GetTxVector ());
<   return snr;
< }
< 
< std::vector<double>
< InterferenceHelper::CalculateMimoTrnSnr (Ptr<Event> event, std::vector<double> rxPowerWList,
<                                          bool interferenceFree, uint8_t numRxAntennas)
< {
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   std::vector<double> snrValues;
<   if (interferenceFree)
<     {
<       snrValues = CalculateSnr (rxPowerWList,
<                                 noiseInterferenceW,
<                                 event->GetTxVector ());
<     }
<   else
<     {
<       uint8_t numTxAntennas = rxPowerWList.size ()/numRxAntennas;
<       double rxPowerW, interference, snrValue;
<       uint8_t index = 0;
<       for (uint8_t tx = 0; tx < numTxAntennas; tx++)
<         {
<           for (uint8_t rx = 0; rx < numRxAntennas; rx++)
<             {
<               rxPowerW = rxPowerWList.at (index);
<               interference = 0;
<               for (uint8_t txInterferer = 0; txInterferer < numTxAntennas; txInterferer++)
<                 {
<                   if (txInterferer != tx)
<                     {
<                       interference += rxPowerWList.at (rx + txInterferer * numRxAntennas);
<                     }
<                 }
<               index++;
<               interference += noiseInterferenceW;
<               snrValue = CalculateSnr (rxPowerW, interference, event->GetTxVector ());
<               snrValues.push_back (snrValue);
<             }
<         }
<     }
<   return snrValues;
< }
< 
< double
< InterferenceHelper::CalculatePayloadSnr (Ptr<Event> event) const
< {
<   NS_LOG_FUNCTION (this);
<   /* Calculate the SINR per stream */
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   std::vector<double> snrPerStream = CalculatePerStreamSnr (event, noiseInterferenceW);
<   double snr;
<   /* In the case of SISO simply return the SNR, in the case of MIMO return the minumum SNR per stream */
<   if (snrPerStream.size () == 1)
<     snr = snrPerStream.at (0);
<   else
<     snr = *(std::min_element (snrPerStream.begin (), snrPerStream.end ()));
<   return snr;
< }
< 
< std::vector<double>
< InterferenceHelper::CalculatePerStreamSnr (Ptr<Event const> event, double noiseInterferenceW) const
< {
<   NS_LOG_FUNCTION (this);
<   std::vector<double> perStreamSnr;
<   if (event->GetMimoRxPowerW ().empty ())
<     {
<       /* In case of SISO simply calculate the SINR */
<       double snr = CalculateSnr (event->GetRxPowerW (),
<                                  noiseInterferenceW,
<                                  event->GetTxVector ());
<       perStreamSnr.push_back (snr);
<     }
<   else
<     {
<       /* In case of MIMO calculate the SINR per stream taking into account inter-stream interference and
<        * assuming that we try to decode the maximum received tx signal at each antenna as long as no two rx antennas
<        * try to decode the same signal */
<       std::vector<double> mimoRxPowerW = event->GetMimoRxPowerW ();
<       std::vector<double> interStreamInterference = event->GetMimoInterStreamInterference ();
<       std::vector<uint8_t> rxPowerLocations = event->GetMimoRxSignalLocation ();
<       for (auto rxStream : rxPowerLocations)
<         {
<           double snr = CalculateSnr (mimoRxPowerW.at (rxStream),
<                                      noiseInterferenceW + interStreamInterference.at (rxStream),
<                                      event->GetTxVector ());
<           perStreamSnr.push_back (snr);
<         }
<     }
<   return perStreamSnr;
< }
< 
< double
< InterferenceHelper::CalculateSnr (Ptr<Event> event) const
< {
<   NS_LOG_FUNCTION (this);
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   double snr = CalculateSnr (event->GetRxPowerW (),
<                              noiseInterferenceW,
<                              event->GetTxVector ());
<  return snr;
< }
< 
1087c817
< InterferenceHelper::CalculateNonHtPhyHeaderSnrPer (Ptr<Event> event) const
---
> InterferenceHelper::CalculatePlcpHeaderSnrPer (Ptr<InterferenceHelper::Event> event)
1089d818
<   NS_LOG_FUNCTION (this);
1094c823
<                              event->GetTxVector ());
---
>                              event->GetTxVector ().GetChannelWidth ());
1096,1097c825,826
<   /* calculate the SNIR at the start of the PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
---
>   /* calculate the SNIR at the start of the plcp header and accumulate
>    * all SNIR changes in the snir vector.
1099,1141c828
<   double per = CalculateNonHtPhyHeaderPer (event, &ni);
< 
<   struct SnrPer snrPer;
<   snrPer.snr = snr;
<   snrPer.per = per;
<   return snrPer;
< }
< 
< struct InterferenceHelper::SnrPer
< InterferenceHelper::CalculateHtPhyHeaderSnrPer (Ptr<Event> event) const
< {
<   NS_LOG_FUNCTION (this);
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   double snr = CalculateSnr (event->GetRxPowerW (),
<                              noiseInterferenceW,
<                              event->GetTxVector ());
<   
<   /* calculate the SNIR at the start of the PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
<    */
<   double per = CalculateHtPhyHeaderPer (event, &ni);
<   
<   struct SnrPer snrPer;
<   snrPer.snr = snr;
<   snrPer.per = per;
<   return snrPer;
< }
< 
< struct InterferenceHelper::SnrPer
< InterferenceHelper::CalculateDmgPhyHeaderSnrPer (Ptr<Event> event) const
< {
<   NS_LOG_FUNCTION (this);
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   double snr = CalculateSnr (event->GetRxPowerW (),
<                              noiseInterferenceW,
<                              event->GetTxVector ());
< 
<   /* calculate the SNIR at the start of the PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
<    */
<   double per = CalculateDmgPhyHeaderPer (event, &ni);
---
>   double per = CalculatePlcpHeaderPer (event, &ni);
1153,1154d839
<   // Always have a zero power noise event in the list
<   AddNiChangeEvent (Time (0), NiChange (0.0, 0));
1156,1162c841
<   m_firstPower = 0;
< }
< 
< InterferenceHelper::NiChanges::const_iterator
< InterferenceHelper::GetNextPosition (Time moment) const
< {
<   return m_niChanges.upper_bound (moment);
---
>   m_firstPower = 0.0;
1165,1166c844,845
< InterferenceHelper::NiChanges::const_iterator
< InterferenceHelper::GetPreviousPosition (Time moment) const
---
> InterferenceHelper::NiChanges::iterator
> InterferenceHelper::GetPosition (Time moment)
1168,1172c847
<   auto it = GetNextPosition (moment);
<   // This is safe since there is always an NiChange at time 0,
<   // before moment.
<   --it;
<   return it;
---
>   return std::upper_bound (m_niChanges.begin (), m_niChanges.end (), NiChange (moment, 0));
1175,1176c850,851
< InterferenceHelper::NiChanges::iterator
< InterferenceHelper::AddNiChangeEvent (Time moment, NiChange change)
---
> void
> InterferenceHelper::AddNiChangeEvent (NiChange change)
1178c853
<   return m_niChanges.insert (GetNextPosition (moment), std::make_pair (moment, change));
---
>   m_niChanges.insert (GetPosition (change.GetTime ()), change);
1193,1196d867
<   //Update m_firstPower for frame capture
<   auto it = GetPreviousPosition (Simulator::Now ());
<   it--;
<   m_firstPower = it->second.GetPower ();
diff ../../NS3-WiGig/src/wifi/model/interference-helper.h ../../ns-3-dev/src/wifi/model/interference-helper.h
23a24,29
> #include <stdint.h>
> #include <vector>
> #include <list>
> #include "wifi-mode.h"
> #include "wifi-preamble.h"
> #include "wifi-phy-standard.h"
25,26c31,33
< #include "wifi-tx-vector.h"
< #include <map>
---
> #include "ns3/simple-ref-count.h"
> #include "ns3/wifi-tx-vector.h"
> #include "error-rate-model.h"
30,34d36
< class WifiPpdu;
< class WifiPsdu;
< class ErrorRateModel;
< class WifiPhy;
< 
38d39
<  * \brief signal event for a PPDU.
40c41
< class Event : public SimpleRefCount<Event>
---
> class InterferenceHelper
44,67c45
<    * Create an Event with the given parameters.
<    *
<    * \param txVector TXVECTOR of the packet
<    * \param duration duration of the signal
<    * \param rxPower the received power (w)
<    */
<   Event (WifiTxVector txVector, Time duration, double rxPower);
<   /**
<    * Create an Event with the given parameters.
<    *
<    * \param ppdu the PPDU
<    * \param txVector the TXVECTOR
<    * \param duration duration of the PPDU
<    * \param rxPower the received power (w)
<    */
<   Event (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower);
<   /**
<    * Create an Event with the given parameters.
<    *
<    * \param ppdu the PPDU
<    * \param txVector the TXVECTOR
<    * \param duration duration of the PPDU
<    * \param rxPower the received power (w)
<    * \param mimoRxPower the received power (w) for MIMO
---
>    * Signal event for a packet.
69,70c47,62
<   Event (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower, std::vector<double> mimoRxPower);
<   ~Event ();
---
>   class Event : public SimpleRefCount<InterferenceHelper::Event>
>   {
> public:
>     /**
>      * Create an Event with the given parameters.
>      *
>      * \param size packet size
>      * \param txVector TXVECTOR of the packet
>      * \param preamble preamble type
>      * \param duration duration of the signal
>      * \param rxPower the receive power (w)
>      */
>     Event (uint32_t size, WifiTxVector txVector,
>            enum WifiPreamble preamble,
>            Time duration, double rxPower);
>     ~Event ();
72,140c64,111
<   /**
<    * Return the PSDU in the PPDU.
<    *
<    * \return the PSDU in the PPDU
<    */
<   Ptr<const WifiPsdu> GetPsdu (void) const;
<   /**
<    * Return the PPDU.
<    *
<    * \return the PPDU
<    */
<   Ptr<const WifiPpdu> GetPpdu (void) const;
<   /**
<    * Return the start time of the signal.
<    *
<    * \return the start time of the signal
<    */
<   Time GetStartTime (void) const;
<   /**
<    * Return the end time of the signal.
<    *
<    * \return the end time of the signal
<    */
<   Time GetEndTime (void) const;
<   /**
<    * Return the duration of the signal.
<    *
<    * \return the duration of the signal
<    */
<   Time GetDuration (void) const;
<   /**
<    * Return the received power (w).
<    *
<    * \return the received power (w)
<    */
<   double GetRxPowerW (void) const;
<   /**
<    * Return the TXVECTOR of the PPDU.
<    *
<    * \return the TXVECTOR of the PPDU
<    */
<   WifiTxVector GetTxVector (void) const;
<   /**
<    * Return the Wi-Fi mode used for the payload.
<    *
<    * \return the Wi-Fi mode used for the payload
<    */
<   WifiMode GetPayloadMode (void) const;
<   /**
<    * Return the list of received powers (W) in the case of MIMO.
<    *
<    * \return the list of received powers in the case of MIMO
<    */
<   std::vector<double> GetMimoRxPowerW (void) const;
<   /**
<    * Return the list of inter-stream interference for each received MIMO power.
<    *
<    * \return the list of inter-stream interference values in the case of MIMO
<    */
<   std::vector<double> GetMimoInterStreamInterference (void) const;
<   /**
<    * Return the location of the Rx signals that we lock into for each Rx antenna
<    * from the list of Rx powers in the case of MIMO.
<    * For now we choose to lock into the strongest Rx signal at each antenna, making sure that no two antennas
<    * try to decode the same stream.
<    *
<    * \return the list of indices from the mimoRxPowerW list that specify the rx signals that we decode
<    */
<   std::vector<uint8_t> GetMimoRxSignalLocation (void) const;
---
>     /**
>      * Return the duration of the signal.
>      *
>      * \return the duration of the signal
>      */
>     Time GetDuration (void) const;
>     /**
>      * Return the start time of the signal.
>      *
>      * \return the start time of the signal
>      */
>     Time GetStartTime (void) const;
>     /**
>      * Return the end time of the signal.
>      *
>      * \return the end time of the signal
>      */
>     Time GetEndTime (void) const;
>     /**
>      * Return the receive power (w).
>      *
>      * \return the receive power (w)
>      */
>     double GetRxPowerW (void) const;
>     /**
>      * Return the size of the packet (bytes).
>      *
>      * \return the size of the packet (bytes)
>      */
>     uint32_t GetSize (void) const;
>     /**
>      * Return the TXVECTOR of the packet.
>      *
>      * \return the TXVECTOR of the packet
>      */
>     WifiTxVector GetTxVector (void) const;
>     /**
>      * Return the Wi-Fi mode used for the payload.
>      *
>      * \return the Wi-Fi mode used for the payload
>      */
>     WifiMode GetPayloadMode (void) const;
>     /**
>      * Return the preamble type of the packet.
>      *
>      * \return the preamble type of the packet
>      */
>     enum WifiPreamble GetPreambleType (void) const;
144,171c115,121
<   Ptr<const WifiPpdu> m_ppdu; ///< PPDU
<   WifiTxVector m_txVector; ///< TXVECTOR
<   Time m_startTime; ///< start time
<   Time m_endTime; ///< end time
<   double m_rxPowerW; ///< received power in watts
<   std::vector<double> m_mimoRxPowerW; //!< received power in watts for MIMO
< };
< 
< /**
<  * \brief Stream insertion operator.
<  *
<  * \param os the stream
<  * \param event the event
<  * \returns a reference to the stream
<  */
< std::ostream& operator<< (std::ostream& os, const Event &event);
< 
< 
< /**
<  * \ingroup wifi
<  * \brief handles interference calculations
<  */
< class InterferenceHelper
< {
< public:
<   /**
<    * Signal event for a PPDU.
<    */
---
>     uint32_t m_size;
>     WifiTxVector m_txVector;
>     enum WifiPreamble m_preamble;
>     Time m_startTime;
>     Time m_endTime;
>     double m_rxPowerW;
>   };
178,179c128,129
<     double snr; ///< SNR in linear scale
<     double per; ///< PER
---
>     double snr;
>     double per;
185d134
<   void SetWifiPhy (Ptr<WifiPhy> wifiPhy);
189c138
<    * \param value noise figure in linear scale
---
>    * \param value noise figure
197c146
<   void SetErrorRateModel (const Ptr<ErrorRateModel> rate);
---
>   void SetErrorRateModel (Ptr<ErrorRateModel> rate);
211,217d159
<   /**
<    * Set the number of RX antennas in the receiver corresponding to this
<    * interference helper.
<    *
<    * \param rx the number of RX antennas
<    */
<   void SetNumberOfReceiveAntennas (uint8_t rx);
226c168
<   Time GetEnergyDuration (double energyW) const;
---
>   Time GetEnergyDuration (double energyW);
229,247d170
<    * Add the PPDU-related signal to interference helper.
<    *
<    * \param txvector TXVECTOR of the packet
<    * \param duration duration of the signal
<    * \param rxPower the received power (w)
<    */
<   Ptr<Event> Add (WifiTxVector txVector, Time duration, double rxPower = 0);
<   /**
<    * Add the packet-related signal to interference helper.
<    *
<    * \param packet the packet
<    * \param ppdu the PPDU
<    * \param txVector the TXVECTOR
<    * \param rxPower received power (W)
<    *
<    * \return Event
<    */
<   Ptr<Event> Add (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower);
<   /**
250,254c173,177
<    * \param packet the packet
<    * \param ppdu the PPDU
<    * \param txVector the TXVECTOR
<    * \param rxPower received power (W)
<    * \param mimoRxPower received power (W) for MIMO
---
>    * \param size packet size
>    * \param txVector TXVECTOR of the packet
>    * \param preamble Wi-Fi preamble for the packet
>    * \param duration the duration of the signal
>    * \param rxPower receive power (W)
256c179
<    * \return Event
---
>    * \return InterferenceHelper::Event
258c181,183
<   Ptr<Event> Add (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower, std::vector<double> mimoRxPower);
---
>   Ptr<InterferenceHelper::Event> Add (uint32_t size, WifiTxVector txVector,
>                                       enum WifiPreamble preamble,
>                                       Time duration, double rxPower);
263c188
<    * \param rxPower received power (W)
---
>    * \param rxPower receive power (W)
266d190
<   //// WIGIG ////
268c192,193
<    * Calculate the SNIR for the event (starting from now until the event end).
---
>    * Calculate the SNIR at the start of the plcp payload and accumulate
>    * all SNIR changes in the snir vector.
270,342c195
<    * \param event the event corresponding to the first time the corresponding TRN subfield arrives
<    *
<    * \return the SNR for the TRN subfield in linear scale
<    */
<   double CalculatePlcpTrnSnr (Ptr<Event> event);
<   /**
<    * Calculate the SNIR for the event (starting from now until the event end).
<    *
<    * \param event the event corresponding to the first time the corresponding TRN subfield arrives
<    * \param rxPowerW List of rx power values in Watt for each Tx and Rx combination.
<    * \param interferenceFree This flag is to idnicate whether we consider inter-stream interference
<    * in our SINR calculations which is for the SISO case or we include inter-stream interference
<    * which is in the MIMO case
<    * \param numRxAntennas The numbers of receive antennas when we the interferenceFree flag is set to false.
<    * \return List of SNR values in linear scale.
<    */
<   std::vector<double> CalculateMimoTrnSnr (Ptr<Event> event, std::vector<double> rxPowerW,
<                                            bool interferenceFree = true, uint8_t numRxAntennas = 1);
<   /**
<    * Calculate the SNIR for the event (starting from now until the event end). In the MIMO case
<    * returns the minimum SINR from the streams taking into account inter-stream interference.
<    * Used in the EndReceive function
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
<    *
<    * \return the SNR for the PPDU in linear scale
<    */
<   double CalculatePayloadSnr (Ptr<Event> event) const;
<   /**
<    * Calculate the SNR per stream (taking into account inter-stream interference) and return
<    * a vector of SNR values (in the case of SISO transmission the vector has a single value, in the case of MIMO multiple)
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
<    *
<    * \return a vector of SNR for the PPDU in liner scale corresponding to the SNR per stream
<    */
<   std::vector<double> CalculatePerStreamSnr (Ptr<const Event> event, double noiseInterferenceW) const;
< 
<   //// WIGIG ////
< 
<   /**
<    * Calculate the SNIR at the start of the payload and accumulate
<    * all SNIR changes in the SNIR vector for each MPDU of an A-MPDU.
<    * This workaround is required in order to provide one PER per MPDU, for
<    * reception success/failure evaluation, while hiding aggregation details from
<    * this class.
<    *
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
<    * \param relativeMpduStartStop the time window (pair of start and end times) of PHY payload to focus on
<    *
<    * \return struct of SNR and PER (with PER being evaluated over the provided time window)
<    */
<   struct InterferenceHelper::SnrPer CalculatePayloadSnrPer (Ptr<Event> event, std::pair<Time, Time> relativeMpduStartStop) const;
<   /**
<    * Calculate the SNIR for the event (starting from now until the event end).
<    *
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
<    *
<    * \return the SNR for the PPDU in linear scale
<    */
<   double CalculateSnr (Ptr<Event> event) const;
<   /**
<    * Calculate the SNIR at the start of the non-HT PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
<    *
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
<    *
<    * \return struct of SNR and PER
<    */
<   struct InterferenceHelper::SnrPer CalculateNonHtPhyHeaderSnrPer (Ptr<Event> event) const;
<   /**
<    * Calculate the SNIR at the start of the HT PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
<    *
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
---
>    * \param event the event corresponding to the first time the corresponding packet arrives
346c199
<   struct InterferenceHelper::SnrPer CalculateHtPhyHeaderSnrPer (Ptr<Event> event) const;
---
>   struct InterferenceHelper::SnrPer CalculatePlcpPayloadSnrPer (Ptr<InterferenceHelper::Event> event);
348,349c201,202
<    * Calculate the SNIR at the start of the DMG PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
---
>    * Calculate the SNIR at the start of the plcp header and accumulate
>    * all SNIR changes in the snir vector.
351c204
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
---
>    * \param event the event corresponding to the first time the corresponding packet arrives
355c208
<   struct InterferenceHelper::SnrPer CalculateDmgPhyHeaderSnrPer (Ptr<Event> event) const;
---
>   struct InterferenceHelper::SnrPer CalculatePlcpHeaderSnrPer (Ptr<InterferenceHelper::Event> event);
371,408d223
< protected:
<   /**
<    * Calculate SNR (linear ratio) from the given signal power and noise+interference power.
<    *
<    * \param signal signal power, W
<    * \param noiseInterference noise and interference power, W
<    * \param txVector the TXVECTOR
<    *
<    * \return SNR in linear scale
<    */
<   double CalculateSnr (double signal, double noiseInterference, WifiTxVector txVector) const;
<   //// WIGIG ////
<   /**
<    * Calculate SNR (linear ratio) from the given list of signal power and noise+interference power.
<    * This is a special function and used for orthogonal EDMG TRN subfields.
<    *
<    * \param signal List of signals powers in Watts.
<    * \param noiseInterference noise and interference power, W
<    * \param txVector the TXVECTOR
<    *
<    * \return List of SNR values in linear scale
<    */
<   std::vector<double> CalculateSnr (std::vector<double> signalList, double noiseInterference, WifiTxVector txVector) const;
<   //// WIGIG ////
<   /**
<    * Calculate the success rate of the chunk given the SINR, duration, and Wi-Fi mode.
<    * The duration and mode are used to calculate how many bits are present in the chunk.
<    *
<    * \param snir the SINR
<    * \param duration the duration of the chunk
<    * \param mode the WifiMode
<    * \param txVector the TXVECTOR
<    *
<    * \return the success rate
<    */
<   double CalculateChunkSuccessRate (double snir, Time duration, WifiMode mode, WifiTxVector txVector) const;
< 
< 
419,420c234,235
<      * \param power the power in watts
<      * \param event causes this NI change
---
>      * \param time time of the event
>      * \param delta the power
422c237
<     NiChange (double power, Ptr<Event> event);
---
>     NiChange (Time time, double delta);
424c239
<      * Return the power
---
>      * Return the event time.
426c241
<      * \return the power in watts
---
>      * \return the event time.
428c243
<     double GetPower (void) const;
---
>     Time GetTime (void) const;
430c245
<      * Add a given amount of power.
---
>      * Return the power
432c247
<      * \param power the power to be added to the existing value in watts
---
>      * \return the power
434c249
<     void AddPower (double power);
---
>     double GetDelta (void) const;
436c251
<      * Return the event causes the corresponding NI change
---
>      * Compare the event time of two NiChange objects (a < o).
438c253,254
<      * \return the event
---
>      * \param o
>      * \return true if a < o.time, false otherwise
440c256
<     Ptr<Event> GetEvent (void) const;
---
>     bool operator < (const NiChange& o) const;
444,445c260,261
<     double m_power; ///< power in watts
<     Ptr<Event> m_event; ///< event
---
>     Time m_time;
>     double m_delta;
447d262
< 
449c264
<    * typedef for a multimap of NiChanges
---
>    * typedef for a vector of NiChanges
451c266,270
<   typedef std::multimap<Time, NiChange> NiChanges;
---
>   typedef std::vector <NiChange> NiChanges;
>   /**
>    * typedef for a list of Events
>    */
>   typedef std::list<Ptr<Event> > Events;
462,463c281,282
<    * \param event the event
<    * \param ni the NiChanges
---
>    * \param event
>    * \param ni
469,482c288,289
<    * Calculate the success rate of the payload chunk given the SINR, duration, and Wi-Fi mode.
<    * The duration and mode are used to calculate how many bits are present in the chunk.
<    *
<    * \param snir the SINR
<    * \param duration the duration of the chunk
<    * \param txVector the TXVECTOR
<    *
<    * \return the success rate
<    */
<   double CalculatePayloadChunkSuccessRate (double snir, Time duration, WifiTxVector txVector) const;
<   /**
<    * Calculate the error rate of the given PHY payload only in the provided time
<    * window (thus enabling per MPDU PER information). The PHY payload can be divided into
<    * multiple chunks (e.g. due to interference from other transmissions).
---
>    * Calculate SNR (linear ratio) from the given signal power and noise+interference power.
>    * (Mode is not currently used)
484,486c291,293
<    * \param event the event
<    * \param ni the NiChanges
<    * \param window time window (pair of start and end times) of PHY payload to focus on
---
>    * \param signal
>    * \param noiseInterference
>    * \param channelWidth
488c295
<    * \return the error rate of the payload
---
>    * \return SNR in liear ratio
490c297
<   double CalculatePayloadPer (Ptr<const Event> event, NiChanges *ni, std::pair<Time, Time> window) const;
---
>   double CalculateSnr (double signal, double noiseInterference, uint32_t channelWidth) const;
492,493c299,300
<    * Calculate the error rate of the non-HT PHY header. The non-HT PHY header
<    * can be divided into multiple chunks (e.g. due to interference from other transmissions).
---
>    * Calculate the success rate of the chunk given the SINR, duration, and Wi-Fi mode.
>    * The duration and mode are used to calculate how many bits are present in the chunk.
495,496c302,305
<    * \param event the event
<    * \param ni the NiChanges
---
>    * \param snir SINR
>    * \param duration
>    * \param mode
>    * \param txVector
498c307
<    * \return the error rate of the non-HT PHY header
---
>    * \return the success rate
500c309
<   double CalculateNonHtPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const;
---
>   double CalculateChunkSuccessRate (double snir, Time duration, WifiMode mode, WifiTxVector txVector) const;
502,503c311,312
<    * Calculate the error rate of the HT PHY header. TheHT PHY header
<    * can be divided into multiple chunks (e.g. due to interference from other transmissions).
---
>    * Calculate the error rate of the given plcp payload. The plcp payload can be divided into
>    * multiple chunks (e.g. due to interference from other transmissions).
505,506c314,315
<    * \param event the event
<    * \param ni the NiChanges
---
>    * \param event
>    * \param ni
508c317
<    * \return the error rate of the HT PHY header
---
>    * \return the error rate of the packet
510c319
<   double CalculateHtPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const;
---
>   double CalculatePlcpPayloadPer (Ptr<const Event> event, NiChanges *ni) const;
512,513c321,322
<    * Calculate the error rate of the DMG PHY header. The DMG PHY header
<    * can be divided into multiple chunks (e.g. due to interference from other transmissions).
---
>    * Calculate the error rate of the plcp header. The plcp header can be divided into
>    * multiple chunks (e.g. due to interference from other transmissions).
515,516c324,325
<    * \param event the event
<    * \param ni the NiChanges
---
>    * \param event
>    * \param ni
518c327
<    * \return the error rate of the DMG PHY header
---
>    * \return the error rate of the packet
520c329
<   double CalculateDmgPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const;
---
>   double CalculatePlcpHeaderPer (Ptr<const Event> event, NiChanges *ni) const;
522d330
<   Ptr<WifiPhy> m_wifiPhy;
524,525c332
<   Ptr<ErrorRateModel> m_errorRateModel; ///< error rate model
<   uint8_t m_numRxAntennas; /**< the number of RX antennas in the corresponding receiver */
---
>   Ptr<ErrorRateModel> m_errorRateModel;
528,552c335,338
<   double m_firstPower; ///< first power in watts
<   bool m_rxing; ///< flag whether it is in receiving state
< 
<   /**
<    * Returns an iterator to the first NiChange that is later than moment
<    *
<    * \param moment time to check from
<    * \returns an iterator to the list of NiChanges
<    */
<   NiChanges::const_iterator GetNextPosition (Time moment) const;
<   /**
<    * Returns an iterator to the first NiChange that is later than moment
<    *
<    * \param moment time to check from
<    * \returns an iterator to the list of NiChanges
<    */
<   //NiChanges::iterator GetNextPosition (Time moment);
<   /**
<    * Returns an iterator to the last NiChange that is before than moment
<    *
<    * \param moment time to check from
<    * \returns an iterator to the list of NiChanges
<    */
<   NiChanges::const_iterator GetPreviousPosition (Time moment) const;
< 
---
>   double m_firstPower;
>   bool m_rxing;
>   /// Returns an iterator to the first nichange, which is later than moment
>   NiChanges::iterator GetPosition (Time moment);
554,555c340
<    * Add NiChange to the list at the appropriate position and
<    * return the iterator of the new event.
---
>    * Add NiChange to the list at the appropriate position.
557,559c342
<    * \param moment time to check from
<    * \param change the NiChange to add
<    * \returns the iterator of the new event
---
>    * \param change
561c344
<   NiChanges::iterator AddNiChangeEvent (Time moment, NiChange change);
---
>   void AddNiChangeEvent (NiChange change);
diff ../../NS3-WiGig/src/wifi/model/mac-low.cc ../../ns-3-dev/src/wifi/model/mac-low.cc
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
22,23d20
<  *          Stefano Avallone <stavallo@unina.it>
<  *          Hany Assasa <hany.assasa@gmail.com>
25a23,24
> #include "ns3/assert.h"
> #include "ns3/packet.h"
26a26
> #include "ns3/tag.h"
27a28,30
> #include "ns3/node.h"
> #include "ns3/socket.h"
> #include "ns3/double.h"
29c32,35
< #include "qos-txop.h"
---
> #include "wifi-phy.h"
> #include "wifi-mac-trailer.h"
> #include "qos-utils.h"
> #include "edca-txop-n.h"
30a37
> #include "yans-wifi-phy.h"
33,51d39
< #include "wifi-psdu.h"
< #include "wifi-utils.h"
< #include "ctrl-headers.h"
< #include "mgt-headers.h"
< #include "wifi-remote-station-manager.h"
< #include "mpdu-aggregator.h"
< #include "msdu-aggregator.h"
< #include "ampdu-subframe-header.h"
< #include "dmg-wifi-mac.h"
< #include "dmg-wifi-phy.h"
< #include "dmg-sta-wifi-mac.h"
< #include "wifi-phy-listener.h"
< #include "wifi-mac-trailer.h"
< #include "wifi-phy.h"
< #include "wifi-net-device.h"
< #include "wifi-mac.h"
< #include <algorithm>
< #include "wifi-ack-policy-selector.h"
< #include "control-trailer.h"
56,60d43
< // Time (in nanoseconds) to be added to the PSDU duration to yield the duration
< // of the timer that is started when the PHY indicates the start of the reception
< // of a frame and we are waiting for a response.
< #define PSDU_DURATION_SAFEGUARD 400
< 
64a48,306
> MacLowTransmissionListener::MacLowTransmissionListener ()
> {
> }
> MacLowTransmissionListener::~MacLowTransmissionListener ()
> {
> }
> void
> MacLowTransmissionListener::GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address source, double rxSnr, WifiMode mode, double dataSnr)
> {
> }
> void
> MacLowTransmissionListener::MissedBlockAck (uint32_t nMpdus)
> {
> }
> 
> MacLowDcfListener::MacLowDcfListener ()
> {
> }
> MacLowDcfListener::~MacLowDcfListener ()
> {
> }
> 
> MacLowAggregationCapableTransmissionListener::MacLowAggregationCapableTransmissionListener ()
> {
> }
> MacLowAggregationCapableTransmissionListener::~MacLowAggregationCapableTransmissionListener ()
> {
> }
> void MacLowAggregationCapableTransmissionListener::SetAmpdu (Mac48Address dest, bool enableAmpdu)
> {
> }
> void MacLowAggregationCapableTransmissionListener::CompleteTransfer (Mac48Address address, uint8_t tid)
> {
> }
> void
> MacLowAggregationCapableTransmissionListener::CompleteMpduTx (Ptr<const Packet> packet, WifiMacHeader hdr, Time tstamp)
> {
> }
> uint16_t
> MacLowAggregationCapableTransmissionListener::GetNextSequenceNumberfor (WifiMacHeader *hdr)
> {
>   return 0;
> }
> uint16_t
> MacLowAggregationCapableTransmissionListener::PeekNextSequenceNumberfor (WifiMacHeader *hdr)
> {
>   return 0;
> }
> Ptr<const Packet>
> MacLowAggregationCapableTransmissionListener::PeekNextPacketInBaQueue (WifiMacHeader &header, Mac48Address recipient, uint8_t tid, Time *timestamp)
> {
>   return 0;
> }
> void
> MacLowAggregationCapableTransmissionListener::RemoveFromBaQueue (uint8_t tid, Mac48Address recipient, uint16_t seqnumber)
> {
> }
> uint32_t
> MacLowAggregationCapableTransmissionListener::GetNOutstandingPackets (Mac48Address recipient, uint8_t tid)
> {
>   return 0;
> }
> uint32_t
> MacLowAggregationCapableTransmissionListener::GetNRetryNeededPackets (Mac48Address recipient, uint8_t tid) const
> {
>   return 0;
> }
> Ptr<MsduAggregator>
> MacLowAggregationCapableTransmissionListener::GetMsduAggregator (void) const
> {
>   return 0;
> }
> Ptr<MpduAggregator>
> MacLowAggregationCapableTransmissionListener::GetMpduAggregator (void) const
> {
>   return 0;
> }
> Mac48Address
> MacLowAggregationCapableTransmissionListener::GetSrcAddressForAggregation (const WifiMacHeader &hdr)
> {
>   return 0;
> }
> Mac48Address
> MacLowAggregationCapableTransmissionListener::GetDestAddressForAggregation (const WifiMacHeader &hdr)
> {
>   return 0;
> }
> 
> MacLowTransmissionParameters::MacLowTransmissionParameters ()
>   : m_nextSize (0),
>     m_waitAck (ACK_NONE),
>     m_sendRts (false),
>     m_overrideDurationId (Seconds (0))
> {
> }
> void
> MacLowTransmissionParameters::EnableNextData (uint32_t size)
> {
>   m_nextSize = size;
> }
> void
> MacLowTransmissionParameters::DisableNextData (void)
> {
>   m_nextSize = 0;
> }
> void
> MacLowTransmissionParameters::EnableOverrideDurationId (Time durationId)
> {
>   m_overrideDurationId = durationId;
> }
> void
> MacLowTransmissionParameters::DisableOverrideDurationId (void)
> {
>   m_overrideDurationId = Seconds (0);
> }
> void
> MacLowTransmissionParameters::EnableSuperFastAck (void)
> {
>   m_waitAck = ACK_SUPER_FAST;
> }
> void
> MacLowTransmissionParameters::EnableBasicBlockAck (void)
> {
>   m_waitAck = BLOCK_ACK_BASIC;
> }
> void
> MacLowTransmissionParameters::EnableCompressedBlockAck (void)
> {
>   m_waitAck = BLOCK_ACK_COMPRESSED;
> }
> void
> MacLowTransmissionParameters::EnableMultiTidBlockAck (void)
> {
>   m_waitAck = BLOCK_ACK_MULTI_TID;
> }
> void
> MacLowTransmissionParameters::EnableFastAck (void)
> {
>   m_waitAck = ACK_FAST;
> }
> void
> MacLowTransmissionParameters::EnableAck (void)
> {
>   m_waitAck = ACK_NORMAL;
> }
> void
> MacLowTransmissionParameters::DisableAck (void)
> {
>   m_waitAck = ACK_NONE;
> }
> void
> MacLowTransmissionParameters::EnableRts (void)
> {
>   m_sendRts = true;
> }
> void
> MacLowTransmissionParameters::DisableRts (void)
> {
>   m_sendRts = false;
> }
> bool
> MacLowTransmissionParameters::MustWaitAck (void) const
> {
>   return (m_waitAck != ACK_NONE);
> }
> bool
> MacLowTransmissionParameters::MustWaitNormalAck (void) const
> {
>   return (m_waitAck == ACK_NORMAL);
> }
> bool
> MacLowTransmissionParameters::MustWaitFastAck (void) const
> {
>   return (m_waitAck == ACK_FAST);
> }
> bool
> MacLowTransmissionParameters::MustWaitSuperFastAck (void) const
> {
>   return (m_waitAck == ACK_SUPER_FAST);
> }
> bool
> MacLowTransmissionParameters::MustWaitBasicBlockAck (void) const
> {
>   return (m_waitAck == BLOCK_ACK_BASIC) ? true : false;
> }
> bool
> MacLowTransmissionParameters::MustWaitCompressedBlockAck (void) const
> {
>   return (m_waitAck == BLOCK_ACK_COMPRESSED) ? true : false;
> }
> bool
> MacLowTransmissionParameters::MustWaitMultiTidBlockAck (void) const
> {
>   return (m_waitAck == BLOCK_ACK_MULTI_TID) ? true : false;
> }
> bool
> MacLowTransmissionParameters::MustSendRts (void) const
> {
>   return m_sendRts;
> }
> bool
> MacLowTransmissionParameters::HasDurationId (void) const
> {
>   return (m_overrideDurationId != Seconds (0));
> }
> Time
> MacLowTransmissionParameters::GetDurationId (void) const
> {
>   NS_ASSERT (m_overrideDurationId != Seconds (0));
>   return m_overrideDurationId;
> }
> bool
> MacLowTransmissionParameters::HasNextPacket (void) const
> {
>   return (m_nextSize != 0);
> }
> uint32_t
> MacLowTransmissionParameters::GetNextPacketSize (void) const
> {
>   NS_ASSERT (HasNextPacket ());
>   return m_nextSize;
> }
> 
> std::ostream &operator << (std::ostream &os, const MacLowTransmissionParameters &params)
> {
>   os << "["
>      << "send rts=" << params.m_sendRts << ", "
>      << "next size=" << params.m_nextSize << ", "
>      << "dur=" << params.m_overrideDurationId << ", "
>      << "ack=";
>   switch (params.m_waitAck)
>     {
>     case MacLowTransmissionParameters::ACK_NONE:
>       os << "none";
>       break;
>     case MacLowTransmissionParameters::ACK_NORMAL:
>       os << "normal";
>       break;
>     case MacLowTransmissionParameters::ACK_FAST:
>       os << "fast";
>       break;
>     case MacLowTransmissionParameters::ACK_SUPER_FAST:
>       os << "super-fast";
>       break;
>     case MacLowTransmissionParameters::BLOCK_ACK_BASIC:
>       os << "basic-block-ack";
>       break;
>     case MacLowTransmissionParameters::BLOCK_ACK_COMPRESSED:
>       os << "compressed-block-ack";
>       break;
>     case MacLowTransmissionParameters::BLOCK_ACK_MULTI_TID:
>       os << "multi-tid-block-ack";
>       break;
>     }
>   os << "]";
>   return os;
> }
> 
> 
83c325
<   void NotifyRxStart (Time duration)
---
>   virtual void NotifyRxStart (Time duration)
86c328
<   void NotifyRxEndOk (void)
---
>   virtual void NotifyRxEndOk (void)
89c331
<   void NotifyRxEndError (void)
---
>   virtual void NotifyRxEndError (void)
92c334
<   void NotifyTxStart (Time duration, double txPowerDbm)
---
>   virtual void NotifyTxStart (Time duration, double txPowerDbm)
95c337
<   void NotifyMaybeCcaBusyStart (Time duration)
---
>   virtual void NotifyMaybeCcaBusyStart (Time duration)
98c340
<   void NotifySwitchingStart (Time duration)
---
>   virtual void NotifySwitchingStart (Time duration)
102c344
<   void NotifySleep (void)
---
>   virtual void NotifySleep (void)
106,113c348
<   void NotifyOff (void)
<   {
<     m_macLow->NotifyOffNow ();
<   }
<   void NotifyWakeup (void)
<   {
<   }
<   void NotifyOn (void)
---
>   virtual void NotifyWakeup (void)
116d350
< 
118c352
<   ns3::MacLow *m_macLow; ///< the MAC
---
>   ns3::MacLow *m_macLow;
123,125c357,360
<   : m_msduAggregator (0),
<     m_mpduAggregator (0),
<     m_normalAckTimeoutEvent (),
---
>   : m_normalAckTimeoutEvent (),
>     m_fastAckTimeoutEvent (),
>     m_superFastAckTimeoutEvent (),
>     m_fastAckFailedTimeoutEvent (),
131c366
<     m_waitIfsEvent (),
---
>     m_waitSifsEvent (),
134,140c369
<     m_currentTxop (0),
<     m_lastNavStart (Seconds (0)),
<     m_lastNavDuration (Seconds (0)),
<     m_cfpStart (Seconds (0)),
<     m_lastBeacon (Seconds (0)),
<     m_cfpForeshortening (Seconds (0)),
<     m_promisc (false),
---
>     m_listener (0),
143,147c372
<     m_cfAckInfo (),
<     m_transmissionSuspended (false),
<     m_restoredSuspendedTransmission (false),
<     m_servingSLS (false),
<     m_servingMimoBFT (false)
---
>     m_nTxMpdus (0)
149a375,380
>   m_lastNavDuration = Seconds (0);
>   m_lastNavStart = Seconds (0);
>   m_promisc = false;
>   m_ampdu = false;
>   m_sentMpdus = 0;
>   m_aggregateQueue = CreateObject<WifiMacQueue> ();
170c401
< MacLow::SetupPhyMacLowListener (const Ptr<WifiPhy> phy)
---
> MacLow::SetupPhyMacLowListener (Ptr<WifiPhy> phy)
191a423,425
>   m_fastAckTimeoutEvent.Cancel ();
>   m_superFastAckTimeoutEvent.Cancel ();
>   m_fastAckFailedTimeoutEvent.Cancel ();
197c431
<   m_waitIfsEvent.Cancel ();
---
>   m_waitSifsEvent.Cancel ();
199,200c433
<   m_msduAggregator = 0;
<   m_mpduAggregator = 0;
---
>   m_waitRifsEvent.Cancel ();
207a441,443
>   m_sentMpdus = 0;
>   m_aggregateQueue = 0;
>   m_ampdu = false;
219a456,470
>   if (m_fastAckTimeoutEvent.IsRunning ())
>     {
>       m_fastAckTimeoutEvent.Cancel ();
>       oneRunning = true;
>     }
>   if (m_superFastAckTimeoutEvent.IsRunning ())
>     {
>       m_superFastAckTimeoutEvent.Cancel ();
>       oneRunning = true;
>     }
>   if (m_fastAckFailedTimeoutEvent.IsRunning ())
>     {
>       m_fastAckFailedTimeoutEvent.Cancel ();
>       oneRunning = true;
>     }
245c496,501
<   if (m_waitIfsEvent.IsRunning ())
---
>   if (m_waitSifsEvent.IsRunning ())
>     {
>       m_waitSifsEvent.Cancel ();
>       oneRunning = true;
>     }
>   if (m_waitRifsEvent.IsRunning ())
247c503
<       m_waitIfsEvent.Cancel ();
---
>       m_waitRifsEvent.Cancel ();
255c511
<   if (oneRunning && m_currentTxop != 0)
---
>   if (oneRunning && m_listener != 0)
257,258c513,514
<       m_currentTxop->Cancel ();
<       m_currentTxop = 0;
---
>       m_listener->Cancel ();
>       m_listener = 0;
263c519
< MacLow::SetPhy (const Ptr<WifiPhy> phy)
---
> MacLow::SetPhy (Ptr<WifiPhy> phy)
266d521
<   m_phy->TraceConnectWithoutContext ("PhyRxPayloadBegin", MakeCallback (&MacLow::RxStartIndication, this));
281,283c536,537
<   m_phy->TraceDisconnectWithoutContext ("PhyRxPayloadBegin", MakeCallback (&MacLow::RxStartIndication, this));
<   m_phy->SetReceiveOkCallback (MakeNullCallback<void, Ptr<WifiPsdu>, double, WifiTxVector, std::vector<bool>> ());
<   m_phy->SetReceiveErrorCallback (MakeNullCallback<void, Ptr<WifiPsdu>> ());
---
>   m_phy->SetReceiveOkCallback (MakeNullCallback<void, Ptr<Packet>, double, WifiTxVector, enum WifiPreamble> ());
>   m_phy->SetReceiveErrorCallback (MakeNullCallback<void, Ptr<Packet>, double> ());
288,301d541
< Ptr<QosTxop>
< MacLow::GetEdca (uint8_t tid) const
< {
<   auto it = m_edca.find (QosUtilsMapTidToAc (tid));
<   NS_ASSERT (it != m_edca.end ());
<   return it->second;
< }
< 
< void
< MacLow::SetMac (const Ptr<WifiMac> mac)
< {
<   m_mac = mac;
< }
< 
303c543
< MacLow::SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> manager)
---
> MacLow::SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> manager)
308,333d547
< Ptr<MsduAggregator>
< MacLow::GetMsduAggregator (void) const
< {
<   return m_msduAggregator;
< }
< 
< Ptr<MpduAggregator>
< MacLow::GetMpduAggregator (void) const
< {
<   return m_mpduAggregator;
< }
< 
< void
< MacLow::SetMsduAggregator (const Ptr<MsduAggregator> aggr)
< {
<   NS_LOG_FUNCTION (this << aggr);
<   m_msduAggregator = aggr;
< }
< 
< void
< MacLow::SetMpduAggregator (const Ptr<MpduAggregator> aggr)
< {
<   NS_LOG_FUNCTION (this << aggr);
<   m_mpduAggregator = aggr;
< }
< 
365c579
< MacLow::GetCtsToSelfSupported (void) const
---
> MacLow::GetCtsToSelfSupported () const
371,384c585
< MacLow::SetSifs (Time sifs)
< {
<   m_sifs = sifs;
< }
< 
< //// WIGIG ////
< void
< MacLow::SetSbifs (Time sbifs)
< {
<   m_sbifs = sbifs;
< }
< 
< void
< MacLow::SetMbifs (Time mbifs)
---
> MacLow::SetCtsTimeout (Time ctsTimeout)
386c587
<   m_mbifs = mbifs;
---
>   m_ctsTimeout = ctsTimeout;
390,396c591
< MacLow::SetLbifs (Time lbifs)
< {
<   m_lbifs = lbifs;
< }
< 
< void
< MacLow::SetBrifs (Time brifs)
---
> MacLow::SetSifs (Time sifs)
398c593
<   m_brifs = brifs;
---
>   m_sifs = sifs;
400d594
< //// WIGIG ////
421,432d614
< MacLow::SetBeaconInterval (Time interval)
< {
<   m_beaconInterval = interval;
< }
< 
< void
< MacLow::SetCfpMaxDuration (Time cfpMaxDuration)
< {
<   m_cfpMaxDuration = cfpMaxDuration;
< }
< 
< void
457c639
< MacLow::GetBasicBlockAckTimeout (void) const
---
> MacLow::GetBasicBlockAckTimeout () const
463c645
< MacLow::GetCompressedBlockAckTimeout (void) const
---
> MacLow::GetCompressedBlockAckTimeout () const
468a651,656
> MacLow::GetCtsTimeout (void) const
> {
>   return m_ctsTimeout;
> }
> 
> Time
492,517d679
< //// WIGIG ////
< Time
< MacLow::GetSbifs (void) const
< {
<   return m_sbifs;
< }
< 
< Time
< MacLow::GetMbifs (void) const
< {
<   return m_mbifs;
< }
< 
< Time
< MacLow::GetLbifs (void) const
< {
<   return m_lbifs;
< }
< 
< Time
< MacLow::GetBrifs (void) const
< {
<   return m_brifs;
< }
< //// WIGIG ////
< 
524,535d685
< Time
< MacLow::GetBeaconInterval (void) const
< {
<   return m_beaconInterval;
< }
< 
< Time
< MacLow::GetCfpMaxDuration (void) const
< {
<   return m_cfpMaxDuration;
< }
< 
543c693
< MacLow::SetRxCallback (Callback<void, Ptr<WifiMacQueueItem>> callback)
---
> MacLow::SetRxCallback (Callback<void, Ptr<Packet>, const WifiMacHeader *> callback)
549,698c699
< MacLow::RegisterChannelAccessManager (Ptr<ChannelAccessManager> channelAccessManager)
< {
<   m_channelAccessManagers.push_back (channelAccessManager);
< }
< 
< //// WIGIG ////
< 
< bool
< MacLow::IsCurrentAllocationEmpty (void) const
< {
<   return m_currentAllocation == 0;
< }
< 
< void
< MacLow::ResumeTransmission (Time duration, Ptr<Txop> txop)
< {
<   NS_LOG_FUNCTION (this << duration << txop);
< 
<   NS_ASSERT_MSG (!IsCurrentAllocationEmpty (), "Restored allocation should not be empty");
< 
<   NS_LOG_DEBUG ("IsAmpdu=" << m_currentAllocation->psdu->IsAggregate ()
<                 << ", PacketSize=" << m_currentAllocation->psdu->GetSize ()
<                 << ", seq=0x" << std::hex << m_currentAllocation->psdu->GetHeader (0).GetSequenceControl () << std::dec);
< 
<   /* Restore the vaiables associated to the current allocation */
<   m_restoredSuspendedTransmission = false;
<   m_currentPacket = m_currentAllocation->psdu;
<   m_txParams = m_currentAllocation->txParams;
<   m_currentTxVector = m_currentAllocation->txVector;
< 
<   /* Check if the remaining time is enough to resume previously suspended transmission */
<   Time transactionTime = CalculateWiGigTransactionTime (m_currentPacket);
<   NS_LOG_DEBUG ("TransactionTime=" << transactionTime <<
<                 ", RemainingTime=" << txop->GetAllocationRemaining ());
<   if (transactionTime <= duration)
<     {
<       /* This only applies for service period */
<       CancelAllEvents ();
<       m_currentTxop = txop;
< 
<       if (m_txParams.MustSendRts ())
<         {
<           SendRtsForPacket ();
<         }
<       else
<         {
<           SendDataPacket ();
<         }
< 
<       /* When this method completes, either we have taken ownership of the medium or the device switched off in the meantime. */
<       NS_ASSERT (m_phy->IsStateTx () || m_phy->IsStateOff ());
<     }
<   else
<     {
<       m_transmissionSuspended = true;
<     }
< 
<   /* Remove suspended allocaion related parameters as we've restored it */
<   m_allocationPeriodsTable.erase (m_currentAllocationID);
< }
< 
< void
< MacLow::AbortSuspendedTransmission (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_restoredSuspendedTransmission = false;
<   m_currentAllocation = 0;
<   m_allocationPeriodsTable.erase (m_currentAllocationID);
< }
< 
< void
< MacLow::ChangeAllocationPacketsAddress (AllocationID allocationId, Mac48Address destAdd)
< {
<   NS_LOG_FUNCTION (this << uint16_t (allocationId) << destAdd);
<   /* Find the stored parameters and packets for the provided allocation */
<   AllocationPeriodsTableI it = m_allocationPeriodsTable.find (m_currentAllocationID);
<   if (it != m_allocationPeriodsTable.end ())
<     {
<       NS_LOG_DEBUG ("Changing Receiver Address for Packets stored for AllocationID=" << uint16_t (allocationId));
< //      it->second.psdu.SetAddr1 (destAdd);
<     }
<   else
<     {
<       NS_LOG_DEBUG ("No allocation parameters stored for AllocationID=" << uint16_t (allocationId));
<     }
< }
< 
< void
< MacLow::RestoreAllocationParameters (AllocationID allocationId)
< {
<   NS_LOG_FUNCTION (this << static_cast<uint16_t> (allocationId));
<   m_transmissionSuspended = false;  /* Transmission is not suspended anymore */
<   m_currentAllocationID = allocationId;
<   /* Find the stored parameters and packets for the provided allocation */
<   AllocationPeriodsTableCI it = m_allocationPeriodsTable.find (m_currentAllocationID);
<   if (it != m_allocationPeriodsTable.end ())
<     {
<       NS_LOG_DEBUG ("Restored allocation parameters for AllocationID=" << uint16_t (allocationId));
<       m_currentAllocation = it->second;
<       m_restoredSuspendedTransmission = true;
<     }
<   else
<     {
<       NS_LOG_DEBUG ("No allocation parameters stored for AllocationID=" << uint16_t (allocationId));
<       m_restoredSuspendedTransmission = false;
<       m_currentAllocation = 0;
<     }
< }
< 
< void
< MacLow::StoreAllocationParameters (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_LOG_DEBUG ("CurrentPacket=" << m_currentPacket);
<   if (m_currentPacket != 0
<       && m_currentPacket->GetHeader (0).IsQosData ())
<     {
<       /* Since CurrentPacket is not empty it means we've suspended an ongoing transmission */
<       Ptr<AllocationParameters> allocationParams = Create<AllocationParameters> ();
<       allocationParams->psdu = m_currentPacket;
<       allocationParams->txParams = m_txParams;
<       allocationParams->txVector = m_currentTxVector;
<       allocationParams->txop = m_currentTxop;
<       m_allocationPeriodsTable[m_currentAllocationID] = allocationParams;
<       NS_LOG_DEBUG ("PSDU Size=" << m_currentPacket->GetSize ()
<                     << ", seq=0x" << std::hex << m_currentPacket->GetHeader (0).GetSequenceControl () << std::dec
<                     << ", Txop=" << m_currentTxop);
<     }
<   m_currentPacket = 0;
<   m_currentAllocation = 0;
< }
< 
< void
< MacLow::EndAllocationPeriod (void)
< {
<   NS_LOG_FUNCTION (this);
<   CancelAllEvents ();
<   StoreAllocationParameters ();
<   if (m_navCounterResetCtsMissed.IsRunning ())
<     {
<       m_navCounterResetCtsMissed.Cancel ();
<     }
<   m_lastNavStart = Simulator::Now ();
<   m_lastNavDuration = Seconds (0);
<   m_currentTxop = 0;
< //  m_phy->EndAllocationPeriod ();
< }
< 
< bool
< MacLow::IsTransmissionSuspended (void) const
---
> MacLow::RegisterDcfListener (MacLowDcfListener *listener)
700c701
<   return m_transmissionSuspended;
---
>   m_dcfListeners.push_back (listener);
704c705
< MacLow::CompletedSuspendedPsduTransmission (Ptr<Txop> txop) const
---
> MacLow::IsAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
706,724c707,712
<   NS_LOG_FUNCTION (this << txop);
<   NS_LOG_DEBUG ("Restored Suspended Transmission=" << m_restoredSuspendedTransmission);
<   if (m_restoredSuspendedTransmission
<       && !IsCurrentAllocationEmpty ()
<       && m_currentAllocation->txop == txop)
<     {
<       return false;
<     }
<   else
<     {
<       return true;
<     }
< }
< 
< bool
< MacLow::SwitchInTransmissionMode (void) const
< {
<   Mac48Address address = m_currentAllocation->psdu->GetAddr1 ();
<   if (m_currentAllocation->txVector.Get_NUM_STS () != StaticCast<DmgWifiMac> (m_mac)->GetStationNStreams (address))
---
>   uint32_t size, actualSize;
>   WifiMacTrailer fcs;
>   size = packet->GetSize () + hdr.GetSize () + fcs.GetSerializedSize ();
>   Ptr<Packet> p = AggregateToAmpdu (packet, hdr);
>   actualSize = p->GetSize ();
>   if (actualSize > size)
726,727c714
<       NS_LOG_INFO ("The number of space-time streams in the saved allocation and the one currently calculate do not match. There has been a switch in"
<                    "the transmission mode");
---
>       m_currentPacket = p;
732,733d718
<       NS_LOG_INFO ("The number of space-time streams in the saved allocation and the one currently calculate match. There has not been a switch in"
<                    "the transmission mode");
737d721
< //// WIGIG ////
740c724,725
< MacLow::StartTransmission (Ptr<WifiMacQueueItem> mpdu,
---
> MacLow::StartTransmission (Ptr<const Packet> packet,
>                            const WifiMacHeader* hdr,
742c727
<                            Ptr<Txop> txop)
---
>                            MacLowTransmissionListener *listener)
744,750c729
<   NS_LOG_FUNCTION (this << *mpdu << params << txop);
<   NS_ASSERT (!m_cfAckInfo.expectCfAck);
<   if (m_phy->IsStateOff ())
<     {
<       NS_LOG_DEBUG ("Cannot start TX because device is OFF");
<       return;
<     }
---
>   NS_LOG_FUNCTION (this << packet << hdr << params << listener);
763c742
<    * one of the EDCA of the QAP.
---
>    * one of the Edca of the QAP.
765,766c744,748
<   m_currentPacket = Create<WifiPsdu> (mpdu, false);
<   const WifiMacHeader& hdr = mpdu->GetHeader ();
---
>   m_currentPacket = packet->Copy ();
>   // remove the priority tag attached, if any
>   SocketPriorityTag priorityTag;
>   m_currentPacket->RemovePacketTag (priorityTag);
>   m_currentHdr = *hdr;
768c750
<   m_currentTxop = txop;
---
>   m_listener = listener;
770,774c752,754
<   if (hdr.IsCtl ())
<     {
<       m_currentTxVector = GetRtsTxVector (mpdu);
<     }
<   else
---
>   m_currentTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
> 
>   if (!m_currentHdr.IsQosData () && !m_currentHdr.IsBlockAck () && !m_currentHdr.IsBlockAckReq ())
776c756,759
<       m_currentTxVector = GetDataTxVector (mpdu);
---
>       //This is mainly encountered when a higher priority control frame (such as beacons)
>       //is sent between A-MPDU transmissions. It avoids to unexpectedly flush the aggregate
>       //queue when previous RTS request has failed.
>       m_ampdu = false;
778,788c761
< 
<   /* The packet received by this function can be any of the following:
<    * (a) a management frame dequeued from the Txop
<    * (b) a non-QoS data frame dequeued from the Txop
<    * (c) a non-broadcast QoS Data frame peeked or dequeued from a QosTxop
<    * (d) a broadcast QoS data or DELBA Request frame dequeued from a QosTxop
<    * (e) a BlockAckReq or ADDBA Request frame
<    * (f) a fragment of non-QoS/QoS Data frame dequeued from the Txop/QosTxop
<    */
<   if (hdr.IsQosData () && !hdr.GetAddr1 ().IsBroadcast ()
<       && !hdr.IsMoreFragments () && hdr.GetFragmentNumber () == 0)
---
>   else if (m_aggregateQueue->GetSize () > 0)
790,852c763,767
<       // We get here if the received packet is a non-broadcast QoS data frame
<       uint8_t tid = hdr.GetQosTid ();
<       Ptr<QosTxop> qosTxop = m_edca.find (QosUtilsMapTidToAc (tid))->second;
< 
<       // if a TXOP limit exists, compute the remaining TXOP duration
<       Time txopLimit = Time::Min ();
<       //// WIGIG ////
<       if (m_currentTxop->GetTxopLimit ().IsStrictlyPositive () || m_currentTxop->GetAllocationRemaining ().IsStrictlyPositive ())
<         {
<           txopLimit = m_currentTxop->GetPpduDurationLimit (mpdu, params);
<           //NS_ASSERT (txopLimit.IsPositive ());
<         }   
<       // QosTxop may send us a peeked frame
<       Ptr<const WifiMacQueueItem> tmp = qosTxop->PeekFrameForTransmission ();
<       //// WIGIG ////
<       bool isPeeked = (tmp != 0 && tmp->GetPacket () == mpdu->GetPacket ());
< 
<       Ptr<WifiMacQueueItem> newMpdu;
<       // If the frame has been peeked, dequeue it if it meets the size and duration constraints
<       if (isPeeked)
<         {
<           newMpdu = qosTxop->DequeuePeekedFrame (mpdu, m_currentTxVector, true, 0, txopLimit);
<         }
<       else if (IsWithinSizeAndTimeLimits (mpdu, m_currentTxVector, 0, txopLimit))
<         {
<           newMpdu = mpdu;
<         }
< 
<       if (newMpdu == 0)
<         {
<           // if the frame has been dequeued, then there is no BA agreement with the
<           // receiver (otherwise the frame would have been peeked). Hence, the frame
<           // has been sent under Normal Ack policy, not acknowledged and now retransmitted.
<           // If we cannot send it now, let the QosTxop retransmit it again.
<           // If the frame has been just peeked, reset the current packet at QosTxop.
<           if (isPeeked)
<             {
<               //// WIGIG ////
<               m_currentPacket = 0;
<               //// WIGIG ////
<               qosTxop->UpdateCurrentPacket (Create<WifiMacQueueItem> (nullptr, WifiMacHeader ()));
<             }
<           return;
<         }
<       // Update the current packet at QosTxop, given that A-MSDU aggregation may have
<       // been performed on the peeked frame
<       qosTxop->UpdateCurrentPacket (newMpdu);
< 
<       //// WIGIG ////
<       /* Since we might perform A-MPDU aggregation, update txopLimit to take into account the correct
<        * size of A-MPDU aggregation */
<       if (m_currentTxop->GetTxopLimit ().IsStrictlyPositive () || m_currentTxop->GetAllocationRemaining ().IsStrictlyPositive ())
<         {
<           /* Get temporary TransmissionLow Parameters for A-MPDU */
<           MacLowTransmissionParameters tempParams = qosTxop->GetAckPolicySelector ()->GetTemporaryParams (m_currentPacket, params);
<           txopLimit = m_currentTxop->GetPpduDurationLimit (mpdu, tempParams);
< //          NS_ASSERT (txopLimit.IsPositive ());
<         }
<       //// WIGIG ////
< 
<       //Perform MPDU aggregation if possible
<       std::vector<Ptr<WifiMacQueueItem>> mpduList;
<       if (m_mpduAggregator != 0)
---
>       //m_aggregateQueue > 0 occurs when a RTS/CTS exchange failed before an A-MPDU transmission.
>       //In that case, we transmit the same A-MPDU as previously.
>       m_sentMpdus = m_aggregateQueue->GetSize ();
>       m_ampdu = true;
>       if (m_sentMpdus > 1)
854c769
<           mpduList = m_mpduAggregator->GetNextAmpdu (newMpdu, m_currentTxVector, txopLimit);
---
>           m_txParams.EnableCompressedBlockAck ();
856,857c771
< 
<       if (mpduList.size () > 1)
---
>       else if (m_currentHdr.IsQosData ())
859,862c773,774
<           m_currentPacket = Create<WifiPsdu> (mpduList);
< 
<           NS_LOG_DEBUG ("tx unicast A-MPDU containing " << mpduList.size () << " MPDUs");
<           qosTxop->SetAmpduExist (hdr.GetAddr1 (), true);
---
>           //VHT single MPDUs are followed by normal ACKs
>           m_txParams.EnableAck ();
864,873c776,781
<       else if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT
<                || m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
<         {
<           // VHT/HE single MPDU
<           m_currentPacket = Create<WifiPsdu> (newMpdu, true);
< 
<           NS_LOG_DEBUG ("tx unicast S-MPDU with sequence number " << hdr.GetSequenceNumber ());
<           qosTxop->SetAmpduExist (hdr.GetAddr1 (), true);
<         }
<       else  // HT
---
>     }
>   else
>     {
>       //Perform MPDU aggregation if possible
>       m_ampdu = IsAmpdu (m_currentPacket, m_currentHdr);
>       if (m_ampdu)
875c783,793
<           m_currentPacket = Create<WifiPsdu> (newMpdu, false);
---
>           AmpduTag ampdu;
>           m_currentPacket->PeekPacketTag (ampdu);
>           if (ampdu.GetRemainingNbOfMpdus () > 0)
>             {
>               m_txParams.EnableCompressedBlockAck ();
>             }
>           else if (m_currentHdr.IsQosData ())
>             {
>               //VHT single MPDUs are followed by normal ACKs
>               m_txParams.EnableAck ();
>             }
877,881c795,803
< 
<       // A QoS Txop must have an installed ack policy selector
<       NS_ASSERT (qosTxop->GetAckPolicySelector () != 0);
<       qosTxop->GetAckPolicySelector ()->UpdateTxParams (m_currentPacket, m_txParams);
<       qosTxop->GetAckPolicySelector ()->SetAckPolicy (m_currentPacket, m_txParams);
---
>     }
>     
>   if (NeedRts ())
>     {
>       m_txParams.EnableRts ();
>     }
>   else
>     {
>       m_txParams.DisableRts ();
884,885c806,807
<   NS_LOG_DEBUG ("startTx size=" << m_currentPacket->GetSize () <<
<                 ", to=" << m_currentPacket->GetAddr1 () << ", txop=" << m_currentTxop);
---
>   NS_LOG_DEBUG ("startTx size=" << GetSize (m_currentPacket, &m_currentHdr) <<
>                 ", to=" << m_currentHdr.GetAddr1 () << ", listener=" << m_listener);
903,1042c825,826
<   /* When this method completes, either we have taken ownership of the medium or the device switched off in the meantime. */
<   NS_ASSERT (m_phy->IsStateTx () || m_phy->IsStateOff ());
< }
< 
< //// WIGIG ////
< void
< MacLow::TransmitSingleFrame (Ptr<WifiMacQueueItem> mpdu,
<                              MacLowTransmissionParameters params,
<                              Ptr<Txop> txop)
< {
<   NS_LOG_FUNCTION (this << *mpdu << params << txop);
<   if (m_phy->IsStateOff ())
<     {
<       NS_LOG_DEBUG ("Cannot start TX because device is OFF");
<       return;
<     }
<   m_currentPacket = Create<WifiPsdu> (mpdu, false);
<   CancelAllEvents ();
<   m_currentTxop = txop;
<   m_txParams = params;
<   m_currentTxVector = GetDmgTxVector (mpdu);
<   SendDataPacket ();
< 
<   /* When this method completes, either we have taken ownership of the medium or the device switched off in the meantime. */
<   NS_ASSERT (m_phy->IsStateTx () || m_phy->IsStateOff ());
< }
< 
< void
< MacLow::StartTransmission (Ptr<WifiMacQueueItem> mpdu,
<                            MacLowTransmissionParameters params,
<                            TransmissionOkCallback callback)
< {
<   NS_LOG_FUNCTION (this << *mpdu << params);
<   if (m_phy->IsStateOff ())
<     {
<       NS_LOG_DEBUG ("Cannot start TX because device is OFF");
<       return;
<     }
<   m_currentPacket = Create<WifiPsdu> (mpdu, false);
<   CancelAllEvents ();
<   m_currentTxop = 0;
<   m_transmissionCallback = callback;
<   m_txParams = params;
<   m_currentTxVector = GetDmgTxVector (mpdu);
<   SendDataPacket ();
< 
<   /* When this method completes, either we have taken ownership of the medium or the device switched off in the meantime. */
<   NS_ASSERT (m_phy->IsStateTx () || m_phy->IsStateOff ());
< }
< 
< void
< MacLow::StartShortSswTransmission (Ptr<WifiMacQueueItem> mpdu,
<                            MacLowTransmissionParameters params,
<                            TransmissionShortSswOkCallback callback)
< {
<   NS_LOG_FUNCTION (this << *mpdu << params);
<   if (m_phy->IsStateOff ())
<     {
<       NS_LOG_DEBUG ("Cannot start TX because device is OFF");
<       return;
<     }
<   m_currentPacket = Create<WifiPsdu> (mpdu, false);
<   CancelAllEvents ();
<   m_currentTxop = 0;
<   m_transmissionShortSswCallback = callback;
<   m_txParams = params;
<   m_currentTxVector = GetDmgControlTxVector ();
<   StartDataTxTimers (m_currentTxVector);
< 
<   NS_ASSERT (m_currentPacket->GetNMpdus ());
< 
<   NS_LOG_DEBUG ("send Short SSW, size=" << m_currentPacket->GetSize () <<
<                 ", mode=" << m_currentTxVector.GetMode  () <<
<                 ", preamble=" << m_currentTxVector.GetPreambleType ());
< 
<   NS_LOG_DEBUG ("Sending non aggregate MPDU");
<   m_phy->Send (m_currentPacket, m_currentTxVector);
< 
<   /* When this method completes, either we have taken ownership of the medium or the device switched off in the meantime. */
<   NS_ASSERT (m_phy->IsStateTx () || m_phy->IsStateOff ());
< }
< 
< void
< MacLow::SLS_Phase_Started (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_servingSLS = true;
<   /* We always prioritize SLS over any data transmission, so we cancel any events. */
<   if (m_normalAckTimeoutEvent.IsRunning ())
<     {
<       m_normalAckTimeoutEvent.Cancel ();
<     }
<   if (m_blockAckTimeoutEvent.IsRunning ())
<     {
<       m_blockAckTimeoutEvent.Cancel ();
<     }
<   if (m_sendAckEvent.IsRunning ())
<     {
<       m_sendAckEvent.Cancel ();
<     }
< }
< 
< void
< MacLow::SLS_Phase_Ended (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_servingSLS = false;
< }
< 
< bool
< MacLow::Is_Performing_SLS (void) const
< {
<   return m_servingSLS;
< }
< 
< void
< MacLow::MIMO_BFT_Phase_Started (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_servingMimoBFT = true;
<   /* We always prioritize MIMO BFT over any data transmission, so we cancel any events. */
<   if (m_normalAckTimeoutEvent.IsRunning ())
<     {
<       m_normalAckTimeoutEvent.Cancel ();
<     }
<   if (m_blockAckTimeoutEvent.IsRunning ())
<     {
<       m_blockAckTimeoutEvent.Cancel ();
<     }
<   if (m_sendAckEvent.IsRunning ())
<     {
<       m_sendAckEvent.Cancel ();
<     }
< }
< 
< void
< MacLow::MIMO_BFT_Phase_Ended (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_servingMimoBFT = false;
---
>   /* When this method completes, we have taken ownership of the medium. */
>   NS_ASSERT (m_phy->IsStateTx ());
1046c830
< MacLow::Is_Performing_MIMO_BFT (void) const
---
> MacLow::NeedRts (void)
1048c832,834
<   return m_servingMimoBFT;
---
>   WifiTxVector dataTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
>   return m_stationManager->NeedRts (m_currentHdr.GetAddr1 (), &m_currentHdr,
>                                     m_currentPacket, dataTxVector);
1050d835
< //// WIGIG ////
1053c838
< MacLow::NeedCtsToSelf (void) const
---
> MacLow::NeedCtsToSelf (void)
1055c840
<   WifiTxVector dataTxVector = GetDataTxVector (*m_currentPacket->begin ());
---
>   WifiTxVector dataTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
1059,1162d843
< bool
< MacLow::IsWithinSizeAndTimeLimits (Ptr<const WifiMacQueueItem> mpdu, WifiTxVector txVector,
<                                     uint32_t ampduSize, Time ppduDurationLimit)
< {
<   NS_ASSERT (mpdu != 0 && mpdu->GetHeader ().IsQosData ());
< 
<   return IsWithinSizeAndTimeLimits (mpdu->GetSize (), mpdu->GetHeader ().GetAddr1 (),
<                                     mpdu->GetHeader ().GetQosTid (), txVector,
<                                     ampduSize, ppduDurationLimit);
< }
< 
< bool
< MacLow::IsWithinSizeAndTimeLimits (uint32_t mpduSize, Mac48Address receiver, uint8_t tid,
<                                     WifiTxVector txVector, uint32_t ampduSize, Time ppduDurationLimit)
< {
<   NS_LOG_FUNCTION (this << mpduSize << receiver << +tid << txVector << ampduSize << ppduDurationLimit);
< 
<   if (ppduDurationLimit != Time::Min () && ppduDurationLimit.IsNegative ())
<     {
<       return false;
<     }
< 
<   WifiModulationClass modulation = txVector.GetMode ().GetModulationClass ();
< 
<   uint32_t maxAmpduSize = 0;
<   if (GetMpduAggregator ())
<     {
<       maxAmpduSize = GetMpduAggregator ()->GetMaxAmpduSize (receiver, tid, modulation);
<     }
< 
<   // If maxAmpduSize is null, then ampduSize must be null as well
<   NS_ASSERT (maxAmpduSize || ampduSize == 0);
< 
<   uint32_t ppduPayloadSize = mpduSize;
< 
<   // compute the correct size for A-MPDUs and S-MPDUs
<   if (ampduSize > 0 || modulation >= WIFI_MOD_CLASS_VHT)
<     {
<       ppduPayloadSize = GetMpduAggregator ()->GetSizeIfAggregated (mpduSize, ampduSize);
<     }
< 
<   if (maxAmpduSize > 0 && ppduPayloadSize > maxAmpduSize)
<     {
<       NS_LOG_DEBUG ("the frame does not meet the constraint on max A-MPDU size");
<       return false;
<     }
< 
<   // Get the maximum PPDU Duration based on the preamble type
<   Time maxPpduDuration = GetPpduMaxTime (txVector.GetPreambleType ());
< 
<   Time txTime = m_phy->CalculateTxDuration (ppduPayloadSize, txVector, m_phy->GetFrequency ());
< 
<   if ((ppduDurationLimit.IsStrictlyPositive () && txTime > ppduDurationLimit)
<       || (maxPpduDuration.IsStrictlyPositive () && txTime > maxPpduDuration))
<     {
<       NS_LOG_DEBUG ("the frame does not meet the constraint on max PPDU duration");
<       return false;
<     }
< 
<   return true;
< }
< 
< void
< MacLow::RxStartIndication (WifiTxVector txVector, Time psduDuration)
< {
<   NS_LOG_FUNCTION (this);
<   NS_LOG_DEBUG ("PSDU reception started for " << psduDuration.ToDouble (Time::US)
<                 << " us (txVector: " << txVector << ")");
<   NS_ASSERT (psduDuration.IsStrictlyPositive ());
< 
<   if (m_normalAckTimeoutEvent.IsRunning ())
<     {
<       // we are waiting for a Normal Ack and something arrived
<       NS_LOG_DEBUG ("Rescheduling Normal Ack timeout");
<       m_normalAckTimeoutEvent.Cancel ();
<       NotifyAckTimeoutResetNow ();
<       m_normalAckTimeoutEvent = Simulator::Schedule (psduDuration + NanoSeconds (PSDU_DURATION_SAFEGUARD),
<                                                      &MacLow::NormalAckTimeout, this);
<     }
<   else if (m_blockAckTimeoutEvent.IsRunning ())
<     {
<       // we are waiting for a BlockAck and something arrived
<       NS_LOG_DEBUG ("Rescheduling Block Ack timeout");
<       m_blockAckTimeoutEvent.Cancel ();
<       NotifyAckTimeoutResetNow ();
<       m_blockAckTimeoutEvent = Simulator::Schedule (psduDuration + NanoSeconds (PSDU_DURATION_SAFEGUARD),
<                                                     &MacLow::BlockAckTimeout, this);
<     }
<   else if (m_ctsTimeoutEvent.IsRunning ())
<     {
<       // we are waiting for a CTS and something arrived
<       NS_LOG_DEBUG ("Rescheduling CTS timeout");
<       m_ctsTimeoutEvent.Cancel ();
<       NotifyCtsTimeoutResetNow ();
<       m_ctsTimeoutEvent = Simulator::Schedule (psduDuration + NanoSeconds (PSDU_DURATION_SAFEGUARD),
<                                                &MacLow::CtsTimeout, this);
<     }
<   else if (m_navCounterResetCtsMissed.IsRunning ())
<     {
<       NS_LOG_DEBUG ("Cannot reset NAV");
<       m_navCounterResetCtsMissed.Cancel ();
<     }
< }
< 
1164c845
< MacLow::ReceiveError (Ptr<WifiPsdu> psdu)
---
> MacLow::ReceiveError (Ptr<Packet> packet, double rxSnr)
1166,1178c847,853
<   NS_LOG_FUNCTION (this << *psdu);
<   NS_LOG_DEBUG ("rx failed");
<   if (IsCfPeriod () && m_currentPacket->GetHeader (0).IsCfPoll ())
<     {
<       NS_ASSERT (m_currentTxop != 0);
<       m_currentTxop->MissedCfPollResponse (m_cfAckInfo.expectCfAck);
<     }
<   else if (m_cfAckInfo.expectCfAck)
<     {
<       NS_ASSERT (m_currentTxop != 0);
<       Ptr<Txop> txop = m_currentTxop;
<       m_currentTxop = 0;
<       txop->MissedAck ();
---
>   NS_LOG_FUNCTION (this << packet << rxSnr);
>   NS_LOG_DEBUG ("rx failed ");
>   if (m_txParams.MustWaitFastAck ())
>     {
>       NS_ASSERT (m_fastAckFailedTimeoutEvent.IsExpired ());
>       m_fastAckFailedTimeoutEvent = Simulator::Schedule (GetSifs (),
>                                                          &MacLow::FastAckFailedTimeout, this);
1180d854
<   m_cfAckInfo.expectCfAck = false;
1197c871
<   m_currentTxop = 0;
---
>   m_listener = 0;
1212,1227c886
<   m_currentTxop = 0;
< }
< 
< void
< MacLow::NotifyOffNow (void)
< {
<   NS_LOG_DEBUG ("Device is switched off. Cancelling MAC pending events");
<   CancelAllEvents ();
<   if (m_navCounterResetCtsMissed.IsRunning ())
<     {
<       m_navCounterResetCtsMissed.Cancel ();
<     }
<   m_lastNavStart = Simulator::Now ();
<   m_lastNavDuration = Seconds (0);
<   m_currentPacket = 0;
<   m_currentTxop = 0;
---
>   m_listener = 0;
1231c890
< MacLow::ReceiveShortSswOk (Ptr<WifiMacQueueItem> mpdu, double rxSnr, WifiTxVector txVector, bool ampduSubframe)
---
> MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, WifiPreamble preamble, bool ampduSubframe)
1233,1253c892,894
<   NS_LOG_FUNCTION (this << *mpdu << rxSnr << txVector);
<   /* An MPDU containing a Short SSW packet is received from the PHY.
<    */  
<   Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
< 
<   /* To do: Set the NAV to account for the duration of the whole SISO period in MU-MIMO BFT */
< //  bool isPrevNavZero = IsNavZero ();
< //  NS_LOG_DEBUG ("duration/id=" << hdr.GetDuration ());
< //  NotifyNav (packet, hdr);
< 
<   Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<   wifiMac->ReceiveShortSswFrame (packet, rxSnr);
<   return;
< }
< 
< void
< MacLow::ReceiveOk (Ptr<WifiMacQueueItem> mpdu, double rxSnr, WifiTxVector txVector, bool ampduSubframe)
< {
<   NS_LOG_FUNCTION (this << *mpdu << rxSnr << txVector);
<   /* An MPDU is received from the PHY.
<    * When we have handled this MPDU,
---
>   NS_LOG_FUNCTION (this << packet << rxSnr << txVector.GetMode () << preamble);
>   /* A packet is received from the PHY.
>    * When we have handled this packet,
1257,1258c898,900
<   const WifiMacHeader& hdr = mpdu->GetHeader ();
<   Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
---
>   WifiMacHeader hdr;
>   packet->RemoveHeader (hdr);
>   m_lastReceivedHdr = hdr;
1262c904
<   NotifyNav (packet, hdr);
---
>   NotifyNav (packet, hdr, preamble);
1284,1312c926,931
<               if ((m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ad) || (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay))
<                 {
<                   m_sendCtsEvent = Simulator::Schedule (GetSifs (),
<                                                         &MacLow::SendDmgCtsAfterRts, this,
<                                                         hdr.GetAddr2 (),
<                                                         hdr.GetDuration (),
<                                                         txVector,
<                                                         rxSnr);
<                   if (txVector.IsControlTrailerPresent ())
<                     {
<                       ControlTrailer ct;
<                       Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
<                       packet->RemoveHeader (ct);
<                       if (ct.IsMimoTransmission () && (!ct.IsMuMimoTransmission ()))
<                         {
<                           Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<                           wifiMac->UpdateBestMimoRxAntennaConfigurationIndex (hdr.GetAddr2 (), ct.GetTxSectorCombinationIdx ());
<                         }
<                     }
<                 }
<               else
<                 {
<                   m_sendCtsEvent = Simulator::Schedule (GetSifs (),
<                                                         &MacLow::SendCtsAfterRts, this,
<                                                         hdr.GetAddr2 (),
<                                                         hdr.GetDuration (),
<                                                         txVector,
<                                                         rxSnr);
<                 }
---
>               m_sendCtsEvent = Simulator::Schedule (GetSifs (),
>                                                     &MacLow::SendCtsAfterRts, this,
>                                                     hdr.GetAddr2 (),
>                                                     hdr.GetDuration (),
>                                                     txVector,
>                                                     rxSnr);
1320c939
<   else if ((hdr.IsCts () || hdr.IsDmgCts ())
---
>   else if (hdr.IsCts ()
1330c949
<       NS_LOG_DEBUG ("received cts from=" << m_currentPacket->GetAddr1 ());
---
>       NS_LOG_DEBUG ("receive cts from=" << m_currentHdr.GetAddr1 ());
1334c953
<       m_stationManager->ReportRxOk (m_currentPacket->GetAddr1 (), &hdr,
---
>       m_stationManager->ReportRxOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
1336c955
<       m_stationManager->ReportRtsOk (m_currentPacket->GetAddr1 (), &m_currentPacket->GetHeader (0),
---
>       m_stationManager->ReportRtsOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
1340a960
>       m_listener->GotCts (rxSnr, txVector.GetMode ());
1343a964
>                                              hdr.GetAddr1 (),
1345,1359d965
<       if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<         {
<           if (txVector.IsControlTrailerPresent ())
<             {
<               ControlTrailer ct;
<               Ptr<Packet> packet = mpdu->GetPacket ()-> Copy ();
<               packet->RemoveHeader (ct);
<               if (ct.IsMimoTransmission () && (!ct.IsMuMimoTransmission ()))
<                 {
<                   Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<                   wifiMac->UpdateBestMimoRxAntennaConfigurationIndex (hdr.GetAddr2 (), ct.GetTxSectorCombinationIdx ());
<                   wifiMac->SteerMimoRxAntennaToward (hdr.GetAddr2 ());
<                 }
<             }
<         }
1363,1364c969,972
<            && m_normalAckTimeoutEvent.IsRunning ()
<            && m_txParams.MustWaitNormalAck ())
---
>            && (m_normalAckTimeoutEvent.IsRunning ()
>                || m_fastAckTimeoutEvent.IsRunning ()
>                || m_superFastAckTimeoutEvent.IsRunning ())
>            && m_txParams.MustWaitAck ())
1366c974
<       NS_LOG_DEBUG ("receive ack from=" << m_currentPacket->GetAddr1 ());
---
>       NS_LOG_DEBUG ("receive ack from=" << m_currentHdr.GetAddr1 ());
1369,1370c977,984
<       //When fragmentation is used, only update manager when the last fragment is acknowledged
<       if (!m_txParams.HasNextPacket ())
---
>       m_stationManager->ReportRxOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
>                                     rxSnr, txVector.GetMode ());
>       m_stationManager->ReportDataOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
>                                       rxSnr, txVector.GetMode (), tag.Get ());
> 
>       bool gotAck = false;
>       if (m_txParams.MustWaitNormalAck ()
>           && m_normalAckTimeoutEvent.IsRunning ())
1372,1376c986,988
<           m_stationManager->ReportRxOk (m_currentPacket->GetAddr1 (), &hdr,
<                                         rxSnr, txVector.GetMode ());
<           m_stationManager->ReportDataOk (m_currentPacket->GetAddr1 (), &m_currentPacket->GetHeader (0),
<                                           rxSnr, txVector.GetMode (), tag.Get (),
<                                           m_currentTxVector, m_currentPacket->GetSize ());
---
>           m_normalAckTimeoutEvent.Cancel ();
>           NotifyAckTimeoutResetNow ();
>           gotAck = true;
1378,1383c990,991
<       // cancel the Normal Ack timer
<       m_normalAckTimeoutEvent.Cancel ();
<       NotifyAckTimeoutResetNow ();
<       m_currentTxop->GotAck ();
< 
<       if (m_txParams.HasNextPacket ())
---
>       if (m_txParams.MustWaitFastAck ()
>           && m_fastAckTimeoutEvent.IsRunning ())
1385,1392c993,995
<           if (m_stationManager->GetRifsPermitted ())
<             {
<               m_waitIfsEvent = Simulator::Schedule (GetRifs (), &MacLow::WaitIfsAfterEndTxFragment, this);
<             }
<           else
<             {
<               m_waitIfsEvent = Simulator::Schedule (GetSifs (), &MacLow::WaitIfsAfterEndTxFragment, this);
<             }
---
>           m_fastAckTimeoutEvent.Cancel ();
>           NotifyAckTimeoutResetNow ();
>           gotAck = true;
1394,1399c997
<       else if (m_currentPacket->GetHeader (0).IsQosData () && m_currentTxop->IsQosTxop () &&
<                m_currentTxop->GetTxopLimit ().IsStrictlyPositive ()
<                //// WIGIG ////
<                //&& m_currentTxop->GetTxopRemaining () > GetSifs ()
<                && m_currentTxop->GetRemainingTimeForTransmission () > GetSifs ())
<                //// WIGIG ////
---
>       if (gotAck)
1401,1408c999
<           if (m_stationManager->GetRifsPermitted ())
<             {
<               m_waitIfsEvent = Simulator::Schedule (GetRifs (), &MacLow::WaitIfsAfterEndTxPacket, this);
<             }
<           else
<             {
<               m_waitIfsEvent = Simulator::Schedule (GetSifs (), &MacLow::WaitIfsAfterEndTxPacket, this);
<             }
---
>           m_listener->GotAck (rxSnr, txVector.GetMode ());
1410c1001
<       else if (m_currentTxop->IsQosTxop ())
---
>       if (m_txParams.HasNextPacket ())
1412c1003,1004
<           m_currentTxop->TerminateTxop ();
---
>           m_waitSifsEvent = Simulator::Schedule (GetSifs (),
>                                                  &MacLow::WaitSifsAfterEndTxFragment, this);
1414,1415c1006,1013
<       /* WIGIG: Set the current packet to zero to avoid storing it for the next access period */
<       m_currentPacket = 0; //// WIGIG ////
---
>       else if (m_currentHdr.IsQosData () && !m_ampdu)
>         {
>           m_waitSifsEvent = Simulator::Schedule (GetSifs (),
>                                                  &MacLow::WaitSifsAfterEndTx, this);
>         }
> 
>       FlushAggregateQueue ();
>       m_ampdu = false;
1418c1016
<            && m_txParams.MustWaitBlockAck ()
---
>            && (m_txParams.MustWaitBasicBlockAck () || m_txParams.MustWaitCompressedBlockAck ())
1428,1450c1026,1029
<       m_currentTxop->GotBlockAck (&blockAck, hdr.GetAddr2 (), rxSnr, tag.Get (), m_currentTxVector);
<       // start next packet if TXOP remains, otherwise contend for accessing the channel again
<       if (m_currentTxop->IsQosTxop () && m_currentTxop->GetTxopLimit ().IsStrictlyPositive ()
<           //// WIGIG ////
<           //&& m_currentTxop->GetTxopRemaining () > GetSifs ()
<           && m_currentTxop->GetRemainingTimeForTransmission () > GetSifs ())
<           //// WIGIG ////
<         {
<           if (m_stationManager->GetRifsPermitted ())
<             {
<               m_waitIfsEvent = Simulator::Schedule (GetRifs (), &MacLow::WaitIfsAfterEndTxPacket, this);
<             }
<           else
<             {
<               m_waitIfsEvent = Simulator::Schedule (GetSifs (), &MacLow::WaitIfsAfterEndTxPacket, this);
<             }
<         }
<       else if (m_currentTxop->IsQosTxop ())
<         {
<           m_currentTxop->TerminateTxop ();
<         }
<       /* WIGIG: Set the current packet to zero to avoid storing it for the next access period */
<       m_currentPacket = 0; //// WIGIG ////
---
>       m_listener->GotBlockAck (&blockAck, hdr.GetAddr2 (), rxSnr, txVector.GetMode (), tag.Get ());
>       m_sentMpdus = 0;
>       m_ampdu = false;
>       FlushAggregateQueue ();
1454,1463d1032
<       if (m_servingSLS)
<         {
<           NS_LOG_DEBUG ("We are serving SLS, so ignore BlockAckRequest frame");
<           return;
<         }
<       if (m_servingMimoBFT)
<         {
<           NS_LOG_DEBUG ("We are serving MIMO BFT, so ignore BlockAckRequest frame");
<           return;
<         }
1477c1046
<               NS_ASSERT (m_sendAckEvent.IsExpired ());
---
>               //NS_ASSERT (m_sendAckEvent.IsExpired ());
1507,1520d1075
<   //// WIGIG ////
<   else if (hdr.IsDMGBeacon ())
<     {
<       NS_LOG_DEBUG ("Received DMG Beacon with BSSID=" << hdr.GetAddr1 ());
<       m_stationManager->ReportRxOk (hdr.GetAddr1 (), &hdr, rxSnr, txVector.GetMode ());
<       goto rxPacket;
<     }
<   else if ((hdr.GetAddr1 () == m_self) && (hdr.IsSSW () || hdr.IsSSW_FBCK () || hdr.IsSSW_ACK ()))
<     {
<       NS_LOG_DEBUG ("Received " << hdr.GetTypeString ());
<       m_stationManager->ReportRxOk (hdr.GetAddr2 (), &hdr, rxSnr, txVector.GetMode ());
<       goto rxPacket;
<     }
<   //// WIGIG ////
1523,1548c1078
<       if (hdr.IsCfEnd ())
<         {
<           NS_LOG_DEBUG ("rx CF-END ");
<           m_cfpStart = NanoSeconds (0);
<           if (m_cfAckInfo.expectCfAck)
<             {
<               NS_ASSERT (m_currentTxop != 0);
<               if (hdr.IsCfAck ())
<                 {
<                   m_currentTxop->GotAck ();
<                 }
<               else
<                 {
<                   m_currentTxop->MissedAck ();
<                 }
<             }
<           if (m_currentTxop != 0)
<             {
<               m_currentTxop->GotCfEnd ();
<             }
<           m_cfAckInfo.expectCfAck = false;
<         }
<       else
<         {
<           NS_LOG_DEBUG ("rx drop " << hdr.GetTypeString ());
<         }
---
>       NS_LOG_DEBUG ("rx drop " << hdr.GetTypeString ());
1552,1581d1081
<       if (hdr.IsCfPoll ())
<         {
<           m_cfpStart = Simulator::Now ();
<           if (m_cfAckInfo.expectCfAck && !hdr.IsCfAck ())
<             {
<               NS_ASSERT (m_currentTxop != 0);
<               Ptr<Txop> txop = m_currentTxop;
<               m_currentTxop = 0;
<               txop->MissedAck ();
<               m_cfAckInfo.expectCfAck = false;
<             }
<         }
<       if (m_servingSLS)
<         {
<           NS_LOG_DEBUG ("We are serving SLS, so ignore any data or management frame");
<           if (m_sendAckEvent.IsRunning ())
<             {
<               m_sendAckEvent.Cancel ();
<             }
<           return;
<         }
<       if (m_servingMimoBFT && (hdr.IsData () || hdr.IsBlockAck ()))
<         {
<           NS_LOG_DEBUG ("We are serving MIMO BFT, so ignore any data or management frame that's not part of it");
<           if (m_sendAckEvent.IsRunning ())
<             {
<               m_sendAckEvent.Cancel ();
<             }
<           return;
<         }
1584,1589c1084
<       if (hdr.IsActionNoAck ())
<         {
<           NS_LOG_DEBUG ("Received Action No ACK Frame");
<           goto rxPacket;
<         }
<       else if (hdr.IsQosData () && ReceiveMpdu (mpdu))
---
>       if (hdr.IsQosData () && ReceiveMpdu (packet, hdr))
1593c1088
<              the block ack agreement exists, the recipient shall buffer the MSDU
---
>              the Block Ack agreement exists, the recipient shall buffer the MSDU
1604,1610c1099
<               NS_ASSERT (m_sendAckEvent.IsExpired ()); //// WIGIG ////
< //// WIGIG ////
<              // if (m_sendAckEvent.IsRunning ())
<              //   {
<              //    m_sendAckEvent.Cancel ();
<              //  }
< //// WIGIG ////
---
>               NS_ASSERT (m_sendAckEvent.IsExpired ());
1632c1121
<              When a recipient does not have an active block ack for a TID, but receives
---
>              When a recipient does not have an active Block ack for a TID, but receives
1637c1126
<           m_edca[ac]->SendDelbaFrame (hdr.GetAddr2 (), hdr.GetQosTid (), false);
---
>           m_edcaListeners[ac]->BlockAckInactivityTimeout (hdr.GetAddr2 (), hdr.GetQosTid ());
1659d1147
<               mpdu = Create<WifiMacQueueItem> (packet, hdr);
1667,1689c1155,1162
<               if (IsCfPeriod ())
<                 {
<                   if (hdr.HasData ())
<                     {
<                       m_cfAckInfo.appendCfAck = true;
<                       m_cfAckInfo.address = hdr.GetAddr2 ();
<                     }
<                 }
<               else
<                 {
<                   NS_LOG_DEBUG ("rx unicast/sendAck from=" << hdr.GetAddr2 ());
<                   NS_ASSERT (m_sendAckEvent.IsExpired ());
<                   m_sendAckEvent = Simulator::Schedule (GetSifs (),
<                                                         &MacLow::SendAckAfterData, this,
<                                                         hdr.GetAddr2 (),
<                                                         hdr.GetDuration (),
<                                                         txVector.GetMode (),
<                                                         rxSnr);
<                 }
<               //else  //// WIGIG ////
<               //  {
<               //    return;
<               //  }
---
>               NS_LOG_DEBUG ("rx unicast/sendAck from=" << hdr.GetAddr2 ());
>               NS_ASSERT (m_sendAckEvent.IsExpired ());
>               m_sendAckEvent = Simulator::Schedule (GetSifs (),
>                                                     &MacLow::SendAckAfterData, this,
>                                                     hdr.GetAddr2 (),
>                                                     hdr.GetDuration (),
>                                                     txVector.GetMode (),
>                                                     rxSnr);
1711d1183
<                   mpdu = Create<WifiMacQueueItem> (packet, hdr);
1714a1187,1190
>           else
>             {
>               // DROP
>             }
1727,1738c1203
<       if (m_cfAckInfo.expectCfAck && hdr.IsCfAck ())
<         {
<           m_cfAckInfo.expectCfAck = false;
<           NS_ASSERT (m_currentTxop != 0);
<           m_currentTxop->GotAck ();
<         }
<       else if (m_servingMimoBFT && hdr.GetAddr1 () == hdr.GetAddr2 ())
<         {
<           NS_LOG_INFO ("During MIMO BF Training phase of MU-MIMO BFT the Initiator sets the TA and RA fields to his own address");
<           goto rxPacket;
<         }
<       NS_LOG_DEBUG ("rx not for me from=" << hdr.GetAddr2 ());
---
>       //NS_LOG_DEBUG_VERBOSE ("rx not-for-me from %d", GetSource (packet));
1742c1207,1217
<   if (m_cfAckInfo.expectCfAck && hdr.IsCfAck ())
---
>   WifiMacTrailer fcs;
>   packet->RemoveTrailer (fcs);
>   m_rxCallback (packet, &hdr);
>   return;
> }
> 
> uint8_t
> MacLow::GetTid (Ptr<const Packet> packet, const WifiMacHeader hdr) const
> {
>   uint8_t tid = 0;
>   if (hdr.IsQosData ())
1744,1746c1219
<       m_cfAckInfo.expectCfAck = false;
<       NS_ASSERT (m_currentTxop != 0);
<       m_currentTxop->GotAck ();
---
>       tid = hdr.GetQosTid ();
1748,1749c1221,1233
<   m_rxCallback (mpdu);
<   return;
---
>   else if (hdr.IsBlockAckReq ())
>     {
>       CtrlBAckRequestHeader baReqHdr;
>       packet->PeekHeader (baReqHdr);
>       tid = baReqHdr.GetTidInfo ();
>     }
>   else if (hdr.IsBlockAck ())
>     {
>       CtrlBAckResponseHeader baRespHdr;
>       packet->PeekHeader (baRespHdr);
>       tid = baRespHdr.GetTidInfo ();
>     }
>   return tid;
1753c1237
< MacLow::GetCfEndSize (void) const
---
> MacLow::GetAckSize (void) const
1755,1756c1239,1250
<   WifiMacHeader cfEnd;
<   if (m_cfAckInfo.expectCfAck || m_cfAckInfo.appendCfAck)
---
>   WifiMacHeader ack;
>   ack.SetType (WIFI_MAC_CTL_ACK);
>   return ack.GetSize () + 4;
> }
> 
> uint32_t
> MacLow::GetBlockAckSize (enum BlockAckType type) const
> {
>   WifiMacHeader hdr;
>   hdr.SetType (WIFI_MAC_CTL_BACKRESP);
>   CtrlBAckResponseHeader blockAck;
>   if (type == BASIC_BLOCK_ACK)
1758c1252
<       cfEnd.SetType (WIFI_MAC_CTL_END_ACK);
---
>       blockAck.SetType (BASIC_BLOCK_ACK);
1760c1254
<   else
---
>   else if (type == COMPRESSED_BLOCK_ACK)
1762c1256
<       cfEnd.SetType (WIFI_MAC_CTL_END);
---
>       blockAck.SetType (COMPRESSED_BLOCK_ACK);
1764c1258,1271
<   return cfEnd.GetSize () + 4;
---
>   else if (type == MULTI_TID_BLOCK_ACK)
>     {
>       //Not implemented
>       NS_ASSERT (false);
>     }
>   return hdr.GetSize () + blockAck.GetSerializedSize () + 4;
> }
> 
> uint32_t
> MacLow::GetRtsSize (void) const
> {
>   WifiMacHeader rts;
>   rts.SetType (WIFI_MAC_CTL_RTS);
>   return rts.GetSize () + 4;
1777,1778c1284,1294
<   NS_ASSERT (ackTxVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HT); //Ack should always use non-HT PPDU (HT PPDU cases not supported yet)
<   return m_phy->CalculateTxDuration (GetAckSize (), ackTxVector, m_phy->GetFrequency ());
---
>   NS_ASSERT (ackTxVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HT); //ACK should always use non-HT PPDU (HT PPDU cases not supported yet)
>   WifiPreamble preamble;
>   if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
>     }
>   return m_phy->CalculateTxDuration (GetAckSize (), ackTxVector, preamble, m_phy->GetFrequency ());
1782c1298
< MacLow::GetBlockAckDuration (WifiTxVector blockAckReqTxVector, BlockAckType type) const
---
> MacLow::GetBlockAckDuration (Mac48Address to, WifiTxVector blockAckReqTxVector, enum BlockAckType type) const
1788,1801c1304,1309
<   return m_phy->CalculateTxDuration (GetBlockAckSize (type), blockAckReqTxVector, m_phy->GetFrequency ());
< }
< 
< Time
< MacLow::GetBlockAckRequestDuration (WifiTxVector blockAckReqTxVector, BlockAckType type) const
< {
<   return m_phy->CalculateTxDuration (GetBlockAckRequestSize (type), blockAckReqTxVector, m_phy->GetFrequency ());
< }
< 
< Time
< MacLow::GetCtsDuration (Mac48Address to, WifiTxVector rtsTxVector, bool addControlTrailer) const
< {
<   //// WIGIG ////
<   if ((rtsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_CTRL || rtsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL))
---
>   WifiPreamble preamble;
>   if (blockAckReqTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT && type == BASIC_BLOCK_ACK)
>     {
>       preamble = WIFI_PREAMBLE_HT_MF;
>     }
>   else if (m_stationManager->GetShortPreambleEnabled ())
1803c1311
<       return GetDmgCtsDuration (addControlTrailer);
---
>       preamble = WIFI_PREAMBLE_SHORT;
1806d1313
<     //// WIGIG ////
1808,1809c1315
<       WifiTxVector ctsTxVector = GetCtsTxVectorForRts (to, rtsTxVector.GetMode ());
<       return GetCtsDuration (ctsTxVector);
---
>       preamble = WIFI_PREAMBLE_LONG;
1810a1317
>   return m_phy->CalculateTxDuration (GetBlockAckSize (type), blockAckReqTxVector, preamble, m_phy->GetFrequency ());
1814c1321
< MacLow::GetCtsDuration (WifiTxVector ctsTxVector) const
---
> MacLow::GetCtsDuration (Mac48Address to, WifiTxVector rtsTxVector) const
1816,1817c1323,1324
<   NS_ASSERT (ctsTxVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HT); //CTS should always use non-HT PPDU (HT PPDU cases not supported yet)
<   return m_phy->CalculateTxDuration (GetCtsSize (), ctsTxVector, m_phy->GetFrequency ());
---
>   WifiTxVector ctsTxVector = GetCtsTxVectorForRts (to, rtsTxVector.GetMode ());
>   return GetCtsDuration (ctsTxVector);
1820d1326
< //// WIGIG ////
1822,1829c1328
< MacLow::GetDmgControlDuration (WifiTxVector txVector, uint32_t payloadSize) const
< {
<   NS_ASSERT (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_CTRL || txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL);
<   return m_phy->CalculateTxDuration (payloadSize, txVector, m_phy->GetFrequency ());
< }
< 
< Time
< MacLow::GetDmgCtsDuration (bool addControlTrailer) const
---
> MacLow::GetCtsDuration (WifiTxVector ctsTxVector) const
1831,1833c1330,1340
<   WifiTxVector ctsTxVector = GetDmgControlTxVector ();
<   NS_ASSERT (ctsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_CTRL || ctsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL);
<   return m_phy->CalculateTxDuration (GetDmgCtsSize (addControlTrailer), ctsTxVector, m_phy->GetFrequency ());
---
>   NS_ASSERT (ctsTxVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HT); //CTS should always use non-HT PPDU (HT PPDU cases not supported yet)
>   WifiPreamble preamble;
>   if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
>     }
>   return m_phy->CalculateTxDuration (GetCtsSize (), ctsTxVector, preamble, m_phy->GetFrequency ());
1837c1344
< MacLow::GetDmgCtsSize (bool addControlTrailer)
---
> MacLow::GetCtsSize (void) const
1840,1844c1347,1348
<   cts.SetType (WIFI_MAC_CTL_DMG_CTS);
<   uint32_t dmgCtsSize = cts.GetSize () + 4;
<   if (addControlTrailer)
<     dmgCtsSize+= 18;
<   return dmgCtsSize;
---
>   cts.SetType (WIFI_MAC_CTL_CTS);
>   return cts.GetSize () + 4;
1847,1848c1351,1352
< WifiTxVector
< MacLow::GetDmgTxVector (Ptr<const WifiMacQueueItem> item) const
---
> uint32_t
> MacLow::GetSize (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
1850,1851c1354,1364
<   Mac48Address to = item->GetHeader ().GetAddr1 ();
<   return m_stationManager->GetDmgTxVector (to, &item->GetHeader (), item->GetPacket ());
---
>   uint32_t size;
>   WifiMacTrailer fcs;
>   if (m_ampdu)
>     {
>       size = packet->GetSize ();
>     }
>   else
>     {
>       size = packet->GetSize () + hdr->GetSize () + fcs.GetSerializedSize ();
>     }
>   return size;
1853d1365
< //// WIGIG ////
1856c1368
< MacLow::GetRtsTxVector (Ptr<const WifiMacQueueItem> item) const
---
> MacLow::GetCtsToSelfTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
1858c1370
<   return m_stationManager->GetRtsTxVector (item->GetHeader ().GetAddr1 ());
---
>   return m_stationManager->GetCtsToSelfTxVector (hdr, packet);
1862,1869c1374
< MacLow::GetDataTxVector (Ptr<const WifiMacQueueItem> item) const
< {
<   return m_stationManager->GetDataTxVector (item->GetHeader ());
< }
< 
< Time
< MacLow::GetResponseDuration (const MacLowTransmissionParameters& params, WifiTxVector dataTxVector,
<                              Mac48Address receiver) const
---
> MacLow::GetRtsTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
1871,1892c1376,1377
<   NS_LOG_FUNCTION (this << receiver << dataTxVector << params);
< 
<   Time duration = Seconds (0);
<   if (params.MustWaitNormalAck ())
<     {
<       duration += GetSifs ();
<       duration += GetAckDuration (receiver, dataTxVector);
<     }
<   else if (params.MustWaitBlockAck ())
<     {
<       duration += GetSifs ();
<       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_self, dataTxVector.GetMode ());
<       duration += GetBlockAckDuration (blockAckReqTxVector, params.GetBlockAckType ());
<     }
<   else if (params.MustSendBlockAckRequest ())
<     {
<       duration += 2 * GetSifs ();
<       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_self, dataTxVector.GetMode ());
<       duration += GetBlockAckRequestDuration (blockAckReqTxVector, params.GetBlockAckRequestType ());
<       duration += GetBlockAckDuration (blockAckReqTxVector, params.GetBlockAckRequestType ());
<     }
<   return duration;
---
>   Mac48Address to = hdr->GetAddr1 ();
>   return m_stationManager->GetRtsTxVector (to, hdr, packet);
1895,1896c1380,1381
< WifiMode
< MacLow::GetControlAnswerMode (WifiMode reqMode) const
---
> WifiTxVector
> MacLow::GetDataTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
1898,2059c1383,1384
<   NS_LOG_FUNCTION (this << reqMode);
<   WifiMode mode = m_stationManager->GetDefaultMode ();
<   bool found = false;
<   if (m_stationManager->HasDmgSupported () || m_stationManager->HasEdmgSupported ())   //// WIGIG ////
<     {
<       /**
<        * Rules for selecting a control response rate from IEEE 802.11ad-2012,
<        * Section 9.7.5a Multirate support for DMG STAs:
<        */
<       WifiMode thismode;
<       /* We start from SC PHY Rates, This is for transmitting an ACK frame or a BA frame */
<       for (uint32_t idx = 0; idx < m_phy->GetNModes (); idx++)
<         {
<           thismode = m_phy->GetMode (idx);
<           if (thismode.IsMandatory () && (thismode.GetDataRate () <= reqMode.GetDataRate ()))
<             {
<               mode = thismode;
<               found = true;
<             }
<           else
<             {
<               break;
<             }
<         }
<     }
<   else
<     {
<       /**
<        * The standard has relatively unambiguous rules for selecting a
<        * control response rate (the below is quoted from IEEE 802.11-2012,
<        * Section 9.7):
<        *
<        * To allow the transmitting STA to calculate the contents of the
<        * Duration/ID field, a STA responding to a received frame shall
<        * transmit its Control Response frame (either CTS or Ack), other
<        * than the BlockAck control frame, at the highest rate in the
<        * BSSBasicRateSet parameter that is less than or equal to the
<        * rate of the immediately previous frame in the frame exchange
<        * sequence (as defined in Annex G) and that is of the same
<        * modulation class (see Section 9.7.8) as the received frame...
<        */
<       //First, search the BSS Basic Rate set
<       for (uint8_t i = 0; i < m_stationManager->GetNBasicModes (); i++)
<         {
<           WifiMode testMode = m_stationManager->GetBasicMode (i);
<           if ((!found || testMode.IsHigherDataRate (mode))
<               && (!testMode.IsHigherDataRate (reqMode))
<               && (IsAllowedControlAnswerModulationClass (reqMode.GetModulationClass (), testMode.GetModulationClass ())))
<             {
<               mode = testMode;
<               //We've found a potentially-suitable transmit rate, but we
<               //need to continue and consider all the basic rates before
<               //we can be sure we've got the right one.
<               found = true;
<             }
<         }
<       if (m_stationManager->GetHtSupported ())
<         {
<           if (!found)
<             {
<               mode = m_stationManager->GetDefaultMcs ();
<               for (uint8_t i = 0; i != m_stationManager->GetNBasicMcs (); i++)
<                 {
<                   WifiMode testMode = m_stationManager->GetBasicMcs (i);
<                   if ((!found || testMode.IsHigherDataRate (mode))
<                       && (!testMode.IsHigherDataRate (reqMode))
<                       && (testMode.GetModulationClass () == reqMode.GetModulationClass ()))
<                     {
<                       mode = testMode;
<                       //We've found a potentially-suitable transmit rate, but we
<                       //need to continue and consider all the basic rates before
<                       //we can be sure we've got the right one.
<                       found = true;
<                     }
<                 }
<             }
<         }
<       //If we found a suitable rate in the BSSBasicRateSet, then we are
<       //done and can return that mode.
<       if (found)
<         {
<           NS_LOG_DEBUG ("MacLow::GetControlAnswerMode returning " << mode);
<           return mode;
<         }
< 
<       /**
<        * If no suitable basic rate was found, we search the mandatory
<        * rates. The standard (IEEE 802.11-2007, Section 9.6) says:
<        *
<        *   ...If no rate contained in the BSSBasicRateSet parameter meets
<        *   these conditions, then the control frame sent in response to a
<        *   received frame shall be transmitted at the highest mandatory
<        *   rate of the PHY that is less than or equal to the rate of the
<        *   received frame, and that is of the same modulation class as the
<        *   received frame. In addition, the Control Response frame shall
<        *   be sent using the same PHY options as the received frame,
<        *   unless they conflict with the requirement to use the
<        *   BSSBasicRateSet parameter.
<        *
<        * \todo Note that we're ignoring the last sentence for now, because
<        * there is not yet any manipulation here of PHY options.
<        */
<       for (uint8_t idx = 0; idx < m_phy->GetNModes (); idx++)
<         {
<           WifiMode thismode = m_phy->GetMode (idx);
<           /* If the rate:
<            *
<            *  - is a mandatory rate for the PHY, and
<            *  - is equal to or faster than our current best choice, and
<            *  - is less than or equal to the rate of the received frame, and
<            *  - is of the same modulation class as the received frame
<            *
<            * ...then it's our best choice so far.
<            */
<           if (thismode.IsMandatory ()
<               && (!found || thismode.IsHigherDataRate (mode))
<               && (!thismode.IsHigherDataRate (reqMode))
<               && (IsAllowedControlAnswerModulationClass (reqMode.GetModulationClass (), thismode.GetModulationClass ())))
<             {
<               mode = thismode;
<               //As above; we've found a potentially-suitable transmit
<               //rate, but we need to continue and consider all the
<               //mandatory rates before we can be sure we've got the right one.
<               found = true;
<             }
<         }
<       if (m_stationManager->GetHtSupported () )
<         {
<           for (uint8_t idx = 0; idx < m_phy->GetNMcs (); idx++)
<             {
<               WifiMode thismode = m_phy->GetMcs (idx);
<               if (thismode.IsMandatory ()
<                   && (!found || thismode.IsHigherDataRate (mode))
<                   && (!thismode.IsHigherCodeRate (reqMode))
<                   && (thismode.GetModulationClass () == reqMode.GetModulationClass ()))
<                 {
<                   mode = thismode;
<                   //As above; we've found a potentially-suitable transmit
<                   //rate, but we need to continue and consider all the
<                   //mandatory rates before we can be sure we've got the right one.
<                   found = true;
<                 }
<             }
<         }
<     }
< 
<   /**
<    * If we still haven't found a suitable rate for the response then
<    * someone has messed up the simulation configuration. This probably means
<    * that the WifiPhyStandard is not set correctly, or that a rate that
<    * is not supported by the PHY has been explicitly requested.
<    *
<    * Either way, it is serious - we can either disobey the standard or
<    * fail, and I have chosen to do the latter...
<    */
<   if (!found)
<     {
<       NS_FATAL_ERROR ("Can't find response rate for " << reqMode);
<     }
< 
<   NS_LOG_DEBUG ("MacLow::GetControlAnswerMode returning " << mode);
<   return mode;
---
>   Mac48Address to = hdr->GetAddr1 ();
>   return m_stationManager->GetDataTxVector (to, hdr, packet);
2065,2079c1390
<   NS_ASSERT (!to.IsGroup ());
<   WifiMode ctsMode = GetControlAnswerMode (rtsTxMode);
<   WifiTxVector v;
<   v.SetMode (ctsMode);
<   v.SetPreambleType (GetPreambleForTransmission (ctsMode.GetModulationClass (), m_stationManager->GetShortPreambleEnabled (), m_stationManager->UseGreenfieldForDestination (to)));
<   v.SetTxPowerLevel (m_stationManager->GetDefaultTxPowerLevel ());
<   v.SetChannelWidth (GetChannelWidthForTransmission (ctsMode, m_phy->GetChannelWidth ()));
<    uint16_t ctsTxGuardInterval = ConvertGuardIntervalToNanoSeconds (ctsMode, m_phy->GetShortGuardInterval (), m_phy->GetGuardInterval ());
<   v.SetGuardInterval (ctsTxGuardInterval);
<   v.SetNss (1);
<   if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<     {
<       v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_phy)->GetChannelConfiguration ());
<     }
<   return v;
---
>   return m_stationManager->GetCtsTxVector (to, rtsTxMode);
2085,2101c1396
<   NS_ASSERT (!to.IsGroup ());
<   WifiMode ackMode = GetControlAnswerMode (dataTxMode);
<   WifiTxVector v;
<   v.SetMode (ackMode);
<   v.SetPreambleType (GetPreambleForTransmission (ackMode.GetModulationClass (), m_stationManager->GetShortPreambleEnabled (), m_stationManager->UseGreenfieldForDestination (to)));
<   v.SetTxPowerLevel (m_stationManager->GetDefaultTxPowerLevel ());
<   v.SetChannelWidth (GetChannelWidthForTransmission (ackMode, m_phy->GetChannelWidth ()));
<    uint16_t ackTxGuardInterval = ConvertGuardIntervalToNanoSeconds (ackMode, m_phy->GetShortGuardInterval (), m_phy->GetGuardInterval ());
<   v.SetGuardInterval (ackTxGuardInterval);
<   v.SetNss (1);
<   //// WIGIG ////
<   if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<     {
<       v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_phy)->GetChannelConfiguration ());
<     }
<   //// WIGIG ////
<   return v;
---
>   return m_stationManager->GetAckTxVector (to, dataTxMode);
2104,2111d1398
< //// WIGIG ////
< WifiTxVector
< MacLow::GetDmgControlTxVector (void) const
< {
<   return m_stationManager->GetDmgControlTxVector ();
< }
< //// WIGIG ////
< 
2115,2131c1402
<   NS_ASSERT (!to.IsGroup ());
<   WifiMode blockAckMode = GetControlAnswerMode (dataTxMode);
<   WifiTxVector v;
<   v.SetMode (blockAckMode);
<   v.SetPreambleType (GetPreambleForTransmission (blockAckMode.GetModulationClass (), m_stationManager->GetShortPreambleEnabled (), m_stationManager->UseGreenfieldForDestination (to)));
<   v.SetTxPowerLevel (m_stationManager->GetDefaultTxPowerLevel ());
<   v.SetChannelWidth (GetChannelWidthForTransmission (blockAckMode, m_phy->GetChannelWidth ()));
<   uint16_t blockAckTxGuardInterval = ConvertGuardIntervalToNanoSeconds (blockAckMode, m_phy->GetShortGuardInterval (), m_phy->GetGuardInterval ());
<   v.SetGuardInterval (blockAckTxGuardInterval);
<   v.SetNss (1);
<   //// WIGIG ////
<   if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<     {
<       v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_phy)->GetChannelConfiguration ());
<     }
<   //// WIGIG ////
<   return v;
---
>   return m_stationManager->GetBlockAckTxVector (to, dataTxMode);
2149,2150c1420
<                                 const MacLowTransmissionParameters& params,
<                                 uint32_t fragmentSize) const
---
>                                 const MacLowTransmissionParameters& params) const
2152,2155c1422,1446
<   Ptr<const WifiMacQueueItem> item = Create<const WifiMacQueueItem> (packet, *hdr);
<   Time txTime = CalculateOverheadTxTime (item, params);
<   uint32_t dataSize;
<   if (fragmentSize > 0)
---
>   WifiPreamble preamble;
>   Time txTime = Seconds (0);
>   if (params.MustSendRts ())
>     {
>       WifiTxVector rtsTxVector = GetRtsTxVector (packet, hdr);
>       //standard says RTS packets can have GF format sec 9.6.0e.1 page 110 bullet b 2
>       if (m_phy->GetGreenfield () && m_stationManager->GetGreenfieldSupported (m_currentHdr.GetAddr1 ()))
>         {
>           preamble = WIFI_PREAMBLE_HT_GF;
>         }
>       //Otherwise, RTS should always use non-HT PPDU (HT PPDU cases not supported yet)
>       else if (m_stationManager->GetShortPreambleEnabled ())
>         {
>           preamble = WIFI_PREAMBLE_SHORT;
>         }
>       else
>         {
>           preamble = WIFI_PREAMBLE_LONG;
>         }
>       txTime += m_phy->CalculateTxDuration (GetRtsSize (), rtsTxVector, preamble, m_phy->GetFrequency ());
>       txTime += GetCtsDuration (hdr->GetAddr1 (), rtsTxVector);
>       txTime += Time (GetSifs () * 2);
>     }
>   WifiTxVector dataTxVector = GetDataTxVector (packet, hdr);
>   if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
2157,2158c1448,1460
<       Ptr<const Packet> fragment = Create<Packet> (fragmentSize);
<       dataSize = GetSize (fragment, hdr, m_currentPacket && m_currentPacket->IsAggregate ());
---
>       preamble = WIFI_PREAMBLE_VHT;
>     }
>   else if (m_phy->GetGreenfield () && m_stationManager->GetGreenfieldSupported (m_currentHdr.GetAddr1 ()))
>     {
>       preamble = WIFI_PREAMBLE_HT_GF;
>     }
>   else if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
>     {
>       preamble = WIFI_PREAMBLE_HT_MF;
>     }
>   else if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
2162c1464
<       dataSize = GetSize (packet, hdr, m_currentPacket && m_currentPacket->IsAggregate ());
---
>       preamble = WIFI_PREAMBLE_LONG;
2164,2173c1466,1468
<   txTime += m_phy->CalculateTxDuration (dataSize, GetDataTxVector (item), m_phy->GetFrequency ());
<   return txTime;
< }
< 
< Time
< MacLow::CalculateOverheadTxTime (Ptr<const WifiMacQueueItem> item,
<                                  const MacLowTransmissionParameters& params) const
< {
<   Time txTime = Seconds (0);
<   if (params.MustSendRts ())
---
>   uint32_t dataSize = GetSize (packet, hdr);
>   txTime += m_phy->CalculateTxDuration (dataSize, dataTxVector, preamble, m_phy->GetFrequency ());
>   if (params.MustWaitAck ())
2175,2178c1470,1471
<       WifiTxVector rtsTxVector = GetRtsTxVector (item);
<       txTime += m_phy->CalculateTxDuration (GetRtsSize (), rtsTxVector, m_phy->GetFrequency ());
<       txTime += GetCtsDuration (item->GetHeader ().GetAddr1 (), rtsTxVector);
<       txTime += Time (GetSifs () * 2);
---
>       txTime += GetSifs ();
>       txTime += GetAckDuration (hdr->GetAddr1 (), dataTxVector);
2180,2181d1472
<   txTime += GetResponseDuration (params, GetDataTxVector (item), item->GetHeader ().GetAddr1 ());
< 
2193c1484,1505
<       WifiTxVector dataTxVector = GetDataTxVector (Create<const WifiMacQueueItem> (packet, *hdr));
---
>       WifiTxVector dataTxVector = GetDataTxVector (packet, hdr);
>       WifiPreamble preamble;
>       if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
>         {
>           preamble = WIFI_PREAMBLE_VHT;
>         }
>       if (m_phy->GetGreenfield () && m_stationManager->GetGreenfieldSupported (m_currentHdr.GetAddr1 ()))
>         {
>           preamble = WIFI_PREAMBLE_HT_GF;
>         }
>       else if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
>         {
>           preamble = WIFI_PREAMBLE_HT_MF;
>         }
>       else if (m_stationManager->GetShortPreambleEnabled ())
>         {
>           preamble = WIFI_PREAMBLE_SHORT;
>         }
>       else
>         {
>           preamble = WIFI_PREAMBLE_LONG;
>         }
2195c1507
<       txTime += m_phy->CalculateTxDuration (params.GetNextPacketSize (), dataTxVector, m_phy->GetFrequency ());
---
>       txTime += m_phy->CalculateTxDuration (params.GetNextPacketSize (), dataTxVector, preamble, m_phy->GetFrequency ());
2200,2220d1511
< //// WIGIG ////
< Time
< MacLow::CalculateWiGigTransactionTime (Ptr<WifiPsdu> psdu)
< {
<   NS_LOG_FUNCTION (this << psdu);
<   Time txTime = m_phy->CalculateTxDuration (psdu->GetSize (), m_currentTxVector, m_phy->GetFrequency ());
<   /* Calculate overhead duration */
<   if (m_txParams.MustSendRts ())
<     {
<       WifiTxVector rtsTxVector = GetDmgControlTxVector ();
<       txTime += m_phy->CalculateTxDuration (GetRtsSize (), rtsTxVector, m_phy->GetFrequency ());
<       txTime += GetCtsDuration (psdu->GetAddr1 (), rtsTxVector);
<       txTime += Time (GetSifs () * 2);
<     }
<   txTime += GetResponseDuration (m_txParams, m_currentTxVector, psdu->GetAddr1 ());
<   /* Convert to MicroSeconds since the duration in the headers are in MicroSeconds */
<   return MicroSeconds (ceil ((double) txTime.GetNanoSeconds () / 1000));
<   return Seconds (0);
< }
< //// WIGIG ////
< 
2222c1513
< MacLow::NotifyNav (Ptr<const Packet> packet, const WifiMacHeader &hdr)
---
> MacLow::NotifyNav (Ptr<const Packet> packet,const WifiMacHeader &hdr, WifiPreamble preamble)
2225,2230d1515
<   if (hdr.GetRawDuration () > 32767)
<     {
<       //All stations process Duration field values less than or equal to 32 767 from valid data frames
<       //to update their NAV settings as appropriate under the coordination function rules.
<       return;
<     }
2232c1517,1519
<   if (hdr.IsCfPoll () && hdr.GetAddr2 () == m_bssid)
---
> 
>   if (hdr.IsCfpoll ()
>       && hdr.GetAddr2 () == m_bssid)
2238,2243c1525,1526
<   else if (hdr.IsCfEnd () && hdr.GetAddr2 () == m_bssid)
<     {
<       //see section 9.3.2.2 802.11-1999
<       DoNavResetNow (Seconds (0));
<       return;
<     }
---
>   /// \todo We should also handle CF_END specially here
>   /// but we don't for now because we do not generate them.
2246,2258d1528
<       if (hdr.IsGrantFrame ())
<         {
<           // see section 9.33.7.3 802.11ad-2012
<           Ptr<Packet> newPacket = packet->Copy ();
<           CtrlDMG_Grant grant;
<           newPacket->RemoveHeader (grant);
<           Ptr<DmgStaWifiMac> highMac = DynamicCast<DmgStaWifiMac> (m_mac);
<           if (grant.GetDynamicAllocationInfo ().GetSourceAID () == highMac->GetAssociationID () ||
<               grant.GetDynamicAllocationInfo ().GetDestinationAID () == highMac->GetAssociationID ())
<             {
<               return;
<             }
<         }
2266,2269c1536,1539
<            * period with a duration of (2 * aSIFSTime) + (CTS_Time) + aRxPHYStartDelay + (2 * aSlotTime)
<            * starting at the PHY-RXEND.indication corresponding to the detection of the RTS frame. The
<            * “CTS_Time” shall be calculated using the length of the CTS frame and the data rate at which
<            * the RTS frame used for the most recent NAV update was received.
---
>            * period with a duration of (2 * aSIFSTime) + (CTS_Time) + (2 * aSlotTime) starting at the
>            * PHY-RXEND.indication corresponding to the detection of the RTS frame. The “CTS_Time” shall
>            * be calculated using the length of the CTS frame and the data rate at which the RTS frame
>            * used for the most recent NAV update was received.
2273c1543
<           WifiTxVector txVector = GetRtsTxVector (Create<const WifiMacQueueItem> (packet, hdr));
---
>           WifiTxVector txVector = GetRtsTxVector (packet, &hdr);
2275,2277c1545,1546
<             m_phy->CalculateTxDuration (cts.GetSerializedSize (), txVector, m_phy->GetFrequency ()) +
<             Time (2 * GetSifs ()) + Time (2 * GetSlotTime ()) +
<             m_phy->CalculatePhyPreambleAndHeaderDuration (txVector);
---
>             m_phy->CalculateTxDuration (cts.GetSerializedSize (), txVector, preamble, m_phy->GetFrequency ()) +
>             Time (2 * GetSifs ()) + Time (2 * GetSlotTime ());
2279,2280c1548,1549
<                                                             &MacLow::DoNavResetNow, this,
<                                                             Seconds (0));
---
>                                                             &MacLow::NavCounterResetCtsMissed, this,
>                                                             Simulator::Now ());
2285a1555,1563
> MacLow::NavCounterResetCtsMissed (Time rtsEndRxTime)
> {
>   if (m_phy->GetLastRxStartTime () < rtsEndRxTime)
>     {
>       DoNavResetNow (Seconds (0.0));
>     }
> }
> 
> void
2288,2289c1566
<   NS_LOG_FUNCTION (this << duration);
<   for (ChannelAccessManagersCI i = m_channelAccessManagers.begin (); i != m_channelAccessManagers.end (); i++)
---
>   for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
2291c1568
<       (*i)->NotifyNavResetNow (duration);
---
>       (*i)->NavReset (duration);
2300c1577
<   for (ChannelAccessManagersCI i = m_channelAccessManagers.begin (); i != m_channelAccessManagers.end (); i++)
---
>   for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
2302c1579
<       (*i)->NotifyNavStartNow (duration);
---
>       (*i)->NavStart (duration);
2318c1595
<   for (ChannelAccessManagersCI i = m_channelAccessManagers.begin (); i != m_channelAccessManagers.end (); i++)
---
>   for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
2320c1597
<       (*i)->NotifyAckTimeoutStartNow (duration);
---
>       (*i)->AckTimeoutStart (duration);
2325c1602
< MacLow::NotifyAckTimeoutResetNow (void)
---
> MacLow::NotifyAckTimeoutResetNow ()
2327c1604
<   for (ChannelAccessManagersCI i = m_channelAccessManagers.begin (); i != m_channelAccessManagers.end (); i++)
---
>   for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
2329c1606
<       (*i)->NotifyAckTimeoutResetNow ();
---
>       (*i)->AckTimeoutReset ();
2336c1613
<   for (ChannelAccessManagersCI i = m_channelAccessManagers.begin (); i != m_channelAccessManagers.end (); i++)
---
>   for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
2338c1615
<       (*i)->NotifyCtsTimeoutStartNow (duration);
---
>       (*i)->CtsTimeoutStart (duration);
2343c1620
< MacLow::NotifyCtsTimeoutResetNow (void)
---
> MacLow::NotifyCtsTimeoutResetNow ()
2345c1622
<   for (ChannelAccessManagersCI i = m_channelAccessManagers.begin (); i != m_channelAccessManagers.end (); i++)
---
>   for (DcfListenersCI i = m_dcfListeners.begin (); i != m_dcfListeners.end (); i++)
2347c1624
<       (*i)->NotifyCtsTimeoutResetNow ();
---
>       (*i)->CtsTimeoutReset ();
2352c1629,1630
< MacLow::ForwardDown (Ptr<const WifiPsdu> psdu, WifiTxVector txVector)
---
> MacLow::ForwardDown (Ptr<const Packet> packet, const WifiMacHeader* hdr,
>                      WifiTxVector txVector, WifiPreamble preamble)
2354,2361c1632,1635
<   NS_LOG_FUNCTION (this << psdu << txVector);
< 
<   NS_ASSERT (psdu->GetNMpdus ());
<   const WifiMacHeader& hdr = (*psdu->begin ())->GetHeader ();
< 
<   NS_LOG_DEBUG ("send " << hdr.GetTypeString () <<
<                 ", to=" << hdr.GetAddr1 () <<
<                 ", size=" << psdu->GetSize () <<
---
>   NS_LOG_FUNCTION (this << packet << hdr << txVector);
>   NS_LOG_DEBUG ("send " << hdr->GetTypeString () <<
>                 ", to=" << hdr->GetAddr1 () <<
>                 ", size=" << packet->GetSize () <<
2363,2369c1637,1643
<                 ", preamble=" << txVector.GetPreambleType () <<
<                 ", duration=" << hdr.GetDuration () <<
<                 ", seq=0x" << std::hex << hdr.GetSequenceControl () << std::dec);
< 
<   //// WIGIG ////
<   /* Antenna steering */
<   if ((m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ad) || (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay))
---
>                 ", duration=" << hdr->GetDuration () <<
>                 ", seq=0x" << std::hex << m_currentHdr.GetSequenceControl () << std::dec);
>   if (!m_ampdu || hdr->IsRts () || hdr->IsBlockAck ())
>     {
>       m_phy->SendPacket (packet, txVector, preamble);
>     }
>   else
2371,2374c1645,1659
<       Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<       /* Change antenna configuration */
<       if (((wifiMac->GetCurrentAccessPeriod () == CHANNEL_ACCESS_DTI) && (wifiMac->GetCurrentAllocation () == CBAP_ALLOCATION))
<           || (wifiMac->GetCurrentAccessPeriod () == CHANNEL_ACCESS_ATI))
---
>       Ptr<Packet> newPacket;
>       Ptr <const Packet> dequeuedPacket;
>       WifiMacHeader newHdr;
>       WifiMacTrailer fcs;
>       m_nTxMpdus = m_aggregateQueue->GetSize ();
>       uint32_t queueSize = m_aggregateQueue->GetSize ();
>       bool vhtSingleMpdu = false;
>       bool last = false;
>       enum mpduType mpdutype = NORMAL_MPDU;
>       
>       uint8_t tid = GetTid (packet, *hdr);
>       AcIndex ac = QosUtilsMapTidToAc (tid);
>       std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
> 
>       if (queueSize == 1)
2376c1661,1680
<           if ((wifiMac->GetTypeOfStation () == DMG_AP) && (hdr.IsAck () || hdr.IsBlockAck ()))
---
>           vhtSingleMpdu = true;
>         }
> 
>       //Add packet tag
>       AmpduTag ampdutag;
>       ampdutag.SetAmpdu (true);
>       Time delay = Seconds (0);
>       Time remainingAmpduDuration = m_phy->CalculateTxDuration (packet->GetSize (), txVector, preamble, m_phy->GetFrequency ());
>       if (queueSize > 1 || vhtSingleMpdu)
>         {
>           txVector.SetAggregation (true);
>         }
>       for (; queueSize > 0; queueSize--)
>         {
>           dequeuedPacket = m_aggregateQueue->Dequeue (&newHdr);
>           newPacket = dequeuedPacket->Copy ();
>           newHdr.SetDuration (hdr->GetDuration ());
>           newPacket->AddHeader (newHdr);
>           newPacket->AddTrailer (fcs);
>           if (queueSize == 1)
2378c1682,1683
<               wifiMac->SteerTxAntennaToward (hdr.GetAddr1 (), (false));
---
>               last = true;
>               mpdutype = LAST_MPDU_IN_AGGREGATE;
2380c1685,1688
<           else if (!(hdr.IsSSW () || hdr.IsSSW_ACK () || hdr.IsSSW_FBCK () || m_servingMimoBFT)) /* Special case to handle TXSS CBAP*/
---
> 
>           listenerIt->second->GetMpduAggregator ()->AddHeaderAndPad (newPacket, last, vhtSingleMpdu);
>           
>           if (delay == Seconds (0))
2382c1690,1698
<               wifiMac->SteerAntennaToward (hdr.GetAddr1 (), hdr.IsData ());
---
>               if (!vhtSingleMpdu)
>                 {
>                   NS_LOG_DEBUG ("Sending MPDU as part of A-MPDU");
>                   mpdutype = MPDU_IN_AGGREGATE;
>                 }
>               else
>                 {
>                   mpdutype = NORMAL_MPDU;
>                 }
2384,2387c1700,1705
<         }
<       else if (wifiMac->GetTypeOfStation () == DMG_ADHOC)
<         {
<           if ((hdr.IsAck () || hdr.IsBlockAck ()))
---
>           
>           Time mpduDuration = m_phy->CalculateTxDuration (newPacket->GetSize (), txVector, preamble, m_phy->GetFrequency (), mpdutype, 0);
>           remainingAmpduDuration -= mpduDuration;
> 
>           ampdutag.SetRemainingNbOfMpdus (queueSize - 1);
>           if (queueSize > 1)
2389c1707
<               wifiMac->SteerTxAntennaToward (hdr.GetAddr1 (), true);
---
>               ampdutag.SetRemainingAmpduDuration (remainingAmpduDuration);
2393c1711
<               wifiMac->SteerAntennaToward (hdr.GetAddr1 (), (hdr.IsData () || hdr.IsAck () || hdr.IsBlockAck ()));
---
>               ampdutag.SetRemainingAmpduDuration (NanoSeconds (0));
2395,2421c1713
<         }
<     }
<   //// WIGIG ////
< 
<   if (hdr.IsCfPoll () && m_stationManager->GetPcfSupported ())
<     {
<       Simulator::Schedule (GetPifs () + m_phy->CalculateTxDuration (psdu->GetSize (), txVector, m_phy->GetFrequency ()), &MacLow::CfPollTimeout, this);
<     }
<   if (hdr.IsBeacon () && m_stationManager->GetPcfSupported ())
<     {
<       if (Simulator::Now () > m_lastBeacon + m_beaconInterval)
<         {
<           m_cfpForeshortening = (Simulator::Now () - m_lastBeacon - m_beaconInterval);
<         }
<       m_lastBeacon = Simulator::Now ();
<     }
<   else if (hdr.IsCfEnd () && m_stationManager->GetPcfSupported ())
<     {
<       m_cfpStart = NanoSeconds (0);
<       m_cfpForeshortening = NanoSeconds (0);
<       m_cfAckInfo.appendCfAck = false;
<       m_cfAckInfo.expectCfAck = false;
<     }
<   else if (IsCfPeriod () && hdr.HasData ())
<     {
<       m_cfAckInfo.expectCfAck = true;
<     }
---
>           newPacket->AddPacketTag (ampdutag);
2423,2436c1715,1727
<   if (psdu->IsSingle ())
<     {
<       txVector.SetAggregation (true);
<       NS_LOG_DEBUG ("Sending S-MPDU");
<     }
<   else if (psdu->IsAggregate ())
<     {
<       txVector.SetAggregation (true);
<       NS_LOG_DEBUG ("Sending A-MPDU");
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Sending non aggregate MPDU");
<     }
---
>           if (delay == Seconds (0))
>             {
>               m_phy->SendPacket (newPacket, txVector, preamble, mpdutype);
>             }
>           else
>             {
>               Simulator::Schedule (delay, &MacLow::SendMpdu, this, newPacket, txVector, preamble, mpdutype);
>             }
>           if (queueSize > 1)
>             {
>               NS_ASSERT (remainingAmpduDuration > 0);
>               delay = delay + mpduDuration;
>             }
2438,2443c1729
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       if (mpdu->GetHeader ().IsQosData ())
<         {
<           auto edcaIt = m_edca.find (QosUtilsMapTidToAc (mpdu->GetHeader ().GetQosTid ()));
<           edcaIt->second->CompleteMpduTx (mpdu);
---
>           preamble = WIFI_PREAMBLE_NONE;
2446d1731
<   m_phy->Send (psdu, txVector);
2450c1735
< MacLow::CfPollTimeout (void)
---
> MacLow::SendMpdu (Ptr<const Packet> packet, WifiTxVector txVector, WifiPreamble preamble, enum mpduType mpdutype)
2452,2464c1737,1738
<   NS_LOG_FUNCTION (this);
<   //to be reworked
<   bool busy = false;
<   for (ChannelAccessManagersCI i = m_channelAccessManagers.begin (); i != m_channelAccessManagers.end (); i++)
<     {
<       busy = (*i)->IsBusy ();
<     }
<   if (!busy)
<     {
<       NS_ASSERT (m_currentTxop != 0);
<       m_currentTxop->MissedCfPollResponse (m_cfAckInfo.expectCfAck);
<       m_cfAckInfo.expectCfAck = false;
<     }
---
>   NS_LOG_DEBUG ("Sending MPDU as part of A-MPDU");
>   m_phy->SendPacket (packet, txVector, preamble, mpdutype);
2472,2475c1746,1776
<   /// \todo should check that there was no RX start before now.
<   /// we should restart a new CTS timeout now until the expected
<   /// end of RX if there was a RX start before now.
<   m_stationManager->ReportRtsFailed (m_currentPacket->GetAddr1 (), &m_currentPacket->GetHeader (0));
---
>   /// \todo should check that there was no rx start before now.
>   /// we should restart a new cts timeout now until the expected
>   /// end of rx if there was a rx start before now.
>   m_stationManager->ReportRtsFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
>   if (m_sentMpdus == 0)
>     {
>       m_currentPacket = 0;
>     }
>   MacLowTransmissionListener *listener = m_listener;
>   m_listener = 0;
>   m_sentMpdus = 0;
>   m_ampdu = false;
>   listener->MissedCts ();
> }
> 
> void
> MacLow::NormalAckTimeout (void)
> {
>   NS_LOG_FUNCTION (this);
>   NS_LOG_DEBUG ("normal ack timeout");
>   /// \todo should check that there was no rx start before now.
>   /// we should restart a new ack timeout now until the expected
>   /// end of rx if there was a rx start before now.
>   m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
>   MacLowTransmissionListener *listener = m_listener;
>   m_listener = 0;
>   m_sentMpdus = 0;
>   m_ampdu = false;
>   FlushAggregateQueue ();
>   listener->MissedAck ();
> }
2477,2478c1778,1785
<   Ptr<QosTxop> qosTxop = DynamicCast<QosTxop> (m_currentTxop);
<   if (qosTxop != 0)
---
> void
> MacLow::FastAckTimeout (void)
> {
>   NS_LOG_FUNCTION (this);
>   m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
>   MacLowTransmissionListener *listener = m_listener;
>   m_listener = 0;
>   if (m_phy->IsStateIdle ())
2480c1787,1788
<       qosTxop->NotifyMissedCts (std::list<Ptr<WifiMacQueueItem>> (m_currentPacket->begin (), m_currentPacket->end ()));
---
>       NS_LOG_DEBUG ("fast Ack idle missed");
>       listener->MissedAck ();
2484c1792
<       m_currentTxop->MissedCts ();
---
>       NS_LOG_DEBUG ("fast Ack ok");
2486,2488d1793
<   m_currentTxop = 0;
<   //// WIGIG ////
<   m_currentPacket = 0;
2492c1797
< MacLow::NormalAckTimeout (void)
---
> MacLow::BlockAckTimeout (void)
2495,2503c1800,1806
<   NS_LOG_DEBUG ("normal ack timeout");
<   /// \todo should check that there was no RX start before now.
<   /// we should restart a new ack timeout now until the expected
<   /// end of RX if there was a RX start before now.
<   Ptr<Txop> txop = m_currentTxop;
<   m_currentTxop = 0;
<   txop->MissedAck ();
<   //// WIGIG ////
<   m_currentPacket = 0;
---
>   NS_LOG_DEBUG ("block ack timeout");
>   MacLowTransmissionListener *listener = m_listener;
>   m_listener = 0;
>   m_sentMpdus = 0;
>   m_ampdu = false;
>   FlushAggregateQueue ();
>   listener->MissedBlockAck (m_nTxMpdus);
2507c1810
< MacLow::BlockAckTimeout (void)
---
> MacLow::SuperFastAckTimeout ()
2510,2515c1813,1825
<   NS_LOG_DEBUG ("block ack timeout");
<   Ptr<Txop> txop = m_currentTxop;
<   m_currentTxop = 0;
<   txop->MissedBlockAck (m_currentPacket->GetNMpdus ());
<   //// WIGIG ////
<   m_currentPacket = 0;
---
>   m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
>   MacLowTransmissionListener *listener = m_listener;
>   m_listener = 0;
>   if (m_phy->IsStateIdle ())
>     {
>       NS_LOG_DEBUG ("super fast Ack failed");
>       listener->MissedAck ();
>     }
>   else
>     {
>       NS_LOG_DEBUG ("super fast Ack ok");
>       listener->GotAck (0.0, WifiMode ());
>     }
2529c1839
<   rts.SetAddr1 (m_currentPacket->GetAddr1 ());
---
>   rts.SetAddr1 (m_currentHdr.GetAddr1 ());
2531c1841,1842
<   WifiTxVector rtsTxVector = GetRtsTxVector (*m_currentPacket->begin ());
---
>   WifiTxVector rtsTxVector = GetRtsTxVector (m_currentPacket, &m_currentHdr);
>   Time duration = Seconds (0);
2533,2541c1844,1857
<   /* Check if a control trailer needs to be added to the RTS packet - for RTS packets before MIMO transmissions */
<   bool addControlTrailer = false;
<   DATA_COMMUNICATION_MODE dataMode = DATA_MODE_SISO;
<   Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<   if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<     {
<       dataMode = wifiMac->GetStationDataCommunicationMode (rts.GetAddr1 ());
<       addControlTrailer = (dataMode != DATA_MODE_SISO);
<       rtsTxVector.SetControlTrailerPresent (addControlTrailer);
---
>   WifiPreamble preamble;
>   //standard says RTS packets can have GF format sec 9.6.0e.1 page 110 bullet b 2
>   if (m_phy->GetGreenfield () && m_stationManager->GetGreenfieldSupported (m_currentHdr.GetAddr1 ()))
>     {
>       preamble = WIFI_PREAMBLE_HT_GF;
>     }
>   //Otherwise, RTS should always use non-HT PPDU (HT PPDU cases not supported yet)
>   else if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
2544,2552c1860,1864
<   Time duration = Seconds (0);
< 
<   duration += GetSifs ();
<   duration += GetCtsDuration (m_currentPacket->GetAddr1 (), rtsTxVector, addControlTrailer);
<   duration += GetSifs ();
<   duration += m_phy->CalculateTxDuration (m_currentPacket->GetSize (),
<                                           m_currentTxVector, m_phy->GetFrequency ());
<   duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
<   if (m_txParams.HasNextPacket ())
---
>   if (m_txParams.HasDurationId ())
>     {
>       duration += m_txParams.GetDurationId ();
>     }
>   else
2554,2556c1866,1895
<       duration += m_phy->CalculateTxDuration (m_txParams.GetNextPacketSize (),
<                                               m_currentTxVector, m_phy->GetFrequency ());
<       duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>       duration += GetSifs ();
>       duration += GetCtsDuration (m_currentHdr.GetAddr1 (), rtsTxVector);
>       duration += GetSifs ();
>       duration += m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr),
>                                               m_currentTxVector, preamble, m_phy->GetFrequency ());
>       duration += GetSifs ();
>       if (m_txParams.MustWaitBasicBlockAck ())
>         {
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, BASIC_BLOCK_ACK);
>         }
>       else if (m_txParams.MustWaitCompressedBlockAck ())
>         {
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>         }
>       else if (m_txParams.MustWaitAck ())
>         {
>           duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>         }
>       if (m_txParams.HasNextPacket ())
>         {
>           duration += m_phy->CalculateTxDuration (m_txParams.GetNextPacketSize (),
>                                                   m_currentTxVector, preamble, m_phy->GetFrequency ());
>           if (m_txParams.MustWaitAck ())
>             {
>               duration += GetSifs ();
>               duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>             }
>         }
2559a1899,1900
>   Time txDuration = m_phy->CalculateTxDuration (GetRtsSize (), rtsTxVector, preamble, m_phy->GetFrequency ());
>   Time timerDelay = txDuration + GetCtsTimeout ();
2561,2566d1901
<   Time txDuration = m_phy->CalculateTxDuration (GetRtsSize (addControlTrailer), rtsTxVector, m_phy->GetFrequency ());
<   // After transmitting an RTS frame, the STA shall wait for a CTSTimeout interval with
<   // a value of aSIFSTime + aSlotTime + aRxPHYStartDelay (IEEE 802.11-2016 sec. 10.3.2.7).
<   // aRxPHYStartDelay equals the time to transmit the PHY header.
<   Time timerDelay = txDuration + GetSifs () + GetSlotTime ()
<                     + m_phy->CalculatePhyPreambleAndHeaderDuration (rtsTxVector);
2572,2590c1907,1911
<   if (addControlTrailer)
<     {
<       ControlTrailer ct;
<       ct.SetControlTrailerFormatType (CT_TYPE_GRANT_RTS_CTS2SELF);
<       ct.SetAsMimoTransmission (true);
<       if (dataMode == DATA_MODE_SU_MIMO)
<         {
<           // For now we use the top combination as reported by the SU_MIMO BFT protocol for MIMO communication.
<           ct.SetTxSectorCombinationIdx (0);
<           wifiMac->UpdateBestMimoTxAntennaConfigurationIndex (rts.GetAddr1 (), 0);
<         }
<       else
<         {
<           ct.SetAsMuMimoTransmission (true);
<           // To do: Set the other parameters regarding MU-MIMO RTS
<         }
<       packet->AddHeader (ct);
<     }
<   ForwardDown (Create<const WifiPsdu> (packet, rts), rtsTxVector);
---
>   packet->AddHeader (rts);
>   WifiMacTrailer fcs;
>   packet->AddTrailer (fcs);
> 
>   ForwardDown (packet, &rts, rtsTxVector, preamble);
2596,2598c1917,1924
<   NS_LOG_FUNCTION (this);
<   Time txDuration = m_phy->CalculateTxDuration (m_currentPacket->GetSize (), dataTxVector, m_phy->GetFrequency ());
<   if (m_txParams.MustWaitNormalAck () && !IsCfPeriod ())
---
>   WifiPreamble preamble;
> 
>   if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
>     {
>       preamble = WIFI_PREAMBLE_VHT;
>     }
>   //Since it is data then it can have format = GF
>   else if (m_phy->GetGreenfield () && m_stationManager->GetGreenfieldSupported (m_currentHdr.GetAddr1 ()))
2600,2606c1926,1944
<       // the timeout duration is "aSIFSTime + aSlotTime + aRxPHYStartDelay, starting
<       // at the PHY-TXEND.confirm primitive" (section 10.3.2.9 or 10.22.2.2 of 802.11-2016).
<       // aRxPHYStartDelay equals the time to transmit the PHY header.
<       WifiTxVector ackTxVector = GetAckTxVector (m_currentPacket->GetAddr1 (),
<                                                  dataTxVector.GetMode ());
<       Time timerDelay = txDuration + GetSifs () + GetSlotTime ()
<                         + m_phy->CalculatePhyPreambleAndHeaderDuration (ackTxVector);
---
>       preamble = WIFI_PREAMBLE_HT_GF;
>     }
>   else if (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
>     {
>       preamble = WIFI_PREAMBLE_HT_MF;
>     }
>   else if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
>     }
> 
>   Time txDuration = m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr), dataTxVector, preamble, m_phy->GetFrequency ());
>   if (m_txParams.MustWaitNormalAck ())
>     {
>       Time timerDelay = txDuration + GetAckTimeout ();
2611c1949,1964
<   else if (m_txParams.MustWaitBlockAck ())
---
>   else if (m_txParams.MustWaitFastAck ())
>     {
>       Time timerDelay = txDuration + GetPifs ();
>       NS_ASSERT (m_fastAckTimeoutEvent.IsExpired ());
>       NotifyAckTimeoutStartNow (timerDelay);
>       m_fastAckTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::FastAckTimeout, this);
>     }
>   else if (m_txParams.MustWaitSuperFastAck ())
>     {
>       Time timerDelay = txDuration + GetPifs ();
>       NS_ASSERT (m_superFastAckTimeoutEvent.IsExpired ());
>       NotifyAckTimeoutStartNow (timerDelay);
>       m_superFastAckTimeoutEvent = Simulator::Schedule (timerDelay,
>                                                         &MacLow::SuperFastAckTimeout, this);
>     }
>   else if (m_txParams.MustWaitBasicBlockAck ())
2613,2619c1966
<       // the timeout duration is "aSIFSTime + aSlotTime + aRxPHYStartDelay, starting
<       // at the PHY-TXEND.confirm primitive" (section 10.3.2.9 or 10.22.2.2 of 802.11-2016).
<       // aRxPHYStartDelay equals the time to transmit the PHY header.
<       WifiTxVector blockAckTxVector = GetBlockAckTxVector (m_currentPacket->GetAddr1 (),
<                                                            dataTxVector.GetMode ());
<       Time timerDelay = txDuration + GetSifs () + GetSlotTime ()
<                         + m_phy->CalculatePhyPreambleAndHeaderDuration (blockAckTxVector);
---
>       Time timerDelay = txDuration + GetBasicBlockAckTimeout ();
2624c1971
<   else if (m_txParams.HasNextPacket ())
---
>   else if (m_txParams.MustWaitCompressedBlockAck ())
2626,2636c1973,1976
<       NS_ASSERT (m_waitIfsEvent.IsExpired ());
<       Time delay = txDuration;
<       if (m_stationManager->GetRifsPermitted ())
<         {
<           delay += GetRifs ();
<         }
<       else
<         {
<           delay += GetSifs ();
<         }
<       m_waitIfsEvent = Simulator::Schedule (delay, &MacLow::WaitIfsAfterEndTxFragment, this);
---
>       Time timerDelay = txDuration + GetCompressedBlockAckTimeout ();
>       NS_ASSERT (m_blockAckTimeoutEvent.IsExpired ());
>       NotifyAckTimeoutStartNow (timerDelay);
>       m_blockAckTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::BlockAckTimeout, this);
2638,2643c1978
<   else if (m_currentPacket->GetHeader (0).IsQosData () && m_currentTxop->IsQosTxop () &&
<            m_currentTxop->GetTxopLimit ().IsStrictlyPositive ()
<            //// WIGIG ////
<            //&& m_currentTxop->GetTxopRemaining () > GetSifs ()
<            && m_currentTxop->GetRemainingTimeForTransmission () > GetSifs ())
<            //// WIGIG ////
---
>   else if (m_txParams.HasNextPacket ())
2645,2646c1980
<       Time delay = txDuration;
<       if (m_stationManager->GetRifsPermitted ())
---
>       if (m_stationManager->HasHtSupported ())
2648c1982,1984
<           delay += GetRifs ();
---
>           Time delay = txDuration + GetRifs ();
>           NS_ASSERT (m_waitRifsEvent.IsExpired ());
>           m_waitRifsEvent = Simulator::Schedule (delay, &MacLow::WaitSifsAfterEndTxFragment, this);
2652c1988,1990
<           delay += GetSifs ();
---
>           Time delay = txDuration + GetSifs ();
>           NS_ASSERT (m_waitSifsEvent.IsExpired ());
>           m_waitSifsEvent = Simulator::Schedule (delay, &MacLow::WaitSifsAfterEndTxFragment, this);
2654d1991
<       m_waitIfsEvent = Simulator::Schedule (delay, &MacLow::WaitIfsAfterEndTxPacket, this);
2659c1996
<       m_endTxNoAckEvent = Simulator::Schedule (txDuration, &MacLow::EndTxNoAck, this);
---
>       Simulator::Schedule (txDuration, &MacLow::EndTxNoAck, this);
2668,2670c2005,2006
<   StartDataTxTimers (m_currentTxVector);
<   //// WIGIG ////
<   if (m_txParams.HasDurationId ()) //// (Modification)
---
>   WifiPreamble preamble;
>   if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
2672c2008
<       m_currentPacket->SetDuration (m_txParams.GetDurationId ());
---
>       preamble = WIFI_PREAMBLE_VHT;
2674,2675c2010
<   //// WIGIG ////
<   else if (!IsCfPeriod ())
---
>   else if (m_phy->GetGreenfield () && m_stationManager->GetGreenfieldSupported (m_currentHdr.GetAddr1 ()))
2677,2692c2012,2033
<       Time duration = GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
<       if (m_txParams.HasNextPacket ())
<         {
<           if (m_stationManager->GetRifsPermitted ())
<             {
<               duration += GetRifs ();
<             }
<           else
<             {
<               duration += GetSifs ();
<             }
<           duration += m_phy->CalculateTxDuration (m_txParams.GetNextPacketSize (),
<                                                   m_currentTxVector, m_phy->GetFrequency ());
<           duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
<         }
<       m_currentPacket->SetDuration (duration);
---
>       //In the future has to make sure that receiver has greenfield enabled
>       preamble = WIFI_PREAMBLE_HT_GF;
>     }
>   else if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
>     {
>       preamble = WIFI_PREAMBLE_HT_MF;
>     }
>   else if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
>     }
> 
>   StartDataTxTimers (m_currentTxVector);
> 
>   Time duration = Seconds (0.0);
>   if (m_txParams.HasDurationId ())
>     {
>       duration += m_txParams.GetDurationId ();
2696c2037
<       if (m_currentPacket->GetHeader (0).IsCfEnd ())
---
>       if (m_txParams.MustWaitBasicBlockAck ())
2698c2039,2041
<           m_currentPacket->GetHeader (0).SetRawDuration (0);
---
>           duration += GetSifs ();
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, BASIC_BLOCK_ACK);
2700c2043,2054
<       else
---
>       else if (m_txParams.MustWaitCompressedBlockAck ())
>         {
>           duration += GetSifs ();
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>         }
>       else if (m_txParams.MustWaitAck ())
>         {
>           duration += GetSifs ();
>           duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>         }
>       if (m_txParams.HasNextPacket ())
2702c2056,2063
<           m_currentPacket->GetHeader (0).SetRawDuration (32768);
---
>           duration += GetSifs ();
>           duration += m_phy->CalculateTxDuration (m_txParams.GetNextPacketSize (),
>                                                   m_currentTxVector, preamble, m_phy->GetFrequency ());
>           if (m_txParams.MustWaitAck ())
>             {
>               duration += GetSifs ();
>               duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>             }
2704a2066
>   m_currentHdr.SetDuration (duration);
2706c2068
<   if (!m_currentPacket->IsAggregate ())
---
>   if (!m_ampdu)
2708,2753c2070,2072
<       if (m_cfAckInfo.appendCfAck)
<         {
<           switch (m_currentPacket->GetHeader (0).GetType ())
<             {
<             case WIFI_MAC_DATA:
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_DATA_CFACK, false);
<               break;
<             case WIFI_MAC_DATA_CFPOLL:
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_DATA_CFACK_CFPOLL, false);
<               break;
<             case WIFI_MAC_DATA_NULL:
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_DATA_NULL_CFACK, false);
<               break;
<             case WIFI_MAC_DATA_NULL_CFPOLL:
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_DATA_NULL_CFACK_CFPOLL, false);
<               break;
<             case WIFI_MAC_CTL_END:
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_CTL_END_ACK, false);
<               break;
<             default:
<               NS_ASSERT (false);
<               break;
<             }
<           NS_ASSERT (m_cfAckInfo.address != Mac48Address ());
<           //Standard says that, for frames of type Data+CF-Ack, Data+CF-Poll+CF-Ack, and CF-Poll+CF-Ack,
<           //the rate chosen to transmit the frame must be supported by both the addressed recipient STA and the STA to which the Ack is intended.
<           //This ideally requires the rate manager to handle this case, but this requires to update all rate manager classes.
<           //Instead, we simply fetch two TxVector and we select the one with the lowest data rate.
<           //This should be later changed, at the latest once HCCA is implemented for HT/VHT/HE stations.
<           WifiMacHeader tmpHdr = m_currentPacket->GetHeader (0);
<           tmpHdr.SetAddr1 (m_cfAckInfo.address);
<           WifiTxVector tmpTxVector = GetDataTxVector (Create<const WifiMacQueueItem> (m_currentPacket->GetPayload (0), tmpHdr));
<           if (tmpTxVector.GetMode ().GetDataRate (tmpTxVector) < m_currentTxVector.GetMode ().GetDataRate (m_currentTxVector))
<             {
<               m_currentTxVector = tmpTxVector;
<             }
<           m_cfAckInfo.appendCfAck = false;
<           m_cfAckInfo.address = Mac48Address ();
<         }
<     }
<   if (m_txParams.MustSendBlockAckRequest ())
<     {
<       Ptr<QosTxop> qosTxop = DynamicCast<QosTxop> (m_currentTxop);
<       NS_ASSERT (qosTxop != 0);
<       auto bar = qosTxop->PrepareBlockAckRequest (m_currentPacket->GetAddr1 (), *m_currentPacket->GetTids ().begin ());
<       qosTxop->ScheduleBar (bar);
---
>       m_currentPacket->AddHeader (m_currentHdr);
>       WifiMacTrailer fcs;
>       m_currentPacket->AddTrailer (fcs);
2755c2074,2076
<   ForwardDown (m_currentPacket, m_currentTxVector);
---
> 
>   ForwardDown (m_currentPacket, &m_currentHdr, m_currentTxVector, preamble);
>   m_currentPacket = 0;
2761c2082,2089
<   return (m_lastNavStart + m_lastNavDuration < Simulator::Now ());
---
>   if (m_lastNavStart + m_lastNavDuration < Simulator::Now ())
>     {
>       return true;
>     }
>   else
>     {
>       return false;
>     }
2775c2103,2118
<   WifiTxVector ctsTxVector = GetRtsTxVector (*m_currentPacket->begin ());
---
>   WifiTxVector ctsTxVector = GetRtsTxVector (m_currentPacket, &m_currentHdr);
> 
>   WifiPreamble preamble;
>   if (ctsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
>     {
>       preamble = WIFI_PREAMBLE_HT_MF;
>     }
>   else if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
>     }
> 
2778,2782c2121,2125
<   duration += GetSifs ();
<   duration += m_phy->CalculateTxDuration (m_currentPacket->GetSize (),
<                                           m_currentTxVector, m_phy->GetFrequency ());
<   duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
<   if (m_txParams.HasNextPacket ())
---
>   if (m_txParams.HasDurationId ())
>     {
>       duration += m_txParams.GetDurationId ();
>     }
>   else
2785,2787c2128,2164
<       duration += m_phy->CalculateTxDuration (m_txParams.GetNextPacketSize (),
<                                               m_currentTxVector, m_phy->GetFrequency ());
<       duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>       duration += m_phy->CalculateTxDuration (GetSize (m_currentPacket,&m_currentHdr),
>                                               m_currentTxVector, preamble, m_phy->GetFrequency ());
>       if (m_txParams.MustWaitBasicBlockAck ())
>         {
> 
>           duration += GetSifs ();
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, BASIC_BLOCK_ACK);
>         }
>       else if (m_txParams.MustWaitCompressedBlockAck ())
>         {
>           duration += GetSifs ();
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>         }
>       else if (m_txParams.MustWaitAck ())
>         {
>           duration += GetSifs ();
>           duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>         }
>       if (m_txParams.HasNextPacket ())
>         {
>           duration += GetSifs ();
>           duration += m_phy->CalculateTxDuration (m_txParams.GetNextPacketSize (),
>                                                   m_currentTxVector, preamble, m_phy->GetFrequency ());
>           if (m_txParams.MustWaitCompressedBlockAck ())
>             {
>               duration += GetSifs ();
>               WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>               duration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>             }
>           else if (m_txParams.MustWaitAck ())
>             {
>               duration += GetSifs ();
>               duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>             }
>         }
2792c2169,2174
<   ForwardDown (Create<const WifiPsdu> (Create<Packet> (), cts), ctsTxVector);
---
>   Ptr<Packet> packet = Create<Packet> ();
>   packet->AddHeader (cts);
>   WifiMacTrailer fcs;
>   packet->AddTrailer (fcs);
> 
>   ForwardDown (packet, &cts, ctsTxVector,preamble);
2794c2176
<   Time txDuration = m_phy->CalculateTxDuration (GetCtsSize (), ctsTxVector, m_phy->GetFrequency ());
---
>   Time txDuration = m_phy->CalculateTxDuration (GetCtsSize (), ctsTxVector, preamble, m_phy->GetFrequency ());
2799a2182
>                                          cts.GetAddr1 (),
2800a2184
> 
2820,2858c2204
<   NS_ASSERT (duration.IsPositive ());
<   cts.SetDuration (duration);
< 
<   Ptr<Packet> packet = Create<Packet> ();
< 
<   SnrTag tag;
<   tag.Set (rtsSnr);
<   packet->AddPacketTag (tag);
< 
<   //CTS should always use non-HT PPDU (HT PPDU cases not supported yet)
<   ForwardDown (Create<const WifiPsdu> (packet, cts), ctsTxVector);
< }
< 
< //// WIGIG ////
< void
< MacLow::SendDmgCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr)
< {
<   NS_LOG_FUNCTION (this << source << duration << rtsTxVector.GetMode () << rtsSnr);
<   /* Send a DMG CTS when we receive a RTS right after SIFS. */
<   WifiTxVector ctsTxVector = GetDmgControlTxVector ();
<   WifiMacHeader cts;
<   cts.SetType (WIFI_MAC_CTL_DMG_CTS);
<   cts.SetDsNotFrom ();
<   cts.SetDsNotTo ();
<   cts.SetNoMoreFragments ();
<   cts.SetNoRetry ();
<   cts.SetAddr1 (source);
<   cts.SetAddr2 (GetAddress ());
< 
<   /* Check if a control trailer needs to be added to the DMG CTS - for CTS before a MIMO transmission */
<   Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<   DATA_COMMUNICATION_MODE dataMode = wifiMac->GetStationDataCommunicationMode (source);
<   bool addControlTrailer = (dataMode != DATA_MODE_SISO);
<   ctsTxVector.SetControlTrailerPresent (addControlTrailer);
< 
<   /* Set duration field */
<   duration -= GetDmgCtsDuration (addControlTrailer);
<   duration -= GetSifs ();
<   NS_ASSERT (duration.IsPositive ());
---
>   NS_ASSERT (duration >= MicroSeconds (0));
2861a2208,2210
>   packet->AddHeader (cts);
>   WifiMacTrailer fcs;
>   packet->AddTrailer (fcs);
2866,2868c2215,2217
< 
<   /* When using RTS/CTS for channel access for MIMO communication a control trailer needs to be added to the packet */
<   if (addControlTrailer)
---
>   
>   WifiPreamble preamble;
>   if (m_stationManager->GetShortPreambleEnabled ())
2870,2887c2219,2223
<       ControlTrailer ct;
<       ct.SetControlTrailerFormatType (CT_TYPE_CTS_DTS);
<       ct.SetAsMimoTransmission (false);
<       /* For now only the station transmitting the data transmits in MIMO while the receiver responds in SISO mode */
< //      if (dataMode == DATA_MODE_SU_MIMO)
< //        {
< //          // For now we use the top combination as reported by the SU_MIMO BFT protocol for MIMO communication.
< //          ct.SetTxSectorCombinationIdx (0);
< //          wifiMac->UpdateBestMimoTxAntennaConfigurationIndex (source, 0);
< //        }
< //      else
< //        {
< //          ct.SetAsMuMimoTransmission (true);
< //          // To do: Set the other parameters regarding MU-MIMO RTS
< //        }
<       packet->AddHeader (ct);
<       /* After sending the CTS set up the receive antennas in the comfiguration needed for MIMO reception */
<       Simulator::Schedule (GetDmgCtsDuration (addControlTrailer), &DmgWifiMac::SteerMimoRxAntennaToward, wifiMac, source);
---
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
2890c2226,2227
<   ForwardDown (Create<const WifiPsdu> (packet, cts), ctsTxVector);
---
>   //CTS should always use non-HT PPDU (HT PPDU cases not supported yet)
>   ForwardDown (packet, &cts, ctsTxVector, preamble);
2892d2228
< //// WIGIG ////
2895c2231
< MacLow::SendDataAfterCts (Time duration)
---
> MacLow::SendDataAfterCts (Mac48Address source, Time duration)
2899c2235
<    * RTS/CTS/Data/Ack handshake
---
>    * RTS/CTS/DATA/ACK hanshake
2902a2239,2274
>   if (m_aggregateQueue->GetSize () != 0)
>     {
>       for (std::vector<Item>::size_type i = 0; i != m_txPackets.size (); i++)
>         {
>           uint8_t tid = GetTid (m_txPackets.at (i).packet, m_txPackets.at (i).hdr);
>           AcIndex ac = QosUtilsMapTidToAc (tid);
>           std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
> 
>           listenerIt->second->CompleteMpduTx (m_txPackets.at (i).packet, m_txPackets.at (i).hdr, m_txPackets.at (i).timestamp);
>         }
>       m_txPackets.clear ();
>     }
> 
>   WifiPreamble preamble;
>   if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
>     {
>       preamble = WIFI_PREAMBLE_VHT;
>     }
>   else if (m_phy->GetGreenfield () && m_stationManager->GetGreenfieldSupported (m_currentHdr.GetAddr1 ()))
>     {
>       //In the future has to make sure that receiver has greenfield enabled
>       preamble = WIFI_PREAMBLE_HT_GF;
>     }
>   else if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
>     {
>       preamble = WIFI_PREAMBLE_HT_MF;
>     }
>   else if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
>     }
> 
2904c2276,2293
<   Time newDuration = GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>   Time newDuration = Seconds (0);
>   if (m_txParams.MustWaitBasicBlockAck ())
>     {
>       newDuration += GetSifs ();
>       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>       newDuration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, BASIC_BLOCK_ACK);
>     }
>   else if (m_txParams.MustWaitCompressedBlockAck ())
>     {
>       newDuration += GetSifs ();
>       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>       newDuration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>     }
>   else if (m_txParams.MustWaitAck ())
>     {
>       newDuration += GetSifs ();
>       newDuration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>     }
2907c2296,2298
<       if (m_stationManager->GetRifsPermitted ())
---
>       newDuration += GetSifs ();
>       newDuration += m_phy->CalculateTxDuration (m_txParams.GetNextPacketSize (), m_currentTxVector, preamble, m_phy->GetFrequency ());
>       if (m_txParams.MustWaitCompressedBlockAck ())
2909c2300,2302
<           newDuration += GetRifs ();
---
>           newDuration += GetSifs ();
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           newDuration += GetBlockAckDuration (m_currentHdr.GetAddr1 (), blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
2911c2304
<       else
---
>       else if (m_txParams.MustWaitAck ())
2913a2307
>           newDuration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
2915,2916d2308
<       newDuration += m_phy->CalculateTxDuration (m_txParams.GetNextPacketSize (), m_currentTxVector, m_phy->GetFrequency ());
<       newDuration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
2919c2311
<   Time txDuration = m_phy->CalculateTxDuration (m_currentPacket->GetSize (), m_currentTxVector, m_phy->GetFrequency ());
---
>   Time txDuration = m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr), m_currentTxVector, preamble, m_phy->GetFrequency ());
2924,2926c2316,2319
<   NS_ASSERT (duration.IsPositive ());
<   m_currentPacket->SetDuration (duration);
<   if (m_txParams.MustSendBlockAckRequest ())
---
>   NS_ASSERT (duration >= MicroSeconds (0));
>   m_currentHdr.SetDuration (duration);
> 
>   if (!m_ampdu)
2928,2931c2321,2323
<       Ptr<QosTxop> qosTxop = DynamicCast<QosTxop> (m_currentTxop);
<       NS_ASSERT (qosTxop != 0);
<       auto bar = qosTxop->PrepareBlockAckRequest (m_currentPacket->GetAddr1 (), *m_currentPacket->GetTids ().begin ());
<       qosTxop->ScheduleBar (bar);
---
>       m_currentPacket->AddHeader (m_currentHdr);
>       WifiMacTrailer fcs;
>       m_currentPacket->AddTrailer (fcs);
2933c2325,2327
<   ForwardDown (m_currentPacket, m_currentTxVector);
---
> 
>   ForwardDown (m_currentPacket, &m_currentHdr, m_currentTxVector, preamble);
>   m_currentPacket = 0;
2937c2331
< MacLow::WaitIfsAfterEndTxFragment (void)
---
> MacLow::WaitSifsAfterEndTxFragment (void)
2939,2940c2333
<   NS_LOG_FUNCTION (this);
<   m_currentTxop->StartNextFragment ();
---
>   m_listener->StartNextFragment ();
2944c2337
< MacLow::WaitIfsAfterEndTxPacket (void)
---
> MacLow::WaitSifsAfterEndTx (void)
2946,2947c2339
<   NS_LOG_FUNCTION (this);
<   m_currentTxop->StartNextPacket ();
---
>   m_listener->StartNext ();
2952a2345,2352
>   MacLowTransmissionListener *listener = m_listener;
>   m_listener = 0;
>   listener->EndTxNoAck ();
> }
> 
> void
> MacLow::FastAckFailedTimeout (void)
> {
2954,2979c2354,2357
<   if (m_currentTxop != 0)
<     {
<       if (m_currentPacket->GetHeader (0).IsBeacon () && m_stationManager->GetPcfSupported ())
<         {
<           m_cfpStart = Simulator::Now ();
<         }
<       if (!m_cfAckInfo.expectCfAck)
<         {
<           Ptr<Txop> txop = m_currentTxop;
<           txop->EndTxNoAck ();
<         }
<       if (!IsCfPeriod ())
<         {
<           m_currentTxop = 0;
<         }
<     }
<   else
<     {
<       if (m_currentPacket->IsShortSSW ())
<         m_transmissionShortSswCallback ();
<       else
<         m_transmissionCallback (m_currentPacket->GetHeader (0));
<     }
<   //// WIGIG ////
<   m_currentPacket = 0;
<   //// WIGIG ////
---
>   MacLowTransmissionListener *listener = m_listener;
>   m_listener = 0;
>   listener->MissedAck ();
>   NS_LOG_DEBUG ("fast Ack busy but missed");
2986,3004c2364,2378
<   if (!m_phy->IsStateTx () && !m_phy->IsStateSwitching ()) //// WIGIG //// (Modification)
<     {
<       // send an Ack, after SIFS, when you receive a packet
<       WifiTxVector ackTxVector = GetAckTxVector (source, dataTxMode);
<       WifiMacHeader ack;
<       ack.SetType (WIFI_MAC_CTL_ACK);
<       ack.SetDsNotFrom ();
<       ack.SetDsNotTo ();
<       ack.SetNoRetry ();
<       ack.SetNoMoreFragments ();
<       ack.SetAddr1 (source);
<       // 802.11-2012, Section 8.3.1.4:  Duration/ID is received duration value
<       // minus the time to transmit the Ack frame and its SIFS interval
<       duration -= GetAckDuration (ackTxVector);
<       duration -= GetSifs ();
<       NS_ASSERT_MSG (duration.IsPositive (), "Please provide test case to maintainers if this assert is hit.");
<       ack.SetDuration (duration);
< 
<       Ptr<Packet> packet = Create<Packet> ();
---
>   // send an ACK, after SIFS, when you receive a packet 
>   WifiTxVector ackTxVector = GetAckTxVector (source, dataTxMode);
>   WifiMacHeader ack;
>   ack.SetType (WIFI_MAC_CTL_ACK);
>   ack.SetDsNotFrom ();
>   ack.SetDsNotTo ();
>   ack.SetNoRetry ();
>   ack.SetNoMoreFragments ();
>   ack.SetAddr1 (source);
>   // 802.11-2012, Section 8.3.1.4:  Duration/ID is received duration value
>   // minus the time to transmit the ACK frame and its SIFS interval
>   duration -= GetAckDuration (ackTxVector);
>   duration -= GetSifs ();
>   NS_ASSERT_MSG (duration >= MicroSeconds (0), "Please provide test case to maintainers if this assert is hit.");
>   ack.SetDuration (duration);
3006,3008c2380,2383
<       SnrTag tag;
<       tag.Set (dataSnr);
<       packet->AddPacketTag (tag);
---
>   Ptr<Packet> packet = Create<Packet> ();
>   packet->AddHeader (ack);
>   WifiMacTrailer fcs;
>   packet->AddTrailer (fcs);
3010,3011c2385,2392
<       //Ack should always use non-HT PPDU (HT PPDU cases not supported yet)
<       ForwardDown (Create<const WifiPsdu> (packet, ack), ackTxVector);
---
>   SnrTag tag;
>   tag.Set (dataSnr);
>   packet->AddPacketTag (tag);
>   
>   WifiPreamble preamble;
>   if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
3015c2396
<       NS_LOG_DEBUG ("Skip ack after data");
---
>       preamble = WIFI_PREAMBLE_LONG;
3016a2398,2400
> 
>   //ACK should always use non-HT PPDU (HT PPDU cases not supported yet)
>   ForwardDown (packet, &ack, ackTxVector, preamble);
3020c2404
< MacLow::ReceiveMpdu (Ptr<WifiMacQueueItem> mpdu)
---
> MacLow::IsInWindow (uint16_t seq, uint16_t winstart, uint16_t winsize)
3022c2406,2407
<   const WifiMacHeader& hdr = mpdu->GetHeader ();
---
>   return ((seq - winstart + 4096) % 4096) < winsize;
> }
3024,3030c2409,2412
<   if (m_stationManager->GetHtSupported ()
<       || m_stationManager->GetVhtSupported ()
<       || m_stationManager->GetHeSupported ()
<       //// WIGIG ////
<       || m_stationManager->HasDmgSupported ()
<       || m_stationManager->HasEdmgSupported ())
<       //// WIGIG ////
---
> bool
> MacLow::ReceiveMpdu (Ptr<Packet> packet, WifiMacHeader hdr)
> {
>   if (m_stationManager->HasHtSupported () || m_stationManager->HasVhtSupported ())
3042c2424
<           //Implement HT immediate BlockAck support for HT Delayed BlockAck is not added yet
---
>           //Implement HT immediate Block Ack support for HT Delayed Block Ack is not added yet
3045c2427
<               StoreMpduIfNeeded (mpdu);
---
>               StoreMpduIfNeeded (packet, hdr);
3049,3053c2431,2439
<                   NS_ASSERT (delta > 0);
<                   uint16_t bufferSize = (*it).second.first.GetBufferSize ();
<                   uint16_t startingSeq = (seqNumber - bufferSize + 1 + 4096) % 4096;
<                   (*it).second.first.SetStartingSequence (startingSeq);
<                   RxCompleteBufferedPacketsWithSmallerSequence ((*it).second.first.GetStartingSequenceControl (), originator, tid);
---
>                   if (delta > 1)
>                     {
>                       (*it).second.first.SetWinEnd (seqNumber);
>                       int16_t winEnd = (*it).second.first.GetWinEnd ();
>                       int16_t bufferSize = (*it).second.first.GetBufferSize ();
>                       uint16_t sum = ((uint16_t)(std::abs (winEnd - bufferSize + 1))) % 4096;
>                       (*it).second.first.SetStartingSequence (sum);
>                       RxCompleteBufferedPacketsWithSmallerSequence ((*it).second.first.GetStartingSequenceControl (), originator, tid);
>                     }
3055a2442
>               (*it).second.first.SetWinEnd (((*it).second.first.GetStartingSequence () + (*it).second.first.GetBufferSize () - 1) % 4096);
3061c2448,2451
<   return StoreMpduIfNeeded (mpdu);
---
>   else
>     {
>       return StoreMpduIfNeeded (packet, hdr);
>     }
3065c2455
< MacLow::StoreMpduIfNeeded (Ptr<WifiMacQueueItem> mpdu)
---
> MacLow::StoreMpduIfNeeded (Ptr<Packet> packet, WifiMacHeader hdr)
3067,3068d2456
<   const WifiMacHeader& hdr = mpdu->GetHeader ();
< 
3071a2460,2463
>       WifiMacTrailer fcs;
>       packet->RemoveTrailer (fcs);
>       BufferedPacket bufferedPacket (packet, hdr);
> 
3073c2465
<       uint32_t mappedSeqControl = QosUtilsMapSeqControlToUniqueInteger (hdr.GetSequenceControl (), endSequence);
---
>       uint16_t mappedSeqControl = QosUtilsMapSeqControlToUniqueInteger (hdr.GetSequenceControl (), endSequence);
3077c2469
<            && QosUtilsMapSeqControlToUniqueInteger ((*i)->GetHeader ().GetSequenceControl (), endSequence) < mappedSeqControl; i++)
---
>            && QosUtilsMapSeqControlToUniqueInteger ((*i).second.GetSequenceControl (), endSequence) < mappedSeqControl; i++)
3080c2472
<       (*it).second.second.insert (i, mpdu);
---
>       (*it).second.second.insert (i, bufferedPacket);
3095d2486
<   NS_LOG_FUNCTION (this);
3111c2502
<   std::list<Ptr<WifiMacQueueItem>> buffer (0);
---
>   std::list<BufferedPacket> buffer (0);
3128,3129c2519,2521
<                                                                 &QosTxop::SendDelbaFrame,
<                                                                 m_edca[ac], originator, tid, false);
---
>                                                                 &MacLowAggregationCapableTransmissionListener::BlockAckInactivityTimeout,
>                                                                 m_edcaListeners[ac],
>                                                                 originator, tid);
3136d2527
<   NS_LOG_FUNCTION (this);
3142a2534
> 
3156c2548
<       uint32_t mappedStart = QosUtilsMapSeqControlToUniqueInteger (seq, endSequence);
---
>       uint16_t mappedStart = QosUtilsMapSeqControlToUniqueInteger (seq, endSequence);
3161c2553
<           guard = (*(*it).second.second.begin ())->GetHeader ().GetSequenceControl ();
---
>           guard = (*it).second.second.begin ()->second.GetSequenceControl ();
3165c2557
<            && QosUtilsMapSeqControlToUniqueInteger ((*i)->GetHeader ().GetSequenceControl (), endSequence) < mappedStart; )
---
>            && QosUtilsMapSeqControlToUniqueInteger ((*i).second.GetSequenceControl (), endSequence) < mappedStart; )
3167c2559
<           if (guard == (*i)->GetHeader ().GetSequenceControl ())
---
>           if (guard == (*i).second.GetSequenceControl ())
3169c2561
<               if (!(*i)->GetHeader ().IsMoreFragments ())
---
>               if (!(*i).second.IsMoreFragments ())
3173c2565
<                       m_rxCallback (*last);
---
>                       m_rxCallback ((*last).first, &(*last).second);
3176c2568
<                   m_rxCallback (*last);
---
>                   m_rxCallback ((*last).first, &(*last).second);
3179c2571
<                   while (i != (*it).second.second.end () && guard == (*i)->GetHeader ().GetSequenceControl ())
---
>                   while (i != (*it).second.second.end () && guard == (*i).second.GetSequenceControl ())
3185c2577
<                       guard = (*i)->GetHeader ().GetSequenceControl ();
---
>                       guard = (*i).second.GetSequenceControl ();
3197c2589
<               while (i != (*it).second.second.end () && guard == (*i)->GetHeader ().GetSequenceControl ())
---
>               while (i != (*it).second.second.end () && guard == (*i).second.GetSequenceControl ())
3203c2595
<                   guard = (*i)->GetHeader ().GetSequenceControl ();
---
>                   guard = (*i).second.GetSequenceControl ();
3221c2613
<       for (; i != (*it).second.second.end () && guard == (*i)->GetHeader ().GetSequenceControl (); i++)
---
>       for (; i != (*it).second.second.end () && guard == (*i).second.GetSequenceControl (); i++)
3223c2615
<           if (!(*i)->GetHeader ().IsMoreFragments ())
---
>           if (!(*i).second.IsMoreFragments ())
3227c2619
<                   m_rxCallback (*lastComplete);
---
>                   m_rxCallback ((*lastComplete).first, &(*lastComplete).second);
3230c2622
<               m_rxCallback (*lastComplete);
---
>               m_rxCallback ((*lastComplete).first, &(*lastComplete).second);
3233c2625
<           guard = (*i)->GetHeader ().IsMoreFragments () ? (guard + 1) : ((guard + 16) & 0xfff0);
---
>           guard = (*i).second.IsMoreFragments () ? (guard + 1) : ((guard + 16) & 0xfff0);
3241d2632
< 
3246d2636
<   NS_LOG_FUNCTION (this);
3260a2651,2652
>   m_currentPacket = packet;
>   m_currentHdr = hdr;
3265c2657,2668
<       duration -= GetBlockAckDuration (blockAckReqTxVector, blockAck->GetType ());
---
>       if (blockAck->IsBasic ())
>         {
>           duration -= GetBlockAckDuration (originator, blockAckReqTxVector, BASIC_BLOCK_ACK);
>         }
>       else if (blockAck->IsCompressed ())
>         {
>           duration -= GetBlockAckDuration (originator, blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>         }
>       else if (blockAck->IsMultiTid ())
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
3280c2683
<   NS_ASSERT (duration.IsPositive ());
---
>   NS_ASSERT (duration >= NanoSeconds (0));
3282c2685
<   //here should be present a control about immediate or delayed BlockAck
---
>   //here should be present a control about immediate or delayed block ack
3283a2687,2702
>   packet->AddHeader (hdr);
>   WifiMacTrailer fcs;
>   packet->AddTrailer (fcs);
>   WifiPreamble preamble;
>   if (blockAckReqTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
>     {
>       preamble = WIFI_PREAMBLE_HT_MF;
>     }
>   else if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
>     }
3287c2706,2707
<   ForwardDown (Create<const WifiPsdu> (packet, hdr), blockAckReqTxVector);
---
>   ForwardDown (packet, &hdr, blockAckReqTxVector, preamble);
>   m_currentPacket = 0;
3293,3326c2713,2718
<   NS_LOG_FUNCTION (this);
<   if (!m_phy->IsStateTx () && !m_phy->IsStateSwitching ()) //// WIGIG //// (Modification)
<     {
<       NS_LOG_FUNCTION (this << +tid << originator << duration.As (Time::S) << blockAckReqTxVector << rxSnr);
<       CtrlBAckResponseHeader blockAck;
<       uint16_t seqNumber = 0;
<       BlockAckCachesI i = m_bAckCaches.find (std::make_pair (originator, tid));
<       NS_ASSERT (i != m_bAckCaches.end ());
<       seqNumber = (*i).second.GetWinStart ();
< 
<       bool immediate = true;
<       AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
<       blockAck.SetStartingSequence (seqNumber);
<       blockAck.SetTidInfo (tid);
<       immediate = (*it).second.first.IsImmediateBlockAck ();
<       //// WIGIG ////
<       if (m_stationManager->HasEdmgSupported ())
<         {
<           blockAck.SetType (BlockAckType::EDMG_COMPRESSED_BLOCK_ACK);
<         }
<       else
<       //// WIGIG ////
<         {
<           if ((*it).second.first.GetBufferSize () > 64)
<             {
<               blockAck.SetType (EXTENDED_COMPRESSED_BLOCK_ACK);
<             }
<           else
<             {
<               blockAck.SetType (COMPRESSED_BLOCK_ACK);
<             }
<         }
<       NS_LOG_DEBUG ("Got Implicit block Ack Req with seq " << seqNumber);
<       (*i).second.FillBlockAckBitmap (&blockAck);
---
>   NS_LOG_FUNCTION (this << (uint16_t) tid << originator << duration.As (Time::S) << blockAckReqTxVector << rxSnr);
>   CtrlBAckResponseHeader blockAck;
>   uint16_t seqNumber = 0;
>   BlockAckCachesI i = m_bAckCaches.find (std::make_pair (originator, tid));
>   NS_ASSERT (i != m_bAckCaches.end ());
>   seqNumber = (*i).second.GetWinStart ();
3328c2720,2727
<       WifiTxVector blockAckTxVector = GetBlockAckTxVector (originator, blockAckReqTxVector.GetMode ());
---
>   bool immediate = true;
>   AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
>   blockAck.SetStartingSequence (seqNumber);
>   blockAck.SetTidInfo (tid);
>   immediate = (*it).second.first.IsImmediateBlockAck ();
>   blockAck.SetType (COMPRESSED_BLOCK_ACK);
>   NS_LOG_DEBUG ("Got Implicit block Ack Req with seq " << seqNumber);
>   (*i).second.FillBlockAckBitmap (&blockAck);
3330,3335c2729
<       SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckTxVector.GetMode (), rxSnr);
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Skip block ack response!");
<     }
---
>   SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxVector.GetMode (), rxSnr);
3343c2737,2740
<   if (!m_phy->IsStateTx () && !m_phy->IsStateSwitching ()) //// WIGIG //// (Modification)
---
>   CtrlBAckResponseHeader blockAck;
>   uint8_t tid = 0;
>   bool immediate = false;
>   if (!reqHdr.IsMultiTid ())
3345,3348c2742,2744
<       CtrlBAckResponseHeader blockAck;
<       uint8_t tid = 0;
<       bool immediate = false;
<       if (!reqHdr.IsMultiTid ())
---
>       tid = reqHdr.GetTidInfo ();
>       AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
>       if (it != m_bAckAgreements.end ())
3350,3352c2746,2749
<           tid = reqHdr.GetTidInfo ();
<           AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
<           if (it != m_bAckAgreements.end ())
---
>           blockAck.SetStartingSequence (reqHdr.GetStartingSequence ());
>           blockAck.SetTidInfo (tid);
>           immediate = (*it).second.first.IsImmediateBlockAck ();
>           if (reqHdr.IsBasic ())
3354,3363c2751,2772
<               blockAck.SetStartingSequence (reqHdr.GetStartingSequence ());
<               blockAck.SetTidInfo (tid);
<               immediate = (*it).second.first.IsImmediateBlockAck ();
<               //// WIGIG ////
<               if (m_stationManager->HasEdmgSupported ())
<                 {
<                   blockAck.SetType (EDMG_COMPRESSED_BLOCK_ACK);
<                 }
<               else
<               //// WIGIG ////
---
>               blockAck.SetType (BASIC_BLOCK_ACK);
>             }
>           else if (reqHdr.IsCompressed ())
>             {
>               blockAck.SetType (COMPRESSED_BLOCK_ACK);
>             }
>           BlockAckCachesI i = m_bAckCaches.find (std::make_pair (originator, tid));
>           NS_ASSERT (i != m_bAckCaches.end ());
>           (*i).second.FillBlockAckBitmap (&blockAck);
>           NS_LOG_DEBUG ("Got block Ack Req with seq " << reqHdr.GetStartingSequence ());
> 
>           if (!m_stationManager->HasHtSupported () && !m_stationManager->HasVhtSupported ())
>             {
>               /* All packets with smaller sequence than starting sequence control must be passed up to Wifimac
>                * See 9.10.3 in IEEE 802.11e standard.
>                */
>               RxCompleteBufferedPacketsWithSmallerSequence (reqHdr.GetStartingSequenceControl (), originator, tid);
>               RxCompleteBufferedPacketsUntilFirstLost (originator, tid);
>             }
>           else
>             {
>               if (!QosUtilsIsOldPacket ((*it).second.first.GetStartingSequence (), reqHdr.GetStartingSequence ()))
3365,3393c2774,2775
<                   if (reqHdr.IsBasic ())
<                     {
<                       blockAck.SetType (BASIC_BLOCK_ACK);
<                     }
<                   else if (reqHdr.IsCompressed ())
<                     {
<                       blockAck.SetType (COMPRESSED_BLOCK_ACK);
<                     }
<                   else if (reqHdr.IsExtendedCompressed ())
<                     {
<                       blockAck.SetType (EXTENDED_COMPRESSED_BLOCK_ACK);
<                     }
<                 }
<               BlockAckCachesI i = m_bAckCaches.find (std::make_pair (originator, tid));
<               NS_ASSERT (i != m_bAckCaches.end ());
<               (*i).second.FillBlockAckBitmap (&blockAck);
<               NS_LOG_DEBUG ("Got block Ack Req with seq " << reqHdr.GetStartingSequence ());
< 
<               if (!m_stationManager->GetHtSupported ()
<                   && !m_stationManager->GetVhtSupported ()
<                   && !m_stationManager->GetHeSupported ()
<                   //// WIGIG ////
<                   && !m_stationManager->HasDmgSupported ()
<                   && !m_stationManager->HasEdmgSupported ())
<                 //// WIGIG ////
<                 {
<                   /* All packets with smaller sequence than starting sequence control must be passed up to WifiMac
<                            * See 9.10.3 in IEEE 802.11e standard.
<                            */
---
>                   (*it).second.first.SetStartingSequence (reqHdr.GetStartingSequence ());
>                   (*it).second.first.SetWinEnd (((*it).second.first.GetStartingSequence () + (*it).second.first.GetBufferSize () - 1) % 4096);
3395a2778
>                   (*it).second.first.SetWinEnd (((*it).second.first.GetStartingSequence () + (*it).second.first.GetBufferSize () - 1) % 4096);
3397,3409d2779
<               else
<                 {
<                   if (!QosUtilsIsOldPacket ((*it).second.first.GetStartingSequence (), reqHdr.GetStartingSequence ()))
<                     {
<                       (*it).second.first.SetStartingSequence (reqHdr.GetStartingSequence ());
<                       RxCompleteBufferedPacketsWithSmallerSequence (reqHdr.GetStartingSequenceControl (), originator, tid);
<                       RxCompleteBufferedPacketsUntilFirstLost (originator, tid);
<                     }
<                 }
<             }
<           else
<             {
<               NS_LOG_DEBUG ("there's not a valid block ack agreement with " << originator);
3414c2784
<           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
---
>           NS_LOG_DEBUG ("there's not a valid block ack agreement with " << originator);
3416d2785
<       SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxMode, rxSnr);
3420c2789
<       NS_LOG_DEBUG ("Skip block ack response!");
---
>       NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
3421a2791,2792
> 
>   SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxMode, rxSnr);
3434,3436c2805,2808
<                                                          &QosTxop::SendDelbaFrame,
<                                                          m_edca[ac], agreement.GetPeer (),
<                                                          agreement.GetTid (), false);
---
>                                                          &MacLowAggregationCapableTransmissionListener::BlockAckInactivityTimeout,
>                                                          m_edcaListeners[ac],
>                                                          agreement.GetPeer (),
>                                                          agreement.GetTid ());
3441c2813
< MacLow::RegisterEdcaForAc (AcIndex ac, Ptr<QosTxop> edca)
---
> MacLow::RegisterBlockAckListenerForAc (enum AcIndex ac, MacLowAggregationCapableTransmissionListener *listener)
3443c2815
<   m_edca.insert (std::make_pair (ac, edca));
---
>   m_edcaListeners.insert (std::make_pair (ac, listener));
3447c2819
< MacLow::DeaggregateAmpduAndReceive (Ptr<WifiPsdu> psdu, double rxSnr, WifiTxVector txVector, std::vector<bool> statusPerMpdu)
---
> MacLow::DeaggregateAmpduAndReceive (Ptr<Packet> aggregatedPacket, double rxSnr, WifiTxVector txVector, WifiPreamble preamble)
3449a2822
>   AmpduTag ampdu;
3451,3452c2824,2825
<   bool ampduSubframe = false; //flag indicating the packet belongs to an A-MPDU and is not a VHT/HE single MPDU
<   if (txVector.IsAggregation ())
---
>   bool ampduSubframe = false; //flag indicating the packet belongs to an A-MPDU and is not a VHT single MPDU
>   if (aggregatedPacket->RemovePacketTag (ampdu))
3454,3455d2826
<       NS_ASSERT (psdu->IsAggregate ());
< 
3457,3477c2828,2829
<       auto n = psdu->begin ();
<       auto status = statusPerMpdu.begin ();
<       NS_ABORT_MSG_IF (psdu->GetNMpdus () != statusPerMpdu.size (), "Should have one receive status per MPDU");
< 
<       WifiMacHeader firsthdr = (*n)->GetHeader ();
< 
<       //// WIGIG ////
<       /* No need to continue processing the received A-MPDU, if we are performing SLS. */
<       if (m_servingSLS)
<         {
<           NS_LOG_DEBUG ("Perfomring SLS BFT, so ignoe the received A-MPDU from " << firsthdr.GetAddr2 () <<
<                         " with sequence=" << firsthdr.GetSequenceNumber ());
<           return;
<         }
<       if (m_servingMimoBFT)
<         {
<           NS_LOG_DEBUG ("Perfomring MIMO BFT, so ignoe the received A-MPDU from " << firsthdr.GetAddr2 () <<
<                         " with sequence=" << firsthdr.GetSequenceNumber ());
<           return;
<         }
<       //// WIGIG ////
---
>       MpduAggregator::DeaggregatedMpdus packets = MpduAggregator::Deaggregate (aggregatedPacket);
>       MpduAggregator::DeaggregatedMpdusCI n = packets.begin ();
3478a2831,2832
>       WifiMacHeader firsthdr;
>       (*n).first->PeekHeader (firsthdr);
3480c2834
<       NotifyNav ((*n)->GetPacket (), firsthdr);
---
>       NotifyNav ((*n).first, firsthdr, preamble);
3484,3485c2838,2870
<           //Iterate over all MPDUs and notify reception only if status OK
<           for (; n != psdu->end (); ++n, ++status)
---
>           bool vhtSingleMpdu = (*n).second.GetEof ();
>           if (vhtSingleMpdu)
>             {
>               //If the MPDU is sent as a VHT single MPDU (EOF=1 in A-MPDU subframe header), then the responder sends an ACK.
>               NS_LOG_DEBUG ("Receive VHT single MPDU");
>               ampduSubframe = false;
>             }
>           else if (preamble != WIFI_PREAMBLE_NONE || !m_sendAckEvent.IsRunning ())
>             {
>               m_sendAckEvent = Simulator::Schedule (ampdu.GetRemainingAmpduDuration () + GetSifs (),
>                                                     &MacLow::SendBlockAckAfterAmpdu, this,
>                                                     firsthdr.GetQosTid (),
>                                                     firsthdr.GetAddr2 (),
>                                                     firsthdr.GetDuration (),
>                                                     txVector,
>                                                     rxSnr);
>             }
> 
>           if (firsthdr.IsAck () || firsthdr.IsBlockAck () || firsthdr.IsBlockAckReq ())
>             {
>               ReceiveOk ((*n).first, rxSnr, txVector, preamble, ampduSubframe);
>             }
>           else if (firsthdr.IsData () || firsthdr.IsQosData ())
>             {
>               NS_LOG_DEBUG ("Deaggregate packet from " << firsthdr.GetAddr2 () << " with sequence=" << firsthdr.GetSequenceNumber ());
>               ReceiveOk ((*n).first, rxSnr, txVector, preamble, ampduSubframe);
>               if (firsthdr.IsQosAck ())
>                 {
>                   NS_LOG_DEBUG ("Normal Ack");
>                   normalAck = true;
>                 }
>             }
>           else
3487,3489c2872,2877
<               firsthdr = (*n)->GetHeader ();
<               NS_ABORT_MSG_IF (firsthdr.GetAddr1 () != m_self, "All MPDUs of A-MPDU should have the same destination address");
<               if (*status) //PER and thus CRC check succeeded
---
>               NS_FATAL_ERROR ("Received A-MPDU with invalid first MPDU type");
>             }
> 
>           if (ampdu.GetRemainingNbOfMpdus () == 0 && !vhtSingleMpdu)
>             {
>               if (normalAck)
3491c2879,2880
<                   if (psdu->IsSingle ())
---
>                   //send block Ack
>                   if (firsthdr.IsBlockAckReq ())
3493,3495c2882
<                       //If the MPDU is sent as a VHT/HE single MPDU (EOF=1 in A-MPDU subframe header), then the responder sends an Ack.
<                       NS_LOG_DEBUG ("Receive S-MPDU");
<                       ampduSubframe = false;
---
>                       NS_FATAL_ERROR ("Sending a BlockAckReq with QosPolicy equal to Normal Ack");
3497c2884,3013
<                   else if (!m_sendAckEvent.IsRunning () && firsthdr.IsQosAck ()) // Implicit BAR Ack Policy
---
>                   uint8_t tid = firsthdr.GetQosTid ();
>                   AgreementsI it = m_bAckAgreements.find (std::make_pair (firsthdr.GetAddr2 (), tid));
>                   if (it != m_bAckAgreements.end ())
>                     {
>                       /* See section 11.5.3 in IEEE 802.11 for mean of this timer */
>                       ResetBlockAckInactivityTimerIfNeeded (it->second.first);
>                       NS_LOG_DEBUG ("rx A-MPDU/sendImmediateBlockAck from=" << firsthdr.GetAddr2 ());
>                       NS_ASSERT (m_sendAckEvent.IsRunning ());
>                     }
>                   else
>                     {
>                       NS_LOG_DEBUG ("There's not a valid agreement for this block ack request.");
>                     }
>                 }
>             }
>         }
>     }
>   else
>     {
>       ReceiveOk (aggregatedPacket, rxSnr, txVector, preamble, ampduSubframe);
>     }
> }
> 
> bool
> MacLow::StopMpduAggregation (Ptr<const Packet> peekedPacket, WifiMacHeader peekedHdr, Ptr<Packet> aggregatedPacket, uint16_t size) const
> {
>   if (peekedPacket == 0)
>     {
>       NS_LOG_DEBUG ("no more packets in queue");
>       return true;
>     }
> 
>   WifiPreamble preamble;
>   Time aPPDUMaxTime = MilliSeconds (10);
> 
>   uint8_t tid = GetTid (peekedPacket, peekedHdr);
>   AcIndex ac = QosUtilsMapTidToAc (tid);
>   std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
> 
>   if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
>     {
>       preamble = WIFI_PREAMBLE_VHT;
>       aPPDUMaxTime = MicroSeconds (5484);
>     }
>   else if (m_phy->GetGreenfield () && m_stationManager->GetGreenfieldSupported (m_currentHdr.GetAddr1 ()))
>     {
>       preamble = WIFI_PREAMBLE_HT_GF;
>     }
>   else if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT)
>     {
>       preamble = WIFI_PREAMBLE_HT_MF;
>     }
>   else if (m_stationManager->GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
>     }
> 
>   //A STA shall not transmit a PPDU that has a duration that is greater than aPPDUMaxTime
>   if (m_phy->CalculateTxDuration (aggregatedPacket->GetSize () + peekedPacket->GetSize () + peekedHdr.GetSize () + WIFI_MAC_FCS_LENGTH, m_currentTxVector, preamble, m_phy->GetFrequency ()) > aPPDUMaxTime)
>     {
>       NS_LOG_DEBUG ("no more packets can be aggregated to satisfy PPDU <= aPPDUMaxTime");
>       return true;
>     }
> 
>   if (!listenerIt->second->GetMpduAggregator ()->CanBeAggregated (peekedPacket->GetSize () + peekedHdr.GetSize () + WIFI_MAC_FCS_LENGTH, aggregatedPacket, size))
>     {
>       NS_LOG_DEBUG ("no more packets can be aggregated because the maximum A-MPDU size has been reached");
>       return true;
>     }
> 
>   return false;
> }
> 
> Ptr<Packet>
> MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
> {
>   NS_ASSERT (m_aggregateQueue->GetSize () == 0);
>   bool isAmpdu = false;
>   Ptr<Packet> newPacket, tempPacket;
>   WifiMacHeader peekedHdr;
>   newPacket = packet->Copy ();
>   Ptr<Packet> currentAggregatedPacket;
>   CtrlBAckRequestHeader blockAckReq;
>   
>   if (hdr.IsBlockAckReq ())
>     {
>       //Workaround to avoid BlockAckReq to be part of an A-MPDU. The standard says that
>       //BlockAckReq is not present in A-MPDU if any QoS data frames for that TID are present.
>       //Since an A-MPDU in non-PSMP frame exchanges aggregates MPDUs from one TID, this means
>       //we should stop aggregation here for single-TID A-MPDUs. Once PSMP and multi-TID A-MPDUs
>       //are supported, the condition of entering here should be changed.
>       return newPacket;
>     }
>   
>   //missing hdr.IsAck() since we have no means of knowing the Tid of the Ack yet
>   if (hdr.IsQosData () || hdr.IsBlockAck ()|| hdr.IsBlockAckReq ())
>     {
>       Time tstamp;
>       uint8_t tid = GetTid (packet, hdr);
>       Ptr<WifiMacQueue> queue;
>       AcIndex ac = QosUtilsMapTidToAc (tid);
>       //since a blockack agreement always preceeds mpdu aggregation there should always exist blockAck listener
>       std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
>       NS_ASSERT (listenerIt != m_edcaListeners.end ());
>       queue = listenerIt->second->GetQueue ();
> 
>       if (!hdr.GetAddr1 ().IsBroadcast () && listenerIt->second->GetMpduAggregator () != 0)
>         {
>           //Have to make sure that their exist a block Ack agreement before sending an AMPDU (BlockAck Manager)
>           if (listenerIt->second->GetBlockAckAgreementExists (hdr.GetAddr1 (), tid))
>             {
>               /* here is performed mpdu aggregation */
>               /* MSDU aggregation happened in edca if the user asked for it so m_currentPacket may contains a normal packet or a A-MSDU*/
>               currentAggregatedPacket = Create<Packet> ();
>               peekedHdr = hdr;
>               uint16_t startingSequenceNumber = 0;
>               uint16_t currentSequenceNumber = 0;
>               uint8_t qosPolicy = 0;
>               uint16_t blockAckSize = 0;
>               bool aggregated = false;
>               int i = 0;
>               Ptr<Packet> aggPacket = newPacket->Copy ();
> 
>               if (!hdr.IsBlockAckReq ())
>                 {
>                   if (!hdr.IsBlockAck ())
3499,3504c3015,3016
<                       m_sendAckEvent = Simulator::Schedule (GetSifs (),
<                                                             &MacLow::SendBlockAckAfterAmpdu, this,
<                                                             firsthdr.GetQosTid (),
<                                                             firsthdr.GetAddr2 (),
<                                                             firsthdr.GetDuration (),
<                                                             txVector, rxSnr);
---
>                       startingSequenceNumber = peekedHdr.GetSequenceNumber ();
>                       peekedHdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
3505a3018,3023
>                   currentSequenceNumber = peekedHdr.GetSequenceNumber ();
>                   newPacket->AddHeader (peekedHdr);
>                   WifiMacTrailer fcs;
>                   newPacket->AddTrailer (fcs);
> 
>                   aggregated = listenerIt->second->GetMpduAggregator ()->Aggregate (newPacket, currentAggregatedPacket);
3507c3025
<                   if (firsthdr.IsAck () || firsthdr.IsBlockAck () || firsthdr.IsBlockAckReq ())
---
>                   if (aggregated)
3509c3027,3030
<                       ReceiveOk ((*n), rxSnr, txVector, ampduSubframe);
---
>                       NS_LOG_DEBUG ("Adding packet with Sequence number " << peekedHdr.GetSequenceNumber () << " to A-MPDU, packet size = " << newPacket->GetSize () << ", A-MPDU size = " << currentAggregatedPacket->GetSize ());
>                       i++;
>                       m_sentMpdus++;
>                       m_aggregateQueue->Enqueue (aggPacket, peekedHdr);
3511c3032,3053
<                   else if (firsthdr.IsData () || firsthdr.IsQosData ())
---
>                 }
>               else if (hdr.IsBlockAckReq ())
>                 {
>                   blockAckSize = packet->GetSize () + hdr.GetSize () + WIFI_MAC_FCS_LENGTH;
>                   qosPolicy = 3; //if the last subrame is block ack req then set ack policy of all frames to blockack
>                   packet->PeekHeader (blockAckReq);
>                   startingSequenceNumber = blockAckReq.GetStartingSequence ();
>                 }
>               /// \todo We should also handle Ack and BlockAck
>               aggregated = false;
>               bool retry = false;
>               //looks for other packets to the same destination with the same Tid need to extend that to include MSDUs
>               Ptr<const Packet> peekedPacket = listenerIt->second->PeekNextPacketInBaQueue (peekedHdr, peekedHdr.GetAddr1 (), tid, &tstamp);
>               if (peekedPacket == 0)
>                 {
>                   peekedPacket = queue->PeekByTidAndAddress (&peekedHdr, tid,
>                                                              WifiMacHeader::ADDR1,
>                                                              hdr.GetAddr1 (), &tstamp);
>                   currentSequenceNumber = listenerIt->second->PeekNextSequenceNumberfor (&peekedHdr);
> 
>                   /* here is performed MSDU aggregation (two-level aggregation) */
>                   if (peekedPacket != 0 && listenerIt->second->GetMsduAggregator () != 0)
3513,3515c3055,3056
<                       NS_LOG_DEBUG ("Deaggregate packet from " << firsthdr.GetAddr2 () << " with sequence=" << firsthdr.GetSequenceNumber ());
<                       ReceiveOk ((*n), rxSnr, txVector, ampduSubframe);
<                       if (firsthdr.IsQosAck ())
---
>                       tempPacket = PerformMsduAggregation (peekedPacket, &peekedHdr, &tstamp, currentAggregatedPacket, blockAckSize);
>                       if (tempPacket != 0)  //MSDU aggregation
3517,3518c3058
<                           NS_LOG_DEBUG ("Normal Ack");
<                           normalAck = true;
---
>                           peekedPacket = tempPacket->Copy ();
3520a3061,3082
>                 }
>               else
>                 {
>                   retry = true;
>                   currentSequenceNumber = peekedHdr.GetSequenceNumber ();
>                 }
> 
>               while (IsInWindow (currentSequenceNumber, startingSequenceNumber, 64) && !StopMpduAggregation (peekedPacket, peekedHdr, currentAggregatedPacket, blockAckSize))
>                 {
>                   //for now always send AMPDU with normal ACK
>                   if (retry == false)
>                     {
>                       currentSequenceNumber = listenerIt->second->GetNextSequenceNumberfor (&peekedHdr);
>                       peekedHdr.SetSequenceNumber (currentSequenceNumber);
>                       peekedHdr.SetFragmentNumber (0);
>                       peekedHdr.SetNoMoreFragments ();
>                       peekedHdr.SetNoRetry ();
>                     }
>                   if (qosPolicy == 0)
>                     {
>                       peekedHdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
>                     }
3523c3085
<                       NS_FATAL_ERROR ("Received A-MPDU with invalid first MPDU type");
---
>                       peekedHdr.SetQosAckPolicy (WifiMacHeader::BLOCK_ACK);
3526c3088,3095
<                   if (!psdu->IsSingle ())
---
>                   newPacket = peekedPacket->Copy ();
>                   Ptr<Packet> aggPacket = newPacket->Copy ();
> 
>                   newPacket->AddHeader (peekedHdr);
>                   WifiMacTrailer fcs;
>                   newPacket->AddTrailer (fcs);
>                   aggregated = listenerIt->second->GetMpduAggregator ()->Aggregate (newPacket, currentAggregatedPacket);
>                   if (aggregated)
3528c3097,3098
<                       if (normalAck)
---
>                       m_aggregateQueue->Enqueue (aggPacket, peekedHdr);
>                       if (i == 1 && hdr.IsQosData ())
3530,3531c3100
<                           //send BlockAck
<                           if (firsthdr.IsBlockAckReq ())
---
>                           if (!m_txParams.MustSendRts ())
3533c3102
<                               NS_FATAL_ERROR ("Sending a BlockAckReq with QosPolicy equal to Normal Ack");
---
>                               listenerIt->second->CompleteMpduTx (packet, hdr, tstamp);
3535,3537c3104
<                           uint8_t tid = firsthdr.GetQosTid ();
<                           AgreementsI it = m_bAckAgreements.find (std::make_pair (firsthdr.GetAddr2 (), tid));
<                           if (it != m_bAckAgreements.end ())
---
>                           else
3539,3542c3106
<                               /* See section 11.5.3 in IEEE 802.11 for the definition of this timer */
<                               ResetBlockAckInactivityTimerIfNeeded (it->second.first);
<                               NS_LOG_DEBUG ("rx A-MPDU/sendImmediateBlockAck from=" << firsthdr.GetAddr2 ());
<                               NS_ASSERT (m_sendAckEvent.IsRunning ());
---
>                               InsertInTxQueue (packet, hdr, tstamp);
3544c3108,3173
<                           else
---
>                         }
>                       NS_LOG_DEBUG ("Adding packet with Sequence number " << peekedHdr.GetSequenceNumber () << " to A-MPDU, packet size = " << newPacket->GetSize () << ", A-MPDU size = " << currentAggregatedPacket->GetSize ());
>                       i++;
>                       isAmpdu = true;
>                       m_sentMpdus++;
>                       if (!m_txParams.MustSendRts ())
>                         {
>                           listenerIt->second->CompleteMpduTx (peekedPacket, peekedHdr, tstamp);
>                         }
>                       else
>                         {
>                           InsertInTxQueue (peekedPacket, peekedHdr, tstamp);
>                         }
>                       if (retry)
>                         {
>                           listenerIt->second->RemoveFromBaQueue (tid, hdr.GetAddr1 (), peekedHdr.GetSequenceNumber ());
>                         }
>                       else
>                         {
>                           queue->Remove (peekedPacket);
>                         }
>                       newPacket = 0;
>                     }
>                   else
>                     {
>                       break;
>                     }
>                   if (retry == true)
>                     {
>                       peekedPacket = listenerIt->second->PeekNextPacketInBaQueue (peekedHdr, hdr.GetAddr1 (), tid, &tstamp);
>                       if (peekedPacket == 0)
>                         {
>                           //I reached the first packet that I added to this A-MPDU
>                           retry = false;
>                           peekedPacket = queue->PeekByTidAndAddress (&peekedHdr, tid,
>                                                                      WifiMacHeader::ADDR1, hdr.GetAddr1 (), &tstamp);
>                           if (peekedPacket != 0)
>                             {
>                               //find what will the sequence number be so that we don't send more than 64 packets apart
>                               currentSequenceNumber = listenerIt->second->PeekNextSequenceNumberfor (&peekedHdr);
> 
>                               if (listenerIt->second->GetMsduAggregator () != 0)
>                                 {
>                                   tempPacket = PerformMsduAggregation (peekedPacket, &peekedHdr, &tstamp, currentAggregatedPacket, blockAckSize);
>                                   if (tempPacket != 0) //MSDU aggregation
>                                     {
>                                       peekedPacket = tempPacket->Copy ();
>                                     }
>                                 }
>                             }
>                         }
>                       else
>                         {
>                           currentSequenceNumber = peekedHdr.GetSequenceNumber ();
>                         }
>                     }
>                   else
>                     {
>                       peekedPacket = queue->PeekByTidAndAddress (&peekedHdr, tid,
>                                                                  WifiMacHeader::ADDR1, hdr.GetAddr1 (), &tstamp);
>                       if (peekedPacket != 0)
>                         {
>                           //find what will the sequence number be so that we don't send more than 64 packets apart
>                           currentSequenceNumber = listenerIt->second->PeekNextSequenceNumberfor (&peekedHdr);
> 
>                           if (listenerIt->second->GetMsduAggregator () != 0 && IsInWindow (currentSequenceNumber, startingSequenceNumber, 64))
3546c3175,3179
<                               NS_LOG_DEBUG ("There's not a valid agreement for this block ack request.");
---
>                               tempPacket = PerformMsduAggregation (peekedPacket, &peekedHdr, &tstamp, currentAggregatedPacket, blockAckSize);
>                               if (tempPacket != 0) //MSDU aggregation
>                                 {
>                                   peekedPacket = tempPacket->Copy ();
>                                 }
3550a3184,3253
> 
>               if (isAmpdu)
>                 {
>                   if (hdr.IsBlockAckReq ())
>                     {
>                       newPacket = packet->Copy ();
>                       peekedHdr = hdr;
>                       Ptr<Packet> aggPacket = newPacket->Copy ();
>                       m_aggregateQueue->Enqueue (aggPacket, peekedHdr);
>                       newPacket->AddHeader (peekedHdr);
>                       WifiMacTrailer fcs;
>                       newPacket->AddTrailer (fcs);
>                       listenerIt->second->GetMpduAggregator ()->Aggregate (newPacket, currentAggregatedPacket);
>                       currentAggregatedPacket->AddHeader (blockAckReq);
>                     }
> 
>                   if (qosPolicy == 0)
>                     {
>                       listenerIt->second->CompleteTransfer (hdr.GetAddr1 (), tid);
>                     }
> 
>                   //Add packet tag
>                   AmpduTag ampdutag;
>                   ampdutag.SetAmpdu (true);
>                   ampdutag.SetRemainingNbOfMpdus (i - 1);
>                   newPacket = currentAggregatedPacket;
>                   newPacket->AddPacketTag (ampdutag);
> 
>                   NS_LOG_DEBUG ("tx unicast A-MPDU");
>                   listenerIt->second->SetAmpdu (hdr.GetAddr1 (), true);
>                 }
>               else
>                 {
>                   uint32_t queueSize = m_aggregateQueue->GetSize ();
>                   NS_ASSERT (queueSize <= 2); //since it is not an A-MPDU then only 2 packets should have been added to the queue no more
>                   if (queueSize >= 1)
>                     {
>                       //remove any packets that we added to the aggregate queue
>                       FlushAggregateQueue ();
>                     }
>                 }
>             }
>           //VHT single MPDU operation
>           WifiTxVector dataTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
>           if (!isAmpdu && dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT && hdr.IsQosData ())
>             {
>               peekedHdr = hdr;
>               peekedHdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
> 
>               currentAggregatedPacket = Create<Packet> ();
>               listenerIt->second->GetMpduAggregator ()->AggregateVhtSingleMpdu (packet, currentAggregatedPacket);
>               m_aggregateQueue->Enqueue (packet, peekedHdr);
>               m_sentMpdus = 1;
> 
>               if (listenerIt->second->GetBlockAckAgreementExists (hdr.GetAddr1 (), tid))
>                 {
>                   listenerIt->second->CompleteTransfer (peekedHdr.GetAddr1 (), tid);
>                 }
> 
>               //Add packet tag
>               AmpduTag ampdutag;
>               ampdutag.SetAmpdu (true);
>               newPacket = currentAggregatedPacket;
>               newPacket->AddHeader (peekedHdr);
>               WifiMacTrailer fcs;
>               newPacket->AddTrailer (fcs);
>               newPacket->AddPacketTag (ampdutag);
> 
>               NS_LOG_DEBUG ("tx unicast VHT single MPDU with sequence number " << hdr.GetSequenceNumber ());
>               listenerIt->second->SetAmpdu (hdr.GetAddr1 (), true);
3554,3563c3257
<   else
<     {
<       /* Simple MPDU */
<       NS_ASSERT (!psdu->IsAggregate ());
<       /* Check if the MPDU contains a Short SSW packet */
<       if (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL && psdu->GetSize () == 6)
<         ReceiveShortSswOk ((*psdu->begin ()), rxSnr, txVector, ampduSubframe);
<       else
<         ReceiveOk ((*psdu->begin ()), rxSnr, txVector, ampduSubframe);
<     }
---
>   return newPacket;
3566,3567c3260,3261
< Time
< MacLow::GetRemainingCfpDuration (void) const
---
> void
> MacLow::FlushAggregateQueue (void)
3569,3572c3263,3268
<   NS_LOG_FUNCTION (this);
<   Time remainingCfpDuration = std::min (m_cfpStart, m_cfpStart + m_cfpMaxDuration - Simulator::Now () - m_cfpForeshortening);
<   NS_ASSERT (remainingCfpDuration.IsPositive ());
<   return remainingCfpDuration;
---
>   if (m_aggregateQueue->GetSize () > 0)
>     {
>       NS_LOG_DEBUG ("Flush aggregate queue");
>       m_aggregateQueue->Flush ();
>     }
>   m_txPackets.clear ();
3575,3576c3271,3272
< bool
< MacLow::IsCfPeriod (void) const
---
> void
> MacLow::InsertInTxQueue (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp)
3578c3274,3280
<   return (m_stationManager->GetPcfSupported () && m_cfpStart.IsStrictlyPositive ());
---
>   Item item;
> 
>   item.packet = packet;
>   item.hdr = hdr;
>   item.timestamp = tStamp;
> 
>   m_txPackets.push_back (item);
3581,3582c3283,3284
< bool
< MacLow::CanTransmitNextCfFrame (void) const
---
> Ptr<Packet>
> MacLow::PerformMsduAggregation (Ptr<const Packet> packet, WifiMacHeader *hdr, Time *tstamp, Ptr<Packet> currentAmpduPacket, uint16_t blockAckSize)
3584,3585c3286,3306
<   NS_LOG_FUNCTION (this);
<   if (!IsCfPeriod ())
---
>   bool msduAggregation = false;
>   bool isAmsdu = false;
>   Ptr<Packet> currentAmsduPacket = Create<Packet> ();
>   Ptr<Packet> tempPacket = Create<Packet> ();
> 
>   Ptr<WifiMacQueue> queue;
>   AcIndex ac = QosUtilsMapTidToAc (GetTid (packet, *hdr));
>   std::map<AcIndex, MacLowAggregationCapableTransmissionListener*>::const_iterator listenerIt = m_edcaListeners.find (ac);
>   NS_ASSERT (listenerIt != m_edcaListeners.end ());
>   queue = listenerIt->second->GetQueue ();
> 
>   Ptr<const Packet> peekedPacket = queue->DequeueByTidAndAddress (hdr, hdr->GetQosTid (),
>                                                                   WifiMacHeader::ADDR1, hdr->GetAddr1 ());
> 
>   listenerIt->second->GetMsduAggregator ()->Aggregate (packet, currentAmsduPacket,
>                                                        listenerIt->second->GetSrcAddressForAggregation (*hdr),
>                                                        listenerIt->second->GetDestAddressForAggregation (*hdr));
> 
>   peekedPacket = queue->PeekByTidAndAddress (hdr, hdr->GetQosTid (),
>                                              WifiMacHeader::ADDR1, hdr->GetAddr1 (), tstamp);
>   while (peekedPacket != 0)
3587c3308,3337
<       return false;
---
>       tempPacket = currentAmsduPacket;
> 
>       msduAggregation = listenerIt->second->GetMsduAggregator ()->Aggregate (peekedPacket, tempPacket,
>                                                                              listenerIt->second->GetSrcAddressForAggregation (*hdr),
>                                                                              listenerIt->second->GetDestAddressForAggregation (*hdr));
> 
>       if (msduAggregation && !StopMpduAggregation (tempPacket, *hdr, currentAmpduPacket, blockAckSize))
>         {
>           isAmsdu = true;
>           currentAmsduPacket = tempPacket;
>           queue->Remove (peekedPacket);
>         }
>       else
>         {
>           break;
>         }
>       peekedPacket = queue->PeekByTidAndAddress (hdr, hdr->GetQosTid (), WifiMacHeader::ADDR1, hdr->GetAddr1 (), tstamp);
>     }
> 
>   if (isAmsdu)
>     {
>       NS_LOG_DEBUG ("A-MSDU with size = " << currentAmsduPacket->GetSize ());
>       hdr->SetQosAmsdu ();
>       hdr->SetAddr3 (GetBssid ());
>       return currentAmsduPacket;
>     }
>   else
>     {
>       queue->PushFront (packet, *hdr);
>       return 0;
3589,3595d3338
<   NS_ASSERT (GetRemainingCfpDuration ().IsPositive ());
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_DATA);
<   WifiMacTrailer fcs;
<   uint32_t maxMacFrameSize = MAX_MSDU_SIZE + hdr.GetSerializedSize () + fcs.GetSerializedSize ();
<   Time nextTransmission = 2 * m_phy->CalculateTxDuration (maxMacFrameSize, m_currentTxVector, m_phy->GetFrequency ()) + 3 * GetSifs () + m_phy->CalculateTxDuration (GetCfEndSize (), m_currentTxVector, m_phy->GetFrequency ());
<   return ((GetRemainingCfpDuration () - nextTransmission).IsPositive ());
diff ../../NS3-WiGig/src/wifi/model/mac-low.h ../../ns-3-dev/src/wifi/model/mac-low.h
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
20,22c19,20
<  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
<  *          Mirko Banchi <mk.banchi@gmail.com>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
>  * Author: Mirko Banchi <mk.banchi@gmail.com>
24d21
< 
27a25,27
> #include <vector>
> #include <stdint.h>
> #include <ostream>
29c29,41
< #include "ns3/object.h"
---
> 
> #include "wifi-mac-header.h"
> #include "wifi-mode.h"
> #include "wifi-phy.h"
> #include "wifi-preamble.h"
> #include "wifi-remote-station-manager.h"
> #include "ctrl-headers.h"
> #include "mgt-headers.h"
> #include "block-ack-agreement.h"
> #include "ns3/mac48-address.h"
> #include "ns3/callback.h"
> #include "ns3/event-id.h"
> #include "ns3/packet.h"
31,33d42
< #include "channel-access-manager.h"
< #include "block-ack-cache.h"
< #include "mac-low-transmission-parameters.h"
35c44
< #include "wifi-mac-header.h"
---
> #include "block-ack-cache.h"
37,39c46,50
< #include "block-ack-type.h"
< #include "wifi-mpdu-type.h"
< #include "wigig-data-types.h"
---
> #include "mpdu-aggregator.h"
> #include "msdu-aggregator.h"
> 
> class TwoLevelAggregationTest;
> class AmpduAggregationTest;
43d53
< class WifiMac;
45,47c55,56
< class Txop;
< class QosTxop;
< class WifiMacQueueItem;
---
> class WifiMac;
> class EdcaTxopN;
49,56d57
< class WifiPsdu;
< class BlockAckAgreement;
< class MgtAddBaResponseHeader;
< class WifiRemoteStationManager;
< class CtrlBAckRequestHeader;
< class CtrlBAckResponseHeader;
< class MsduAggregator;
< class MpduAggregator;
60c61
<  * \brief handle RTS/CTS/Data/Ack transactions.
---
>  * \brief listen to events coming from ns3::MacLow.
62c63
< class MacLow : public Object
---
> class MacLowTransmissionListener
64a66,199
>   MacLowTransmissionListener ();
>   virtual ~MacLowTransmissionListener ();
> 
>   /**
>    * \param snr the snr of the cts
>    * \param txMode the txMode of the cts
>    *
>    * ns3::MacLow received an expected CTS within
>    * CtsTimeout.
>    */
>   virtual void GotCts (double snr, WifiMode txMode) = 0;
>   /**
>    * ns3::MacLow did not receive an expected CTS
>    * within CtsTimeout.
>    */
>   virtual void MissedCts (void) = 0;
>   /**
>    * \param snr the snr of the ack
>    * \param txMode the transmission mode of the ack
>    *
>    * ns3::MacLow received an expected ACK within
>    * AckTimeout. The <i>snr</i> and <i>txMode</i>
>    * arguments are not valid when SUPER_FAST_ACK is
>    * used.
>    */
>   virtual void GotAck (double snr, WifiMode txMode) = 0;
>   /**
>    * ns3::MacLow did not receive an expected ACK within
>    * AckTimeout.
>    */
>   virtual void MissedAck (void) = 0;
>   /**
>    * \param blockAck Block ack response header
>    * \param source Address of block ack sender
>    * \param rxSnr received SNR of block ack response
>    * \param txMode mode of block ack response
>    * \param dataSnr SNR conveyed from remote station (received data SNR)
>    *
>    * Invoked when ns3::MacLow receives a block ack frame.
>    * Block ack frame is received after a block ack request
>    * and contains information about the correct reception
>    * of a set of packet for which a normal ack wasn't send.
>    * Default implementation for this method is empty. Every
>    * queue that intends to be notified by MacLow of reception
>    * of a block ack must redefine this function.
>    */
>   virtual void GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address source, double rxSnr, WifiMode txMode, double dataSnr);
>   /**
>    * \param nMpdus number of MPDUs that were transmitted in the unsuccesful A-MPDU transmission
>    *
>    * ns3::MacLow did not receive an expected BLOCK_ACK within
>    * BlockAckTimeout. This method is used only for immediate
>    * block ack variant. With delayed block ack, the MissedAck method will be
>    * called instead: upon receipt of a block ack request, the rx station will
>    * reply with a normal ack frame. Later, when the rx station gets a txop, it
>    * will send the block ack back to the tx station which will reply with a
>    * normal ack to the rx station.
>    */
>   virtual void MissedBlockAck (uint32_t nMpdus);
>   /**
>    * Invoked when ns3::MacLow wants to start a new transmission
>    * as configured by MacLowTransmissionParameters::EnableNextData.
>    * The listener is expected to call again MacLow::StartTransmission
>    * with the "next" fragment to send.
>    */
>   virtual void StartNextFragment (void) = 0;
>   /**
>    * Invoked when ns3::MacLow wants to continue the TXOP.
>    * The listener is expected to call again MacLow::StartTransmission
>    * with the "next" packet to send.
>    */
>   virtual void StartNext (void) = 0;
>   /**
>    * Invoked if this transmission was canceled
>    * one way or another. When this method is invoked,
>    * you can assume that the packet has not been passed
>    * down the stack to the PHY.
>    */
>   virtual void Cancel (void) = 0;
>   /**
>    * Invoked upon the end of the transmission of a frame that does not
>    * require an ACK (e.g., broadcast and multicast frames).
>    *
>    */
>   virtual void EndTxNoAck (void) = 0;
> };
> 
> 
> /**
>  * \brief listen to NAV events
>  * \ingroup wifi
>  *
>  * This class is typically connected to an instance of ns3::Dcf
>  * and calls to its methods are forwards to the corresponding
>  * ns3::Dcf methods.
>  */
> class MacLowDcfListener
> {
> public:
>   MacLowDcfListener ();
>   virtual ~MacLowDcfListener ();
>   /**
>    * Norify that NAV has started for the given duration.
>    *
>    * \param duration duration of NAV timer
>    */
>   virtual void NavStart (Time duration) = 0;
>   /**
>    * Notify that NAV has resetted.
>    *
>    * \param duration duration of NAV timer
>    */
>   virtual void NavReset (Time duration) = 0;
>   /**
>    * Notify that ACK timeout has started for a given duration.
>    *
>    * \param duration duration of ACK timeout
>    */
>   virtual void AckTimeoutStart (Time duration) = 0;
>   /**
>    * Notify that ACK timeout has resetted.
>    */
>   virtual void AckTimeoutReset () = 0;
>   /**
>    * Notify that CTS timeout has started for a given duration.
>    *
>    * \param duration duration of CTS timeout
>    */
>   virtual void CtsTimeoutStart (Time duration) = 0;
>   /**
>    * Notify that CTS timeout has resetted.
>    */
>   virtual void CtsTimeoutReset () = 0;
> };
65a201,505
> /**
>  * \ingroup wifi
>  * \brief listen for block ack events.
>  */
> class MacLowAggregationCapableTransmissionListener
> {
> public:
>   MacLowAggregationCapableTransmissionListener ();
>   virtual ~MacLowAggregationCapableTransmissionListener ();
>   /**
>    * Typically is called in order to notify EdcaTxopN that a block ack inactivity
>    * timeout occurs for the block ack agreement identified by the pair <i>originator</i>, <i>tid</i>.
>    *
>    * Rx station maintains an inactivity timer for each block ack
>    * agreement. Timer is reset when a frame with ack policy block ack
>    * or a block ack request are received. When this timer reaches zero
>    * this method is called and a delba frame is scheduled for transmission.
>    *
>    * \param originator MAC address of the data originator
>    * \param tid
>    */
>   virtual void BlockAckInactivityTimeout (Mac48Address originator, uint8_t tid) = 0;
>   /**
>    * Returns the EDCA queue to check if there are packets that can be aggregated with a Block Ack
>    */
>   virtual Ptr<WifiMacQueue> GetQueue (void) = 0;
>   /**
>    * \param address address of peer station involved in block ack mechanism.
>    * \param tid traffic ID of transmitted packet.
>    *
>    * Calls CompleteAmpduTransfer that resets the status of OriginatorBlockAckAgreement after the transfer
>    * of an A-MPDU with ImmediateBlockAck policy (i.e. no BAR is scheduled)
>    */
>   virtual void CompleteTransfer (Mac48Address address, uint8_t tid);
>   virtual void SetAmpdu (Mac48Address dest, bool enableAmpdu);
>   /**
>    * This function stores an MPDU (part of an A-MPDU) in blockackagreement (i.e. the sender is waiting
>    * for a blockack containing the sequence number of this MPDU).
>    * It also calls NotifyMpdu transmission that updates the status of OriginatorBlockAckAgreement.
>    */
>   virtual void CompleteMpduTx (Ptr<const Packet> packet, WifiMacHeader hdr, Time tstamp);
>   /**
>    * Return the next sequence number for the given header.
>    *
>    * \param hdr Wi-Fi header
>    * \return the next sequence number
>    */
>   virtual uint16_t GetNextSequenceNumberfor (WifiMacHeader *hdr);
>   /**
>    * Return the next sequence number for the Traffic ID and destination, but do not pick it (i.e. the current sequence number remains unchanged).
>    *
>    * \param hdr Wi-Fi header
>    * \return the next sequence number
>    */
>   virtual uint16_t PeekNextSequenceNumberfor (WifiMacHeader *hdr);
>   /*
>    * Peek in retransmit queue and get the next packet without removing it from the queue
>    */
>   virtual Ptr<const Packet> PeekNextPacketInBaQueue (WifiMacHeader &header, Mac48Address recipient, uint8_t tid, Time *timestamp);
>   /**
>    * Remove a packet after you peek in the retransmit queue and get it
>    */
>   virtual void RemoveFromBaQueue (uint8_t tid, Mac48Address recipient, uint16_t seqnumber);
>   /**
>    * \param recipient address of the peer station
>    * \param tid traffic ID.
>    * \return true if a block ack agreement exists, false otherwise
>    *
>    * Checks if a block ack agreement exists with station addressed by
>    * <i>recipient</i> for tid <i>tid</i>.
>    */
>   virtual bool GetBlockAckAgreementExists (Mac48Address address, uint8_t tid) = 0;
>   /**
>    * \param recipient address of peer station involved in block ack mechanism.
>    * \param tid traffic ID.
>    * \return the number of packets buffered for a specified agreement
>    *
>    * Returns number of packets buffered for a specified agreement.
>    */
>   virtual uint32_t GetNOutstandingPackets (Mac48Address recipient, uint8_t tid);
>   /**
>    * \param recipient address of peer station involved in block ack mechanism.
>    * \param tid traffic ID.
>    * \return the number of packets for a specific agreement that need retransmission
>    *
>    * Returns number of packets for a specific agreement that need retransmission.
>    */
>   virtual uint32_t GetNRetryNeededPackets (Mac48Address recipient, uint8_t tid) const;
>   /**
>    */
>   virtual Ptr<MsduAggregator> GetMsduAggregator (void) const;
>   /**
>    */
>   virtual Ptr<MpduAggregator> GetMpduAggregator (void) const;
>   /**
>    */
>   virtual Mac48Address GetSrcAddressForAggregation (const WifiMacHeader &hdr);
>   /**
>    */
>   virtual Mac48Address GetDestAddressForAggregation (const WifiMacHeader &hdr);
> };
> 
> /**
>  * \brief control how a packet is transmitted.
>  * \ingroup wifi
>  *
>  * The ns3::MacLow::StartTransmission method expects
>  * an instance of this class to describe how the packet
>  * should be transmitted.
>  */
> class MacLowTransmissionParameters
> {
> public:
>   MacLowTransmissionParameters ();
> 
>   /**
>    * Wait ACKTimeout for an ACK. If we get an ACK
>    * on time, call MacLowTransmissionListener::GotAck.
>    * Call MacLowTransmissionListener::MissedAck otherwise.
>    */
>   void EnableAck (void);
>   /**
>    *   - wait PIFS after end-of-tx. If idle, call
>    *     MacLowTransmissionListener::MissedAck.
>    *   - if busy at end-of-tx+PIFS, wait end-of-rx
>    *   - if Ack ok at end-of-rx, call
>    *     MacLowTransmissionListener::GotAck.
>    *   - if Ack not ok at end-of-rx, report call
>    *     MacLowTransmissionListener::MissedAck
>    *     at end-of-rx+SIFS.
>    *
>    * This is really complicated but it is needed for
>    * proper HCCA support.
>    */
>   void EnableFastAck (void);
>   /**
>    *  - if busy at end-of-tx+PIFS, call
>    *    MacLowTransmissionListener::GotAck
>    *  - if idle at end-of-tx+PIFS, call
>    *    MacLowTransmissionListener::MissedAck
>    */
>   void EnableSuperFastAck (void);
>   /**
>    * Wait BASICBLOCKACKTimeout for a Basic Block Ack Response frame.
>    */
>   void EnableBasicBlockAck (void);
>   /**
>    * Wait COMPRESSEDBLOCKACKTimeout for a Compressed Block Ack Response frame.
>    */
>   void EnableCompressedBlockAck (void);
>   /**
>    * NOT IMPLEMENTED FOR NOW
>    */
>   void EnableMultiTidBlockAck (void);
>   /**
>    * Send a RTS, and wait CTSTimeout for a CTS. If we get a
>    * CTS on time, call MacLowTransmissionListener::GotCts
>    * and send data. Otherwise, call MacLowTransmissionListener::MissedCts
>    * and do not send data.
>    */
>   void EnableRts (void);
>   /**
>    * \param size size of next data to send after current packet is
>    *        sent.
>    *
>    * Add the transmission duration of the next data to the
>    * durationId of the outgoing packet and call
>    * MacLowTransmissionListener::StartNextFragment at the end of
>    * the current transmission + SIFS.
>    */
>   void EnableNextData (uint32_t size);
>   /**
>    * \param durationId the value to set in the duration/Id field of
>    *        the outgoing packet.
>    *
>    * Ignore all other durationId calculation and simply force the
>    * packet's durationId field to this value.
>    */
>   void EnableOverrideDurationId (Time durationId);
>   /**
>    * Do not wait for Ack after data transmission. Typically
>    * used for Broadcast and multicast frames.
>    */
>   void DisableAck (void);
>   /**
>    * Do not send rts and wait for cts before sending data.
>    */
>   void DisableRts (void);
>   /**
>    * Do not attempt to send data burst after current transmission
>    */
>   void DisableNextData (void);
>   /**
>    * Do not force the duration/id field of the packet: its
>    * value is automatically calculated by the MacLow before
>    * calling WifiPhy::Send.
>    */
>   void DisableOverrideDurationId (void);
>   /**
>    * \returns true if must wait for ACK after data transmission,
>    *          false otherwise.
>    *
>    * This methods returns true when any of MustWaitNormalAck,
>    * MustWaitFastAck, or MustWaitSuperFastAck return true.
>    */
>   bool MustWaitAck (void) const;
>   /**
>    * \returns true if normal ACK protocol should be used, false
>    *          otherwise.
>    *
>    * \sa EnableAck
>    */
>   bool MustWaitNormalAck (void) const;
>   /**
>    * \returns true if fast ack protocol should be used, false
>    *          otherwise.
>    *
>    * \sa EnableFastAck
>    */
>   bool MustWaitFastAck (void) const;
>   /**
>    * \returns true if super fast ack protocol should be used, false
>    *          otherwise.
>    *
>    * \sa EnableSuperFastAck
>    */
>   bool MustWaitSuperFastAck (void) const;
>   /**
>    * \returns true if block ack mechanism is used, false otherwise.
>    *
>    * \sa EnableBlockAck
>    */
>   bool MustWaitBasicBlockAck (void) const;
>   /**
>    * \returns true if compressed block ack mechanism is used, false otherwise.
>    *
>    * \sa EnableCompressedBlockAck
>    */
>   bool MustWaitCompressedBlockAck (void) const;
>   /**
>    * \returns true if multi-tid block ack mechanism is used, false otherwise.
>    *
>    * \sa EnableMultiTidBlockAck
>    */
>   bool MustWaitMultiTidBlockAck (void) const;
>   /**
>    * \returns true if RTS should be sent and CTS waited for before
>    *          sending data, false otherwise.
>    */
>   bool MustSendRts (void) const;
>   /**
>    * \returns true if a duration/id was forced with
>    *         EnableOverrideDurationId, false otherwise.
>    */
>   bool HasDurationId (void) const;
>   /**
>    * \returns the duration/id forced by EnableOverrideDurationId
>    */
>   Time GetDurationId (void) const;
>   /**
>    * \returns true if EnableNextData was called, false otherwise.
>    */
>   bool HasNextPacket (void) const;
>   /**
>    * \returns the size specified by EnableNextData.
>    */
>   uint32_t GetNextPacketSize (void) const;
> 
> private:
>   friend std::ostream &operator << (std::ostream &os, const MacLowTransmissionParameters &params);
>   uint32_t m_nextSize;
>   enum
>   {
>     ACK_NONE,
>     ACK_NORMAL,
>     ACK_FAST,
>     ACK_SUPER_FAST,
>     BLOCK_ACK_BASIC,
>     BLOCK_ACK_COMPRESSED,
>     BLOCK_ACK_MULTI_TID
>   } m_waitAck;
>   bool m_sendRts;
>   Time m_overrideDurationId;
> };
> 
> /**
>  * Serialize MacLowTransmissionParameters to ostream in a human-readable form.
>  *
>  * \param os std::ostream
>  * \param params MacLowTransmissionParameters
>  * \return std::ostream
>  */
> std::ostream &operator << (std::ostream &os, const MacLowTransmissionParameters &params);
> 
> 
> /**
>  * \ingroup wifi
>  * \brief handle RTS/CTS/DATA/ACK transactions.
>  */
> class MacLow : public Object
> {
> public:
>   // Allow test cases to access private members
>   friend class ::TwoLevelAggregationTest;
>   friend class ::AmpduAggregationTest;
69c509
<   typedef Callback<void, Ptr<WifiMacQueueItem>> MacLowRxCallback;
---
>   typedef Callback<void, Ptr<Packet>, const WifiMacHeader*> MacLowRxCallback;
85,86c525,526
<   void SetPhy (const Ptr<WifiPhy> phy);
<   /**
---
>   void SetPhy (Ptr<WifiPhy> phy);
>   /*
92,100d531
<    */
<   void ResetPhy (void);
<   /**
<    * \param tid the Traffic ID
<    * \return the QosTxop corresponding to the given TID
<    */
<   Ptr<QosTxop> GetEdca (uint8_t tid) const;
<   /**
<    * Set up WifiMac associated with this MacLow.
102c533
<    * \param mac WifiMac associated with this MacLow
---
>    * \param phy WifiPhy associated with this MacLow
104c535
<   void SetMac (const Ptr<WifiMac> mac);
---
>   void ResetPhy (void);
110c541
<   void SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> manager);
---
>   void SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> manager);
118c549
<    * Set Ack timeout of this MacLow.
---
>    * Set ACK timeout of this MacLow.
120c551
<    * \param ackTimeout Ack timeout of this MacLow
---
>    * \param ackTimeout ACK timeout of this MacLow
124c555
<    * Set Basic BlockAck timeout of this MacLow.
---
>    * Set Basic Block ACK timeout of this MacLow.
126c557
<    * \param blockAckTimeout Basic BlockAck timeout of this MacLow
---
>    * \param blockAckTimeout Basic Block ACK timeout of this MacLow
130c561
<    * Set Compressed BlockAck timeout of this MacLow.
---
>    * Set Compressed Block ACK timeout of this MacLow.
132c563
<    * \param blockAckTimeout Compressed BlockAck timeout of this MacLow
---
>    * \param blockAckTimeout Compressed Block ACK timeout of this MacLow
141a573,578
>    * Set CTS timeout of this MacLow.
>    *
>    * \param ctsTimeout CTS timeout of this MacLow
>    */
>   void SetCtsTimeout (Time ctsTimeout);
>   /**
166,199d602
<    * \param interval the expected interval between two beacon transmissions.
<    */
<   void SetBeaconInterval (Time interval);
<   /**
<    * \param duration the maximum duration for the CF period.
<    */
<   void SetCfpMaxDuration (Time duration);
<   //// WIGIG ////
<   /**
<    * Set Short Beamforming Interframe Space (SBIFS) of this MacLow.
<    *
<    * \param sbifs SBIFS of this MacLow
<    */
<   void SetSbifs (Time sbifs);
<   /**
<    * Set Medimum Beamforming Interframe Space (SBIFS) of this MacLow.
<    *
<    * \param mbifs MBIFS of this MacLow
<    */
<   void SetMbifs (Time mbifs);
<   /**
<    * Set Long Beamforming Interframe Space (LBIFS) of this MacLow.
<    *
<    * \param lbifs LBIFS of this MacLow
<    */
<   void SetLbifs (Time lbifs);
<   /**
<    * Set Beam Refinement Interframe Space (BRIFS) of this MacLow.
<    *
<    * \param sbifs SBIFS of this MacLow
<    */
<   void SetBrifs (Time brifs);
<   //// WIGIG ////
<   /**
214c617
<   bool GetCtsToSelfSupported (void) const;
---
>   bool GetCtsToSelfSupported () const;
222c625
<    * Return Ack timeout of this MacLow.
---
>    * Return ACK timeout of this MacLow.
224c627
<    * \return Ack timeout
---
>    * \return ACK timeout
228c631,637
<    * Return Basic BlockAck timeout of this MacLow.
---
>    * Return Basic Block ACK timeout of this MacLow.
>    *
>    * \return Basic Block ACK timeout
>    */
>   Time GetBasicBlockAckTimeout () const;
>   /**
>    * Return Compressed Block ACK timeout of this MacLow.
230c639
<    * \return Basic BlockAck timeout
---
>    * \return Compressed Block ACK timeout
232c641
<   Time GetBasicBlockAckTimeout (void) const;
---
>   Time GetCompressedBlockAckTimeout () const;
234c643
<    * Return Compressed BlockAck timeout of this MacLow.
---
>    * Return CTS timeout of this MacLow.
236c645
<    * \return Compressed BlockAck timeout
---
>    * \return CTS timeout
238c647
<   Time GetCompressedBlockAckTimeout (void) const;
---
>   Time GetCtsTimeout (void) const;
264,301d672
<    * \return the expected interval between two beacon transmissions.
<    */
<   Time GetBeaconInterval (void) const;
<   /**
<    * \return the maximum duration for the CF period.
<    */
<   Time GetCfpMaxDuration (void) const;
<   /**
<    * \return the remaining duration for the CF period.
<    */
<   Time GetRemainingCfpDuration (void) const;
<   //// WIGIG ////
<   /**
<    * Return Short Beamforming Interframe Space (SBIFS) of this MacLow.
<    *
<    * \return SBIFS
<    */
<   Time GetSbifs (void) const;
<   /**
<    * Return Medium Beamforming Interframe Space (SBIFS) of this MacLow.
<    *
<    * \return MBIFS
<    */
<   Time GetMbifs (void) const;
<   /**
<    * Return Large Beamforming Interframe Space (LBIFS) of this MacLow.
<    *
<    * \return LBIFS
<    */
<   Time GetLbifs (void) const;
<   /**
<    * Return Beamforming Refinement Interframe Space (BRIFS) of this MacLow.
<    *
<    * \return BRIFS
<    */
<   Time GetBrifs (void) const;
<   //// WIGIG ////
<   /**
321c692
<   void SetRxCallback (Callback<void, Ptr<WifiMacQueueItem>> callback);
---
>   void SetRxCallback (Callback<void,Ptr<Packet>,const WifiMacHeader *> callback);
323,324c694,695
<    * \param channelAccessManager pointer to ChannelAccessManager in order to listen to NAV events
<    *        for every incoming and outgoing packet.
---
>    * \param listener listen to NAV events for every incoming
>    *        and outgoing packet.
326c697
<   void RegisterChannelAccessManager (Ptr<ChannelAccessManager> channelAccessManager);
---
>   void RegisterDcfListener (MacLowDcfListener *listener);
329,362d699
<    * Check whether the given MPDU, if transmitted according to the given TX vector,
<    * meets the constraint on the maximum A-MPDU size (by assuming that the frame
<    * has to be aggregated to an existing A-MPDU of the given size) and its
<    * transmission time exceeds neither the max PPDU duration (depending on the
<    * PPDU format) nor the given PPDU duration limit (if strictly positive).
<    * The given MPDU needs to be a QoS Data frame.
<    *
<    * \param mpdu the MPDU.
<    * \param txVector the TX vector used to transmit the MPDU
<    * \param ampduSize the size of the existing A-MPDU in bytes, if any
<    * \param ppduDurationLimit the limit on the PPDU duration
<    * \returns true if constraints on size and duration limit are met.
<    */
<   bool IsWithinSizeAndTimeLimits (Ptr<const WifiMacQueueItem> mpdu, WifiTxVector txVector,
<                                   uint32_t ampduSize, Time ppduDurationLimit);
<   /**
<    * Check whether an MPDU of the given size, destined to the given receiver and
<    * belonging to the given TID, if transmitted according to the given TX vector,
<    * meets the constraint on the maximum A-MPDU size (by assuming that the frame
<    * has to be aggregated to an existing A-MPDU of the given size) and its
<    * transmission time exceeds neither the max PPDU duration (depending on the
<    * PPDU format) nor the given PPDU duration limit (if strictly positive).
<    *
<    * \param mpduSize the MPDU size.
<    * \param receiver the receiver
<    * \param tid the TID
<    * \param txVector the TX vector used to transmit the MPDU
<    * \param ampduSize the size of the existing A-MPDU in bytes, if any
<    * \param ppduDurationLimit the limit on the PPDU duration
<    * \returns true if constraints on size and duration limit are met.
<    */
<   bool IsWithinSizeAndTimeLimits (uint32_t mpduSize, Mac48Address receiver, uint8_t tid,
<                                   WifiTxVector txVector, uint32_t ampduSize, Time ppduDurationLimit);
<   /**
375,384d711
<   /**
<    * \param packet to send (does not include the 802.11 MAC header and checksum)
<    * \param hdr header associated to the packet to send.
<    * \param params transmission parameters of packet.
<    * \param fragmentSize the packet fragment size (if fragmentation is used) in bytes
<    * \return the transmission time that includes the time for the next packet transmission
<    *
<    * This transmission time does not include the time required for
<    * the next packet transmission if one was selected.
<    */
387,388c714
<                                const MacLowTransmissionParameters& params,
<                                uint32_t fragmentSize = 0) const;
---
>                                const MacLowTransmissionParameters &params) const;
391,430c717,718
<    * \param item packet to send (does not include the 802.11 MAC header and checksum)
<    * \param params transmission parameters of packet.
<    * \return the transmission time that does not include the time required to transmit the frame
<    *
<    * This transmission time  only includes the time for the RTS/CTS exchange (if any)
<    * and for the Ack frame (if any).
<    */
<   Time CalculateOverheadTxTime (Ptr<const WifiMacQueueItem> item,
<                                const MacLowTransmissionParameters& params) const;
< 
<   /**
<    * \param mpdu packet to send
<    * \param parameters the transmission parameters to use for this packet.
<    * \param txop pointer to the calling Txop.
<    *
<    * Start the transmission of the input packet and notify the listener
<    * of transmission events.
<    */
<   virtual void StartTransmission (Ptr<WifiMacQueueItem> mpdu,
<                                   MacLowTransmissionParameters parameters,
<                                   Ptr<Txop> txop);
< 
<   //// WIGIG ////
<   typedef Callback<void, const WifiMacHeader &> TransmissionOkCallback;
<   typedef Callback<void> TransmissionShortSswOkCallback;
< 
<   /**
<    * \param mpdu packet to send
<    * \param parameters the transmission parameters to use for this packet.
<    * \param txop pointer to the calling Txop.
<    *
<    * Start the transmission of the input packet and notify the listener
<    * of transmission events.
<    * Note: This function is used for DMG/EDMG management and control frames transmission.
<    */
<   void TransmitSingleFrame (Ptr<WifiMacQueueItem> mpdu,
<                             MacLowTransmissionParameters params,
<                             Ptr<Txop> txop);
<   /**
<    * \param mpdu packet to send
---
>    * \param packet packet to send
>    * \param hdr 802.11 header for packet to send
437c725,726
<   virtual void StartTransmission (Ptr<WifiMacQueueItem> mpdu,
---
>   virtual void StartTransmission (Ptr<const Packet> packet,
>                                   const WifiMacHeader* hdr,
439,520c728
<                                   TransmissionOkCallback callback);
<   /**
<    * \param mpdu packet to send
<    * \param parameters the transmission parameters to use for this packet.
<    * \param listener listen to transmission events.
<    *
<    * Start the transmission of the input Short SSW packet and notify the listener
<    * of transmission events.
<    */
<   void StartShortSswTransmission (Ptr<WifiMacQueueItem> mpdu,
<                           MacLowTransmissionParameters parameters,
<                           TransmissionShortSswOkCallback callback);
<   /**
<    * Resume Transmission for the current allocation if transmission has been suspended.
<    * \param overrideDuration Flagt to indicate if we want to override duration field
<    * \param duration The duration of the current Allocation
<    * \param listener
<    */
< //  void ResumeTransmission (bool overrideDuration, Time duration, MacLowTransmissionListener *listener);
<   
<   /**
<    * IsCurrentAllocationEmpty
<    * \return True if the current allocation pointer is empty, otherwise false.
<    */
<   bool IsCurrentAllocationEmpty (void) const;
<   /**
<    * Resume Transmission for the current allocation if transmission has been suspended.
<    * \param duration The remaining duration of the current resumed allocation.
<    * \param txop Pointer to the transmit opprtunity associated with the suspedned transmission.
<    */
<   void ResumeTransmission (Time duration, Ptr<Txop> txop);
<   /**
<    * Abort suspended transmission - in case the suspended packet lifetime has passed.
<    */
<   void AbortSuspendedTransmission (void);
< 
< 
<   void ChangeAllocationPacketsAddress (AllocationID allocationId, Mac48Address destAdd);
<   /**
<    * Restore Allocation Parameters for specific allocation SP or CBAP.
<    * \param allocationId The ID of the allocation.
<    */
<   void RestoreAllocationParameters (AllocationID allocationId);
<   /**
<    * Store parameters related to the current allocation.
<    */
<   void StoreAllocationParameters (void);
<   /**
<    * This function is called upon the end of the current allocation period.
<    */
<   void EndAllocationPeriod (void);
<   /**
<    * Check whether a transmission has been suspended due to time constraints for the restored or current allocation.
<    * \return True if transmission has been suspended, otherwise false.
<    */
<   bool IsTransmissionSuspended (void) const;
<   /**
<    * Check whether we have completed the transmission of a suspended PSDU for the given Txop.
<    * \param txop A pointer to the Txop utilizing the current allocation for which the PSDU transmission has been suspended.
<    * \return True if we've completed the transmission for the restored suspended transmission corresponding to the given Txop,
<    *          otherwise false.
<    */
<   bool CompletedSuspendedPsduTransmission (Ptr<Txop> txop) const;
<   /**
<    * Check whether there has been a switch in the transmission mode (SISO/MIMO) between the suspension of the transmission and its restoration.
<    * \return True if there has been a switch in the transmission mode between the suspenssion and restoration of the transmission.
<    */
<   bool SwitchInTransmissionMode (void) const;
<   //// WIGIG ////
< 
<   /**
<    * \param txVector the TXVECTOR decoded from PHY header.
<    * \param psduDuration the duration of the PSDU that is about to be received.
<    *
<    * This method is typically invoked by the lower PHY layer to notify
<    * the MAC layer that the reception of a PSDU is starting.
<    * This is equivalent to the PHY-RXSTART primitive.
<    * If the reception is correct for at least one MPDU of the PSDU
<    * the DeaggregateAmpduAndReceive will be called after \p psduDuration.
<    * Otherwise, ReceiveError will be called after the same duration.
<    */
<   void RxStartIndication (WifiTxVector txVector, Time psduDuration);
---
>                                   MacLowTransmissionListener *listener);
523,525c731,734
<    * \param mpdu MPDU received
<    * \param rxSnr snr of MPDU received in linear scale
<    * \param txVector TXVECTOR of MPDU received
---
>    * \param packet packet received
>    * \param rxSnr snr of packet received
>    * \param txVector TXVECTOR of packet received
>    * \param preamble type of preamble used for the packet received
529c738
<    * the MAC layer that an MPDU was successfully received.
---
>    * the MAC layer that a packet was successfully received.
531c740
<   void ReceiveOk (Ptr<WifiMacQueueItem> mpdu, double rxSnr, WifiTxVector txVector, bool ampduSubframe);
---
>   void ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, WifiPreamble preamble, bool ampduSubframe);
533,536c742,744
<    * \param mpdu MPDU received
<    * \param rxSnr snr of MPDU received in linear scale
<    * \param txVector TXVECTOR of MPDU received
<    * \param ampduSubframe true if this MPDU is part of an A-MPDU
---
>    * \param packet packet received.
>    * \param rxSnr snr of packet received.
>    * \param isEndOfFrame PHY-RXEND indication.
539c747
<    * the MAC layer that an Short SSW packet was successfully received.
---
>    * the MAC layer that a packet was unsuccessfully received.
541,549c749
<   void ReceiveShortSswOk (Ptr<WifiMacQueueItem> mpdu, double rxSnr, WifiTxVector txVector, bool ampduSubframe);
< 
<   /**
<    * \param psdu PSDU received.
<    *
<    * This method is typically invoked by the lower PHY layer to notify
<    * the MAC layer that a PSDU was unsuccessfully received.
<    */
<   void ReceiveError (Ptr<WifiPsdu> psdu);
---
>   void ReceiveError (Ptr<Packet> packet, double rxSnr);
554,555c754,755
<    * the MAC layer that a channel switching occurred. When a channel switching
<    * occurs, pending MAC transmissions (RTS, CTS, Data and Ack) are cancelled.
---
>    * the MAC layer that a channel switching occured. When a channel switching
>    * occurs, pending MAC transmissions (RTS, CTS, DATA and ACK) are cancelled.
561c761
<    * into sleep mode, pending MAC transmissions (RTS, CTS, Data and Ack) are cancelled.
---
>    * into sleep mode, pending MAC transmissions (RTS, CTS, DATA and ACK) are cancelled.
565,570d764
<    * This method is typically invoked by the PhyMacLowListener to notify
<    * the MAC layer that the device has been put into off mode. When the device is put
<    * into off mode, pending MAC transmissions (RTS, CTS, Data and Ack) are cancelled.
<    */
<   void NotifyOffNow (void);
<   /**
572c766
<    *        frame).
---
>    * frame).
574c768
<    *        mechanism.
---
>    * mechanism.
576c770
<    *        packets for which block ack was negotiated.
---
>    * packets for which block ack was negotiated.
583c777
<    * for which block ack was negotiated.
---
>    * for which Block Ack was negotiated.
589,590c783,784
<    * \param originator Address of peer participating in block ack mechanism.
<    * \param tid TID for which block ack was created.
---
>    * \param originator Address of peer participating in Block Ack mechanism.
>    * \param tid TID for which Block Ack was created.
593c787
<    * for TID <i>tid</i>. If the agreement exists, tears down it. This function is typically
---
>    * for tid <i>tid</i>. If the agreement exists, tears down it. This function is typically
599c793
<    * \param edca the QosTxop for the queue.
---
>    * \param listener The listener for the queue.
601c795
<    * The lifetime of the registered QosTxop is typically equal to the lifetime of the queue
---
>    * The lifetime of the registered listener is typically equal to the lifetime of the queue
604c798,807
<   void RegisterEdcaForAc (AcIndex ac, Ptr<QosTxop> edca);
---
>   void RegisterBlockAckListenerForAc (enum AcIndex ac, MacLowAggregationCapableTransmissionListener *listener);
>   /**
>    * \param packet the packet to be aggregated. If the aggregation is succesfull, it corresponds either to the first data packet that will be aggregated or to the BAR that will be piggybacked at the end of the A-MPDU.
>    * \param hdr the WifiMacHeader for the packet.
>    * \return the A-MPDU packet if aggregation is successfull, the input packet otherwise
>    *
>    * This function adds the packets that will be added to an A-MPDU to an aggregate queue
>    *
>    */
>   Ptr<Packet> AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr);
607c810
<    * \param rxSnr SNR of packet received in linear scale
---
>    * \param rxSnr snr of packet received
609c812
<    * \param statusPerMpdu reception status per MPDU
---
>    * \param preamble type of preamble used for the packet received
614,616c817
<   void DeaggregateAmpduAndReceive (Ptr<WifiPsdu> aggregatedPacket, double rxSnr, WifiTxVector txVector,
<                                    std::vector<bool> statusPerMpdu);
< 
---
>   void DeaggregateAmpduAndReceive (Ptr<Packet> aggregatedPacket, double rxSnr, WifiTxVector txVector, WifiPreamble preamble);
618,620c819,825
<    * Return a TXVECTOR for the Data frame given the destination.
<    * The function consults WifiRemoteStationManager, which controls the rate
<    * to different destinations.
---
>    * \param peekedPacket the packet to be aggregated
>    * \param peekedHdr the WifiMacHeader for the packet.
>    * \param aggregatedPacket the current A-MPDU
>    * \param size the size of a piggybacked block ack request
>    * \return false if the given packet can be added to an A-MPDU, true otherwise
>    *
>    * This function decides if a given packet can be added to an A-MPDU or not
622,623d826
<    * \param item the item being asked for TXVECTOR
<    * \return TXVECTOR for the given item
625c828
<   virtual WifiTxVector GetDataTxVector (Ptr<const WifiMacQueueItem> item) const;
---
>   bool StopMpduAggregation (Ptr<const Packet> peekedPacket, WifiMacHeader peekedHdr, Ptr<Packet> aggregatedPacket, uint16_t size) const;
627d829
<    * Start NAV with the given duration.
629,630c831,832
<    * \param duration the duration
<    * \return true if NAV is reset
---
>    * This function is called to flush the aggregate queue, which is used for A-MPDU
>    *
632c834
<   bool DoNavStartNow (Time duration);
---
>   void FlushAggregateQueue (void);
634d835
<   //// WIGIG ////
636c837
<    * Return a TXVECTOR for the DMG Control frame given the destination.
---
>    * Return a TXVECTOR for the DATA frame given the destination.
640,667c841,843
<    * \param item the item being asked for TXVECTOR
<    * \return TXVECTOR for the given item
<    */
<   WifiTxVector GetDmgTxVector (Ptr<const WifiMacQueueItem> item) const;
<   /**
<    * SLS phase has started.
<    */
<   void SLS_Phase_Started (void);
<   /**
<    * SLS phase has ended.
<    */
<   void SLS_Phase_Ended (void);
<   /**
<    * Return whether we are performing SLS or not.
<    * \return True if we are performing SLS, otherwise false.
<    */
<   bool Is_Performing_SLS (void) const;
<   /**
<    * MIMO BFT phase has started.
<    */
<   void MIMO_BFT_Phase_Started (void);
<   /**
<    * MIMO BFT phase has ended.
<    */
<   void MIMO_BFT_Phase_Ended (void);
<   /**
<    * Return whether we are performing MIMO BFT or not.
<    * \return True if we are performing MIMO BFT, otherwise false.
---
>    * \param packet the packet being asked for TXVECTOR
>    * \param hdr the WifiMacHeader
>    * \return TXVECTOR for the given packet
669,670c845
<   bool Is_Performing_MIMO_BFT (void) const;
<   //// WIGIG ////
---
>   virtual WifiTxVector GetDataTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const;
671a847
> private:
673,676c849,850
<    * This function indicates whether Simulator::Now is in the CF period.
<    *
<    * \return true if Simulator::Now is in CF period,
<    *         false otherwise
---
>    * Cancel all scheduled events. Called before beginning a transmission
>    * or switching channel.
678c852
<   virtual bool IsCfPeriod (void) const;
---
>   void CancelAllEvents (void);
680c854
<    * This function decides if a CF frame can be transmitted in the current CFP.
---
>    * Return the total ACK size (including FCS trailer).
682,683c856
<    * \return true if a CF frame can be transmitted in the current CFP,
<    *         false otherwise
---
>    * \return the total ACK size
685,686c858
<   bool CanTransmitNextCfFrame (void) const;
< 
---
>   uint32_t GetAckSize (void) const;
688c860
<    * Returns the aggregator used to construct A-MSDU subframes.
---
>    * Return the total Block ACK size (including FCS trailer).
690c862,863
<    * \return the aggregator used to construct A-MSDU subframes.
---
>    * \param type the Block ACK type
>    * \return the total Block ACK size
692c865
<   Ptr<MsduAggregator> GetMsduAggregator (void) const;
---
>   uint32_t GetBlockAckSize (enum BlockAckType type) const;
694c867
<    * Returns the aggregator used to construct A-MPDU subframes.
---
>    * Return the total RTS size (including FCS trailer).
696c869
<    * \return the aggregator used to construct A-MPDU subframes.
---
>    * \return the total RTS size
698,699c871
<   Ptr<MpduAggregator> GetMpduAggregator (void) const;
< 
---
>   uint32_t GetRtsSize (void) const;
701c873
<    * Set the aggregator used to construct A-MSDU subframes.
---
>    * Return the total CTS size (including FCS trailer).
703c875
<    * \param aggr pointer to the MSDU aggregator.
---
>    * \return the total CTS size
705c877
<   void SetMsduAggregator (const Ptr<MsduAggregator> aggr);
---
>   uint32_t GetCtsSize (void) const;
707c879,880
<    * Set the aggregator used to construct A-MPDU subframes.
---
>    * Return the total size of the packet after WifiMacHeader and FCS trailer
>    * have been added.
709,723c882,884
<    * \param aggr pointer to the MPDU aggregator.
<    */
<   void SetMpduAggregator (const Ptr<MpduAggregator> aggr);
<   /**
<    * Calculate DMG/EDMG transaction time including RTS/CTS, PSDU transmission time, acknowledgemen
<    * , and interframe spacing.
<    * \param psdu Pointer to the PSDU to be transmitted.
<    * \return The total transaction time.
<    */
<   Time CalculateWiGigTransactionTime (Ptr<WifiPsdu> psdu);
< 
< private:
<   /**
<    * Cancel all scheduled events. Called before beginning a transmission
<    * or switching channel.
---
>    * \param packet the packet to be encapsulated with WifiMacHeader and FCS trailer
>    * \param hdr the WifiMacHeader
>    * \return the total packet size
725c886
<   void CancelAllEvents (void);
---
>   uint32_t GetSize (Ptr<const Packet> packet, const WifiMacHeader *hdr) const;
727c888
<    * Return the total CF-END size (including FCS trailer).
---
>    * Forward the packet down to WifiPhy for transmission. This is called for the entire A-MPDu when MPDU aggregation is used.
729c890,893
<    * \return the total CF-END size in bytes
---
>    * \param packet
>    * \param hdr
>    * \param txVector
>    * \param preamble
731c895,896
<   uint32_t GetCfEndSize (void) const;
---
>   void ForwardDown (Ptr<const Packet> packet, const WifiMacHeader *hdr,
>                     WifiTxVector txVector, WifiPreamble preamble);
733c898
<    * Forward a PSDU down to WifiPhy for transmission.
---
>    * Forward the MPDU down to WifiPhy for transmission. This is called for each MPDU when MPDU aggregation is used.
735,736c900,904
<    * \param psdu the PSDU
<    * \param txVector the transmit vector
---
>    * \param packet
>    * \param hdr
>    * \param txVector
>    * \param preamble
>    * \param mpdutype
738c906
<   void ForwardDown (Ptr<const WifiPsdu> psdu, WifiTxVector txVector);
---
>   void SendMpdu (Ptr<const Packet> packet, WifiTxVector txVector, WifiPreamble preamble, enum mpduType mpdutype);
744,757c912,914
<    * \param item the item being asked for RTS TXVECTOR
<    * \return TXVECTOR for the RTS of the given item
<    */
<   WifiTxVector GetRtsTxVector (Ptr<const WifiMacQueueItem> item) const;
<   //// WIGIG ////
<   /**
<    * Return the total DMG CTS size (including FCS trailer).
<    *
<    * \return the total DMG CTS size
<    */
<   static uint32_t GetDmgCtsSize (bool addControlTrailer = false);
<   /**
<    * Get DMG Control TxVector
<    * \return
---
>    * \param packet the packet being asked for RTS TXVECTOR
>    * \param hdr the WifiMacHeader
>    * \return TXVECTOR for the RTS of the given packet
759,760c916
<   WifiTxVector GetDmgControlTxVector (void) const;
<   //// WIGIG ////
---
>   WifiTxVector GetRtsTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const;
773c929
<    * Return a TXVECTOR for the Ack frame given the destination and the mode of the Data
---
>    * Return a TXVECTOR for the ACK frame given the destination and the mode of the DATA
778,780c934,936
<    * \param to the MAC address of the Ack receiver
<    * \param dataTxMode the mode of the Data used by the sender
<    * \return TXVECTOR for the Ack
---
>    * \param to the MAC address of the ACK receiver
>    * \param dataTxMode the mode of the DATA used by the sender
>    * \return TXVECTOR for the ACK
784c940
<    * Return a TXVECTOR for the BlockAck frame given the destination and the mode of the Data
---
>    * Return a TXVECTOR for the Block ACK frame given the destination and the mode of the DATA
789,791c945,947
<    * \param to the MAC address of the BlockAck receiver
<    * \param dataTxMode the mode of the Data used by the sender
<    * \return TXVECTOR for the BlockAck
---
>    * \param to the MAC address of the Block ACK receiver
>    * \param dataTxMode the mode of the DATA used by the sender
>    * \return TXVECTOR for the Block ACK
794a951,960
>    * Return a TXVECTOR for the CTS-to-self frame.
>    * The function consults WifiRemoteStationManager, which controls the rate
>    * to different destinations.
>    *
>    * \param packet the packet that requires CTS-to-self
>    * \param hdr the Wifi header of the packet
>    * \return TXVECTOR for the CTS-to-self operation
>    */
>   WifiTxVector GetCtsToSelfTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const;
>   /**
806c972
<    * Return a TXVECTOR for the BlockAck frame given the destination and the mode of the Data
---
>    * Return a TXVECTOR for the Block ACK frame given the destination and the mode of the DATA
811,813c977,979
<    * \param to the MAC address of the BlockAck receiver
<    * \param dataTxMode the mode of the Data used by the sender
<    * \return TXVECTOR for the BlockAck
---
>    * \param to the MAC address of the Block ACK receiver
>    * \param dataTxMode the mode of the DATA used by the sender
>    * \return TXVECTOR for the Block ACK
817,824d982
<    * Get control answer mode function.
<    *
<    * \param reqMode request mode
<    *
<    * \return control answer mode
<    */
<   WifiMode GetControlAnswerMode (WifiMode reqMode) const;
<   /**
827c985
<    * \param ctsTxVector the TXVECTOR used to transmit the CTS
---
>    * \param ctsTxVector
835,836c993,994
<    * \param to the receiver MAC address
<    * \param rtsTxVector the TXVECTOR used to transmit the RTS
---
>    * \param to
>    * \param rtsTxVector
839,840c997
<   Time GetCtsDuration (Mac48Address to, WifiTxVector rtsTxVector, bool addControlTrailer = false) const;
<   //// WIGIG ////
---
>   Time GetCtsDuration (Mac48Address to, WifiTxVector rtsTxVector) const;
842c999
<    * Return the time required to transmit the DMG CTS (including preamble and FCS).
---
>    * Return the time required to transmit the ACK (including preamble and FCS).
844c1001,1002
<    * \return the time required to transmit the DMG CTS (including preamble and FCS)
---
>    * \param ackTxVector
>    * \return the time required to transmit the ACK (including preamble and FCS)
846c1004
<   Time GetDmgCtsDuration (bool addControlTrailer = false) const;
---
>   Time GetAckDuration (WifiTxVector ackTxVector) const;
852c1010
<    * \param txVector
---
>    * \param dataTxVector
855,871d1012
<   Time GetDmgControlDuration (WifiTxVector txVector, uint32_t payloadSize) const;
<   //// WIGIG ////
<   /**
<    * Return the time required to transmit the Ack (including preamble and FCS).
<    *
<    * \param ackTxVector the TXVECTOR used to transmit the Ack
<    * \return the time required to transmit the Ack (including preamble and FCS)
<    */
<   Time GetAckDuration (WifiTxVector ackTxVector) const;
<   /**
<    * Return the time required to transmit the Ack to the specified address
<    * given the TXVECTOR of the Data (including preamble and FCS).
<    *
<    * \param to the receiver MAC address
<    * \param dataTxVector the TXVECTOR used to transmit the Data
<    * \return the time required to transmit the Ack (including preamble and FCS)
<    */
874c1015
<    * Return the time required to transmit the BlockAck to the specified address
---
>    * Return the time required to transmit the Block ACK to the specified address
877,888c1018,1021
<    * \param blockAckReqTxVector the TXVECTOR used to transmit the BAR
<    * \param type the BlockAck type
<    * \return the time required to transmit the BlockAck (including preamble and FCS)
<    */
<   Time GetBlockAckDuration (WifiTxVector blockAckReqTxVector, BlockAckType type) const;
<   /**
<    * Return the time required to transmit the BlockAckRequest to the specified address
<    * given the TXVECTOR (including preamble and FCS).
<    *
<    * \param blockAckReqTxVector the TX vector used to transmit the BAR
<    * \param type the BlockAckRequest type
<    * \return the time required to transmit the BlockAckRequest (including preamble and FCS)
---
>    * \param to
>    * \param dataTxVector
>    * \param type the Block ACK type
>    * \return the time required to transmit the Block ACK (including preamble and FCS)
890c1023
<   Time GetBlockAckRequestDuration (WifiTxVector blockAckReqTxVector, BlockAckType type) const;
---
>   Time GetBlockAckDuration (Mac48Address to, WifiTxVector blockAckReqTxVector, enum BlockAckType type) const;
892,893c1025
<    * Return the time required to transmit the response frames (Ack or BAR+BA
<    * following the policy configured in the transmit parameters).
---
>    * Check if the current packet should be sent with a RTS protection.
895,898c1027,1028
<    * \param params the transmission parameters
<    * \param dataTxVector the TX vector used to transmit the data frame
<    * \param receiver the station from which a response is expected
<    * \return the time required to transmit the response (Ack or BAR+BA)
---
>    * \return true if RTS protection should be used,
>    *         false otherwise
900,901c1030
<   Time GetResponseDuration (const MacLowTransmissionParameters& params,
<                             WifiTxVector dataTxVector, Mac48Address receiver) const;
---
>   bool NeedRts (void);
908c1037
<   bool NeedCtsToSelf (void) const;
---
>   bool NeedCtsToSelf (void);
909a1039
>   void NotifyNav (Ptr<const Packet> packet,const WifiMacHeader &hdr, WifiPreamble preamble);
911c1041
<    * Notify NAV function.
---
>    * Reset NAV with the given duration.
913,914c1043
<    * \param packet the packet
<    * \param hdr the header
---
>    * \param duration
916c1045
<   void NotifyNav (Ptr<const Packet> packet,const WifiMacHeader &hdr);
---
>   void DoNavResetNow (Time duration);
918c1047
<    * Reset NAV with the given duration.
---
>    * Start NAV with the given duration.
920c1049,1050
<    * \param duration the duration to set
---
>    * \param duration
>    * \return true if NAV is resetted
922c1052
<   void DoNavResetNow (Time duration);
---
>   bool DoNavStartNow (Time duration);
931c1061,1063
<    * Notify ChannelAccessManager that Ack timer should be started for the given duration.
---
>    * Notify DcfManager (via DcfListener) that
>    * ACK timer should be started for the given
>    * duration.
933c1065
<    * \param duration the duration of the timer
---
>    * \param duration
937c1069,1070
<    * Notify ChannelAccessManager that Ack timer should be reset.
---
>    * Notify DcfManager (via DcfListener) that
>    * ACK timer should be resetted.
939c1072
<   void NotifyAckTimeoutResetNow (void);
---
>   void NotifyAckTimeoutResetNow ();
941c1074,1076
<    * Notify ChannelAccessManager that CTS timer should be started for the given duration.
---
>    * Notify DcfManager (via DcfListener) that
>    * CTS timer should be started for the given
>    * duration.
943c1078
<    * \param duration the duration of the timer
---
>    * \param duration
947c1082,1090
<    * Notify ChannelAccessManager that CTS timer should be reset.
---
>    * Notify DcfManager (via DcfListener) that
>    * CTS timer should be resetted.
>    */
>   void NotifyCtsTimeoutResetNow ();
>   /**
>    * Reset NAV after CTS was missed when the NAV was
>    * setted with RTS.
>    *
>    * \param rtsEndRxTime
949c1092
<   void NotifyCtsTimeoutResetNow (void);
---
>   void NavCounterResetCtsMissed (Time rtsEndRxTime);
952c1095
<    * Event handler when normal Ack timeout occurs.
---
>    * Event handler when normal ACK timeout occurs.
956c1099,1111
<    * Event handler when BlockAck timeout occurs.
---
>    * Event handler when fast ACK timeout occurs (idle).
>    */
>   void FastAckTimeout (void);
>   /**
>    * Event handler when super fast ACK timeout occurs.
>    */
>   void SuperFastAckTimeout (void);
>   /**
>    * Event handler when fast ACK timeout occurs (busy).
>    */
>   void FastAckFailedTimeout (void);
>   /**
>    * Event handler when block ACK timeout occurs.
964,967d1118
<    * Event handler when CF-Poll timeout occurs.
<    */
<   void CfPollTimeout (void);
<   /**
974,983d1124
<    * \param source the transmitter of the RTS
<    * \param duration the NAV of the RTS
<    * \param rtsTxVector the TXVECTOR used to transmit the RTS
<    * \param rtsSnr the SNR of the RTS in linear scale
<    */
<   void SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr);
<   //// WIGIG ////
<   /**
<    * Send CTS after receiving RTS.
<    *
989,990c1130
<   void SendDmgCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr);
<   //// WIGIG ////
---
>   void SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr);
992c1132
<    * Send Ack after receiving Data.
---
>    * Send ACK after receiving DATA.
994,997c1134,1137
<    * \param source the transmitter of the Data
<    * \param duration the NAV of the Data
<    * \param dataTxMode the TXVECTOR used to transmit the Data
<    * \param dataSnr the SNR of the Data in linear scale
---
>    * \param source
>    * \param duration
>    * \param dataTxMode
>    * \param dataSnr
1001c1141
<    * Send Data after receiving CTS.
---
>    * Send DATA after receiving CTS.
1003c1143,1144
<    * \param duration the NAV of the CTS
---
>    * \param source
>    * \param duration
1005c1146
<   void SendDataAfterCts (Time duration);
---
>   void SendDataAfterCts (Mac48Address source, Time duration);
1011,1016c1152,1153
<   void WaitIfsAfterEndTxFragment (void);
<   /**
<    * Event handler that is usually scheduled to fired at the appropriate time
<    * after sending a packet.
<    */
<   void WaitIfsAfterEndTxPacket (void);
---
>   void WaitSifsAfterEndTxFragment (void);
>   void WaitSifsAfterEndTx (void);
1019c1156
<    * A transmission that does not require an Ack has completed.
---
>    * A transmission that does not require an ACK has completed.
1023c1160
<    * Send RTS to begin RTS-CTS-Data-Ack transaction.
---
>    * Send RTS to begin RTS-CTS-DATA-ACK transaction.
1027,1028c1164,1165
<    * Send Data packet, which can be Data-Ack or
<    * RTS-CTS-Data-Ack transaction.
---
>    * Send DATA packet, which can be DATA-ACK or
>    * RTS-CTS-DATA-ACK transaction.
1032,1033c1169,1170
<    * Start a Data timer by scheduling appropriate
<    * Ack timeout.
---
>    * Start a DATA timer by scheduling appropriate
>    * ACK timeout.
1035c1172
<    * \param dataTxVector the TXVECTOR used to transmit the Data
---
>    * \param dataTxVector
1039c1176
<   void DoDispose (void);
---
>   virtual void DoDispose (void);
1042,1043c1179,1187
<    * \param originator Address of peer participating in block ack mechanism.
<    * \param tid TID for which block ack was created.
---
>    * \param packet packet to check
>    * \param hdr 802.11 header for packet to check
>    *
>    * Returns Tid of different packet types
>    */
>   uint8_t GetTid (Ptr<const Packet> packet, const WifiMacHeader hdr) const;
>   /**
>    * \param originator Address of peer participating in Block Ack mechanism.
>    * \param tid TID for which Block Ack was created.
1047c1191
<    * smaller than <i>seq</i>. All comparison are performed circularly modulo 4096.
---
>    * smaller than <i>seq</i>. All comparison are performed circularly mod 4096.
1051,1052c1195,1196
<    * \param originator Address of peer participating in block ack mechanism.
<    * \param tid TID for which block ack was created.
---
>    * \param originator Address of peer participating in Block Ack mechanism.
>    * \param tid TID for which Block Ack was created.
1064,1066c1208,1214
<    * \param mpdu the MPDU
<    * \returns true if MPDU received
<    *
---
>    * \param seq MPDU sequence number
>    * \param winstart sequence number window start
>    * \param winsize the size of the sequence number window (currently default is 64)
>    * This method checks if the MPDU's sequence number is inside the scoreboard boundaries or not
>    */
>   bool IsInWindow (uint16_t seq, uint16_t winstart, uint16_t winsize);
>   /**
1068,1069c1216,1217
<    * and stores the MPDU if needed when an MPDU is received in an non-HT Station (implements HT
<    * immediate BlockAck)
---
>    * and sotres the MPDU if needed when an MPDU is received in an non-HT Station (implements HT
>    * immediate block Ack)
1071c1219
<   bool ReceiveMpdu (Ptr<WifiMacQueueItem> mpdu);
---
>   bool ReceiveMpdu (Ptr<Packet> packet, WifiMacHeader hdr);
1073,1075d1220
<    * \param mpdu the MPDU
<    * \returns true if the MPDU stored
<    *
1081c1226
<   bool StoreMpduIfNeeded (Ptr<WifiMacQueueItem> mpdu);
---
>   bool StoreMpduIfNeeded (Ptr<Packet> packet, WifiMacHeader hdr);
1083,1084c1228,1229
<    * Invoked after that a BlockAckRequest has been received. Looks for corresponding
<    * block ack agreement and creates a block ack bitmap on a received packets basis.
---
>    * Invoked after that a block ack request has been received. Looks for corresponding
>    * block ack agreement and creates block ack bitmap on a received packets basis.
1086,1090c1231,1235
<    * \param reqHdr the BAR header
<    * \param originator the transmitter of the BAR
<    * \param duration the NAV of the BAR
<    * \param blockAckReqTxMode the TXVECTOR used to transmit the BAR
<    * \param rxSnr the SNR of the BAR in linear scale
---
>    * \param reqHdr
>    * \param originator
>    * \param duration
>    * \param blockAckReqTxMode
>    * \param rxSnr
1096c1241,1246
<    * block ack agreement and creates a block ack bitmap on a received packets basis.
---
>    * block ack agreement and creates block ack bitmap on a received packets basis.
>    */
>   void SendBlockAckAfterAmpdu (uint8_t tid, Mac48Address originator,
>                                Time duration, WifiTxVector blockAckReqTxVector, double rxSnr);
>   /**
>    * This method creates block ack frame with header equals to <i>blockAck</i> and start its transmission.
1098,1114c1248,1253
<    * \param tid the Traffic ID
<    * \param originator the originator MAC address
<    * \param duration the remaining NAV duration
<    * \param blockAckReqTxVector the transmit vector
<    * \param rxSnr the receive SNR in linear scale
<    */
<   void SendBlockAckAfterAmpdu (uint8_t tid, Mac48Address originator, Time duration,
<                                WifiTxVector blockAckReqTxVector, double rxSnr);
<   /**
<    * This method creates BlockAck frame with header equals to <i>blockAck</i> and start its transmission.
<    *
<    * \param blockAck the BA response header to send
<    * \param originator the station to send a BA to
<    * \param immediate use immediate BA policy if true
<    * \param duration the NAV duration
<    * \param blockAckReqTxMode the TXVECTOR used to transmit the BAR
<    * \param rxSnr the received SNR in linear scale
---
>    * \param blockAck
>    * \param originator
>    * \param immediate
>    * \param duration
>    * \param blockAckReqTxMode
>    * \param rxSnr
1119c1258
<    * Every time that a BlockAckRequest or a packet with Ack Policy equals to <i>Block Ack</i>
---
>    * Every time that a block ack request or a packet with ack policy equals to <i>block ack</i>
1124c1263
<    * \param agreement the BA agreement
---
>    * \param agreement
1133c1272
<   void SetupPhyMacLowListener (const Ptr<WifiPhy> phy);
---
>   void SetupPhyMacLowListener (Ptr<WifiPhy> phy);
1139a1279,1303
>   /**
>    * Checks if the given packet will be aggregated to an A-MPDU or not
>    *
>    * \param packet packet to check whether it can be aggregated in an A-MPDU
>    * \param hdr 802.11 header for packet to check whether it can be aggregated in an A-MPDU
>    *
>    */
>   bool IsAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr);
>   /**
>    * Insert in a temporary queue.
>    * It is only used with a RTS/CTS exchange for an A-MPDU transmission.
>    */
>   void InsertInTxQueue (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp);
>   /**
>    * Perform MSDU aggregation for a given MPDU in an A-MPDU
>    *
>    * \param packet packet picked for aggregation
>    * \param hdr 802.11 header for packet picked for aggregation
>    * \param tstamp timestamp
>    * \param currentAmpduPacket current A-MPDU packet
>    * \param blockAckSize size of the piggybacked block ack request
>    *
>    * \return the aggregate if MSDU aggregation succeeded, 0 otherwise
>    */
>   Ptr<Packet> PerformMsduAggregation (Ptr<const Packet> packet, WifiMacHeader *hdr, Time *tstamp, Ptr<Packet> currentAmpduPacket, uint16_t blockAckSize);
1142d1305
<   Ptr<WifiMac> m_mac; //!< Pointer to WifiMac (to fetch configuration)
1147c1310
<    * A struct that holds information about Ack piggybacking (CF-Ack).
---
>    * A struct for packet, Wifi header, and timestamp.
1149c1312
<   struct CfAckInfo
---
>   typedef struct
1151,1154c1314,1317
<     bool appendCfAck;     //!< Flag used for PCF to indicate whether a CF-Ack should be appended
<     bool expectCfAck;     //!< Flag used for PCF to indicate whether a CF-Ack should be expected
<     Mac48Address address; //!< Address of the station to be acknowledged
<   };
---
>     Ptr<const Packet> packet;
>     WifiMacHeader hdr;
>     Time timestamp;
>   } Item;
1157c1320
<    * typedef for an iterator for a list of ChannelAccessManager.
---
>    * typedef for an iterator for a list of MacLowDcfListener.
1159c1322
<   typedef std::vector<Ptr<ChannelAccessManager> >::const_iterator ChannelAccessManagersCI;
---
>   typedef std::vector<MacLowDcfListener *>::const_iterator DcfListenersCI;
1161c1324
<    * typedef for a list of ChannelAccessManager.
---
>    * typedef for a list of MacLowDcfListener.
1163,1164c1326,1327
<   typedef std::vector<Ptr<ChannelAccessManager> > ChannelAccessManagers;
<   ChannelAccessManagers m_channelAccessManagers; //!< List of ChannelAccessManager
---
>   typedef std::vector<MacLowDcfListener *> DcfListeners;
>   DcfListeners m_dcfListeners; //!< List of MacLowDcfListener (pass events to Dcf)
1166,1170c1329,1333
<   Ptr<MsduAggregator> m_msduAggregator;             //!< A-MSDU aggregator
<   Ptr<MpduAggregator> m_mpduAggregator;             //!< A-MPDU aggregator
< 
<   EventId m_normalAckTimeoutEvent;      //!< Normal Ack timeout event
<   EventId m_blockAckTimeoutEvent;       //!< BlockAck timeout event
---
>   EventId m_normalAckTimeoutEvent;      //!< Normal ACK timeout event
>   EventId m_fastAckTimeoutEvent;        //!< Fast ACK timeout event
>   EventId m_superFastAckTimeoutEvent;   //!< Super fast ACK timeout event
>   EventId m_fastAckFailedTimeoutEvent;  //!< Fast ACK failed timeout event
>   EventId m_blockAckTimeoutEvent;       //!< Block ACK timeout event
1173,1176c1336,1339
<   EventId m_sendAckEvent;               //!< Event to send Ack
<   EventId m_sendDataEvent;              //!< Event to send Data
<   EventId m_waitIfsEvent;               //!< Wait for IFS event
<   EventId m_endTxNoAckEvent;            //!< Event for finishing transmission that does not require Ack
---
>   EventId m_sendAckEvent;               //!< Event to send ACK
>   EventId m_sendDataEvent;              //!< Event to send DATA
>   EventId m_waitSifsEvent;              //!< Wait for SIFS event
>   EventId m_endTxNoAckEvent;            //!< Event for finishing transmission that does not require ACK
1177a1341
>   EventId m_waitRifsEvent;              //!< Wait for RIFS event
1179,1180c1343,1345
<   Ptr<WifiPsdu> m_currentPacket;            //!< Current packet transmitted/to be transmitted
<   Ptr<Txop> m_currentTxop;                  //!< Current TXOP
---
>   Ptr<Packet> m_currentPacket;              //!< Current packet transmitted/to be transmitted
>   WifiMacHeader m_currentHdr;               //!< Header of the current transmitted packet
>   WifiMacHeader m_lastReceivedHdr;          //!< Header of the last received packet
1181a1347
>   MacLowTransmissionListener *m_listener;   //!< Transmission listener for the current packet
1184,1186c1350,1353
<   Time m_ackTimeout;                        //!< Ack timeout duration
<   Time m_basicBlockAckTimeout;              //!< Basic BlockAck timeout duration
<   Time m_compressedBlockAckTimeout;         //!< Compressed BlockAck timeout duration
---
>   Time m_ackTimeout;                        //!< ACK timeout duration
>   Time m_basicBlockAckTimeout;              //!< Basic block ACK timeout duration
>   Time m_compressedBlockAckTimeout;         //!< Compressed block ACK timeout duration
>   Time m_ctsTimeout;                        //!< CTS timeout duration
1192,1200d1358
<   //// WIGIG ////
<   Time m_sbifs;                             //!< Short Beamforming Interframe Space (SBIFS) duration.
<   Time m_mbifs;                             //!< Medium Beamforming Interframe Space (MBIS) duration.
<   Time m_lbifs;                             //!< Long Beamforming Interframe Space (LBIFS) duration.
<   Time m_brifs;                             //!< Beam Refinement Protocol Interframe Spacing (BRIFS) duration.
<   //// WIGIG ////
<   Time m_beaconInterval;   //!< Expected interval between two beacon transmissions
<   Time m_cfpMaxDuration;   //!< CFP max duration
< 
1204,1207d1361
<   Time m_cfpStart;          //!< The time when the latest CF period started
<   Time m_lastBeacon;        //!< The time when the last beacon frame transmission started
<   Time m_cfpForeshortening; //!< The delay the current CF period should be foreshortened
< 
1208a1363
>   bool m_ampdu;    //!< Flag if the current transmission involves an A-MPDU
1215c1370,1371
<   typedef std::list<Ptr<WifiMacQueueItem>>::iterator BufferedPacketI; //!< buffered packet iterator typedef
---
>   typedef std::pair<Ptr<Packet>, WifiMacHeader> BufferedPacket;
>   typedef std::list<BufferedPacket>::iterator BufferedPacketI;
1217,1218c1373,1374
<   typedef std::pair<Mac48Address, uint8_t> AgreementKey; //!< agreement key typedef
<   typedef std::pair<BlockAckAgreement, std::list<Ptr<WifiMacQueueItem>> > AgreementValue; //!< agreement value typedef
---
>   typedef std::pair<Mac48Address, uint8_t> AgreementKey;
>   typedef std::pair<BlockAckAgreement, std::list<BufferedPacket> > AgreementValue;
1220,1221c1376,1377
<   typedef std::map<AgreementKey, AgreementValue> Agreements; //!< agreements
<   typedef std::map<AgreementKey, AgreementValue>::iterator AgreementsI; //!< agreements iterator
---
>   typedef std::map<AgreementKey, AgreementValue> Agreements;
>   typedef std::map<AgreementKey, AgreementValue>::iterator AgreementsI;
1223,1260c1379,1392
<   typedef std::map<AgreementKey, BlockAckCache> BlockAckCaches; //!< block ack caches typedef
<   typedef std::map<AgreementKey, BlockAckCache>::iterator BlockAckCachesI; //!< block ack caches iterator typedef
< 
<   Agreements m_bAckAgreements; //!< block ack agreements
<   BlockAckCaches m_bAckCaches; //!< block ack caches
< 
<   typedef std::map<AcIndex, Ptr<QosTxop> > QueueEdcas; //!< EDCA queues typedef
<   QueueEdcas m_edca; //!< EDCA queues
< 
<   bool m_ctsToSelfSupported;             //!< Flag whether CTS-to-self is supported
<   WifiTxVector m_currentTxVector;        //!< TXVECTOR used for the current packet transmission
< 
<   CfAckInfo m_cfAckInfo; //!< Info about piggyback Acks used in PCF
< 
<   //// WIGIG ////
<   TransmissionOkCallback m_transmissionCallback;
<   TransmissionShortSswOkCallback m_transmissionShortSswCallback;
< 
< 
<   /* Variables for suspended data transmission for different allocation periods */
<   struct AllocationParameters : public SimpleRefCount<AllocationParameters> {
<     MacLowTransmissionParameters txParams;      //!< Suspended transmission MacLow parameters.
<     WifiTxVector txVector;                      //!< TxVector associated with the suspended transmission.
<     Ptr<Txop> txop;                             //!< Transmit opportunity responsbile for this suspended transmission.
<     Ptr<WifiPsdu> psdu;                         //!< PSDU to to be transmitted.
<   };
< 
<   typedef std::map<AllocationID, Ptr<AllocationParameters> > AllocationPeriodsTable;
<   typedef AllocationPeriodsTable::const_iterator AllocationPeriodsTableCI;
<   typedef AllocationPeriodsTable::iterator AllocationPeriodsTableI;
<   AllocationPeriodsTable m_allocationPeriodsTable;  //!< Table to store allocation periods (CBAP/SP) related transmission parameters.
<   AllocationID m_currentAllocationID;               //!< The ID of the current allocation served by the High MAC.
<   Ptr<AllocationParameters> m_currentAllocation;    //!< Current allocation parameters.
<   bool m_transmissionSuspended;                     //!< Flag to indicate that we have suspended transmission for the current allocation.
<   bool m_restoredSuspendedTransmission;             //!< Flag to indicate that we have more time to transmit more packets.
<   bool m_servingSLS;                                //!< Flag to indicate that we are performing BFT.
<   bool m_servingMimoBFT;                            //!< Flag to indicate that we are performing MIMO BFT.
<   //// WIGIG ////
---
>   typedef std::map<AgreementKey, BlockAckCache> BlockAckCaches;
>   typedef std::map<AgreementKey, BlockAckCache>::iterator BlockAckCachesI;
> 
>   Agreements m_bAckAgreements;
>   BlockAckCaches m_bAckCaches;
> 
>   typedef std::map<AcIndex, MacLowAggregationCapableTransmissionListener*> QueueListeners;
>   QueueListeners m_edcaListeners;
>   bool m_ctsToSelfSupported;          //!< Flag whether CTS-to-self is supported
>   uint8_t m_sentMpdus;                //!< Number of transmitted MPDUs in an A-MPDU that have not been acknowledged yet
>   Ptr<WifiMacQueue> m_aggregateQueue; //!< Queue used for MPDU aggregation
>   WifiTxVector m_currentTxVector;     //!< TXVECTOR used for the current packet transmission
>   std::vector<Item> m_txPackets;      //!< Contain temporary items to be sent with the next A-MPDU transmission, once RTS/CTS exchange has succeeded. It is not used in other cases.
>   uint32_t m_nTxMpdus;                //!<Holds the number of transmitted MPDUs in the last A-MPDU transmission
Only in ../../NS3-WiGig/src/wifi/model: mac-low-transmission-parameters.cc
Only in ../../NS3-WiGig/src/wifi/model: mac-low-transmission-parameters.h
diff ../../NS3-WiGig/src/wifi/model/mac-rx-middle.cc ../../ns-3-dev/src/wifi/model/mac-rx-middle.cc
20a21,23
> #include "mac-rx-middle.h"
> #include "wifi-mac-header.h"
> #include "ns3/assert.h"
22d24
< #include "ns3/sequence-number.h"
24,25c26,28
< #include "mac-rx-middle.h"
< #include "wifi-mac-queue-item.h"
---
> #include "ns3/simulator.h"
> #include "ns3/sequence-number.h"
> #include <list>
47,49c50,52
<   bool m_defragmenting; ///< flag to indicate whether we are defragmenting
<   uint16_t m_lastSequenceControl; ///< last sequence control
<   Fragments m_fragments; ///< fragments
---
>   bool m_defragmenting;
>   uint16_t m_lastSequenceControl;
>   Fragments m_fragments;
69c72
<   bool IsDeFragmenting (void) const
---
>   bool IsDeFragmenting (void)
128c131
<   bool IsNextFragment (uint16_t sequenceControl) const
---
>   bool IsNextFragment (uint16_t sequenceControl)
145c148
<   uint16_t GetLastSequenceControl (void) const
---
>   uint16_t GetLastSequenceControl (void)
201c204
<       /* only for QoS data non-broadcast frames */
---
>       /* only for qos data non-broadcast frames */
212,213c215,216
<        * - QoS data broadcast frames
<        * - non-QoS data frames
---
>        * - qos data broadcast frames
>        * - nqos data frames
251c254
<                             ", frag=" << +hdr->GetFragmentNumber () <<
---
>                             ", frag=" << hdr->GetFragmentNumber () <<
267c270
<                             ", frag=" << +hdr->GetFragmentNumber () <<
---
>                             ", frag=" << hdr->GetFragmentNumber () <<
285c288
<                         ", frag=" << +hdr->GetFragmentNumber () <<
---
>                         ", frag=" << hdr->GetFragmentNumber () <<
299c302
< MacRxMiddle::Receive (Ptr<WifiMacQueueItem> mpdu)
---
> MacRxMiddle::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
301,310c304
<   NS_LOG_FUNCTION (*mpdu);
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
<   Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
<   //// WIGIG ////
<   if (hdr->IsSSW () || hdr->IsSSW_FBCK () || hdr->IsSSW_ACK ()  || hdr->IsDMGBeacon ())
<     {
<       m_callback (Create<WifiMacQueueItem> (packet, *hdr));
<       return;
<     }
<   //// WIGIG ////
---
>   NS_LOG_FUNCTION (packet << hdr);
312,315d305
<   if (!m_pcfCallback.IsNull ())
<     {
<       m_pcfCallback ();
<     }
318c308
<    * The check below is really unneeded because it can fail in a lot of
---
>    * The check below is really uneeded because it can fail in a lot of
336c326
<                     ", frag=" << +hdr->GetFragmentNumber ());
---
>                     ", frag=" << hdr->GetFragmentNumber ());
339,340c329,330
<   Ptr<Packet> aggregate = HandleFragments (packet, hdr, originator);
<   if (aggregate == 0)
---
>   Ptr<Packet> agregate = HandleFragments (packet, hdr, originator);
>   if (agregate == 0)
346c336
<                 ", frag=" << +hdr->GetFragmentNumber ());
---
>                 ", frag=" << hdr->GetFragmentNumber ());
351,368c341
<   if (aggregate == packet)
<     {
<       m_callback (mpdu);
<     }
<   else
<     {
<       // We could do this in all cases, but passing the received mpdu in case of
<       // A-MSDUs saves us the time to deaggregate the A-MSDU in MSDUs (which are
<       // kept separate in the received mpdu) and allows us to pass the originally
<       // transmitted packets (i.e., with the same UID) to the receiver.
<       m_callback (Create<WifiMacQueueItem> (aggregate, *hdr));
<     }
< }
< 
< void
< MacRxMiddle::SetPcfCallback (Callback<void> callback)
< {
<   m_pcfCallback = callback;
---
>   m_callback (agregate, hdr);
diff ../../NS3-WiGig/src/wifi/model/mac-rx-middle.h ../../ns-3-dev/src/wifi/model/mac-rx-middle.h
25c25
< #include "ns3/simple-ref-count.h"
---
> #include <utility>
26a27,28
> #include "ns3/mac48-address.h"
> #include "ns3/packet.h"
32,34d33
< class Packet;
< class Mac48Address;
< class WifiMacQueueItem;
41c40
< class MacRxMiddle : public SimpleRefCount<MacRxMiddle>
---
> class MacRxMiddle
47c46
<   typedef Callback<void, Ptr<WifiMacQueueItem>> ForwardUpCallback;
---
>   typedef Callback<void, Ptr<Packet>, const WifiMacHeader*> ForwardUpCallback;
55c54
<    * \param callback the callback to set
---
>    * \param callback
59,71c58
<   /**
<    * Set a callback to trigger the next PCF frame.
<    *
<    * \param callback the callback to set
<    */
<   void SetPcfCallback (Callback<void> callback);
< 
<   /**
<    * Receive a packet.
<    *
<    * \param mpdu the MPDU
<    */
<   void Receive (Ptr<WifiMacQueueItem> mpdu);
---
>   void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
75d61
<   /// allow MacRxMiddleTest associated class access
82c68
<    * \param hdr the MAC header
---
>    * \param hdr
91,92c77,78
<    * \param hdr the MAC header
<    * \param originator the packet originator status
---
>    * \param hdr
>    * \param originator
106,108c92,94
<    * \param packet the packet
<    * \param hdr the MAC header
<    * \param originator the packet originator status
---
>    * \param packet
>    * \param hdr
>    * \param originator
125c111
<    * typedef for an iterator for Originators
---
>    * typedef for an interator for Originators
129c115
<    * typedef for an iterator for QosOriginators
---
>    * typedef for an interator for QosOriginators
133,137c119,121
<   Originators m_originatorStatus; ///< originator status
<   QosOriginators m_qosOriginatorStatus; ///< QOS originator status
<   ForwardUpCallback m_callback; ///< forward up callback
< 
<   Callback<void> m_pcfCallback; //!< PCF callback
---
>   Originators m_originatorStatus;
>   QosOriginators m_qosOriginatorStatus;
>   ForwardUpCallback m_callback;
diff ../../NS3-WiGig/src/wifi/model/mac-tx-middle.cc ../../ns-3-dev/src/wifi/model/mac-tx-middle.cc
24c24
< #include "ns3/log.h"
---
> #include "ns3/assert.h"
30,31d29
< NS_LOG_COMPONENT_DEFINE ("MacTxMiddle");
< 
35d32
<   NS_LOG_FUNCTION (this);
40,41c37
<   NS_LOG_FUNCTION (this);
<   for (std::map<Mac48Address,uint16_t*>::const_iterator i = m_qosSequences.begin (); i != m_qosSequences.end (); i++)
---
>   for (std::map<Mac48Address,uint16_t*>::iterator i = m_qosSequences.begin (); i != m_qosSequences.end (); i++)
48c44
< MacTxMiddle::GetNextSequenceNumberFor (const WifiMacHeader *hdr)
---
> MacTxMiddle::GetNextSequenceNumberfor (const WifiMacHeader *hdr)
50d45
<   NS_LOG_FUNCTION (this);
57c52
<       std::map<Mac48Address, uint16_t*>::const_iterator it = m_qosSequences.find (hdr->GetAddr1 ());
---
>       std::map<Mac48Address, uint16_t*>::iterator it = m_qosSequences.find (hdr->GetAddr1 ());
68c63
<           std::pair <std::map<Mac48Address,uint16_t*>::const_iterator,bool> newIns = m_qosSequences.insert (newSeq);
---
>           std::pair <std::map<Mac48Address,uint16_t*>::iterator,bool> newIns = m_qosSequences.insert (newSeq);
87c82
< MacTxMiddle::PeekNextSequenceNumberFor (const WifiMacHeader *hdr)
---
> MacTxMiddle::PeekNextSequenceNumberfor (const WifiMacHeader *hdr)
89d83
<   NS_LOG_FUNCTION (this);
96c90
<       std::map<Mac48Address, uint16_t*>::const_iterator it = m_qosSequences.find (hdr->GetAddr1 ());
---
>       std::map<Mac48Address, uint16_t*>::iterator it = m_qosSequences.find (hdr->GetAddr1 ());
116d109
<   NS_LOG_FUNCTION (this);
diff ../../NS3-WiGig/src/wifi/model/mac-tx-middle.h ../../ns-3-dev/src/wifi/model/mac-tx-middle.h
19,20c19,20
<  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
<  *          Mirko Banchi <mk.banchi@gmail.com>
---
>  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
>  *         Mirko Banchi <mk.banchi@gmail.com>
25a26
> #include <stdint.h>
27c28
< #include "ns3/simple-ref-count.h"
---
> #include "ns3/mac48-address.h"
32d32
< class Mac48Address;
39c39
< class MacTxMiddle : public SimpleRefCount<MacTxMiddle>
---
> class MacTxMiddle
51c51
<   uint16_t GetNextSequenceNumberFor (const WifiMacHeader *hdr);
---
>   uint16_t GetNextSequenceNumberfor (const WifiMacHeader *hdr);
59c59
<   uint16_t PeekNextSequenceNumberFor (const WifiMacHeader *hdr);
---
>   uint16_t PeekNextSequenceNumberfor (const WifiMacHeader *hdr);
71,72c71,72
<   std::map <Mac48Address,uint16_t*> m_qosSequences; ///< QOS sequences
<   uint16_t m_sequence; ///< current sequence number
---
>   std::map <Mac48Address,uint16_t*> m_qosSequences;
>   uint16_t m_sequence;
diff ../../NS3-WiGig/src/wifi/model/mgt-headers.cc ../../ns-3-dev/src/wifi/model/mgt-headers.cc
5d4
<  * Copyright (c) 2015-2020 IMDEA Networks Institute
22d20
<  *          Hany Assasa <hany.assasa@gmail.com>
25,29c23
< #include "ns3/address-utils.h"
< #include "ns3/assert.h"
< #include "ns3/simulator.h"
< 
< #include "ext-headers.h"
---
> #include <sstream>
31c25,26
< #include "wifi-information-element.h"
---
> #include "ns3/simulator.h"
> #include "ns3/assert.h"
62a58,81
> void
> MgtProbeRequestHeader::SetHtCapabilities (HtCapabilities htcapabilities)
> {
>   m_htCapability = htcapabilities;
> }
> 
> HtCapabilities
> MgtProbeRequestHeader::GetHtCapabilities (void) const
> {
>   return m_htCapability;
> }
> 
> void
> MgtProbeRequestHeader::SetVhtCapabilities (VhtCapabilities vhtcapabilities)
> {
>   m_vhtCapability = vhtcapabilities;
> }
> 
> VhtCapabilities
> MgtProbeRequestHeader::GetVhtCapabilities (void) const
> {
>   return m_vhtCapability;
> }
> 
76c95,96
<   size += GetInformationElementsSerializedSize ();
---
>   size += m_htCapability.GetSerializedSize ();
>   size += m_vhtCapability.GetSerializedSize ();
100,102c120,123
<   os << "ssid=" << m_ssid
<      << "rates=" << m_rates;
<   PrintInformationElements (os);
---
>   os << "ssid=" << m_ssid << ", "
>      << "rates=" << m_rates << ", "
>      << "HT Capabilities=" << m_htCapability << " , "
>      << "VHT Capabilities= " << m_vhtCapability;
112c133,134
<   i = SerializeInformationElements (i);
---
>   i = m_htCapability.Serialize (i);
>   i = m_vhtCapability.Serialize (i);
122c144,145
<   i = DeserializeInformationElements (i);
---
>   i = m_htCapability.DeserializeIfPresent (i);
>   i = m_vhtCapability.DeserializeIfPresent (i);
128c151
<  *                    Probe Response
---
>  *          Probe Response
158a182,187
> SupportedRates
> MgtProbeResponseHeader::GetSupportedRates (void) const
> {
>   return m_rates;
> }
> 
160c189
< MgtProbeResponseHeader::SetSupportedRates (SupportedRates rates)
---
> MgtProbeResponseHeader::SetCapabilities (CapabilityInformation capabilities)
162c191
<   m_rates = rates;
---
>   m_capability = capabilities;
165,166c194,195
< SupportedRates
< MgtProbeResponseHeader::GetSupportedRates (void) const
---
> CapabilityInformation
> MgtProbeResponseHeader::GetCapabilities (void) const
168c197,233
<   return m_rates;
---
>   return m_capability;
> }
> 
> void
> MgtProbeResponseHeader::SetHtCapabilities (HtCapabilities htcapabilities)
> {
>   m_htCapability = htcapabilities;
> }
> 
> HtCapabilities
> MgtProbeResponseHeader::GetHtCapabilities (void) const
> {
>   return m_htCapability;
> }
> 
> void
> MgtProbeResponseHeader::SetHtOperations (HtOperations htoperations)
> {
>   m_htOperations = htoperations;
> }
> 
> HtOperations
> MgtProbeResponseHeader::GetHtOperations (void) const
> {
>   return m_htOperations;
> }
> 
> void
> MgtProbeResponseHeader::SetVhtCapabilities (VhtCapabilities vhtcapabilities)
> {
>   m_vhtCapability = vhtcapabilities;
> }
> 
> VhtCapabilities
> MgtProbeResponseHeader::GetVhtCapabilities (void) const
> {
>   return m_vhtCapability;
184c249
< MgtProbeResponseHeader::SetCapabilities (CapabilityInformation capabilities)
---
> MgtProbeResponseHeader::SetSupportedRates (SupportedRates rates)
186c251
<   m_capability = capabilities;
---
>   m_rates = rates;
189,190c254,255
< CapabilityInformation
< MgtProbeResponseHeader::GetCapabilities (void) const
---
> void
> MgtProbeResponseHeader::SetDsssParameterSet (DsssParameterSet dsssParameterSet)
192c257,287
<   return m_capability;
---
>   m_dsssParameterSet = dsssParameterSet;
> }
> 
> DsssParameterSet
> MgtProbeResponseHeader::GetDsssParameterSet (void) const
> {
>   return m_dsssParameterSet;
> }
> 
> void
> MgtProbeResponseHeader::SetErpInformation (ErpInformation erpInformation)
> {
>   m_erpInformation = erpInformation;
> }
> 
> ErpInformation
> MgtProbeResponseHeader::GetErpInformation (void) const
> {
>   return m_erpInformation;
> }
> 
> void
> MgtProbeResponseHeader::SetEdcaParameterSet (EdcaParameterSet edcaparameters)
> {
>   m_edcaParameterSet = edcaparameters;
> }
> 
> EdcaParameterSet
> MgtProbeResponseHeader::GetEdcaParameterSet (void) const
> {
>   return m_edcaParameterSet;
220a316,317
>   size += m_dsssParameterSet.GetSerializedSize ();
>   size += m_erpInformation.GetSerializedSize ();
222c319,322
<   size += GetInformationElementsSerializedSize ();
---
>   size += m_edcaParameterSet.GetSerializedSize ();
>   size += m_htCapability.GetSerializedSize ();
>   size += m_htOperations.GetSerializedSize ();
>   size += m_vhtCapability.GetSerializedSize ();
229,233c329,335
<   os << "Timestamp=" << m_timestamp << "," <<
<         "BeaconInterval=" << m_beaconInterval  << "," <<
<         "rates=" << m_rates << ", "
<         "ssid=" << m_ssid;
<   PrintInformationElements (os);
---
>   os << "ssid=" << m_ssid << ", "
>      << "rates=" << m_rates << ", "
>      << "DSSS Parameter Set=" << m_dsssParameterSet << " , "
>      << "ERP information=" << m_erpInformation << ", "
>      << "HT Capabilities=" << m_htCapability << " , "
>      << "HT Operations=" << m_htOperations << " , "
>      << "VHT Capabilities= " << m_vhtCapability;
242a345,349
>   //supported rates
>   //fh parameter set
>   //ds parameter set
>   //cf parameter set
>   //ibss parameter set
248a356,357
>   i = m_dsssParameterSet.Serialize (i);
>   i = m_erpInformation.Serialize (i);
250c359,362
<   i = SerializeInformationElements (i);
---
>   i = m_edcaParameterSet.Serialize (i);
>   i = m_htCapability.Serialize (i);
>   i = m_htOperations.Serialize (i);
>   i = m_vhtCapability.Serialize (i);
262a375,376
>   i = m_dsssParameterSet.DeserializeIfPresent (i);
>   i = m_erpInformation.DeserializeIfPresent (i);
264c378,381
<   i = DeserializeInformationElements (i);
---
>   i = m_edcaParameterSet.DeserializeIfPresent (i);
>   i = m_htCapability.DeserializeIfPresent (i);
>   i = m_htOperations.DeserializeIfPresent (i);
>   i = m_vhtCapability.DeserializeIfPresent (i);
304c421
< MgtAssocRequestHeader::SetCapabilities (CapabilityInformation capabilities)
---
> MgtAssocRequestHeader::SetSsid (Ssid ssid)
306c423
<   m_capability = capabilities;
---
>   m_ssid = ssid;
310c427
< MgtAssocRequestHeader::SetSsid (Ssid ssid)
---
> MgtAssocRequestHeader::SetSupportedRates (SupportedRates rates)
312c429
<   m_ssid = ssid;
---
>   m_rates = rates;
320a438,443
> void
> MgtAssocRequestHeader::SetCapabilities (CapabilityInformation capabilities)
> {
>   m_capability = capabilities;
> }
> 
327,328c450,451
< uint16_t
< MgtAssocRequestHeader::GetListenInterval (void) const
---
> void
> MgtAssocRequestHeader::SetHtCapabilities (HtCapabilities htcapabilities)
330c453
<   return m_listenInterval;
---
>   m_htCapability = htcapabilities;
333,334c456,457
< Ssid
< MgtAssocRequestHeader::GetSsid (void) const
---
> HtCapabilities
> MgtAssocRequestHeader::GetHtCapabilities (void) const
336c459
<   return m_ssid;
---
>   return m_htCapability;
340c463
< MgtAssocRequestHeader::SetSupportedRates (SupportedRates rates)
---
> MgtAssocRequestHeader::SetVhtCapabilities (VhtCapabilities vhtcapabilities)
342c465,477
<   m_rates = rates;
---
>   m_vhtCapability = vhtcapabilities;
> }
> 
> VhtCapabilities
> MgtAssocRequestHeader::GetVhtCapabilities (void) const
> {
>   return m_vhtCapability;
> }
> 
> Ssid
> MgtAssocRequestHeader::GetSsid (void) const
> {
>   return m_ssid;
350a486,491
> uint16_t
> MgtAssocRequestHeader::GetListenInterval (void) const
> {
>   return m_listenInterval;
> }
> 
377c518,519
<   size += GetInformationElementsSerializedSize ();
---
>   size += m_htCapability.GetSerializedSize ();
>   size += m_vhtCapability.GetSerializedSize ();
384,386c526,529
<   os << "ssid=" << m_ssid  << ", "
<      << "rates=" << m_rates;
<   PrintInformationElements (os);
---
>   os << "ssid=" << m_ssid << ", "
>      << "rates=" << m_rates << ", "
>      << "HT Capabilities=" << m_htCapability << " , "
>      << "VHT Capabilities= " << m_vhtCapability;
398c541,542
<   i = SerializeInformationElements (i);
---
>   i = m_htCapability.Serialize (i);
>   i = m_vhtCapability.Serialize (i);
410c554,555
<   i = DeserializeInformationElements (i);
---
>   i = m_htCapability.DeserializeIfPresent (i);
>   i = m_vhtCapability.DeserializeIfPresent (i);
416c561
<  *          Ressoc Request
---
>  *          Assoc Response
419,446c564
< NS_OBJECT_ENSURE_REGISTERED (MgtReassocRequestHeader);
< 
< MgtReassocRequestHeader::MgtReassocRequestHeader ()
<   : m_currentApAddr (Mac48Address ())
< {
< }
< 
< MgtReassocRequestHeader::~MgtReassocRequestHeader ()
< {
< }
< 
< void
< MgtReassocRequestHeader::SetSsid (Ssid ssid)
< {
<   m_ssid = ssid;
< }
< 
< void
< MgtReassocRequestHeader::SetSupportedRates (SupportedRates rates)
< {
<   m_rates = rates;
< }
< 
< void
< MgtReassocRequestHeader::SetListenInterval (uint16_t interval)
< {
<   m_listenInterval = interval;
< }
---
> NS_OBJECT_ENSURE_REGISTERED (MgtAssocResponseHeader);
448,449c566,567
< void
< MgtReassocRequestHeader::SetCapabilities (CapabilityInformation capabilities)
---
> MgtAssocResponseHeader::MgtAssocResponseHeader ()
>   : m_aid (0)
451d568
<   m_capability = capabilities;
454,455c571
< CapabilityInformation
< MgtReassocRequestHeader::GetCapabilities (void) const
---
> MgtAssocResponseHeader::~MgtAssocResponseHeader ()
457d572
<   return m_capability;
460,461c575,576
< Ssid
< MgtReassocRequestHeader::GetSsid (void) const
---
> StatusCode
> MgtAssocResponseHeader::GetStatusCode (void)
463c578
<   return m_ssid;
---
>   return m_code;
467c582
< MgtReassocRequestHeader::GetSupportedRates (void) const
---
> MgtAssocResponseHeader::GetSupportedRates (void)
472,477d586
< uint16_t
< MgtReassocRequestHeader::GetListenInterval (void) const
< {
<   return m_listenInterval;
< }
< 
479,502c588
< MgtReassocRequestHeader::SetCurrentApAddress (Mac48Address currentApAddr)
< {
<   m_currentApAddr = currentApAddr;
< }
< 
< TypeId
< MgtReassocRequestHeader::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::MgtReassocRequestHeader")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<MgtReassocRequestHeader> ()
<   ;
<   return tid;
< }
< 
< TypeId
< MgtReassocRequestHeader::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< uint32_t
< MgtReassocRequestHeader::GetSerializedSize (void) const
---
> MgtAssocResponseHeader::SetStatusCode (StatusCode code)
504,512c590
<   uint32_t size = 0;
<   size += m_capability.GetSerializedSize ();
<   size += 2; //listen interval
<   size += 6; //current AP address
<   size += m_ssid.GetSerializedSize ();
<   size += m_rates.GetSerializedSize ();
<   size += m_rates.extended.GetSerializedSize ();
<   size += GetInformationElementsSerializedSize ();
<   return size;
---
>   m_code = code;
516c594
< MgtReassocRequestHeader::Print (std::ostream &os) const
---
> MgtAssocResponseHeader::SetSupportedRates (SupportedRates rates)
518,521c596
<   os << "current AP address=" << m_currentApAddr << ", "
<      << "ssid=" << m_ssid << ", "
<      << "rates=" << m_rates;
<   PrintInformationElements (os);
---
>   m_rates = rates;
525c600
< MgtReassocRequestHeader::Serialize (Buffer::Iterator start) const
---
> MgtAssocResponseHeader::SetCapabilities (CapabilityInformation capabilities)
527,534c602
<   Buffer::Iterator i = start;
<   i = m_capability.Serialize (i);
<   i.WriteHtolsbU16 (m_listenInterval);
<   WriteTo (i, m_currentApAddr);
<   i = m_ssid.Serialize (i);
<   i = m_rates.Serialize (i);
<   i = m_rates.extended.Serialize (i);
<   i = SerializeInformationElements (i);
---
>   m_capability = capabilities;
537,538c605,606
< uint32_t
< MgtReassocRequestHeader::Deserialize (Buffer::Iterator start)
---
> CapabilityInformation
> MgtAssocResponseHeader::GetCapabilities (void) const
540,548c608
<   Buffer::Iterator i = start;
<   i = m_capability.Deserialize (i);
<   m_listenInterval = i.ReadLsbtohU16 ();
<   ReadFrom (i, m_currentApAddr);
<   i = m_ssid.Deserialize (i);
<   i = m_rates.Deserialize (i);
<   i = m_rates.extended.DeserializeIfPresent (i);
<   i = DeserializeInformationElements (i);
<   return i.GetDistanceFrom (start);
---
>   return m_capability;
551,559c611,612
< 
< /***********************************************************
<  *          Assoc/Reassoc Response
<  ***********************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (MgtAssocResponseHeader);
< 
< MgtAssocResponseHeader::MgtAssocResponseHeader ()
<   : m_aid (0)
---
> void
> MgtAssocResponseHeader::SetHtCapabilities (HtCapabilities htcapabilities)
560a614
>   m_htCapability = htcapabilities;
563c617,618
< MgtAssocResponseHeader::~MgtAssocResponseHeader ()
---
> HtCapabilities
> MgtAssocResponseHeader::GetHtCapabilities (void) const
564a620
>   return m_htCapability;
567,568c623,624
< StatusCode
< MgtAssocResponseHeader::GetStatusCode (void)
---
> void
> MgtAssocResponseHeader::SetHtOperations (HtOperations htoperations)
570c626
<   return m_code;
---
>   m_htOperations = htoperations;
573,574c629,630
< SupportedRates
< MgtAssocResponseHeader::GetSupportedRates (void)
---
> HtOperations
> MgtAssocResponseHeader::GetHtOperations (void) const
576c632
<   return m_rates;
---
>   return m_htOperations;
580c636
< MgtAssocResponseHeader::SetStatusCode (StatusCode code)
---
> MgtAssocResponseHeader::SetVhtCapabilities (VhtCapabilities vhtcapabilities)
582c638
<   m_code = code;
---
>   m_vhtCapability = vhtcapabilities;
585,586c641,642
< void
< MgtAssocResponseHeader::SetSupportedRates (SupportedRates rates)
---
> VhtCapabilities
> MgtAssocResponseHeader::GetVhtCapabilities (void) const
588c644
<   m_rates = rates;
---
>   return m_vhtCapability;
592c648
< MgtAssocResponseHeader::SetCapabilities (CapabilityInformation capabilities)
---
> MgtAssocResponseHeader::SetErpInformation (ErpInformation erpInformation)
594c650
<   m_capability = capabilities;
---
>   m_erpInformation = erpInformation;
597,598c653,654
< CapabilityInformation
< MgtAssocResponseHeader::GetCapabilities (void) const
---
> ErpInformation
> MgtAssocResponseHeader::GetErpInformation (void) const
600c656
<   return m_capability;
---
>   return m_erpInformation;
604c660
< MgtAssocResponseHeader::SetAssociationId (uint16_t aid)
---
> MgtAssocResponseHeader::SetEdcaParameterSet (EdcaParameterSet edcaparameters)
606c662
<   m_aid = aid;
---
>   m_edcaParameterSet = edcaparameters;
609,610c665,666
< uint16_t
< MgtAssocResponseHeader::GetAssociationId (void) const
---
> EdcaParameterSet
> MgtAssocResponseHeader::GetEdcaParameterSet (void) const
612c668
<   return m_aid;
---
>   return m_edcaParameterSet;
639a696
>   size += m_erpInformation.GetSerializedSize ();
641c698,701
<   size += GetInformationElementsSerializedSize ();
---
>   size += m_edcaParameterSet.GetSerializedSize ();
>   size += m_htCapability.GetSerializedSize ();
>   size += m_htOperations.GetSerializedSize ();
>   size += m_vhtCapability.GetSerializedSize ();
649,650c709,713
<      << "rates=" << m_rates;
<   PrintInformationElements (os);
---
>      << "rates=" << m_rates << ", "
>      << "ERP information=" << m_erpInformation << ", "
>      << "HT Capabilities=" << m_htCapability << " , "
>      << "HT Operations=" << m_htOperations << " , "
>      << "VHT Capabilities= " << m_vhtCapability;
660a724
>   i = m_erpInformation.Serialize (i);
662c726,729
<   i = SerializeInformationElements (i);
---
>   i = m_edcaParameterSet.Serialize (i);
>   i = m_htCapability.Serialize (i);
>   i = m_htOperations.Serialize (i);
>   i = m_vhtCapability.Serialize (i);
672a740
>   i = m_erpInformation.DeserializeIfPresent (i);
674c742,745
<   i = DeserializeInformationElements (i);
---
>   i = m_edcaParameterSet.DeserializeIfPresent (i);
>   i = m_htCapability.DeserializeIfPresent (i);
>   i = m_htOperations.DeserializeIfPresent (i);
>   i = m_vhtCapability.DeserializeIfPresent (i);
694c765
<   m_category = static_cast<uint8_t> (type);
---
>   m_category = type;
697,701d767
<     case QOS:
<       {
<         m_actionValue = static_cast<uint8_t> (action.qos);
<         break;
<       }
704,714c770
<         m_actionValue = static_cast<uint8_t> (action.blockAck);
<         break;
<       }
<     case PUBLIC:
<       {
<         m_actionValue = static_cast<uint8_t> (action.publicAction);
<         break;
<       }
<     case RADIO_MEASUREMENT:
<       {
<         m_actionValue = static_cast<uint8_t> (action.radioMeasurementAction);
---
>         m_actionValue = action.blockAck;
719c775
<         m_actionValue = static_cast<uint8_t> (action.meshAction);
---
>         m_actionValue = action.meshAction;
724c780
<         m_actionValue = static_cast<uint8_t> (action.multihopAction);
---
>         m_actionValue = action.multihopAction;
729,744c785
<         m_actionValue = static_cast<uint8_t> (action.selfProtectedAction);
<         break;
<       }
<     case DMG:
<       {
<         m_actionValue = static_cast<uint8_t> (action.dmgAction);
<         break;
<       }
<     case FST:
<       {
<         m_actionValue = static_cast<uint8_t> (action.fstAction);
<         break;
<       }
<     case UNPROTECTED_DMG:
<       {
<         m_actionValue = static_cast<uint8_t> (action.unprotectedAction);
---
>         m_actionValue = action.selfProtectedAction;
757c798,813
<   return static_cast<WifiActionHeader::CategoryValue> (m_category);
---
>   switch (m_category)
>     {
>     case BLOCK_ACK:
>       return BLOCK_ACK;
>     case MESH:
>       return MESH;
>     case MULTIHOP:
>       return MULTIHOP;
>     case SELF_PROTECTED:
>       return SELF_PROTECTED;
>     case VENDOR_SPECIFIC_ACTION:
>       return VENDOR_SPECIFIC_ACTION;
>     default:
>       NS_FATAL_ERROR ("Unknown action value");
>       return SELF_PROTECTED;
>     }
767,787d822
<     case QOS:
<       switch (m_actionValue)
<         {
<         case ADDTS_REQUEST:
<           retval.qos = ADDTS_REQUEST;
<           break;
<         case ADDTS_RESPONSE:
<           retval.qos = ADDTS_RESPONSE;
<           break;
<         case DELTS:
<           retval.qos = DELTS;
<           break;
<         case SCHEDULE:
<           retval.qos = SCHEDULE;
<           break;
<         case QOS_MAP_CONFIGURE:
<           retval.qos = QOS_MAP_CONFIGURE;
<           break;
<         }
<       break;
< 
803,838d837
<     case PUBLIC:
<       switch (m_actionValue)
<         {
<         case QAB_REQUEST:
<           retval.publicAction = QAB_REQUEST;
<           break;
<         case QAB_RESPONSE:
<           retval.publicAction = QAB_RESPONSE;
<           break;
<         }
<       break;
< 
<     case RADIO_MEASUREMENT:
<       switch (m_actionValue)
<         {
<         case RADIO_MEASUREMENT_REQUEST:
<           retval.radioMeasurementAction = RADIO_MEASUREMENT_REQUEST;
<           break;
<         case RADIO_MEASUREMENT_REPORT:
<           retval.radioMeasurementAction = RADIO_MEASUREMENT_REPORT;
<           break;
<         case LINK_MEASUREMENT_REQUEST:
<           retval.radioMeasurementAction = LINK_MEASUREMENT_REQUEST;
<           break;
<         case LINK_MEASUREMENT_REPORT:
<           retval.radioMeasurementAction = LINK_MEASUREMENT_REPORT;
<           break;
<         case NEIGHBOR_REPORT_REQUEST:
<           retval.radioMeasurementAction = NEIGHBOR_REPORT_REQUEST;
<           break;
<         case NEIGHBOR_REPORT_RESPONSE:
<           retval.radioMeasurementAction = NEIGHBOR_REPORT_RESPONSE;
<           break;
<         }
<       break;
< 
919,1048d917
< 
<     case DMG:
<       switch (m_actionValue)
<         {
<         case DMG_POWER_SAVE_CONFIGURATION_REQUEST:
<           retval.dmgAction = DMG_POWER_SAVE_CONFIGURATION_REQUEST;
<           break;
<         case DMG_POWER_SAVE_CONFIGURATION_RESPONSE:
<           retval.dmgAction = DMG_POWER_SAVE_CONFIGURATION_RESPONSE;
<           break;
<         case DMG_INFORMATION_REQUEST:
<           retval.dmgAction = DMG_INFORMATION_REQUEST;
<           break;
<         case DMG_INFORMATION_RESPONSE:
<           retval.dmgAction = DMG_INFORMATION_RESPONSE;
<           break;
<         case DMG_HANDOVER_REQUEST:
<           retval.dmgAction = DMG_HANDOVER_REQUEST;
<           break;
<         case DMG_HANDOVER_RESPONSE:
<           retval.dmgAction = DMG_HANDOVER_RESPONSE;
<           break;
<         case DMG_DTP_REQUEST:
<           retval.dmgAction = DMG_DTP_REQUEST;
<           break;
<         case DMG_DTP_RESPONSE:
<           retval.dmgAction = DMG_DTP_RESPONSE;
<           break;
<         case DMG_RELAY_SEARCH_REQUEST:
<           retval.dmgAction = DMG_RELAY_SEARCH_REQUEST;
<           break;
<         case DMG_RELAY_SEARCH_RESPONSE:
<           retval.dmgAction = DMG_RELAY_SEARCH_RESPONSE;
<           break;
<         case DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REQUEST:
<           retval.dmgAction = DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REQUEST;
<           break;
<         case DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REPORT:
<           retval.dmgAction = DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REPORT;
<           break;
<         case DMG_RLS_REQUEST:
<           retval.dmgAction = DMG_RLS_REQUEST;
<           break;
<         case DMG_RLS_RESPONSE:
<           retval.dmgAction = DMG_RLS_RESPONSE;
<           break;
<         case DMG_RLS_ANNOUNCEMENT:
<           retval.dmgAction = DMG_RLS_ANNOUNCEMENT;
<           break;
<         case DMG_RLS_TEARDOWN:
<           retval.dmgAction = DMG_RLS_TEARDOWN;
<           break;
<         case DMG_RELAY_ACK_REQUEST:
<           retval.dmgAction = DMG_RELAY_ACK_REQUEST;
<           break;
<         case DMG_RELAY_ACK_RESPONSE:
<           retval.dmgAction = DMG_RELAY_ACK_RESPONSE;
<           break;
<         case DMG_TPA_REQUEST:
<           retval.dmgAction = DMG_TPA_REQUEST;
<           break;
<         case DMG_TPA_RESPONSE:
<           retval.dmgAction = DMG_TPA_RESPONSE;
<           break;
<         case DMG_ROC_REQUEST:
<           retval.dmgAction = DMG_ROC_REQUEST;
<           break;
<         case DMG_ROC_RESPONSE:
<           retval.dmgAction = DMG_ROC_RESPONSE;
<           break;
<         default:
<           NS_FATAL_ERROR ("Unknown DMG management action code");
<           retval.selfProtectedAction = PEER_LINK_OPEN; /* quiet compiler */
<         }
<       break;
< 
<     case FST:
<       switch (m_actionValue)
<         {
<         case FST_SETUP_REQUEST:
<           retval.fstAction = FST_SETUP_REQUEST;
<           break;
<         case FST_SETUP_RESPONSE:
<           retval.fstAction = FST_SETUP_RESPONSE;
<           break;
<         case FST_TEAR_DOWN:
<           retval.fstAction = FST_TEAR_DOWN;
<           break;
<         case FST_ACK_REQUEST:
<           retval.fstAction = FST_ACK_REQUEST;
<           break;
<         case FST_ACK_RESPONSE:
<           retval.fstAction = FST_ACK_RESPONSE;
<           break;
<         case ON_CHANNEL_TUNNEL_REQUEST:
<           retval.fstAction = ON_CHANNEL_TUNNEL_REQUEST;
<           break;
<         default:
<           NS_FATAL_ERROR ("Unknown FST management action code");
<           retval.selfProtectedAction = PEER_LINK_OPEN; /* quiet compiler */
<         }
<       break;
< 
<     case UNPROTECTED_DMG:
<       switch (m_actionValue)
<         {
<         case UNPROTECTED_DMG_ANNOUNCE:
<           retval.unprotectedAction = UNPROTECTED_DMG_ANNOUNCE;
<           break;
<         case UNPROTECTED_DMG_BRP:
<           retval.unprotectedAction = UNPROTECTED_DMG_BRP;
<           break;
<         case UNPROTECTED_MIMO_BF_SETUP:
<           retval.unprotectedAction = UNPROTECTED_MIMO_BF_SETUP;
<           break;
<         case UNPROTECTED_MIMO_BF_POLL:
<           retval.unprotectedAction = UNPROTECTED_MIMO_BF_POLL;
<           break;
<         case UNPROTECTED_MIMO_BF_FEEDBACK:
<           retval.unprotectedAction = UNPROTECTED_MIMO_BF_FEEDBACK;
<           break;
<         case UNPROTECTED_MIMO_BF_SELECTION:
<           retval.unprotectedAction = UNPROTECTED_MIMO_BF_SELECTION;
<           break;
<         default:
<           NS_FATAL_ERROR ("Unknown Unprotected DMG action code");
<           retval.selfProtectedAction = PEER_LINK_OPEN; /* quiet compiler */
<         }
<       break;
< 
1159,1439d1027
< /***************************************************
< *               Add TS Request Frame
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (DmgAddTSRequestFrame);
< 
< DmgAddTSRequestFrame::DmgAddTSRequestFrame ()
<   : m_dialogToken (1)
< {
< }
< 
< TypeId
< DmgAddTSRequestFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::DmgAddTSRequestFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<DmgAddTSRequestFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< DmgAddTSRequestFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< DmgAddTSRequestFrame::Print (std::ostream &os) const
< {
< }
< 
< uint32_t
< DmgAddTSRequestFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1;                                      //Dialog token
<   size += m_dmgTspecElement.GetSerializedSize (); //DMG TSPEC
<   return size;
< }
< 
< void
< DmgAddTSRequestFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_dmgTspecElement.Serialize (i);
< }
< 
< uint32_t
< DmgAddTSRequestFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_dmgTspecElement.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< DmgAddTSRequestFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< DmgAddTSRequestFrame::SetDmgTspecElement (DmgTspecElement &element)
< {
<   m_dmgTspecElement = element;
< }
< 
< uint8_t
< DmgAddTSRequestFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< DmgTspecElement
< DmgAddTSRequestFrame::GetDmgTspec (void) const
< {
<   return m_dmgTspecElement;
< }
< 
< /***************************************************
< *               Add TS Response Frame
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (DmgAddTSResponseFrame);
< 
< DmgAddTSResponseFrame::DmgAddTSResponseFrame ()
<   : m_dialogToken (1)
< {
< }
< 
< TypeId
< DmgAddTSResponseFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::DmgAddTSResponseFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<DmgAddTSResponseFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< DmgAddTSResponseFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< DmgAddTSResponseFrame::Print (std::ostream &os) const
< {
< }
< 
< uint32_t
< DmgAddTSResponseFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1;                                      //Dialog token
<   size += m_status.GetSerializedSize ();          //Status Code
<   size += m_tsDelayElement.GetSerializedSize ();  //TS Delay
<   size += m_dmgTspecElement.GetSerializedSize (); //DMG TSPEC
<   return size;
< }
< 
< void
< DmgAddTSResponseFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_status.Serialize (i);
<   i = m_tsDelayElement.Serialize (i);
<   i = m_dmgTspecElement.Serialize (i);
< }
< 
< uint32_t
< DmgAddTSResponseFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_status.Deserialize (i);
<   i = m_tsDelayElement.Deserialize (i);
<   i = m_dmgTspecElement.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< DmgAddTSResponseFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< DmgAddTSResponseFrame::SetStatusCode (StatusCode status)
< {
<   m_status = status;
< }
< 
< void
< DmgAddTSResponseFrame::SetTsDelay (TsDelayElement &element)
< {
<   m_tsDelayElement = element;
< }
< 
< void
< DmgAddTSResponseFrame::SetDmgTspecElement (DmgTspecElement &element)
< {
<   m_dmgTspecElement = element;
< }
< 
< uint8_t
< DmgAddTSResponseFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< StatusCode
< DmgAddTSResponseFrame::GetStatusCode (void) const
< {
<   return m_status;
< }
< 
< TsDelayElement
< DmgAddTSResponseFrame::GetTsDelay (void) const
< {
<   return m_tsDelayElement;
< }
< 
< DmgTspecElement
< DmgAddTSResponseFrame::GetDmgTspec (void) const
< {
<   return m_dmgTspecElement;
< }
< 
< /***************************************************
< *               Delete TS Frame (8.5.3.4)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (DelTsFrame);
< 
< DelTsFrame::DelTsFrame ()
<   : m_reasonCode (0)
< {
< }
< 
< TypeId
< DelTsFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::DelTsFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<DelTsFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< DelTsFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< DelTsFrame::Print (std::ostream &os) const
< {
< }
< 
< uint32_t
< DelTsFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 3;                                        //TS Info
<   size += 2;                                        //Reason Code
<   size += m_dmgAllocationInfo.GetSerializedSize (); //DMG Allocation Info
<   return size;
< }
< 
< void
< DelTsFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.Write (m_tsInfo, 3);
<   i.WriteHtolsbU16 (m_reasonCode);
<   i = m_dmgAllocationInfo.Serialize (i);
< }
< 
< uint32_t
< DelTsFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   i.Read (m_tsInfo, 3);
<   m_reasonCode = i.ReadLsbtohU16 ();
<   i = m_dmgAllocationInfo.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< DelTsFrame::SetReasonCode (uint16_t reason)
< {
<   m_reasonCode = reason;
< }
< 
< void
< DelTsFrame::SetDmgAllocationInfo (DmgAllocationInfo info)
< {
<   m_dmgAllocationInfo = info;
< }
< 
< uint16_t
< DelTsFrame::GetReasonCode (void) const
< {
<   return m_reasonCode;
< }
< 
< DmgAllocationInfo
< DelTsFrame::GetDmgAllocationInfo (void) const
< {
<   return m_dmgAllocationInfo;
< }
1894,5691d1481
< }
< 
< /***************************************************
< *      Radio Measurement Request Frame (8.5.7.2)
< ****************************************************/
< 
< RadioMeasurementRequest::RadioMeasurementRequest ()
<   : m_dialogToken (0),
<     m_numOfRepetitions (0)
< {
< }
< 
< TypeId
< RadioMeasurementRequest::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::RadioMeasurementRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<RadioMeasurementRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< RadioMeasurementRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< RadioMeasurementRequest::Print (std::ostream &os) const
< {
< 
< }
< 
< uint32_t
< RadioMeasurementRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 3;
<   for (WifiInfoElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       size += (*iter)->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< RadioMeasurementRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_numOfRepetitions);
<   for (WifiInfoElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       i = (*iter)->Serialize (i);
<     }
< }
< 
< uint32_t
< RadioMeasurementRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<DirectionalChannelQualityRequestElement> element;
<   m_dialogToken = i.ReadU8 ();
<   m_numOfRepetitions = i.ReadLsbtohU16 ();
<   while (!i.IsEnd ())
<     {
<       element = Create<DirectionalChannelQualityRequestElement> ();
<       i = element->Deserialize (i);
<       m_list.push_back (element);
<   }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< RadioMeasurementRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< RadioMeasurementRequest::SetNumberOfRepetitions (uint16_t repetitions)
< {
<   m_numOfRepetitions = repetitions;
< }
< 
< void
< RadioMeasurementRequest::AddMeasurementRequestElement (Ptr<WifiInformationElement> elem)
< {
<   m_list.push_back (elem);
< }
< 
< uint8_t
< RadioMeasurementRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< RadioMeasurementRequest::GetNumberOfRepetitions (void) const
< {
<   return m_numOfRepetitions;
< }
< 
< WifiInfoElementList
< RadioMeasurementRequest::GetListOfMeasurementRequestElement (void) const
< {
<   return m_list;
< }
< 
< /***************************************************
< *      Radio Measurement Request Frame (8.5.7.3)
< ****************************************************/
< 
< RadioMeasurementReport::RadioMeasurementReport ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< RadioMeasurementReport::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::RadioMeasurementReport")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<RadioMeasurementReport> ()
<   ;
<   return tid;
< }
< 
< TypeId
< RadioMeasurementReport::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< RadioMeasurementReport::Print (std::ostream &os) const
< {
< 
< }
< 
< uint32_t
< RadioMeasurementReport::GetSerializedSize (void) const
< {
<   uint32_t size = 1;
<   for (WifiInfoElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       size += (*iter)->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< RadioMeasurementReport::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   for (WifiInfoElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       i = (*iter)->Serialize (i);
<     }
< }
< 
< uint32_t
< RadioMeasurementReport::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<DirectionalChannelQualityReportElement> element;
<   m_dialogToken = i.ReadU8 ();
<   while (!i.IsEnd ())
<     {
<       element = Create<DirectionalChannelQualityReportElement> ();
<       i = element->Deserialize (i);
<       m_list.push_back (element);
<   }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< RadioMeasurementReport::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< RadioMeasurementReport::AddMeasurementReportElement (Ptr<WifiInformationElement> elem)
< {
<   m_list.push_back (elem);
< }
< 
< uint8_t
< RadioMeasurementReport::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< WifiInfoElementList
< RadioMeasurementReport::GetListOfMeasurementReportElement (void) const
< {
<   return m_list;
< }
< 
< /***************************************************
< *      Link Measurement Request Frame (8.5.7.5)
< ****************************************************/
< 
< LinkMeasurementRequest::LinkMeasurementRequest ()
<   : m_dialogToken (0),
<     m_transmitPowerUsed (0),
<     m_maxTransmitPower (0)
< {
< }
< 
< TypeId
< LinkMeasurementRequest::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::LinkMeasurementRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<LinkMeasurementRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< LinkMeasurementRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< LinkMeasurementRequest::Print (std::ostream &os) const
< {
< 
< }
< 
< uint32_t
< LinkMeasurementRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 3;
<   for (WifiInformationSubelementMap::const_iterator iter = m_map.begin (); iter != m_map.end (); iter++)
<     {
<       size += iter->second->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< LinkMeasurementRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteU8 (m_transmitPowerUsed);
<   i.WriteU8 (m_maxTransmitPower);
<   for (WifiInformationSubelementMap::const_iterator iter = m_map.begin (); iter != m_map.end (); iter++)
<     {
<       iter->second->Serialize (i);
<     }
< }
< 
< uint32_t
< LinkMeasurementRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<WifiInformationElement> element;
<   uint8_t id, length;
<   m_dialogToken = i.ReadU8 ();
<   m_transmitPowerUsed = i.ReadU8 ();
<   m_maxTransmitPower = i.ReadU8 ();
<   while (!i.IsEnd ())
<     {
<       i = DeserializeElementID (i, id, length);
<       switch (id)
<         {
<           case IE_DMG_LINK_MARGIN:
<             {
<               element = Create<LinkMarginElement> ();
<               break;
<             }
<           case IE_DMG_LINK_ADAPTATION_ACKNOWLEDGMENT:
<             {
<               element = Create<LinkAdaptationAcknowledgment> ();
<               break;
<             }
<         }
<       i = element->DeserializeElementBody (i, length);
<       m_map[id] = element;
<   }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< LinkMeasurementRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< LinkMeasurementRequest::SetTransmitPowerUsed (uint8_t power)
< {
<   m_transmitPowerUsed = power;
< }
< 
< void
< LinkMeasurementRequest::SetMaxTransmitPower (uint8_t power)
< {
<   m_maxTransmitPower = power;
< }
< 
< void
< LinkMeasurementRequest::AddSubElement (Ptr<WifiInformationElement> elem)
< {
<   m_map[elem->ElementId ()] = elem;
< }
< 
< uint8_t
< LinkMeasurementRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint8_t
< LinkMeasurementRequest::GetTransmitPowerUsed (uint8_t power) const
< {
<   return m_transmitPowerUsed;
< }
< 
< uint8_t
< LinkMeasurementRequest::GetMaxTransmitPower (uint8_t power) const
< {
<   return m_maxTransmitPower;
< }
< 
< Ptr<WifiInformationElement>
< LinkMeasurementRequest::GetSubElement (WifiInformationElementId id)
< {
<   return m_map[id];
< }
< 
< WifiInformationSubelementMap
< LinkMeasurementRequest::GetListOfSubElements (void) const
< {
<   return m_map;
< }
< 
< /***************************************************
< *      Link Measurement Report Frame (8.5.7.5)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (LinkMeasurementReport);
< 
< LinkMeasurementReport::LinkMeasurementReport ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< LinkMeasurementReport::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::LinkMeasurementReport")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<LinkMeasurementReport> ()
<   ;
<   return tid;
< }
< 
< TypeId
< LinkMeasurementReport::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< LinkMeasurementReport::Print (std::ostream &os) const
< {
<   os << "Dialog Token=" << m_dialogToken;
< }
< 
< uint32_t
< LinkMeasurementReport::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 9;
<   for (WifiInformationSubelementMap::const_iterator iter = m_map.begin (); iter != m_map.end (); iter++)
<     {
<       size += iter->second->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< LinkMeasurementReport::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU32 (m_tpcElement);
<   i.WriteU8 (m_receiveAntId);
<   i.WriteU8 (m_transmitAntId);
<   i.WriteU8 (m_rcpi);
<   i.WriteU8 (m_rsni);
<   for (WifiInformationSubelementMap::const_iterator iter = m_map.begin (); iter != m_map.end (); iter++)
<     {
<       iter->second->Serialize (i);
<     }
< }
< 
< uint32_t
< LinkMeasurementReport::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<WifiInformationElement> element;
<   uint8_t id, length;
<   m_dialogToken = i.ReadU8 ();
<   m_tpcElement = i.ReadLsbtohU32 ();
<   m_receiveAntId = i.ReadU8 ();
<   m_transmitAntId = i.ReadU8 ();
<   m_rcpi = i.ReadU8 ();
<   m_rsni = i.ReadU8 ();
<   while (!i.IsEnd ())
<     {
<       i = DeserializeElementID (i, id, length);
<       switch (id)
<         {
<           case IE_DMG_LINK_MARGIN:
<             {
<               element = Create<LinkMarginElement> ();
<               break;
<             }
<           case IE_DMG_LINK_ADAPTATION_ACKNOWLEDGMENT:
<             {
<               element = Create<LinkAdaptationAcknowledgment> ();
<               break;
<             }
<         }
<       i = element->DeserializeElementBody (i, length);
<       m_map[id] = element;
<   }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< LinkMeasurementReport::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< LinkMeasurementReport::SetTpcReportElement (uint32_t elem)
< {
<   m_tpcElement = elem;
< }
< 
< void
< LinkMeasurementReport::SetReceiveAntennaId (uint8_t id)
< {
<   m_receiveAntId = id;
< }
< 
< void
< LinkMeasurementReport::SetTransmitAntennaId (uint8_t id)
< {
<   m_transmitAntId = id;
< }
< 
< void
< LinkMeasurementReport::SetRCPI (uint8_t value)
< {
<   m_rcpi = value;
< }
< 
< void
< LinkMeasurementReport::SetRSNI (uint8_t value)
< {
<   m_rsni = value;
< }
< 
< void
< LinkMeasurementReport::AddSubElement (Ptr<WifiInformationElement> elem)
< {
<   m_map[elem->ElementId ()] = elem;
< }
< 
< uint8_t
< LinkMeasurementReport::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint32_t
< LinkMeasurementReport::GetTpcReportElement (void) const
< {
<   return m_tpcElement;
< }
< 
< uint8_t
< LinkMeasurementReport::GetReceiveAntennaId (void) const
< {
<   return m_receiveAntId;
< }
< 
< uint8_t
< LinkMeasurementReport::GetTransmitAntennaId (void) const
< {
<   return m_transmitAntId;
< }
< 
< uint8_t
< LinkMeasurementReport::GetRCPI (void) const
< {
<   return m_rcpi;
< }
< 
< uint8_t
< LinkMeasurementReport::GetRSNI (void) const
< {
<   return m_rsni;
< }
< 
< Ptr<WifiInformationElement>
< LinkMeasurementReport::GetSubElement (WifiInformationElementId id)
< {
<   return m_map[id];
< }
< 
< WifiInformationSubelementMap
< LinkMeasurementReport::GetListOfSubElements (void) const
< {
<   return m_map;
< }
< 
< /***************************************************
< *               Common QAB Frame
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtQabFrame);
< 
< void
< ExtQabFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Requestor AP Address = " << m_requester
<      << ", Responder AP Address = " << m_responder;
< }
< 
< uint32_t
< ExtQabFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 6; //Requestor AP Address
<   size += 6; //Responder AP Address
< 
<   return size;
< }
< 
< void
< ExtQabFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtQabFrame::SetRequesterApAddress (Mac48Address address)
< {
<   m_requester = address;
< }
< 
< void
< ExtQabFrame::SetResponderApAddress (Mac48Address address)
< {
<   m_responder = address;
< }
< 
< uint8_t
< ExtQabFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< Mac48Address
< ExtQabFrame::GetRequesterApAddress (void) const
< {
<   return m_requester;
< }
< 
< Mac48Address
< ExtQabFrame::GetResponderApAddress (void) const
< {
<   return m_responder;
< }
< 
< /***************************************************
< *           QAB Request Frame (8.5.8.25)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtQabRequestFrame);
< 
< ExtQabRequestFrame::ExtQabRequestFrame ()
< {
<   m_dialogToken = 0;
< }
< 
< TypeId
< ExtQabRequestFrame::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtQabRequestFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtQabRequestFrame> ()
<   ;
<   return tid;
< }
< 
< void
< ExtQabRequestFrame::Print (std::ostream &os) const
< {
<   ExtQabFrame::Print (os);
<   m_element.Print (os);
< }
< 
< uint32_t
< ExtQabRequestFrame::GetSerializedSize (void) const
< {
<   return ExtQabFrame::GetSerializedSize () + m_element.GetSerializedSize ();
< }
< 
< TypeId
< ExtQabRequestFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtQabRequestFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   WriteTo (i, m_requester);
<   WriteTo (i, m_responder);
<   i = m_element.Serialize (i);
< }
< 
< uint32_t
< ExtQabRequestFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   ReadFrom (i, m_requester);
<   ReadFrom (i, m_responder);
<   i = m_element.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtQabRequestFrame::SetQuietPeriodRequestElement (QuietPeriodRequestElement &element)
< {
<   m_element = element;
< }
< 
< QuietPeriodRequestElement
< ExtQabRequestFrame::GetQuietPeriodRequestElement (void) const
< {
<   return m_element;
< }
< 
< /***************************************************
< *           QAB Response Frame (8.5.8.26)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtQabResponseFrame);
< 
< ExtQabResponseFrame::ExtQabResponseFrame ()
< {
<   m_dialogToken = 0;
< }
< 
< void
< ExtQabResponseFrame::Print (std::ostream &os) const
< {
<   ExtQabFrame::Print (os);
<   m_element.Print (os);
< }
< 
< uint32_t
< ExtQabResponseFrame::GetSerializedSize (void) const
< {
<   return ExtQabFrame::GetSerializedSize () + m_element.GetSerializedSize ();
< }
< 
< TypeId
< ExtQabResponseFrame::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtQabResponseFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtQabResponseFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtQabResponseFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtQabResponseFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   WriteTo (i, m_requester);
<   WriteTo (i, m_responder);
<   i = m_element.Serialize (i);
< }
< 
< uint32_t
< ExtQabResponseFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   ReadFrom (i, m_requester);
<   ReadFrom (i, m_responder);
<   i = m_element.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtQabResponseFrame::SetQuietPeriodResponseElement (QuietPeriodResponseElement &element)
< {
<   m_element = element;
< }
< 
< QuietPeriodResponseElement
< ExtQabResponseFrame::GetQuietPeriodResponseElement (void) const
< {
<   return m_element;
< }
< 
< /***************************************************
< *           Common Information Frame
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtInformationFrame);
< 
< ExtInformationFrame::ExtInformationFrame ()
< {
< }
< 
< void
< ExtInformationFrame::Print (std::ostream &os) const
< {
< 
< }
< 
< uint32_t
< ExtInformationFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 6; //Subject Address
<   size += m_requestElement->GetSerializedSize (); //Request Information
<   // DMG Capabilities List
<   size += m_dmgCapabilitiesList.size () * 26; /* The whole DMG Capabilities Element Size */
<   // Wifi Information Element List (Optional)
<   size += GetInformationElementsSerializedSize ();
<   return size;
< }
< 
< void
< ExtInformationFrame::SetSubjectAddress (Mac48Address address)
< {
<   m_subjectAddress = address;
< }
< 
< void
< ExtInformationFrame::SetRequestInformationElement (Ptr<RequestElement> elem)
< {
<   m_requestElement = elem;
< }
< 
< void
< ExtInformationFrame::AddDmgCapabilitiesElement (Ptr<DmgCapabilities> elem)
< {
<   m_dmgCapabilitiesList.push_back (elem);
< }
< 
< 
< Mac48Address
< ExtInformationFrame::GetSubjectAddress (void) const
< {
<   return m_subjectAddress;
< }
< 
< Ptr<RequestElement>
< ExtInformationFrame::GetRequestInformationElement (void) const
< {
<   return m_requestElement;
< }
< 
< DmgCapabilitiesList
< ExtInformationFrame::GetDmgCapabilitiesList (void) const
< {
<   return m_dmgCapabilitiesList;
< }
< 
< /***************************************************
< *         Information Request Frame (8.5.20.4)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtInformationRequest);
< 
< TypeId
< ExtInformationRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtInformationRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtInformationRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtInformationRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtInformationRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   WriteTo (i, m_subjectAddress);
<   i = m_requestElement->Serialize (i);
<   for (DmgCapabilitiesList::const_iterator j = m_dmgCapabilitiesList.begin (); j != m_dmgCapabilitiesList.end () ; j++)
<     {
<       i = (*j)->Serialize (i);
<     }
<   i = SerializeInformationElements (i);
< }
< 
< uint32_t
< ExtInformationRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Buffer::Iterator m;
<   Ptr<DmgCapabilities> dmgCapabilities;
< 
<   ReadFrom (i, m_subjectAddress);
<   m_requestElement = Create<RequestElement> ();
<   i = m_requestElement->Deserialize (i);
< 
<   /* Deserialize DMG Capabilities Elements */
<   while (!i.IsEnd ())
<     {
<       m = i;
<       dmgCapabilities = Create<DmgCapabilities> ();
<       i = dmgCapabilities->DeserializeIfPresent (i);
<       if (i.GetDistanceFrom (m) != 0)
<         {
<           m_dmgCapabilitiesList.push_back (dmgCapabilities);
<         }
<       else
<         {
<           break;
<         }
<     }
< 
<   /* Deserialize Infomration Elements */
<   i = DeserializeInformationElements (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< 
< /***************************************************
< *         Information Response Frame (8.5.20.5)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtInformationResponse);
< 
< TypeId
< ExtInformationResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtInformationResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtInformationResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtInformationResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< uint32_t
< ExtInformationResponse::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 6; //Subject Address
<   size += m_requestElement->GetSerializedSize (); //Request Information
<   // DMG Capabilities List
<   size += m_dmgCapabilitiesList.size () * 26; /* The whole DMG Capabilities Element Size */
<   // Wifi Information Element List (Optional)
<   if (m_beamRefinement != 0)
<     {
<       size += m_beamRefinement->GetSerializedSize ();
<     }
<   if (m_channelElement != 0)
<     {
<       size += m_channelElement->GetSerializedSize ();
<     }
<   if (m_edmgChannelElement != 0)
<     {
<       size += m_edmgChannelElement->GetSerializedSize ();
<     }
<   size += GetInformationElementsSerializedSize ();
<   return size;
< }
< void
< ExtInformationResponse::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   WriteTo (i, m_subjectAddress);
<   for (DmgCapabilitiesList::const_iterator j = m_dmgCapabilitiesList.begin (); j != m_dmgCapabilitiesList.end () ; j++)
<     {
<       i = (*j)->Serialize (i);
<     }
<   i = m_requestElement->Serialize (i);
<   if (m_beamRefinement != 0)
<     {
<       i = m_beamRefinement->Serialize (i);
<     }
<   if (m_channelElement != 0)
<     {
<       i = m_channelElement->Serialize (i);
<     }
<   if (m_edmgChannelElement != 0)
<     {
<       i = m_edmgChannelElement->Serialize (i);
<     }
<   i = SerializeInformationElements (i);
< }
< 
< uint32_t
< ExtInformationResponse::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Buffer::Iterator m;
<   Ptr<DmgCapabilities> dmgCapabilities;
< 
< 
<   ReadFrom (i, m_subjectAddress);
<   /* Deserialize DMG Capabilities Elements */
<   while (!i.IsEnd ())
<     {
<       m = i;
<       dmgCapabilities = Create<DmgCapabilities> ();
<       i = dmgCapabilities->DeserializeIfPresent (i);
<       if (i.GetDistanceFrom (m) != 0)
<         {
<           m_dmgCapabilitiesList.push_back (dmgCapabilities);
<         }
<       else
<         {
<           break;
<         }
<     }
< 
<   m_requestElement = Create<RequestElement> ();
<   i = m_requestElement->Deserialize (i);
< 
<   m_beamRefinement = Create<BeamRefinementElement> ();
<   m_channelElement = Create<ChannelMeasurementFeedbackElement> ();
<   m_edmgChannelElement = Create<EDMGChannelMeasurementFeedbackElement> ();
< 
<   m = i;
<   i = m_beamRefinement->DeserializeIfPresent (i);
<   if (i.GetDistanceFrom (m) != 0)
<     {
<       bool channelPresent = false;
<       if (m_beamRefinement->IsSnrPresent ())
<         {
<           channelPresent = true;
<           if (m_beamRefinement->GetEdmgExtensionFlag ())
<             {
<               m_channelElement->SetSnrListSize (m_beamRefinement->GetExtendedNumberOfMeasurements ());
<             }
<           else
<             {
<               m_channelElement->SetSnrListSize (m_beamRefinement->GetNumberOfMeasurements ());
<             }
<         }
< 
<       if (m_beamRefinement->IsChannelMeasurementPresent ())
<         {
<           channelPresent = true;
<           if (m_beamRefinement->GetEdmgExtensionFlag ())
<             {
<               m_channelElement->SetChannelMeasurementSize (m_beamRefinement->GetExtendedNumberOfMeasurements ());
<             }
<           else
<             {
<               m_channelElement->SetChannelMeasurementSize (m_beamRefinement->GetNumberOfMeasurements ());
<             }
<           m_channelElement->SetTapComponentsSize (m_beamRefinement->GetNumberOfTapsPresent ());
<         }
< 
<       if (m_beamRefinement->IsTapDelayPresent ())
<         {
<           if (m_beamRefinement->GetEdmgExtensionFlag ())
<             {
<               m_edmgChannelElement->SetTapsDelaySize (m_beamRefinement->GetNumberOfTapsPresent ());
<             }
<           else
<             {
<               channelPresent = true;
<               m_channelElement->SetTapsDelaySize (m_beamRefinement->GetNumberOfTapsPresent ());
<             }
<         }
< 
<       if (m_beamRefinement->IsSectorIdOrderPresent ())
<         {
<           if (m_beamRefinement->GetNumberOfBeams () != 0)
<             {
<               if (m_beamRefinement->GetEdmgExtensionFlag ())
<                 {
<                   m_edmgChannelElement->SetSectorIdOrderSize (m_beamRefinement->GetNumberOfBeams ());
<                 }
<               else
<                 {
<                   channelPresent = true;
<                   m_channelElement->SetSectorIdSize (m_beamRefinement->GetNumberOfBeams ());
<                 }
<             }
<           else
<             {
<               if (m_beamRefinement->GetEdmgExtensionFlag ())
<                 {
<                   m_edmgChannelElement->SetSectorIdOrderSize (m_beamRefinement->GetExtendedNumberOfMeasurements ());
<                 }
<               else
<                 {
<                   channelPresent = true;
<                   m_channelElement->SetSectorIdSize (m_beamRefinement->GetNumberOfMeasurements ());
<                 }
<             }
<         }
< 
<       if ((m_beamRefinement->GetSectorSweepFrameType () == BRP_FRAME) || (m_beamRefinement->GetSectorSweepFrameType () == BEAM_TRACKING_FBCK))
<         {
<           if (m_beamRefinement->GetEdmgExtensionFlag ())
<             {
<               m_edmgChannelElement->SetBrpCdownSize (m_beamRefinement->GetExtendedNumberOfMeasurements ());
<             }
<         }
< 
<       if (channelPresent)
<         {
<           i = m_channelElement->Deserialize (i);
<         }
< 
<       if (m_beamRefinement->IsEdmgChannelMeasurementPresent ())
<         {
<           i = m_edmgChannelElement->Deserialize (i);
<         }
<     }
< 
<   /* Deserialize Infomration Elements */
<   i = DeserializeInformationElements (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< Ptr<BeamRefinementElement>
< ExtInformationResponse::GetBeamRefinementElement (void) const
< {
<   return m_beamRefinement;
< }
< Ptr<ChannelMeasurementFeedbackElement>
< ExtInformationResponse::GetChannelMeasurementElement (void) const
< {
<   return m_channelElement;
< }
< 
< Ptr<EDMGChannelMeasurementFeedbackElement>
< ExtInformationResponse::GetEDMGChannelMeasurementElement (void) const
< {
<   return m_edmgChannelElement;
< }
< 
< void
< ExtInformationResponse::SetBeamRefinementElement (Ptr<BeamRefinementElement> element)
< {
<   m_beamRefinement = element;
< }
< 
< void
< ExtInformationResponse::SetChannelMeasurementElement (Ptr<ChannelMeasurementFeedbackElement> element)
< {
<   m_channelElement = element;
< }
< 
< void
< ExtInformationResponse::SetEdmgChannelMeasurementElement (Ptr<EDMGChannelMeasurementFeedbackElement> element)
< {
<   m_edmgChannelElement = element;
< }
< 
< /***************************************************
< *                 Handover Request
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtHandoverRequestHeader);
< 
< ExtHandoverRequestHeader::ExtHandoverRequestHeader ()
<   : m_handoverReason (LeavingPBSS),
<     m_remainingBI (0)
< {
< }
< 
< TypeId
< ExtHandoverRequestHeader::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtHandoverRequestHeader")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtHandoverRequestHeader> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtHandoverRequestHeader::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtHandoverRequestHeader::Print (std::ostream &os) const
< {
<   os << "Handover Reason = " << m_handoverReason
<      << ", m_remainingBI = " << m_remainingBI;
< }
< 
< uint32_t
< ExtHandoverRequestHeader::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Handover Reason
<   size += 1; //Handover Remaining BI
<   return size;
< }
< 
< void
< ExtHandoverRequestHeader::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_handoverReason);
<   i.WriteU8 (m_remainingBI);
< }
< 
< uint32_t
< ExtHandoverRequestHeader::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_handoverReason = i.ReadU8 ();
<   m_remainingBI = i.ReadU8 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtHandoverRequestHeader::SetHandoverReason (enum HandoverReason reason)
< {
<   m_handoverReason = reason;
< }
< 
< void
< ExtHandoverRequestHeader::SetHandoverRemainingBI (uint8_t remaining)
< {
<   m_remainingBI = remaining;
< }
< 
< enum HandoverReason
< ExtHandoverRequestHeader::GetHandoverReason (void) const
< {
<   return static_cast<enum HandoverReason> (m_handoverReason);
< }
< 
< uint8_t
< ExtHandoverRequestHeader::GetHandoverRemainingBI (void) const
< {
<   return m_remainingBI;
< }
< 
< /***************************************************
< *                 Handover Response
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtHandoverResponseHeader);
< 
< ExtHandoverResponseHeader::ExtHandoverResponseHeader ()
<   : m_handoverResult (1),
<     m_handoverRejectReason (LowPower)
< {
< }
< 
< TypeId
< ExtHandoverResponseHeader::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtHandoverResponseHeader")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtHandoverResponseHeader> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtHandoverResponseHeader::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtHandoverResponseHeader::Print (std::ostream &os) const
< {
<   os << "Handover Result = " << m_handoverResult
<      << ", Handover Reject Reason = " << m_handoverRejectReason;
< }
< 
< uint32_t
< ExtHandoverResponseHeader::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Handover Result
<   size += 1; //Handover Reject Reason
<   return size;
< }
< 
< void
< ExtHandoverResponseHeader::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_handoverResult);
<   i.WriteU8 (m_handoverRejectReason);
< }
< 
< uint32_t
< ExtHandoverResponseHeader::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_handoverResult = i.ReadU8 ();
<   m_handoverRejectReason = i.ReadU8 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtHandoverResponseHeader::SetHandoverResult (bool result)
< {
<   m_handoverResult = result;
< }
< 
< void
< ExtHandoverResponseHeader::SetHandoverRejectReason (enum HandoverRejectReason reason)
< {
<   m_handoverRejectReason = reason;
< }
< 
< bool
< ExtHandoverResponseHeader::GetHandoverResult (void) const
< {
<   return m_handoverResult;
< }
< 
< enum HandoverRejectReason
< ExtHandoverResponseHeader::GetHandoverRejectReason (void) const
< {
<   return static_cast<enum HandoverRejectReason> (m_handoverRejectReason);
< }
< 
< /***************************************************
< *               Relay Search Request
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRelaySearchRequestHeader);
< 
< ExtRelaySearchRequestHeader::ExtRelaySearchRequestHeader ()
<   : m_dialogToken (0),
<     m_aid (0)
< {
< }
< 
< TypeId
< ExtRelaySearchRequestHeader::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRelaySearchRequestHeader")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRelaySearchRequestHeader> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRelaySearchRequestHeader::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRelaySearchRequestHeader::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Destination REDS AID = " << m_aid;
< }
< 
< uint32_t
< ExtRelaySearchRequestHeader::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += 2; //Destination REDS AID
<   return size;
< }
< 
< void
< ExtRelaySearchRequestHeader::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_aid);
< }
< 
< uint32_t
< ExtRelaySearchRequestHeader::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   m_aid = i.ReadLsbtohU16 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRelaySearchRequestHeader::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtRelaySearchRequestHeader::SetDestinationRedsAid (uint16_t aid)
< {
<   m_aid = aid;
< }
< 
< uint8_t
< ExtRelaySearchRequestHeader::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< ExtRelaySearchRequestHeader::GetDestinationRedsAid (void) const
< {
<   return m_aid;
< }
< 
< /***************************************************
< *               Relay Search Response
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRelaySearchResponseHeader);
< 
< ExtRelaySearchResponseHeader::ExtRelaySearchResponseHeader ()
<   : m_dialogToken (0),
<     m_statusCode (0)
< {
< }
< 
< TypeId
< ExtRelaySearchResponseHeader::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRelaySearchResponseHeader")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRelaySearchResponseHeader> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRelaySearchResponseHeader::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRelaySearchResponseHeader::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Status Code = " << m_statusCode;
< }
< 
< uint32_t
< ExtRelaySearchResponseHeader::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += 2; //Status Code
<   if (m_statusCode == 0)
<     {
<       size += m_list.size () * 3; //Relay Capable STA Info
<     }
<   return size;
< }
< 
< void
< ExtRelaySearchResponseHeader::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_statusCode);
<   if (m_statusCode == 0)
<     {
<       for (RelayCapableStaList::const_iterator item = m_list.begin (); item != m_list.end (); item++)
<         {
<           i.WriteU8 ((item->first & 0xFF));
<           i = item->second.Serialize (i);
<         }
<     }
< }
< 
< uint32_t
< ExtRelaySearchResponseHeader::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   RelayCapabilitiesInfo info;
<   uint16_t aid;
<   m_dialogToken = i.ReadU8 ();
<   m_statusCode = i.ReadLsbtohU16 ();
<   if (!i.IsEnd ())
<     {
<       do
<         {
<           aid = i.ReadU8 ();
<           i = info.Deserialize (i);
<           m_list[aid] = info;
<         }
<       while (!i.IsEnd ());
<     }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRelaySearchResponseHeader::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtRelaySearchResponseHeader::SetStatusCode (uint16_t code)
< {
<   m_statusCode = code;
< }
< 
< void
< ExtRelaySearchResponseHeader::AddRelayCapableStaInfo (uint8_t aid, RelayCapabilitiesInfo &element)
< {
<   m_list[aid] = element;
< }
< 
< void
< ExtRelaySearchResponseHeader::SetRelayCapableList (RelayCapableStaList &list)
< {
<   m_list = list;
< }
< 
< uint8_t
< ExtRelaySearchResponseHeader::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< ExtRelaySearchResponseHeader::GetStatusCode (void) const
< {
<   return m_statusCode;
< }
< 
< RelayCapableStaList
< ExtRelaySearchResponseHeader::GetRelayCapableList (void) const
< {
<   return m_list;
< }
< 
< /***************************************************
< *     Multi Relay Channel Measurement Request
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMultiRelayChannelMeasurementRequest);
< 
< ExtMultiRelayChannelMeasurementRequest::ExtMultiRelayChannelMeasurementRequest ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< ExtMultiRelayChannelMeasurementRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtMultiRelayChannelMeasurementRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMultiRelayChannelMeasurementRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMultiRelayChannelMeasurementRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMultiRelayChannelMeasurementRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMultiRelayChannelMeasurementRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   return size;
< }
< 
< void
< ExtMultiRelayChannelMeasurementRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
< }
< 
< uint32_t
< ExtMultiRelayChannelMeasurementRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMultiRelayChannelMeasurementRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< uint8_t
< ExtMultiRelayChannelMeasurementRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< /***************************************************
< *     Multi Relay Channel Measurement Report
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMultiRelayChannelMeasurementReport);
< 
< ExtMultiRelayChannelMeasurementReport::ExtMultiRelayChannelMeasurementReport ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< ExtMultiRelayChannelMeasurementReport::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtMultiRelayChannelMeasurementReport")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMultiRelayChannelMeasurementReport> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMultiRelayChannelMeasurementReport::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMultiRelayChannelMeasurementReport::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1;                  //Dialog Token
<   size += m_list.size () * 4; //Channel Measurement Info
<   return size;
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   Ptr<ExtChannelMeasurementInfo> info;
<   i.WriteU8 (m_dialogToken);
<   for (ChannelMeasurementInfoList::const_iterator item = m_list.begin (); item != m_list.end (); item++)
<     {
<       info = *item;
<       i = info->Serialize (i);
<     }
< }
< 
< uint32_t
< ExtMultiRelayChannelMeasurementReport::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<ExtChannelMeasurementInfo> element;
<   m_dialogToken = i.ReadU8 ();
<   while (!i.IsEnd ())
<     {
<       element = Create<ExtChannelMeasurementInfo> ();
<       i = element->Deserialize (i);
<       m_list.push_back (element);
<     }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::AddChannelMeasurementInfo (Ptr<ExtChannelMeasurementInfo> element)
< {
<   m_list.push_back (element);
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::SetChannelMeasurementList (ChannelMeasurementInfoList &list)
< {
<   m_list = list;
< }
< 
< uint8_t
< ExtMultiRelayChannelMeasurementReport::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< ChannelMeasurementInfoList
< ExtMultiRelayChannelMeasurementReport::GetChannelMeasurementInfoList (void) const
< {
<   return m_list;
< }
< 
< /***************************************************
< *        Generic Relay Link Setup Frame
< ****************************************************/
< 
< ExtRlsFrame::ExtRlsFrame ()
<   : m_destinationAid (0),
<     m_relayAid (0),
<     m_sourceAid (0)
< {
< }
< 
< uint32_t
< ExtRlsFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 2; //Destination AID
<   size += 2; //Relay AID
<   size += 2; //Source AID
<   return size;
< }
< 
< void
< ExtRlsFrame::SetDestinationAid (uint16_t aid)
< {
<   m_destinationAid = aid;
< }
< 
< void
< ExtRlsFrame::SetRelayAid (uint16_t aid)
< {
<   m_relayAid = aid;
< }
< 
< void
< ExtRlsFrame::SetSourceAid (uint16_t aid)
< {
<   m_sourceAid = aid;
< }
< 
< uint16_t
< ExtRlsFrame::GetDestinationAid (void) const
< {
<   return m_destinationAid;
< }
< 
< uint16_t
< ExtRlsFrame::GetRelayAid (void) const
< {
<   return m_relayAid;
< }
< 
< uint16_t
< ExtRlsFrame::GetSourceAid (void) const
< {
<   return m_sourceAid;
< }
< 
< /***************************************************
< *        Relay Link Setup Request 8.5.20.14
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRlsRequest);
< 
< ExtRlsRequest::ExtRlsRequest ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< ExtRlsRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRlsRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRlsRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRlsRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRlsRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Destination AID = " << m_destinationAid
<      << ", Relay AID = " <<  m_relayAid
<      << ", Source AID = " <<  m_sourceAid;
< }
< 
< uint32_t
< ExtRlsRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += ExtRlsFrame::GetSerializedSize ();
<   size += m_destinationCapability.GetSerializedSize (); //Destination Capability
<   size += m_relayCapability.GetSerializedSize ();       //Relay Capability
<   size += m_sourceCapability.GetSerializedSize ();      //Source Capability
<   size += m_relayParameter->GetSerializedSize ();       //Relay Transfer
<   return size;
< }
< 
< void
< ExtRlsRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_destinationAid);
<   i.WriteHtolsbU16 (m_relayAid);
<   i.WriteHtolsbU16 (m_sourceAid);
< 
<   i = m_destinationCapability.Serialize (i);
<   i = m_relayCapability.Serialize (i);
<   i = m_sourceCapability.Serialize (i);
<   i = m_relayParameter->Serialize (i);
< }
< 
< uint32_t
< ExtRlsRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   m_destinationAid = i.ReadLsbtohU16 ();
<   m_relayAid = i.ReadLsbtohU16 ();
<   m_sourceAid = i.ReadLsbtohU16 ();
< 
<   i = m_destinationCapability.Deserialize (i);
<   i = m_relayCapability.Deserialize (i);
<   i = m_sourceCapability.Deserialize (i);
< 
<   m_relayParameter = Create<RelayTransferParameterSetElement> ();
<   i = m_relayParameter->Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRlsRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtRlsRequest::SetDestinationCapabilityInformation (RelayCapabilitiesInfo &elem)
< {
<   m_destinationCapability = elem;
< }
< 
< void
< ExtRlsRequest::SetRelayCapabilityInformation (RelayCapabilitiesInfo &elem)
< {
<   m_relayCapability = elem;
< }
< 
< void
< ExtRlsRequest::SetSourceCapabilityInformation (RelayCapabilitiesInfo &elem)
< {
<   m_sourceCapability = elem;
< }
< 
< void
< ExtRlsRequest::SetRelayTransferParameterSet (Ptr<RelayTransferParameterSetElement> elem)
< {
<   m_relayParameter = elem;
< }
< 
< uint8_t
< ExtRlsRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< RelayCapabilitiesInfo
< ExtRlsRequest::GetDestinationCapabilityInformation (void) const
< {
<   return m_destinationCapability;
< }
< 
< RelayCapabilitiesInfo
< ExtRlsRequest::GetRelayCapabilityInformation (void) const
< {
<   return m_relayCapability;
< }
< 
< RelayCapabilitiesInfo
< ExtRlsRequest::GetSourceCapabilityInformation (void) const
< {
<   return m_sourceCapability;
< }
< 
< Ptr<RelayTransferParameterSetElement>
< ExtRlsRequest::GetRelayTransferParameterSet (void) const
< {
<   return m_relayParameter;
< }
< 
< /***************************************************
< *        Relay Link Setup Response 8.5.20.15
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRlsResponse);
< 
< ExtRlsResponse::ExtRlsResponse ()
<   : m_dialogToken (0),
<     m_destinationStatusCode (0),
<     m_relayStatusCode (0),
<     m_insertRelayStatus (false)
< {
< }
< 
< TypeId
< ExtRlsResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRlsResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRlsResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRlsResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRlsResponse::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Destination Status Code = " << m_destinationStatusCode;
<   if (m_insertRelayStatus)
<      os << ", Relay Status Code = " <<  m_relayStatusCode;
< }
< 
< uint32_t
< ExtRlsResponse::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 2; //Destination Status Code
<   if (m_insertRelayStatus)
<     size += 2; //Relay Status Code
< 
<   return size;
< }
< 
< void
< ExtRlsResponse::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_destinationStatusCode);
< 
<   if (m_insertRelayStatus)
<     i.WriteHtolsbU16 (m_relayStatusCode);
< }
< 
< uint32_t
< ExtRlsResponse::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   m_destinationStatusCode = i.ReadLsbtohU16 ();
< 
<   if (!i.IsEnd ())
<     m_relayStatusCode = i.ReadLsbtohU16 ();
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRlsResponse::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtRlsResponse::SetDestinationStatusCode (uint16_t status)
< {
<   m_destinationStatusCode = status;
< }
< 
< void
< ExtRlsResponse::SetRelayStatusCode (uint16_t status)
< {
<   m_insertRelayStatus = true;
<   m_relayStatusCode = status;
< }
< 
< uint8_t
< ExtRlsResponse::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< ExtRlsResponse::GetDestinationStatusCode (void) const
< {
<   return m_destinationStatusCode;
< }
< 
< uint16_t
< ExtRlsResponse::GetRelayStatusCode (void) const
< {
<   return m_relayStatusCode;
< }
< 
< /***************************************************
< *        Relay Link Setup Announcment 8.5.20.16
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRlsAnnouncment);
< 
< ExtRlsAnnouncment::ExtRlsAnnouncment ()
<   : m_status (0)
< {
< }
< 
< TypeId
< ExtRlsAnnouncment::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRlsAnnouncment")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRlsAnnouncment> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRlsAnnouncment::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRlsAnnouncment::Print (std::ostream &os) const
< {
<   os << "Status Code = " << m_status
<      << ", Destination AID = " << m_destinationAid
<      << ", Relay AID = " <<  m_relayAid
<      << ", Source AID = " <<  m_sourceAid;
< }
< 
< uint32_t
< ExtRlsAnnouncment::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 2; //Status Code
<   size += ExtRlsFrame::GetSerializedSize ();
<   return size;
< }
< 
< void
< ExtRlsAnnouncment::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteHtolsbU16 (m_status);
<   i.WriteHtolsbU16 (m_destinationAid);
<   i.WriteHtolsbU16 (m_relayAid);
<   i.WriteHtolsbU16 (m_sourceAid);
< }
< 
< uint32_t
< ExtRlsAnnouncment::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_status = i.ReadLsbtohU16 ();
<   m_destinationAid = i.ReadLsbtohU16 ();
<   m_relayAid = i.ReadLsbtohU16 ();
<   m_sourceAid = i.ReadLsbtohU16 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRlsAnnouncment::SetStatusCode (uint16_t status)
< {
<   m_status = status;
< }
< 
< uint16_t
< ExtRlsAnnouncment::GetStatusCode (void) const
< {
<   return m_status;
< }
< 
< /***************************************************
< *        Relay Link Setup Teardown 8.5.20.17
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRlsTearDown);
< 
< ExtRlsTearDown::ExtRlsTearDown ()
<   : m_reasonCode (0)
< {
< }
< 
< TypeId
< ExtRlsTearDown::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRlsTearDown")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRlsTearDown> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRlsTearDown::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRlsTearDown::Print (std::ostream &os) const
< {
<   os << "Destination AID = " << m_destinationAid
<      << ", Relay AID = " <<  m_relayAid
<      << ", Source AID = " <<  m_sourceAid
<      << ", Reason Code = " << m_reasonCode;
< }
< 
< uint32_t
< ExtRlsTearDown::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += ExtRlsFrame::GetSerializedSize ();
<   size += 2; //Reason Code
< 
<   return size;
< }
< 
< void
< ExtRlsTearDown::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteHtolsbU16 (m_destinationAid);
<   i.WriteHtolsbU16 (m_relayAid);
<   i.WriteHtolsbU16 (m_sourceAid);
<   i.WriteHtolsbU16 (m_reasonCode);
< }
< 
< uint32_t
< ExtRlsTearDown::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_destinationAid = i.ReadLsbtohU16 ();
<   m_relayAid = i.ReadLsbtohU16 ();
<   m_sourceAid = i.ReadLsbtohU16 ();
<   m_reasonCode = i.ReadLsbtohU16 ();
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRlsTearDown::SetReasonCode (uint16_t reason)
< {
<   m_reasonCode = reason;
< }
< 
< uint16_t
< ExtRlsTearDown::GetReasonCode (void) const
< {
<   return m_reasonCode;
< }
< 
< /***************************************************
< *          Relay Ack Request 8.5.20.18
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRelayAckRequest);
< 
< TypeId
< ExtRelayAckRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRelayAckRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRelayAckRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRelayAckRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< /***************************************************
< *          Relay Ack Response 8.5.20.19
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRelayAckResponse);
< 
< TypeId
< ExtRelayAckResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRelayAckResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRelayAckResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRelayAckResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< /*************************************************************
< * Transmission Time-Point Adjustment Request frame 8.5.20.20
< **************************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtTpaRequest);
< 
< ExtTpaRequest::ExtTpaRequest ()
<   : m_dialogToken (0),
<     m_timingOffset (0),
<     m_samplingOffset (0)
< {
< }
< 
< TypeId
< ExtTpaRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtTpaRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtTpaRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtTpaRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtTpaRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Timing Offset = " << m_timingOffset
<      << ", Sampling Frequency Offset = " <<  m_samplingOffset;
< }
< 
< uint32_t
< ExtTpaRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 2; //Timing Offset
<   size += 2; //Sampling Frequency Offset
< 
<   return size;
< }
< 
< void
< ExtTpaRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_timingOffset);
<   i.WriteHtolsbU16 (m_samplingOffset);
< }
< 
< uint32_t
< ExtTpaRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   m_timingOffset = i.ReadLsbtohU16 ();
<   m_samplingOffset = i.ReadLsbtohU16 ();
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtTpaRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtTpaRequest::SetTimingOffset (uint16_t offset)
< {
<   m_timingOffset = offset;
< }
< 
< void
< ExtTpaRequest::SetSamplingFrequencyOffset (uint16_t offset)
< {
<   m_samplingOffset = offset;
< }
< 
< uint8_t
< ExtTpaRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< ExtTpaRequest::GetTimingOffset (void) const
< {
<   return m_timingOffset;
< }
< 
< uint16_t
< ExtTpaRequest::GetSamplingFrequencyOffset (void) const
< {
<   return m_samplingOffset;
< }
< 
< /*************************************************************
< *            Fast Session Transfer Setup Frame
< **************************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstSetupFrame);
< 
< ExtFstSetupFrame::ExtFstSetupFrame ()
< {
< }
< 
< void
< ExtFstSetupFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtFstSetupFrame::SetSessionTransition (SessionTransitionElement &elem)
< {
<   m_sessionTransition = elem;
< }
< 
< void
< ExtFstSetupFrame::SetMultiBand (Ptr<MultiBandElement> elem)
< {
<   m_multiBand = elem;
< }
< 
< void
< ExtFstSetupFrame::SetWakeupSchedule (Ptr<WakeupScheduleElement> elem)
< {
<   m_wakeupSchedule = elem;
< }
< 
< void
< ExtFstSetupFrame::SetAwakeWindow (Ptr<AwakeWindowElement> elem)
< {
<   m_awakeWindow = elem;
< }
< 
< void
< ExtFstSetupFrame::SetSwitchingStream (Ptr<SwitchingStreamElement> elem)
< {
<   m_switchingStream = elem;
< }
< 
< uint8_t
< ExtFstSetupFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< SessionTransitionElement
< ExtFstSetupFrame::GetSessionTransition (void) const
< {
<   return m_sessionTransition;
< }
< 
< Ptr<MultiBandElement>
< ExtFstSetupFrame::GetMultiBand (void) const
< {
<   return m_multiBand;
< }
< 
< Ptr<WakeupScheduleElement>
< ExtFstSetupFrame::GetWakeupSchedule (void) const
< {
<   return m_wakeupSchedule;
< }
< 
< Ptr<AwakeWindowElement>
< ExtFstSetupFrame::GetAwakeWindow (void) const
< {
<   return m_awakeWindow;
< }
< 
< Ptr<SwitchingStreamElement>
< ExtFstSetupFrame::GetSwitchingStream (void) const
< {
<   return m_switchingStream;
< }
< 
< /*************************************************************
< *       Fast Session Transfer Request 8.5.21.2
< **************************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstSetupRequest);
< 
< ExtFstSetupRequest::ExtFstSetupRequest ()
< {
<   m_dialogToken = 0;
<   m_llt = 0;
< }
< 
< TypeId
< ExtFstSetupRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstSetupRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstSetupRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstSetupRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtFstSetupRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", LLT = " << m_llt;
< }
< 
< uint32_t
< ExtFstSetupRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 4; //LLT
<   size += m_sessionTransition.GetSerializedSize ();
<   if (m_multiBand != 0)
<     size += m_multiBand->GetSerializedSize ();
<   if (m_wakeupSchedule != 0)
<     size += m_wakeupSchedule->GetSerializedSize ();
<   if (m_awakeWindow != 0)
<     size += m_awakeWindow->GetSerializedSize ();
<   if (m_switchingStream != 0)
<     size += m_switchingStream->GetSerializedSize ();
< 
<   return size;
< }
< 
< void
< ExtFstSetupRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU32 (m_llt);
<   i = m_sessionTransition.Serialize (i);
<   if (m_multiBand != 0)
<     {
<       i = m_multiBand->Serialize (i);
<     }
<   if (m_wakeupSchedule != 0)
<     {
<       i = m_wakeupSchedule->Serialize (i);
<     }
<   if (m_awakeWindow != 0)
<     {
<       i = m_awakeWindow->Serialize (i);
<     }
<   if (m_switchingStream != 0)
<     {
<       i = m_switchingStream->Serialize (i);
<     }
< }
< 
< uint32_t
< ExtFstSetupRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   m_llt = i.ReadLsbtohU32 ();
<   i = m_sessionTransition.Deserialize (i);
<   if (m_multiBand != 0)
<     {
<       i = m_multiBand->DeserializeIfPresent (i);
<     }
<   if (m_wakeupSchedule != 0)
<     {
<       i = m_wakeupSchedule->DeserializeIfPresent (i);
<     }
<   if (m_awakeWindow != 0)
<     {
<       i = m_awakeWindow->DeserializeIfPresent (i);
<     }
<   if (m_switchingStream != 0)
<     {
<       i = m_switchingStream->DeserializeIfPresent (i);
<     }
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtFstSetupRequest::SetLlt (uint32_t llt)
< {
<   m_llt = llt;
< }
< 
< uint32_t
< ExtFstSetupRequest::GetLlt (void) const
< {
<   return m_llt;
< }
< 
< /*************************************************************
< *          Fast Session Transfer Response 8.5.21.3
< **************************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstSetupResponse);
< 
< ExtFstSetupResponse::ExtFstSetupResponse ()
< {
<   m_dialogToken = 0;
<   m_statusCode = 0;
< }
< 
< TypeId
< ExtFstSetupResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstSetupResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstSetupResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstSetupResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtFstSetupResponse::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Status Code = " << m_statusCode;
< }
< 
< uint32_t
< ExtFstSetupResponse::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 2; //Status Code
<   size += m_sessionTransition.GetSerializedSize ();
<   if (m_multiBand != 0)
<     size += m_multiBand->GetSerializedSize ();
<   if (m_wakeupSchedule != 0)
<     size += m_wakeupSchedule->GetSerializedSize ();
<   if (m_awakeWindow != 0)
<     size += m_awakeWindow->GetSerializedSize ();
<   if (m_switchingStream != 0)
<     size += m_switchingStream->GetSerializedSize ();
< 
<   return size;
< }
< 
< void
< ExtFstSetupResponse::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_statusCode);
<   i = m_sessionTransition.Serialize (i);
<   if (m_multiBand != 0)
<     i = m_multiBand->Serialize (i);
<   if (m_wakeupSchedule != 0)
<     i = m_wakeupSchedule->Serialize (i);
<   if (m_awakeWindow != 0)
<     i = m_awakeWindow->Serialize (i);
<   if (m_switchingStream != 0)
<     i = m_switchingStream->Serialize (i);
< }
< 
< uint32_t
< ExtFstSetupResponse::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   m_statusCode = i.ReadLsbtohU16 ();
<   i = m_sessionTransition.Deserialize (i);
<   if (m_multiBand != 0)
<     {
<       i = m_multiBand->DeserializeIfPresent (i);
<     }
<   if (m_wakeupSchedule != 0)
<     {
<       i = m_wakeupSchedule->DeserializeIfPresent (i);
<     }
<   if (m_awakeWindow != 0)
<     {
<       i = m_awakeWindow->DeserializeIfPresent (i);
<     }
<   if (m_switchingStream != 0)
<     {
<       i = m_switchingStream->DeserializeIfPresent (i);
<     }
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtFstSetupResponse::SetStatusCode (uint16_t status)
< {
<   m_statusCode = status;
< }
< 
< uint16_t
< ExtFstSetupResponse::GetStatusCode (void) const
< {
<   return m_statusCode;
< }
< 
< /***************************************************
< *     Fast Session Transfer Tear Down 8.5.21.4
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstTearDown);
< 
< ExtFstTearDown::ExtFstTearDown ()
<   : m_fstsID (0)
< {
< }
< 
< TypeId
< ExtFstTearDown::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstTearDown")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstTearDown> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstTearDown::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtFstTearDown::Print (std::ostream &os) const
< {
<   os << "FSTS ID = " << m_fstsID;
< }
< 
< uint32_t
< ExtFstTearDown::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 4; //FSTS ID
<   return size;
< }
< 
< void
< ExtFstTearDown::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteHtolsbU32 (m_fstsID);
< }
< 
< uint32_t
< ExtFstTearDown::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_fstsID = i.ReadLsbtohU32 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtFstTearDown::SetFstsID (uint32_t id)
< {
<   m_fstsID = id;
< }
< 
< uint32_t
< ExtFstTearDown::GetFstsID (void) const
< {
<   return m_fstsID;
< }
< 
< /***************************************************
< *     Fast Session Transfer Ack Request 8.5.21.5
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstAckRequest);
< 
< ExtFstAckRequest::ExtFstAckRequest ()
<   : m_dialogToken (0),
<     m_fstsID (0)
< {
< }
< 
< TypeId
< ExtFstAckRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstAckRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstAckRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstAckRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtFstAckRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", FSTS ID = " << m_fstsID;
< }
< 
< uint32_t
< ExtFstAckRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += 4; //FSTS ID
<   return size;
< }
< 
< void
< ExtFstAckRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU32 (m_fstsID);
< }
< 
< uint32_t
< ExtFstAckRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   m_fstsID = i.ReadLsbtohU32 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtFstAckRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtFstAckRequest::SetFstsID (uint32_t id)
< {
<   m_fstsID = id;
< }
< 
< uint8_t
< ExtFstAckRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint32_t
< ExtFstAckRequest::GetFstsID (void) const
< {
<   return m_fstsID;
< }
< 
< /***************************************************
< *     Fast Session Transfer Ack Response 8.5.21.6
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstAckResponse);
< 
< TypeId
< ExtFstAckResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstAckResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstAckResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstAckResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< /***************************************************
< *             Announce Frame (8.5.22.2)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtAnnounceFrame);
< 
< ExtAnnounceFrame::ExtAnnounceFrame ()
<   : m_timestamp (0),
<     m_beaconInterval (0)
< {
< }
< 
< TypeId
< ExtAnnounceFrame::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtAnnounceFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtAnnounceFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtAnnounceFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtAnnounceFrame::Print (std::ostream &os) const
< {
<   os << "Timestamp = " << m_timestamp << "|"
<      << "BeaconInterval = " << m_beaconInterval;
<   PrintInformationElements (os);
< }
< 
< uint32_t
< ExtAnnounceFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Timestamp
<   size += 2; //Beacon Interval
<   size += GetInformationElementsSerializedSize ();
<   return size;
< }
< 
< void
< ExtAnnounceFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_timestamp);
<   i.WriteHtolsbU16 (m_beaconInterval);
<   i = SerializeInformationElements (i);
< }
< 
< uint32_t
< ExtAnnounceFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_timestamp = i.ReadU8 ();
<   m_beaconInterval = i.ReadLsbtohU16 ();
<   i = DeserializeInformationElements (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtAnnounceFrame::SetTimestamp (uint8_t timestamp)
< {
<   m_timestamp = timestamp;
< }
< 
< void
< ExtAnnounceFrame::SetBeaconInterval (uint16_t interval)
< {
<   m_beaconInterval = interval;
< }
< 
< uint8_t
< ExtAnnounceFrame::GetTimestamp (void) const
< {
<   return m_timestamp;
< }
< 
< uint16_t
< ExtAnnounceFrame::GetBeaconInterval (void) const
< {
<   return m_beaconInterval;
< }
< 
< /***************************************************
< *               BRP Frame (8.5.22.3)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtBrpFrame);
< 
< ExtBrpFrame::ExtBrpFrame ()
< {
< }
< 
< TypeId
< ExtBrpFrame::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtBrpFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtBrpFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtBrpFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtBrpFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtBrpFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_brpRequestField.GetSerializedSize ();
<   size += m_beamRefinementElement.GetSerializedSize ();
<   for (ChannelMeasurementFeedbackElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       size += (*iter)->GetSerializedSize ();
<     }
<   if (m_partialSlsElement != 0)
<     size += m_partialSlsElement->GetSerializedSize ();
<   if (m_edmgBrpRequestElement != 0)
<     size += m_edmgBrpRequestElement->GetSerializedSize ();
<   for (EDMGChannelMeasurementFeedbackElementList::const_iterator iter = m_edmgList.begin (); iter != m_edmgList.end (); iter++)
<     {
<       size += (*iter)->GetSerializedSize ();
<     }
< 
<   return size;
< }
< 
< void
< ExtBrpFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_brpRequestField.Serialize (i);
<   i = m_beamRefinementElement.Serialize (i);
<   for (ChannelMeasurementFeedbackElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       i = (*iter)->Serialize (i);
<     }
<   if (m_partialSlsElement != 0)
<     i = m_partialSlsElement->Serialize (i);
<   if (m_edmgBrpRequestElement != 0)
<     i = m_edmgBrpRequestElement->Serialize (i);
<   for (EDMGChannelMeasurementFeedbackElementList::const_iterator iter = m_edmgList.begin (); iter != m_edmgList.end (); iter++)
<     {
<       i = (*iter)->Serialize (i);
<     }
< }
< 
< uint32_t
< ExtBrpFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Buffer::Iterator m;
< 
<   m_dialogToken = i.ReadU8 ();
<   i = m_brpRequestField.Deserialize (i);
<   i = m_beamRefinementElement.Deserialize (i);
< 
<   uint16_t numberOfMeasurements;
<   uint16_t currentMeasurements;
< 
<   /* Calculate the limit of the number of measurements that can fit within a single Channel Measurement/ EDMG Channel Measurement feedback element,
<    * considering that each information element has a maximum size of 255 bytes. */
< 
<   // Calculate the size of a single measurement according to the fields that are present
<   uint8_t channelMeasurementSize = 0;
<   uint8_t edmgChannelMeasurementSize = 0;
< 
<   if (m_beamRefinementElement.IsSnrPresent ())
<     channelMeasurementSize += 1;
<   if (m_beamRefinementElement.IsChannelMeasurementPresent ())
<     {
<       uint8_t tapSize;
<       switch (m_beamRefinementElement.GetNumberOfTapsPresent ()) {
<         case TAPS_1:
<           tapSize = 2;
<           break;
<         case TAPS_5:
<           tapSize = 5 * 2;
<           break;
<         case TAPS_15:
<           tapSize = 15 * 2;
<           break;
<         case TAPS_63:
<           tapSize = 63 * 2;
<           break;
<         default:
<           NS_FATAL_ERROR ("Value for Number of Taps present is not allowed");
<           break;
<         }
<       channelMeasurementSize += tapSize;
<     }
<   if (m_beamRefinementElement.IsSectorIdOrderPresent ())
<     {
<       if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<         edmgChannelMeasurementSize += 3;
<       else
<         channelMeasurementSize += 1;
<     }
<   if (m_beamRefinementElement.GetSectorSweepFrameType () == BRP_FRAME && m_beamRefinementElement.GetEdmgExtensionFlag ())
<     edmgChannelMeasurementSize += 1;
< 
<   // Calculate the additional space taken within the element by other fields
<   uint8_t channelAdditionalSize = 2;
<   uint8_t edmgChannelAdditionalSize = 0;
< 
<   if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<     edmgChannelAdditionalSize += 3;
< 
<   if (m_beamRefinementElement.IsTapDelayPresent ())
<     {
<       uint8_t tapSize;
<       switch (m_beamRefinementElement.GetNumberOfTapsPresent ()) {
<         case TAPS_1:
<           tapSize = 1;
<           break;
<         case TAPS_5:
<           tapSize = 5;
<           break;
<         case TAPS_15:
<           tapSize = 15;
<           break;
<         case TAPS_63:
<           tapSize = 63;
<           break;
<         default:
<           NS_FATAL_ERROR ("Value for Number of Taps present is not allowed");
<           break;
<         }
<       if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<         edmgChannelAdditionalSize += (tapSize * 2);
<       else
<         channelAdditionalSize += (tapSize * 1);
<     }
< 
<   // Calculate the maximum number of measurements within one element (Note: for simplicity we assume that we have the same number of channel and
<   // EDMG channel measurement feedback elements, so we calculate this according to the element that fits less measurements)
<   uint8_t maxMeasurements = 0;
<   if (channelMeasurementSize > 0)
<     {
<       maxMeasurements = (255 - channelAdditionalSize) / channelMeasurementSize;
<     }
<   if (edmgChannelMeasurementSize > 0)
<     {
<       uint8_t edmgMaxMeasurements = (255 - edmgChannelAdditionalSize) / edmgChannelMeasurementSize;
<       if (edmgMaxMeasurements < maxMeasurements)
<         maxMeasurements = edmgMaxMeasurements;
<     }
< 
<   // Deserialize the channel/EDMG channel measurement feedback elements
<   if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<     {
<       numberOfMeasurements = m_beamRefinementElement.GetExtendedNumberOfMeasurements ();
<     }
<   else
<     {
<       numberOfMeasurements = m_beamRefinementElement.GetNumberOfMeasurements ();
<     }
< 
<   /* Deserialize Channel Measurement Feedback Elements */
<   while (numberOfMeasurements != 0)
<     {
<       Ptr<ChannelMeasurementFeedbackElement> channelMeasurement = Create<ChannelMeasurementFeedbackElement> ();
<       if (numberOfMeasurements > maxMeasurements)
<         currentMeasurements = maxMeasurements;
<       else
<         currentMeasurements = numberOfMeasurements;
<       numberOfMeasurements -= currentMeasurements;
<       if (m_beamRefinementElement.IsSnrPresent ())
<         {
<           channelMeasurement->SetSnrListSize (currentMeasurements);
<         }
<       if (m_beamRefinementElement.IsChannelMeasurementPresent ())
<         {
<           channelMeasurement->SetChannelMeasurementSize (currentMeasurements);
<           channelMeasurement->SetTapComponentsSize (m_beamRefinementElement.GetNumberOfTapsPresent ());
<         }
<       if (m_beamRefinementElement.IsTapDelayPresent () && (!m_beamRefinementElement.GetEdmgExtensionFlag ()))
<         {
<            channelMeasurement->SetTapsDelaySize (m_beamRefinementElement.GetNumberOfTapsPresent ());
<         }
<       if (m_beamRefinementElement.IsSectorIdOrderPresent ()  && (!m_beamRefinementElement.GetEdmgExtensionFlag ()))
<         {
<            channelMeasurement->SetSectorIdSize (currentMeasurements);
<         }
<      m = i;
<      i = channelMeasurement->DeserializeIfPresent (i);
<      if (i.GetDistanceFrom (m) != 0)
<        {
<          m_list.push_back (channelMeasurement);
<        }
<      else
<        {
<          break;
<        }
<    }
< 
<   m_partialSlsElement = Create<EdmgPartialSectorLevelSweep> ();
<   i = m_partialSlsElement->DeserializeIfPresent (i);
<   m_edmgBrpRequestElement = Create<EdmgBrpRequestElement> ();
<   i = m_edmgBrpRequestElement->DeserializeIfPresent (i);
<   /* Deserialize EDMG Channel Measurement Feedback Elements */
<   if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<     {
<       numberOfMeasurements = m_beamRefinementElement.GetExtendedNumberOfMeasurements ();
<       while (numberOfMeasurements != 0)
<         {
<           Ptr<EDMGChannelMeasurementFeedbackElement> edmgChannelMeasurement = Create<EDMGChannelMeasurementFeedbackElement> ();
<           if (numberOfMeasurements > maxMeasurements)
<             currentMeasurements = maxMeasurements;
<           else
<             currentMeasurements = numberOfMeasurements;
<           numberOfMeasurements -= currentMeasurements;
<           if (m_beamRefinementElement.IsTapDelayPresent ())
<             {
<                edmgChannelMeasurement->SetTapsDelaySize (m_beamRefinementElement.GetNumberOfTapsPresent ());
<             }
<           if (m_beamRefinementElement.IsSectorIdOrderPresent ())
<             {
<                edmgChannelMeasurement->SetSectorIdOrderSize (currentMeasurements);
<             }
<          if (m_beamRefinementElement.GetSectorSweepFrameType () == BRP_FRAME)
<            {
<              edmgChannelMeasurement->SetBrpCdownSize (currentMeasurements);
<            }
<          m = i;
<          i = edmgChannelMeasurement->DeserializeIfPresent (i);
<          if (i.GetDistanceFrom (m) != 0)
<            {
<              m_edmgList.push_back (edmgChannelMeasurement);
<            }
<          else
<            {
<              break;
<            }
<         }
<     }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtBrpFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtBrpFrame::SetBrpRequestField (BRP_Request_Field &field)
< {
<   m_brpRequestField = field;
< }
< 
< void
< ExtBrpFrame::SetBeamRefinementElement (BeamRefinementElement &element)
< {
<   m_beamRefinementElement = element;
< }
< 
< void
< ExtBrpFrame::AddChannelMeasurementFeedback (ChannelMeasurementFeedbackElement *element)
< {
<   m_list.push_back (element);
< }
< 
< 
< void
< ExtBrpFrame::SetEdmgPartialSlsElement (EdmgPartialSectorLevelSweep *element)
< {
<   m_partialSlsElement = element;
< }
< 
< void
< ExtBrpFrame::SetEdmgBrpRequestElement (EdmgBrpRequestElement *element)
< {
<   m_edmgBrpRequestElement = element;
< }
< 
< void
< ExtBrpFrame::AddEdmgChannelMeasurementFeedback (EDMGChannelMeasurementFeedbackElement *element)
< {
<   m_edmgList.push_back (element);
< }
< 
< uint8_t
< ExtBrpFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< BRP_Request_Field
< ExtBrpFrame::GetBrpRequestField (void) const
< {
<   return m_brpRequestField;
< }
< 
< BeamRefinementElement
< ExtBrpFrame::GetBeamRefinementElement (void) const
< {
<   return m_beamRefinementElement;
< }
< 
< ChannelMeasurementFeedbackElementList
< ExtBrpFrame::GetChannelMeasurementFeedbackList (void) const
< {
<   return m_list;
< }
< 
< Ptr<EdmgPartialSectorLevelSweep>
< ExtBrpFrame::GetEdmgPartialSlsElement (void) const
< {
<   return m_partialSlsElement;
< }
< 
< Ptr<EdmgBrpRequestElement>
< ExtBrpFrame::GetEdmgBrpRequestElement(void) const
< {
<   return m_edmgBrpRequestElement;
< }
< 
< EDMGChannelMeasurementFeedbackElementList
< ExtBrpFrame::GetEdmgChannelMeasurementFeedbackList (void) const
< {
<   return m_edmgList;
< }
< 
< 
< /***************************************************
< *          MIMO BF Setup frame (9.6.21.4)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMimoBfSetupFrame);
< 
< ExtMimoBfSetupFrame::ExtMimoBfSetupFrame ()
< {
< }
< 
< TypeId
< ExtMimoBfSetupFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::ExtMimoBfSetupFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMimoBfSetupFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMimoBfSetupFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMimoBfSetupFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMimoBfSetupFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_mimoSetupControl.GetSerializedSize ();
<   return size;
< }
< 
< void
< ExtMimoBfSetupFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_mimoSetupControl.Serialize (i);
< }
< 
< uint32_t
< ExtMimoBfSetupFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_mimoSetupControl.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMimoBfSetupFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMimoBfSetupFrame::SetMimoSetupControlElement (MimoSetupControlElement element)
< {
<   m_mimoSetupControl = element;
< }
< 
< uint8_t
< ExtMimoBfSetupFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< MimoSetupControlElement
< ExtMimoBfSetupFrame::GetMimoSetupControlElement (void) const
< {
<   return m_mimoSetupControl;
< }
< 
< /***************************************************
< *          MIMO BF Poll frame (9.6.21.5)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMimoBfPollFrame);
< 
< ExtMimoBfPollFrame::ExtMimoBfPollFrame ()
< {
< }
< 
< TypeId
< ExtMimoBfPollFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::ExtMimoBfPollFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMimoBfPollFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMimoBfPollFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMimoBfPollFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMimoBfPollFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_mimoPollControl.GetSerializedSize ();
<   return size;
< }
< 
< void
< ExtMimoBfPollFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_mimoPollControl.Serialize (i);
< }
< 
< uint32_t
< ExtMimoBfPollFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_mimoPollControl.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMimoBfPollFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMimoBfPollFrame::SetMimoPollControlElement (MimoPollControlElement element)
< {
<   m_mimoPollControl = element;
< }
< 
< uint8_t
< ExtMimoBfPollFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< MimoPollControlElement
< ExtMimoBfPollFrame::GetMimoSetupControlElement (void) const
< {
<   return m_mimoPollControl;
< }
< 
< /***************************************************
< *          MIMO BF Feedback frame (9.6.21.6)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMimoBfFeedbackFrame);
< 
< ExtMimoBfFeedbackFrame::ExtMimoBfFeedbackFrame ()
< {
< }
< 
< TypeId
< ExtMimoBfFeedbackFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::ExtMimoBfFeedbackFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMimoBfFeedbackFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMimoBfFeedbackFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMimoBfFeedbackFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMimoBfFeedbackFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_mimoFeedbackControl.GetSerializedSize ();
<   for (ChannelMeasurementFeedbackElementListCI it = m_channelMeasurementFeedbackList.begin ();
<        it != m_channelMeasurementFeedbackList.end (); it++)
<     {
<       size += (*it)->GetSerializedSize ();
<     }
<   for (EDMGChannelMeasurementFeedbackElementListCI it = m_edmgChannelMeasurementFeedbackList.begin ();
<        it != m_edmgChannelMeasurementFeedbackList.end (); it++)
<     {
<       size += (*it)->GetSerializedSize ();
<     }
<   for (DigitalBFFeedbackElementListCI it = m_digitalBFFeedbackElementList.begin ();
<        it != m_digitalBFFeedbackElementList.end (); it++)
<     {
<       size += (*it)->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< ExtMimoBfFeedbackFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   /* Serialize MIMO Feedback Control element */
<   i = m_mimoFeedbackControl.Serialize (i);
< 
<   /* Serialize Channel Measurement Feedback elements */
<   for (ChannelMeasurementFeedbackElementListCI it = m_channelMeasurementFeedbackList.begin ();
<        it != m_channelMeasurementFeedbackList.end (); it++)
<     {
<       i = (*it)->Serialize (i);
<     }
< 
<   /* Serialize EDMG Channel Measurement Feedback elements */
<   for (EDMGChannelMeasurementFeedbackElementListCI it = m_edmgChannelMeasurementFeedbackList.begin ();
<        it != m_edmgChannelMeasurementFeedbackList.end (); it++)
<     {
<       i = (*it)->Serialize (i);
<     }
< 
<   /* Serialize Digital BF Feedback elements */
<   for (DigitalBFFeedbackElementListCI it = m_digitalBFFeedbackElementList.begin ();
<        it != m_digitalBFFeedbackElementList.end (); it++)
<     {
<       i = (*it)->Serialize (i);
<     }
< }
< 
< uint32_t
< ExtMimoBfFeedbackFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Buffer::Iterator m;
< 
<   m_dialogToken = i.ReadU8 ();
<   i = m_mimoFeedbackControl.Deserialize (i);
< 
<   uint8_t channelMeasurementSize = 1;
<   uint8_t edmgChannelMeasurementSize = 4;
<   if (m_mimoFeedbackControl.IsChannelMeasurementPresent ())
<     {
<       uint8_t tapSize;
<       switch (m_mimoFeedbackControl.GetNumberOfTapsPresent ()) {
<         case TAPS_1:
<           tapSize = 2;
<           break;
<         case TAPS_5:
<           tapSize = 5 * 2;
<           break;
<         case TAPS_15:
<           tapSize = 15 * 2;
<           break;
<         case TAPS_63:
<           tapSize = 63 * 2;
<           break;
<         default:
<           NS_FATAL_ERROR ("Value for Number of Taps present is not allowed");
<           break;
<         }
<       channelMeasurementSize += tapSize;
<     }
< 
<   // Calculate the additional space taken within the element by other fields
<   uint8_t channelAdditionalSize = 2;
<   uint8_t edmgChannelAdditionalSize = 3;
< 
<   if (m_mimoFeedbackControl.IsTapDelayPresent ())
<     {
<       uint8_t tapSize;
<       switch (m_mimoFeedbackControl.GetNumberOfTapsPresent ()) {
<         case TAPS_1:
<           tapSize = 1 * 2;
<           break;
<         case TAPS_5:
<           tapSize = 5 * 2;
<           break;
<         case TAPS_15:
<           tapSize = 15 * 2;
<           break;
<         case TAPS_63:
<           tapSize = 63 * 2;
<           break;
<         default:
<           NS_FATAL_ERROR ("Value for Number of Taps present is not allowed");
<           break;
<         }
<         edmgChannelAdditionalSize += tapSize;
<     }
< 
<   // Calculate the maximum number of measurements within one element (Note: for simplicity we assume that we have the same number of channel and
<   // EDMG channel measurement feedback elements, so we calculate this according to the element that fits less measurements)
<   uint8_t maxMeasurements = (255 - channelAdditionalSize) / channelMeasurementSize;
<   uint8_t edmgMaxMeasurements = (255 - edmgChannelAdditionalSize) / edmgChannelMeasurementSize;
<   if (edmgMaxMeasurements < maxMeasurements)
<      maxMeasurements = edmgMaxMeasurements;
< 
<   // Deserialize the channel/EDMG channel measurement feedback elements
<   uint8_t rxAntennas = m_mimoFeedbackControl.GetNumberOfRxAntennas ();
<   uint8_t txAntennas = m_mimoFeedbackControl.GetNumberOfTxAntennas ();
<   uint16_t numberOfMeasurements = m_mimoFeedbackControl.GetNumberOfTXSectorCombinationsPresent ()
<           * rxAntennas * txAntennas;
<   uint8_t currentMeasurements = 0;
<   /* Deserialize Channel Measurement Feedback Elements */
<   while (numberOfMeasurements != 0)
<     {
<       Ptr<ChannelMeasurementFeedbackElement> channelMeasurement = Create<ChannelMeasurementFeedbackElement> ();
<       if (numberOfMeasurements > maxMeasurements)
<         currentMeasurements = (maxMeasurements / ( txAntennas * rxAntennas )) * (txAntennas * rxAntennas);
<       else
<         currentMeasurements = numberOfMeasurements;
<       numberOfMeasurements -= currentMeasurements;
<       channelMeasurement->SetSnrListSize (currentMeasurements);
<       if (m_mimoFeedbackControl.IsChannelMeasurementPresent ())
<         {
<           channelMeasurement->SetChannelMeasurementSize (currentMeasurements);
<           channelMeasurement->SetTapComponentsSize (m_mimoFeedbackControl.GetNumberOfTapsPresent ());
<         }
<      m = i;
<      i = channelMeasurement->DeserializeIfPresent (i);
<      if (i.GetDistanceFrom (m) != 0)
<        {
<          m_channelMeasurementFeedbackList.push_back (channelMeasurement);
<        }
<      else
<        {
<          break;
<        }
<    }
<   /* Deserialize EDMG Channel Measurement Feedback Elements */
<   numberOfMeasurements = m_mimoFeedbackControl.GetNumberOfTXSectorCombinationsPresent ()
<           * m_mimoFeedbackControl.GetNumberOfRxAntennas ()
<           * m_mimoFeedbackControl.GetNumberOfTxAntennas ();
<   currentMeasurements = 0;
<   while (numberOfMeasurements != 0)
<     {
<       Ptr<EDMGChannelMeasurementFeedbackElement> edmgChannelMeasurement = Create<EDMGChannelMeasurementFeedbackElement> ();
< 
<       if (numberOfMeasurements > maxMeasurements)
<         currentMeasurements = (maxMeasurements / ( txAntennas * rxAntennas )) * (txAntennas * rxAntennas);
<       else
<          currentMeasurements = numberOfMeasurements;
<       numberOfMeasurements -= currentMeasurements;
<       if (m_mimoFeedbackControl.IsTapDelayPresent ())
<          {
<            edmgChannelMeasurement->SetTapsDelaySize (m_mimoFeedbackControl.GetNumberOfTapsPresent ());
<          }
<       edmgChannelMeasurement->SetSectorIdOrderSize (currentMeasurements);
<       edmgChannelMeasurement->SetBrpCdownSize (currentMeasurements);
<       m = i;
<       i = edmgChannelMeasurement->DeserializeIfPresent (i);
<       if (i.GetDistanceFrom (m) != 0)
<         {
<            m_edmgChannelMeasurementFeedbackList.push_back (edmgChannelMeasurement);
<         }
<       else
<         {
<           break;
<         }
<     }
<   // To do: Add deserialization for Digital Feedback
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMimoBfFeedbackFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMimoBfFeedbackFrame::SetMimoFeedbackControlElement (MIMOFeedbackControl &element)
< {
<   m_mimoFeedbackControl = element;
< }
< 
< void
< ExtMimoBfFeedbackFrame::AddChannelMeasurementFeedbackElement (Ptr<ChannelMeasurementFeedbackElement> element)
< {
<   m_channelMeasurementFeedbackList.push_back (element);
< }
< 
< void
< ExtMimoBfFeedbackFrame::AddEdmgChannelMeasurementFeedbackElement (Ptr<EDMGChannelMeasurementFeedbackElement> element)
< {
<   m_edmgChannelMeasurementFeedbackList.push_back (element);
< }
< 
< void
< ExtMimoBfFeedbackFrame::AddDigitalBfFeedbackElement (Ptr<DigitalBFFeedbackElement> element)
< {
<   m_digitalBFFeedbackElementList.push_back (element);
< }
< 
< uint8_t
< ExtMimoBfFeedbackFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< MIMOFeedbackControl
< ExtMimoBfFeedbackFrame::GetMimoFeedbackControlElement (void) const
< {
<   return m_mimoFeedbackControl;
< }
< 
< ChannelMeasurementFeedbackElementList
< ExtMimoBfFeedbackFrame::GetListOfChannelMeasurementFeedback (void) const
< {
<   return m_channelMeasurementFeedbackList;
< }
< 
< EDMGChannelMeasurementFeedbackElementList
< ExtMimoBfFeedbackFrame::GetListOfEDMGChannelMeasurementFeedback (void) const
< {
<   return m_edmgChannelMeasurementFeedbackList;
< }
< 
< DigitalBFFeedbackElementList
< ExtMimoBfFeedbackFrame::GetListOfDigitalBFFeedbackElement (void) const
< {
<   return m_digitalBFFeedbackElementList;
< }
< 
< /***************************************************
< *          MIMO BF Poll frame (9.6.21.7)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMimoBFSelectionFrame);
< 
< ExtMimoBFSelectionFrame::ExtMimoBFSelectionFrame ()
< {
< }
< 
< TypeId
< ExtMimoBFSelectionFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::ExtMimoBFSelectionFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMimoBFSelectionFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMimoBFSelectionFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMimoBFSelectionFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMimoBFSelectionFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_mimoSelectionControlElement.GetSerializedSize ();
<   size += m_edmgGroupIDSetElement.GetSerializedSize ();
<   return size;
< }
< 
< void
< ExtMimoBFSelectionFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_mimoSelectionControlElement.Serialize (i);
<   i = m_edmgGroupIDSetElement.Serialize (i);
< }
< 
< uint32_t
< ExtMimoBFSelectionFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_mimoSelectionControlElement.Deserialize (i);
<   i = m_edmgGroupIDSetElement.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMimoBFSelectionFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMimoBFSelectionFrame::SetMIMOSelectionControlElement (MIMOSelectionControlElement &element)
< {
<   m_mimoSelectionControlElement = element;
< }
< 
< void
< ExtMimoBFSelectionFrame::SetEDMGGroupIDSetElement (EDMGGroupIDSetElement &element)
< {
<   m_edmgGroupIDSetElement = element;
< }
< 
< uint8_t
< ExtMimoBFSelectionFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< MIMOSelectionControlElement
< ExtMimoBFSelectionFrame::GetMIMOSelectionControlElement (void) const
< {
<   return m_mimoSelectionControlElement;
< }
< 
< EDMGGroupIDSetElement
< ExtMimoBFSelectionFrame::GetEDMGGroupIDSetElement (void) const
< {
<   return m_edmgGroupIDSetElement;
diff ../../NS3-WiGig/src/wifi/model/mgt-headers.h ../../ns-3-dev/src/wifi/model/mgt-headers.h
5d4
<  * Copyright (c) 2015-2020 IMDEA Networks Institute
22d20
<  *          Hany Assasa <hany.assasa@gmail.com>
31d28
< #include "ns3/mac48-address.h"
37d33
< #include "extended-capabilities.h"
39c35
< #include "ht-operation.h"
---
> #include "ht-operations.h"
41d36
< #include "vht-operation.h"
44,54d38
< #include "he-capabilities.h"
< #include "he-operation.h"
< #include "cf-parameter-set.h"
< //// WIGIG ////
< #include "common-header.h"
< #include "ctrl-headers.h"
< #include "dmg-capabilities.h"
< #include "dmg-information-elements.h"
< #include "ext-headers.h"
< #include "fields-headers.h"
< //// WIGIG ////
62c46
< class MgtAssocRequestHeader : public Header, public MgtFrame
---
> class MgtAssocRequestHeader : public Header
92a77,88
>    * Set the HT capabilities.
>    *
>    * \param htcapabilities HT capabilities
>    */
>   void SetHtCapabilities (HtCapabilities htcapabilities);
>   /**
>    * Set the VHT capabilities.
>    *
>    * \param vhtcapabilities VHT capabilities
>    */
>   void SetVhtCapabilities (VhtCapabilities vhtcapabilities);
>   /**
98a95,106
>    * Return the HT capabilities.
>    *
>    * \return HT capabilities
>    */
>   HtCapabilities GetHtCapabilities (void) const;
>   /**
>    * Return the VHT capabilities.
>    *
>    * \return VHT capabilities
>    */
>   VhtCapabilities GetVhtCapabilities (void) const;
>   /**
122,126c130,134
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
133c141,143
<   uint16_t m_listenInterval;          //!< listen interval
---
>   HtCapabilities m_htCapability;      //!< HT capabilities
>   VhtCapabilities m_vhtCapability;    //!< VHT capabilities
>   uint16_t m_listenInterval;
139c149
<  * Implement the header for management frames of type reassociation request.
---
>  * Implement the header for management frames of type association response.
141c151
< class MgtReassocRequestHeader : public Header, public MgtFrame
---
> class MgtAssocResponseHeader : public Header
144,145c154,155
<   MgtReassocRequestHeader ();
<   ~MgtReassocRequestHeader ();
---
>   MgtAssocResponseHeader ();
>   ~MgtAssocResponseHeader ();
148c158
<    * Set the Service Set Identifier (SSID).
---
>    * Return the status code.
150c160
<    * \param ssid SSID
---
>    * \return the status code
152c162
<   void SetSsid (Ssid ssid);
---
>   StatusCode GetStatusCode (void);
154c164
<    * Set the supported rates.
---
>    * Return the supported rates.
156c166
<    * \param rates the supported rates
---
>    * \return the supported rates
158c168
<   void SetSupportedRates (SupportedRates rates);
---
>   SupportedRates GetSupportedRates (void);
160c170
<    * Set the listen interval.
---
>    * Return the Capability information.
162c172
<    * \param interval the listen interval
---
>    * \return Capability information
164c174
<   void SetListenInterval (uint16_t interval);
---
>   CapabilityInformation GetCapabilities (void) const;
172c182
<    * Return the Capability information.
---
>    * Return the HT capabilities.
174c184
<    * \return Capability information
---
>    * \return HT capabilities
176c186
<   CapabilityInformation GetCapabilities (void) const;
---
>   HtCapabilities GetHtCapabilities (void) const;
178c188
<    * Return the Service Set Identifier (SSID).
---
>    * Return the HT operations.
180c190
<    * \return SSID
---
>    * \return HT operations
182c192
<   Ssid GetSsid (void) const;
---
>   HtOperations GetHtOperations (void) const;
184c194
<    * Return the supported rates.
---
>    * Return the ERP information.
186c196
<    * \return the supported rates
---
>    * \return the ERP information
188c198
<   SupportedRates GetSupportedRates (void) const;
---
>   ErpInformation GetErpInformation (void) const;
190c200
<    * Return the listen interval.
---
>    * Return the EDCA Parameter Set.
192c202
<    * \return the listen interval
---
>    * \return the EDCA Parameter Set
194c204
<   uint16_t GetListenInterval (void) const;
---
>   EdcaParameterSet GetEdcaParameterSet (void) const;
196c206
<    * Set the address of the current access point.
---
>    * Set the VHT capabilities.
198c208
<    * \param currentApAddr address of the current access point
---
>    * \param vhtcapabilities VHT capabilities
200,201c210
<   void SetCurrentApAddress (Mac48Address currentApAddr);
< 
---
>   void SetVhtCapabilities (VhtCapabilities vhtcapabilities);
203,240c212
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
< 
< private:
<   Mac48Address m_currentApAddr;       //!< Address of the current access point
<   Ssid m_ssid;                        //!< Service Set ID (SSID)
<   SupportedRates m_rates;             //!< List of supported rates
<   CapabilityInformation m_capability; //!< Capability information
<   uint16_t m_listenInterval;          //!< listen interval
< };
< 
< 
< /**
<  * \ingroup wifi
<  * Implement the header for management frames of type association and reassociation response.
<  */
< class MgtAssocResponseHeader : public Header, public MgtFrame
< {
< public:
<   MgtAssocResponseHeader ();
<   ~MgtAssocResponseHeader ();
< 
<   /**
<    * Return the status code.
<    *
<    * \return the status code
<    */
<   StatusCode GetStatusCode (void);
<   /**
<    * Return the supported rates.
---
>    * Return the VHT capabilities.
242c214
<    * \return the supported rates
---
>    * \return VHT capabilities
244c216
<   SupportedRates GetSupportedRates (void);
---
>   VhtCapabilities GetVhtCapabilities (void) const;
246c218
<    * Return the Capability information.
---
>    * Set the HT capabilities.
248c220
<    * \return Capability information
---
>    * \param htcapabilities HT capabilities
250c222
<   CapabilityInformation GetCapabilities (void) const;
---
>   void SetHtCapabilities (HtCapabilities htcapabilities);
252c224
<    * Return the association ID.
---
>    * Set the HT operations.
254c226
<    * \return the association ID
---
>    * \param htoperations HT operations
256,262c228
<   uint16_t GetAssociationId (void) const;
<   /**
<    * Set the Capability information.
<    *
<    * \param capabilities Capability information
<    */
<   void SetCapabilities (CapabilityInformation capabilities);
---
>   void SetHtOperations (HtOperations htoperations);
276c242,248
<    * Set the association ID.
---
>    * Set the ERP information.
>    *
>    * \param erpInformation the ERP information
>    */
>   void SetErpInformation (ErpInformation erpInformation);
>   /**
>    * Set the EDCA Parameter Set.
278c250
<    * \param aid the association ID
---
>    * \param edcaParameterSet the EDCA Parameter Set
280c252
<   void SetAssociationId (uint16_t aid);
---
>   void SetEdcaParameterSet (EdcaParameterSet edcaParameterSet);
287,291c259,263
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
295,298c267,275
<   SupportedRates m_rates;                   //!< List of supported rates
<   CapabilityInformation m_capability;       //!< Capability information
<   StatusCode m_code;                        //!< Status code
<   uint16_t m_aid;                           //!< Association Identifier.
---
>   SupportedRates m_rates; //!< List of supported rates
>   CapabilityInformation m_capability; //!< Capability information
>   StatusCode m_code; //!< Status code
>   uint16_t m_aid;
>   HtCapabilities m_htCapability; //!< HT capabilities
>   HtOperations m_htOperations; //!< HT operations
>   VhtCapabilities m_vhtCapability; //!< VHT capabilities
>   ErpInformation m_erpInformation; //!< ERP information
>   EdcaParameterSet m_edcaParameterSet; //!< EDCA Parameter Set
306c283
< class MgtProbeRequestHeader : public Header, public MgtFrame
---
> class MgtProbeRequestHeader : public Header
334a312,335
>   /**
>    * Set the HT capabilities.
>    *
>    * \param htcapabilities HT capabilities
>    */
>   void SetHtCapabilities (HtCapabilities htcapabilities);
>   /**
>    * Return the HT capabilities.
>    *
>    * \return HT capabilities
>    */
>   HtCapabilities GetHtCapabilities (void) const;
>   /**
>    * Set the VHT capabilities.
>    *
>    * \param vhtcapabilities VHT capabilities
>    */
>   void SetVhtCapabilities (VhtCapabilities vhtcapabilities);
>   /**
>   * Return the VHT capabilities.
>   *
>   * \return VHT capabilities
>   */
>   VhtCapabilities GetVhtCapabilities (void) const;
341,345c342,346
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
350a352,353
>   HtCapabilities m_htCapability;   //!< HT capabilities
>   VhtCapabilities m_vhtCapability; //!< VHT capabilities
358c361
< class MgtProbeResponseHeader : public Header, public MgtFrame
---
> class MgtProbeResponseHeader : public Header
365c368
<    * Set the beacon interval in microseconds unit.
---
>    * Return the Service Set Identifier (SSID).
367c370
<    * \param us beacon interval in microseconds unit
---
>    * \return SSID
369c372,426
<   void SetBeaconIntervalUs (uint64_t us);
---
>   Ssid GetSsid (void) const;
>   /**
>    * Return the beacon interval in microseconds unit.
>    *
>    * \return beacon interval in microseconds unit
>    */
>   uint64_t GetBeaconIntervalUs (void) const;
>   /**
>    * Return the supported rates.
>    *
>    * \return the supported rates
>    */
>   SupportedRates GetSupportedRates (void) const;
>   /**
>    * Return the Capability information.
>    *
>    * \return Capability information
>    */
>   CapabilityInformation GetCapabilities (void) const;
>   /**
>    * Return the DSSS Parameter Set.
>    *
>    * \return the DSSS Parameter Set
>    */
>   DsssParameterSet GetDsssParameterSet (void) const;
>   /**
>    * Return the HT capabilities.
>    *
>    * \return HT capabilities
>    */
>   HtCapabilities GetHtCapabilities (void) const;
>   /**
>    * Return the HT operations.
>    *
>    * \return HT operations
>    */
>   HtOperations GetHtOperations (void) const;
>   /**
>    * Return the VHT capabilities.
>    *
>    * \return VHT capabilities
>    */
>   VhtCapabilities GetVhtCapabilities (void) const;
>   /**
>    * Return the ERP information.
>    *
>    * \return the ERP information
>    */
>   ErpInformation GetErpInformation (void) const;
>   /**
>    * Return the EDCA Parameter Set.
>    *
>    * \return the EDCA Parameter Set
>    */
>   EdcaParameterSet GetEdcaParameterSet (void) const;
376a434,451
>    * Set the HT capabilities.
>    *
>    * \param htcapabilities HT capabilities
>    */
>   void SetHtCapabilities (HtCapabilities htcapabilities);
>   /**
>    * Set the HT operations.
>    *
>    * \param htoperations HT operations
>    */
>   void SetHtOperations (HtOperations htoperations);
>   /**
>    * Set the VHT capabilities.
>    *
>    * \param vhtcapabilities VHT capabilities
>    */
>   void SetVhtCapabilities (VhtCapabilities vhtcapabilities);
>   /**
383c458
<    * Set the supported rates.
---
>    * Set the beacon interval in microseconds unit.
385c460
<    * \param rates the supported rates
---
>    * \param us beacon interval in microseconds unit
387,388c462
<   void SetSupportedRates (SupportedRates rates);
< 
---
>   void SetBeaconIntervalUs (uint64_t us);
390c464
<    * Return the time stamp.
---
>    * Set the supported rates.
392c466
<    * \return time stamp
---
>    * \param rates the supported rates
394c468
<   uint64_t GetTimestamp ();
---
>   void SetSupportedRates (SupportedRates rates);
396c470
<    * Return the beacon interval in microseconds unit.
---
>    * Set the DSSS Parameter Set.
398c472
<    * \return beacon interval in microseconds unit
---
>    * \param dsssParameterSet the DSSS Parameter Set
400c474
<   uint64_t GetBeaconIntervalUs (void) const;
---
>   void SetDsssParameterSet (DsssParameterSet dsssParameterSet);
402c476
<    * Return the Capability information.
---
>    * Set the ERP information.
404c478
<    * \return Capability information
---
>    * \param erpInformation the ERP information
406c480
<   CapabilityInformation GetCapabilities (void) const;
---
>   void SetErpInformation (ErpInformation erpInformation);
408c482
<    * Return the Service Set Identifier (SSID).
---
>    * Set the EDCA Parameter Set.
410c484
<    * \return SSID
---
>    * \param edcaParameterSet the EDCA Parameter Set
412c486
<   Ssid GetSsid (void) const;
---
>   void SetEdcaParameterSet (EdcaParameterSet edcaParameterSet);
414c488
<    * Return the supported rates.
---
>    * Return the time stamp.
416c490
<    * \return the supported rates
---
>    * \return time stamp
418c492
<   SupportedRates GetSupportedRates (void) const;
---
>   uint64_t GetTimestamp ();
425,429c499,503
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
437a512,517
>   DsssParameterSet m_dsssParameterSet; //!< DSSS Parameter Set
>   HtCapabilities m_htCapability;       //!< HT capabilities
>   HtOperations m_htOperations;         //!< HT operations
>   VhtCapabilities m_vhtCapability;     //!< VHT capabilities
>   ErpInformation m_erpInformation;     //!< ERP information
>   EdcaParameterSet m_edcaParameterSet; //!< EDCA Parameter Set
479d558
<   ///CategoryValue enumeration
482d560
<     QOS = 1,
484,485d561
<     PUBLIC = 4,
<     RADIO_MEASUREMENT = 5,      //Category: Radio Measurement
489,491d564
<     DMG = 16,                   //Category: DMG
<     FST = 18,                   //Category: Fast Session Transfer
<     UNPROTECTED_DMG = 20,       //Category: Unprotected DMG
497d569
<   ///SelfProtectedActionValue enumeration
507d578
<   ///MultihopActionValue enumeration
514,550d584
<   enum QosActionValue
<   {
<     ADDTS_REQUEST = 0,
<     ADDTS_RESPONSE = 1,
<     DELTS = 2,
<     SCHEDULE = 3,
<     QOS_MAP_CONFIGURE = 4,
<   };
< 
<   /**
<    * Block Ack Action field values
<    * See 802.11 Table 8-202
<    */
<   enum BlockAckActionValue
<   {
<     BLOCK_ACK_ADDBA_REQUEST = 0,
<     BLOCK_ACK_ADDBA_RESPONSE = 1,
<     BLOCK_ACK_DELBA = 2
<   };
< 
<   enum PublicActionValue
<   {
<     QAB_REQUEST = 16,
<     QAB_RESPONSE = 17,
<   };
< 
<   enum RadioMeasurementActionValue
<   {
<     RADIO_MEASUREMENT_REQUEST = 0,
<     RADIO_MEASUREMENT_REPORT = 1,
<     LINK_MEASUREMENT_REQUEST = 2,
<     LINK_MEASUREMENT_REPORT = 3,
<     NEIGHBOR_REPORT_REQUEST = 4,
<     NEIGHBOR_REPORT_RESPONSE = 5
<   };
< 
<   ///MeshActionValue enumeration
567,599c601,602
<    * DMG Action field values
<    * See 802.11ad Table 8-281b
<    */
<   enum DmgActionValue
<   {
<     DMG_POWER_SAVE_CONFIGURATION_REQUEST = 0,
<     DMG_POWER_SAVE_CONFIGURATION_RESPONSE = 1,
<     DMG_INFORMATION_REQUEST = 2,
<     DMG_INFORMATION_RESPONSE = 3,
<     DMG_HANDOVER_REQUEST = 4,
<     DMG_HANDOVER_RESPONSE = 5,
<     DMG_DTP_REQUEST = 6,
<     DMG_DTP_RESPONSE = 7,
<     DMG_RELAY_SEARCH_REQUEST = 8,
<     DMG_RELAY_SEARCH_RESPONSE = 9,
<     DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REQUEST = 10,
<     DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REPORT = 11,
<     DMG_RLS_REQUEST = 12,
<     DMG_RLS_RESPONSE = 13,
<     DMG_RLS_ANNOUNCEMENT = 14,
<     DMG_RLS_TEARDOWN = 15,
<     DMG_RELAY_ACK_REQUEST = 16,
<     DMG_RELAY_ACK_RESPONSE = 17,
<     DMG_TPA_REQUEST = 18,
<     DMG_TPA_RESPONSE = 19,
<     DMG_TPA_REPORT = 20,
<     DMG_ROC_REQUEST = 21,
<     DMG_ROC_RESPONSE = 22
<   };
< 
<   /**
<    * FST Action field values
<    * See 802.11ad Table 8-281x
---
>    * Block ACK action field values
>    * See 802.11 Table 8-202
601c604
<   enum FstActionValue
---
>   enum BlockAckActionValue
603,608c606,608
<     FST_SETUP_REQUEST = 0,
<     FST_SETUP_RESPONSE = 1,
<     FST_TEAR_DOWN = 2,
<     FST_ACK_REQUEST = 3,
<     FST_ACK_RESPONSE = 4,
<     ON_CHANNEL_TUNNEL_REQUEST = 5
---
>     BLOCK_ACK_ADDBA_REQUEST = 0,
>     BLOCK_ACK_ADDBA_RESPONSE = 1,
>     BLOCK_ACK_DELBA = 2
611,623d610
<   /**
<    * Unprotected DMG action field values
<    * See 802.11ad Table 8-281ae
<    */
<   enum UnprotectedDmgValue
<   {
<     UNPROTECTED_DMG_ANNOUNCE = 0,
<     UNPROTECTED_DMG_BRP = 1,
<     UNPROTECTED_MIMO_BF_SETUP = 2,
<     UNPROTECTED_MIMO_BF_POLL = 3,
<     UNPROTECTED_MIMO_BF_FEEDBACK = 4,
<     UNPROTECTED_MIMO_BF_SELECTION = 5,
<   };
630,640c617,621
<     QosActionValue qos;
<     BlockAckActionValue blockAck; ///< block ack
<     RadioMeasurementActionValue radioMeasurementAction;
<     PublicActionValue publicAction;
<     SelfProtectedActionValue selfProtectedAction; ///< self protected action
<     MultihopActionValue multihopAction; ///< multi hop action
<     MeshActionValue meshAction; ///< mesh action
<     DmgActionValue dmgAction;
<     FstActionValue fstAction;
<     UnprotectedDmgValue unprotectedAction;
<   } ActionValue; ///< the action value
---
>     enum MeshActionValue meshAction;
>     enum MultihopActionValue multihopAction;
>     enum SelfProtectedActionValue selfProtectedAction;
>     enum BlockAckActionValue blockAck;
>   } ActionValue;
647c628
<   void SetAction (CategoryValue type, ActionValue action);
---
>   void   SetAction (enum CategoryValue type,ActionValue action);
667,671c648,652
<   TypeId GetInstanceTypeId () const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize () const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId () const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize () const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
675,679d655
<   /**
<    * Category value to string function
<    * \param value the category value
<    * \returns the category value string
<    */
681,685d656
<   /**
<    * Self protected action value to string function
<    * \param value the protected action value
<    * \returns the self protected action value string
<    */
691,725d661
< /**
<  * \ingroup wifi
<  * Implement the header for action frames of type DMG ADDTS request.
<  */
< class DmgAddTSRequestFrame : public Header
< {
< public:
<   DmgAddTSRequestFrame ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The Dialog Token field.
<   * \param token
<   */
<   void SetDialogToken (uint8_t token);
<   void SetDmgTspecElement (DmgTspecElement &element);
< 
<   uint8_t GetDialogToken (void) const;
<   DmgTspecElement GetDmgTspec (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   DmgTspecElement m_dmgTspecElement;
< 
< };
729c665
<  * Implement the header for action frames of type DMG ADDTS request.
---
>  * Implement the header for management frames of type add block ack request.
731,773c667
< class DmgAddTSResponseFrame : public Header
< {
< public:
<   DmgAddTSResponseFrame ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The Dialog Token field.
<   * \param token
<   */
<   void SetDialogToken (uint8_t token);
<   void SetStatusCode (StatusCode status);
<   void SetTsDelay (TsDelayElement &element);
<   void SetDmgTspecElement (DmgTspecElement &element);
< 
<   uint8_t GetDialogToken (void) const;
<   StatusCode GetStatusCode (void) const;
<   TsDelayElement GetTsDelay (void) const;
<   DmgTspecElement GetDmgTspec (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   StatusCode m_status;
<   TsDelayElement m_tsDelayElement;
<   DmgTspecElement m_dmgTspecElement;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for action frames of type DELTS (8.5.3.4).
<  */
< class DelTsFrame : public Header
---
> class MgtAddBaRequestHeader : public Header
776c670
<   DelTsFrame ();
---
>   MgtAddBaRequestHeader ();
789,821d682
<   void SetReasonCode (uint16_t reason);
<   void SetDmgAllocationInfo (DmgAllocationInfo info);
< 
<   uint16_t GetReasonCode (void) const;
<   DmgAllocationInfo GetDmgAllocationInfo (void) const;
< 
< private:
<   uint8_t m_tsInfo[3];
<   uint16_t m_reasonCode;
<   DmgAllocationInfo m_dmgAllocationInfo;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for management frames of type Add Block Ack request.
<  */
< class MgtAddBaRequestHeader : public Header
< {
< public:
<   MgtAddBaRequestHeader ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
823c684
<    * Enable delayed BlockAck.
---
>    * Enable delayed Block ACK.
827c688
<    * Enable immediate BlockAck
---
>    * Enable immediate Block ACK
874c735
<    * Return whether the Block Ack policy is immediate Block Ack.
---
>    * Return whether the Block ACK policy is immediate Block ACK.
876c737
<    * \return true if immediate Block Ack is being used, false otherwise
---
>    * \return true if immediate Block ACK is being used, false otherwise
920c781
<    * \param seqControl the raw sequence control
---
>    * \param seqControl
924c785
<   uint8_t m_dialogToken;   //!< Not used for now
---
>   uint8_t m_dialogToken;   /* Not used for now */
926c787
<   uint8_t m_policy;        //!< Block Ack policy
---
>   uint8_t m_policy;        //!< Block ACK policy
936c797
<  * Implement the header for management frames of type Add Block Ack response.
---
>  * Implement the header for management frames of type add block ack response.
948,952c809,813
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
955c816
<    * Enable delayed BlockAck.
---
>    * Enable delayed Block ACK.
959c820
<    * Enable immediate BlockAck.
---
>    * Enable immediate Block ACK
1006c867
<    * Return whether the Block Ack policy is immediate Block Ack.
---
>    * Return whether the Block ACK policy is immediate Block ACK.
1008c869
<    * \return true if immediate Block Ack is being used, false otherwise
---
>    * \return true if immediate Block ACK is being used, false otherwise
1045c906
<   uint8_t m_dialogToken;   //!< Not used for now
---
>   uint8_t m_dialogToken;   /* Not used for now */
1057c918
<  * Implement the header for management frames of type Delete Block Ack.
---
>  * Implement the header for management frames of type del block ack.
1070,1074c931,935
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
1077c938
<    * Check if the initiator bit in the DELBA is set.
---
>    * Check if the initiator bit in the DELBA is setted.
1079c940
<    * \return true if the initiator bit in the DELBA is set,
---
>    * \return true if the initiator bit in the DELBA is setted,
1094c955
<   void SetTid (uint8_t tid);
---
>   void SetTid (uint8_t);
1104d964
< 
1119c979
<   uint16_t m_initiator; //!< initiator
---
>   uint16_t m_initiator;
1121,2607c981
<   uint16_t m_reasonCode; //!< Not used for now. Always set to 1: "Unspecified reason"
< };
< 
< /**
<  * \ingroup wifi
<  * The Radio Measurement Request frame uses the Action frame body format. It is transmitted by a STA
<  * requesting another STA to make one or more measurements on one or more channels.
<  */
< class RadioMeasurementRequest : public Header
< {
< public:
<   RadioMeasurementRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the radio measurement request
<    * to identify the request/report transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Number of Repetitions field contains the requested number of repetitions for all the Measurement
<    * Request elements in this frame. A value of 0 in the Number of Repetitions field indicates Measurement
<    * Request elements are executed once without repetition. A value of 65 535 in the Number of Repetitions field
<    * indicates Measurement Request elements are repeated until the measurement is cancelled or superseded.
<    * \param repetitions
<    */
<   void SetNumberOfRepetitions (uint16_t repetitions);
< 
<   void AddMeasurementRequestElement (Ptr<WifiInformationElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetNumberOfRepetitions (void) const;
<   WifiInfoElementList GetListOfMeasurementRequestElement (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_numOfRepetitions;
<   WifiInfoElementList m_list;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * The Radio Measurement Report frame uses the Action frame body format. It is transmitted by a STA in
<  * response to a Radio Measurement Request frame or by a STA providing a triggered autonomous measurement report.
<  */
< class RadioMeasurementReport : public Header
< {
< public:
<   RadioMeasurementReport ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to the value in the corresponding Radio Measurement Request frame. If the
<    * Radio Measurement Report frame is not being transmitted in response to a Radio Measurement Request
<    * frame then the Dialog token is set to 0.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   void AddMeasurementReportElement (Ptr<WifiInformationElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   WifiInfoElementList GetListOfMeasurementReportElement (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   WifiInfoElementList m_list;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * The Link Measurement Request frame uses the Action frame body format and is transmitted by a STA to
<  * request another STA to respond with a Link Measurement Report frame to enable measurement of link path
<  * loss and estimation of link margin.
<  */
< class LinkMeasurementRequest : public Header
< {
< public:
<   LinkMeasurementRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the request to identify the
<    * transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Transmit Power Used field is set to the transmit power used to transmit the frame containing the Link
<    * Measurement Request, as described in 8.4.1.20.
<    * \param power
<    */
<   void SetTransmitPowerUsed (uint8_t power);
<   /**
<    * The Max Transmit Power field provides the upper limit on the transmit power as measured at the output of
<    * \the antenna connector to be used by the transmitting STA on its operating channel. This field is described in
<    * 8.4.1.19. The Max Transmit Power field is a twos complement signed integer and is 1 octet in length,
<    * providing an upper limit, in a dBm scale, on the transmit power as measured at the output of the antenna
<    * connector to be used by the transmitting STA on its operating channel. The maximum tolerance for the value
<    * reported in Max Transmit Power field is ±5 dB. The value of the Max Transmit Power field is equal to the
<    * minimum of the maximum powers at which the STA is permitted to transmit in the operating channel by
<    * device capability, policy, and regulatory authority.
<    * \param power
<    */
<   void SetMaxTransmitPower (uint8_t power);
<   void AddSubElement (Ptr<WifiInformationElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   uint8_t GetTransmitPowerUsed (uint8_t power) const;
<   uint8_t GetMaxTransmitPower (uint8_t power) const;
<   /**
<    * Get a specific SubElement by ID.
<    * \param id The ID of the Wifi SubElement.
<    * \return
<    */
<   Ptr<WifiInformationElement> GetSubElement (WifiInformationElementId id);
<   /**
<    * Get List of SubElement associated with this frame.
<    * \return
<    */
<   WifiInformationSubelementMap GetListOfSubElements (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint8_t m_transmitPowerUsed;
<   uint8_t m_maxTransmitPower;
<   WifiInformationSubelementMap m_map;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * The Link Measurement Report frame uses the Action frame body format and is transmitted by a STA in
<  * response to a Link Measurement Request frame.
<  */
< class LinkMeasurementReport : public Header
< {
< public:
<   LinkMeasurementReport ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetTpcReportElement (uint32_t elem);
<   void SetReceiveAntennaId (uint8_t id);
<   void SetTransmitAntennaId (uint8_t id);
<   void SetRCPI (uint8_t value);
<   void SetRSNI (uint8_t value);
<   void AddSubElement (Ptr<WifiInformationElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   uint32_t GetTpcReportElement (void) const;
<   uint8_t GetReceiveAntennaId (void) const;
<   uint8_t GetTransmitAntennaId (void) const;
<   uint8_t GetRCPI (void) const;
<   uint8_t GetRSNI (void) const;
<   /**
<    * Get a specific SubElement by ID.
<    * \param id The ID of the Wifi SubElement.
<    * \return
<    */
<   Ptr<WifiInformationElement> GetSubElement (WifiInformationElementId id);
<   /**
<    * Get List of SubElement associated with this frame.
<    * \return
<    */
<   WifiInformationSubelementMap GetListOfSubElements (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint32_t m_tpcElement;
<   uint8_t m_receiveAntId;
<   uint8_t m_transmitAntId;
<   uint8_t m_rcpi;
<   uint8_t m_rsni;
<   WifiInformationSubelementMap m_map;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Public QAB Frame.
<  */
< class ExtQabFrame : public Header
< {
< public:
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const = 0;
<   virtual uint32_t Deserialize (Buffer::Iterator start) = 0;
< 
<   void SetDialogToken (uint8_t token);
<   void SetRequesterApAddress (Mac48Address address);
<   void SetResponderApAddress (Mac48Address address);
< 
<   uint8_t GetDialogToken (void) const;
<   Mac48Address GetRequesterApAddress (void) const;
<   Mac48Address GetResponderApAddress (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   Mac48Address m_requester;
<   Mac48Address m_responder;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Public QAB Request (8.5.8.25).
<  * The QAB Request Action frame is transmitted by an AP to another AP to schedule quiet periods that
<  * facilitate the detection of other system operating in the same band.
<  */
< class ExtQabRequestFrame : public ExtQabFrame
< {
< public:
<   ExtQabRequestFrame ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetQuietPeriodRequestElement (QuietPeriodRequestElement &element);
< 
<   QuietPeriodRequestElement GetQuietPeriodRequestElement (void) const;
< 
< private:
<   QuietPeriodRequestElement m_element;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Public QAB Response (8.5.8.26).
<  * A QAB Response frame is sent in response to a QAB Request frame.
<  */
< class ExtQabResponseFrame : public ExtQabFrame
< {
< public:
<   ExtQabResponseFrame ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetQuietPeriodResponseElement (QuietPeriodResponseElement &element);
< 
<   QuietPeriodResponseElement GetQuietPeriodResponseElement (void) const;
< 
< private:
<   QuietPeriodResponseElement m_element;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type  Common Information frame.
<  */
< class ExtInformationFrame : public Header, public MgtFrame
< {
< public:
<   ExtInformationFrame ();
< 
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const = 0;
<   virtual uint32_t Deserialize (Buffer::Iterator start) = 0;
< 
<   /**
<    * Set the MAC address of the STA whose information is being requested. If this frame is sent to
<    * the PCP and the value of the Subject Address field is the broadcast address, then the STA is
<    * requesting information regarding all associated STAs.
<    * \param address The Mac address
<    */
<   void SetSubjectAddress (Mac48Address address);
<   /**
<    * Set the request element which contains a list of requested information IDs.
<    * \param elem the Request Element.
<    */
<   void SetRequestInformationElement (Ptr<RequestElement> elem);
<   /**
<    * The DMG Capabilities element carries information about the transmitter STA and other STAs known
<    * to the transmitter STA.
<    * \param elem The DMG Capabilities Information Element.
<    */
<   void AddDmgCapabilitiesElement (Ptr<DmgCapabilities> elem);
< 
< 
<   Mac48Address GetSubjectAddress (void) const;
<   Ptr<RequestElement> GetRequestInformationElement (void) const;
<   DmgCapabilitiesList GetDmgCapabilitiesList (void) const;
< 
< protected:
<   Mac48Address m_subjectAddress;
<   Ptr<RequestElement> m_requestElement;
<   DmgCapabilitiesList m_dmgCapabilitiesList;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Information Request frame (8.5.20.4).
<  */
< class ExtInformationRequest : public ExtInformationFrame
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Information Request frame (8.5.20.4).
<  */
< class ExtInformationResponse : public ExtInformationFrame
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
<   virtual uint32_t GetSerializedSize (void) const;
< 
< 
<   Ptr<BeamRefinementElement> GetBeamRefinementElement (void) const;
<   Ptr<ChannelMeasurementFeedbackElement> GetChannelMeasurementElement (void) const;
<   Ptr<EDMGChannelMeasurementFeedbackElement> GetEDMGChannelMeasurementElement (void) const;
< 
<   void SetBeamRefinementElement (Ptr<BeamRefinementElement> element);
<   void SetChannelMeasurementElement (Ptr<ChannelMeasurementFeedbackElement> element);
<   void SetEdmgChannelMeasurementElement (Ptr<EDMGChannelMeasurementFeedbackElement> element);
< 
< protected:
<   Ptr<BeamRefinementElement> m_beamRefinement;
<   Ptr<ChannelMeasurementFeedbackElement> m_channelElement;
<   Ptr<EDMGChannelMeasurementFeedbackElement> m_edmgChannelElement;
< 
< };
< 
< enum HandoverReason
< {
<   LeavingPBSS = 0,
<   LowPowerPCP = 1,
<   QualifiedSTA = 2,
<   BecomePCP = 3
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type handover request frame.
<  */
< class ExtHandoverRequestHeader : public Header
< {
< public:
<   ExtHandoverRequestHeader ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the reason that the current PCP intends to do the PCP handover.
<    * \param reason
<    */
<   void SetHandoverReason (enum HandoverReason reason);
<   /**
<    * Set the number of beacon intervals, excluding the beacon interval in which this frame
<    * is transmitted, remaining until the handover takes effect.
<    * \param length
<    */
<   void SetHandoverRemainingBI (uint8_t remaining);
< 
<   enum HandoverReason GetHandoverReason (void) const;
<   uint8_t GetHandoverRemainingBI (void) const;
< 
< private:
<   uint8_t m_handoverReason;
<   uint8_t m_remainingBI;
< 
< };
< 
< enum HandoverRejectReason
< {
<   LowPower = 0,
<   HandoverInProgress = 1,
<   InvalidBI = 2,
<   UnspecifiedReason = 3
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type handover response frame.
<  */
< class ExtHandoverResponseHeader : public Header
< {
< public:
<   ExtHandoverResponseHeader ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set whether the STA accepted the handover request.
<    * \param  result A value of 0 indicates that the STA accepts the handover request.
<    * A value of 1 indicates that the STA does not accept the handover request.
<    */
<   void SetHandoverResult (bool result);
<   /**
<    *
<    */
<   void SetHandoverRejectReason (enum HandoverRejectReason reason);
< 
<   bool GetHandoverResult (void) const;
<   enum HandoverRejectReason GetHandoverRejectReason (void) const;
< 
< private:
<   bool m_handoverResult;
<   uint8_t m_handoverRejectReason;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay Search Request frame.
<  */
< class ExtRelaySearchRequestHeader : public Header
< {
< public:
<   ExtRelaySearchRequestHeader ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetDestinationRedsAid (uint16_t aid);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetDestinationRedsAid (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_aid;
< 
< };
< 
< typedef std::map<uint16_t, RelayCapabilitiesInfo> RelayCapableStaList;
< typedef RelayCapableStaList::const_iterator RelayCapableStaListCI;
< typedef RelayCapableStaList::iterator RelayCapableStaListI;
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay Search Response frame.
<  */
< class ExtRelaySearchResponseHeader : public Header
< {
< public:
<   ExtRelaySearchResponseHeader ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetStatusCode (uint16_t status);
<   void AddRelayCapableStaInfo (uint8_t aid, RelayCapabilitiesInfo &element);
<   void SetRelayCapableList (RelayCapableStaList &list);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetStatusCode (void) const;
<   RelayCapableStaList GetRelayCapableList (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_statusCode;
<   RelayCapableStaList m_list;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Multi-relay Channel Measurement Request frame.
<  * The Multi-Relay Channel Measurement Request frame is transmitted by a STA initiating relay operation to
<  * the recipient STA in order to obtain Channel Measurements between the recipient STA and the other STA
<  * participating in the relay operation.
<  *
<  */
< class ExtMultiRelayChannelMeasurementRequest : public Header
< {
< public:
<   ExtMultiRelayChannelMeasurementRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the Multi-Relay Channel
<    * Measurement Request frame to identify the request/report transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
< 
<   uint8_t GetDialogToken (void) const;
< 
< private:
<   uint8_t m_dialogToken;
< 
< };
< 
< typedef std::vector<Ptr<ExtChannelMeasurementInfo> > ChannelMeasurementInfoList;
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay Search Response frame.
<  */
< class ExtMultiRelayChannelMeasurementReport : public Header
< {
< public:
<   ExtMultiRelayChannelMeasurementReport ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void AddChannelMeasurementInfo (Ptr<ExtChannelMeasurementInfo> element);
<   void SetChannelMeasurementList (ChannelMeasurementInfoList &list);
< 
<   uint8_t GetDialogToken (void) const;
<   ChannelMeasurementInfoList GetChannelMeasurementInfoList (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   ChannelMeasurementInfoList m_list;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement a generic header for extension frames of type RLS (Relay Link Setup) frame.
< */
< class ExtRlsFrame : public Header
< {
< public:
<  ExtRlsFrame ();
< 
<  virtual uint32_t GetSerializedSize (void) const;
<  virtual void Serialize (Buffer::Iterator start) const = 0;
<  virtual uint32_t Deserialize (Buffer::Iterator start) = 0;
< 
<  /**
<   * Set the Destination AID field value .
<   * \param aid the AID of the target destination.
<   */
<  void SetDestinationAid (uint16_t aid);
<  /**
<   * Set the Relay AID field value.
<   * \param aid the AID of the RDS.
<   */
<  void SetRelayAid (uint16_t aid);
<  /**
<   * The Source AID field value.
<   * \param aid  is the AID of the initiating STA.
<   */
<  void SetSourceAid (uint16_t aid);
< 
<  uint16_t GetDestinationAid (void) const;
<  uint16_t GetRelayAid (void) const;
<  uint16_t GetSourceAid (void) const;
< 
< protected:
<  uint16_t m_destinationAid;
<  uint16_t m_relayAid;
<  uint16_t m_sourceAid;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type RLS (Relay Link Setup) Request frame.
<  */
< class ExtRlsRequest : public ExtRlsFrame
< {
< public:
<   ExtRlsRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the RLS Request frame to
<    * identify the request/response transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Destination Capability Information field indicates the Relay capabilities info field within the Relay
<    * capabilities element of the target destination REDS as defined in 8.4.2.150.
<    * \param elem
<    */
<   void SetDestinationCapabilityInformation (RelayCapabilitiesInfo &elem);
<   /**
<    * The Relay Capability Information field indicates the Relay capabilities info field within the Relay
<    * capabilities element of the selected RDS as defined in 8.4.2.150.
<    * \param elem
<    */
<   void SetRelayCapabilityInformation (RelayCapabilitiesInfo &elem);
<   /**
<    * The Source Capability Information field indicates the Relay capabilities info field within the Relay
<    * capabilities element of the originator of the request as defined in 8.4.2.150.
<    * \param elem
<    */
<   void SetSourceCapabilityInformation (RelayCapabilitiesInfo &elem);
<   /**
<    * The Relay Transfer Parameter Set element is defined in 8.4.2.151.
<    * \param elem
<    */
<   void SetRelayTransferParameterSet (Ptr<RelayTransferParameterSetElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   RelayCapabilitiesInfo GetDestinationCapabilityInformation (void) const;
<   RelayCapabilitiesInfo GetRelayCapabilityInformation (void) const;
<   RelayCapabilitiesInfo GetSourceCapabilityInformation (void) const;
<   Ptr<RelayTransferParameterSetElement> GetRelayTransferParameterSet (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   RelayCapabilitiesInfo m_destinationCapability;
<   RelayCapabilitiesInfo m_relayCapability;
<   RelayCapabilitiesInfo m_sourceCapability;
<   Ptr<RelayTransferParameterSetElement> m_relayParameter;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type RLS (Relay Link Setup) Response frame.
<  */
< class ExtRlsResponse : public Header
< {
< public:
<   ExtRlsResponse ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the RLS Request frame to
<    * identify the request/response transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Destination Status Code field is included when the destination REDS transmits this RLS Response
<    * frame as a result of RLS Request. It is defined in 8.4.1.9.
<    * \param aid the AID of the target destination.
<    */
<   void SetDestinationStatusCode (uint16_t status);
<   /**
<    * The Relay Status Code field is included when the relay REDS transmits this RLS Response frame as a result
<    * of RLS Request. It is defined in 8.4.1.9.
<    * \param aid the AID of the selected RDS.
<    */
<   void SetRelayStatusCode (uint16_t status);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetDestinationStatusCode (void) const;
<   uint16_t GetRelayStatusCode (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_destinationStatusCode;
<   uint16_t m_relayStatusCode;
<   bool m_insertRelayStatus;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type RLS (Relay Link Setup) Announcment frame.
< * The RLS Announcement frame is sent to announce the successful RLS.
< */
< class ExtRlsAnnouncment : public ExtRlsFrame
< {
< public:
<  ExtRlsAnnouncment ();
< 
<  /**
<   * Register this type.
<   * \return The TypeId.
<   */
<  static TypeId GetTypeId (void);
<  // Inherited
<  virtual TypeId GetInstanceTypeId (void) const;
<  virtual void Print (std::ostream &os) const;
<  virtual uint32_t GetSerializedSize (void) const;
<  void Serialize (Buffer::Iterator start) const;
<  uint32_t Deserialize (Buffer::Iterator start);
< 
<  /**
<   * Set the status code on the RLS.
<   * \param status the status of the RLS
<   */
<  void SetStatusCode (uint16_t status);
< 
<  uint16_t GetStatusCode (void) const;
< 
< private:
<  uint16_t m_status;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type RLS (Relay Link Setup) Teardown frame.
< * The RLS Teardown frame is sent to terminate a relay operation.
< */
< class ExtRlsTearDown : public ExtRlsFrame
< {
< public:
<  ExtRlsTearDown ();
< 
<  /**
<   * Register this type.
<   * \return The TypeId.
<   */
<  static TypeId GetTypeId (void);
<  // Inherited
<  virtual TypeId GetInstanceTypeId (void) const;
<  virtual void Print (std::ostream &os) const;
<  virtual uint32_t GetSerializedSize (void) const;
<  void Serialize (Buffer::Iterator start) const;
<  uint32_t Deserialize (Buffer::Iterator start);
< 
<  /**
<   * Set the reason code.
<   * \param reason the reason of the RLS teardown
<   */
<  void SetReasonCode (uint16_t reason);
< 
<  uint16_t GetReasonCode (void) const;
< 
< private:
<  uint16_t m_reasonCode;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay ACK Request frame format (8.5.20.18).
<  * The Relay ACK Request frame is sent by a source REDS to an RDS participating in a relay operation in
<  * order to determine whether all frames forwarded through the RDS were successfully received by the
<  * destination REDS also participating in the relay operation. This frame is used only when the RDS is
<  * operated in HD-DF mode and relay operation is link switching type.
<  */
< class ExtRelayAckRequest : public CtrlBAckRequestHeader
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   TypeId GetInstanceTypeId (void) const;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay ACK Request frame format (8.5.20.19).
<  * The Relay ACK Response frame is sent by an RDS to a source REDS participating in a relay operation in
<  * order to report which frames have been received by the destination REDS also participating in the relay
<  * operation. This frame is used only when the RDS is operated in HD-DF mode and relay operation is link
<  * switching type.
<  */
< class ExtRelayAckResponse : public CtrlBAckResponseHeader
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   TypeId GetInstanceTypeId (void) const;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type TPA (Transmission Time-Point Adjustment) Request frame.
<  * The TPA Request frame is sent by a destination REDS participating in operation based on link cooperating
<  * type to both the RDS and source REDS that belong to the same group as the destination REDS in order for
<  * them to send back their own TPA Response frames at the separately pre-defined times. Also, a source REDS
<  * sends a TPA Request frame to the RDS that is selected by the source REDS in order for the RDS to feedback
<  * its own TPA Response frame at the pre-defined time.
<  */
< class ExtTpaRequest : public Header
< {
< public:
<   ExtTpaRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the TPA Request frame to
<    * identify the request/response transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Timing Offset is 2 octets in length and indicates the amount of time, in nanoseconds, that the STA
<    * identified in the RA of the frame is required to change the timing offset of its transmissions so that they
<    * arrive at the expected time at the transmitting STA.
<    */
<   void SetTimingOffset (uint16_t offset);
<   /**
<    * The Sampling Frequency Offset is 2 octets in length and indicates the amount by which to change the
<    * sampling frequency offset of the burst transmission so that bursts arrive at the destination DMG STA with
<    * no sampling frequency offset. The unit is 0.01 ppm. The Sampling Frequency Offset field is reserved when
<    * set to 0.
<    * \param offset the smapling frequency offset
<    */
<   void SetSamplingFrequencyOffset (uint16_t offset);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetTimingOffset (void) const;
<   uint16_t GetSamplingFrequencyOffset (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_timingOffset;
<   uint16_t m_samplingOffset;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) Setup frame.
< */
< class ExtFstSetupFrame : public Header
< {
< public:
<   ExtFstSetupFrame ();
< 
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const = 0;
<   virtual void Print (std::ostream &os) const = 0;
<   virtual uint32_t GetSerializedSize (void) const = 0;
<   virtual void Serialize (Buffer::Iterator start) const = 0;
<   virtual uint32_t Deserialize (Buffer::Iterator start) = 0;
< 
<   /**
<   * The Dialog Token field is set to a nonzero value chosen by the STA sending the TPA Request frame to
<   * identify the request/response transaction.
<   * \param token
<   */
<   void SetDialogToken (uint8_t token);
<   /**
<   * Set the Session Transition field defined in 8.4.2.147.
<   * \param elem the sessio transition element
<   */
<   void SetSessionTransition (SessionTransitionElement &elem);
<   /**
<   * Set the Multi-band field contains the Multi-Band element as defined in 8.4.2.140. The regulatory information
<   * contained in the Multi-band element is applicable to all the fields and elements contained in the frame.
<   * \param elem the multi-band element
<   */
<   void SetMultiBand (Ptr<MultiBandElement> elem);
<   void SetWakeupSchedule (Ptr<WakeupScheduleElement> elem);
<   void SetAwakeWindow (Ptr<AwakeWindowElement> elem);
<   void SetSwitchingStream (Ptr<SwitchingStreamElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   SessionTransitionElement GetSessionTransition (void) const;
<   Ptr<MultiBandElement> GetMultiBand (void) const;
<   Ptr<WakeupScheduleElement> GetWakeupSchedule (void) const;
<   Ptr<AwakeWindowElement> GetAwakeWindow (void) const;
<   Ptr<SwitchingStreamElement> GetSwitchingStream (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   SessionTransitionElement m_sessionTransition;
<   Ptr<MultiBandElement> m_multiBand;
<   Ptr<WakeupScheduleElement> m_wakeupSchedule;
<   Ptr<AwakeWindowElement> m_awakeWindow;
<   Ptr<SwitchingStreamElement> m_switchingStream;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) Setup Request frame.
< * The FST Setup Request frame is an Action frame of category FST. The FST Setup Request frame allows an
< * initiating STA to announce to a peer STA whether the initiating STA intends to enable FST for the session
< * between the initiating STA and the peer STA (10.32).
< */
< class ExtFstSetupRequest : public ExtFstSetupFrame
< {
< public:
<   ExtFstSetupRequest ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The Link loss timeout (LLT) field is 32 bits and indicates the compressed maximum duration counted from
<   * the last time an MPDU was received by the initiating STA from the peer STA until the initiating STA
<   * decides to initiate FST.
<   * \param llt
<   */
<   void SetLlt (uint32_t llt);
< 
<   uint32_t GetLlt (void) const;
< 
< private:
<   uint32_t m_llt;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) Setup Response frame.
< * The FST Setup Response frame is an Action frame of category FST. This frame is transmitted in response to
< * the reception of an FST Setup Request frame.
< */
< class ExtFstSetupResponse : public ExtFstSetupFrame
< {
< public:
<   ExtFstSetupResponse ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * \param status
<   */
<   void SetStatusCode (uint16_t status);
<   /**
<   * \return Status of the FST Setup
<   */
<   uint16_t GetStatusCode (void) const;
< 
< private:
<   uint16_t m_statusCode;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) Tear Down frame.
< * This frame is transmitted to delete an established FST session between STAs.
< */
< class ExtFstTearDown : public Header
< {
< public:
<   ExtFstTearDown ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The FSTS ID field contains the identification of the FST session established between the STAs identified by
<   * the TA and RA fields of this frame
<   * \param token
<   */
<   void SetFstsID (uint32_t id);
< 
<   uint32_t GetFstsID (void) const;
< 
< private:
<   uint32_t m_fstsID;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) ACK Request frame.
< * This frame is transmitted in the frequency band an FST session is transferred to and confirms
< * the FST session transfer
< */
< class ExtFstAckRequest : public Header
< {
< public:
<   ExtFstAckRequest ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The Dialog Token field is set to a nonzero value chosen by the STA sending the FST ACK Request frame to
<   * identify the request/response transaction.
<   * \param token
<   */
<   void SetDialogToken (uint8_t token);
<   /**
<   * The FSTS ID field contains the identification of the FST session established between the STAs identified by
<   * the TA and RA fields of this frame
<   * \param token
<   */
<   void SetFstsID (uint32_t id);
< 
<   uint8_t GetDialogToken (void) const;
<   uint32_t GetFstsID (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint32_t m_fstsID;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) ACK Request frame.
< * The FST Ack Response frame is an Action frame of category FST. This frame is transmitted in response to
< * the reception of an FST Ack Request frame
< */
< class ExtFstAckResponse : public ExtFstAckRequest
< {
< public:
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Unprotected DMG Announce frame (8.5.22.2).
<  * The Announce frame is an Action or an Action No Ack frame of category Unprotected DMG. Announce frames
<  * can be transmitted during the ATI of a beacon interval and can perform functions including of a DMG
<  * Beacon frame, but since this frame does not have to be transmitted as a sector sweep to a STA, it can
<  * provide much more spectrally efficient access than using a DMG Beacon frame.
<  */
< class ExtAnnounceFrame : public Header, public MgtFrame
< {
< public:
<   ExtAnnounceFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the Timestamp for this frame.
<    * \param timestamp The Timestamp for this frame
<    */
<   void SetTimestamp (uint8_t timestamp);
<   /**
<    * Set the Beacon Interval.
<    * \param interval the Beacon Interval.
<    */
<   void SetBeaconInterval (uint16_t interval);
< 
<   uint8_t GetTimestamp (void) const;
<   uint16_t GetBeaconInterval (void) const;
< 
< protected:
<   uint8_t m_timestamp;
<   uint16_t m_beaconInterval;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Unprotected DMG BRP Frame (8.5.22.3).
<  * The BRP frame is an Action No Ack frame.
<  */
< class ExtBrpFrame : public Header
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   ExtBrpFrame (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetBrpRequestField (BRP_Request_Field &field);
<   void SetBeamRefinementElement (BeamRefinementElement &element);
<   void AddChannelMeasurementFeedback (ChannelMeasurementFeedbackElement *element);
<   void SetEdmgPartialSlsElement (EdmgPartialSectorLevelSweep *element);
<   void SetEdmgBrpRequestElement (EdmgBrpRequestElement *element);
<   void AddEdmgChannelMeasurementFeedback (EDMGChannelMeasurementFeedbackElement *element);
< 
<   uint8_t GetDialogToken (void) const;
<   BRP_Request_Field GetBrpRequestField (void) const;
<   BeamRefinementElement GetBeamRefinementElement (void) const;
<   ChannelMeasurementFeedbackElementList GetChannelMeasurementFeedbackList (void) const;
<   Ptr<EdmgPartialSectorLevelSweep> GetEdmgPartialSlsElement (void) const;
<   Ptr<EdmgBrpRequestElement> GetEdmgBrpRequestElement (void) const;
<   EDMGChannelMeasurementFeedbackElementList GetEdmgChannelMeasurementFeedbackList (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   BRP_Request_Field m_brpRequestField;
<   BeamRefinementElement m_beamRefinementElement;
<   ChannelMeasurementFeedbackElementList m_list;
<   Ptr<EdmgPartialSectorLevelSweep> m_partialSlsElement;
<   Ptr<EdmgBrpRequestElement> m_edmgBrpRequestElement;
<   EDMGChannelMeasurementFeedbackElementList m_edmgList;
< 
< };
< 
< /**
<  * \ingroup wifi
<  *
<  * The MIMO BF Setup frame is an Action No Ack frame for IEEE 802.11ay.
<  *
<  */
< class ExtMimoBfSetupFrame : public Header
< {
< public:
<   ExtMimoBfSetupFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetMimoSetupControlElement (MimoSetupControlElement element);
< 
<   uint8_t GetDialogToken (void) const;
<   MimoSetupControlElement GetMimoSetupControlElement (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   MimoSetupControlElement m_mimoSetupControl;
< 
< };
< 
< /**
<  * \ingroup wifi
<  *
<  * The MIMO BF Poll frame is an Action No Ack frame for IEEE 802.11ay.
<  *
<  */
< class ExtMimoBfPollFrame : public Header
< {
< public:
<   ExtMimoBfPollFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetMimoPollControlElement (MimoPollControlElement element);
< 
<   uint8_t GetDialogToken (void) const;
<   MimoPollControlElement GetMimoSetupControlElement (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   MimoPollControlElement m_mimoPollControl;
< 
< };
< 
< /**
<  * \ingroup wifi
<  *
<  * The MIMO BF Feedback frame is an Action No Ack frame for IEEE 802.11ay.
<  *
<  * Note: The length of a MIMO BF Feedback frame can limit the choice of channel
<  * measurement parameters such as the number of measurements and the number of taps.
<  */
< class ExtMimoBfFeedbackFrame : public Header
< {
< public:
<   ExtMimoBfFeedbackFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a value chosen by the STA sending the frame to uniquely identify
<    * the transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   void SetMimoFeedbackControlElement (MIMOFeedbackControl &element);
<   /**
<    * The MIMO BF Feedback frame contains more than one Channel Measurement Feedback element if the
<    * measurement information exceeds 255 octets. The content of each Channel Measurement Feedback
<    * element that follows the first one in a single MIMO BF Feedback frame is a continuation of the content in
<    * the previous element. The SNR, Channel Measurement, Additional SNR and Additional Channel
<    * Measurement subfields can be split between several elements. Each Channel Measurement Feedback
<    * element that is not the last Channel Measurement Feedback element in the frame is 257 octets long.
<    * Channel measurement information for a single channel measurement is always contained within a single
<    * MIMO BF Feedback frame.
<    * \param element
<    */
<   void AddChannelMeasurementFeedbackElement (Ptr<ChannelMeasurementFeedbackElement> element);
<   /**
<    * The MIMO BF Feedback frame contains more than one EDMG Channel Measurement Feedback element if
<    * the measurement information exceeds 254 octets. The content of each EDMG Channel Measurement
<    * Feedback element that follows the first one in a single MIMO BF Feedback frame is a continuation of the
<    * content in the previous element. The EDMG Sector ID Order, BRP CDOWN, Tap Delay, Additional
<    * EDMG Sector ID Order, Additional BRP CDOWN and Additional Tap Delay subfields can be split
<    * between several elements. Each EDMG Channel Measurement Feedback element that is not the last EDMG
<    * Channel Measurement Feedback element in the frame is 257 octets long. Channel measurement
<    * information for a single channel measurement is always contained within a single MIMO BF Feedback frame.
<    * \param element
<    */
<   void AddEdmgChannelMeasurementFeedbackElement (Ptr<EDMGChannelMeasurementFeedbackElement> element);
<   void AddDigitalBfFeedbackElement (Ptr<DigitalBFFeedbackElement> element);
< 
<   uint8_t GetDialogToken (void) const;
<   MIMOFeedbackControl GetMimoFeedbackControlElement (void) const;
<   ChannelMeasurementFeedbackElementList GetListOfChannelMeasurementFeedback (void) const;
<   EDMGChannelMeasurementFeedbackElementList GetListOfEDMGChannelMeasurementFeedback (void) const;
<   DigitalBFFeedbackElementList GetListOfDigitalBFFeedbackElement (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   MIMOFeedbackControl m_mimoFeedbackControl;
<   ChannelMeasurementFeedbackElementList m_channelMeasurementFeedbackList;
<   EDMGChannelMeasurementFeedbackElementList m_edmgChannelMeasurementFeedbackList;
<   DigitalBFFeedbackElementList m_digitalBFFeedbackElementList;
< 
< };
< 
< /**
<  * \ingroup wifi
<  *
<  * The MIMO BF Selection frame is an Action No Ack frame. The format of a MIMO BF Selection frame.
<  */
< class ExtMimoBFSelectionFrame : public Header
< {
< public:
<   ExtMimoBFSelectionFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetMIMOSelectionControlElement (MIMOSelectionControlElement &element);
<   /**
<    * The EDMG Group ID Set element is defined in 9.4.2.254. The element contains the updated
<    * list of MU groups following completion of the MU MIMO beamforming training.
<    * \param element
<    */
<   void SetEDMGGroupIDSetElement (EDMGGroupIDSetElement &element);
< 
<   uint8_t GetDialogToken (void) const;
<   MIMOSelectionControlElement GetMIMOSelectionControlElement (void) const;
<   EDMGGroupIDSetElement GetEDMGGroupIDSetElement (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   MIMOSelectionControlElement m_mimoSelectionControlElement;
<   EDMGGroupIDSetElement m_edmgGroupIDSetElement;
< 
---
>   uint16_t m_reasonCode; /* Not used for now. Always set to 1: "Unspecified reason" */
diff ../../NS3-WiGig/src/wifi/model/minstrel-ht-wifi-manager.cc ../../ns-3-dev/src/wifi/model/minstrel-ht-wifi-manager.cc
19,21c19,21
<  * Authors: Duy Nguyen <duy@soe.ucsc.edu>
<  *          Ghada Badawy <gbadawy@gmail.com>
<  *          Matias Richart <mrichart@fing.edu.uy>
---
>  * Author: Duy Nguyen <duy@soe.ucsc.edu>
>  *         Ghada Badawy <gbadawy@gmail.com>
>  *         Matias Richart <mrichart@fing.edu.uy>
37,41d36
< #include <iomanip>
< #include "ns3/packet.h"
< #include "ns3/simulator.h"
< #include "ns3/log.h"
< #include "ns3/random-variable-stream.h"
43d37
< #include "wifi-mac.h"
44a39,50
> #include "ns3/random-variable-stream.h"
> #include "ns3/simulator.h"
> #include "ns3/log.h"
> #include "ns3/uinteger.h"
> #include "ns3/double.h"
> #include "ns3/wifi-mac.h"
> #include "ns3/assert.h"
> #include "ns3/boolean.h"
> #include "ns3/string.h"
> #include <vector>
> #include <iomanip>
> #include <fstream>
53d58
< ///MinstrelHtWifiRemoteStation structure
56c61,63
<   uint8_t m_sampleGroup;     //!< The group that the sample rate belongs to.
---
>   void DisposeStation ();
> 
>   uint32_t m_sampleGroup;     //!< The group that the sample rate belongs to.
63,64c70,71
<   uint32_t m_avgAmpduLen;      //!< Average number of MPDUs in an A-MPDU.
<   uint32_t m_ampduLen;         //!< Number of MPDUs in an A-MPDU.
---
>   double m_avgAmpduLen;       //!< Average number of MPDUs in an A-MPDU.
>   double m_ampduLen;          //!< Number of MPDUs in an A-MPDU.
72a80,94
> void
> MinstrelHtWifiRemoteStation::DisposeStation ()
> {
>   if (m_isHt)
>     {
>       std::vector<std::vector<uint32_t> > ().swap (m_sampleTable);
>       for (uint8_t j = 0; j < m_groupsTable.size (); j++)
>         {
>           std::vector<struct HtRateInfo> ().swap (m_groupsTable[j].m_ratesTable);
>         }
>       std::vector<struct GroupInfo> ().swap (m_groupsTable);
>       m_statsFile.close ();
>     }
> }
> 
89,91c111,113
<                    UintegerValue (10),
<                    MakeUintegerAccessor (&MinstrelHtWifiManager::m_lookAroundRate),
<                    MakeUintegerChecker<uint8_t>(0, 100))
---
>                    DoubleValue (10),
>                    MakeDoubleAccessor (&MinstrelHtWifiManager::m_lookAroundRate),
>                    MakeDoubleChecker<double> (0, 100))
94,96c116,118
<                    UintegerValue (75),
<                    MakeUintegerAccessor (&MinstrelHtWifiManager::m_ewmaLevel),
<                    MakeUintegerChecker<uint8_t>(0, 100))
---
>                    DoubleValue (75),
>                    MakeDoubleAccessor (&MinstrelHtWifiManager::m_ewmaLevel),
>                    MakeDoubleChecker<double> (0, 100))
101c123
<                    MakeUintegerChecker <uint8_t> ())
---
>                    MakeUintegerChecker <uint32_t> ())
103c125
<                    "The packet length used for calculating mode TxTime (bytes)",
---
>                    "The packet length used for calculating mode TxTime",
117,120c139,142
<     .AddTraceSource ("Rate",
<                      "Traced value for rate changes (b/s)",
<                      MakeTraceSourceAccessor (&MinstrelHtWifiManager::m_currentRate),
<                      "ns3::TracedValueCallback::Uint64")
---
>     .AddTraceSource ("RateChange",
>                      "The transmission rate has changed",
>                      MakeTraceSourceAccessor (&MinstrelHtWifiManager::m_rateChange),
>                      "ns3::MinstrelHtWifiManager::RateChangeTracedCallback")
127,128c149
<     m_numRates (0),
<     m_currentRate (0)
---
>     m_numRates (0)
142c163
<   for (uint8_t i = 0; i < m_numGroups; i++)
---
>   if (HasHtSupported ())
144,145c165,169
<       m_minstrelGroups[i].ratesFirstMpduTxTimeTable.clear ();
<       m_minstrelGroups[i].ratesTxTimeTable.clear ();
---
>       for (uint32_t i = 0; i < m_numGroups; i++)
>         {
>           m_minstrelGroups[i].ratesFirstMpduTxTimeTable.clear ();
>           m_minstrelGroups[i].ratesTxTimeTable.clear ();
>         }
161c185
< MinstrelHtWifiManager::SetupPhy (const Ptr<WifiPhy> phy)
---
> MinstrelHtWifiManager::SetupPhy (Ptr<WifiPhy> phy)
164c188
<   // Setup PHY for legacy manager.
---
>   // Setup phy for legacy manager.
170,177d193
< MinstrelHtWifiManager::SetupMac (const Ptr<WifiMac> mac)
< {
<   NS_LOG_FUNCTION (this << mac);
<   m_legacyManager->SetupMac (mac);
<   WifiRemoteStationManager::SetupMac (mac);
< }
< 
< void
181,184c197
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
---
> 
191,192c204,205
<   // Check if the device supports HT
<   if (GetHtSupported ())
---
>   // Check if the device supports HT or VHT
>   if (HasHtSupported () || HasVhtSupported ())
197c210
<       if (GetVhtSupported ())
---
>       if (HasVhtSupported ())
210c223
<        *  - A deviceIndex, which indexes a MCS in the PHY MCS array.
---
>        *  - A deviceIndex, which indexes a MCS in the phy MCS array.
217c230
<       for (uint16_t chWidth = 20; chWidth <= MAX_HT_WIDTH; chWidth *= 2)
---
>       for (uint32_t chWidth = 20; chWidth <= MAX_HT_WIDTH; chWidth *= 2)
223c236
<                   uint8_t groupId = GetHtGroupId (streams, sgi, chWidth);
---
>                   uint32_t groupId = GetHtGroupId (streams, sgi, chWidth);
232c245
<                   if (!(!GetShortGuardIntervalSupported () && m_minstrelGroups[groupId].sgi)                   ///Is SGI supported by the transmitter?
---
>                   if (!(!GetPhy ()->GetGuardInterval () && m_minstrelGroups[groupId].sgi)                   ///Is SGI supported by the transmitter?
234c247
<                       && (GetPhy ()->GetMaxSupportedTxSpatialStreams () >= m_minstrelGroups[groupId].streams))  ///Are streams supported by the transmitter?
---
>                       && (GetPhy ()->GetNumberOfTransmitAntennas () >= m_minstrelGroups[groupId].streams))  ///Are streams supported by the transmitter?
238c251
<                       // Calculate TX time for all rates of the group
---
>                       // Calculate tx time for all rates of the group
242c255
<                           uint16_t deviceIndex = i + (m_minstrelGroups[groupId].streams - 1) * 8;
---
>                           uint32_t deviceIndex = i + (m_minstrelGroups[groupId].streams - 1) * 8;
244,245c257,258
<                           AddFirstMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode, FIRST_MPDU_IN_AGGREGATE));
<                           AddMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode, MIDDLE_MPDU_IN_AGGREGATE));
---
>                           AddFirstMpduTxTime (groupId, mode, CalculateFirstMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode));
>                           AddMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode));
247c260
<                       NS_LOG_DEBUG ("Initialized group " << +groupId << ": (" << +streams << "," << +sgi << "," << chWidth << ")");
---
>                       NS_LOG_DEBUG ("Initialized group " << groupId << ": (" << (uint32_t)streams << "," << (uint32_t)sgi << "," << chWidth << ")");
253c266
<       if (GetVhtSupported ())
---
>       if (HasVhtSupported ())
256c269
<           for (uint16_t chWidth = 20; chWidth <= MAX_VHT_WIDTH; chWidth *= 2)
---
>           for (uint32_t chWidth = 20; chWidth <= MAX_VHT_WIDTH; chWidth *= 2)
262c275
<                       uint8_t groupId = GetVhtGroupId (streams, sgi, chWidth);
---
>                       uint32_t groupId = GetVhtGroupId (streams, sgi, chWidth);
271c284
<                       if (!(!GetShortGuardIntervalSupported () && m_minstrelGroups[groupId].sgi)                   ///Is SGI supported by the transmitter?
---
>                       if (!(!GetPhy ()->GetGuardInterval () && m_minstrelGroups[groupId].sgi)                   ///Is SGI supported by the transmitter?
273c286
<                           && (GetPhy ()->GetMaxSupportedTxSpatialStreams () >= m_minstrelGroups[groupId].streams))  ///Are streams supported by the transmitter?
---
>                           && (GetPhy ()->GetNumberOfTransmitAntennas () >= m_minstrelGroups[groupId].streams))  ///Are streams supported by the transmitter?
277c290
<                           // Calculate TX time for all rates of the group
---
>                           // Calculate tx time for all rates of the group
285,286c298,299
<                                   AddFirstMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode, FIRST_MPDU_IN_AGGREGATE));
<                                   AddMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode, MIDDLE_MPDU_IN_AGGREGATE));
---
>                                   AddFirstMpduTxTime (groupId, mode, CalculateFirstMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode));
>                                   AddMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode));
289c302
<                           NS_LOG_DEBUG ("Initialized group " << +groupId << ": (" << +streams << "," << +sgi << "," << chWidth << ")");
---
>                           NS_LOG_DEBUG ("Initialized group " << groupId << ": (" << (uint32_t)streams << "," << (uint32_t)sgi << "," << chWidth << ")");
297a311,318
> void
> MinstrelHtWifiManager::SetupMac (Ptr<WifiMac> mac)
> {
>   NS_LOG_FUNCTION (this << mac);
>   m_legacyManager->SetupMac (mac);
>   WifiRemoteStationManager::SetupMac (mac);
> }
> 
299c320
< MinstrelHtWifiManager::IsValidMcs (Ptr<WifiPhy> phy, uint8_t streams, uint16_t chWidth, WifiMode mode)
---
> MinstrelHtWifiManager::IsValidMcs (Ptr<WifiPhy> phy, uint8_t streams, uint32_t chWidth, WifiMode mode)
301c322,323
<   NS_LOG_FUNCTION (this << phy << +streams << chWidth << mode);
---
>   NS_LOG_FUNCTION (this << phy << (int)streams << chWidth << mode);
> 
306c328
<   return txvector.IsValid ();
---
>   return phy->IsValidTxVector (txvector);
310,311c332
< MinstrelHtWifiManager::CalculateMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi,
<                                                 uint16_t chWidth, WifiMode mode, MpduType mpduType)
---
> MinstrelHtWifiManager::CalculateFirstMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi, uint32_t chWidth, WifiMode mode)
313c334,335
<   NS_LOG_FUNCTION (this << phy << +streams << +sgi << chWidth << mode << mpduType);
---
>   NS_LOG_FUNCTION (this << phy << (int)streams << (int)sgi << chWidth << mode);
> 
316c338
<   txvector.SetGuardInterval (sgi ? 400 : 800);
---
>   txvector.SetShortGuardInterval (sgi);
319c341
<   txvector.SetStbc (0);
---
>   txvector.SetStbc (phy->GetStbc ());
321,323c343
<   txvector.SetPreambleType (WIFI_PREAMBLE_HT_MF);
<   return WifiPhy::CalculatePhyPreambleAndHeaderDuration (txvector)
<          + WifiPhy::GetPayloadDuration (m_frameLength, txvector, phy->GetFrequency (), mpduType);
---
>   return phy->CalculateTxDuration (m_frameLength, txvector, WIFI_PREAMBLE_HT_MF, phy->GetFrequency (), MPDU_IN_AGGREGATE, 0);
327c347
< MinstrelHtWifiManager::GetFirstMpduTxTime (uint8_t groupId, WifiMode mode) const
---
> MinstrelHtWifiManager::CalculateMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi, uint32_t chWidth, WifiMode mode)
329,332c349,374
<   NS_LOG_FUNCTION (this << +groupId << mode);
<   auto it = m_minstrelGroups[groupId].ratesFirstMpduTxTimeTable.find (mode);
<   NS_ASSERT (it != m_minstrelGroups[groupId].ratesFirstMpduTxTimeTable.end ());
<   return it->second;
---
>   NS_LOG_FUNCTION (this << phy << (int)streams << (int)sgi << chWidth << mode);
> 
>   WifiTxVector txvector;
>   txvector.SetNss (streams);
>   txvector.SetShortGuardInterval (sgi);
>   txvector.SetChannelWidth (chWidth);
>   txvector.SetNess (0);
>   txvector.SetStbc (phy->GetStbc ());
>   txvector.SetMode (mode);
>   return phy->CalculateTxDuration (m_frameLength, txvector, WIFI_PREAMBLE_NONE, phy->GetFrequency (), MPDU_IN_AGGREGATE, 0);
> }
> 
> Time
> MinstrelHtWifiManager::GetFirstMpduTxTime (uint32_t groupId, WifiMode mode) const
> {
>   NS_LOG_FUNCTION (this << groupId << mode);
> 
>   for (TxTime::const_iterator i = m_minstrelGroups[groupId].ratesFirstMpduTxTimeTable.begin (); i != m_minstrelGroups[groupId].ratesFirstMpduTxTimeTable.end (); i++)
>     {
>       if (mode == i->second)
>         {
>           return i->first;
>         }
>     }
>   NS_ASSERT (false);
>   return Seconds (0);
336c378
< MinstrelHtWifiManager::AddFirstMpduTxTime (uint8_t groupId, WifiMode mode, Time t)
---
> MinstrelHtWifiManager::AddFirstMpduTxTime (uint32_t groupId, WifiMode mode, Time t)
338,339c380,382
<   NS_LOG_FUNCTION (this << +groupId << mode << t);
<   m_minstrelGroups[groupId].ratesFirstMpduTxTimeTable.insert (std::make_pair (mode, t));
---
>   NS_LOG_FUNCTION (this << groupId << mode << t);
> 
>   m_minstrelGroups[groupId].ratesFirstMpduTxTimeTable.push_back (std::make_pair (t, mode));
343c386
< MinstrelHtWifiManager::GetMpduTxTime (uint8_t groupId, WifiMode mode) const
---
> MinstrelHtWifiManager::GetMpduTxTime (uint32_t groupId, WifiMode mode) const
345,348c388,398
<   NS_LOG_FUNCTION (this << +groupId << mode);
<   auto it = m_minstrelGroups[groupId].ratesTxTimeTable.find (mode);
<   NS_ASSERT (it != m_minstrelGroups[groupId].ratesTxTimeTable.end ());
<   return it->second;
---
>   NS_LOG_FUNCTION (this << groupId << mode);
> 
>   for (TxTime::const_iterator i = m_minstrelGroups[groupId].ratesTxTimeTable.begin (); i != m_minstrelGroups[groupId].ratesTxTimeTable.end (); i++)
>     {
>       if (mode == i->second)
>         {
>           return i->first;
>         }
>     }
>   NS_ASSERT (false);
>   return Seconds (0);
352c402
< MinstrelHtWifiManager::AddMpduTxTime (uint8_t groupId, WifiMode mode, Time t)
---
> MinstrelHtWifiManager::AddMpduTxTime (uint32_t groupId, WifiMode mode, Time t)
354,355c404,406
<   NS_LOG_FUNCTION (this << +groupId << mode << t);
<   m_minstrelGroups[groupId].ratesTxTimeTable.insert (std::make_pair (mode, t));
---
>   NS_LOG_FUNCTION (this << groupId << mode << t);
> 
>   m_minstrelGroups[groupId].ratesTxTimeTable.push_back (std::make_pair (t, mode));
361a413
> 
394c446
<   if (GetHtSupported ())
---
>   if (HasHtSupported () || HasVhtSupported ())
414a467
> 
426c479
<       if (!GetHtSupported (station))
---
>       if (!GetHtSupported (station) && !GetVhtSupported (station))
428c481
<           NS_LOG_INFO ("non-HT station " << station);
---
>           NS_LOG_DEBUG ("Non-HT station " << station);
432,433c485,486
<           m_legacyManager->SetAttribute ("LookAroundRate", UintegerValue (m_lookAroundRate));
<           m_legacyManager->SetAttribute ("EWMA", UintegerValue (m_ewmaLevel));
---
>           m_legacyManager->SetAttribute ("LookAroundRate", DoubleValue (m_lookAroundRate));
>           m_legacyManager->SetAttribute ("EWMA", DoubleValue (m_ewmaLevel));
444,445c497
<           station->m_minstrelTable = MinstrelRate (station->m_nModes);
<           station->m_sampleTable = SampleRate (m_numRates, std::vector<uint8_t> (m_nSampleCol));
---
>           station->m_sampleTable = SampleRate (m_numRates, std::vector<uint32_t> (m_nSampleCol));
447a500,502
>           std::ostringstream tmp;
>           tmp << "minstrel-ht-stats-" << station->m_state->m_address << ".txt";
>           station->m_statsFile.open (tmp.str ().c_str (), std::ios::out);
454c509,510
< MinstrelHtWifiManager::DoReportRxOk (WifiRemoteStation *st, double rxSnr, WifiMode txMode)
---
> MinstrelHtWifiManager::DoReportRxOk (WifiRemoteStation *st,
>                                      double rxSnr, WifiMode txMode)
457c513,514
<   NS_LOG_DEBUG ("DoReportRxOk m_txrate=" << static_cast<MinstrelHtWifiRemoteStation*> (st)->m_txrate);
---
> 
>   NS_LOG_DEBUG ("DoReportRxOk m_txrate=" << ((MinstrelHtWifiRemoteStation *)st)->m_txrate);
464c521,523
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
> 
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *)st;
> 
470c529,530
<   NS_LOG_DEBUG ("DoReportRtsFailed m_txrate = " << station->m_txrate);
---
> 
>   NS_LOG_DEBUG ("DoReportRtsFailed m_txrate=" << station->m_txrate);
477a538,539
> 
>   NS_LOG_DEBUG ("self=" << st << " rts ok");
484c546,547
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
> 
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *)st;
485a549
> 
490a555
> 
498c563,564
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
> 
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *)st;
506,507d571
<   NS_LOG_DEBUG ("DoReportDataFailed " << station << "\t rate " << station->m_txrate << "\tlongRetry \t" << station->m_longRetry);
< 
514,515c578,581
<       uint8_t rateId = GetRateId (station->m_txrate);
<       uint8_t groupId = GetGroupId (station->m_txrate);
---
>       NS_LOG_DEBUG ("DoReportDataFailed " << station << "\t rate " << station->m_txrate << "\tlongRetry \t" << station->m_longRetry);
> 
>       uint32_t rateId = GetRateId (station->m_txrate);
>       uint32_t groupId = GetGroupId (station->m_txrate);
516a583
> 
522,523c589,590
< MinstrelHtWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> MinstrelHtWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                        double ackSnr, WifiMode ackMode, double dataSnr)
525,526c592,593
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
534c601
<   NS_LOG_DEBUG ("DoReportDataOk m_txrate = " << station->m_txrate << ", attempt = " << station->m_minstrelTable[station->m_txrate].numRateAttempt << ", success = " << station->m_minstrelTable[station->m_txrate].numRateSuccess << " (before update).");
---
>   NS_LOG_DEBUG ("Data OK - Txrate = " << station->m_txrate  );
543,544d609
<       NS_LOG_DEBUG ("DoReportDataOk m_txrate = " << station->m_txrate << ", attempt = " << station->m_minstrelTable[station->m_txrate].numRateAttempt << ", success = " << station->m_minstrelTable[station->m_txrate].numRateSuccess << " (after update).");
< 
555,556c620,621
<       uint8_t rateId = GetRateId (station->m_txrate);
<       uint8_t groupId = GetGroupId (station->m_txrate);
---
>       uint32_t rateId = GetRateId (station->m_txrate);
>       uint32_t groupId = GetGroupId (station->m_txrate);
562,563d626
<       NS_LOG_DEBUG ("DoReportDataOk m_txrate = " << station->m_txrate << ", attempt = " << station->m_minstrelTable[station->m_txrate].numRateAttempt << ", success = " << station->m_minstrelTable[station->m_txrate].numRateSuccess << " (after update).");
< 
586c649
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
626c689
<   NS_LOG_DEBUG ("Next rate to use TxRate = " << station->m_txrate);
---
>   NS_LOG_DEBUG ("Next rate to use TxRate = " << station->m_txrate  );
630,631c693
< MinstrelHtWifiManager::DoReportAmpduTxStatus (WifiRemoteStation *st, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                                               double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> MinstrelHtWifiManager::DoReportAmpduTxStatus (WifiRemoteStation *st, uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus, double rxSnr, double dataSnr)
633,634c695,696
<   NS_LOG_FUNCTION (this << st << +nSuccessfulMpdus << +nFailedMpdus << rxSnr << dataSnr << dataChannelWidth << +dataNss);
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << nSuccessfulMpdus << nFailedMpdus << rxSnr << dataSnr);
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
642c704,707
<   NS_ASSERT_MSG (station->m_isHt, "A-MPDU Tx Status called but no HT or VHT supported.");
---
>   if (!station->m_isHt)
>     {
>       NS_ASSERT_MSG (false,"A-MPDU Tx Status called but no HT or VHT supported.");
>     }
644,645c709,710
<   NS_LOG_DEBUG ("DoReportAmpduTxStatus. TxRate=" << station->m_txrate << " SuccMpdus=" <<
<                 +nSuccessfulMpdus << " FailedMpdus=" << +nFailedMpdus);
---
>   NS_LOG_DEBUG ("DoReportAmpduTxStatus. TxRate=" << station->m_txrate << " SuccMpdus= " <<
>                 nSuccessfulMpdus << " FailedMpdus= " << nFailedMpdus);
652,653c717,718
<   uint8_t rateId = GetRateId (station->m_txrate);
<   uint8_t groupId = GetGroupId (station->m_txrate);
---
>   uint32_t rateId = GetRateId (station->m_txrate);
>   uint32_t groupId = GetGroupId (station->m_txrate);
677c742
<       NS_LOG_DEBUG ("Next rate to use TxRate = " << station->m_txrate);
---
>       NS_LOG_DEBUG ("Next rate to use TxRate = " << station->m_txrate  );
703c768
<    * Following implementation in Linux, in MinstrelHT lowest base rate is not used.
---
>    * Following implementation in Linux, in MinstrelHT Lowest baserate is not used.
715c780
<    * Get the IDs for all rates.
---
>    * Get the ids for all rates.
717,722c782,787
<   uint8_t maxTpRateId = GetRateId (station->m_maxTpRate);
<   uint8_t maxTpGroupId = GetGroupId (station->m_maxTpRate);
<   uint8_t maxTp2RateId = GetRateId (station->m_maxTpRate2);
<   uint8_t maxTp2GroupId = GetGroupId (station->m_maxTpRate2);
<   uint8_t maxProbRateId = GetRateId (station->m_maxProbRate);
<   uint8_t maxProbGroupId = GetGroupId (station->m_maxProbRate);
---
>   uint32_t maxTpRateId = GetRateId (station->m_maxTpRate);
>   uint32_t maxTpGroupId = GetGroupId (station->m_maxTpRate);
>   uint32_t maxTp2RateId = GetRateId (station->m_maxTpRate2);
>   uint32_t maxTp2GroupId = GetGroupId (station->m_maxTpRate2);
>   uint32_t maxProbRateId = GetRateId (station->m_maxProbRate);
>   uint32_t maxProbGroupId = GetGroupId (station->m_maxProbRate);
752c817
<           NS_FATAL_ERROR ("Max retries reached and m_longRetry not cleared properly. longRetry= " << station->m_longRetry);
---
>           NS_ASSERT_MSG (false,"Max retries reached and m_longRetry not cleared properly. longRetry= " << station->m_longRetry);
776c841
<           NS_FATAL_ERROR ("Max retries reached and m_longRetry not cleared properly. longRetry= " << station->m_longRetry);
---
>           NS_ASSERT_MSG (false,"Max retries reached and m_longRetry not cleared properly. longRetry= " << station->m_longRetry);
787a853
> 
791c857
< MinstrelHtWifiManager::UpdatePacketCounters (MinstrelHtWifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus)
---
> MinstrelHtWifiManager::UpdatePacketCounters (MinstrelHtWifiRemoteStation *station, uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus)
793c859
<   NS_LOG_FUNCTION (this << station << +nSuccessfulMpdus << +nFailedMpdus);
---
>   NS_LOG_FUNCTION (this << station << nSuccessfulMpdus << nFailedMpdus);
811a878,885
> 
> }
> void
> MinstrelHtWifiManager::DoDisposeStation (WifiRemoteStation *st)
> {
>   NS_LOG_FUNCTION (this << st);
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
>   station->DisposeStation ();
818c892
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
828,829c902,904
<       uint64_t dataRate = vector.GetMode ().GetDataRate (vector);
<       if (m_currentRate != dataRate && !station->m_isSampling)
---
> 
>       uint64_t dataRate = vector.GetMode ().GetDataRate (vector.GetChannelWidth (), vector.IsShortGuardInterval (), vector.GetNss ());
>       if (!station->m_isSampling)
831,832c906
<           NS_LOG_DEBUG ("New datarate: " << dataRate);
<           m_currentRate = dataRate;
---
>           m_rateChange (dataRate, station->m_state->m_address);
833a908
> 
840,842c915,917
<       uint8_t rateId = GetRateId (station->m_txrate);
<       uint8_t groupId = GetGroupId (station->m_txrate);
<       uint8_t mcsIndex = station->m_groupsTable[groupId].m_ratesTable[rateId].mcsIndex;
---
>       uint32_t rateId = GetRateId (station->m_txrate);
>       uint32_t groupId = GetGroupId (station->m_txrate);
>       uint32_t mcsIndex = station->m_groupsTable[groupId].m_ratesTable[rateId].mcsIndex;
844c919
<       NS_LOG_DEBUG ("DoGetDataMode rateId= " << +rateId << " groupId= " << +groupId << " mode= " << GetMcsSupported (station, mcsIndex));
---
>       NS_LOG_DEBUG ("DoGetDataMode rateId= " << rateId << " groupId= " << groupId << " mode= " << GetMcsSupported (station, mcsIndex));
849c924
<       if ((group.sgi && !GetShortGuardIntervalSupported (station)) || group.chWidth > GetChannelWidth (station)  ||  group.streams > GetNumberOfSupportedStreams (station))
---
>       if ((group.sgi && !GetShortGuardInterval (station)) || group.chWidth > GetChannelWidth (station)  ||  (uint32_t) group.streams > GetNumberOfSupportedRxAntennas (station))
851,854c926,927
<           NS_FATAL_ERROR ("Inconsistent group selected. Group: (" << +group.streams <<
<                          "," << +group.sgi << "," << group.chWidth << ")" <<
<                          " Station capabilities: (" << GetNumberOfSupportedStreams (station) <<
<                          "," << GetShortGuardIntervalSupported (station) << "," << GetChannelWidth (station) << ")");
---
>           NS_ASSERT_MSG (false,"Inconsistent group selected. Group: (" << (uint32_t)group.streams << "," << (uint32_t)group.sgi << "," << group.chWidth << ")" <<
>                          " Station capabilities: (" << GetNumberOfSupportedRxAntennas (station) << "," << GetShortGuardInterval (station) << "," << GetChannelWidth (station) << ")");
856,858c929,931
<       WifiMode mode = GetMcsSupported (station, mcsIndex);
<       uint64_t dataRate = mode.GetDataRate (group.chWidth, group.sgi ? 400 : 800, group.streams);
<       if (m_currentRate != dataRate && !station->m_isSampling)
---
> 
>       uint64_t dataRate = GetMcsSupported (station, mcsIndex).GetDataRate (group.chWidth, group.sgi, group.streams);
>       if (!station->m_isSampling)
860,861c933
<           NS_LOG_DEBUG ("New datarate: " << dataRate);
<           m_currentRate = dataRate;
---
>           m_rateChange (dataRate, station->m_state->m_address);
863c935,937
<       return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), group.sgi ? 400 : 800, GetNumberOfAntennas (), group.streams, GetNess (station), GetChannelWidthForTransmission (mode, group.chWidth), GetAggregation (station) && !station->m_isSampling, false);
---
> 
>       return WifiTxVector (GetMcsSupported (station, mcsIndex), GetDefaultTxPowerLevel (), GetLongRetryCount (station),
>                            group.sgi, group.streams, GetNess (station), group.chWidth, GetAggregation (station) && !station->m_isSampling, GetStbc (station));
871c945
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
900,902c974,976
<       uint8_t rateId = GetRateId (station->m_txrate);
<       uint8_t groupId = GetGroupId (station->m_txrate);
<       uint8_t mcsIndex = station->m_groupsTable[groupId].m_ratesTable[rateId].mcsIndex;
---
>       uint32_t rateId = GetRateId (station->m_txrate);
>       uint32_t groupId = GetGroupId (station->m_txrate);
>       uint32_t mcsIndex = station->m_groupsTable[groupId].m_ratesTable[rateId].mcsIndex;
906c980
<       uint8_t nBasicRates = GetNBasicModes ();
---
>       uint32_t nBasicRates = GetNBasicModes ();
911c985
<       for (uint8_t i = 0; i < nBasicRates; i++)
---
>       for (uint32_t i = 0; i < nBasicRates; i++)
913c987
<           uint64_t rate = GetBasicMode (i).GetDataRate (20);
---
>           uint64_t rate = GetBasicMode (i).GetDataRate (20,false,1);
924,925c998,999
<           uint8_t nSupportRates = phy->GetNModes ();
<           for (uint8_t i = 0; i < nSupportRates; i++)
---
>           uint32_t nSupportRates = phy->GetNModes ();
>           for (uint32_t i = 0; i < nSupportRates; i++)
927c1001
<               uint64_t rate = phy->GetMode (i).GetDataRate (20);
---
>               uint64_t rate = phy->GetMode (i).GetDataRate (20,false,1);
938,939c1012,1013
<       return WifiTxVector (rtsRate, GetDefaultTxPowerLevel (), GetPreambleForTransmission (rtsRate.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))),
<                            800, 1, 1, 0, GetChannelWidthForTransmission (rtsRate, GetChannelWidth (station)), GetAggregation (station), false);
---
>       return WifiTxVector (rtsRate, GetDefaultTxPowerLevel (), GetShortRetryCount (station),
>                            false, 1, 0, GetChannelWidth (station), GetAggregation (station), false);
944c1018
< MinstrelHtWifiManager::DoNeedRetransmission (WifiRemoteStation *st, Ptr<const Packet> packet, bool normally)
---
> MinstrelHtWifiManager::DoNeedDataRetransmission (WifiRemoteStation *st, Ptr<const Packet> packet, bool normally)
948c1022
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *)st;
982,987c1056,1061
<   uint8_t maxProbRateId = GetRateId (station->m_maxProbRate);
<   uint8_t maxProbGroupId = GetGroupId (station->m_maxProbRate);
<   uint8_t maxTpRateId = GetRateId (station->m_maxTpRate);
<   uint8_t maxTpGroupId = GetGroupId (station->m_maxTpRate);
<   uint8_t maxTp2RateId = GetRateId (station->m_maxTpRate2);
<   uint8_t maxTp2GroupId = GetGroupId (station->m_maxTpRate2);
---
>   uint32_t maxProbRateId = GetRateId (station->m_maxProbRate);
>   uint32_t maxProbGroupId = GetGroupId (station->m_maxProbRate);
>   uint32_t maxTpRateId = GetRateId (station->m_maxTpRate);
>   uint32_t maxTpGroupId = GetGroupId (station->m_maxTpRate);
>   uint32_t maxTp2RateId = GetRateId (station->m_maxTpRate2);
>   uint32_t maxTp2GroupId = GetGroupId (station->m_maxTpRate2);
1002c1076,1083
< uint16_t
---
> bool
> MinstrelHtWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
> }
> 
> uint32_t
1006,1011c1087,1097
<   uint8_t sampleGroup = station->m_sampleGroup;
<   uint8_t index = station->m_groupsTable[sampleGroup].m_index;
<   uint8_t col = station->m_groupsTable[sampleGroup].m_col;
<   uint8_t sampleIndex = station->m_sampleTable[index][col];
<   uint16_t rateIndex = GetIndex (sampleGroup, sampleIndex);
<   NS_LOG_DEBUG ("Next Sample is " << rateIndex);
---
> 
>   uint32_t sampleGroup = station->m_sampleGroup;
> 
>   uint32_t index = station->m_groupsTable[sampleGroup].m_index;
>   uint32_t col = station->m_groupsTable[sampleGroup].m_col;
> 
>   uint32_t sampleIndex = station->m_sampleTable[index][col];
> 
>   uint32_t rateIndex = GetIndex (sampleGroup, sampleIndex);
>   NS_LOG_DEBUG ("Next Sample is " << rateIndex );
> 
1012a1099
> 
1029c1116
<   uint8_t sampleGroup = station->m_sampleGroup;
---
>   uint32_t sampleGroup = station->m_sampleGroup;
1044c1131
<   NS_LOG_DEBUG ("New sample set: group= " << +sampleGroup << " index= " << +station->m_sampleTable[index][col]);
---
>   NS_LOG_DEBUG ("New sample set: group= " << sampleGroup << " index= " << station->m_sampleTable[index][col]);
1047c1134
< uint16_t
---
> uint32_t
1051c1138
<   NS_LOG_DEBUG ("FindRate packet=" << station->m_totalPacketsCount);
---
>   NS_LOG_DEBUG ("FindRate " << "packet=" << station->m_totalPacketsCount );
1064c1151
<       uint16_t sampleIdx = GetNextSample (station);
---
>       uint32_t sampleIdx = GetNextSample (station);
1068,1069c1155,1156
<       uint8_t sampleGroupId = GetGroupId (sampleIdx);
<       uint8_t sampleRateId = GetRateId (sampleIdx);
---
>       uint32_t sampleGroupId = GetGroupId (sampleIdx);
>       uint32_t sampleRateId = GetRateId (sampleIdx);
1095,1099c1182,1186
<               uint8_t maxTpGroupId = GetGroupId (station->m_maxTpRate);
<               uint8_t maxTp2GroupId = GetGroupId (station->m_maxTpRate2);
<               uint8_t maxTp2RateId = GetRateId (station->m_maxTpRate2);
<               uint8_t maxProbGroupId = GetGroupId (station->m_maxProbRate);
<               uint8_t maxProbRateId = GetRateId (station->m_maxProbRate);
---
>               uint32_t maxTpGroupId = GetGroupId (station->m_maxTpRate);
>               uint32_t maxTp2GroupId = GetGroupId (station->m_maxTpRate2);
>               uint32_t maxTp2RateId = GetRateId (station->m_maxTpRate2);
>               uint32_t maxProbGroupId = GetGroupId (station->m_maxProbRate);
>               uint32_t maxProbRateId = GetRateId (station->m_maxProbRate);
1109,1110c1196,1197
<                             " maxProbDuration= " << maxProbDuration << " sampleStreams= " << +sampleStreams <<
<                             " maxTpStreams= " << +maxTpStreams);
---
>                             " maxProbDuration= " << maxProbDuration << " sampleStreams= " << (uint32_t)sampleStreams <<
>                             " maxTpStreams= " << (uint32_t)maxTpStreams);
1156a1244,1245
>   NS_LOG_DEBUG ("Updating stats=" << this);
> 
1166c1255
<       uint32_t newLen = station->m_ampduLen / station->m_ampduPacketCount;
---
>       double newLen = station->m_ampduLen / station->m_ampduPacketCount;
1178c1267
<   for (uint8_t j = 0; j < m_numGroups; j++)
---
>   for (uint32_t j = 0; j < m_numGroups; j++)
1189c1278
<           for (uint8_t i = 0; i < m_numRates; i++)
---
>           for (uint32_t i = 0; i < m_numRates; i++)
1195c1284
<                   NS_LOG_DEBUG (+i << " " << GetMcsSupported (station, station->m_groupsTable[j].m_ratesTable[i].mcsIndex) <<
---
>                   NS_LOG_DEBUG (i << " " << GetMcsSupported (station,  station->m_groupsTable[j].m_ratesTable[i].mcsIndex) <<
1209c1298
<                       /// Bookkeeping.
---
>                       /// Bookeeping.
1236c1325
<                   /// Bookkeeping.
---
>                   /// Bookeeping.
1269c1358
< MinstrelHtWifiManager::CalculateThroughput (MinstrelHtWifiRemoteStation *station, uint8_t groupId, uint8_t rateId, double ewmaProb)
---
> MinstrelHtWifiManager::CalculateThroughput (MinstrelHtWifiRemoteStation *station, uint32_t groupId, uint32_t rateId, double ewmaProb)
1273c1362
<   * Do not account throughput if probability of success is below 10%
---
>   * Do not account throughput if sucess prob is below 10%
1299c1388
< MinstrelHtWifiManager::SetBestProbabilityRate (MinstrelHtWifiRemoteStation *station, uint16_t index)
---
> MinstrelHtWifiManager::SetBestProbabilityRate (MinstrelHtWifiRemoteStation *station, uint32_t index)
1303c1392
<   uint8_t tmpGroupId, tmpRateId;
---
>   uint32_t tmpGroupId, tmpRateId;
1305c1394
<   uint8_t groupId, rateId;
---
>   uint32_t groupId, rateId;
1308c1397
<   uint8_t maxGPGroupId, maxGPRateId;
---
>   uint32_t maxGPGroupId, maxGPRateId;
1360c1449
< MinstrelHtWifiManager::SetBestStationThRates (MinstrelHtWifiRemoteStation *station, uint16_t index)
---
> MinstrelHtWifiManager::SetBestStationThRates (MinstrelHtWifiRemoteStation *station, uint32_t index)
1362c1451
<   uint8_t groupId, rateId;
---
>   uint32_t groupId, rateId;
1364,1365c1453,1454
<   uint8_t maxTpGroupId, maxTpRateId;
<   uint8_t maxTp2GroupId, maxTp2RateId;
---
>   uint32_t maxTpGroupId, maxTpRateId;
>   uint32_t maxTp2GroupId, maxTp2RateId;
1421a1511
>   NS_LOG_DEBUG ("RateInit=" << station);
1429c1519
<   for (uint8_t groupId = 0; groupId < m_numGroups; groupId++)
---
>   for (uint32_t groupId = 0; groupId < m_numGroups; groupId++)
1434c1524
<           if (!(!GetVhtSupported (station) && m_minstrelGroups[groupId].isVht)                    ///Is VHT supported by the receiver?
---
>           if (!(!GetVhtSupported (station) && m_minstrelGroups[groupId].isVht)                  ///Is VHT supported by the receiver?
1436,1438c1526,1528
<               && !(!GetShortGuardIntervalSupported (station) && m_minstrelGroups[groupId].sgi)    ///Is SGI supported by the receiver?
<               && (GetChannelWidth (station) >= m_minstrelGroups[groupId].chWidth)                 ///Is channel width supported by the receiver?
<               && (GetNumberOfSupportedStreams (station) >= m_minstrelGroups[groupId].streams))    ///Are streams supported by the receiver?
---
>               && !(!GetShortGuardInterval (station) && m_minstrelGroups[groupId].sgi)           ///Is SGI supported by the receiver?
>               && (GetChannelWidth (station) >= m_minstrelGroups[groupId].chWidth)               ///Is channel width supported by the receiver?
>               && (GetNumberOfSupportedRxAntennas (station) >= m_minstrelGroups[groupId].streams)) ///Are streams supported by the receiver?
1440,1441c1530,1531
<               NS_LOG_DEBUG ("Group " << +groupId << ": (" << +m_minstrelGroups[groupId].streams <<
<                             "," << +m_minstrelGroups[groupId].sgi << "," << m_minstrelGroups[groupId].chWidth << ")");
---
>               NS_LOG_DEBUG ("Group " << groupId << ": (" << (uint32_t)m_minstrelGroups[groupId].streams <<
>                             "," << (uint32_t)m_minstrelGroups[groupId].sgi << "," << m_minstrelGroups[groupId].chWidth << ")");
1448c1538
<               for (uint8_t i = 0; i < m_numRates; i++)
---
>               for (uint32_t i = 0; i < m_numRates; i++)
1454c1544
<               for (uint8_t i = 0; i < station->m_nModes; i++)
---
>               for (uint32_t i = 0; i < station->m_nModes; i++)
1460c1550
<                   uint8_t rateId = mode.GetMcsValue ();
---
>                   uint32_t rateId = mode.GetMcsValue ();
1472c1562
<                       NS_LOG_DEBUG ("Mode " << +i << ": " << mode << " isVht: " << m_minstrelGroups[groupId].isVht);
---
>                       NS_LOG_DEBUG ("Mode " << i << ": " << mode << " isVht: " << m_minstrelGroups[groupId].isVht);
1501c1591
< MinstrelHtWifiManager::CalculateRetransmits (MinstrelHtWifiRemoteStation *station, uint16_t index)
---
> MinstrelHtWifiManager::CalculateRetransmits (MinstrelHtWifiRemoteStation *station, uint32_t index)
1504,1505c1594,1595
<   uint8_t groupId = GetGroupId (index);
<   uint8_t rateId = GetRateId (index);
---
>   uint32_t groupId = GetGroupId (index);
>   uint32_t rateId = GetRateId (index);
1513c1603
< MinstrelHtWifiManager::CalculateRetransmits (MinstrelHtWifiRemoteStation *station, uint8_t groupId, uint8_t rateId)
---
> MinstrelHtWifiManager::CalculateRetransmits (MinstrelHtWifiRemoteStation *station, uint32_t groupId, uint32_t rateId)
1515c1605,1606
<   NS_LOG_FUNCTION (this << station << +groupId << +rateId);
---
>   NS_LOG_FUNCTION (this << station << groupId << groupId);
>   NS_LOG_DEBUG (" Calculating the number of retries");
1560c1651
< MinstrelHtWifiManager::CalculateEwmsd (double oldEwmsd, double currentProb, double ewmaProb, double weight)
---
> MinstrelHtWifiManager::CalculateEwmsd (double oldEwmsd, double currentProb, double ewmaProb, uint32_t weight)
1577c1668,1669
<   NS_LOG_FUNCTION (this << station);
---
>   NS_LOG_DEBUG ("InitSampleTable=" << this);
> 
1581c1673
<   uint8_t numSampleRates = m_numRates;
---
>   uint32_t numSampleRates = m_numRates;
1583,1584c1675,1676
<   uint16_t newIndex;
<   for (uint8_t col = 0; col < m_nSampleCol; col++)
---
>   uint32_t newIndex;
>   for (uint32_t col = 0; col < m_nSampleCol; col++)
1586c1678
<       for (uint8_t i = 0; i < numSampleRates; i++ )
---
>       for (uint32_t i = 0; i < numSampleRates; i++ )
1608,1613c1700,1701
<   if (!station->m_statsFile.is_open ())
<     {
<       std::ostringstream tmp;
<       tmp << "minstrel-ht-stats-" << station->m_state->m_address << ".txt";
<       station->m_statsFile.open (tmp.str ().c_str (), std::ios::out);
<     }
---
>   NS_LOG_FUNCTION (this << station);
>   NS_LOG_DEBUG ("PrintTable=" << station);
1617c1705
<   for (uint8_t i = 0; i < m_numGroups; i++)
---
>   for (uint32_t i = 0; i < m_numGroups; i++)
1630c1718
< MinstrelHtWifiManager::StatsDump (MinstrelHtWifiRemoteStation *station, uint8_t groupId, std::ofstream &of)
---
> MinstrelHtWifiManager::StatsDump (MinstrelHtWifiRemoteStation *station, uint32_t groupId, std::ofstream &of)
1632c1720
<   uint8_t numRates = m_numRates;
---
>   uint32_t numRates = m_numRates;
1644c1732
<   for (uint8_t i = 0; i < numRates; i++)
---
>   for (uint32_t i = 0; i < numRates; i++)
1657,1659c1745,1747
<           uint16_t maxTpRate = station->m_maxTpRate;
<           uint16_t maxTpRate2 = station->m_maxTpRate2;
<           uint16_t maxProbRate = station->m_maxProbRate;
---
>           uint32_t maxTpRate = station->m_maxTpRate;
>           uint32_t maxTpRate2 = station->m_maxTpRate2;
>           uint32_t maxProbRate = station->m_maxProbRate;
1661c1749
<           uint16_t idx = GetIndex (groupId, i);
---
>           uint32_t idx = GetIndex (groupId, i);
1693c1781
<               of << std::setw (7) << "   MCS" << +i << "/" << (int) group.streams;
---
>               of << std::setw (7) << "   MCS" << i << "/" << (int) group.streams;
1696c1784
<           of << "  " << std::setw (3) << +idx << "  ";
---
>           of << "  " << std::setw (3) << idx << "  ";
1715,1716c1803,1804
< uint16_t
< MinstrelHtWifiManager::GetIndex (uint8_t groupId, uint8_t rateId)
---
> uint32_t
> MinstrelHtWifiManager::GetIndex (uint32_t groupId, uint32_t rateId)
1718,1719c1806,1807
<   NS_LOG_FUNCTION (this << +groupId << +rateId);
<   uint16_t index;
---
>   NS_LOG_FUNCTION (this << groupId << rateId);
>   uint32_t index;
1724,1725c1812,1813
< uint8_t
< MinstrelHtWifiManager::GetRateId (uint16_t index)
---
> uint32_t
> MinstrelHtWifiManager::GetRateId (uint32_t index)
1728c1816,1817
<   uint8_t id;
---
> 
>   uint32_t id;
1733,1734c1822,1823
< uint8_t
< MinstrelHtWifiManager::GetGroupId (uint16_t index)
---
> uint32_t
> MinstrelHtWifiManager::GetGroupId (uint32_t index)
1736a1826
> 
1740,1741c1830,1831
< uint8_t
< MinstrelHtWifiManager::GetHtGroupId (uint8_t txstreams, uint8_t sgi, uint16_t chWidth)
---
> uint32_t
> MinstrelHtWifiManager::GetHtGroupId (uint8_t txstreams, uint8_t sgi, uint32_t chWidth)
1743c1833,1834
<   NS_LOG_FUNCTION (this << +txstreams << +sgi << chWidth);
---
>   NS_LOG_FUNCTION (this << (int)txstreams << (int)sgi << chWidth);
> 
1747,1748c1838,1839
< uint8_t
< MinstrelHtWifiManager::GetVhtGroupId (uint8_t txstreams, uint8_t sgi, uint16_t chWidth)
---
> uint32_t
> MinstrelHtWifiManager::GetVhtGroupId (uint8_t txstreams, uint8_t sgi, uint32_t chWidth)
1750c1841,1842
<   NS_LOG_FUNCTION (this << +txstreams << +sgi << chWidth);
---
>   NS_LOG_FUNCTION (this << (int)txstreams << (int)sgi << chWidth);
> 
1754c1846
< uint16_t
---
> uint32_t
1759,1760c1851,1852
<   uint8_t groupId = 0;
<   uint8_t rateId = 0;
---
>   uint32_t groupId = 0;
>   uint32_t rateId = 0;
1773,1774c1865,1866
< uint16_t
< MinstrelHtWifiManager::GetLowestIndex (MinstrelHtWifiRemoteStation *station, uint8_t groupId)
---
> uint32_t
> MinstrelHtWifiManager::GetLowestIndex (MinstrelHtWifiRemoteStation *station, uint32_t groupId)
1776c1868
<   NS_LOG_FUNCTION (this << station << +groupId);
---
>   NS_LOG_FUNCTION (this << station);
1778c1870
<   uint8_t rateId = 0;
---
>   uint32_t rateId = 0;
1786a1879
> 
1792c1885
<   for (uint8_t i = 0; i < phy->GetNMcs (); i++)
---
>   for (uint32_t i = 0; i < phy->GetNMcs (); i++)
1808c1901
<   for (uint8_t i = 0; i < phy->GetNMcs (); i++)
---
>   for (uint32_t i = 0; i < phy->GetNMcs (); i++)
1819a1913,1917
> 
> 
> 
> 
> 
diff ../../NS3-WiGig/src/wifi/model/minstrel-ht-wifi-manager.h ../../ns-3-dev/src/wifi/model/minstrel-ht-wifi-manager.h
19,21c19,21
<  *Authors: Duy Nguyen <duy@soe.ucsc.edu>
<  *         Ghada Badawy <gbadawy@gmail.com>
<  *         Matias Richart <mrichart@fing.edu.uy>
---
>  *Author: Duy Nguyen <duy@soe.ucsc.edu>
>  *        Ghada Badawy <gbadawy@gmail.com>
>  *        Matias Richart <mrichart@fing.edu.uy>
31c31,36
< #include "wifi-mpdu-type.h"
---
> #include "wifi-mode.h"
> #include "ns3/nstime.h"
> #include "ns3/random-variable-stream.h"
> #include <vector>
> #include <map>
> #include <deque>
36a42
>  * A vector of Time, WifiMode pairs.
38c44
< typedef std::map<WifiMode, Time> TxTime;
---
> typedef std::vector<std::pair<Time, WifiMode> > TxTime;
48,52c54,59
<   uint8_t streams;  ///< streams
<   uint8_t sgi;      ///< short guard interval (0 or 1)
<   uint16_t chWidth; ///< channel width (MHz)
<   bool isVht;       ///< is VHT?
<   bool isSupported; ///< is supported?
---
>   uint8_t streams;
>   uint8_t sgi;
>   uint32_t chWidth;
>   bool isVht;
>   bool isSupported;
> 
55,56c62,63
<   TxTime ratesTxTimeTable;          ///< rates transmit time table
<   TxTime ratesFirstMpduTxTimeTable; ///< rates MPDU transmit time table
---
>   TxTime ratesTxTimeTable;
>   TxTime ratesFirstMpduTxTimeTable;
63c70
< typedef std::vector<McsGroup> MinstrelMcsGroups;
---
> typedef std::vector<struct McsGroup> MinstrelMcsGroups;
75a83
> 
77c85,87
<   uint8_t mcsIndex;             //!< The index in the operationalMcsSet of the WifiRemoteStationManager.
---
> 
>   uint32_t mcsIndex;            //!< The index in the operationalMcsSet of the WifiRemoteStationManager.
> 
82a93
> 
83a95
> 
89a102
> 
90a104
> 
96c110
<   double throughput;            //!< Throughput of this rate (in packets per second).
---
>   double throughput;            //!< Throughput of this rate (in pkts per second).
103c117
< typedef std::vector<HtRateInfo> HtMinstrelRate;
---
> typedef std::vector<struct HtRateInfo> HtMinstrelRate;
114a129
> 
116,118c131,135
<   uint16_t m_maxTpRate;           //!< The max throughput rate of this group in bps.
<   uint16_t m_maxTpRate2;          //!< The second max throughput rate of this group in bps.
<   uint16_t m_maxProbRate;         //!< The highest success probability rate of this group in bps.
---
> 
>   uint32_t m_maxTpRate;           //!< The max throughput rate of this group.
>   uint32_t m_maxTpRate2;          //!< The second max throughput rate of this group.
>   uint32_t m_maxProbRate;         //!< The highest success probability rate of this group.
> 
128a146,151
>  * Data structure for a Sample Rate table.
>  * A vector of a vector uint32_t.
>  */
> typedef std::vector<std::vector<uint32_t> > HtSampleRate;
> 
> /**
132c155
< static const uint8_t MAX_SUPPORTED_STREAMS = 4;  //!< Maximal number of streams supported by the PHY layer.
---
> static const uint8_t MAX_SUPPORTED_STREAMS = 4;  //!< Maximal number of streams supported by the phy layer.
137,138c160,161
< static const uint8_t MAX_HT_WIDTH = 40;          //!< Maximal channel width in MHz.
< static const uint8_t MAX_VHT_WIDTH = 160;        //!< Maximal channel width in MHz.
---
> static const uint8_t MAX_HT_WIDTH = 40;          //!< Maximal channel width.
> static const uint8_t MAX_VHT_WIDTH = 160;        //!< Maximal channel width.
144c167
<  * Minstrel-HT is a rate adaptation mechanism for the 802.11n/ac standard
---
>  * Minstrel-HT is a rate adaptation mechanism for the 802.11n/ac standard 
146,150c169,173
<  * to dynamically learn about working rates that can be supported.
<  * Minstrel-HT is designed for high-latency devices that implement a
<  * Multiple Rate Retry (MRR) chain. This kind of device does
<  * not give feedback for every frame retransmission, but only when a frame
<  * was correctly transmitted (an Ack is received) or a frame transmission
---
>  * to dynamically learn about working rates that can be supported.  
>  * Minstrel-HT is designed for high-latency devices that implement a 
>  * Multiple Rate Retry (MRR) chain. This kind of device does 
>  * not give feedback for every frame retransmission, but only when a frame 
>  * was correctly transmitted (an ACK is received) or a frame transmission 
152c175
<  * The MRR chain is used to advise the hardware about which rate to use
---
>  * The MRR chain is used to advise the hardware about which rate to use 
154,155c177,178
<  *
<  * Minstrel-HT adapts the MCS, channel width, number of streams, and
---
>  * 
>  * Minstrel-HT adapts the MCS, channel width, number of streams, and 
157,159c180,182
<  * it arranges MCS in groups, where each group is defined by the
<  * tuple (streams, SGI, channel width).  There is a vector of all groups
<  * supported by the PHY layer of the transmitter; for each group, the
---
>  * it arranges MCS in groups, where each group is defined by the 
>  * tuple (#streams, SGI, channel width).  There is a vector of all groups 
>  * supported by the PHY layer of the transmitter; for each group, the 
162,163c185,186
<  * Each station maintains a table of groups statistics. For each group, a flag
<  * indicates if the group is supported by the station. Different stations
---
>  * Each station maintains a table of groups statistics. For each group, a flag 
>  * indicates if the group is supported by the station. Different stations 
166,167c189,190
<  * Stats are updated per A-MPDU when receiving AmpduTxStatus. If the number
<  * of successful or failed MPDUs is greater than zero (a BlockAck was
---
>  * Stats are updated per A-MPDU when receiving AmpduTxStatus. If the number 
>  * of successful or failed MPDUs is greater than zero (a BlockAck was 
169c192
<  * If the number of successful and failed MPDUs is zero (BlockAck timeout),
---
>  * If the number of successful and failed MPDUs is zero (BlockAck timeout), 
171,173c194,196
<  *
<  * On each update interval, it sets the maxThrRate, the secondmaxThrRate
<  * and the maxProbRate for the MRR chain. These rates are only used when
---
>  * 
>  * On each update interval, it sets the maxThrRate, the secondmaxThrRate 
>  * and the maxProbRate for the MRR chain. These rates are only used when 
175,178c198,201
<  *
<  * Differently from legacy minstrel, sampling is not done based on
<  * "lookaround ratio", but assuring all rates are sampled at least once
<  * each interval. However, it samples less often the low rates and high
---
>  * 
>  * Differently from legacy minstrel, sampling is not done based on 
>  * "lookaround ratio", but assuring all rates are sampled at least once 
>  * each interval. However, it samples less often the low rates and high 
181c204
<  * When this rate control is configured but non-legacy modes are not supported,
---
>  * When this rate control is configured but HT and VHT are not supported, 
183,186d205
<  *
<  * This RAA does not support HE modes yet and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11ax or higher.
189a209
> 
191,194d210
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
210,211c226,227
<   void SetupPhy (const Ptr<WifiPhy> phy);
<   void SetupMac (const Ptr<WifiMac> mac);
---
>   virtual void SetupPhy (Ptr<WifiPhy> phy);
>   virtual void SetupMac (Ptr<WifiMac> mac);
221d236
< 
223,283c238,271
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
<   void DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                               double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   bool DoNeedRetransmission (WifiRemoteStation *st, Ptr<const Packet> packet, bool normally);
< 
<   /**
<    * Check the validity of a combination of number of streams, chWidth and mode.
<    *
<    * \param phy pointer to the wifi PHY
<    * \param streams the number of streams
<    * \param chWidth the channel width (MHz)
<    * \param mode the wifi mode
<    * \returns true if the combination is valid
<    */
<   bool IsValidMcs (Ptr<WifiPhy> phy, uint8_t streams, uint16_t chWidth, WifiMode mode);
< 
<   /**
<    * Estimates the TxTime of a frame with a given mode and group (stream, guard interval and channel width).
<    *
<    * \param phy pointer to the wifi PHY
<    * \param streams the number of streams
<    * \param sgi short guard interval enabled (0 or 1)
<    * \param chWidth the channel width (MHz)
<    * \param mode the wifi mode
<    * \param mpduType the type of the MPDU
<    * \returns the transmit time
<    */
<   Time CalculateMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi,
<                                 uint16_t chWidth, WifiMode mode, MpduType mpduType);
< 
<   /**
<    * Obtain the TxTime saved in the group information.
<    *
<    * \param groupId the group ID
<    * \param mode the wifi mode
<    * \returns the transmit time
<    */
<   Time GetMpduTxTime (uint8_t groupId, WifiMode mode) const;
< 
<   /**
<    * Save a TxTime to the vector of groups.
<    *
<    * \param groupId the group ID
<    * \param mode the wifi mode
<    * \param t the transmit time
<    */
<   void AddMpduTxTime (uint8_t groupId, WifiMode mode, Time t);
---
>   // Overriden from base class.
>   virtual void DoInitialize (void);
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual void DoReportAmpduTxStatus (WifiRemoteStation *station, uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus, double rxSnr, double dataSnr);
>   virtual bool IsLowLatency (void) const;
>   virtual bool DoNeedDataRetransmission (WifiRemoteStation *st, Ptr<const Packet> packet, bool normally);
>   virtual void DoDisposeStation (WifiRemoteStation *station);
> 
>   /// Check the validity of a combination of number of streams, chWidth and mode.
>   bool IsValidMcs (Ptr<WifiPhy> phy, uint8_t streams, uint32_t chWidth, WifiMode mode);
> 
>   /// Estimates the TxTime of a frame with a given mode and group (stream, guard interval and channel width).
>   Time CalculateMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi, uint32_t chWidth, WifiMode mode);
> 
>   /// Estimates the TxTime of a frame with a given mode and group (stream, guard interval and channel width).
>   Time CalculateFirstMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi, uint32_t chWidth, WifiMode mode);
> 
>   /// Obtain the TXtime saved in the group information.
>   Time GetMpduTxTime (uint32_t groupId, WifiMode mode) const;
> 
>   /// Save a TxTime to the vector of groups.
>   void AddMpduTxTime (uint32_t groupId, WifiMode mode, Time t);
285,292c273,274
<   /**
<    * Obtain the TxTime saved in the group information.
<    *
<    * \param groupId the group ID
<    * \param mode the wifi mode
<    * \returns the transmit time
<    */
<   Time GetFirstMpduTxTime (uint8_t groupId, WifiMode mode) const;
---
>   /// Obtain the TXtime saved in the group information.
>   Time GetFirstMpduTxTime (uint32_t groupId, WifiMode mode) const;
294,301c276,277
<   /**
<    * Save a TxTime to the vector of groups.
<    *
<    * \param groupId the group ID
<    * \param mode the wifi mode
<    * \param t the transmit time
<    */
<   void AddFirstMpduTxTime (uint8_t groupId, WifiMode mode, Time t);
---
>   /// Save a TxTime to the vector of groups.
>   void AddFirstMpduTxTime (uint32_t groupId, WifiMode mode, Time t);
303,306c279
<   /**
<    * Update the number of retries and reset accordingly.
<    * \param station the wifi remote station
<    */
---
>   /// Update the number of retries and reset accordingly.
309,316c282,283
<   /**
<    * Update the number of sample count variables.
<    *
<    * \param station the wifi remote station
<    * \param nSuccessfulMpdus the number of successfully received MPDUs
<    * \param nFailedMpdus the number of failed MPDUs
<    */
<   void UpdatePacketCounters (MinstrelHtWifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus);
---
>   /// Update the number of sample count variables.
>   void UpdatePacketCounters (MinstrelHtWifiRemoteStation *station, uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus);
318,324c285,286
<   /**
<    * Getting the next sample from Sample Table.
<    *
<    * \param station the wifi remote station
<    * \returns the next sample
<    */
<   uint16_t GetNextSample (MinstrelHtWifiRemoteStation *station);
---
>   /// Getting the next sample from Sample Table.
>   uint32_t GetNextSample (MinstrelHtWifiRemoteStation *station);
326,330c288
<   /**
<    * Set the next sample from Sample Table.
<    *
<    * \param station the wifi remote station
<    */
---
>   /// Set the next sample from Sample Table.
333,339c291,292
<   /**
<    * Find a rate to use from Minstrel Table.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \returns the rate in bps
<    */
<   uint16_t FindRate (MinstrelHtWifiRemoteStation *station);
---
>   /// Find a rate to use from Minstrel Table.
>   uint32_t FindRate (MinstrelHtWifiRemoteStation *station);
341,345c294
<   /**
<    * Update the Minstrel Table every 1/10 seconds.
<    *
<    * \param station the minstrel HT wifi remote station
<    */
---
>   /// Updating the Minstrel Table every 1/10 seconds.
348,352c297
<   /**
<    * Initialize Minstrel Table.
<    *
<    * \param station the minstrel HT wifi remote station
<    */
---
>   /// Initialize Minstrel Table.
355,364c300,301
<   /**
<    * Return the average throughput of the MCS defined by groupId and rateId.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \param groupId the group ID
<    * \param rateId the rate ID
<    * \param ewmaProb the EWMA probability
<    * \returns the throughput in bps
<    */
<   double CalculateThroughput (MinstrelHtWifiRemoteStation *station, uint8_t groupId, uint8_t rateId, double ewmaProb);
---
>   /// Return the average throughput of the MCS defined by groupId and rateId.
>   double CalculateThroughput (MinstrelHtWifiRemoteStation *station, uint32_t groupId, uint32_t rateId, double ewmaProb);
366,372c303,304
<   /**
<    * Set index rate as maxTpRate or maxTp2Rate if is better than current values.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \param index the index
<    */
<   void SetBestStationThRates (MinstrelHtWifiRemoteStation *station, uint16_t index);
---
>   /// Set index rate as maxTpRate or maxTp2Rate if is better than current values.
>   void SetBestStationThRates (MinstrelHtWifiRemoteStation *station, uint32_t index);
374,380c306,307
<   /**
<    * Set index rate as maxProbRate if it is better than current value.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \param index the index
<    */
<   void SetBestProbabilityRate (MinstrelHtWifiRemoteStation *station, uint16_t index);
---
>   /// Set index rate as maxProbRate if it is better than current value.
>   void SetBestProbabilityRate (MinstrelHtWifiRemoteStation *station, uint32_t index);
382,388c309,310
<   /**
<    * Calculate the number of retransmissions to set for the index rate.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \param index the index
<    */
<   void CalculateRetransmits (MinstrelHtWifiRemoteStation *station, uint16_t index);
---
>   /// Calculate the number of retransmissions to set for the index rate.
>   void CalculateRetransmits (MinstrelHtWifiRemoteStation *station, uint32_t index);
390,397c312,313
<   /**
<    * Calculate the number of retransmissions to set for the (groupId, rateId) rate.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \param groupId the group ID
<    * \param rateId the rate ID
<    */
<   void CalculateRetransmits (MinstrelHtWifiRemoteStation *station, uint8_t groupId, uint8_t rateId);
---
>   /// Calculate the number of retransmissions to set for the (groupId, rateId) rate.
>   void CalculateRetransmits (MinstrelHtWifiRemoteStation *station, uint32_t groupId, uint32_t rateId);
411,412c327,328
<    *  - Ack timeouts
<    *  - Data transmission
---
>    *  - ACK timeouts
>    *  - DATA transmission
414,418d329
<    *
<    * \param dataTransmissionTime the data transmission time
<    * \param shortRetries the short retries
<    * \param longRetries the long retries
<    * \returns the unicast packet time
422,431c333,334
<   /**
<    * Perform EWMSD (Exponentially Weighted Moving Standard Deviation) calculation.
<    *
<    * \param oldEwmsd the old EWMSD
<    * \param currentProb the current probability
<    * \param ewmaProb the EWMA probability
<    * \param weight the weight
<    * \returns the EWMSD
<    */
<   double CalculateEwmsd (double oldEwmsd, double currentProb, double ewmaProb, double weight);
---
>   /// Perform EWMSD (Exponentially Weighted Moving Standard Deviation) calculation.
>   double CalculateEwmsd (double oldEwmsd, double currentProb, double ewmaProb, uint32_t weight);
433,437c336
<   /**
<    * Initialize Sample Table.
<    *
<    * \param station the minstrel HT wifi remote station
<    */
---
>   /// Initialize Sample Table.
440,444c339
<   /**
<    * Printing Sample Table.
<    *
<    * \param station the minstrel HT wifi remote station
<    */
---
>   /// Printing Sample Table.
447,451c342
<   /**
<    * Printing Minstrel Table.
<    *
<    * \param station the minstrel HT wifi remote station
<    */
---
>   /// Printing Minstrel Table.
454,461c345,346
<   /**
<    * Print group statistics.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \param groupId the group ID
<    * \param of the output file stream
<    */
<   void StatsDump (MinstrelHtWifiRemoteStation *station, uint8_t groupId, std::ofstream &of);
---
>   /// Print group statistics.
>   void StatsDump (MinstrelHtWifiRemoteStation *station, uint32_t index, std::ofstream &of);
463,467c348
<   /**
<    * Check for initializations.
<    *
<    * \param station the minstrel HT wifi remote station
<    */
---
>   /// Check for initializations.
470,475d350
<   /**
<    * Count retries.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \returns the count of retries
<    */
478,482d352
<   /**
<    * Update rate.
<    *
<    * \param station the minstrel HT wifi remote station
<    */
488c358
<    * The group order is fixed by BW -> SGI -> streams.
---
>    * The group order is fixed by BW -> SGI -> #streams.
491,493d360
<    *
<    * \param index the index
<    * \returns the rate ID
496,502c363,364
<   /**
<    * Return the rateId inside a group, from the global index.
<    *
<    * \param index the index
<    * \returns the rate ID
<    */
<   uint8_t GetRateId (uint16_t index);
---
>   /// Return the rateId inside a group, from the global index.
>   uint32_t GetRateId (uint32_t index);
504,510c366,367
<   /**
<    * Return the groupId from the global index.
<    *
<    * \param index the index
<    * \returns the group ID
<    */
<   uint8_t GetGroupId (uint16_t index);
---
>   /// Return the groupId from the global index.
>   uint32_t GetGroupId (uint32_t index);
512,519c369,370
<   /**
<    * Returns the global index corresponding to the groupId and rateId.
<    *
<    * \param groupId the group ID
<    * \param rateId the rate ID
<    * \returns the index
<    */
<   uint16_t GetIndex (uint8_t groupId, uint8_t rateId);
---
>   /// Returns the global index corresponding to the groupId and rateId.
>   uint32_t GetIndex (uint32_t groupId, uint32_t rateId);
521,529c372,373
<   /**
<    * Returns the groupId of a HT MCS with the given number of streams, if using SGI and the channel width used.
<    *
<    * \param txstreams the number of streams
<    * \param sgi short guard interval enabled (0 or 1)
<    * \param chWidth the channel width (MHz)
<    * \returns the HT group ID
<    */
<   uint8_t GetHtGroupId (uint8_t txstreams, uint8_t sgi, uint16_t chWidth);
---
>   /// Returns the groupId of a HT MCS with the given number of streams, if using sgi and the channel width used.
>   uint32_t GetHtGroupId (uint8_t txstreams, uint8_t sgi, uint32_t chWidth);
531,539c375,376
<   /**
<    * Returns the groupId of a VHT MCS with the given number of streams, if using SGI and the channel width used.
<    *
<    * \param txstreams the number of streams
<    * \param sgi short guard interval enabled (0 or 1)
<    * \param chWidth the channel width (MHz)
<    * \returns the VHT group ID
<    */
<   uint8_t GetVhtGroupId (uint8_t txstreams, uint8_t sgi, uint16_t chWidth);
---
>   /// Returns the groupId of a VHT MCS with the given number of streams, if using sgi and the channel width used.
>   uint32_t GetVhtGroupId (uint8_t txstreams, uint8_t sgi, uint32_t chWidth);
541,547c378,379
<   /**
<    * Returns the lowest global index of the rates supported by the station.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \returns the lowest global index
<    */
<   uint16_t GetLowestIndex (MinstrelHtWifiRemoteStation *station);
---
>   /// Returns the lowest global index of the rates supported by the station.
>   uint32_t GetLowestIndex (MinstrelHtWifiRemoteStation *station);
549,556c381,382
<   /**
<    * Returns the lowest global index of the rates supported by in the group.
<    *
<    * \param station the minstrel HT wifi remote station
<    * \param groupId the group ID
<    * \returns the lowest global index
<    */
<   uint16_t GetLowestIndex (MinstrelHtWifiRemoteStation *station, uint8_t groupId);
---
>   /// Returns the lowest global index of the rates supported by in the group.
>   uint32_t GetLowestIndex (MinstrelHtWifiRemoteStation *station, uint32_t groupId);
558,561c384
<   /**
<    * Returns a list of only the VHT MCS supported by the device.
<    * \returns the list of the VHT MCS supported
<    */
---
>   /// Returns a list of only the VHT MCS supported by the device.
564,567c387
<   /**
<    * Returns a list of only the HT MCS supported by the device.
<    * \returns the list of the HT MCS supported
<    */
---
>   /// Returns a list of only the HT MCS supported by the device.
570,578c390,404
<   Time m_updateStats;        //!< How frequent do we calculate the stats (1/10 seconds).
<   uint8_t m_lookAroundRate;  //!< The % to try other rates than our current rate.
<   uint8_t m_ewmaLevel;       //!< Exponential weighted moving average level (or coefficient).
<   uint8_t m_nSampleCol;      //!< Number of sample columns.
<   uint32_t m_frameLength;    //!< Frame length used for calculate modes TxTime in bytes.
<   uint8_t m_numGroups;       //!< Number of groups Minstrel should consider.
<   uint8_t m_numRates;        //!< Number of rates per group Minstrel should consider.
<   bool m_useVhtOnly;         //!< If only VHT MCS should be used, instead of HT and VHT.
<   bool m_printStats;         //!< If statistics table should be printed.
---
>   Time m_updateStats;         //!< How frequent do we calculate the stats (1/10 seconds).
>   double m_lookAroundRate;    //!< The % to try other rates than our current rate.
>   double m_ewmaLevel;         //!< Exponential weighted moving average level (or coefficient).
> 
>   uint32_t m_nSampleCol;      //!< Number of sample columns.
>   uint32_t m_frameLength;     //!< Frame length used for calculate modes TxTime.
> 
> 
>   uint8_t m_numGroups;         //!< Number of groups Minstrel should consider.
>   uint8_t m_numRates;          //!< Number of rates per group Minstrel should consider.
> 
>   bool m_useVhtOnly;           //!< If only VHT MCS should be used, instead of HT and VHT.
> 
>   bool m_printStats;           //!< If statistics table should be printed.
> 
583a410
> 
586c413,416
<   TracedValue<uint64_t> m_currentRate; //!< Trace rate changes
---
>   /**
>    * The trace source fired when the transmission rate change.
>    */
>   TracedCallback<uint64_t, Mac48Address> m_rateChange;
diff ../../NS3-WiGig/src/wifi/model/minstrel-wifi-manager.cc ../../ns-3-dev/src/wifi/model/minstrel-wifi-manager.cc
18,19c18,19
<  * Authors: Duy Nguyen <duy@soe.ucsc.edu>
<  *          Matías Richart <mrichart@fing.edu.uy>
---
>  * Author: Duy Nguyen <duy@soe.ucsc.edu>
>  *         Matías Richart <mrichart@fing.edu.uy>
32,36d31
< #include <iomanip>
< #include "ns3/packet.h"
< #include "ns3/random-variable-stream.h"
< #include "ns3/simulator.h"
< #include "ns3/log.h"
38d32
< #include "wifi-mac.h"
39a34,42
> #include "ns3/simulator.h"
> #include "ns3/log.h"
> #include "ns3/uinteger.h"
> #include "ns3/double.h"
> #include "ns3/boolean.h"
> #include "ns3/wifi-mac.h"
> #include "ns3/assert.h"
> #include <vector>
> #include <iomanip>
62,65c65,68
<                    "The percentage to try other rates",
<                    UintegerValue (10),
<                    MakeUintegerAccessor (&MinstrelWifiManager::m_lookAroundRate),
<                    MakeUintegerChecker<uint8_t> ())
---
>                    "the percentage to try other rates",
>                    DoubleValue (10),
>                    MakeDoubleAccessor (&MinstrelWifiManager::m_lookAroundRate),
>                    MakeDoubleChecker<double> ())
68,70c71,73
<                    UintegerValue (75),
<                    MakeUintegerAccessor (&MinstrelWifiManager::m_ewmaLevel),
<                    MakeUintegerChecker<uint8_t> ())
---
>                    DoubleValue (75),
>                    MakeDoubleAccessor (&MinstrelWifiManager::m_ewmaLevel),
>                    MakeDoubleChecker<double> ())
75c78
<                    MakeUintegerChecker <uint8_t> ())
---
>                    MakeUintegerChecker <uint32_t> ())
86,94d88
<     .AddAttribute ("PrintSamples",
<                    "Print samples table",
<                    BooleanValue (false),
<                    MakeBooleanAccessor (&MinstrelWifiManager::m_printSamples),
<                    MakeBooleanChecker ())
<     .AddTraceSource ("Rate",
<                      "Traced value for rate changes (b/s)",
<                      MakeTraceSourceAccessor (&MinstrelWifiManager::m_currentRate),
<                      "ns3::TracedValueCallback::Uint64")
100,101d93
<   : WifiRemoteStationManager (),
<     m_currentRate (0)
113c105
< MinstrelWifiManager::SetupPhy (const Ptr<WifiPhy> phy)
---
> MinstrelWifiManager::SetupPhy (Ptr<WifiPhy> phy)
116,117c108,109
<   uint8_t nModes = phy->GetNModes ();
<   for (uint8_t i = 0; i < nModes; i++)
---
>   uint32_t nModes = phy->GetNModes ();
>   for (uint32_t i = 0; i < nModes; i++)
122,123c114
<       txVector.SetPreambleType (WIFI_PREAMBLE_LONG);
<       AddCalcTxTime (mode, phy->CalculateTxDuration (m_pktLen, txVector, phy->GetFrequency ()));
---
>       AddCalcTxTime (mode, phy->CalculateTxDuration (m_pktLen, txVector, WIFI_PREAMBLE_LONG, phy->GetFrequency ()));
129c120
< MinstrelWifiManager::SetupMac (const Ptr<WifiMac> mac)
---
> MinstrelWifiManager::SetupMac (Ptr<WifiMac> mac)
135,152d125
< void
< MinstrelWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
165,167c138,146
<   auto it = m_calcTxTime.find (mode);
<   NS_ASSERT (it != m_calcTxTime.end ());
<   return it->second;
---
>   for (TxTime::const_iterator i = m_calcTxTime.begin (); i != m_calcTxTime.end (); i++)
>     {
>       if (mode == i->second)
>         {
>           return i->first;
>         }
>     }
>   NS_ASSERT (false);
>   return Seconds (0);
174c153
<   m_calcTxTime.insert (std::make_pair (mode, t));
---
>   m_calcTxTime.push_back (std::make_pair (t, mode));
215c194
<       station->m_sampleTable = SampleRate (station->m_nModes, std::vector<uint8_t> (m_sampleCol));
---
>       station->m_sampleTable = SampleRate (station->m_nModes, std::vector<uint32_t> (m_sampleCol));
218a198,200
>       std::ostringstream tmp;
>       tmp << "minstrel-stats-" << station->m_state->m_address << ".txt";
>       station->m_statsFile.open (tmp.str ().c_str (), std::ios::out);
232c214
<  *  4  | Lowest base rate | Lowest base rate  | Lowest base rate
---
>  *  4  | Lowest Baserate  | Lowest baserate   | Lowest baserate
369c351
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   uint32_t channelWidth = GetChannelWidth (station);
371a354
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
376a360,362
> 
>       //start the rate at half way
>       station->m_txrate = station->m_nModes / 2;
378,384c364
<   WifiMode mode = GetSupported (station, station->m_txrate);
<   if (m_currentRate != mode.GetDataRate (channelWidth) && !station->m_isSampling)
<     {
<       NS_LOG_DEBUG ("New datarate: " << mode.GetDataRate (channelWidth));
<       m_currentRate = mode.GetDataRate (channelWidth);
<     }
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, station->m_txrate), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
392c372
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   uint32_t channelWidth = GetChannelWidth (station);
394a375
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
398d378
<   WifiMode mode;
401c381
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
405c385
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
407d386
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
430c409
< uint16_t
---
> uint32_t
440,441c419,420
<   uint16_t idx = 0;
<   NS_LOG_DEBUG ("Total: " << station->m_totalPacketsCount << "  Sample: " << station->m_samplePacketsCount << "  Deferred: " << station->m_numSamplesDeferred);
---
> 
>   uint32_t idx;
451c430
<       uint8_t ratesSupported = station->m_nModes;
---
>       int ratesSupported = station->m_nModes;
470,471d448
<       NS_LOG_DEBUG ("Sample rate = " << idx << "(" << GetSupported (station, idx) << ")");
< 
482c459
<        * Decide if direct ( 1st MRR stage) or indirect (2nd MRR stage)
---
>        * Decide if direct ( 1st mrr stage) or indirect (2nd mrr stage)
501c478
<               idx = station->m_maxTpRate;
---
>               idx =  station->m_maxTpRate;
519c496
<           idx = station->m_maxTpRate;
---
>           idx =  station->m_maxTpRate;
556c533
<   for (uint8_t i = 0; i < station->m_nModes; i++)
---
>   for (uint32_t i = 0; i < station->m_nModes; i++)
559c536
<       //calculate the perfect TX time for this rate
---
>       //calculate the perfect tx time for this rate
568c545
<       NS_LOG_DEBUG (+i << " " << GetSupported (station, i) <<
---
>       NS_LOG_DEBUG (i << " " << GetSupported (station, i) <<
582c559
<           //bookkeeping
---
>           //bookeeping
591,592c568,569
<               //EWMA probability (cast for gcc 3.4 compatibility)
<               tempProb = ((tempProb * (100 - m_ewmaLevel)) + (station->m_minstrelTable[i].ewmaProb * m_ewmaLevel) ) / 100;
---
>               //ewma probability (cast for gcc 3.4 compatibility)
>               tempProb = static_cast<uint32_t> (((tempProb * (100 - m_ewmaLevel)) + (station->m_minstrelTable[i].ewmaProb * m_ewmaLevel) ) / 100);
598c575,576
<           station->m_minstrelTable[i].throughput = tempProb * static_cast<uint32_t> ((1000000 / txTime.GetMicroSeconds ()));
---
>           station->m_minstrelTable[i].throughput = tempProb * (1000000 / txTime.GetMicroSeconds ());
> 
605c583
<       //bookkeeping
---
>       //bookeeping
643c621
<   NS_LOG_DEBUG ("Attempt/success reset to 0");
---
>   NS_LOG_DEBUG ("Attempt/success resetted to 0");
645,646c623
<   uint32_t max_tp = 0;
<   uint8_t index_max_tp = 0, index_max_tp2 = 0;
---
>   uint32_t max_tp = 0, index_max_tp = 0, index_max_tp2 = 0;
648c625
<   //go find max throughput, second maximum throughput, high probability of success
---
>   //go find max throughput, second maximum throughput, high probability succ
651c628
<   for (uint8_t i = 0; i < station->m_nModes; i++)
---
>   for (uint32_t i = 0; i < station->m_nModes; i++)
653c630
<       NS_LOG_DEBUG (+i << " " << GetSupported (station, i) <<
---
>       NS_LOG_DEBUG (i << " " << GetSupported (station, i) <<
666c643
<   for (uint8_t i = 0; i < station->m_nModes; i++)
---
>   for (uint32_t i = 0; i < station->m_nModes; i++)
675,677c652,653
<   uint32_t max_prob = 0;
<   uint8_t index_max_prob = 0;
<   for (uint8_t i = 0; i < station->m_nModes; i++)
---
>   uint32_t max_prob = 0, index_max_prob = 0;
>   for (uint32_t i = 0; i < station->m_nModes; i++)
700,702c676,678
<   NS_LOG_DEBUG ("max throughput=" << +index_max_tp << "(" << GetSupported (station, index_max_tp) <<
<                 ")\tsecond max throughput=" << +index_max_tp2 << "(" << GetSupported (station, index_max_tp2) <<
<                 ")\tmax prob=" << +index_max_prob << "(" << GetSupported (station, index_max_prob) << ")");
---
>   NS_LOG_DEBUG ("max throughput=" << index_max_tp << "(" << GetSupported (station, index_max_tp) <<
>                 ")\tsecond max throughput=" << index_max_tp2 << "(" << GetSupported (station, index_max_tp2) <<
>                 ")\tmax prob=" << index_max_prob << "(" << GetSupported (station, index_max_prob) << ")");
707,710d682
<   if (m_printSamples)
<     {
<       PrintSampleTable (station);
<     }
714c686,687
< MinstrelWifiManager::DoReportRxOk (WifiRemoteStation *st, double rxSnr, WifiMode txMode)
---
> MinstrelWifiManager::DoReportRxOk (WifiRemoteStation *st,
>                                    double rxSnr, WifiMode txMode)
717d689
<   NS_LOG_DEBUG ("DoReportRxOk m_txrate=" << static_cast<MinstrelWifiRemoteStation*> (st)->m_txrate);
724c696
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *)st;
725a698
> 
732c705,706
<   NS_LOG_FUNCTION (this << st << ctsSnr << ctsMode << rtsSnr);
---
>   NS_LOG_FUNCTION (this << st);
>   NS_LOG_DEBUG ("self=" << st << " rts ok");
739c713
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *)st;
747,748c721
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
<   NS_LOG_DEBUG ("DoReportDataFailed " << station << "\t rate " << station->m_txrate << "\tlongRetry \t" << station->m_longRetry);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *)st;
759,760c732,733
< MinstrelWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                      double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> MinstrelWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                      double ackSnr, WifiMode ackMode, double dataSnr)
762,763c735,736
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (st << ackSnr << ackMode << dataSnr);
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *) st;
787d759
<   NS_LOG_DEBUG ("Next rate to use TxRate = " << station->m_txrate);
794c766
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *) st;
815d786
<   NS_LOG_DEBUG ("Next rate to use TxRate = " << station->m_txrate);
858c829
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *) st;
866c837
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *) st;
871c842
< MinstrelWifiManager::DoNeedRetransmission (WifiRemoteStation *st, Ptr<const Packet> packet, bool normally)
---
> MinstrelWifiManager::DoNeedDataRetransmission (WifiRemoteStation *st, Ptr<const Packet> packet, bool normally)
874c845
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *)st;
881c852
<   if (station->m_longRetry >= CountRetries (station))
---
>   if (station->m_longRetry > CountRetries (station))
883d853
<       NS_LOG_DEBUG ("No re-transmission allowed. Retries: " <<  station->m_longRetry << " Max retries: " << CountRetries (station));
888d857
<       NS_LOG_DEBUG ("Re-transmit. Retries: " <<  station->m_longRetry << " Max retries: " << CountRetries (station));
893c862,869
< uint16_t
---
> bool
> MinstrelWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
> }
> 
> uint32_t
897c873
<   uint16_t bitrate;
---
>   uint32_t bitrate;
901,903c877,878
<   //bookkeeping for m_index and m_col variables
<   NS_ABORT_MSG_IF (station->m_nModes < 2, "Integer overflow detected");
<   if (station->m_index > station->m_nModes - 2)
---
>   //bookeeping for m_index and m_col variables
>   if (station->m_index > (station->m_nModes - 2))
918,919c893,895
<   NS_LOG_FUNCTION (this << station);
<   for (uint8_t i = 0; i < station->m_nModes; i++)
---
>   NS_LOG_FUNCTION (station);
> 
>   for (uint32_t i = 0; i < station->m_nModes; i++)
921c897
<       NS_LOG_DEBUG ("Initializing rate index " << +i << " " << GetSupported (station, i));
---
>       NS_LOG_DEBUG ("Initializing rate index " << i << " " << GetSupported (station, i));
938c914
<       //at least one retry is permitted.
---
>       //at least one retry is permitter.
964c940
<   //First transmission (Data + Ack timeout)
---
>   //First transmission (DATA + ACK timeout)
971c947
<       //Add one re-transmission (Data + Ack timeout)
---
>       //Add one re-transmission (DATA + ACK timeout)
975c951
<       tt += (cw / 2.0) * GetMac ()->GetSlot ();
---
>       tt += NanoSeconds ((cw / 2) * GetMac ()->GetSlot ());
987c963,964
<   NS_LOG_FUNCTION (this << station);
---
>   NS_LOG_DEBUG ("InitSampleTable=" << this);
> 
991c968
<   uint8_t numSampleRates = station->m_nModes;
---
>   uint32_t numSampleRates = station->m_nModes;
993,994c970,971
<   uint16_t newIndex;
<   for (uint8_t col = 0; col < m_sampleCol; col++)
---
>   uint32_t newIndex;
>   for (uint32_t col = 0; col < m_sampleCol; col++)
996c973
<       for (uint8_t i = 0; i < numSampleRates; i++ )
---
>       for (uint32_t i = 0; i < numSampleRates; i++ )
1003d979
<           NS_LOG_DEBUG ("InitSampleTable uv: " << uv);
1019c995,997
<   uint8_t numSampleRates = station->m_nModes;
---
>   NS_LOG_DEBUG ("PrintSampleTable=" << station);
> 
>   uint32_t numSampleRates = station->m_nModes;
1021c999
<   for (uint8_t i = 0; i < numSampleRates; i++)
---
>   for (uint32_t i = 0; i < numSampleRates; i++)
1023c1001
<       for (uint8_t j = 0; j < m_sampleCol; j++)
---
>       for (uint32_t j = 0; j < m_sampleCol; j++)
1035,1040c1013,1014
<   if (!station->m_statsFile.is_open ())
<     {
<       std::ostringstream tmp;
<       tmp << "minstrel-stats-" << station->m_state->m_address << ".txt";
<       station->m_statsFile.open (tmp.str ().c_str (), std::ios::out);
<     }
---
>   NS_LOG_FUNCTION (this << station);
>   NS_LOG_DEBUG ("PrintTable=" << station);
1045,1047c1019,1021
<   uint16_t maxTpRate = station->m_maxTpRate;
<   uint16_t maxTpRate2 = station->m_maxTpRate2;
<   uint16_t maxProbRate = station->m_maxProbRate;
---
>   uint32_t maxTpRate = station->m_maxTpRate;
>   uint32_t maxTpRate2 = station->m_maxTpRate2;
>   uint32_t maxProbRate = station->m_maxProbRate;
1049c1023
<   for (uint8_t i = 0; i < station->m_nModes; i++)
---
>   for (uint32_t i = 0; i < station->m_nModes; i++)
1078c1052
<       float tmpTh = rate.throughput / 100000.0f;
---
>       float tmpTh = rate.throughput / 100000.0;
1097a1072,1092
> }
> 
> 
> void
> MinstrelWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> MinstrelWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/minstrel-wifi-manager.h ../../ns-3-dev/src/wifi/model/minstrel-wifi-manager.h
18,19c18,19
<  * Authors: Duy Nguyen <duy@soe.ucsc.edu>
<  *          Matías Richart <mrichart@fing.edu.uy>
---
>  * Author: Duy Nguyen <duy@soe.ucsc.edu>
>  *         Matías Richart <mrichart@fing.edu.uy>
25d24
< #include "ns3/traced-value.h"
26a26,28
> #include "wifi-mode.h"
> #include "ns3/nstime.h"
> #include "ns3/random-variable-stream.h"
28d29
< #include <map>
32,33d32
< class UniformRandomVariable;
< 
48,49c47,48
<   uint32_t numRateSuccess;      ///< number of successful packets
<   uint32_t prob;                ///< (# packets success)/(# total packets)
---
>   uint32_t numRateSuccess;      ///< number of successful pkts
>   uint32_t prob;                ///< (# pkts success )/(# total pkts)
55c54
<   uint32_t throughput;  ///< throughput of a rate in bps
---
>   uint32_t throughput;  ///< throughput of a rate
62,63c61,62
<   uint8_t numSamplesSkipped; //!< number of samples skipped
<   int sampleLimit; //!< sample limit
---
>   uint8_t numSamplesSkipped;
>   int sampleLimit;
70c69
< typedef std::vector<RateInfo> MinstrelRate;
---
> typedef std::vector<struct RateInfo> MinstrelRate;
73c72
<  * A vector of a vector uint8_t
---
>  * A vector of a vector uint32_t
75c74
< typedef std::vector<std::vector<uint8_t> > SampleRate;
---
> typedef std::vector<std::vector<uint32_t> > SampleRate;
90c89
<    * then we wrap back to the row 1 column 1.
---
>    * then we wrap back to the row 1 col 1.
93,101c92,99
<   uint8_t m_col;                 ///< column index
<   uint8_t m_index;               ///< vector index
<   uint16_t m_maxTpRate;          ///< the current throughput rate in bps
<   uint16_t m_maxTpRate2;         ///< second highest throughput rate in bps
<   uint16_t m_maxProbRate;        ///< rate with highest probability of success in bps
<   uint8_t m_nModes;              ///< number of modes supported
<   int m_totalPacketsCount;       ///< total number of packets as of now
<   int m_samplePacketsCount;      ///< how many packets we have sample so far
<   int m_numSamplesDeferred;      ///< number samples deferred
---
>   uint32_t m_col, m_index;
>   uint32_t m_maxTpRate;          ///< the current throughput rate
>   uint32_t m_maxTpRate2;         ///< second highest throughput rate
>   uint32_t m_maxProbRate;        ///< rate with highest prob of success
>   uint32_t m_nModes;             ///< number of modes supported
>   int m_totalPacketsCount;             ///< total number of packets as of now
>   int m_samplePacketsCount;             ///< how many packets we have sample so far
>   int m_numSamplesDeferred;
103,105c101,103
<   uint16_t m_sampleRate;         ///< current sample rate in bps
<   bool m_sampleDeferred;         ///< a flag to indicate sample rate is on the second stage
<   uint32_t m_shortRetry;         ///< short retries such as control packets
---
>   uint32_t m_sampleRate;         ///< current sample rate
>   bool  m_sampleDeferred;        ///< a flag to indicate sample rate is on the second stage
>   uint32_t m_shortRetry;         ///< short retries such as control packts
108c106
<   uint16_t m_txrate;             ///< current transmit rate in bps
---
>   uint32_t m_txrate;             ///< current transmit rate
112c110
<   std::ofstream m_statsFile;     ///< stats file
---
>   std::ofstream m_statsFile;
122c120
<  * based on statistics collected on the probability of successful
---
>  * based on statistics collected on the probability of successful 
127,128c125,126
<  * Minstrel is appropriate for non-HT configurations; for HT (i.e. 802.11n
<  * or higher), users should use MinstrelHtWifiManager instead.
---
>  * Minstrel is appropriate for non-HT/VHT configurations; for HT/VHT
>  * (i.e. 802.11n/ac), users should use MinstrelHtWifiManager instead.
130c128
<  * Wi-Fi MAC that supports 802.11n or higher.
---
>  * Wi-Fi MAC that has VhtSupported or HtSupported set.
134,136c132,134
<  * For each rate, a new parameter samplesSkipped is added. This parameter
<  * is intended to solve an issue regarding the sampling of low rates when
<  * a high rate is working well, which leads to outdated statistics.
---
>  * For each rate, a new parameter samplesSkipped is added. This parameter 
>  * is intended to solve an issue regarding the sampling of low rates when 
>  * a high rate is working well, which leads to outdated statistics. 
138c136
<  * but may help in dynamic scenarios to react faster and more accurately
---
>  * but may help in dynamic scenarios to react faster and more accurately 
140c138
<  *
---
>  * 
142,144c140,142
<  * rates is as follows.  When a sample rate is deferred to the second MRR
<  * chain stage, a new parameter (numSamplesDeferred) is increased. This
<  * parameters is used (jointly with sampleCount) to compare current
---
>  * rates is as follows.  When a sample rate is deffered to the second MRR 
>  * chain stage, a new parameter (numSamplesDeferred) is increased. This 
>  * paramters is used (jointly with sampleCount) to compare current 
146c144
<  *
---
>  * 
148,149c146,147
<  * This parameter limits the number of times a very low or very high
<  * probability rate is sampled, avoiding to try a poorly working sample
---
>  * This parameter limits the number of times a very low or very high 
>  * probability rate is sampled, avoiding to try a poorly working sample 
153,154c151,152
<  * not apply EWMA but instead assigns the entire probability.
<  * Since the EWMA probability is initialized to zero, this generates
---
>  * not apply EWMA but instead assigns the entire probability. 
>  * Since the EWMA probability is initialized to zero, this generates 
158a157
> 
160,163d158
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
169,170c164,167
<   void SetupPhy (const Ptr<WifiPhy> phy);
<   void SetupMac (const Ptr<WifiMac> mac);
---
>   virtual void SetupPhy (Ptr<WifiPhy> phy);
>   virtual void SetupMac (Ptr<WifiMac> mac);
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
183,187d179
<   /**
<    * Update the rate.
<    *
<    * \param station the station object
<    */
190,194c182
<   /**
<    * Update the Minstrel Table every 1/10 seconds.
<    *
<    * \param station the station object
<    */
---
>   //updating the Minstrel Table every 1/10 seconds
197,203c185,186
<   /**
<    * Find a rate to use from Minstrel Table.
<    *
<    * \param station the station object
<    * \returns the rate in bps
<    */
<   uint16_t FindRate (MinstrelWifiRemoteStation *station);
---
>   //find a rate to use from Minstrel Table
>   uint32_t FindRate (MinstrelWifiRemoteStation *station);
205,210d187
<   /**
<    * Get data transmit vector.
<    *
<    * \param station the station object
<    * \returns WifiTxVector
<    */
213,218d189
<   /**
<    * Get RTS transmit vector.
<    *
<    * \param station the station object
<    * \returns WifiTxVector
<    */
221,226d191
<   /**
<    * Get the number of retries.
<    *
<    * \param station the station object
<    * \returns the number of retries
<    */
229,233d193
<   /**
<    * Update packet counters.
<    *
<    * \param station the station object
<    */
236,240c196
<   /**
<    * Update the number of retries and reset accordingly.
<    *
<    * \param station the station object
<    */
---
>   //update the number of retries and reset accordingly
243,248c199
<   /**
<    * Check for initializations.
<    *
<    * \param station the station object
<    */
<   void CheckInit (MinstrelWifiRemoteStation *station);
---
>   void CheckInit (MinstrelWifiRemoteStation *station);  ///< check for initializations
250,254c201
<   /**
<    * Initialize Sample Table.
<    *
<    * \param station the station object
<    */
---
>   //initialize Sample Table
258,272c205,218
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
---
>   //overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
274,275c220
<   bool DoNeedRetransmission (WifiRemoteStation *st,
<                                  Ptr<const Packet> packet, bool normally);
---
>   virtual bool DoNeedDataRetransmission (WifiRemoteStation *st, Ptr<const Packet> packet, bool normally);
276a222
>   virtual bool IsLowLatency (void) const;
278,283c224
<   /**
<    * Estimate the TxTime of a packet with a given mode.
<    *
<    * \param mode Wi-Fi mode
<    * \returns the transmission time
<    */
---
>   //for estimating the TxTime of a packet with a given mode
293,297c234
<   /**
<    * Initialize Minstrel Table.
<    *
<    * \param station the station object
<    */
---
>   //initialize Minstrel Table
300,306c237,238
<   /**
<    * Get the next sample from Sample Table.
<    *
<    * \param station the station object
<    * \returns the next sample
<    */
<   uint16_t GetNextSample (MinstrelWifiRemoteStation *station);
---
>   //getting the next sample from Sample Table
>   uint32_t GetNextSample (MinstrelWifiRemoteStation *station);
320,321c252,253
<    *  - Ack timeouts
<    *  - Data transmission
---
>    *  - ACK timeouts
>    *  - DATA transmission
323,327d254
<    *
<    * \param dataTransmissionTime the data transmission time
<    * \param shortRetries short retries
<    * \param longRetries long retries
<    * \returns the unicast packet time
331,335c258
<   /**
<    * Print Sample Table.
<    *
<    * \param station the station object
<    */
---
>   //printing Sample Table
338,342c261
<   /**
<    * Print Minstrel Table.
<    *
<    * \param station the station object
<    */
---
>   //printing Minstrel Table
344a264
> 
347c267
<    * Essentially a map from WifiMode to its corresponding transmission time
---
>    * (Essentially a list for WifiMode and its corresponding transmission time
350c270
<   typedef std::map<WifiMode, Time> TxTime;
---
>   typedef std::vector<std::pair<Time,WifiMode> > TxTime;
354,356c274,276
<   uint8_t m_lookAroundRate; ///< the % to try other rates than our current rate
<   uint8_t m_ewmaLevel;      ///< exponential weighted moving average
<   uint8_t m_sampleCol;      ///< number of sample columns
---
>   double m_lookAroundRate;  ///< the % to try other rates than our current rate
>   double m_ewmaLevel;       ///< exponential weighted moving average
>   uint32_t m_sampleCol;     ///< number of sample columns
358,359c278
<   bool m_printStats;        ///< whether statistics table should be printed.
<   bool m_printSamples;      ///< whether samples table should be printed.
---
>   bool m_printStats;        ///< If statistics table should be printed.
361c280
<   /// Provides uniform random variables.
---
>   //Provides uniform random variables.
363,364d281
< 
<   TracedValue<uint64_t> m_currentRate; //!< Trace rate changes
diff ../../NS3-WiGig/src/wifi/model/mpdu-aggregator.cc ../../ns-3-dev/src/wifi/model/mpdu-aggregator.cc
19d18
<  *         Stefano Avallone <stavallo@unina.it>
23d21
< #include "ns3/packet.h"
25,39c23
< #include "ampdu-subframe-header.h"
< #include "wifi-phy.h"
< #include "wifi-tx-vector.h"
< #include "wifi-remote-station-manager.h"
< #include "mac-low.h"
< #include "wifi-mac-queue-item.h"
< #include "wifi-mac-queue.h"
< #include "msdu-aggregator.h"
< #include "wifi-net-device.h"
< #include "ht-capabilities.h"
< #include "vht-capabilities.h"
< #include "he-capabilities.h"
< #include "wifi-mac.h"
< #include "ctrl-headers.h"
< #include "wifi-mac-trailer.h"
---
> #include "wifi-mac-header.h"
53c37
<     .AddConstructor<MpduAggregator> ()
---
>     //No AddConstructor because this is an abstract class.
58c42,43
< MpduAggregator::MpduAggregator ()
---
> MpduAggregator::DeaggregatedMpdus
> MpduAggregator::Deaggregate (Ptr<Packet> aggregatedPacket)
60,102c45,46
< }
< 
< MpduAggregator::~MpduAggregator ()
< {
< }
< 
< void
< MpduAggregator::SetEdcaQueues (EdcaQueues edcaQueues)
< {
<     m_edca = edcaQueues;
< }
< 
< void
< MpduAggregator::Aggregate (Ptr<const WifiMacQueueItem> mpdu, Ptr<Packet> ampdu, bool isSingle)
< {
<   NS_LOG_FUNCTION (mpdu << ampdu << isSingle);
<   NS_ASSERT (ampdu);
<   // if isSingle is true, then ampdu must be empty
<   NS_ASSERT (!isSingle || ampdu->GetSize () == 0);
< 
<   // pad the previous A-MPDU subframe if the A-MPDU is not empty
<   if (ampdu->GetSize () > 0)
<     {
<       uint8_t padding = CalculatePadding (ampdu->GetSize ());
< 
<       if (padding)
<         {
<           Ptr<Packet> pad = Create<Packet> (padding);
<           ampdu->AddAtEnd (pad);
<         }
<     }
< 
<   // add MPDU header and trailer
<   Ptr<Packet> tmp = mpdu->GetPacket ()->Copy ();
<   tmp->AddHeader (mpdu->GetHeader ());
<   AddWifiMacTrailer (tmp);
< 
<   // add A-MPDU subframe header and MPDU to the A-MPDU
<   AmpduSubframeHeader hdr = GetAmpduSubframeHeader (static_cast<uint16_t> (tmp->GetSize ()), isSingle);
< 
<   tmp->AddHeader (hdr);
<   ampdu->AddAtEnd (tmp);
< }
---
>   NS_LOG_FUNCTION_NOARGS ();
>   DeaggregatedMpdus set;
104,216d47
< uint32_t
< MpduAggregator::GetSizeIfAggregated (uint32_t mpduSize, uint32_t ampduSize)
< {
<   NS_LOG_FUNCTION (mpduSize << ampduSize);
< 
<   return ampduSize + CalculatePadding (ampduSize) + 4 + mpduSize;
< }
< 
< uint32_t
< MpduAggregator::GetMaxAmpduSize (Mac48Address recipient, uint8_t tid,
<                                  WifiModulationClass modulation) const
< {
<   NS_LOG_FUNCTION (this << recipient << +tid << modulation);
< 
<   AcIndex ac = QosUtilsMapTidToAc (tid);
<   Ptr<QosTxop> qosTxop = m_edca.find (ac)->second;
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (qosTxop->GetLow ()->GetPhy ()->GetDevice ());
<   NS_ASSERT (device);
<   Ptr<WifiRemoteStationManager> stationManager = device->GetRemoteStationManager ();
<   NS_ASSERT (stationManager);
< 
<   // Find the A-MPDU max size configured on this device
<   UintegerValue size;
< 
<   switch (ac)
<     {
<       case AC_BE:
<         device->GetMac ()->GetAttribute ("BE_MaxAmpduSize", size);
<         break;
<       case AC_BK:
<         device->GetMac ()->GetAttribute ("BK_MaxAmpduSize", size);
<         break;
<       case AC_VI:
<         device->GetMac ()->GetAttribute ("VI_MaxAmpduSize", size);
<         break;
<       case AC_VO:
<         device->GetMac ()->GetAttribute ("VO_MaxAmpduSize", size);
<         break;
<       default:
<         NS_ABORT_MSG ("Unknown AC " << ac);
<         return 0;
<     }
< 
<   uint32_t maxAmpduSize = size.Get ();
< 
<   if (maxAmpduSize == 0)
<     {
<       NS_LOG_DEBUG ("A-MPDU Aggregation is disabled on this station for AC " << ac);
<       return 0;
<     }
< 
<   // Retrieve the Capabilities elements advertised by the recipient
<   //// WIGIG ////
<   Ptr<const EdmgCapabilities> edmgCapabilities = stationManager->GetStationEdmgCapabilities (recipient);
<   Ptr<const DmgCapabilities> dmgCapabilities = stationManager->GetStationDmgCapabilities (recipient);
<   //// WIGIG ////
<   Ptr<const HeCapabilities> heCapabilities = stationManager->GetStationHeCapabilities (recipient);
<   Ptr<const VhtCapabilities> vhtCapabilities = stationManager->GetStationVhtCapabilities (recipient);
<   Ptr<const HtCapabilities> htCapabilities = stationManager->GetStationHtCapabilities (recipient);
< 
<   // Determine the constraint imposed by the recipient based on the PPDU
<   // format used to transmit the A-MPDU
<   //// WIGIG ////
<   if ((modulation == WIFI_MOD_CLASS_EDMG_SC) || (modulation == WIFI_MOD_CLASS_EDMG_OFDM))
<     {
<       NS_ABORT_MSG_IF (!edmgCapabilities, "EDMG Capabilities element not received");
< 
<       maxAmpduSize = std::min (maxAmpduSize, edmgCapabilities->GetMaxAmpduLength ());
<     }
<   else if ((modulation == WIFI_MOD_CLASS_DMG_SC) || (modulation == WIFI_MOD_CLASS_DMG_OFDM))
<     {
<       NS_ABORT_MSG_IF (!dmgCapabilities, "DMG Capabilities element not received");
< 
<       maxAmpduSize = std::min (maxAmpduSize, dmgCapabilities->GetMaxAmpduLength ());
<     }
<   //// WIGIG ////
<   else if (modulation == WIFI_MOD_CLASS_HE)
<     {
<       NS_ABORT_MSG_IF (!heCapabilities, "HE Capabilities element not received");
< 
<       maxAmpduSize = std::min (maxAmpduSize, heCapabilities->GetMaxAmpduLength ());
<     }
<   else if (modulation == WIFI_MOD_CLASS_VHT)
<     {
<       NS_ABORT_MSG_IF (!vhtCapabilities, "VHT Capabilities element not received");
< 
<       maxAmpduSize = std::min (maxAmpduSize, vhtCapabilities->GetMaxAmpduLength ());
<     }
<   else if (modulation == WIFI_MOD_CLASS_HT)
<     {
<       NS_ABORT_MSG_IF (!htCapabilities, "HT Capabilities element not received");
< 
<       maxAmpduSize = std::min (maxAmpduSize, htCapabilities->GetMaxAmpduLength ());
<     }
<   else  // non-HT PPDU
<     {
<       NS_LOG_DEBUG ("A-MPDU aggregation is not available for non-HT PHYs");
< 
<       maxAmpduSize = 0;
<     }
< 
<   return maxAmpduSize;
< }
< 
< uint8_t
< MpduAggregator::CalculatePadding (uint32_t ampduSize)
< {
<   return (4 - (ampduSize % 4 )) % 4;
< }
< 
< AmpduSubframeHeader
< MpduAggregator::GetAmpduSubframeHeader (uint16_t mpduSize, bool isSingle)
< {
218,238c49,61
<   hdr.SetLength (mpduSize);
<   if (isSingle)
<     {
<       hdr.SetEof (1);
<     }
<   return hdr;
< }
< 
< std::vector<Ptr<WifiMacQueueItem>>
< MpduAggregator::GetNextAmpdu (Ptr<const WifiMacQueueItem> mpdu, WifiTxVector txVector,
<                               Time ppduDurationLimit) const
< {
<   NS_LOG_FUNCTION (this << *mpdu << ppduDurationLimit);
<   std::vector<Ptr<WifiMacQueueItem>> mpduList;
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
< 
<   NS_ASSERT (mpdu->GetHeader ().IsQosData () && !recipient.IsBroadcast ());
< 
<   uint8_t tid = GetTid (mpdu->GetPacket (), mpdu->GetHeader ());
<   auto edcaIt = m_edca.find (QosUtilsMapTidToAc (tid));
<   NS_ASSERT (edcaIt != m_edca.end ());
---
>   Ptr<Packet> extractedMpdu = Create<Packet> ();
>   uint32_t maxSize = aggregatedPacket->GetSize ();
>   uint16_t extractedLength;
>   uint32_t padding;
>   uint32_t deserialized = 0;
> 
>   while (deserialized < maxSize)
>     {
>       deserialized += aggregatedPacket->RemoveHeader (hdr);
>       extractedLength = hdr.GetLength ();
>       extractedMpdu = aggregatedPacket->CreateFragment (0, static_cast<uint32_t> (extractedLength));
>       aggregatedPacket->RemoveAtStart (extractedLength);
>       deserialized += extractedLength;
240,241c63
<   WifiModulationClass modulation = txVector.GetMode ().GetModulationClass ();
<   uint32_t maxAmpduSize = GetMaxAmpduSize (recipient, tid, modulation);
---
>       padding = (4 - (extractedLength % 4 )) % 4;
243,259c65
<   if (maxAmpduSize == 0)
<     {
<       NS_LOG_DEBUG ("A-MPDU aggregation disabled");
<       return mpduList;
<     }
< 
<   //Have to make sure that the block ack agreement is established before sending an A-MPDU
<   if (edcaIt->second->GetBaAgreementEstablished (recipient, tid))
<     {
<       /* here is performed MPDU aggregation */
<       uint16_t startingSequenceNumber = edcaIt->second->GetBaStartingSequence (recipient, tid);
<       Ptr<WifiMacQueueItem> nextMpdu;
<       uint16_t maxMpdus = edcaIt->second->GetBaBufferSize (recipient, tid);
<       uint32_t currentAmpduSize = 0;
< 
<       // check if the received MPDU meets the size and duration constraints
<       if (edcaIt->second->GetLow ()->IsWithinSizeAndTimeLimits (mpdu, txVector, 0, ppduDurationLimit))
---
>       if (padding > 0 && deserialized < maxSize)
261,262c67,68
<           // MPDU can be aggregated
<           nextMpdu = Copy (mpdu);
---
>           aggregatedPacket->RemoveAtStart (padding);
>           deserialized += padding;
265,312c71,72
<       while (nextMpdu != 0)
<         {
<           /* if we are here, nextMpdu can be aggregated to the A-MPDU.
<            * nextMpdu may be any of the following:
<            * (a) an A-MSDU (with all the constituent MSDUs dequeued from
<            *     the EDCA queue)
<            * (b) an MSDU dequeued from the EDCA queue
<            * (c) a retransmitted MSDU or A-MSDU dequeued from the BA Manager queue
<            * (d) an MPDU that was aggregated in an A-MPDU which was not
<            *     transmitted (e.g., because the RTS/CTS exchange failed)
<            */
< 
<           currentAmpduSize = GetSizeIfAggregated (nextMpdu->GetSize (), currentAmpduSize);
< 
<           NS_LOG_DEBUG ("Adding packet with sequence number " << nextMpdu->GetHeader ().GetSequenceNumber ()
<                         << " to A-MPDU, packet size = " << nextMpdu->GetSize ()
<                         << ", A-MPDU size = " << currentAmpduSize);
< 
<           // Always use the Normal Ack policy (Implicit Block Ack), for now
<           nextMpdu->GetHeader ().SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
< 
<           mpduList.push_back (nextMpdu);
< 
<           // If allowed by the BA agreement, get the next MPDU
<           nextMpdu = 0;
< 
<           Ptr<const WifiMacQueueItem> peekedMpdu;
<           peekedMpdu = edcaIt->second->PeekNextFrame (tid, recipient);
<           if (peekedMpdu != 0)
<             {
<               uint16_t currentSequenceNumber = peekedMpdu->GetHeader ().GetSequenceNumber ();
< 
<               if (IsInWindow (currentSequenceNumber, startingSequenceNumber, maxMpdus))
<                 {
<                   // dequeue the frame if constraints on size and duration limit are met.
<                   // Note that the dequeued MPDU differs from the peeked MPDU if A-MSDU
<                   // aggregation is performed during the dequeue
<                   NS_LOG_DEBUG ("Trying to aggregate another MPDU");
<                   nextMpdu = edcaIt->second->DequeuePeekedFrame (peekedMpdu, txVector, true,
<                                                                  currentAmpduSize, ppduDurationLimit);
<                 }
<             }
<         }
<       if (mpduList.size () == 1)
<         {
<           // return an empty vector if it was not possible to aggregate at least two MPDUs
<           mpduList.clear ();
<         }
---
>       std::pair<Ptr<Packet>, AmpduSubframeHeader> packetHdr (extractedMpdu, hdr);
>       set.push_back (packetHdr);
314c74,75
<   return mpduList;
---
>   NS_LOG_INFO ("Deaggreated A-MPDU: extracted " << set.size () << " MPDUs");
>   return set;
diff ../../NS3-WiGig/src/wifi/model/mpdu-aggregator.h ../../ns-3-dev/src/wifi/model/mpdu-aggregator.h
1,154c1,99
< /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
< /*
<  * Copyright (c) 2013
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License version 2 as
<  * published by the Free Software Foundation;
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
<  *
<  * Author: Ghada Badawy <gbadawy@gmail.com>
<  */
< 
< #ifndef MPDU_AGGREGATOR_H
< #define MPDU_AGGREGATOR_H
< 
< #include "ns3/object.h"
< #include "wifi-mode.h"
< #include "qos-txop.h"
< #include "ns3/nstime.h"
< #include <vector>
< 
< namespace ns3 {
< 
< class AmpduSubframeHeader;
< class WifiTxVector;
< class Packet;
< class WifiMacQueueItem;
< 
< /**
<  * \brief Aggregator used to construct A-MPDUs
<  * \ingroup wifi
<  */
< class MpduAggregator : public Object
< {
< public:
<   /**
<    * EDCA queues typedef
<    */
<   typedef std::map<AcIndex, Ptr<QosTxop> > EdcaQueues;
< 
< 
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
<   static TypeId GetTypeId (void);
< 
<   MpduAggregator ();
<   virtual ~MpduAggregator ();
< 
<   /**
<    * Aggregate an MPDU to an A-MPDU.
<    *
<    * \param mpdu the MPDU.
<    * \param ampdu the A-MPDU.
<    * \param isSingle whether it is a single MPDU.
<    */
<   static void Aggregate (Ptr<const WifiMacQueueItem> mpdu, Ptr<Packet> ampdu, bool isSingle);
< 
<   /**
<    * Compute the size of the A-MPDU resulting from the aggregation of an MPDU of
<    * size <i>mpduSize</i> and an A-MPDU of size <i>ampduSize</i>.
<    *
<    * \param mpduSize the MPDU size in bytes.
<    * \param ampduSize the A-MPDU size in bytes.
<    * \return the size of the resulting A-MPDU in bytes.
<    */
<   static uint32_t GetSizeIfAggregated (uint32_t mpduSize, uint32_t ampduSize);
< 
<   /**
<    * Determine the maximum size for an A-MPDU of the given TID that can be sent
<    * to the given receiver when using the given modulation class.
<    *
<    * \param recipient the receiver station address.
<    * \param tid the TID.
<    * \param modulation the modulation class.
<    * \return the maximum A-MPDU size in bytes.
<    */
<   uint32_t GetMaxAmpduSize (Mac48Address recipient, uint8_t tid,
<                             WifiModulationClass modulation) const;
< 
<   /**
<    * Attempt to aggregate other MPDUs to the given MPDU, while meeting the
<    * following constraints:
<    *
<    * - the size of the resulting A-MPDU does not exceed the maximum A-MPDU size
<    * as determined for the modulation class indicated by the given TxVector
<    *
<    * - the time to transmit the resulting PPDU, according to the given TxVector,
<    * does not exceed both the maximum PPDU duration allowed by the corresponding
<    * modulation class (if any) and the given PPDU duration limit (if distinct from
<    * Time::Min ())
<    *
<    * For now, only non-broadcast QoS Data frames can be aggregated (do not pass
<    * other types of frames to this method). MPDUs to aggregate are looked for
<    * among those with the same TID and receiver as the given MPDU.
<    *
<    * The resulting A-MPDU is returned as a vector of the constituent MPDUs
<    * (including the given MPDU), which are not actually aggregated (call the
<    * Aggregate method afterwards to get the actual A-MPDU). If aggregation was
<    * not possible (aggregation is disabled, there is no Block Ack agreement
<    * established with the receiver, or another MPDU to aggregate was not found),
<    * the returned vector is empty.
<    *
<    * \param mpdu the given MPDU.
<    * \param txVector the TxVector used to transmit the frame
<    * \param ppduDurationLimit the limit on the PPDU duration
<    * \return the resulting A-MPDU, if aggregation is possible.
<    */
<   std::vector<Ptr<WifiMacQueueItem>> GetNextAmpdu (Ptr<const WifiMacQueueItem> mpdu,
<                                                    WifiTxVector txVector,
<                                                    Time ppduDurationLimit = Time::Min ()) const;
< 
<   /**
<    * Set the map of EDCA queues.
<    *
<    * \param edcaQueues the map of EDCA queues.
<    */
<   void SetEdcaQueues (EdcaQueues edcaQueues);
< 
<   /**
<    * \param ampduSize the size of the A-MPDU that needs to be padded in bytes
<    * \return the size of the padding that must be added to the end of an A-MPDU in bytes
<    *
<    * Calculates how much padding must be added to the end of an A-MPDU of the given size
<    * (once another MPDU is aggregated).
<    * Each A-MPDU subframe is padded so that its length is multiple of 4 octets.
<    */
<   static uint8_t CalculatePadding (uint32_t ampduSize);
< 
<   /**
<    * Get the A-MPDU subframe header corresponding to the MPDU size and
<    * whether the MPDU is a single MPDU.
<    *
<    * \param mpduSize size of the MPDU in bytes.
<    * \param isSingle true if S-MPDU.
<    */
<   static AmpduSubframeHeader GetAmpduSubframeHeader (uint16_t mpduSize, bool isSingle);
< 
< private:
<   EdcaQueues m_edca;   //!< the map of EDCA queues
< };
< 
< }  //namespace ns3
< 
< #endif /* MPDU_AGGREGATOR_H */
---
> /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
> /*
>  * Copyright (c) 2013
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License version 2 as
>  * published by the Free Software Foundation;
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
>  *
>  * Author: Ghada Badawy <gbadawy@gmail.com>
>  */
> 
> #ifndef MPDU_AGGREGATOR_H
> #define MPDU_AGGREGATOR_H
> 
> #include "ns3/ptr.h"
> #include "ns3/packet.h"
> #include "ns3/object.h"
> #include "ampdu-subframe-header.h"
> #include <list>
> 
> namespace ns3 {
> 
> class WifiMacHeader;
> 
> /**
>  * \brief Abstract class that concrete mpdu aggregators have to implement
>  * \ingroup wifi
>  */
> class MpduAggregator : public Object
> {
> public:
>   /**
>    * A list of deaggregated packets and their A-MPDU subframe headers.
>    */
>   typedef std::list<std::pair<Ptr<Packet>, AmpduSubframeHeader> > DeaggregatedMpdus;
>   /**
>    * A constant iterator for a list of deaggregated packets and their A-MPDU subframe headers.
>    */
>   typedef std::list<std::pair<Ptr<Packet>, AmpduSubframeHeader> >::const_iterator DeaggregatedMpdusCI;
> 
>   static TypeId GetTypeId (void);
> 
>   virtual void SetMaxAmpduSize (uint32_t maxSize) = 0;
>   virtual uint32_t GetMaxAmpduSize (void) const = 0;
>   /**
>    * \param packet Packet we have to insert into <i>aggregatedPacket</i>.
>    * \param aggregatedPacket Packet that will contain <i>packet</i>, if aggregation is possible.
>    *
>    * \return true if <i>packet</i> can be aggregated to <i>aggregatedPacket</i>, false otherwise.
>    *
>    * Adds <i>packet</i> to <i>aggregatedPacket</i>. In concrete aggregator's implementation is
>    * specified how and if <i>packet</i> can be added to <i>aggregatedPacket</i>.
>    */
>   virtual bool Aggregate (Ptr<const Packet> packet, Ptr<Packet> aggregatedPacket) = 0;
>   /**
>   * This method performs a VHT single MPDU aggregation.
>   */
>   virtual void AggregateVhtSingleMpdu (Ptr<const Packet> packet, Ptr<Packet> aggregatedPacket) = 0;
>   /**
>    * Adds A-MPDU subframe header and padding to each MPDU that is part of an A-MPDU before it is sent.
>    */
>   virtual void AddHeaderAndPad (Ptr<Packet> packet, bool last, bool vhtSingleMpdu) = 0;
>   /**
>    * \param packetSize size of the packet we want to insert into <i>aggregatedPacket</i>.
>    * \param aggregatedPacket packet that will contain the packet of size <i>packetSize</i>, if aggregation is possible.
>    * \param blockAckSize size of the piggybacked block ack request
>    *
>    * \return true if the packet of size <i>packetSize</i> can be aggregated to <i>aggregatedPacket</i>, false otherwise.
>    *
>    * This method is used to determine if a packet could be aggregated to an A-MPDU without exceeding the maximum packet size.
>    */
>   virtual bool CanBeAggregated (uint32_t packetSize, Ptr<Packet> aggregatedPacket, uint8_t blockAckSize) = 0;
>   /**
>    * \return padding that must be added to the end of an aggregated packet
>    *
>    * Calculates how much padding must be added to the end of an aggregated packet, after that a new packet is added.
>    * Each A-MPDU subframe is padded so that its length is multiple of 4 octets.
>    */
>   virtual uint32_t CalculatePadding (Ptr<const Packet> packet) = 0;
>   /**
>    * Deaggregates an A-MPDU by removing the A-MPDU subframe header and padding.
>    *
>    * \return list of deaggragted packets and their A-MPDU subframe headers
>    */
>   static DeaggregatedMpdus Deaggregate (Ptr<Packet> aggregatedPacket);
> };
> 
> }  //namespace ns3
> 
> #endif /* MPDU_AGGREGATOR_H */
Only in ../../ns-3-dev/src/wifi/model: mpdu-standard-aggregator.cc
Only in ../../ns-3-dev/src/wifi/model: mpdu-standard-aggregator.h
diff ../../NS3-WiGig/src/wifi/model/msdu-aggregator.cc ../../ns-3-dev/src/wifi/model/msdu-aggregator.cc
19d18
<  *         Stefano Avallone <stavallo@unina.it>
23c22
< #include "ns3/packet.h"
---
> 
25,36c24
< #include "amsdu-subframe-header.h"
< #include "qos-txop.h"
< #include "mpdu-aggregator.h"
< #include "wifi-remote-station-manager.h"
< #include "mac-low.h"
< #include "wifi-phy.h"
< #include "wifi-net-device.h"
< #include "ht-capabilities.h"
< #include "wifi-mac.h"
< #include "wifi-mac-queue.h"
< #include "wifi-mac-trailer.h"
< #include <algorithm>
---
> #include "wifi-mac-header.h"
50d37
<     .AddConstructor<MsduAggregator> ()
55,285d41
< MsduAggregator::MsduAggregator ()
< {
< }
< 
< MsduAggregator::~MsduAggregator ()
< {
< }
< 
< void
< MsduAggregator::SetEdcaQueues (EdcaQueues map)
< {
<     m_edca = map;
< }
< 
< uint16_t
< MsduAggregator::GetSizeIfAggregated (uint16_t msduSize, uint16_t amsduSize)
< {
<   NS_LOG_FUNCTION (msduSize << amsduSize);
< 
<   // the size of the A-MSDU subframe header is 14 bytes: DA (6), SA (6) and Length (2)
<   return amsduSize + CalculatePadding (amsduSize) + 14 + msduSize;
< }
< 
< Ptr<WifiMacQueueItem>
< MsduAggregator::GetNextAmsdu (Mac48Address recipient, uint8_t tid,
<                               WifiTxVector txVector, uint32_t ampduSize,
<                               Time ppduDurationLimit) const
< {
<   NS_LOG_FUNCTION (recipient << +tid << txVector << ampduSize << ppduDurationLimit);
< 
<   /* "The Address 1 field of an MPDU carrying an A-MSDU shall be set to an
<    * individual address or to the GCR concealment address" (Section 10.12
<    * of 802.11-2016)
<    */
<   NS_ABORT_MSG_IF (recipient.IsBroadcast (), "Recipient address is broadcast");
< 
<   Ptr<QosTxop> qosTxop = m_edca.find (QosUtilsMapTidToAc (tid))->second;
<   Ptr<WifiMacQueue> queue = qosTxop->GetWifiMacQueue ();
<   WifiMacQueue::ConstIterator peekedIt = queue->PeekByTidAndAddress (tid, recipient);
< 
<   if (peekedIt == queue->end ())
<     {
<       NS_LOG_DEBUG ("No packet with the given TID and address in the queue");
<       return 0;
<     }
< 
<   /* "A STA shall not transmit an A-MSDU within a QoS Data frame under a block
<    * ack agreement unless the recipient indicates support for A-MSDU by setting
<    * the A-MSDU Supported field to 1 in its BlockAck Parameter Set field of the
<    * ADDBA Response frame" (Section 10.12 of 802.11-2016)
<    */
<   // No check required for now, as we always set the A-MSDU Supported field to 1
< 
<   WifiModulationClass modulation = txVector.GetMode ().GetModulationClass ();
< 
<   // Get the maximum size of the A-MSDU we can send to the recipient
<   uint16_t maxAmsduSize = GetMaxAmsduSize (recipient, tid, modulation);
< 
<   if (maxAmsduSize == 0)
<     {
<       return 0;
<     }
< 
<   Ptr<WifiMacQueueItem> amsdu = Create<WifiMacQueueItem> (Create<const Packet> (), (*peekedIt)->GetHeader ());
<   uint8_t nMsdu = 0;
<   // We need to keep track of the first MSDU. When it is processed, it is not known
<   // if aggregation will succeed or not.
<   WifiMacQueue::ConstIterator first = peekedIt;
< 
<   // TODO Add support for the Max Number Of MSDUs In A-MSDU field in the Extended
<   // Capabilities element sent by the recipient
< 
<   while (peekedIt != queue->end ())
<     {
<       // check if aggregating the peeked MSDU violates the A-MSDU size limit
<       uint16_t newAmsduSize = GetSizeIfAggregated ((*peekedIt)->GetPacket ()->GetSize (),
<                                                    amsdu->GetPacket ()->GetSize ());
< 
<       if (newAmsduSize > maxAmsduSize)
<         {
<           NS_LOG_DEBUG ("No other MSDU can be aggregated: maximum A-MSDU size reached");
<           break;
<         }
< 
<       // check if the A-MSDU obtained by aggregating the peeked MSDU violates
<       // the A-MPDU size limit or the PPDU duration limit
<       if (!qosTxop->GetLow ()->IsWithinSizeAndTimeLimits (amsdu->GetHeader ().GetSize () + newAmsduSize
<                                                           + WIFI_MAC_FCS_LENGTH,
<                                                           recipient, tid, txVector, ampduSize, ppduDurationLimit))
<         {
<           NS_LOG_DEBUG ("No other MSDU can be aggregated");
<           break;
<         }
< 
<       // The MSDU can be aggregated to the A-MSDU.
<       // If it is the first MSDU, move to the next one
<       if (nMsdu == 0)
<         {
<           amsdu = Copy (*peekedIt);
<           peekedIt++;
<         }
<       // otherwise, remove it from the queue
<       else
<         {
<           amsdu->Aggregate (*peekedIt);
<           peekedIt = queue->Remove (peekedIt);
<         }
< 
<       nMsdu++;
< 
<       peekedIt = queue->PeekByTidAndAddress (tid, recipient, peekedIt);
<     }
< 
<   if (nMsdu < 2)
<     {
<       NS_LOG_DEBUG ("Aggregation failed (could not aggregate at least two MSDUs)");
<       return 0;
<     }
< 
<   // Aggregation succeeded, we have to remove the first MSDU
<   queue->Remove (first);
< 
<   return amsdu;
< }
< 
< uint8_t
< MsduAggregator::CalculatePadding (uint16_t amsduSize)
< {
<   return (4 - (amsduSize % 4 )) % 4;
< }
< 
< uint16_t
< MsduAggregator::GetMaxAmsduSize (Mac48Address recipient, uint8_t tid,
<                                  WifiModulationClass modulation) const
< {
<   NS_LOG_FUNCTION (this << recipient << +tid << modulation);
< 
<   AcIndex ac = QosUtilsMapTidToAc (tid);
<   Ptr<QosTxop> qosTxop = m_edca.find (ac)->second;
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (qosTxop->GetLow ()->GetPhy ()->GetDevice ());
<   NS_ASSERT (device);
<   Ptr<WifiRemoteStationManager> stationManager = device->GetRemoteStationManager ();
<   NS_ASSERT (stationManager);
< 
<   // Find the A-MSDU max size configured on this device
<   UintegerValue size;
< 
<   switch (ac)
<     {
<       case AC_BE:
<         device->GetMac ()->GetAttribute ("BE_MaxAmsduSize", size);
<         break;
<       case AC_BK:
<         device->GetMac ()->GetAttribute ("BK_MaxAmsduSize", size);
<         break;
<       case AC_VI:
<         device->GetMac ()->GetAttribute ("VI_MaxAmsduSize", size);
<         break;
<       case AC_VO:
<         device->GetMac ()->GetAttribute ("VO_MaxAmsduSize", size);
<         break;
<       default:
<         NS_ABORT_MSG ("Unknown AC " << ac);
<         return 0;
<     }
< 
<   uint16_t maxAmsduSize = size.Get ();
< 
<   if (maxAmsduSize == 0)
<     {
<       NS_LOG_DEBUG ("A-MSDU Aggregation is disabled on this station for AC " << ac);
<       return 0;
<     }
< 
<   // Retrieve the Capabilities elements advertised by the recipient
<   //// WIGIG ////
<   Ptr<const EdmgCapabilities> edmgCapabilities = stationManager->GetStationEdmgCapabilities (recipient);
<   Ptr<const DmgCapabilities> dmgCapabilities = stationManager->GetStationDmgCapabilities (recipient);
<   //// WIGIG ////
<   Ptr<const VhtCapabilities> vhtCapabilities = stationManager->GetStationVhtCapabilities (recipient);
<   Ptr<const HtCapabilities> htCapabilities = stationManager->GetStationHtCapabilities (recipient);
< 
<   //// WIGIG ////
<   if (dmgCapabilities || edmgCapabilities)
<     {
<       /* In IEEE 802.11ad/ay, DMG STAs do not negotiate the maximum size of an A-MSDU not the maximum length of an MPDU */
<       return maxAmsduSize;
<     }
<   //// WIGIG ////
< 
<   if (!htCapabilities)
<     {
<       /* "A non-DMG STA shall not transmit an A-MSDU to a STA from which it has
<        * not received a frame containing an HT Capabilities element" (Section
<        * 10.12 of 802.11-2016)
<        */
<       NS_LOG_DEBUG ("A-MSDU Aggregation disabled because the recipient did not"
<                     " send an HT Capabilities element");
<       return 0;
<     }
< 
<   // Determine the constraint imposed by the recipient based on the PPDU
<   // format used to transmit the A-MSDU
<   if (modulation >= WIFI_MOD_CLASS_VHT)
<     {
<       // the maximum A-MSDU size is indirectly constrained by the maximum MPDU
<       // size supported by the recipient and advertised in the VHT Capabilities
<       // element (see Table 9-19 of 802.11-2016 as amended by 802.11ax)
<       NS_ABORT_MSG_IF (!vhtCapabilities, "VHT Capabilities element not received");
< 
<       maxAmsduSize = std::min (maxAmsduSize, static_cast<uint16_t>(vhtCapabilities->GetMaxMpduLength () - 56));
<     }
<   else if (modulation == WIFI_MOD_CLASS_HT)
<     {
<       // the maximum A-MSDU size is constrained by the maximum A-MSDU size
<       // supported by the recipient and advertised in the HT Capabilities
<       // element (see Table 9-19 of 802.11-2016)
< 
<       maxAmsduSize = std::min (maxAmsduSize, htCapabilities->GetMaxAmsduLength ());
<     }
<   else  // non-HT PPDU
<     {
<       // the maximum A-MSDU size is indirectly constrained by the maximum PSDU size
<       // supported by the recipient (see Table 9-19 of 802.11-2016)
< 
<       maxAmsduSize = std::min (maxAmsduSize, static_cast<uint16_t>(3839));
<     }
< 
<   return maxAmsduSize;
< }
< 
296c52
<   uint8_t padding;
---
>   uint32_t padding;
315c71
<       std::pair<Ptr<const Packet>, AmsduSubframeHeader> packetHdr (extractedMsdu, hdr);
---
>       std::pair<Ptr<Packet>, AmsduSubframeHeader> packetHdr (extractedMsdu, hdr);
diff ../../NS3-WiGig/src/wifi/model/msdu-aggregator.h ../../ns-3-dev/src/wifi/model/msdu-aggregator.h
23a24,25
> #include "ns3/ptr.h"
> #include "ns3/packet.h"
25,28c27,28
< #include "ns3/nstime.h"
< #include "wifi-mode.h"
< #include "qos-utils.h"
< #include <map>
---
> #include "amsdu-subframe-header.h"
> #include <list>
32,36c32
< class AmsduSubframeHeader;
< class Packet;
< class QosTxop;
< class WifiMacQueueItem;
< class WifiTxVector;
---
> class WifiMacHeader;
39c35
<  * \brief Aggregator used to construct A-MSDUs
---
>  * \brief Abstract class that concrete msdu aggregators have to implement
45,56c41,42
<   /// DeaggregatedMsdus typedef
<   typedef std::list<std::pair<Ptr<const Packet>, AmsduSubframeHeader> > DeaggregatedMsdus;
<   /// DeaggregatedMsdusCI typedef
<   typedef std::list<std::pair<Ptr<const Packet>, AmsduSubframeHeader> >::const_iterator DeaggregatedMsdusCI;
<   /// EDCA queues typedef
<   typedef std::map<AcIndex, Ptr<QosTxop> > EdcaQueues;
< 
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
<   static TypeId GetTypeId (void);
---
>   typedef std::list<std::pair<Ptr<Packet>, AmsduSubframeHeader> > DeaggregatedMsdus;
>   typedef std::list<std::pair<Ptr<Packet>, AmsduSubframeHeader> >::const_iterator DeaggregatedMsdusCI;
58,59c44
<   MsduAggregator ();
<   virtual ~MsduAggregator ();
---
>   static TypeId GetTypeId (void);
61,71c46,47
<   /**
<    * Compute the size of the A-MSDU resulting from the aggregation of an MSDU of
<    * size <i>msduSize</i> and an A-MSDU of size <i>amsduSize</i>.
<    * Note that only the basic A-MSDU subframe format (section 9.3.2.2.2 of IEEE
<    * 802.11-2016) is supported.
<    *
<    * \param msduSize the MSDU size in bytes.
<    * \param amsduSize the A-MSDU size in bytes.
<    * \return the size of the resulting A-MSDU in bytes.
<    */
<   static uint16_t GetSizeIfAggregated (uint16_t msduSize, uint16_t amsduSize);
---
>   virtual void SetMaxAmsduSize (uint32_t maxSize) = 0;
>   virtual uint32_t GetMaxAmsduSize (void) const = 0;
73,112c49,51
<   /**
<    * Dequeue MSDUs to be transmitted to a given station and belonging to a
<    * given TID from the corresponding EDCA queue and aggregate them to form
<    * an A-MSDU that meets the following constraints:
<    *
<    * - the A-MSDU size does not exceed the maximum A-MSDU size as determined for
<    * the modulation class indicated by the given TxVector
<    *
<    * - the size of the A-MPDU resulting from the aggregation of the MPDU in which
<    * the A-MSDU will be embedded and an existing A-MPDU of the given size
<    * (possibly null) does not exceed the maximum A-MPDU size as determined for
<    * the modulation class indicated by the given TxVector
<    *
<    * - the time to transmit the resulting PPDU, according to the given TxVector,
<    * does not exceed both the maximum PPDU duration allowed by the corresponding
<    * modulation class (if any) and the given PPDU duration limit (if distinct from
<    * Time::Min ())
<    *
<    * If it is not possible to aggregate at least two MSDUs, no MSDU is dequeued
<    * from the EDCA queue and a null pointer is returned.
<    *
<    * \param recipient the receiver station address.
<    * \param tid the TID.
<    * \param txVector the TxVector used to transmit the frame
<    * \param ampduSize the size of the existing A-MPDU in bytes
<    * \param ppduDurationLimit the limit on the PPDU duration
<    * \return the resulting A-MSDU, if aggregation is possible, 0 otherwise.
<    */
<   Ptr<WifiMacQueueItem> GetNextAmsdu (Mac48Address recipient, uint8_t tid,
<                                       WifiTxVector txVector, uint32_t ampduSize = 0,
<                                       Time ppduDurationLimit = Time::Min ()) const;
< 
<   /**
<    * Determine the maximum size for an A-MSDU of the given TID that can be sent
<    * to the given receiver when using the given modulation class.
<    *
<    * \param recipient the receiver station address.
<    * \param tid the TID.
<    * \param modulation the modulation class.
<    * \return the maximum A-MSDU size in bytes.
---
>   /* Adds <i>packet</i> to <i>aggregatedPacket</i>. In concrete aggregator's implementation is
>    * specified how and if <i>packet</i> can be added to <i>aggregatedPacket</i>. If <i>packet</i>
>    * can be added returns true, false otherwise.
114,115c53,54
<   uint16_t GetMaxAmsduSize (Mac48Address recipient, uint8_t tid,
<                             WifiModulationClass modulation) const;
---
>   virtual bool Aggregate (Ptr<const Packet> packet, Ptr<Packet> aggregatedPacket,
>                           Mac48Address src, Mac48Address dest) = 0;
117,121d55
<   /**
<    *
<    * \param aggregatedPacket the aggregated packet.
<    * \returns DeaggregatedMsdus.
<    */
123,143d56
< 
<   /**
<    * Set the map of EDCA queues.
<    *
<    * \param map the map of EDCA queues.
<    */
<   void SetEdcaQueues (EdcaQueues map);
< 
<   /**
<    * Calculate how much padding must be added to the end of an A-MSDU of the
<    * given size if a new MSDU is added.
<    * Each A-MSDU subframe is padded so that its length is multiple of 4 octets.
<    *
<    * \param amsduSize the size of the A-MSDU
<    *
<    * \return the number of octets required for padding
<    */
<   static uint8_t CalculatePadding (uint16_t amsduSize);
< 
< private:
<   EdcaQueues m_edca;   //!< the map of EDCA queues
Only in ../../ns-3-dev/src/wifi/model: msdu-standard-aggregator.cc
Only in ../../ns-3-dev/src/wifi/model: msdu-standard-aggregator.h
Only in ../../NS3-WiGig/src/wifi/model: multi-band-net-device.cc
Only in ../../NS3-WiGig/src/wifi/model: multi-band-net-device.h
diff ../../NS3-WiGig/src/wifi/model/nist-error-rate-model.cc ../../ns-3-dev/src/wifi/model/nist-error-rate-model.cc
22c22
< #include "ns3/log.h"
---
> #include <cmath>
24d23
< #include "dsss-error-rate-model.h"
25a25
> #include "ns3/log.h"
87d86
< 
99,109c98
< NistErrorRateModel::Get1024QamBer (double snr) const
< {
<   NS_LOG_FUNCTION (this << snr);
<   double z = std::sqrt (snr / (341.0 * 2.0));
<   double ber = 31.0 / 160.0 * 0.5 * erfc (z);
<   NS_LOG_INFO ("1024-Qam" << " snr=" << snr << " ber=" << ber);
<   return ber;
< }
< 
< double
< NistErrorRateModel::GetFecBpskBer (double snr, uint64_t nbits,
---
> NistErrorRateModel::GetFecBpskBer (double snr, uint32_t nbits,
120c109
<   double pms = std::pow (1 - pe, nbits);
---
>   double pms = std::pow (1 - pe, (double)nbits);
125c114
< NistErrorRateModel::GetFecQpskBer (double snr, uint64_t nbits,
---
> NistErrorRateModel::GetFecQpskBer (double snr, uint32_t nbits,
136c125
<   double pms = std::pow (1 - pe, nbits);
---
>   double pms = std::pow (1 - pe, (double)nbits);
213c202
< NistErrorRateModel::GetFec16QamBer (double snr, uint64_t nbits,
---
> NistErrorRateModel::GetFec16QamBer (double snr, uint32_t nbits,
224c213
<   double pms = std::pow (1 - pe, nbits);
---
>   double pms = std::pow (1 - pe, static_cast<double> (nbits));
229c218
< NistErrorRateModel::GetFec64QamBer (double snr, uint64_t nbits,
---
> NistErrorRateModel::GetFec64QamBer (double snr, uint32_t nbits,
240c229
<   double pms = std::pow (1 - pe, nbits);
---
>   double pms = std::pow (1 - pe, static_cast<double> (nbits));
245c234
< NistErrorRateModel::GetFec256QamBer (double snr, uint64_t nbits,
---
> NistErrorRateModel::GetFec256QamBer (double snr, uint32_t nbits,
256c245
<   double pms = std::pow (1 - pe, nbits);
---
>   double pms = std::pow (1 - pe, static_cast<double> (nbits));
261,277c250
< NistErrorRateModel::GetFec1024QamBer (double snr, uint64_t nbits,
<                                       uint32_t bValue) const
< {
<   NS_LOG_FUNCTION (this << snr << nbits << bValue);
<   double ber = Get1024QamBer (snr);
<   if (ber == 0.0)
<     {
<       return 1.0;
<     }
<   double pe = CalculatePe (ber, bValue);
<   pe = std::min (pe, 1.0);
<   double pms = std::pow (1 - pe, nbits);
<   return pms;
< }
< 
< double
< NistErrorRateModel::GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint64_t nbits) const
---
> NistErrorRateModel::GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint32_t nbits) const
283,284c256
<       || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT
<       || mode.GetModulationClass () == WIFI_MOD_CLASS_HE)
---
>       || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
369,385d340
<       else if (mode.GetConstellationSize () == 1024)
<         {
<           if (mode.GetCodeRate () == WIFI_CODE_RATE_5_6)
<             {
<               return GetFec1024QamBer (snr,
<                                        nbits,
<                                        5    // b value
<                                        );
<             }
<           else
<             {
<               return GetFec1024QamBer (snr,
<                                        nbits,
<                                        3    // b value
<                                        );
<             }
<         }
389c344
<       switch (mode.GetDataRate (20))
---
>       switch (mode.GetDataRate (20, 0, 1))
diff ../../NS3-WiGig/src/wifi/model/nist-error-rate-model.h ../../ns-3-dev/src/wifi/model/nist-error-rate-model.h
23a24,25
> #include <stdint.h>
> #include "wifi-mode.h"
24a27
> #include "dsss-error-rate-model.h"
39,42d41
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
47c46
<   double GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint64_t nbits) const;
---
>   virtual double GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint32_t nbits) const;
54,55c53,54
<    * \param p the SNR ratio (not dB)
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param p
>    * \param bValue
57c56
<    * \return the coded BER
---
>    * \return BER
63c62
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
71c70
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
79c78
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
87c86
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
95c94
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
100,106d98
<    * Return BER of QAM1024 at the given SNR.
<    *
<    * \param snr SNR ratio (not dB)
<    * \return BER of QAM1024 at the given SNR
<    */
<   double Get1024QamBer (double snr) const;
<   /**
109c101
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
111c103
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
115c107
<   double GetFecBpskBer (double snr, uint64_t nbits,
---
>   double GetFecBpskBer (double snr, uint32_t nbits,
120c112
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
122c114
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
126c118
<   double GetFecQpskBer (double snr, uint64_t nbits,
---
>   double GetFecQpskBer (double snr, uint32_t nbits,
131c123
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
133c125
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
137c129
<   double GetFec16QamBer (double snr, uint64_t nbits,
---
>   double GetFec16QamBer (double snr, uint32_t nbits,
142c134
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
144c136
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
148c140
<   double GetFec64QamBer (double snr, uint64_t nbits,
---
>   double GetFec64QamBer (double snr, uint32_t nbits,
153c145
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
155c147
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
158c150
<   double GetFec256QamBer (double snr, uint64_t nbits,
---
>   double GetFec256QamBer (double snr, uint32_t nbits,
160,169d151
<   /**
<    * Return BER of QAM1024 at the given SNR after applying FEC.
<    *
<    * \param snr SNR ratio (not dB)
<    * \param nbits the number of bits in the chunk
<    * \param bValue such that coding rate = bValue / (bValue + 1)
<    * \return BER of QAM1024 at the given SNR after applying FEC
<    */
<   double GetFec1024QamBer (double snr, uint64_t nbits,
<                            uint32_t bValue) const;
Only in ../../NS3-WiGig/src/wifi/model: obss-pd-algorithm.cc
Only in ../../NS3-WiGig/src/wifi/model: obss-pd-algorithm.h
diff ../../NS3-WiGig/src/wifi/model/onoe-wifi-manager.cc ../../ns-3-dev/src/wifi/model/onoe-wifi-manager.cc
21,22d20
< #include "ns3/log.h"
< #include "ns3/simulator.h"
24c22,24
< #include "wifi-tx-vector.h"
---
> #include "ns3/simulator.h"
> #include "ns3/log.h"
> #include "ns3/uinteger.h"
30c30
< NS_LOG_COMPONENT_DEFINE ("OnoeWifiManager");
---
> NS_LOG_COMPONENT_DEFINE ("OnoeWifiRemoteStation");
40,48c40,47
<   Time m_nextModeUpdate; ///< next mode update
<   bool m_rateBlocked; ///< whether the rate cannot be changed
<   uint32_t m_shortRetry; ///< short retry
<   uint32_t m_longRetry; ///< long retry
<   uint32_t m_tx_ok; ///< transmit OK
<   uint32_t m_tx_err; ///< transmit error
<   uint32_t m_tx_retr; ///< transmit retry
<   uint32_t m_tx_upper; ///< transmit upper
<   uint8_t m_txrate; ///< transmit rate
---
>   Time m_nextModeUpdate;
>   uint32_t m_shortRetry;
>   uint32_t m_longRetry;
>   uint32_t m_tx_ok;
>   uint32_t m_tx_err;
>   uint32_t m_tx_retr;
>   uint32_t m_tx_upper;
>   uint32_t m_txrate;
73,76d71
<     .AddTraceSource ("Rate",
<                      "Traced value for rate changes (b/s)",
<                      MakeTraceSourceAccessor (&OnoeWifiManager::m_currentRate),
<                      "ns3::TracedValueCallback::Uint64")
82,88d76
<   : WifiRemoteStationManager (),
<     m_currentRate (0)
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< OnoeWifiManager::~OnoeWifiManager ()
90,108d77
<   NS_LOG_FUNCTION (this);
< }
< 
< void
< OnoeWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
114d82
<   NS_LOG_FUNCTION (this);
117d84
<   station->m_rateBlocked = false;
129c96,97
< OnoeWifiManager::DoReportRxOk (WifiRemoteStation *station, double rxSnr, WifiMode txMode)
---
> OnoeWifiManager::DoReportRxOk (WifiRemoteStation *station,
>                                double rxSnr, WifiMode txMode)
131d98
<   NS_LOG_FUNCTION (this << station << rxSnr << txMode);
137,138c104
<   NS_LOG_FUNCTION (this << st);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
140d105
<   station->m_rateBlocked = true;  // do not change rate for retransmission
146,147c111
<   NS_LOG_FUNCTION (this << st);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
149d112
<   station->m_rateBlocked = true;  // do not change rate for retransmission
153c116,117
< OnoeWifiManager::DoReportRtsOk (WifiRemoteStation *st, double ctsSnr, WifiMode ctsMode, double rtsSnr)
---
> OnoeWifiManager::DoReportRtsOk (WifiRemoteStation *station,
>                                 double ctsSnr, WifiMode ctsMode, double rtsSnr)
155,157d118
<   NS_LOG_FUNCTION (this << st << ctsSnr << ctsMode << rtsSnr);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
<   station->m_rateBlocked = true;  // do not change rate
161,162c122,123
< OnoeWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> OnoeWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                  double ackSnr, WifiMode ackMode, double dataSnr)
164,165c125
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
168d127
<   station->m_rateBlocked = false;  // we can change the rate for next packet
174,175c133
<   NS_LOG_FUNCTION (this << st);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
178d135
<   station->m_rateBlocked = false;  // we can change the rate for next packet
184,185c141
<   NS_LOG_FUNCTION (this << st);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
188d143
<   station->m_rateBlocked = false;  // we can change the rate for next packet
194d148
<   NS_LOG_FUNCTION (this << station);
203,204c157
<   NS_LOG_FUNCTION (this << station);
<   if (Simulator::Now () < station->m_nextModeUpdate || station->m_rateBlocked)
---
>   if (Simulator::Now () < station->m_nextModeUpdate)
215c168
<   uint8_t nrate;
---
>   uint32_t nrate;
286,287c239
<   NS_LOG_FUNCTION (this << st);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
290c242
<   uint8_t rateIndex;
---
>   uint32_t rateIndex;
328c280
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   uint32_t channelWidth = GetChannelWidth (station);
330a283
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
333,339c286
<   WifiMode mode = GetSupported (station, rateIndex);
<   if (m_currentRate != mode.GetDataRate (channelWidth))
<     {
<       NS_LOG_DEBUG ("New datarate: " << mode.GetDataRate (channelWidth));
<       m_currentRate = mode.GetDataRate (channelWidth);
<     }
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, rateIndex), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
345,347c292,293
<   NS_LOG_FUNCTION (this << st);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
>   uint32_t channelWidth = GetChannelWidth (station);
349a296
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
354d300
<   WifiMode mode;
357c303
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
361c307
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
363d308
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
364a310,335
> }
> 
> bool
> OnoeWifiManager::IsLowLatency (void) const
> {
>   return false;
> }
> 
> void
> OnoeWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> OnoeWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/onoe-wifi-manager.h ../../ns-3-dev/src/wifi/model/onoe-wifi-manager.h
24d23
< #include "ns3/traced-value.h"
25a25
> #include "ns3/nstime.h"
42,44c42,44
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
---
>  * This RAA does not support HT or VHT modes and will error exit
>  * if the user tries to configure this RAA with a Wi-Fi MAC that
>  * has VhtSupported or HtSupported set.
49,52d48
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
53a50
> 
55d51
<   virtual ~OnoeWifiManager ();
56a53,55
>   // Inherited from WifiRemoteStationManager
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
59,73c58,72
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
---
>   //overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool IsLowLatency (void) const;
78c77
<    * \param station the ONOE wifi remote station
---
>    * \param station
81,85d79
<   /**
<    * Update the mode.
<    *
<    * \param station the ONOE wifi remote station
<    */
88,92c82,84
<   Time m_updatePeriod; ///< update period
<   uint32_t m_addCreditThreshold; ///< add credit threshold
<   uint32_t m_raiseThreshold; ///< raise threshold
< 
<   TracedValue<uint64_t> m_currentRate; //!< Trace rate changes
---
>   Time m_updatePeriod;
>   uint32_t m_addCreditThreshold;
>   uint32_t m_raiseThreshold;
diff ../../NS3-WiGig/src/wifi/model/originator-block-ack-agreement.cc ../../ns-3-dev/src/wifi/model/originator-block-ack-agreement.cc
22d21
< #include "ns3/log.h"
24,25d22
< #include "wifi-mac-queue-item.h"
< #include "wifi-utils.h"
29c26,32
< NS_LOG_COMPONENT_DEFINE ("OriginatorBlockAckAgreement");
---
> OriginatorBlockAckAgreement::OriginatorBlockAckAgreement ()
>   : BlockAckAgreement (),
>     m_state (PENDING),
>     m_sentMpdus (0),
>     m_needBlockAckReq (false)
> {
> }
33c36,38
<     m_state (PENDING)
---
>     m_state (PENDING),
>     m_sentMpdus (0),
>     m_needBlockAckReq (false)
42c47
< OriginatorBlockAckAgreement::SetState (State state)
---
> OriginatorBlockAckAgreement::SetState (enum State state)
45,50c50,54
< }
< 
< OriginatorBlockAckAgreement::State
< OriginatorBlockAckAgreement::GetState (void) const
< {
<   return m_state;
---
>   if (state == INACTIVE)
>     {
>       m_needBlockAckReq = false;
>       m_sentMpdus = 0;
>     }
66,72c70
< OriginatorBlockAckAgreement::IsRejected (void) const
< {
<   return (m_state == REJECTED) ? true : false;
< }
< 
< bool
< OriginatorBlockAckAgreement::IsNoReply (void) const
---
> OriginatorBlockAckAgreement::IsInactive (void) const
74c72
<   return (m_state == NO_REPLY) ? true : false;
---
>   return (m_state == INACTIVE) ? true : false;
78c76
< OriginatorBlockAckAgreement::IsReset (void) const
---
> OriginatorBlockAckAgreement::IsUnsuccessful (void) const
80,98c78
<   return (m_state == RESET) ? true : false;
< }
< 
< uint16_t
< OriginatorBlockAckAgreement::GetStartingSequence (void) const
< {
<   if (m_txWindow.GetWinSize () == 0)
<     {
<       // the TX window has not been initialized yet
<       return m_startingSeq;
<     }
<   return m_txWindow.GetWinStart ();
< }
< 
< std::size_t
< OriginatorBlockAckAgreement::GetDistance (uint16_t seqNumber) const
< {
<   NS_ASSERT (seqNumber < SEQNO_SPACE_SIZE);
<   return (seqNumber - GetStartingSequence () + SEQNO_SPACE_SIZE) % SEQNO_SPACE_SIZE;
---
>   return (m_state == UNSUCCESSFUL) ? true : false;
102c82
< OriginatorBlockAckAgreement::InitTxWindow (void)
---
> OriginatorBlockAckAgreement::NotifyMpduTransmission (uint16_t nextSeqNumber)
104,130c84,88
<   m_txWindow.Init (m_startingSeq, m_bufferSize);
< }
< 
< void
< OriginatorBlockAckAgreement::AdvanceTxWindow (void)
< {
<   while (m_txWindow.At (0))
<     {
<       m_txWindow.Advance (1); // reset the current head -- ensures loop termination
<     }
< }
< 
< void
< OriginatorBlockAckAgreement::NotifyTransmittedMpdu (Ptr<const WifiMacQueueItem> mpdu)
< {
<   uint16_t mpduSeqNumber = mpdu->GetHeader ().GetSequenceNumber ();
<   uint16_t distance = GetDistance (mpduSeqNumber);
< 
<   if (distance >= SEQNO_SPACE_HALF_SIZE)
<     {
<       NS_LOG_DEBUG ("Transmitted an old MPDU, do nothing.");
<       return;
<     }
< 
<   // advance the transmit window if an MPDU beyond the current transmit window
<   // is transmitted (see Section 10.24.7.7 of 802.11-2016)
<   if (distance >= m_txWindow.GetWinSize ())
---
>   NS_ASSERT (m_sentMpdus < m_bufferSize);
>   m_sentMpdus++;
>   uint16_t delta = (nextSeqNumber - m_startingSeq + 4096) % 4096;
>   uint16_t min = m_bufferSize < 64 ? m_bufferSize : 64;
>   if (delta >= min || m_sentMpdus == m_bufferSize)
132,137c90
<       std::size_t count = distance - m_txWindow.GetWinSize () + 1;
<       m_txWindow.Advance (count);
<       // transmit window may advance further
<       AdvanceTxWindow ();
<       NS_LOG_DEBUG ("Transmitted MPDU beyond current transmit window. New starting sequence number: "
<                     << m_txWindow.GetWinStart ());
---
>       m_needBlockAckReq = true;
141,142c94,95
< void
< OriginatorBlockAckAgreement::NotifyAckedMpdu (Ptr<const WifiMacQueueItem> mpdu)
---
> bool
> OriginatorBlockAckAgreement::IsBlockAckRequestNeeded (void) const
144,161c97
<   uint16_t mpduSeqNumber = mpdu->GetHeader ().GetSequenceNumber ();
<   uint16_t distance = GetDistance (mpduSeqNumber);
< 
<   if (distance >= SEQNO_SPACE_HALF_SIZE)
<     {
<       NS_LOG_DEBUG ("Acked an old MPDU, do nothing.");
<       return;
<     }
< 
<   // when an MPDU is transmitted, the transmit window is updated such that the
<   // transmitted MPDU is in the window, hence we cannot be notified of the
<   // acknowledgment of an MPDU which is beyond the transmit window
<   m_txWindow.At (distance) = true;
< 
<   // the starting sequence number can be advanced to the sequence number of
<   // the nearest unacknowledged MPDU
<   AdvanceTxWindow ();
<   NS_LOG_DEBUG ("Starting sequence number: " << m_txWindow.GetWinStart ());
---
>   return m_needBlockAckReq;
165c101
< OriginatorBlockAckAgreement::NotifyDiscardedMpdu (Ptr<const WifiMacQueueItem> mpdu)
---
> OriginatorBlockAckAgreement::CompleteExchange (void)
167,180c103,104
<   uint16_t mpduSeqNumber = mpdu->GetHeader ().GetSequenceNumber ();
<   uint16_t distance = GetDistance (mpduSeqNumber);
< 
<   if (distance >= SEQNO_SPACE_HALF_SIZE)
<     {
<       NS_LOG_DEBUG ("Discarded an old MPDU, do nothing.");
<       return;
<     }
< 
<   m_txWindow.Advance (distance + 1);
<   // transmit window may advance further
<   AdvanceTxWindow ();
<   NS_LOG_DEBUG ("Discarded MPDU within current transmit window. New starting sequence number: "
<                 << m_txWindow.GetWinStart ());
---
>   m_needBlockAckReq = false;
>   m_sentMpdus = 0;
diff ../../NS3-WiGig/src/wifi/model/originator-block-ack-agreement.h ../../ns-3-dev/src/wifi/model/originator-block-ack-agreement.h
25,27d24
< #include "block-ack-window.h"
< 
< class OriginatorBlockAckWindowTest;
31,32d27
< class WifiMacQueueItem;
< 
35,56c30,31
<  * Maintains the state and information about transmitted MPDUs with Ack Policy set to Block Ack
<  * for an originator station. The state diagram is as follows:
<  *
<    \verbatim
<     /------------\ send ADDBARequest ----------------
<     |   START    |------------------>|   PENDING    |-------
<     \------------/                   ----------------       \
<           ^            receive     /        |                \
<           |        ADDBAResponse  /         |                 \
<           |          (failure)   v          |                  \
<           |        ---------------          |                   --------------------->  ----------------
<           |        |  REJECTED   |          |          receive ADDBAResponse (success)  |  ESTABLISHED |
<           |        ---------------          |      no            -------------------->  ----------------
<           |           receive    ^          | ADDBAResponse     /
<           |        ADDBAResponse  \         |                  /
<           |          (failure)     \        v                 /
<           |                         ----------------         /
<           |-------------------------|   NO_REPLY   |---------
<             Reset after timeout     ----------------
<    \endverbatim
<  *
<  * See also OriginatorBlockAckAgreement::State
---
>  * Maintains the state and information about transmitted MPDUs with ack policy block ack
>  * for an originator station.
60d34
<   /// allow BlockAckManager class access
62,63d35
<   /// allow OriginatorBlockAckWindowTest class access
<   friend class ::OriginatorBlockAckWindowTest;
68,73d39
<   /**
<    * Constructor
<    *
<    * \param recipient MAC address
<    * \param tid Traffic ID
<    */
75a42,60
>   /*                                      receive ADDBAResponse
>    *  send ADDBARequest ---------------   status code = success  ---------------
>    *  ----------------->|   PENDING    |------------------------>|  ESTABLISHED |-----
>    *                    ---------------                          ---------------      |
>    *                          |                                    /   ^    ^         |
>    *   receive ADDBAResponse  |                receive BlockAck   /    |    |         | receive BlockAck
>    *   status code = failure  |           retryPkts + queuePkts  /     |    |         | retryPkts + queuePkts
>    *                          v                     <           /      |    |         |           >=
>    *                   ---------------     blockAckThreshold   /       |    |         | blockAckThreshold
>    *                   | UNSUCCESSFUL |                       /        |    |         |
>    *                   ---------------                       v         |    ----------|
>    *                                            --------------         |
>    *                                            |  INACTIVE   |        |
>    *                                            --------------         |
>    *                        send a MPDU (Normal Ack)   |               |
>    *                        retryPkts + queuePkts      |               |
>    *                                  >=               |               |
>    *                         blockAckThreshold         |----------------
>    */
86c71,80
<   *    with Ack Policy set to Block Ack.
---
>   *    with ack policy set to block ack.
>   *
>   *  INACTIVE:
>   *    In our implementation, block ack tear-down happens only if an inactivity timeout occurs
>   *    so we could have an active block ack but a number of packets that doesn't reach the value of
>   *    m_blockAckThreshold (see ns3::BlockAckManager). In these conditions the agreement becomes
>   *    INACTIVE until that the number of packets reaches the value of m_blockAckThreshold again.
>   *
>   *  UNSUCCESSFUL (not used for now):
>   *    The agreement's state becomes UNSUCCESSFUL if:
88,99c82,89
<   *  NO_REPLY
<   *    No reply after an ADDBA request. In this state the originator will send the rest of packets
<   *    in queue using normal MPDU.
<   *
<   *  RESET
<   *    A transient state to mark the agreement for reinitialization after failed ADDBA request.
<   *    Since it is a temporary state, it is not included in the state diagram above. In this
<   *    state the next transmission will be treated as if the BA agreement is not created yet.
<   *
<   *  REJECTED (not used for now):
<   *    The agreement's state becomes REJECTED if an ADDBAResponse frame is received from recipient 
<   *    and the Status Code field is set to failure.
---
>   *    - its previous state was PENDING and an ADDBAResponse frame wasn't received from
>   *      recipient station within an interval of time defined by m_bAckSetupTimeout attribute
>   *      in ns3::WifiMac.
>   *    - an ADDBAResponse frame is received from recipient and the Status Code field is set
>   *      to failure.
>   *
>   *    In both cases for station addressed by BlockAckAgreement::m_peer and for
>   *    TID BlockAckAgreement::m_tid block ack mechanism won't be used.
101d90
<   /// State enumeration
106,108c95,96
<     NO_REPLY,
<     RESET,
<     REJECTED
---
>     INACTIVE,
>     UNSUCCESSFUL
110,121c98
<   /**
<    * Set the current state.
<    *
<    * \param state to set
<    */
<   void SetState (State state);
<   /**
<    * Get the current state.
<    *
<    * \return state
<    */
<   State GetState (void) const;
---
>   void SetState (enum State state);
137c114
<    * Check if the current state of this agreement is NO_REPLY.
---
>    * Check if the current state of this agreement is INACTIVE.
139c116
<    * \return true if the current state of this agreement is NO_REPLY,
---
>    * \return true if the current state of this agreement is INACTIVE,
142c119
<   bool IsNoReply (void) const;
---
>   bool IsInactive (void) const;
144c121
<    * Check if the current state of this agreement is RESET.
---
>    * Check if the current state of this agreement is UNSUCCESSFUL.
146c123
<    * \return true if the current state of this agreement is RESET,
---
>    * \return true if the current state of this agreement is UNSUCCESSFUL,
149c126
<   bool IsReset (void) const;
---
>   bool IsUnsuccessful (void) const;
151c128
<    * Check if the current state of this agreement is REJECTED.
---
>    * Notifies a packet's transmission with ack policy Block Ack.
153,154c130
<    * \return true if the current state of this agreement is REJECTED,
<    *         false otherwise
---
>    * \param nextSeqNumber
156,157c132
<   bool IsRejected (void) const;
< 
---
>   void NotifyMpduTransmission (uint16_t nextSeqNumber);
159,161c134,135
<    * Return the starting sequence number of the transmit window, if a transmit
<    * window has been initialized. Otherwise, return the starting sequence number
<    * stored by the BlockAckAgreement base class.
---
>    * Returns true if all packets for which a block ack was negotiated have been transmitted so
>    * a block ack request is needed in order to acknowledge them.
163c137,138
<    * \return the starting sequence number.
---
>    * \return  true if all packets for which a block ack was negotiated have been transmitted,
>    * false otherwise
165,202c140,141
<   uint16_t GetStartingSequence (void) const;
< 
<   /**
<    * Get the distance between the current starting sequence number and the
<    * given sequence number.
<    *
<    * \param seqNumber the given sequence number
<    * \return the distance of the given sequence number from the current winstart
<    */
<   std::size_t GetDistance (uint16_t seqNumber) const;
< 
<   /**
<    * Initialize the originator's transmit window by setting its size and starting
<    * sequence number equal to the values stored by the BlockAckAgreement base class.
<    */
<   void InitTxWindow (void);
< 
<   /**
<    * Advance the transmit window so as to include the transmitted MPDU, if the
<    * latter is not an old packet and is beyond the current transmit window.
<    *
<    * \param mpdu the transmitted MPDU
<    */
<   void NotifyTransmittedMpdu (Ptr<const WifiMacQueueItem> mpdu);
<   /**
<    * Record that the given MPDU has been acknowledged and advance the transmit
<    * window if possible.
<    *
<    * \param mpdu the acknowledged MPDU
<    */
<   void NotifyAckedMpdu (Ptr<const WifiMacQueueItem> mpdu);
<   /**
<    * Advance the transmit window beyond the MPDU that has been reported to
<    * be discarded.
<    *
<    * \param mpdu the discarded MPDU
<    */
<   void NotifyDiscardedMpdu (Ptr<const WifiMacQueueItem> mpdu);
---
>   bool IsBlockAckRequestNeeded (void) const;
>   void CompleteExchange (void);
206,213c145,147
<   /**
<    * Advance the transmit window so that the starting sequence number is the
<    * nearest unacknowledged MPDU.
<    */
<   void AdvanceTxWindow (void);
< 
<   State m_state;                 ///< state
<   BlockAckWindow m_txWindow;     ///< originator's transmit window
---
>   enum State m_state;
>   uint16_t m_sentMpdus;
>   bool m_needBlockAckReq;
diff ../../NS3-WiGig/src/wifi/model/parf-wifi-manager.cc ../../ns-3-dev/src/wifi/model/parf-wifi-manager.cc
21,23d20
< #include "ns3/log.h"
< #include "ns3/uinteger.h"
< #include "ns3/data-rate.h"
25a23,26
> #include "ns3/assert.h"
> #include "ns3/log.h"
> #include "ns3/uinteger.h"
> #include "ns3/trace-source-accessor.h"
29c30
< namespace ns3 {
---
> NS_LOG_COMPONENT_DEFINE ("ns3::ParfWifiManager");
31c32
< NS_LOG_COMPONENT_DEFINE ("ParfWifiManager");
---
> namespace ns3 {
47,51c48,50
<   uint8_t m_prevRateIndex;   //!< Rate index of the previous transmission.
<   uint8_t m_rateIndex;       //!< Current rate index used by the remote station.
<   uint8_t m_prevPowerLevel;  //!< Power level of the previous transmission.
<   uint8_t m_powerLevel;      //!< Current power level used by the remote station.
<   uint8_t m_nSupported;      //!< Number of supported rates by the remote station.
---
>   uint32_t m_currentRate;    //!< Current rate used by the remote station.
>   uint8_t m_currentPower;    //!< Current power used by the remote station.
>   uint32_t m_nSupported;     //!< Number of supported rates by the remote station.
97c96
< ParfWifiManager::SetupPhy (const Ptr<WifiPhy> phy)
---
> ParfWifiManager::SetupPhy (Ptr<WifiPhy> phy)
99,101c98,99
<   NS_LOG_FUNCTION (this << phy);
<   m_minPower = 0;
<   m_maxPower = phy->GetNTxPower () - 1;
---
>   m_minPower = phy->GetTxPowerStart ();
>   m_maxPower = phy->GetTxPowerEnd ();
105,122d102
< void
< ParfWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
138c118
<                                   << ", rate=" << +station->m_rateIndex << ", power=" << +station->m_powerLevel);
---
>                                   << ", rate=" << station->m_currentRate << ", power=" << (int)station->m_currentPower);
149,158c129,132
<       station->m_rateIndex = station->m_nSupported - 1;
<       station->m_prevRateIndex = station->m_nSupported - 1;
<       station->m_powerLevel = m_maxPower;
<       station->m_prevPowerLevel = m_maxPower;
<       WifiMode mode = GetSupported (station, station->m_rateIndex);
<       uint16_t channelWidth = GetChannelWidth (station);
<       DataRate rate = DataRate (mode.GetDataRate (channelWidth));
<       double power = GetPhy ()->GetPowerDbm (m_maxPower);
<       m_powerChange (power, power, station->m_state->m_address);
<       m_rateChange (rate, rate, station->m_state->m_address);
---
>       station->m_currentRate = station->m_nSupported - 1;
>       station->m_currentPower = m_maxPower;
>       m_powerChange (station->m_currentPower, station->m_state->m_address);
>       m_rateChange (station->m_currentRate, station->m_state->m_address);
169c143,144
< /*
---
> /**
>  * \internal
182c157
<   ParfWifiRemoteStation *station = static_cast<ParfWifiRemoteStation*> (st);
---
>   ParfWifiRemoteStation *station = (ParfWifiRemoteStation *)st;
190c165
<                            << ", rate=" << +station->m_rateIndex << ", power=" << +station->m_powerLevel);
---
>                            << ", rate=" << station->m_currentRate << ", power=" << (int)station->m_currentPower);
197c172
<           if (station->m_rateIndex != 0)
---
>           if (station->m_currentRate != 0)
200c175,176
<               station->m_rateIndex--;
---
>               station->m_currentRate--;
>               m_rateChange (station->m_currentRate, station->m_state->m_address);
212c188
<           if (station->m_powerLevel < m_maxPower)
---
>           if (station->m_currentPower < m_maxPower)
215c191,192
<               station->m_powerLevel++;
---
>               station->m_currentPower++;
>               m_powerChange (station->m_currentPower, station->m_state->m_address);
227c204
<           if (station->m_powerLevel == m_maxPower)
---
>           if (station->m_currentPower == m_maxPower)
229c206
<               if (station->m_rateIndex != 0)
---
>               if (station->m_currentRate != 0)
232c209,210
<                   station->m_rateIndex--;
---
>                   station->m_currentRate--;
>                   m_rateChange (station->m_currentRate, station->m_state->m_address);
238c216,217
<               station->m_powerLevel++;
---
>               station->m_currentPower++;
>               m_powerChange (station->m_currentPower, station->m_state->m_address);
258a238
>   NS_LOG_DEBUG ("station=" << station << " rts ok");
261,262c241,242
< void ParfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                       double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> void ParfWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                       double ackSnr, WifiMode ackMode, double dataSnr)
264,265c244,245
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   ParfWifiRemoteStation *station = static_cast<ParfWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   ParfWifiRemoteStation *station = (ParfWifiRemoteStation *) st;
273c253
<   NS_LOG_DEBUG ("station=" << station << " data ok success=" << station->m_nSuccess << ", timer=" << station->m_nAttempt << ", rate=" << +station->m_rateIndex << ", power=" << +station->m_powerLevel);
---
>   NS_LOG_DEBUG ("station=" << station << " data ok success=" << station->m_nSuccess << ", timer=" << station->m_nAttempt << ", rate=" << station->m_currentRate << ", power=" << (int)station->m_currentPower);
276c256
<       && (station->m_rateIndex < (station->m_state->m_operationalRateSet.size () - 1)))
---
>       && (station->m_currentRate < (station->m_state->m_operationalRateSet.size () - 1)))
279c259,260
<       station->m_rateIndex++;
---
>       station->m_currentRate++;
>       m_rateChange (station->m_currentRate, station->m_state->m_address);
287c268
<       if (station->m_powerLevel != m_minPower)
---
>       if (station->m_currentPower != m_minPower)
290c271,272
<           station->m_powerLevel--;
---
>           station->m_currentPower--;
>           m_powerChange (station->m_currentPower, station->m_state->m_address);
314,315c296,297
<   ParfWifiRemoteStation *station = static_cast<ParfWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   ParfWifiRemoteStation *station = (ParfWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
317a300
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
321,336c304
<   WifiMode mode = GetSupported (station, station->m_rateIndex);
<   DataRate rate = DataRate (mode.GetDataRate (channelWidth));
<   DataRate prevRate = DataRate (GetSupported (station, station->m_prevRateIndex).GetDataRate (channelWidth));
<   double power = GetPhy ()->GetPowerDbm (station->m_powerLevel);
<   double prevPower = GetPhy ()->GetPowerDbm (station->m_prevPowerLevel);
<   if (station->m_prevPowerLevel != station->m_powerLevel)
<     {
<       m_powerChange (prevPower, power, station->m_state->m_address);
<       station->m_prevPowerLevel = station->m_powerLevel;
<     }
<   if (station->m_prevRateIndex != station->m_rateIndex)
<     {
<       m_rateChange (prevRate, rate, station->m_state->m_address);
<       station->m_prevRateIndex = station->m_rateIndex;
<     }
<   return WifiTxVector (mode, station->m_powerLevel, GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, station->m_currentRate), station->m_currentPower, GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
343c311
<   /// \todo we could/should implement the ARF algorithm for
---
>   /// \todo we could/should implement the Arf algorithm for
345,346c313,314
<   ParfWifiRemoteStation *station = static_cast<ParfWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   ParfWifiRemoteStation *station = (ParfWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
348a317
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
352d320
<   WifiMode mode;
355c323
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
359c327
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (station, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
361d328
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
362a330,356
> }
> 
> bool
> ParfWifiManager::IsLowLatency (void) const
> {
>   NS_LOG_FUNCTION (this);
>   return true;
> }
> 
> void
> ParfWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> ParfWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/parf-wifi-manager.h ../../ns-3-dev/src/wifi/model/parf-wifi-manager.h
39,41c39,41
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
---
>  * This RAA does not support HT or VHT modes and will error exit
>  * if the user tries to configure this RAA with a Wi-Fi MAC that
>  * has VhtSupported or HtSupported set.
55c55,57
<   void SetupPhy (const Ptr<WifiPhy> phy);
---
>   virtual void SetupPhy (Ptr<WifiPhy> phy);
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
59,73c61,75
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
---
>   //overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool IsLowLatency (void) const;
83c85
< 
---
>   
89c91
<   uint8_t m_minPower;
---
>   uint32_t m_minPower;
94c96
<   uint8_t m_maxPower;
---
>   uint32_t m_maxPower;
97c99
<    * The trace source fired when the transmission power changes.
---
>    * The trace source fired when the transmission power changes....
99c101
<   TracedCallback<double, double, Mac48Address> m_powerChange;
---
>   TracedCallback<uint8_t, Mac48Address> m_powerChange;
103c105,106
<   TracedCallback<DataRate, DataRate, Mac48Address> m_rateChange;
---
>   TracedCallback<uint32_t, Mac48Address> m_rateChange;
> 
Only in ../../NS3-WiGig/src/wifi/model: preamble-detection-model.cc
Only in ../../NS3-WiGig/src/wifi/model: preamble-detection-model.h
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-delay.cc
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-delay.h
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-engine.cc
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-engine.h
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-loss.cc
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-loss.h
diff ../../NS3-WiGig/src/wifi/model/qos-blocked-destinations.cc ../../ns-3-dev/src/wifi/model/qos-blocked-destinations.cc
22d21
< #include "ns3/mac48-address.h"
38c37,44
<   return m_blockedQosPackets.find ({dest, tid}) != m_blockedQosPackets.end ();
---
>   for (BlockedPacketsCI i = m_blockedQosPackets.begin (); i != m_blockedQosPackets.end (); i++)
>     {
>       if (i->first == dest && i->second == tid)
>         {
>           return true;
>         }
>     }
>   return false;
44c50,53
<   m_blockedQosPackets.insert ({dest, tid});
---
>   if (!IsBlocked (dest, tid))
>     {
>       m_blockedQosPackets.push_back (std::make_pair (dest, tid));
>     }
50c59,66
<   m_blockedQosPackets.erase ({dest, tid});
---
>   for (BlockedPacketsI i = m_blockedQosPackets.begin (); i != m_blockedQosPackets.end (); i++)
>     {
>       if (i->first == dest && i->second == tid)
>         {
>           m_blockedQosPackets.erase (i);
>           break;
>         }
>     }
diff ../../NS3-WiGig/src/wifi/model/qos-blocked-destinations.h ../../ns-3-dev/src/wifi/model/qos-blocked-destinations.h
25,26c25,26
< #include <set>
< #include "ns3/simple-ref-count.h"
---
> #include <list>
> #include "ns3/mac48-address.h"
30,31d29
< class Mac48Address;
< 
34c32
<  * for a BlockAck response.
---
>  * for a block ACK response.
36c34
< class QosBlockedDestinations : public SimpleRefCount<QosBlockedDestinations>
---
> class QosBlockedDestinations
44c42
<    * BlockAck response).
---
>    * block ACK response).
46,47c44,45
<    * \param dest the destination MAC address
<    * \param tid the TID
---
>    * \param dest
>    * \param tid
51c49
<    * Un-block the given destination address and TID (e.g. BlockAck
---
>    * Un-block the given destination address and TID (e.g. block ACK
54,55c52,53
<    * \param dest the destination MAC address
<    * \param tid the TID
---
>    * \param dest
>    * \param tid
60c58
<    * from sending (e.g. pending BlockAck response).
---
>    * from sending (e.g. pending block ACK response).
62,63c60,61
<    * \param dest the destination MAC address
<    * \param tid the TID
---
>    * \param dest
>    * \param tid
72c70,82
<   std::set<std::pair<Mac48Address, uint8_t>> m_blockedQosPackets; ///< blocked QoS packets
---
>   /**
>    * typedef for a list of <Mac48Address, TID> pair.
>    */
>   typedef std::list<std::pair<Mac48Address, uint8_t> > BlockedPackets;
>   /**
>    * typedef for an iterator of BlockedPackets
>    */
>   typedef std::list<std::pair<Mac48Address, uint8_t> >::iterator BlockedPacketsI;
>   /**
>    * typedef for a constan iterator of BlockedPackets
>    */
>   typedef std::list<std::pair<Mac48Address, uint8_t> >::const_iterator BlockedPacketsCI;
>   BlockedPackets m_blockedQosPackets;
Only in ../../NS3-WiGig/src/wifi/model: qos-txop.cc
Only in ../../NS3-WiGig/src/wifi/model: qos-txop.h
diff ../../NS3-WiGig/src/wifi/model/qos-utils.cc ../../ns-3-dev/src/wifi/model/qos-utils.cc
22,23d21
< #include "ns3/socket.h"
< #include "ns3/queue-item.h"
25,27c23
< #include "wifi-mac-header.h"
< #include "mgt-headers.h"
< #include "ctrl-headers.h"
---
> #include "ns3/socket.h"
34c30
<   NS_ASSERT_MSG (tid < 8, "Tid " << +tid << " out of range");
---
>   NS_ASSERT_MSG (tid < 8, "Tid " << (uint16_t) tid << " out of range");
38d33
<     case 3:
41a37,38
>       return AC_BK;
>       break;
44a42,44
>     case 3:
>       return AC_BE;
>       break;
45a46,47
>       return AC_VI;
>       break;
49a52,53
>       return AC_VO;
>       break;
91,185d94
< 
< /**
<  *  \brief Extraction operator for TypeId
<  *  \param [in] packet is the packet
<  *  \param [in] hdr is Wifi MAC header
<  *  \returns the TypeId of the MAC header
<  */
< uint8_t
< GetTid (Ptr<const Packet> packet, const WifiMacHeader hdr)
< {
<   NS_ASSERT (hdr.IsQosData () || packet != 0);
<   if (hdr.IsQosData ())
<     {
<       return hdr.GetQosTid ();
<     }
<   else if (hdr.IsBlockAckReq ())
<     {
<       CtrlBAckRequestHeader baReqHdr;
<       packet->PeekHeader (baReqHdr);
<       return baReqHdr.GetTidInfo ();
<     }
<   else if (hdr.IsBlockAck ())
<     {
<       CtrlBAckResponseHeader baRespHdr;
<       packet->PeekHeader (baRespHdr);
<       return baRespHdr.GetTidInfo ();
<     }
<   else if (hdr.IsMgt () && hdr.IsAction ())
<     {
<       Ptr<Packet> pkt = packet->Copy ();
<       WifiActionHeader actionHdr;
<       pkt->RemoveHeader (actionHdr);
< 
<       if (actionHdr.GetCategory () == WifiActionHeader::BLOCK_ACK)
<         {
<           switch (actionHdr.GetAction ().blockAck)
<             {
<             case WifiActionHeader::BLOCK_ACK_ADDBA_REQUEST:
<               {
<                 MgtAddBaRequestHeader reqHdr;
<                 pkt->RemoveHeader (reqHdr);
<                 return reqHdr.GetTid ();
<               }
<             case WifiActionHeader::BLOCK_ACK_ADDBA_RESPONSE:
<               {
<                 MgtAddBaResponseHeader respHdr;
<                 pkt->RemoveHeader (respHdr);
<                 return respHdr.GetTid ();
<               }
<             case WifiActionHeader::BLOCK_ACK_DELBA:
<               {
<                 MgtDelBaHeader delHdr;
<                 pkt->RemoveHeader (delHdr);
<                 return delHdr.GetTid ();
<               }
<             default:
<               {
<                 NS_FATAL_ERROR ("Cannot extract Traffic ID from this BA action frame");
<               }
<             }
<         }
<       else
<         {
<           NS_FATAL_ERROR ("Cannot extract Traffic ID from this action frame");
<         }
<     }
<   else
<     {
<       NS_FATAL_ERROR ("Packet has no Traffic ID");
<     }
< }
< 
< uint8_t
< SelectQueueByDSField (Ptr<QueueItem> item)
< {
<   uint8_t dscp, priority = 0;
<   if (item->GetUint8Value (QueueItem::IP_DSFIELD, dscp))
<     {
<       // if the QoS map element is implemented, it should be used here
<       // to set the priority.
<       // User priority is set to the three most significant bits of the DS field
<       priority = dscp >> 5;
<     }
< 
<   // replace the priority tag
<   SocketPriorityTag priorityTag;
<   priorityTag.SetPriority (priority);
<   item->GetPacket ()->ReplacePacketTag (priorityTag);
< 
<   // if the admission control were implemented, here we should check whether
<   // the access category assigned to the packet should be downgraded
< 
<   return static_cast<uint8_t> (QosUtilsMapTidToAc (priority));
< }
< 
diff ../../NS3-WiGig/src/wifi/model/qos-utils.h ../../ns-3-dev/src/wifi/model/qos-utils.h
23a24
> #include "ns3/uinteger.h"
24a26
> #include "ns3/packet.h"
28,31d29
< class Packet;
< class WifiMacHeader;
< class QueueItem;
< 
65c63
<  * If a QoS tag is attached to the packet, returns a value < 8.
---
>  * If a qos tag is attached to the packet, returns a value < 8.
82c80
<  * \param endSequence the sequence number ending the acknowledgment window
---
>  * \param endSequence
126,181d123
< 
< /**
<  * \ingroup wifi
<  * Next function is useful to get traffic id of different packet types.
<  *
<  * \param packet packet to check
<  * \param hdr 802.11 header for packet to check
<  *
<  * Returns TID of different packet types
<  */
< uint8_t GetTid (Ptr<const Packet> packet, const WifiMacHeader hdr);
< 
< /**
<  * \ingroup wifi
<  * \brief Determine the TX queue for a given packet
<  * \param item the packet
<  * \returns the access category
<  *
<  * Modeled after the Linux function ieee80211_select_queue (net/mac80211/wme.c).
<  * A SocketPriority tag is attached to the packet (or the existing one is
<  * replaced) to carry the user priority, which is set to the three most
<  * significant bits of the DS field (TOS field in case of IPv4 and Traffic
<  * Class field in case of IPv6). The Access Category corresponding to the
<  * user priority according to the QosUtilsMapTidToAc function is returned.
<  *
<  * The following table shows the mapping for the Diffserv Per Hop Behaviors.
<  *
<  * PHB  | TOS (binary) | UP  | Access Category
<  * -----|--------------|-----|-----------------
<  * EF   |   101110xx   |  5  |     AC_VI
<  * AF11 |   001010xx   |  1  |     AC_BK
<  * AF21 |   010010xx   |  2  |     AC_BK
<  * AF31 |   011010xx   |  3  |     AC_BE
<  * AF41 |   100010xx   |  4  |     AC_VI
<  * AF12 |   001100xx   |  1  |     AC_BK
<  * AF22 |   010100xx   |  2  |     AC_BK
<  * AF32 |   011100xx   |  3  |     AC_BE
<  * AF42 |   100100xx   |  4  |     AC_VI
<  * AF13 |   001110xx   |  1  |     AC_BK
<  * AF23 |   010110xx   |  2  |     AC_BK
<  * AF33 |   011110xx   |  3  |     AC_BE
<  * AF43 |   100110xx   |  4  |     AC_VI
<  * CS0  |   000000xx   |  0  |     AC_BE
<  * CS1  |   001000xx   |  1  |     AC_BK
<  * CS2  |   010000xx   |  2  |     AC_BK
<  * CS3  |   011000xx   |  3  |     AC_BE
<  * CS4  |   100000xx   |  4  |     AC_VI
<  * CS5  |   101000xx   |  5  |     AC_VI
<  * CS6  |   110000xx   |  6  |     AC_VO
<  * CS7  |   111000xx   |  7  |     AC_VO
<  *
<  * This method is called by the traffic control layer before enqueuing a
<  * packet in the queue disc, if a queue disc is installed on the outgoing
<  * device, or passing a packet to the device, otherwise.
<  */
< uint8_t SelectQueueByDSField (Ptr<QueueItem> item);
Only in ../../ns-3-dev/src/wifi/model: random-stream.cc
Only in ../../ns-3-dev/src/wifi/model: random-stream.h
diff ../../NS3-WiGig/src/wifi/model/regular-wifi-mac.cc ../../ns-3-dev/src/wifi/model/regular-wifi-mac.cc
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
19,20c18
<  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
22a21
> #include "regular-wifi-mac.h"
23a23
> #include "ns3/boolean.h"
25,27c25,26
< #include "ns3/packet.h"
< #include "regular-wifi-mac.h"
< #include "wifi-phy.h"
---
> #include "ns3/uinteger.h"
> #include "ns3/trace-source-accessor.h"
31,44c30,34
< #include "channel-access-manager.h"
< #include "msdu-aggregator.h"
< #include "mpdu-aggregator.h"
< #include "wifi-utils.h"
< #include "mgt-headers.h"
< #include "ns3/simulator.h"
< #include "amsdu-subframe-header.h"
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "vht-configuration.h"
< #include "he-configuration.h"
< #include <algorithm>
< #include <cmath>
< #include "extended-capabilities.h"
---
> #include "dcf.h"
> #include "dcf-manager.h"
> #include "wifi-phy.h"
> #include "msdu-standard-aggregator.h"
> #include "mpdu-standard-aggregator.h"
52,59c42,46
< RegularWifiMac::RegularWifiMac ()
<   : //// WIGIG ////
<     m_dmgSupported (0),
<     m_edmgSupported (0),
<     //// WIGIG ////
<     m_qosSupported (0),
<     m_erpSupported (0),
<     m_dsssSupported (0)
---
> RegularWifiMac::RegularWifiMac () :
>   m_htSupported (0),
>   m_vhtSupported (0),
>   m_erpSupported (0),
>   m_dsssSupported (0)
62c49
<   m_rxMiddle = Create<MacRxMiddle> ();
---
>   m_rxMiddle = new MacRxMiddle ();
65c52
<   m_txMiddle = Create<MacTxMiddle> ();
---
>   m_txMiddle = new MacTxMiddle ();
69d55
<   m_low->SetMac (this);
71,72c57,58
<   m_channelAccessManager = CreateObject<ChannelAccessManager> ();
<   m_channelAccessManager->SetupLow (m_low);
---
>   m_dcfManager = new DcfManager ();
>   m_dcfManager->SetupLowListener (m_low);
74,84c60,65
<   m_txop = CreateObject<Txop> ();
<   m_txop->SetMacLow (m_low);
<   m_txop->SetChannelAccessManager (m_channelAccessManager);
<   m_txop->SetTxMiddle (m_txMiddle);
<   m_txop->SetTxOkCallback (MakeCallback (&RegularWifiMac::TxOk, this));
<   m_txop->SetTxFailedCallback (MakeCallback (&RegularWifiMac::TxFailed, this));
<   m_txop->SetTxDroppedCallback (MakeCallback (&RegularWifiMac::NotifyTxDrop, this));
< 
<   //// WIGIG ////
<   m_fstId = 0;      /* Fast Session ID. */
<   //// WIGIG ////
---
>   m_dca = CreateObject<DcaTxop> ();
>   m_dca->SetLow (m_low);
>   m_dca->SetManager (m_dcfManager);
>   m_dca->SetTxMiddle (m_txMiddle);
>   m_dca->SetTxOkCallback (MakeCallback (&RegularWifiMac::TxOk, this));
>   m_dca->SetTxFailedCallback (MakeCallback (&RegularWifiMac::TxFailed, this));
104c85
<   m_txop->Initialize ();
---
>   m_dca->Initialize ();
106c87
<   for (EdcaQueues::const_iterator i = m_edca.begin (); i != m_edca.end (); ++i)
---
>   for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
116c97
< 
---
>   delete m_rxMiddle;
117a99,100
> 
>   delete m_txMiddle;
119a103,105
>   delete m_dcfManager;
>   m_dcfManager = 0;
> 
126,127c112,113
<   m_txop->Dispose ();
<   m_txop = 0;
---
>   m_dca->Dispose ();
>   m_dca = 0;
131d116
<       i->second->Dispose ();
134,158d118
< 
<   m_channelAccessManager->Dispose ();
<   m_channelAccessManager = 0;
<   
<   WifiMac::DoDispose ();
< }
< 
< //// WIGIG ////
< void
< RegularWifiMac::MacTxOk (Mac48Address address)
< {
<   NS_LOG_FUNCTION (this << address);
<   FstSessionMap::iterator it = m_fstSessionMap.find (address);
<   if (it != m_fstSessionMap.end ())
<     {
<       FstSession *fstSession = static_cast<FstSession*> (&it->second);
<       if ((fstSession->CurrentState == FST_SETUP_COMPLETION_STATE) && fstSession->LinkLossCountDownEvent.IsRunning ())
<         {
<           NS_LOG_INFO ("Transmitted MPDU Successfully, so reset Link Count Down Timer");
<           fstSession->LinkLossCountDownEvent.Cancel ();
<           fstSession->LinkLossCountDownEvent = Simulator::Schedule (MicroSeconds (fstSession->LLT * 32),
<                                                                     &RegularWifiMac::ChangeBand, this,
<                                                                     address, fstSession->NewBandId, fstSession->IsInitiator);
<         }
<     }
162,182c122
< RegularWifiMac::MacRxOk (Mac48Address address)
< {
<   NS_LOG_FUNCTION (this << address);
<   FstSessionMap::iterator it = m_fstSessionMap.find (address);
<   if (it != m_fstSessionMap.end ())
<     {
<       FstSession *fstSession = static_cast<FstSession*> (&it->second);
<       if ((fstSession->CurrentState == FST_SETUP_COMPLETION_STATE) && fstSession->LinkLossCountDownEvent.IsRunning ())
<         {
<           NS_LOG_INFO ("Received MPDU Successfully, so reset Link Count Down Timer");
<           fstSession->LinkLossCountDownEvent.Cancel ();
<           fstSession->LinkLossCountDownEvent = Simulator::Schedule (MicroSeconds (fstSession->LLT * 32),
<                                                                     &RegularWifiMac::ChangeBand, this,
<                                                                     address, fstSession->NewBandId, fstSession->IsInitiator);
<         }
<     }
< }
< //// WIGIG ////
< 
< void
< RegularWifiMac::SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> stationManager)
---
> RegularWifiMac::SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> stationManager)
185a126,128
>   m_stationManager->SetHtSupported (GetHtSupported ());
>   m_stationManager->SetVhtSupported (GetVhtSupported ());
>   m_low->SetWifiRemoteStationManager (stationManager);
187,193c130
<   //// WIGIG ////
<   /* Connect trace source for FST */
<   m_stationManager->RegisterTxOkCallback (MakeCallback (&RegularWifiMac::MacTxOk, this));
<   m_stationManager->RegisterRxOkCallback (MakeCallback (&RegularWifiMac::MacRxOk, this));
<   m_stationManager->SetDmgSupported (GetDmgSupported ());
<   m_stationManager->SetEdmgSupported (GetEdmgSupported ());
<   //// WIGIG ////
---
>   m_dca->SetWifiRemoteStationManager (stationManager);
195,197c132
<   m_low->SetWifiRemoteStationManager (stationManager);
<   m_txop->SetWifiRemoteStationManager (stationManager);
<   for (EdcaQueues::const_iterator i = m_edca.begin (); i != m_edca.end (); ++i)
---
>   for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
209,220c144
< Ptr<ExtendedCapabilities>
< RegularWifiMac::GetExtendedCapabilities (void) const
< {
<   NS_LOG_FUNCTION (this);
<   Ptr<ExtendedCapabilities> capabilities = Create<ExtendedCapabilities> ();
<   capabilities->SetHtSupported (GetHtSupported ());
<   capabilities->SetVhtSupported (GetVhtSupported ());
<   //TODO: to be completed
<   return capabilities;
< }
< 
< Ptr<HtCapabilities>
---
> HtCapabilities
223,254c147,158
<   NS_LOG_FUNCTION (this);
<   Ptr<HtCapabilities> capabilities = Create<HtCapabilities> ();
<   if (GetHtSupported ())
<     {
<       Ptr<HtConfiguration> htConfiguration = GetHtConfiguration ();
<       bool greenfieldSupported = htConfiguration->GetGreenfieldSupported ();
<       bool sgiSupported = htConfiguration->GetShortGuardIntervalSupported ();
<       capabilities->SetHtSupported (1);
<       capabilities->SetLdpc (0);
<       capabilities->SetSupportedChannelWidth (m_phy->GetChannelWidth () >= 40);
<       capabilities->SetShortGuardInterval20 (sgiSupported);
<       capabilities->SetShortGuardInterval40 (m_phy->GetChannelWidth () >= 40 && sgiSupported);
<       capabilities->SetGreenfield (greenfieldSupported);
<       // Set Maximum A-MSDU Length subfield
<       uint16_t maxAmsduSize = std::max ({m_voMaxAmsduSize, m_viMaxAmsduSize,
<                                          m_beMaxAmsduSize, m_bkMaxAmsduSize});
<       if (maxAmsduSize <= 3839)
<         {
<           capabilities->SetMaxAmsduLength (3839);
<         }
<       else
<         {
<           capabilities->SetMaxAmsduLength (7935);
<         }
<       uint32_t maxAmpduLength = std::max ({m_voMaxAmpduSize, m_viMaxAmpduSize,
<                                            m_beMaxAmpduSize, m_bkMaxAmpduSize});
<       // round to the next power of two minus one
<       maxAmpduLength = (1ul << static_cast<uint32_t> (std::ceil (std::log2 (maxAmpduLength + 1)))) - 1;
<       // The maximum A-MPDU length in HT capabilities elements ranges from 2^13-1 to 2^16-1
<       capabilities->SetMaxAmpduLength (std::min (std::max (maxAmpduLength, 8191u), 65535u));
< 
<       capabilities->SetLSigProtectionSupport (!greenfieldSupported);
---
>   HtCapabilities capabilities;
>   capabilities.SetHtSupported (1);
>   if (m_htSupported)
>     {
>       capabilities.SetLdpc (m_phy->GetLdpc ());
>       capabilities.SetSupportedChannelWidth (m_phy->GetChannelWidth () == 40);
>       capabilities.SetShortGuardInterval20 (m_phy->GetGuardInterval ());
>       capabilities.SetShortGuardInterval40 (m_phy->GetChannelWidth () == 40 && m_phy->GetGuardInterval ());
>       capabilities.SetGreenfield (m_phy->GetGreenfield ());
>       capabilities.SetMaxAmsduLength (1); //hardcoded for now (TBD)
>       capabilities.SetLSigProtectionSupport (!m_phy->GetGreenfield ());
>       capabilities.SetMaxAmpduLength (3); //hardcoded for now (TBD)
263c167
<           capabilities->SetRxMcsBitmask (mcs.GetMcsValue ());
---
>           capabilities.SetRxMcsBitmask (mcs.GetMcsValue ());
266,267c170
<           uint64_t dataRate = mcs.GetDataRate (m_phy->GetChannelWidth (), sgiSupported ? 400 : 800, nss);
<           if (dataRate > maxSupportedRate)
---
>           if (mcs.GetDataRate (m_phy->GetChannelWidth (), m_phy->GetGuardInterval (), nss) > maxSupportedRate)
269c172
<               maxSupportedRate = dataRate;
---
>               maxSupportedRate = mcs.GetDataRate (m_phy->GetChannelWidth (), m_phy->GetGuardInterval (), nss);
273,278c176,178
<       capabilities->SetRxHighestSupportedDataRate (static_cast<uint16_t> (maxSupportedRate / 1e6)); //in Mbit/s
<       capabilities->SetTxMcsSetDefined (m_phy->GetNMcs () > 0);
<       capabilities->SetTxMaxNSpatialStreams (m_phy->GetMaxSupportedTxSpatialStreams ());
<       //we do not support unequal modulations
<       capabilities->SetTxRxMcsSetUnequal (0);
<       capabilities->SetTxUnequalModulation (0);
---
>       capabilities.SetRxHighestSupportedDataRate (maxSupportedRate / 1e6); //in Mbit/s
>       capabilities.SetTxMcsSetDefined (m_phy->GetNMcs () > 0);
>       capabilities.SetTxMaxNSpatialStreams (m_phy->GetSupportedTxSpatialStreams ());
283c183
< Ptr<VhtCapabilities>
---
> VhtCapabilities
286,288c186,188
<   NS_LOG_FUNCTION (this);
<   Ptr<VhtCapabilities> capabilities = Create<VhtCapabilities> ();
<   if (GetVhtSupported ())
---
>   VhtCapabilities capabilities;
>   capabilities.SetVhtSupported (1);
>   if (m_vhtSupported)
290,293d189
<       Ptr<HtConfiguration> htConfiguration = GetHtConfiguration ();
<       Ptr<VhtConfiguration> vhtConfiguration = GetVhtConfiguration ();
<       bool sgiSupported = htConfiguration->GetShortGuardIntervalSupported ();
<       capabilities->SetVhtSupported (1);
296,311c192
<           capabilities->SetSupportedChannelWidthSet (1);
<         }
<       else
<         {
<           capabilities->SetSupportedChannelWidthSet (0);
<         }
<       // Set Maximum MPDU Length subfield
<       uint16_t maxAmsduSize = std::max ({m_voMaxAmsduSize, m_viMaxAmsduSize,
<                                          m_beMaxAmsduSize, m_bkMaxAmsduSize});
<       if (maxAmsduSize <= 3839)
<         {
<           capabilities->SetMaxMpduLength (3895);
<         }
<       else if (maxAmsduSize <= 7935)
<         {
<           capabilities->SetMaxMpduLength (7991);
---
>           capabilities.SetSupportedChannelWidthSet (1);
315c196
<           capabilities->SetMaxMpduLength (11454);
---
>           capabilities.SetSupportedChannelWidthSet (0);
317,326c198,202
<       uint32_t maxAmpduLength = std::max ({m_voMaxAmpduSize, m_viMaxAmpduSize,
<                                            m_beMaxAmpduSize, m_bkMaxAmpduSize});
<       // round to the next power of two minus one
<       maxAmpduLength = (1ul << static_cast<uint32_t> (std::ceil (std::log2 (maxAmpduLength + 1)))) - 1;
<       // The maximum A-MPDU length in VHT capabilities elements ranges from 2^13-1 to 2^20-1
<       capabilities->SetMaxAmpduLength (std::min (std::max (maxAmpduLength, 8191u), 1048575u));
< 
<       capabilities->SetRxLdpc (0);
<       capabilities->SetShortGuardIntervalFor80Mhz ((m_phy->GetChannelWidth () == 80) && sgiSupported);
<       capabilities->SetShortGuardIntervalFor160Mhz ((m_phy->GetChannelWidth () == 160) && sgiSupported);
---
>       capabilities.SetMaxMpduLength (2); //hardcoded for now (TBD)
>       capabilities.SetRxLdpc (m_phy->GetLdpc ());
>       capabilities.SetShortGuardIntervalFor80Mhz ((m_phy->GetChannelWidth () == 80) && m_phy->GetGuardInterval ());
>       capabilities.SetShortGuardIntervalFor160Mhz ((m_phy->GetChannelWidth () == 160) && m_phy->GetGuardInterval ());
>       capabilities.SetMaxAmpduLengthExponent (7); //hardcoded for now (TBD)
338c214
<       for (uint8_t nss = 1; nss <= m_phy->GetMaxSupportedRxSpatialStreams (); nss++)
---
>       for (uint8_t nss = 1; nss <= m_phy->GetSupportedRxSpatialStreams (); nss++)
340c216
<           capabilities->SetRxMcsMap (maxMcs, nss);
---
>           capabilities.SetRxMcsMap (maxMcs, nss);
342c218
<       for (uint8_t nss = 1; nss <= m_phy->GetMaxSupportedTxSpatialStreams (); nss++)
---
>       for (uint8_t nss = 1; nss <= m_phy->GetSupportedTxSpatialStreams (); nss++)
344c220
<           capabilities->SetTxMcsMap (maxMcs, nss);
---
>           capabilities.SetTxMcsMap (maxMcs, nss);
346,364d221
<       uint64_t maxSupportedRateLGI = 0; //in bit/s
<       for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<         {
<           WifiMode mcs = m_phy->GetMcs (i);
<           if (mcs.GetModulationClass () != WIFI_MOD_CLASS_VHT || !mcs.IsAllowed (m_phy->GetChannelWidth (), 1))
<             {
<               continue;
<             }
<           if (mcs.GetDataRate (m_phy->GetChannelWidth ()) > maxSupportedRateLGI)
<             {
<               maxSupportedRateLGI = mcs.GetDataRate (m_phy->GetChannelWidth ());
<               NS_LOG_DEBUG ("Updating maxSupportedRateLGI to " << maxSupportedRateLGI);
<             }
<         }
<       capabilities->SetRxHighestSupportedLgiDataRate (static_cast<uint16_t> (maxSupportedRateLGI / 1e6)); //in Mbit/s
<       capabilities->SetTxHighestSupportedLgiDataRate (static_cast<uint16_t> (maxSupportedRateLGI / 1e6)); //in Mbit/s
<       //To be filled in once supported
<       capabilities->SetRxStbc (0);
<       capabilities->SetTxStbc (0);
369,370c226,227
< Ptr<HeCapabilities>
< RegularWifiMac::GetHeCapabilities (void) const
---
> void
> RegularWifiMac::SetVoMaxAmsduSize (uint32_t size)
372,408c229,232
<   NS_LOG_FUNCTION (this);
<   Ptr<HeCapabilities> capabilities = Create<HeCapabilities> ();
<   if (GetHeSupported ())
<     {
<       Ptr<HeConfiguration> heConfiguration = GetHeConfiguration ();
<       capabilities->SetHeSupported (1);
<       uint8_t channelWidthSet = 0;
<       if (m_phy->GetChannelWidth () >= 40 && Is2_4Ghz (m_phy->GetFrequency ()))
<         {
<           channelWidthSet |= 0x01;
<         }
<       if (m_phy->GetChannelWidth () >= 80 && Is5Ghz (m_phy->GetFrequency ()))
<         {
<           channelWidthSet |= 0x02;
<         }
<       if (m_phy->GetChannelWidth () >= 160 && Is5Ghz (m_phy->GetFrequency ()))
<         {
<           channelWidthSet |= 0x04;
<         }
<       capabilities->SetChannelWidthSet (channelWidthSet);
<       uint8_t gi = 0;
<       if (heConfiguration->GetGuardInterval () <= NanoSeconds (1600))
<         {
<           //todo: We assume for now that if we support 800ns GI then 1600ns GI is supported as well
<           gi |= 0x01;
<         }
<       if (heConfiguration->GetGuardInterval () == NanoSeconds (800))
<         {
<           gi |= 0x02;
<         }
<       capabilities->SetHeLtfAndGiForHePpdus (gi);
<       uint32_t maxAmpduLength = std::max ({m_voMaxAmpduSize, m_viMaxAmpduSize,
<                                            m_beMaxAmpduSize, m_bkMaxAmpduSize});
<       // round to the next power of two minus one
<       maxAmpduLength = (1ul << static_cast<uint32_t> (std::ceil (std::log2 (maxAmpduLength + 1)))) - 1;
<       // The maximum A-MPDU length in HE capabilities elements ranges from 2^20-1 to 2^23-1
<       capabilities->SetMaxAmpduLength (std::min (std::max (maxAmpduLength, 1048575u), 8388607u));
---
>   NS_LOG_FUNCTION (this << size);
>   m_voMaxAmsduSize = size;
>   ConfigureAggregation ();
> }
410,423c234,287
<       uint8_t maxMcs = 0;
<       for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<         {
<           WifiMode mcs = m_phy->GetMcs (i);
<           if ((mcs.GetModulationClass () == WIFI_MOD_CLASS_HE)
<               && (mcs.GetMcsValue () > maxMcs))
<             {
<               maxMcs = mcs.GetMcsValue ();
<             }
<         }
<       capabilities->SetHighestMcsSupported (maxMcs);
<       capabilities->SetHighestNssSupported (m_phy->GetMaxSupportedTxSpatialStreams ());
<     }
<   return capabilities;
---
> void
> RegularWifiMac::SetViMaxAmsduSize (uint32_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_viMaxAmsduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetBeMaxAmsduSize (uint32_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_beMaxAmsduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetBkMaxAmsduSize (uint32_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_bkMaxAmsduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetVoMaxAmpduSize (uint32_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_voMaxAmpduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetViMaxAmpduSize (uint32_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_viMaxAmpduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetBeMaxAmpduSize (uint32_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_beMaxAmpduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetBkMaxAmpduSize (uint32_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_bkMaxAmpduSize = size;
>   ConfigureAggregation ();
429c293
<   NS_LOG_FUNCTION (this << +threshold);
---
>   NS_LOG_FUNCTION (this << (uint16_t) threshold);
436c300
<   NS_LOG_FUNCTION (this << +threshold);
---
>   NS_LOG_FUNCTION (this << (uint16_t) threshold);
443c307
<   NS_LOG_FUNCTION (this << +threshold);
---
>   NS_LOG_FUNCTION (this << (uint16_t) threshold);
450c314
<   NS_LOG_FUNCTION (this << +threshold);
---
>   NS_LOG_FUNCTION (this << (uint16_t) threshold);
483c347
< RegularWifiMac::SetupEdcaQueue (AcIndex ac)
---
> RegularWifiMac::SetupEdcaQueue (enum AcIndex ac)
491,493c355,357
<   Ptr<QosTxop> edca = CreateObject<QosTxop> ();
<   edca->SetMacLow (m_low);
<   edca->SetChannelAccessManager (m_channelAccessManager);
---
>   Ptr<EdcaTxopN> edca = CreateObject<EdcaTxopN> ();
>   edca->SetLow (m_low);
>   edca->SetManager (m_dcfManager);
497d360
<   edca->SetTxDroppedCallback (MakeCallback (&RegularWifiMac::NotifyTxDrop, this));
508c371
<   for (EdcaQueues::const_iterator i = m_edca.begin (); i != m_edca.end (); ++i)
---
>   for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
512,519d374
<   m_type = type;
< }
< 
< TypeOfStation
< RegularWifiMac::GetTypeOfStation (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return m_type;
522,523c377,378
< Ptr<Txop>
< RegularWifiMac::GetTxop () const
---
> Ptr<DcaTxop>
> RegularWifiMac::GetDcaTxop () const
525c380
<   return m_txop;
---
>   return m_dca;
528c383
< Ptr<QosTxop>
---
> Ptr<EdcaTxopN>
534c389
< Ptr<QosTxop>
---
> Ptr<EdcaTxopN>
540c395
< Ptr<QosTxop>
---
> Ptr<EdcaTxopN>
546c401
< Ptr<QosTxop>
---
> Ptr<EdcaTxopN>
553c408
< RegularWifiMac::SetWifiPhy (const Ptr<WifiPhy> phy)
---
> RegularWifiMac::SetWifiPhy (Ptr<WifiPhy> phy)
557c412
<   m_channelAccessManager->SetupPhyListener (phy);
---
>   m_dcfManager->SetupPhyListener (phy);
573c428
<   m_channelAccessManager->RemovePhyListener (m_phy);
---
>   m_dcfManager->RemovePhyListener (m_phy);
612,617d466
< RegularWifiMac::SetVhtSupported (bool enable)
< {
<   //To be removed once deprecated API is cleaned up
< }
< 
< void
620,664c469,470
<   //To be removed once deprecated API is cleaned up
< }
< 
< void
< RegularWifiMac::SetHeSupported (bool enable)
< {
<   //To be removed once deprecated API is cleaned up
< }
< 
< bool
< RegularWifiMac::GetHtSupported () const
< {
<   if (GetHtConfiguration ())
<     {
<       return true;
<     }
<   return false;
< }
< 
< bool
< RegularWifiMac::GetVhtSupported () const
< {
<   if (GetVhtConfiguration ())
<     {
<       return true;
<     }
<   return false;
< }
< 
< bool
< RegularWifiMac::GetHeSupported () const
< {
<   if (GetHeConfiguration ())
<     {
<       return true;
<     }
<   return false;
< }
< 
< //// WIGIG ////
< void
< RegularWifiMac::SetDmgSupported (bool enable)
< {
<   NS_LOG_FUNCTION (this);
<   m_dmgSupported = enable;
---
>   NS_LOG_FUNCTION (this << enable);
>   m_htSupported = enable;
668d473
<       EnableAggregation ();
670c475
<   else
---
>   if (!enable && !m_vhtSupported)
673a479,482
>   else
>     {
>       EnableAggregation ();
>     }
677c486
< RegularWifiMac::GetDmgSupported (void) const
---
> RegularWifiMac::GetVhtSupported () const
679c488
<   return m_dmgSupported;
---
>   return m_vhtSupported;
683c492
< RegularWifiMac::SetEdmgSupported (bool enable)
---
> RegularWifiMac::SetVhtSupported (bool enable)
685,686c494,495
<   NS_LOG_FUNCTION (this);
<   m_edmgSupported = enable;
---
>   NS_LOG_FUNCTION (this << enable);
>   m_vhtSupported = enable;
690d498
<       EnableAggregation ();
692c500
<   else
---
>   if (!enable && !m_htSupported)
695a504,507
>   else
>     {
>       EnableAggregation ();
>     }
699c511
< RegularWifiMac::GetEdmgSupported (void) const
---
> RegularWifiMac::GetHtSupported () const
701c513
<   return m_edmgSupported;
---
>   return m_htSupported;
703d514
< //// WIGIG ////
741a553,558
> bool
> RegularWifiMac::GetCtsToSelfSupported () const
> {
>   return m_low->GetCtsToSelfSupported ();
> }
> 
746c563
<   m_channelAccessManager->SetSlot (slotTime);
---
>   m_dcfManager->SetSlot (slotTime);
760c577
<   m_channelAccessManager->SetSifs (sifs);
---
>   m_dcfManager->SetSifs (sifs);
774c591
<   m_channelAccessManager->SetEifsNoDifs (eifsNoDifs);
---
>   m_dcfManager->SetEifsNoDifs (eifsNoDifs);
780c597
<   return m_channelAccessManager->GetEifsNoDifs ();
---
>   return m_dcfManager->GetEifsNoDifs ();
822a640,652
> RegularWifiMac::SetCtsTimeout (Time ctsTimeout)
> {
>   NS_LOG_FUNCTION (this << ctsTimeout);
>   m_low->SetCtsTimeout (ctsTimeout);
> }
> 
> Time
> RegularWifiMac::GetCtsTimeout (void) const
> {
>   return m_low->GetCtsTimeout ();
> }
> 
> void
887,892d716
< MacState
< RegularWifiMac::GetMacState (void) const
< {
<   return m_state;
< }
< 
913,944c737
< RegularWifiMac::SetRifsSupported (bool enable)
< {
<   NS_LOG_FUNCTION (this << enable);
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           htConfiguration->SetRifsSupported (enable);
<         }
<     }
<   m_rifsSupported = enable;
< }
< 
< bool
< RegularWifiMac::GetRifsSupported (void) const
< {
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           return htConfiguration->GetRifsSupported ();
<         }
<     }
<   return m_rifsSupported;
< }
< 
< void
< RegularWifiMac::Enqueue (Ptr<Packet> packet,
---
> RegularWifiMac::Enqueue (Ptr<const Packet> packet,
962c755
< RegularWifiMac::ForwardUp (Ptr<const Packet> packet, Mac48Address from, Mac48Address to)
---
> RegularWifiMac::ForwardUp (Ptr<Packet> packet, Mac48Address from, Mac48Address to)
964c757
<   NS_LOG_FUNCTION (this << packet << from << to);
---
>   NS_LOG_FUNCTION (this << packet << from);
968,971d760
< //// WIGIG ////
< /**
<  * Functions for Fast Session Transfer.
<  */
973c762
< RegularWifiMac::SetupFSTSession (Mac48Address staAddress)
---
> RegularWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
975c764
<   NS_LOG_FUNCTION (this << staAddress);
---
>   NS_LOG_FUNCTION (this << packet << hdr);
977,1235d765
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (staAddress);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstSetupRequest requestHdr;
< 
<   /* Generate new FST Session ID */
<   m_fstId++;
< 
<   SessionTransitionElement sessionTransition;
<   Band newBand, oldBand;
<   newBand.Band_ID = Band_4_9GHz;
<   newBand.Setup = 1;
<   newBand.Operation = 1;
<   sessionTransition.SetNewBand (newBand);
<   oldBand.Band_ID = Band_60GHz;
<   oldBand.Setup = 1;
<   oldBand.Operation = 1;
<   sessionTransition.SetOldBand (oldBand);
<   sessionTransition.SetFstsID (m_fstId);
<   sessionTransition.SetSessionControl (SessionType_InfrastructureBSS, false);
< 
<   requestHdr.SetSessionTransition (sessionTransition);
<   requestHdr.SetLlt (m_llt);
<   requestHdr.SetMultiBand (GetMultiBandElement ());
<   requestHdr.SetDialogToken (10);
< 
<   /* We are the initiator of the FST session */
<   FstSession fstSession;
<   fstSession.ID = m_fstId;
<   fstSession.CurrentState = FST_INITIAL_STATE;
<   fstSession.IsInitiator = true;
<   fstSession.NewBandId = Band_4_9GHz;
<   fstSession.LLT = m_llt;
<   m_fstSessionMap[staAddress] = fstSession;
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_SETUP_REQUEST;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (requestHdr);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::SendFstSetupResponse (Mac48Address to, uint8_t token, uint16_t status, SessionTransitionElement sessionTransition)
< {
<   NS_LOG_FUNCTION (this << to << token << status);
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (to);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstSetupResponse responseHdr;
<   responseHdr.SetDialogToken (token);
<   responseHdr.SetStatusCode (status);
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_SETUP_RESPONSE;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (responseHdr);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::SendFstAckRequest (Mac48Address to, uint8_t dialog, uint32_t fstsID)
< {
<   NS_LOG_FUNCTION (this << to << dialog);
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (to);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstAckResponse requestHdr;
<   requestHdr.SetDialogToken (dialog);
<   requestHdr.SetFstsID (fstsID);
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_ACK_REQUEST;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (requestHdr);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::SendFstAckResponse (Mac48Address to, uint8_t dialog, uint32_t fstsID)
< {
<   NS_LOG_FUNCTION (this << to << dialog);
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (to);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstAckResponse responseHdr;
<   responseHdr.SetDialogToken (dialog);
<   responseHdr.SetFstsID (fstsID);
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_ACK_RESPONSE;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (responseHdr);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::SendFstTearDownFrame (Mac48Address to)
< {
<   NS_LOG_FUNCTION (this << to);
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (to);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstTearDown frame;
<   frame.SetFstsID (0);
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_TEAR_DOWN;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (frame);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::NotifyBandChanged (enum WifiPhyStandard, Mac48Address address, bool isInitiator)
< {
<   NS_LOG_FUNCTION (this << address << isInitiator);
<   /* If we are the initiator, we send FST Ack Request in the new band */
<   if (isInitiator)
<     {
<       /* We transmit an FST ACK Request in the new frequency band */
<       FstSession *fstSession = &m_fstSessionMap[address];
<       SendFstAckRequest (address, 0, fstSession->ID);
<     }
< }
< 
< void
< RegularWifiMac::TxOk (Ptr<const Packet> currentPacket, const WifiMacHeader &hdr)
< {
<   NS_LOG_FUNCTION (this << hdr);
<   if (hdr.IsAction ())
<     {
<       WifiActionHeader actionHdr;
<       Ptr<Packet> packet = currentPacket->Copy ();
<       packet->RemoveHeader (actionHdr);
< 
<       if (actionHdr.GetCategory () == WifiActionHeader::FST)
<         {
<           switch (actionHdr.GetAction ().fstAction)
<             {
<             case WifiActionHeader::FST_SETUP_RESPONSE:
<               {
<                 NS_LOG_LOGIC ("FST Responder: Received ACK for FST Response, so transit to FST_SETUP_COMPLETION_STATE");
<                 FstSession *fstSession = &m_fstSessionMap[hdr.GetAddr1 ()];
<                 fstSession->CurrentState = FST_SETUP_COMPLETION_STATE;
<                 /* We are the responder of the FST session and we got ACK for FST Setup Response */          
<                 if (fstSession->LLT == 0)
<                   {
<                     NS_LOG_LOGIC ("FST Responder: LLT=0, so transit to FST_TRANSITION_DONE_STATE");
<                     fstSession->CurrentState = FST_TRANSITION_DONE_STATE;
<                     ChangeBand (hdr.GetAddr1 (), fstSession->NewBandId, false);
<                   }
<                 else
<                   {
<                     NS_LOG_LOGIC ("FST Responder: LLT>0, so start Link Loss Countdown");
<                     /* Initiate a Link Loss Timer */
<                     fstSession->LinkLossCountDownEvent = Simulator::Schedule (MicroSeconds (fstSession->LLT * 32),
<                                                                               &RegularWifiMac::ChangeBand, this,
<                                                                               hdr.GetAddr1 (), fstSession->NewBandId, false);
<                   }
<                 return;
<               }
<             case WifiActionHeader::FST_ACK_RESPONSE:
<               {
<                 /* We are the Responder of the FST session and we got ACK for FST ACK Response */
<                 NS_LOG_LOGIC ("FST Responder: Transmitted FST ACK Response successfully, so transit to FST_TRANSITION_CONFIRMED_STATE");
<                 FstSession *fstSession = &m_fstSessionMap[hdr.GetAddr1 ()];
<                 fstSession->CurrentState = FST_TRANSITION_CONFIRMED_STATE;
<                 return;
<               }
<             default:
<               break;
<             }
<         }
<     }
<   m_txOkCallback (hdr);
< }
< 
< void
< RegularWifiMac::ChangeBand (Mac48Address peerStation, BandID bandId, bool isInitiator)
< {
<   NS_LOG_FUNCTION (this << peerStation << bandId << isInitiator);
<   if (bandId == Band_60GHz)
<     {
<       m_bandChangedCallback (WIFI_PHY_STANDARD_80211ad, peerStation, isInitiator);
<     }
<   else if (bandId == Band_4_9GHz)
<     {
<       m_bandChangedCallback (WIFI_PHY_STANDARD_80211n_5GHZ, peerStation, isInitiator);
<     }
<   else if (bandId == Band_2_4GHz)
<     {
<       m_bandChangedCallback (WIFI_PHY_STANDARD_80211n_2_4GHZ, peerStation, isInitiator);
<     }
< }
< //// WIGIG ////
< 
< void
< RegularWifiMac::Receive (Ptr<WifiMacQueueItem> mpdu)
< {
<   NS_LOG_FUNCTION (this << *mpdu);
< 
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
<   Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
1321,1413d850
< 
<           //// WIGIG ////
< 
<           /* Fast Session Transfer */
<           case WifiActionHeader::FST:
<             switch (actionHdr.GetAction ().fstAction)
<               {
<               case WifiActionHeader::FST_SETUP_REQUEST:
<                 {
<                   ExtFstSetupRequest requestHdr;
<                   packet->RemoveHeader (requestHdr);
<                   /* We are the responder of the FST, create new entry for FST Session */
<                   FstSession fstSession;
<                   fstSession.ID = requestHdr.GetSessionTransition ().GetFstsID ();
<                   fstSession.CurrentState = FST_INITIAL_STATE;
<                   fstSession.IsInitiator = false;
<                   fstSession.NewBandId = static_cast<BandID> (requestHdr.GetSessionTransition ().GetNewBand ().Band_ID);
<                   fstSession.LLT = requestHdr.GetLlt ();
<                   m_fstSessionMap[hdr->GetAddr2 ()] = fstSession;
<                   NS_LOG_LOGIC ("FST Responder: Received FST Setup Request with LLT=" << m_llt);
<                   /* Send FST Response to the Initiator */
<                   SendFstSetupResponse (hdr->GetAddr2 (), requestHdr.GetDialogToken (), 0, requestHdr.GetSessionTransition ());
<                   return;
<                 }
<               case WifiActionHeader::FST_SETUP_RESPONSE:
<                 {
<                   ExtFstSetupResponse responseHdr;
<                   packet->RemoveHeader (responseHdr);
<                   /* We are the initiator of the FST */
<                   if (responseHdr.GetStatusCode () == 0)
<                     {
<                       /* Move the Initiator to the Setup Completion State */
<                       NS_LOG_LOGIC ("FST Initiator: Received FST Setup Response with Status=0, so transit to FST_SETUP_COMPLETION_STATE");
<                       FstSession *fstSession = &m_fstSessionMap[hdr->GetAddr2 ()];
<                       fstSession->CurrentState = FST_SETUP_COMPLETION_STATE;
<                       if (fstSession->LLT == 0)
<                         {
<                           NS_LOG_LOGIC ("FST Initiator: Received FST Setup Response with LLT=0, so transit to FST_TRANSITION_DONE_STATE");
<                           fstSession->CurrentState = FST_TRANSITION_DONE_STATE;
<                           /* Optionally transmit Broadcast FST Setup Response */
< 
<                           /* Check the new band */
<                           ChangeBand (hdr->GetAddr2 (), fstSession->NewBandId, true);
<                         }
<                       else
<                         {
<                           NS_LOG_LOGIC ("FST Initiator: Received FST Setup Response with LLT>0, so Initiate Link Loss Countdown");
<                           /* Initiate a Link Loss Timer */
<                           fstSession->LinkLossCountDownEvent = Simulator::Schedule (MicroSeconds (fstSession->LLT * 32),
<                                                                                     &RegularWifiMac::ChangeBand, this,
<                                                                                     hdr->GetAddr2 (), fstSession->NewBandId, true);
<                         }
<                     }
<                   else
<                     {
<                       NS_LOG_DEBUG ("FST Failed with " << hdr->GetAddr2 ());
<                     }
<                   return;
<                 }
<               case WifiActionHeader::FST_TEAR_DOWN:
<                 {
<                   ExtFstTearDown teardownHdr;
<                   packet->RemoveHeader (teardownHdr);
<                   FstSession *fstSession = &m_fstSessionMap[hdr->GetAddr2 ()];
<                   fstSession->CurrentState = FST_INITIAL_STATE;
<                   NS_LOG_DEBUG ("FST session with ID= " << teardownHdr.GetFstsID ()<< "is terminated");
<                   return;
<                 }
<               case WifiActionHeader::FST_ACK_REQUEST:
<                 {
<                   ExtFstAckRequest requestHdr;
<                   packet->RemoveHeader (requestHdr);
<                   SendFstAckResponse (hdr->GetAddr2 (), requestHdr.GetDialogToken (), requestHdr.GetFstsID ());
<                   NS_LOG_LOGIC ("FST Responder: Received FST ACK Request for FSTS ID=" << requestHdr.GetFstsID ()
<                                 << " so transmit FST ACK Response");
<                   return;
<                 }
<               case WifiActionHeader::FST_ACK_RESPONSE:
<                 {
<                   ExtFstAckResponse responseHdr;
<                   packet->RemoveHeader (responseHdr);
<                   /* We are the initiator, Get FST Session */
<                   FstSession *fstSession = &m_fstSessionMap[hdr->GetAddr2 ()];
<                   fstSession->CurrentState = FST_TRANSITION_CONFIRMED_STATE;
<                   NS_LOG_LOGIC ("FST Initiator: Received FST ACK Response for FSTS ID=" << responseHdr.GetFstsID ()
<                                 << " so transit to FST_TRANSITION_CONFIRMED_STATE");
<                   return;
<                 }
<               default:
<                 NS_FATAL_ERROR ("Unsupported Action field in Block Ack Action frame");
<                 return;
<               }
< 		//// WIGIG ////
1423c860,861
< RegularWifiMac::DeaggregateAmsduAndForward (Ptr<WifiMacQueueItem> mpdu)
---
> RegularWifiMac::DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket,
>                                             const WifiMacHeader *hdr)
1425,1426c863,867
<   NS_LOG_FUNCTION (this << *mpdu);
<   for (auto& msduPair : *PeekPointer (mpdu))
---
>   MsduAggregator::DeaggregatedMsdus packets =
>     MsduAggregator::Deaggregate (aggregatedPacket);
> 
>   for (MsduAggregator::DeaggregatedMsdusCI i = packets.begin ();
>        i != packets.end (); ++i)
1428,1429c869,870
<       ForwardUp (msduPair.first, msduPair.second.GetSourceAddr (),
<                  msduPair.second.GetDestinationAddr ());
---
>       ForwardUp ((*i).first, (*i).second.GetSourceAddr (),
>                  (*i).second.GetDestinationAddr ());
1439c880
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
---
>   hdr.SetAction ();
1442c883
<   hdr.SetAddr3 (GetBssid ());
---
>   hdr.SetAddr3 (GetAddress ());
1445d885
<   hdr.SetNoOrder ();
1463,1481c903,909
< 
<   //// WIGIG ////
<   if (m_stationManager->HasEdmgSupported ())
<     {
<       respHdr.SetBufferSize (1023);
<     }
<   else
<   //// WIGIG ////
<     {
<       Ptr<HeConfiguration> heConfiguration = GetHeConfiguration ();
<       if (heConfiguration && heConfiguration->GetMpduBufferSize () > 64)
<         {
<           respHdr.SetBufferSize (255);
<         }
<       else
<         {
<           respHdr.SetBufferSize (63);
<         }
<     }
---
>   //For now there's not no control about limit of reception. We
>   //assume that receiver has no limit on reception. However we assume
>   //that a receiver sets a bufferSize in order to satisfy next
>   //equation: (bufferSize + 1) % 16 = 0 So if a recipient is able to
>   //buffer a packet, it should be also able to buffer all possible
>   //packet's fragments. See section 7.3.1.14 in IEEE802.11e for more details.
>   respHdr.SetBufferSize (1023);
1521,1522c949
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Not used anymore")
---
>                    MakeBooleanChecker ())
1528,1567c955
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Not used anymore")
<     .AddAttribute ("HeSupported",
<                    "This Boolean attribute is set to enable 802.11ax support at this STA.",
<                    BooleanValue (false),
<                    MakeBooleanAccessor (&RegularWifiMac::SetHeSupported,
<                                         &RegularWifiMac::GetHeSupported),
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Not used anymore")
< 
<   	//// WIGIG ////
<     .AddAttribute ("DmgSupported",
<                    "This Boolean attribute is set to enable 802.11ad support at this STA",
<                     BooleanValue (false),
<                     MakeBooleanAccessor (&RegularWifiMac::SetDmgSupported,
<                                          &RegularWifiMac::GetDmgSupported),
<                     MakeBooleanChecker ())
<     .AddAttribute ("EdmgSupported",
<                    "This Boolean attribute is set to enable 802.11ay support at this STA",
<                     BooleanValue (false),
<                     MakeBooleanAccessor (&RegularWifiMac::SetEdmgSupported,
<                                          &RegularWifiMac::GetEdmgSupported),
<                     MakeBooleanChecker ())
< 
<     /* Fast Session Transfer Support */
<     .AddAttribute ("LLT", "The value of link loss timeout in microseconds",
<                     UintegerValue (0),
<                     MakeUintegerAccessor (&RegularWifiMac::m_llt),
<                     MakeUintegerChecker<uint32_t> ())
<     .AddAttribute ("FstTimeout", "The timeout value of FST session in TUs.",
<                     UintegerValue (10),
<                     MakeUintegerAccessor (&RegularWifiMac::m_fstTimeout),
<                     MakeUintegerChecker<uint8_t> ())
<     .AddAttribute ("SupportMultiBand",
<                    "Support multi-band operation for fast session transfer.",
<                     BooleanValue (false),
<                     MakeBooleanAccessor (&RegularWifiMac::m_supportMultiBand),
<                     MakeBooleanChecker ())
<   	//// WIGIG ////
< 
---
>                    MakeBooleanChecker ())
1571c959,960
<                    MakeBooleanAccessor (&RegularWifiMac::SetCtsToSelfSupported),
---
>                    MakeBooleanAccessor (&RegularWifiMac::SetCtsToSelfSupported,
>                                         &RegularWifiMac::GetCtsToSelfSupported),
1574,1576c963
<                    "Maximum length in bytes of an A-MSDU for AC_VO access class "
<                    "(capped to 7935 for HT PPDUs and 11398 for VHT/HE PPDUs). "
<                    "Value 0 means A-MSDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MSDU for AC_VO access class.",
1578,1579c965,966
<                    MakeUintegerAccessor (&RegularWifiMac::m_voMaxAmsduSize),
<                    MakeUintegerChecker<uint16_t> (0, 11398))
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetVoMaxAmsduSize),
>                    MakeUintegerChecker<uint32_t> ())
1581,1583c968
<                    "Maximum length in bytes of an A-MSDU for AC_VI access class "
<                    "(capped to 7935 for HT PPDUs and 11398 for VHT/HE PPDUs). "
<                    "Value 0 means A-MSDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MSDU for AC_VI access class.",
1585,1586c970,971
<                    MakeUintegerAccessor (&RegularWifiMac::m_viMaxAmsduSize),
<                    MakeUintegerChecker<uint16_t> (0, 11398))
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetViMaxAmsduSize),
>                    MakeUintegerChecker<uint32_t> ())
1588,1590c973
<                    "Maximum length in bytes of an A-MSDU for AC_BE access class "
<                    "(capped to 7935 for HT PPDUs and 11398 for VHT/HE PPDUs). "
<                    "Value 0 means A-MSDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MSDU for AC_BE access class.",
1592,1593c975,976
<                    MakeUintegerAccessor (&RegularWifiMac::m_beMaxAmsduSize),
<                    MakeUintegerChecker<uint16_t> (0, 11398))
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetBeMaxAmsduSize),
>                    MakeUintegerChecker<uint32_t> ())
1595,1597c978
<                    "Maximum length in bytes of an A-MSDU for AC_BK access class "
<                    "(capped to 7935 for HT PPDUs and 11398 for VHT/HE PPDUs). "
<                    "Value 0 means A-MSDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MSDU for AC_BK access class.",
1599,1600c980,981
<                    MakeUintegerAccessor (&RegularWifiMac::m_bkMaxAmsduSize),
<                    MakeUintegerChecker<uint16_t> (0, 11398))
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetBkMaxAmsduSize),
>                    MakeUintegerChecker<uint32_t> ())
1602,1604c983
<                    "Maximum length in bytes of an A-MPDU for AC_VO access class "
<                    "(capped to 65535 for HT PPDUs, 1048575 for VHT PPDUs, and 8388607 for HE PPDUs). "
<                    "Value 0 means A-MPDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MPDU for AC_VO access class.",
1606c985
<                    MakeUintegerAccessor (&RegularWifiMac::m_voMaxAmpduSize),
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetVoMaxAmpduSize),
1609,1611c988
<                    "Maximum length in bytes of an A-MPDU for AC_VI access class "
<                    "(capped to 65535 for HT PPDUs, 1048575 for VHT PPDUs, and 8388607 for HE PPDUs). "
<                    "Value 0 means A-MPDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MPDU for AC_VI access class.",
1613c990
<                    MakeUintegerAccessor (&RegularWifiMac::m_viMaxAmpduSize),
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetViMaxAmpduSize),
1616,1618c993
<                    "Maximum length in bytes of an A-MPDU for AC_BE access class "
<                    "(capped to 65535 for HT PPDUs, 1048575 for VHT PPDUs, and 8388607 for HE PPDUs). "
<                    "Value 0 means A-MPDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MPDU for AC_BE access class.",
1620c995
<                    MakeUintegerAccessor (&RegularWifiMac::m_beMaxAmpduSize),
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetBeMaxAmpduSize),
1623,1625c998
<                    "Maximum length in bytes of an A-MPDU for AC_BK access class "
<                    "(capped to 65535 for HT PPDUs, 1048575 for VHT PPDUs, and 8388607 for HE PPDUs). "
<                    "Value 0 means A-MPDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MPDU for AC_BK access class.",
1627c1000
<                    MakeUintegerAccessor (&RegularWifiMac::m_bkMaxAmpduSize),
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetBkMaxAmpduSize),
1631,1632c1004
<                    "block ack mechanism is used. If this value is 0, block ack is never used."
<                    "When A-MPDU is enabled, block ack mechanism is used regardless of this value.",
---
>                    "block ack mechanism is used. If this value is 0, block ack is never used.",
1638,1639c1010
<                    "block ack mechanism is used. If this value is 0, block ack is never used."
<                    "When A-MPDU is enabled, block ack mechanism is used regardless of this value.",
---
>                    "block ack mechanism is used. If this value is 0, block ack is never used.",
1645,1646c1016
<                    "block ack mechanism is used. If this value is 0, block ack is never used."
<                    "When A-MPDU is enabled, block ack mechanism is used regardless of this value.",
---
>                    "block ack mechanism is used. If this value is 0, block ack is never used.",
1652,1653c1022
<                    "block ack mechanism is used. If this value is 0, block ack is never used."
<                    "When A-MPDU is enabled, block ack mechanism is used regardless of this value.",
---
>                    "block ack mechanism is used. If this value is 0, block ack is never used.",
1658c1027
<                    "Represents max time (blocks of 1024 microseconds) allowed for block ack"
---
>                    "Represents max time (blocks of 1024 micro seconds) allowed for block ack"
1666c1035
<                    "Represents max time (blocks of 1024 microseconds) allowed for block ack"
---
>                    "Represents max time (blocks of 1024 micro seconds) allowed for block ack"
1674c1043
<                    "Represents max time (blocks of 1024 microseconds) allowed for block ack"
---
>                    "Represents max time (blocks of 1024 micro seconds) allowed for block ack"
1682c1051
<                    "Represents max time (blocks of 1024 microseconds) allowed for block ack"
---
>                    "Represents max time (blocks of 1024 micro seconds) allowed for block ack"
1692,1693c1061,1062
<                    MakeBooleanAccessor (&RegularWifiMac::SetShortSlotTimeSupported,
<                                         &RegularWifiMac::GetShortSlotTimeSupported),
---
>                    MakeBooleanAccessor (&WifiMac::GetShortSlotTimeSupported,
>                                         &WifiMac::SetShortSlotTimeSupported),
1695,1703c1064,1065
<     .AddAttribute ("RifsSupported",
<                    "Whether or not RIFS is supported (only used by HT APs or STAs).",
<                    BooleanValue (false),
<                    MakeBooleanAccessor (&RegularWifiMac::SetRifsSupported,
<                                         &RegularWifiMac::GetRifsSupported),
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Use the HtConfiguration instead")
<     .AddAttribute ("Txop",
<                    "The Txop object.",
---
>     .AddAttribute ("DcaTxop",
>                    "The DcaTxop object.",
1705,1707c1067,1069
<                    MakePointerAccessor (&RegularWifiMac::GetTxop),
<                    MakePointerChecker<Txop> ())
<     .AddAttribute ("VO_Txop",
---
>                    MakePointerAccessor (&RegularWifiMac::GetDcaTxop),
>                    MakePointerChecker<DcaTxop> ())
>     .AddAttribute ("VO_EdcaTxopN",
1711,1712c1073,1074
<                    MakePointerChecker<QosTxop> ())
<     .AddAttribute ("VI_Txop",
---
>                    MakePointerChecker<EdcaTxopN> ())
>     .AddAttribute ("VI_EdcaTxopN",
1716,1717c1078,1079
<                    MakePointerChecker<QosTxop> ())
<     .AddAttribute ("BE_Txop",
---
>                    MakePointerChecker<EdcaTxopN> ())
>     .AddAttribute ("BE_EdcaTxopN",
1721,1722c1083,1084
<                    MakePointerChecker<QosTxop> ())
<     .AddAttribute ("BK_Txop",
---
>                    MakePointerChecker<EdcaTxopN> ())
>     .AddAttribute ("BK_EdcaTxopN",
1726c1088
<                    MakePointerChecker<QosTxop> ())
---
>                    MakePointerChecker<EdcaTxopN> ())
1740c1102
< RegularWifiMac::FinishConfigureStandard (WifiPhyStandard standard)
---
> RegularWifiMac::FinishConfigureStandard (enum WifiPhyStandard standard)
1747,1754c1109,1112
<     //// WIGIG ////
<     case WIFI_PHY_STANDARD_80211ad:
<       SetDmgSupported (true);
<       cwmin = 15;
<       cwmax = 1023;
<       break;
<     case WIFI_PHY_STANDARD_80211ay:
<       SetEdmgSupported (true);
---
>     case WIFI_PHY_STANDARD_80211ac:
>       SetVhtSupported (true);
>     case WIFI_PHY_STANDARD_80211n_5GHZ:
>       SetHtSupported (true);
1758,1773d1115
<     //// WIGIG ////
<     case WIFI_PHY_STANDARD_80211ax_5GHZ:
<     case WIFI_PHY_STANDARD_80211ac:
<     case WIFI_PHY_STANDARD_80211n_5GHZ:
<       {
<         EnableAggregation ();
<         //To be removed once deprecated attributes are removed
<         Ptr<HtConfiguration> htConfiguration = GetHtConfiguration ();
<         NS_ASSERT (htConfiguration);
<         htConfiguration->SetRifsSupported (m_rifsSupported);
<         SetQosSupported (true);
<         cwmin = 15;
<         cwmax = 1023;
<         break;
<       }
<     case WIFI_PHY_STANDARD_80211ax_2_4GHZ:
1775,1782c1117
<       {
<         EnableAggregation ();
<         //To be removed once deprecated RifsSupported attribute is removed
<         Ptr<HtConfiguration> htConfiguration = GetHtConfiguration ();
<         NS_ASSERT (htConfiguration);
<         htConfiguration->SetRifsSupported (m_rifsSupported);
<         SetQosSupported (true);
<       }
---
>       SetHtSupported (true);
1810c1145
<   ConfigureDcf (m_txop, cwMin, cwMax, isDsssOnly, AC_BE_NQOS);
---
>   ConfigureDcf (m_dca, cwMin, cwMax, isDsssOnly, AC_BE_NQOS);
1813,1816c1148,1158
<   for (EdcaQueues::const_iterator i = m_edca.begin (); i != m_edca.end (); ++i)
<     {
<       ConfigureDcf (i->second, cwMin, cwMax, isDsssOnly, i->first);
<     }
---
>   for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
>   {
>     ConfigureDcf (i->second, cwMin, cwMax, isDsssOnly, i->first);
>   }
> }
> 
> void
> RegularWifiMac::TxOk (const WifiMacHeader &hdr)
> {
>   NS_LOG_FUNCTION (this << hdr);
>   m_txOkCallback (hdr);
1827c1169
< RegularWifiMac::EnableAggregation (void)
---
> RegularWifiMac::ConfigureAggregation (void)
1830c1172,1196
<   if (m_low->GetMsduAggregator () == 0)
---
>   if (GetVOQueue ()->GetMsduAggregator () != 0)
>     {
>       GetVOQueue ()->GetMsduAggregator ()->SetMaxAmsduSize (m_voMaxAmsduSize);
>     }
>   if (GetVIQueue ()->GetMsduAggregator () != 0)
>     {
>       GetVIQueue ()->GetMsduAggregator ()->SetMaxAmsduSize (m_viMaxAmsduSize);
>     }
>   if (GetBEQueue ()->GetMsduAggregator () != 0)
>     {
>       GetBEQueue ()->GetMsduAggregator ()->SetMaxAmsduSize (m_beMaxAmsduSize);
>     }
>   if (GetBKQueue ()->GetMsduAggregator () != 0)
>     {
>       GetBKQueue ()->GetMsduAggregator ()->SetMaxAmsduSize (m_bkMaxAmsduSize);
>     }
>   if (GetVOQueue ()->GetMpduAggregator () != 0)
>     {
>       GetVOQueue ()->GetMpduAggregator ()->SetMaxAmpduSize (m_voMaxAmpduSize);
>     }
>   if (GetVIQueue ()->GetMpduAggregator () != 0)
>     {
>       GetVIQueue ()->GetMpduAggregator ()->SetMaxAmpduSize (m_viMaxAmpduSize);
>     }
>   if (GetBEQueue ()->GetMpduAggregator () != 0)
1832,1834c1198
<       Ptr<MsduAggregator> msduAggregator = CreateObject<MsduAggregator> ();
<       msduAggregator->SetEdcaQueues (m_edca);
<       m_low->SetMsduAggregator (msduAggregator);
---
>       GetBEQueue ()->GetMpduAggregator ()->SetMaxAmpduSize (m_beMaxAmpduSize);
1836c1200
<   if (m_low->GetMpduAggregator () == 0)
---
>   if (GetBKQueue ()->GetMpduAggregator () != 0)
1838,1840c1202
<       Ptr<MpduAggregator> mpduAggregator = CreateObject<MpduAggregator> ();
<       mpduAggregator->SetEdcaQueues (m_edca);
<       m_low->SetMpduAggregator (mpduAggregator);
---
>       GetBKQueue ()->GetMpduAggregator ()->SetMaxAmpduSize (m_bkMaxAmpduSize);
1844a1207,1226
> RegularWifiMac::EnableAggregation (void)
> {
>   NS_LOG_FUNCTION (this);
>   for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
>   {
>     if (i->second->GetMsduAggregator () == 0)
>       {
>         Ptr<MsduStandardAggregator> msduAggregator = CreateObject<MsduStandardAggregator> ();
>         i->second->SetMsduAggregator (msduAggregator);
>       }
>     if (i->second->GetMpduAggregator () == 0)
>       {
>         Ptr<MpduStandardAggregator> mpduAggregator = CreateObject<MpduStandardAggregator> ();
>         i->second->SetMpduAggregator (mpduAggregator);
>       }
>   }
>   ConfigureAggregation ();
> }
> 
> void
1848,1849c1230,1234
<   m_low->SetMsduAggregator (0);
<   m_low->SetMpduAggregator (0);
---
>   for (EdcaQueues::iterator i = m_edca.begin (); i != m_edca.end (); ++i)
>   {
>     i->second->SetMsduAggregator (0);
>     i->second->SetMpduAggregator (0);
>   }
diff ../../NS3-WiGig/src/wifi/model/regular-wifi-mac.h ../../ns-3-dev/src/wifi/model/regular-wifi-mac.h
24,25c24,27
< #include "wifi-mac.h"
< #include "qos-txop.h"
---
> #include "ns3/wifi-mac.h"
> #include "dca-txop.h"
> #include "edca-txop-n.h"
> #include "wifi-remote-station-manager.h"
27,30c29,30
< #include "wifi-mac-header.h"
< #include "ctrl-headers.h"
< #include "mgt-headers.h"
< #include "edmg-short-ssw.h"
---
> #include "qos-utils.h"
> #include <map>
33a34
> class Dcf;
37,81c38
< class ChannelAccessManager;
< class ExtendedCapabilities;
< 
< //// WIGIG ////
< enum FST_STATES {
<   FST_INITIAL_STATE = 0,
<   FST_SETUP_COMPLETION_STATE,
<   FST_TRANSITION_DONE_STATE,
<   FST_TRANSITION_CONFIRMED_STATE
< };
< 
< struct FstSession {
<   uint32_t ID;                      //!< A unique ID that corresponds to a pair of receiver and transmitter.
<   FST_STATES CurrentState;          //!< Current state of the FST State Machine.
<   Time STT;                         //!< State transition timer.
<   bool IsInitiator;                 //!< Flag to indicate if we are the FST session initiator.
<   BandID NewBandId;                 //!< The new band the station is transferring to.
<   uint32_t LLT;                     //!< Link Loss Time (LLT) for this FST Session.
<   EventId LinkLossCountDownEvent;   //!< Event for Link Loss Timeout.
< };
< 
< /**
<  * This type defines a mapping between between the MAC Address of
<  * the Peer FST and FST Session Variables.
<  */
< typedef std::map<Mac48Address, FstSession> FstSessionMap;
< 
< //// WIGIG ////
< 
< /**
<  * The current MAC state of the STA.
<  */
< enum MacState
< {
<   ASSOCIATED,
<   WAIT_BEACON,
<   WAIT_PROBE_RESP,
<   WAIT_ASSOC_RESP,
<   UNASSOCIATED,
<   REFUSED
< };
< 
< /** This type defines a mapping between an Access Category index,
< and a pointer to the corresponding channel access function */
< typedef std::map<AcIndex, Ptr<QosTxop> > EdcaQueues;
---
> class DcfManager;
87,88c44,46
<  * This class encapsulates all the low-level MAC functionality and all the
<  * high-level MAC functionality (association/disassociation state machines).
---
>  * This class encapsulates all the low-level MAC functionality
>  * DCA, EDCA, etc) and all the high-level MAC functionality
>  * (association/disassociation state machines).
94,97d51
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
103c57,59
<   // Implementations of pure virtual methods.
---
>   /**
>    * \param slotTime the slot duration
>    */
104a61,63
>   /**
>    * \param sifs the sifs duration
>    */
105a65,70
>   /**
>    * \param eifsNoDifs the duration of an EIFS minus DIFS.
>    *
>    * This value is used to calculate the EIFS depending
>    * on AIFSN.
>    */
106a72,74
>   /**
>    * \param pifs the pifs duration.
>    */
107a76,78
>   /**
>    * \param rifs the rifs duration.
>    */
108a80,86
>   /**
>    * \param ctsTimeout the duration of a CTS timeout.
>    */
>   void SetCtsTimeout (Time ctsTimeout);
>   /**
>    * \param ackTimeout the duration of an ACK timeout.
>    */
110,113c88
<   void SetShortSlotTimeSupported (bool enable);
<   void SetSsid (Ssid ssid);
<   void SetAddress (Mac48Address address);
<   void SetPromisc (void);
---
> 
114a90,92
>   /**
>    * \return the current PIFS duration.
>    */
115a94,96
>   /**
>    * \return the current SIFS duration.
>    */
116a98,100
>   /**
>    * \return the current slot duration.
>    */
117a102,104
>   /**
>    * \return the current EIFS minus DIFS duration
>    */
119,130d105
<   Time GetAckTimeout (void) const;
<   bool GetShortSlotTimeSupported (void) const;
<   Ssid GetSsid (void) const;
<   Mac48Address GetAddress (void) const;
<   Mac48Address GetBssid (void) const;
<   virtual void Enqueue (Ptr<Packet> packet, Mac48Address to, Mac48Address from);
<   virtual bool SupportsSendFrom (void) const;
<   virtual void SetWifiPhy (const Ptr<WifiPhy> phy);
<   Ptr<WifiPhy> GetWifiPhy (void) const;
<   void ResetWifiPhy (void);
<   virtual void SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> stationManager);
< 
132,137c107
<    * This type defines the callback of a higher layer that a
<    * WifiMac(-derived) object invokes to pass a packet up the stack.
<    *
<    * \param packet the packet that has been received.
<    * \param from the MAC address of the device that sent the packet.
<    * \param to the MAC address of the device that the packet is destined for.
---
>    * \return the current CTS timeout duration.
139,146c109,111
<   typedef Callback<void, Ptr<const Packet>, Mac48Address, Mac48Address> ForwardUpCallback;
< 
<   void SetForwardUpCallback (ForwardUpCallback upCallback);
<   void SetLinkUpCallback (Callback<void> linkUp);
<   void SetLinkDownCallback (Callback<void> linkDown);
< 
<   /* Next functions are not pure virtual so non-QoS WifiMacs are not
<    * forced to implement them.
---
>   Time GetCtsTimeout (void) const;
>   /**
>    * \return the current ACK timeout duration.
148,154c113
<   void SetBasicBlockAckTimeout (Time blockAckTimeout);
<   Time GetBasicBlockAckTimeout (void) const;
<   void SetCompressedBlockAckTimeout (Time blockAckTimeout);
<   Time GetCompressedBlockAckTimeout (void) const;
< 
<   // Should be implemented by child classes
<   virtual void Enqueue (Ptr<Packet> packet, Mac48Address to) = 0;
---
>   Time GetAckTimeout (void) const;
164c123,124
<    * Enable or disable RIFS feature.
---
>    * Return whether the device supports CTS-to-self
>    * capability.
166c126,134
<    * \param enable true if RIFS is to be supported,
---
>    * \return true if CTS-to-self is supported,
>    *         false otherwise.
>    */
>   bool GetCtsToSelfSupported () const;
> 
>   /**
>    * Enable or disable short slot time feature.
>    *
>    * \param enable true if short slot time is to be supported,
168d135
<    * \deprecated
170c137
<   void SetRifsSupported (bool enable);
---
>   virtual void SetShortSlotTimeSupported (bool enable);
172c139
<    * \return whether the device supports RIFS capability.
---
>    * \return whether the device supports short slot time capability.
174c141
<    * \return true if short RIFS is supported,
---
>    * \return true if short slot time is supported,
176d142
<    * \deprecated
178c144,145
<   bool GetRifsSupported (void) const;
---
>   virtual bool GetShortSlotTimeSupported (void) const;
> 
180c147
<    * \param bssid the BSSID of the network that this device belongs to.
---
>    * \return the MAC address associated to this MAC layer.
182,183c149
<   void SetBssid (Mac48Address bssid);
< 
---
>   virtual Mac48Address GetAddress (void) const;
185c151
<    * \return the station manager attached to this MAC.
---
>    * \return the ssid which this MAC layer is going to try to stay in.
187c153
<   Ptr<WifiRemoteStationManager> GetWifiRemoteStationManager (void) const;
---
>   virtual Ssid GetSsid (void) const;
189,191c155
<    * Return the extended capabilities of the device.
<    *
<    * \return the extended capabilities that we support
---
>    * \param address the current address of this MAC layer.
193c157
<   Ptr<ExtendedCapabilities> GetExtendedCapabilities (void) const;
---
>   virtual void SetAddress (Mac48Address address);
195,197c159
<    * Return the HT capabilities of the device.
<    *
<    * \return the HT capabilities that we support
---
>    * \param ssid the current ssid of this MAC layer.
199c161
<   Ptr<HtCapabilities> GetHtCapabilities (void) const;
---
>   virtual void SetSsid (Ssid ssid);
201,203c163,167
<    * Return the VHT capabilities of the device.
<    *
<    * \return the VHT capabilities that we support
---
>    * \param bssid the BSSID of the network that this device belongs to.
>    */
>   virtual void SetBssid (Mac48Address bssid);
>   /**
>    * \return the bssid of the network this device belongs to.
205c169
<   Ptr<VhtCapabilities> GetVhtCapabilities (void) const;
---
>   virtual Mac48Address GetBssid (void) const;
207c171
<    * Return the HE capabilities of the device.
---
>    * \brief Sets the interface in promiscuous mode.
209c173,175
<    * \return the HE capabilities that we support
---
>    * Enables promiscuous mode on the interface. Note that any further
>    * filtering on the incoming frame path may affect the overall
>    * behavior.
211c177
<   Ptr<HeCapabilities> GetHeCapabilities (void) const;
---
>   virtual void SetPromisc (void);
214c180,188
<    * \return Get the state of the MAC layer (Associated/MissedBeacon...)
---
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
>    * \param from the address from which the packet should be sent.
>    *
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.  The extra parameter "from" allows
>    * this device to operate in a bridged mode, forwarding received
>    * frames without altering the source address.
216c190
<   virtual MacState GetMacState (void) const;
---
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to, Mac48Address from);
217a192
>   virtual bool SupportsSendFrom (void) const;
220c195,196
<    * Accessor for the DCF object
---
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
222c198,200
<    * \return a smart pointer to Txop
---
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.
224,225c202
<   Ptr<Txop> GetTxop (void) const;
< 
---
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to) = 0;
227,229c204
<    * Accessor for the AC_VO channel access function
<    *
<    * \return a smart pointer to QosTxop
---
>    * \param phy the physical layer attached to this MAC.
231c206
<   Ptr<QosTxop> GetVOQueue (void) const;
---
>   virtual void SetWifiPhy (Ptr<WifiPhy> phy);
233c208,224
<    * Accessor for the AC_VI channel access function
---
>    * \return the physical layer attached to this MAC.
>    */
>   virtual Ptr<WifiPhy> GetWifiPhy (void) const;
>   /**
>    * removes attached WifiPhy device from this MAC.
>    */
>   virtual void ResetWifiPhy (void);
>   /**
>    * \param stationManager the station manager attached to this MAC.
>    */
>   virtual void SetWifiRemoteStationManager (Ptr<WifiRemoteStationManager> stationManager);
>   /**
>    * \return the station manager attached to this MAC.
>    */
>   virtual Ptr<WifiRemoteStationManager> GetWifiRemoteStationManager (void) const;
>   /**
>    * Return the HT capability of the device.
235c226
<    * \return a smart pointer to QosTxop
---
>    * \return the HT capability that we support
237c228
<   Ptr<QosTxop> GetVIQueue (void) const;
---
>   HtCapabilities GetHtCapabilities (void) const;
239c230
<    * Accessor for the AC_BE channel access function
---
>    * Return the VHT capability of the device.
241c232
<    * \return a smart pointer to QosTxop
---
>    * \return the VHT capability that we support
243c234,235
<   Ptr<QosTxop> GetBEQueue (void) const;
---
>   VhtCapabilities GetVhtCapabilities (void) const;
> 
245c237,238
<    * Accessor for the AC_BK channel access function
---
>    * This type defines the callback of a higher layer that a
>    * WifiMac(-derived) object invokes to pass a packet up the stack.
247c240,242
<    * \return a smart pointer to QosTxop
---
>    * \param packet the packet that has been received.
>    * \param from the MAC address of the device that sent the packet.
>    * \param to the MAC address ot the device that the packet is destined for.
249c244
<   Ptr<QosTxop> GetBKQueue (void) const;
---
>   typedef Callback<void, Ptr<Packet>, Mac48Address, Mac48Address> ForwardUpCallback;
251c246,247
<    * Accessor for all EDCA Queues.
---
>    * \param upCallback the callback to invoke when a packet must be
>    * forwarded up the stack.
253c249
<   EdcaQueues GetEdcaQueues () const;
---
>   virtual void SetForwardUpCallback (ForwardUpCallback upCallback);
255,256c251
<    * Setup FST session as initiator.
<    * \param staAddress The address of the sta to establish FST session with it.
---
>    * \param linkUp the callback to invoke when the link becomes up.
258c253
<   void SetupFSTSession (Mac48Address staAddress);
---
>   virtual void SetLinkUpCallback (Callback<void> linkUp);
260,261c255,260
<    * Get Type Of Station.
<    * \return station type
---
>    * \param linkDown the callback to invoke when the link becomes down.
>    */
>   virtual void SetLinkDownCallback (Callback<void> linkDown);
> 
>   /* Next functions are not pure virtual so non Qos WifiMacs are not
>    * forced to implement them.
263c262,266
<   TypeOfStation GetTypeOfStation (void) const;
---
>   virtual void SetBasicBlockAckTimeout (Time blockAckTimeout);
>   virtual Time GetBasicBlockAckTimeout (void) const;
>   virtual void SetCompressedBlockAckTimeout (Time blockAckTimeout);
>   virtual Time GetCompressedBlockAckTimeout (void) const;
> 
269,273c272,276
<   Ptr<MacRxMiddle> m_rxMiddle;  //!< RX middle (defragmentation etc.)
<   Ptr<MacTxMiddle> m_txMiddle;  //!< TX middle (aggregation etc.)
<   Ptr<MacLow> m_low;            //!< MacLow (RTS, CTS, Data, Ack etc.)
<   Ptr<ChannelAccessManager> m_channelAccessManager; //!< channel access manager
<   Ptr<WifiPhy> m_phy;           //!< Wifi PHY
---
>   MacRxMiddle *m_rxMiddle;  //!< RX middle (de-fragmentation etc.)
>   MacTxMiddle *m_txMiddle;  //!< TX middle (aggregation etc.)
>   Ptr<MacLow> m_low;        //!< MacLow (RTS, CTS, DATA, ACK etc.)
>   DcfManager *m_dcfManager; //!< DCF manager (access to channel)
>   Ptr<WifiPhy> m_phy;       //!< Wifi PHY
281,284c284
<   //// WIGIG ////
<   Callback<void> m_sessionTransfer; //!< Callback when a session transfer takes place.
<   bool m_supportMultiBand;          //!< Flag to indicate whether we support multiband operation.
<   uint8_t m_fstTimeout;             //!< FST Session Timeout duration in TUs.
---
>   Ssid m_ssid; //!< Service Set ID (SSID)
286c286,296
<   /** Fast Session Transfer Functions **/
---
>   /** This holds a pointer to the DCF instance for this WifiMac - used
>   for transmission of frames to non-QoS peers. */
>   Ptr<DcaTxop> m_dca;
> 
>   /** This type defines a mapping between an Access Category index,
>   and a pointer to the corresponding channel access function */
>   typedef std::map<AcIndex, Ptr<EdcaTxopN> > EdcaQueues;
> 
>   /** This is a map from Access Category index to the corresponding
>   channel access function */
>   EdcaQueues m_edca;
289,317c299,301
<    * Send FST Setup Response to Initiator.
<    * \param to The Mac address of the initiator.
<    * \param token The token dialog.
<    * \param status The status of the setup operation.
<    * \param sessionTransition The session transition element.
<    */
<   void SendFstSetupResponse (Mac48Address to, uint8_t token, uint16_t status, SessionTransitionElement sessionTransition);
<   /**
<    * Send FST ACK Request frame to the responder.
<    * \param to The MAC address of the responder station.
<    * \param token The token dialog.
<    * \param fstsID The ID of FST session.
<    */
<   void SendFstAckRequest (Mac48Address to, uint8_t token, uint32_t fstsID);
<   /**
<    * Send FST ACk Response frame to the initiator.
<    * \param to The MAC address of the initiator station.
<    * \param token The token dialog.
<    * \param fstsID The ID of FST session.
<    */
<   void SendFstAckResponse (Mac48Address to, uint8_t token, uint32_t fstsID);
<   /**
<    * Send FST TearDown frame to a station.
<    * \param to The MAC address of the peer station.
<    */
<   void SendFstTearDownFrame (Mac48Address to);
<   /**
<    * Get the multiband information element associated with this STA device.
<    * \return The MultiBand information element correspodning to this WifiMac.
---
>    * Accessor for the DCF object
>    *
>    * \return a smart pointer to DcaTxop
319c303,304
<   virtual Ptr<MultiBandElement> GetMultiBandElement (void) const = 0;
---
>   Ptr<DcaTxop> GetDcaTxop (void) const;
> 
321,324c306,308
<    * Notify that the frequency band has changed
<    * \param standard The WiFi standard to use in the new band.
<    * \param address The address of the peer station.
<    * \param isInitiator flag to indicate whether we are the initiator of the FST or not.
---
>    * Accessor for the AC_VO channel access function
>    *
>    * \return a smart pointer to EdcaTxopN
326c310
<   void NotifyBandChanged (WifiPhyStandard standard, Mac48Address address, bool isInitiator);
---
>   Ptr<EdcaTxopN> GetVOQueue (void) const;
328,331c312,314
<    * Change the current operational frequency band.
<    * \param peerStation The MAC address of the peer station.
<    * \param bandId The ID of the new band.
<    * \param isInitiator True is we are the initiator of the FST, otherwise false.
---
>    * Accessor for the AC_VI channel access function
>    *
>    * \return a smart pointer to EdcaTxopN
333c316
<   void ChangeBand (Mac48Address peerStation, BandID bandId, bool isInitiator);
---
>   Ptr<EdcaTxopN> GetVIQueue (void) const;
335,336c318,320
<    * MacTxOk
<    * \param address
---
>    * Accessor for the AC_BE channel access function
>    *
>    * \return a smart pointer to EdcaTxopN
338c322
<   void MacTxOk (Mac48Address address);
---
>   Ptr<EdcaTxopN> GetBEQueue (void) const;
340,341c324,326
<    * MacRxOk
<    * \param address
---
>    * Accessor for the AC_BK channel access function
>    *
>    * \return a smart pointer to EdcaTxopN
343,360c328
<   void MacRxOk (Mac48Address address);
< 
<   uint32_t m_llt;                   //!< Link Loss Timeout.
<   uint32_t m_fstId;                 //!< Fast session transfer ID.
<   FstSessionMap m_fstSessionMap;    //!< Maps for active FST sessions.
< 
<   //// WIGIG ////
< 
<   Ssid m_ssid;      //!< Service Set ID (SSID)
<   MacState m_state; //!< The state of the MAC layer.
< 
<   /** This holds a pointer to the DCF instance for this WifiMac - used
<   for transmission of frames to non-QoS peers. */
<   Ptr<Txop> m_txop;
< 
<   /** This is a map from Access Category index to the corresponding
<   channel access function */
<   EdcaQueues m_edca;
---
>   Ptr<EdcaTxopN> GetBKQueue (void) const;
363c331
<    * \param standard the PHY standard to be used
---
>    * \param standard the phy standard to be used
366c334
<    * complete the configuration process for a requested PHY standard.
---
>    * complete the configuration process for a requested phy standard.
368c336
<    * This method may be overridden by a derived class (e.g., in order
---
>    * This method may be overriden by a derived class (e.g., in order
374,375c342,343
<   void FinishConfigureStandard (WifiPhyStandard standard);
< 
---
>   virtual void FinishConfigureStandard (enum WifiPhyStandard standard);
>   
377,378c345,346
<    * \param cwMin the minimum contention window size
<    * \param cwMax the maximum contention window size
---
>    * \param cwMin the minimum congestion window size
>    * \param cwMax the maximum congestion window size
388c356
<    * access functions (instantiated within this class as QosTxop's)
---
>    * access functions (instantiated within this class as EdcaTxopN's)
400c368
<    * of Block Ack management frames is dealt with here.
---
>    * of Block Ack managment frames is dealt with here.
402c370
<    * This method will need, however, to be overridden by derived
---
>    * This method will need, however, to be overriden by derived
406c374,375
<    * \param mpdu the MPDU that has been received.
---
>    * \param packet the packet that has been received.
>    * \param hdr a pointer to the MAC header of the received frame.
408c377
<   virtual void Receive (Ptr<WifiMacQueueItem> mpdu);
---
>   virtual void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
411c380
<    * (i.e. we received an Ack from the receiver).
---
>    * (i.e. we received an ACK from the receiver).
413,414c382
<    * \param packet the packet that has been transmitted.
<    * \param hdr the header of the packet that we successfully sent.
---
>    * \param hdr the header of the packet that we successfully sent
416c384
<   virtual void TxOk (Ptr<const Packet> packet, const WifiMacHeader &hdr);
---
>   virtual void TxOk (const WifiMacHeader &hdr);
419c387
<    * (i.e. we did not receive an Ack from the receiver).
---
>    * (i.e. we did not receive an ACK from the receiver).
432c400
<   void ForwardUp (Ptr<const Packet> packet, Mac48Address from, Mac48Address to);
---
>   void ForwardUp (Ptr<Packet> packet, Mac48Address from, Mac48Address to);
438c406,407
<    * \param mpdu the MPDU containing the A-MSDU.
---
>    * \param aggregatedPacket the Packet containing the A-MSDU.
>    * \param hdr a pointer to the MAC header for \c aggregatedPacket.
440c409,410
<   virtual void DeaggregateAmsduAndForward (Ptr<WifiMacQueueItem> mpdu);
---
>   virtual void DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket,
>                                            const WifiMacHeader *hdr);
449,450c419,435
<   void SendAddBaResponse (const MgtAddBaRequestHeader *reqHdr,
<                           Mac48Address originator);
---
>   virtual void SendAddBaResponse (const MgtAddBaRequestHeader *reqHdr,
>                                   Mac48Address originator);
> 
>   /**
>    * This Boolean is set \c true iff this WifiMac is to model
>    * 802.11e/WMM style Quality of Service. It is exposed through the
>    * attribute system.
>    *
>    * At the moment, this flag is the sole selection between QoS and
>    * non-QoS operation for the STA (whether IBSS, AP, or
>    * non-AP). Ultimately, we will want a QoS-enabled STA to be able to
>    * fall back to non-QoS operation with a non-QoS peer. This'll
>    * require further intelligence - i.e., per-association QoS
>    * state. Having a big switch seems like a good intermediate stage,
>    * however.
>    */
>   bool m_qosSupported;
457c442
<   virtual void SetQosSupported (bool enable);
---
>   void SetQosSupported (bool enable);
465a451,464
>     * This Boolean is set \c true iff this WifiMac is to model
>     * 802.11n. It is exposed through the attribute system.
>     *
>     * At the moment, this flag is the sole selection between HT and
>     * non-HT operation for the STA (whether IBSS, AP, or
>     * non-AP). Ultimately, we will want a HT-enabled STA to be able to
>     * fall back to non-HT operation with a non-HT peer. This'll
>     * require further intelligence - i.e., per-association HT
>     * state. Having a big switch seems like a good intermediate stage,
>     * however.
>     */
>   bool m_htSupported;
> 
>   /**
478a478,482
>    * This Boolean is set \c true iff this WifiMac is to model
>    * 802.11ac. It is exposed through the attribute system.
>    */
>   bool m_vhtSupported;
>   /**
490c494,499
< 
---
>   
>   /**
>    * This Boolean is set \c true iff this WifiMac is to model
>    * 802.11g. It is exposed through the attribute system.
>    */
>   bool m_erpSupported;
503c512,517
< 
---
>   
>   /**
>    * This Boolean is set \c true iff this WifiMac is to model
>    * 802.11b. It is exposed through the attribute system.
>    */
>   bool m_dsssSupported;
517,564d530
<   //// WIGIG ////
<   /**
<    * This Boolean is set \c true if this WifiMac is to model
<    * 802.11ad. It is exposed through the attribute system.
<    */
<   bool m_dmgSupported;
<   /**
<    * Enable or disable DMG support for the device.
<    *
<    * \param enable whether DMG is supported
<    */
<   void SetDmgSupported (bool enable);
<   /**
<    * Return whether the device supports DMG.
<    *
<    * \return true if DMG is supported, false otherwise
<    */
<   bool GetDmgSupported (void) const;
<   /**
<    * This Boolean is set \c true if this WifiMac is to model
<    * 802.11ay. It is exposed through the attribute system.
<    */
<   bool m_edmgSupported;
<   /**
<    * Enable or disable EDMG support for the device.
<    *
<    * \param enable whether EDMG is supported
<    */
<   void SetEdmgSupported (bool enable);
<   /**
<    * Return whether the device supports EDMG.
<    *
<    * \return true if EDMG is supported, false otherwise
<    */
<   bool GetEdmgSupported (void) const;
<   //// WIGIG ////
<   /**
<    * Enable or disable HE support for the device.
<    *
<    * \param enable whether HE is supported
<    */
<   void SetHeSupported (bool enable);
<   /**
<    * Return whether the device supports HE.
<    *
<    * \return true if HE is supported, false otherwise
<    */
<   bool GetHeSupported () const;
567d532
<   /// type conversion operator
569,575c534
<   /**
<    * assignment operator
<    *
<    * \param mac the RegularWifiMac to assign
<    * \returns the assigned value
<    */
<   RegularWifiMac & operator= (const RegularWifiMac & mac);
---
>   RegularWifiMac & operator= (const RegularWifiMac &);
581c540
<    * \param ac the Access Category of the queue to initialise.
---
>    * \param ac the Access Category index of the queue to initialise.
583c542
<   void SetupEdcaQueue (AcIndex ac);
---
>   void SetupEdcaQueue (enum AcIndex ac);
585,589c544,553
<   /**
<    * Set the block ack threshold for AC_VO.
<    *
<    * \param threshold the block ack threshold for AC_VO.
<    */
---
>   void SetVoMaxAmsduSize (uint32_t size);
>   void SetViMaxAmsduSize (uint32_t size);
>   void SetBeMaxAmsduSize (uint32_t size);
>   void SetBkMaxAmsduSize (uint32_t size);
> 
>   void SetVoMaxAmpduSize (uint32_t size);
>   void SetViMaxAmpduSize (uint32_t size);
>   void SetBeMaxAmpduSize (uint32_t size);
>   void SetBkMaxAmpduSize (uint32_t size);
>   
591,595d554
<   /**
<    * Set the block ack threshold for AC_VI.
<    *
<    * \param threshold the block ack threshold for AC_VI.
<    */
597,601d555
<   /**
<    * Set the block ack threshold for AC_BE.
<    *
<    * \param threshold the block ack threshold for AC_BE.
<    */
603,607d556
<   /**
<    * Set the block ack threshold for AC_BK.
<    *
<    * \param threshold the block ack threshold for AC_BK.
<    */
609,614c558
< 
<   /**
<    * Set VO block ack inactivity timeout.
<    *
<    * \param timeout the VO block ack inactivity timeout.
<    */
---
>   
616,620d559
<   /**
<    * Set VI block ack inactivity timeout.
<    *
<    * \param timeout the VI block ack inactivity timeout.
<    */
622,626d560
<   /**
<    * Set BE block ack inactivity timeout.
<    *
<    * \param timeout the BE block ack inactivity timeout.
<    */
628,632d561
<   /**
<    * Set BK block ack inactivity timeout.
<    *
<    * \param timeout the BK block ack inactivity timeout.
<    */
634,660c563,564
< 
<   /**
<    * This Boolean is set \c true iff this WifiMac is to model
<    * 802.11e/WMM style Quality of Service. It is exposed through the
<    * attribute system.
<    *
<    * At the moment, this flag is the sole selection between QoS and
<    * non-QoS operation for the STA (whether IBSS, AP, or
<    * non-AP). Ultimately, we will want a QoS-enabled STA to be able to
<    * fall back to non-QoS operation with a non-QoS peer. This'll
<    * require further intelligence - i.e., per-association QoS
<    * state. Having a big switch seems like a good intermediate stage,
<    * however.
<    */
<   bool m_qosSupported;
<   /**
<    * This Boolean is set \c true iff this WifiMac is to model
<    * 802.11g. It is exposed through the attribute system.
<    */
<   bool m_erpSupported;
<   /**
<    * This Boolean is set \c true iff this WifiMac is to model
<    * 802.11b. It is exposed through the attribute system.
<    */
<   bool m_dsssSupported;
< 
<   /// Enable aggregation function
---
>   
>   void ConfigureAggregation (void);
662d565
<   /// Disable aggregation function
665,680c568,581
<   uint16_t m_voMaxAmsduSize; ///< maximum A-MSDU size for AC_VO (in bytes)
<   uint16_t m_viMaxAmsduSize; ///< maximum A-MSDU size for AC_VI (in bytes)
<   uint16_t m_beMaxAmsduSize; ///< maximum A-MSDU size for AC_BE (in bytes)
<   uint16_t m_bkMaxAmsduSize; ///< maximum A-MSDU size for AC_BK (in bytes)
< 
<   uint32_t m_voMaxAmpduSize; ///< maximum A-MPDU size for AC_VO (in bytes)
<   uint32_t m_viMaxAmpduSize; ///< maximum A-MPDU size for AC_VI (in bytes)
<   uint32_t m_beMaxAmpduSize; ///< maximum A-MPDU size for AC_BE (in bytes)
<   uint32_t m_bkMaxAmpduSize; ///< maximum A-MPDU size for AC_BK (in bytes)
< 
<   TracedCallback<const WifiMacHeader &> m_txOkCallback; ///< transmit OK callback
<   TracedCallback<const WifiMacHeader &> m_txErrCallback; ///< transmit error callback
< 
<   TypeOfStation m_type;  ///< type of the station
<   bool m_shortSlotTimeSupported; ///< flag whether short slot time is supported
<   bool m_rifsSupported; ///< flag whether RIFS is supported (deprecated)
---
>   uint32_t m_voMaxAmsduSize;
>   uint32_t m_viMaxAmsduSize;
>   uint32_t m_beMaxAmsduSize;
>   uint32_t m_bkMaxAmsduSize;
> 
>   uint32_t m_voMaxAmpduSize;
>   uint32_t m_viMaxAmpduSize;
>   uint32_t m_beMaxAmpduSize;
>   uint32_t m_bkMaxAmpduSize;
> 
>   TracedCallback<const WifiMacHeader &> m_txOkCallback;
>   TracedCallback<const WifiMacHeader &> m_txErrCallback;
>   
>   bool m_shortSlotTimeSupported;
Only in ../../NS3-WiGig/src/wifi/model: rf-chain.cc
Only in ../../NS3-WiGig/src/wifi/model: rf-chain.h
diff ../../NS3-WiGig/src/wifi/model/rraa-wifi-manager.cc ../../ns-3-dev/src/wifi/model/rraa-wifi-manager.cc
20a21,22
> #include "rraa-wifi-manager.h"
> #include "ns3/assert.h"
22c24,26
< #include "ns3/packet.h"
---
> #include "ns3/boolean.h"
> #include "ns3/double.h"
> #include "ns3/uinteger.h"
24,26d27
< #include "rraa-wifi-manager.h"
< #include "wifi-phy.h"
< #include "wifi-mac.h"
42,51c43,50
<   uint32_t m_counter;            //!< Counter for transmission attempts.
<   uint32_t m_nFailed;            //!< Number of failed transmission attempts.
<   uint32_t m_adaptiveRtsWnd;     //!< Window size for the Adaptive RTS mechanism.
<   uint32_t m_rtsCounter;         //!< Counter for RTS transmission attempts.
<   Time m_lastReset;              //!< Time of the last reset.
<   bool m_adaptiveRtsOn;          //!< Check if Adaptive RTS mechanism is on.
<   bool m_lastFrameFail;          //!< Flag if the last frame sent has failed.
<   bool m_initialized;            //!< For initializing variables.
<   uint8_t m_nRate;               //!< Number of supported rates.
<   uint8_t m_rateIndex;           //!< Current rate index.
---
>   uint32_t m_counter;
>   uint32_t m_failed;
>   uint32_t m_rtsWnd;
>   uint32_t m_rtsCounter;
>   Time m_lastReset;
>   bool m_rtsOn;
>   bool m_lastFrameFail;
>   bool m_initialized;
53c52
<   RraaThresholdsTable m_thresholds; //!< RRAA thresholds for this station.
---
>   uint32_t m_rate;
66c65
<                    "If true the RRAA-BASIC algorithm will be used, otherwise the RRAA will be used",
---
>                    "If true the RRAA-BASIC algorithm will be used, otherwise the RRAA wil be used",
71c70
<                    "Timeout for the RRAA BASIC loss estimation block",
---
>                    "Timeout for the RRAA BASIC loss estimaton block (s)",
75,103c74,183
<     .AddAttribute ("FrameLength",
<                    "The Data frame length (in bytes) used for calculating mode TxTime.",
<                    UintegerValue (1420),
<                    MakeUintegerAccessor (&RraaWifiManager::m_frameLength),
<                    MakeUintegerChecker <uint32_t> ())
<     .AddAttribute ("AckFrameLength",
<                    "The Ack frame length (in bytes) used for calculating mode TxTime.",
<                    UintegerValue (14),
<                    MakeUintegerAccessor (&RraaWifiManager::m_ackLength),
<                    MakeUintegerChecker <uint32_t> ())
<     .AddAttribute ("Alpha",
<                    "Constant for calculating the MTL threshold.",
<                    DoubleValue (1.25),
<                    MakeDoubleAccessor (&RraaWifiManager::m_alpha),
<                    MakeDoubleChecker<double> (1))
<     .AddAttribute ("Beta",
<                    "Constant for calculating the ORI threshold.",
<                    DoubleValue (2),
<                    MakeDoubleAccessor (&RraaWifiManager::m_beta),
<                    MakeDoubleChecker<double> (1))
<     .AddAttribute ("Tau",
<                    "Constant for calculating the EWND size.",
<                    DoubleValue (0.012),
<                    MakeDoubleAccessor (&RraaWifiManager::m_tau),
<                    MakeDoubleChecker<double> (0))
<     .AddTraceSource ("Rate",
<                      "Traced value for rate changes (b/s)",
<                      MakeTraceSourceAccessor (&RraaWifiManager::m_currentRate),
<                      "ns3::TracedValueCallback::Uint64")
---
>     .AddAttribute ("ewndFor54mbps",
>                    "ewnd parameter for 54 Mbs data mode",
>                    UintegerValue (40),
>                    MakeUintegerAccessor (&RraaWifiManager::m_ewndfor54),
>                    MakeUintegerChecker<uint32_t> ())
>     .AddAttribute ("ewndFor48mbps",
>                    "ewnd parameter for 48 Mbs data mode",
>                    UintegerValue (40),
>                    MakeUintegerAccessor (&RraaWifiManager::m_ewndfor48),
>                    MakeUintegerChecker<uint32_t> ())
>     .AddAttribute ("ewndFor36mbps",
>                    "ewnd parameter for 36 Mbs data mode",
>                    UintegerValue (40),
>                    MakeUintegerAccessor (&RraaWifiManager::m_ewndfor36),
>                    MakeUintegerChecker<uint32_t> ())
>     .AddAttribute ("ewndFor24mbps",
>                    "ewnd parameter for 24 Mbs data mode",
>                    UintegerValue (40),
>                    MakeUintegerAccessor (&RraaWifiManager::m_ewndfor24),
>                    MakeUintegerChecker<uint32_t> ())
>     .AddAttribute ("ewndFor18mbps",
>                    "ewnd parameter for 18 Mbs data mode",
>                    UintegerValue (20),
>                    MakeUintegerAccessor (&RraaWifiManager::m_ewndfor18),
>                    MakeUintegerChecker<uint32_t> ())
>     .AddAttribute ("ewndFor12mbps",
>                    "ewnd parameter for 12 Mbs data mode",
>                    UintegerValue (20),
>                    MakeUintegerAccessor (&RraaWifiManager::m_ewndfor12),
>                    MakeUintegerChecker<uint32_t> ())
>     .AddAttribute ("ewndFor9mbps",
>                    "ewnd parameter for 9 Mbs data mode",
>                    UintegerValue (10),
>                    MakeUintegerAccessor (&RraaWifiManager::m_ewndfor9),
>                    MakeUintegerChecker<uint32_t> ())
>     .AddAttribute ("ewndFor6mbps",
>                    "ewnd parameter for 6 Mbs data mode",
>                    UintegerValue (6),
>                    MakeUintegerAccessor (&RraaWifiManager::m_ewndfor6),
>                    MakeUintegerChecker<uint32_t> ())
>     .AddAttribute ("poriFor48mbps",
>                    "Pori parameter for 48 Mbs data mode",
>                    DoubleValue (0.047),
>                    MakeDoubleAccessor (&RraaWifiManager::m_porifor48),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("poriFor36mbps",
>                    "Pori parameter for 36 Mbs data mode",
>                    DoubleValue (0.115),
>                    MakeDoubleAccessor (&RraaWifiManager::m_porifor36),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("poriFor24mbps",
>                    "Pori parameter for 24 Mbs data mode",
>                    DoubleValue (0.1681),
>                    MakeDoubleAccessor (&RraaWifiManager::m_porifor24),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("poriFor18mbps",
>                    "Pori parameter for 18 Mbs data mode",
>                    DoubleValue (0.1325),
>                    MakeDoubleAccessor (&RraaWifiManager::m_porifor18),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("poriFor12mbps",
>                    "Pori parameter for 12 Mbs data mode",
>                    DoubleValue (0.1861),
>                    MakeDoubleAccessor (&RraaWifiManager::m_porifor12),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("poriFor9mbps",
>                    "Pori parameter for 9 Mbs data mode",
>                    DoubleValue (0.1434),
>                    MakeDoubleAccessor (&RraaWifiManager::m_porifor9),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("poriFor6mbps",
>                    "Pori parameter for 6 Mbs data mode",
>                    DoubleValue (0.5),
>                    MakeDoubleAccessor (&RraaWifiManager::m_porifor6),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("pmtlFor54mbps",
>                    "Pmtl parameter for 54 Mbs data mode",
>                    DoubleValue (0.094),
>                    MakeDoubleAccessor (&RraaWifiManager::m_pmtlfor54),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("pmtlFor48mbps",
>                    "Pmtl parameter for 48 Mbs data mode",
>                    DoubleValue (0.23),
>                    MakeDoubleAccessor (&RraaWifiManager::m_pmtlfor48),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("pmtlFor36mbps",
>                    "Pmtl parameter for 36 Mbs data mode",
>                    DoubleValue (0.3363),
>                    MakeDoubleAccessor (&RraaWifiManager::m_pmtlfor36),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("pmtlFor24mbps",
>                    "Pmtl parameter for 24 Mbs data mode",
>                    DoubleValue (0.265),
>                    MakeDoubleAccessor (&RraaWifiManager::m_pmtlfor24),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("pmtlFor18mbps",
>                    "Pmtl parameter for 18 Mbs data mode",
>                    DoubleValue (0.3722),
>                    MakeDoubleAccessor (&RraaWifiManager::m_pmtlfor18),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("pmtlFor12mbps",
>                    "Pmtl parameter for 12 Mbs data mode",
>                    DoubleValue (0.2868),
>                    MakeDoubleAccessor (&RraaWifiManager::m_pmtlfor12),
>                    MakeDoubleChecker<double> ())
>     .AddAttribute ("pmtlFor9mbps",
>                    "Pmtl parameter for 9 Mbs data mode",
>                    DoubleValue (0.3932),
>                    MakeDoubleAccessor (&RraaWifiManager::m_pmtlfor9),
>                    MakeDoubleChecker<double> ())
107a188
> 
109,110d189
<   : WifiRemoteStationManager (),
<     m_currentRate (0)
112d190
<   NS_LOG_FUNCTION (this);
117,202d194
<   NS_LOG_FUNCTION (this);
< }
< 
< void
< RraaWifiManager::SetupPhy (const Ptr<WifiPhy> phy)
< {
<   NS_LOG_FUNCTION (this << phy);
<   uint8_t nModes = phy->GetNModes ();
<   for (uint8_t i = 0; i < nModes; i++)
<     {
<       WifiMode mode = phy->GetMode (i);
<       WifiTxVector txVector;
<       txVector.SetMode (mode);
<       txVector.SetPreambleType (WIFI_PREAMBLE_LONG);
<       /* Calculate the TX Time of the Data and the corresponding Ack */
<       Time dataTxTime = phy->CalculateTxDuration (m_frameLength, txVector, phy->GetFrequency ());
<       Time ackTxTime = phy->CalculateTxDuration (m_ackLength, txVector, phy->GetFrequency ());
<       NS_LOG_DEBUG ("Calculating TX times: Mode= " << mode << " DataTxTime= " << dataTxTime << " AckTxTime= " << ackTxTime);
<       AddCalcTxTime (mode, dataTxTime + ackTxTime);
<     }
<   WifiRemoteStationManager::SetupPhy (phy);
< }
< 
< void
< RraaWifiManager::SetupMac (const Ptr<WifiMac> mac)
< {
<   NS_LOG_FUNCTION (this);
<   m_sifs = mac->GetSifs ();
<   m_difs = m_sifs + 2 * mac->GetSlot ();
<   WifiRemoteStationManager::SetupMac (mac);
< }
< 
< void
< RraaWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
< Time
< RraaWifiManager::GetCalcTxTime (WifiMode mode) const
< {
<   NS_LOG_FUNCTION (this << mode);
<   for (TxTime::const_iterator i = m_calcTxTime.begin (); i != m_calcTxTime.end (); i++)
<     {
<       if (mode == i->second)
<         {
<           return i->first;
<         }
<     }
<   NS_ASSERT (false);
<   return Seconds (0);
< }
< 
< void
< RraaWifiManager::AddCalcTxTime (WifiMode mode, Time t)
< {
<   NS_LOG_FUNCTION (this << mode << t);
<   m_calcTxTime.push_back (std::make_pair (t, mode));
< }
< 
< WifiRraaThresholds
< RraaWifiManager::GetThresholds (RraaWifiRemoteStation *station, WifiMode mode) const
< {
<   NS_LOG_FUNCTION (this << station << mode);
<   struct WifiRraaThresholds threshold;
<   for (RraaThresholdsTable::const_iterator i = station->m_thresholds.begin (); i != station->m_thresholds.end (); i++)
<     {
<       if (mode == i->second)
<         {
<           return i->first;
<         }
<     }
<   NS_ABORT_MSG ("No thresholds for mode " << mode << " found");
<   return threshold; // Silence compiler warning
210c202
<   station->m_adaptiveRtsWnd = 0;
---
>   station->m_rtsWnd = 0;
212c204
<   station->m_adaptiveRtsOn = false;
---
>   station->m_rtsOn = false;
218c210
< RraaWifiManager::CheckInit (RraaWifiRemoteStation *station)
---
> RraaWifiManager::ResetCountersBasic (RraaWifiRemoteStation *station)
220d211
<   NS_LOG_FUNCTION (this << station);
223,229c214
<       //Note: we appear to be doing late initialization of the table
<       //to make sure that the set of supported rates has been initialized
<       //before we perform our own initialization.
<       station->m_nRate = GetNSupported (station);
<       //Initialize at maximal rate
<       station->m_rateIndex = GetMaxRate (station);
< 
---
>       station->m_rate = GetMaxRate (station);
231,274d215
< 
<       station->m_thresholds = RraaThresholdsTable (station->m_nRate);
<       InitThresholds (station);
<       ResetCountersBasic (station);
<     }
< }
< 
< void
< RraaWifiManager::InitThresholds (RraaWifiRemoteStation *station)
< {
<   NS_LOG_FUNCTION (this << station);
<   NS_LOG_DEBUG ("InitThresholds = " << station);
< 
<   double nextCritical = 0;
<   double nextMtl = 0;
<   double mtl = 0;
<   double ori = 0;
<   for (uint8_t i = 0; i < station->m_nRate; i++)
<     {
<       WifiMode mode = GetSupported (station, i);
<       Time totalTxTime = GetCalcTxTime (mode) + m_sifs + m_difs;
<       if (i == GetMaxRate (station))
<         {
<           ori = 0;
<         }
<       else
<         {
<           WifiMode nextMode = GetSupported (station, i + 1);
<           Time nextTotalTxTime = GetCalcTxTime (nextMode) + m_sifs + m_difs;
<           nextCritical = 1 - (nextTotalTxTime.GetSeconds () / totalTxTime.GetSeconds ());
<           nextMtl = m_alpha * nextCritical;
<           ori = nextMtl / m_beta;
<         }
<       if (i == 0)
<         {
<           mtl = 1;
<         }
<       WifiRraaThresholds th;
<       th.m_ewnd = static_cast<uint32_t> (ceil (m_tau / totalTxTime.GetSeconds ()));
<       th.m_ori = ori;
<       th.m_mtl = mtl;
<       station->m_thresholds.push_back (std::make_pair (th, mode));
<       mtl = nextMtl;
<       NS_LOG_DEBUG (mode << " " << th.m_ewnd << " " << th.m_mtl << " " << th.m_ori);
275a217,219
>   station->m_failed = 0;
>   station->m_counter = GetThresholds (station, station->m_rate).ewnd;
>   station->m_lastReset = Simulator::Now ();
278,279c222,223
< void
< RraaWifiManager::ResetCountersBasic (RraaWifiRemoteStation *station)
---
> uint32_t
> RraaWifiManager::GetMaxRate (RraaWifiRemoteStation *station)
281,284c225
<   NS_LOG_FUNCTION (this << station);
<   station->m_nFailed = 0;
<   station->m_counter = GetThresholds (station, station->m_rateIndex).m_ewnd;
<   station->m_lastReset = Simulator::Now ();
---
>   return GetNSupported (station) - 1;
287,288c228,229
< uint8_t
< RraaWifiManager::GetMaxRate (RraaWifiRemoteStation *station) const
---
> uint32_t
> RraaWifiManager::GetMinRate (RraaWifiRemoteStation *station)
290c231
<   return station->m_nRate - 1;
---
>   return 0;
296d236
<   NS_LOG_FUNCTION (this << st);
302,303c242
<   NS_LOG_FUNCTION (this << st);
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
---
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
307c246
<   station->m_nFailed++;
---
>   station->m_failed++;
315d253
<   NS_LOG_FUNCTION (this << st << rxSnr << txMode);
322c260
<   NS_LOG_FUNCTION (this << st << ctsSnr << ctsMode << rtsSnr);
---
>   NS_LOG_DEBUG ("self=" << st << " rts ok");
326,327c264,265
< RraaWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> RraaWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                  double ackSnr, WifiMode ackMode, double dataSnr)
329,330c267
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
---
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
340d276
<   NS_LOG_FUNCTION (this << st);
346d281
<   NS_LOG_FUNCTION (this << st);
352,354c287,288
<   NS_LOG_FUNCTION (this << st);
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
356a291
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
359,361c294
<   CheckInit (station);
<   WifiMode mode = GetSupported (station, station->m_rateIndex);
<   if (m_currentRate != mode.GetDataRate (channelWidth))
---
>   if (!station->m_initialized)
363,364c296
<       NS_LOG_DEBUG ("New datarate: " << mode.GetDataRate (channelWidth));
<       m_currentRate = mode.GetDataRate (channelWidth);
---
>       ResetCountersBasic (station);
366c298
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (GetSupported (station, station->m_rate), GetDefaultTxPowerLevel (), GetLongRetryCount (station), false, 1, 0, channelWidth, GetAggregation (station), false);
372,374c304,305
<   NS_LOG_FUNCTION (this << st);
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
<   uint16_t channelWidth = GetChannelWidth (station);
---
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
>   uint32_t channelWidth = GetChannelWidth (station);
376a308
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
380d311
<   WifiMode mode;
383c314
<       mode = GetSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetSupported (st, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (st), false, 1, 0, channelWidth, GetAggregation (station), false);
387c318
<       mode = GetNonErpSupported (station, 0);
---
>       rtsTxVector = WifiTxVector (GetNonErpSupported (st, 0), GetDefaultTxPowerLevel (), GetShortRetryCount (st), false, 1, 0, channelWidth, GetAggregation (station), false);
389d319
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
395c325
<                             uint32_t size, bool normally)
---
>                             Ptr<const Packet> packet, bool normally)
397,399c327
<   NS_LOG_FUNCTION (this << st << size << normally);
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
<   CheckInit (station);
---
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
405c333
<   return station->m_adaptiveRtsOn;
---
>   return station->m_rtsOn;
411d338
<   NS_LOG_FUNCTION (this << station);
422,424c349,350
<   NS_LOG_FUNCTION (this << station);
<   WifiRraaThresholds thresholds = GetThresholds (station, station->m_rateIndex);
<   double ploss = (station->m_nFailed / thresholds.m_ewnd);
---
>   ThresholdsItem thresholds = GetThresholds (station, station->m_rate);
>   double ploss = (double) station->m_failed / (double) thresholds.ewnd;
426c352
<       || ploss > thresholds.m_mtl)
---
>       || ploss > thresholds.pmtl)
428c354,355
<       if (ploss > thresholds.m_mtl)
---
>       if (station->m_rate > GetMinRate (station)
>           && ploss > thresholds.pmtl)
430c357
<           station->m_rateIndex--;
---
>           station->m_rate--;
432,433c359,360
<       else if (station->m_rateIndex < GetMaxRate (station)
<                && ploss < thresholds.m_ori)
---
>       else if (station->m_rate < GetMaxRate (station)
>                && ploss < thresholds.pori)
435c362
<           station->m_rateIndex++;
---
>           station->m_rate++;
444c371
<   if (!station->m_adaptiveRtsOn
---
>   if (!station->m_rtsOn
447,448c374,375
<       station->m_adaptiveRtsWnd++;
<       station->m_rtsCounter = station->m_adaptiveRtsWnd;
---
>       station->m_rtsWnd++;
>       station->m_rtsCounter = station->m_rtsWnd;
450,451c377,378
<   else if ((station->m_adaptiveRtsOn && station->m_lastFrameFail)
<            || (!station->m_adaptiveRtsOn && !station->m_lastFrameFail))
---
>   else if ((station->m_rtsOn && station->m_lastFrameFail)
>            || (!station->m_rtsOn && !station->m_lastFrameFail))
453,454c380,381
<       station->m_adaptiveRtsWnd = station->m_adaptiveRtsWnd / 2;
<       station->m_rtsCounter = station->m_adaptiveRtsWnd;
---
>       station->m_rtsWnd = station->m_rtsWnd / 2;
>       station->m_rtsCounter = station->m_rtsWnd;
458c385
<       station->m_adaptiveRtsOn = true;
---
>       station->m_rtsOn = true;
463c390,505
<       station->m_adaptiveRtsOn = false;
---
>       station->m_rtsOn = false;
>     }
> }
> 
> struct RraaWifiManager::ThresholdsItem
> RraaWifiManager::GetThresholds (RraaWifiRemoteStation *station,
>                                 uint32_t rate) const
> {
>   WifiMode mode = GetSupported (station, rate);
>   return GetThresholds (mode, station);
> }
> 
> struct RraaWifiManager::ThresholdsItem
> RraaWifiManager::GetThresholds (WifiMode mode, RraaWifiRemoteStation *station) const
> {
>   uint8_t nss = 1;  // This RAA only supports 1 spatial stream
>   switch (mode.GetDataRate (GetChannelWidth (station), GetShortGuardInterval (station), nss) / 1000000)
>     {
>     case 54:
>       {
>         ThresholdsItem mode54 = {
>           54000000,
>           0.0,
>           m_pmtlfor54,
>           m_ewndfor54
>         };
>         return mode54;
>       } break;
>     case 48:
>       {
>         ThresholdsItem mode48 = {
>           48000000,
>           m_porifor48,
>           m_pmtlfor48,
>           m_ewndfor48
>         };
>         return mode48;
>       } break;
>     case 36:
>       {
>         ThresholdsItem mode36 = {
>           36000000,
>           m_porifor36,
>           m_pmtlfor36,
>           m_ewndfor36
>         };
>         return mode36;
>       } break;
>     case 24:
>       {
>         ThresholdsItem mode24 = {
>           24000000,
>           m_porifor24,
>           m_pmtlfor24,
>           m_ewndfor24
>         };
>         return mode24;
>       } break;
>     case 18:
>       {
>         ThresholdsItem mode18 = {
>           18000000,
>           m_porifor18,
>           m_pmtlfor18,
>           m_ewndfor18
>         };
>         return mode18;
>       } break;
>     case 12:
>       {
>         ThresholdsItem mode12 = {
>           12000000,
>           m_porifor12,
>           m_pmtlfor12,
>           m_ewndfor12
>         };
>         return mode12;
>       } break;
>     case 9:
>       {
>         ThresholdsItem mode9 =  {
>           9000000,
>           m_porifor9,
>           m_pmtlfor9,
>           m_ewndfor9
>         };
>         return mode9;
>       } break;
>     case 6:
>       {
>         ThresholdsItem mode6 =  {
>           6000000,
>           m_porifor6,
>           1.0,
>           m_ewndfor6
>         };
>         return mode6;
>       } break;
>     }
>   NS_ASSERT_MSG (false, "Thresholds for an unknown mode are asked (" << mode << ")");
>   return ThresholdsItem ();
> }
> 
> bool
> RraaWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
> void
> RraaWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
467,468c509,510
< WifiRraaThresholds
< RraaWifiManager::GetThresholds (RraaWifiRemoteStation *station, uint8_t index) const
---
> void
> RraaWifiManager::SetVhtSupported (bool enable)
470,472c512,516
<   NS_LOG_FUNCTION (this << station << +index);
<   WifiMode mode = GetSupported (station, index);
<   return GetThresholds (station, mode);
---
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/rraa-wifi-manager.h ../../ns-3-dev/src/wifi/model/rraa-wifi-manager.h
25d24
< #include "ns3/traced-value.h"
32,44d30
< /// WifiRraaThresholds structure
< struct WifiRraaThresholds
<   {
<     double m_ori; ///< Opportunistic Rate Increase threshold
<     double m_mtl; ///< Maximum Tolerable Loss threshold
<     uint32_t m_ewnd; ///< Evaluation Window
<   };
< 
< /**
<  * List of thresholds for each mode.
<  */
< typedef std::vector<std::pair<WifiRraaThresholds, WifiMode> > RraaThresholdsTable;
< 
54,56c40,42
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
---
>  * This RAA does not support HT or VHT modes and will error exit
>  * if the user tries to configure this RAA with a Wi-Fi MAC that
>  * has VhtSupported or HtSupported set.
61,64d46
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
71,73c53,54
<   virtual void SetupPhy (const Ptr<WifiPhy> phy);
<   virtual void SetupMac (const Ptr<WifiMac> mac);
< 
---
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
76,92c57,81
<   // Overridden from base class.
<   void DoInitialize (void);
<   WifiRemoteStation * DoCreateStation (void) const;
<   void DoReportRxOk (WifiRemoteStation *station,
<                      double rxSnr, WifiMode txMode);
<   void DoReportRtsFailed (WifiRemoteStation *station);
<   void DoReportDataFailed (WifiRemoteStation *station);
<   void DoReportRtsOk (WifiRemoteStation *station,
<                       double ctsSnr, WifiMode ctsMode, double rtsSnr);
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportFinalRtsFailed (WifiRemoteStation *station);
<   void DoReportFinalDataFailed (WifiRemoteStation *station);
<   WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
<   WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
<   bool DoNeedRts (WifiRemoteStation *st,
<                   uint32_t size, bool normally);
---
>   struct ThresholdsItem
>   {
>     uint32_t datarate;
>     double pori;
>     double pmtl;
>     uint32_t ewnd;
>   };
> 
>   //overriden from base class
>   virtual WifiRemoteStation * DoCreateStation (void) const;
>   virtual void DoReportRxOk (WifiRemoteStation *station,
>                              double rxSnr, WifiMode txMode);
>   virtual void DoReportRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportDataFailed (WifiRemoteStation *station);
>   virtual void DoReportRtsOk (WifiRemoteStation *station,
>                               double ctsSnr, WifiMode ctsMode, double rtsSnr);
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
>   virtual void DoReportFinalRtsFailed (WifiRemoteStation *station);
>   virtual void DoReportFinalDataFailed (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetDataTxVector (WifiRemoteStation *station);
>   virtual WifiTxVector DoGetRtsTxVector (WifiRemoteStation *station);
>   virtual bool DoNeedRts (WifiRemoteStation *st,
>                           Ptr<const Packet> packet, bool normally);
>   virtual bool IsLowLatency (void) const;
94,98d82
<   /**
<    * Check for initializations.
<    * \param station The remote station.
<    */
<   void CheckInit (RraaWifiRemoteStation *station);
103c87
<    * \param station the remote station
---
>    * \param station
107c91,100
<   uint8_t GetMaxRate (RraaWifiRemoteStation *station) const;
---
>   uint32_t GetMaxRate (RraaWifiRemoteStation *station);
>   /**
>    * Return the index for the minimum transmission rate for
>    * the given station.
>    *
>    * \param station
>    *
>    * \return the index for the minimum transmission rate
>    */
>   uint32_t GetMinRate (RraaWifiRemoteStation *station);
109c102
<    * Check if the counter should be reset.
---
>    * Check if the counter should be resetted.
111c104
<    * \param station the remote station
---
>    * \param station
118c111
<    * \param station the remote station
---
>    * \param station
124c117
<    * \param station the remote station
---
>    * \param station
130c123
<    * \param station the remote station
---
>    * \param station
134c127
<    * Initialize the thresholds internal list for the given station.
---
>    * Get a threshold for the given mode.
136,152c129,130
<    * \param station the remote station
<    */
<   void InitThresholds (RraaWifiRemoteStation *station);
<   /**
<    * Get the thresholds for the given station and mode.
<    *
<    * \param station the remote station
<    * \param mode the WifiMode
<    *
<    * \return the RRAA thresholds
<    */
<   WifiRraaThresholds GetThresholds (RraaWifiRemoteStation *station, WifiMode mode) const;
<   /**
<    * Get the thresholds for the given station and mode index.
<    *
<    * \param station the remote station
<    * \param index the mode index in the supported rates
---
>    * \param mode
>    * \param station
154c132
<    * \return the RRAA thresholds
---
>    * \return threshold
156c134
<   WifiRraaThresholds GetThresholds (RraaWifiRemoteStation *station, uint8_t index) const;
---
>   struct ThresholdsItem GetThresholds (WifiMode mode, RraaWifiRemoteStation *station) const;
158,192c136,168
<    * Get the estimated TxTime of a packet with a given mode.
<    *
<    * \param mode the WifiMode
<    *
<    * \return the estimated TX time
<    */
<   Time GetCalcTxTime (WifiMode mode) const;
<   /**
<    * Add transmission time for the given mode to an internal list.
<    *
<    * \param mode the WifiMode
<    * \param t transmission time
<    */
<   void AddCalcTxTime (WifiMode mode, Time t);
<   /**
<    * typedef for a vector of a pair of Time, WifiMode.
<    * Essentially a list for WifiMode and its corresponding transmission time
<    * to transmit a reference packet.
<    */
<   typedef std::vector<std::pair<Time,WifiMode> > TxTime;
< 
<   TxTime m_calcTxTime;     //!< To hold all the calculated TxTime for all modes.
<   Time m_sifs;             //!< Value of SIFS configured in the device.
<   Time m_difs;             //!< Value of DIFS configured in the device.
< 
<   uint32_t m_frameLength;  //!< Data frame length used for calculate mode TxTime.
<   uint32_t m_ackLength;    //!< Ack frame length used for calculate mode TxTime.
< 
<   bool m_basic;    ///< basic
<   Time m_timeout;  ///< timeout
<   double m_alpha;  //!< Alpha value for RRAA (value for calculating MTL threshold)
<   double m_beta;   //!< Beta value for RRAA (value for calculating ORI threshold).
<   double m_tau;    //!< Tau value for RRAA (value for calculating EWND size).
< 
<   TracedValue<uint64_t> m_currentRate; //!< Trace rate changes
---
>    * Get a threshold for the given station and mode index.
>    *
>    * \param station
>    * \param rate
>    *
>    * \return threshold
>    */
>   struct ThresholdsItem GetThresholds (RraaWifiRemoteStation *station, uint32_t rate) const;
> 
>   bool m_basic;
>   Time m_timeout;
>   uint32_t m_ewndfor54;
>   uint32_t m_ewndfor48;
>   uint32_t m_ewndfor36;
>   uint32_t m_ewndfor24;
>   uint32_t m_ewndfor18;
>   uint32_t m_ewndfor12;
>   uint32_t m_ewndfor9;
>   uint32_t m_ewndfor6;
>   double m_porifor48;
>   double m_porifor36;
>   double m_porifor24;
>   double m_porifor18;
>   double m_porifor12;
>   double m_porifor9;
>   double m_porifor6;
>   double m_pmtlfor54;
>   double m_pmtlfor48;
>   double m_pmtlfor36;
>   double m_pmtlfor24;
>   double m_pmtlfor18;
>   double m_pmtlfor12;
>   double m_pmtlfor9;
Only in ../../NS3-WiGig/src/wifi/model: rrpaa-wifi-manager.cc
Only in ../../NS3-WiGig/src/wifi/model: rrpaa-wifi-manager.h
Only in ../../NS3-WiGig/src/wifi/model: sensitivity-lut.cc
Only in ../../NS3-WiGig/src/wifi/model: sensitivity-lut.h
Only in ../../NS3-WiGig/src/wifi/model: sensitivity-model-60-ghz.cc
Only in ../../NS3-WiGig/src/wifi/model: sensitivity-model-60-ghz.h
Only in ../../NS3-WiGig/src/wifi/model: simple-frame-capture-model.cc
Only in ../../NS3-WiGig/src/wifi/model: simple-frame-capture-model.h
diff ../../NS3-WiGig/src/wifi/model/snr-tag.cc ../../ns-3-dev/src/wifi/model/snr-tag.cc
25d24
< #include "ns3/double.h"
26a26,27
> #include "ns3/tag.h"
> #include "ns3/double.h"
39c40
<     .AddAttribute ("Snr", "The SNR of the last packet received",
---
>     .AddAttribute ("Snr", "The snr of the last packet received",
54a56,60
> {
> }
> 
> SnrTag::SnrTag (double snr)
>   : m_snr (snr)
diff ../../NS3-WiGig/src/wifi/model/snr-tag.h ../../ns-3-dev/src/wifi/model/snr-tag.h
28c28
< #include "ns3/tag.h"
---
> #include "ns3/packet.h"
37,40d36
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
42c38
<   TypeId GetInstanceTypeId (void) const;
---
>   virtual TypeId GetInstanceTypeId (void) const;
45c41
<    * Create a SnrTag with the default SNR 0
---
>    * Create a SnrTag with the default snr 0
49,52c45,54
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (TagBuffer i) const;
<   void Deserialize (TagBuffer i);
<   void Print (std::ostream &os) const;
---
>   /**
>    * Create a SnrTag with the given snr value
>    * \param snr the given SNR value
>    */
>   SnrTag (double snr);
> 
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (TagBuffer i) const;
>   virtual void Deserialize (TagBuffer i);
>   virtual void Print (std::ostream &os) const;
57c59
<    * \param snr the value of the SNR to set in linear scale
---
>    * \param snr the value of the snr to set
63c65
<    * \return the SNR value in linear scale
---
>    * \return the SNR value
69c71
<   double m_snr;  //!< SNR value in linear scale
---
>   double m_snr;  //!< SNR value
73d74
< 
Only in ../../NS3-WiGig/src/wifi/model: spectrum-dmg-wifi-phy.cc
Only in ../../NS3-WiGig/src/wifi/model: spectrum-dmg-wifi-phy.h
diff ../../NS3-WiGig/src/wifi/model/spectrum-wifi-phy.cc ../../ns-3-dev/src/wifi/model/spectrum-wifi-phy.cc
25a26,28
> #include "spectrum-wifi-phy.h"
> #include "ns3/spectrum-channel.h"
> #include "ns3/spectrum-value.h"
26a30,32
> #include "wifi-phy-state-helper.h"
> #include "ns3/simulator.h"
> #include "ns3/assert.h"
27a34
> #include "ns3/double.h"
29,31c36
< #include "ns3/net-device.h"
< #include "ns3/node.h"
< #include "spectrum-wifi-phy.h"
---
> #include "ampdu-tag.h"
33,36c38,40
< #include "wifi-spectrum-phy-interface.h"
< #include "wifi-utils.h"
< #include "wifi-ppdu.h"
< #include "wifi-psdu.h"
---
> #include "wifi-phy-tag.h"
> #include "ns3/antenna-model.h"
> #include <cmath>
79d82
<   WifiPhy::DoDispose ();
97a101,206
> bool
> SpectrumWifiPhy::DoChannelSwitch (uint16_t nch)
> {
>   if (IsInitialized () == false)
>     {
>       //this is not channel switch, this is initialization
>       NS_LOG_DEBUG ("start at channel " << nch);
>       return true;
>     }
> 
>   NS_ASSERT (!IsStateSwitching ());
>   switch (m_state->GetState ())
>     {
>     case SpectrumWifiPhy::RX:
>       NS_LOG_DEBUG ("drop packet because of channel switching while reception");
>       m_endPlcpRxEvent.Cancel ();
>       m_endRxEvent.Cancel ();
>       goto switchChannel;
>       break;
>     case SpectrumWifiPhy::TX:
>       NS_LOG_DEBUG ("channel switching postponed until end of current transmission");
>       Simulator::Schedule (GetDelayUntilIdle (), &WifiPhy::SetChannelNumber, this, nch);
>       break;
>     case SpectrumWifiPhy::CCA_BUSY:
>     case SpectrumWifiPhy::IDLE:
>       goto switchChannel;
>       break;
>     case SpectrumWifiPhy::SLEEP:
>       NS_LOG_DEBUG ("channel switching ignored in sleep mode");
>       break;
>     default:
>       NS_ASSERT (false);
>       break;
>     }
> 
>   return false;
> 
> switchChannel:
> 
>   NS_LOG_DEBUG ("switching channel " << GetChannelNumber () << " -> " << nch);
>   m_rxSpectrumModel = WifiSpectrumValueHelper::GetSpectrumModel (GetFrequency (), GetChannelWidth ());
>   m_state->SwitchToChannelSwitching (GetChannelSwitchDelay ());
>   m_interference.EraseEvents ();
>   /*
>    * Needed here to be able to correctly sensed the medium for the first
>    * time after the switching. The actual switching is not performed until
>    * after m_channelSwitchDelay. Packets received during the switching
>    * state are added to the event list and are employed later to figure
>    * out the state of the medium after the switching.
>    */
>   return true;
> }
> 
> bool
> SpectrumWifiPhy::DoFrequencySwitch (uint32_t frequency)
> {
>   if (IsInitialized () == false)
>     {
>       //this is not channel switch, this is initialization
>       NS_LOG_DEBUG ("start at frequency " << frequency);
>       return true;
>     }
> 
>   NS_ASSERT (!IsStateSwitching ());
>   switch (m_state->GetState ())
>     {
>     case SpectrumWifiPhy::RX:
>       NS_LOG_DEBUG ("drop packet because of channel/frequency switching while reception");
>       m_endPlcpRxEvent.Cancel ();
>       m_endRxEvent.Cancel ();
>       goto switchFrequency;
>       break;
>     case SpectrumWifiPhy::TX:
>       NS_LOG_DEBUG ("channel/frequency switching postponed until end of current transmission");
>       Simulator::Schedule (GetDelayUntilIdle (), &WifiPhy::SetFrequency, this, frequency);
>       break;
>     case SpectrumWifiPhy::CCA_BUSY:
>     case SpectrumWifiPhy::IDLE:
>       goto switchFrequency;
>       break;
>     case SpectrumWifiPhy::SLEEP:
>       NS_LOG_DEBUG ("frequency switching ignored in sleep mode");
>       break;
>     default:
>       NS_ASSERT (false);
>       break;
>     }
> 
>   return false;
> 
> switchFrequency:
> 
>   NS_LOG_DEBUG ("switching frequency " << GetFrequency () << " -> " << frequency);
>   m_rxSpectrumModel = WifiSpectrumValueHelper::GetSpectrumModel (GetFrequency (), GetChannelWidth ());
>   m_state->SwitchToChannelSwitching (GetChannelSwitchDelay ());
>   m_interference.EraseEvents ();
>   /*
>    * Needed here to be able to correctly sensed the medium for the first
>    * time after the switching. The actual switching is not performed until
>    * after m_channelSwitchDelay. Packets received during the switching
>    * state are added to the event list and are employed later to figure
>    * out the state of the medium after the switching.
>    */
>   return true;
> }
> 
115,117c224,225
<           uint16_t channelWidth = GetChannelWidth ();
<           NS_LOG_DEBUG ("Creating spectrum model from frequency/width pair of (" << GetFrequency () << ", " << channelWidth << ")");
<           m_rxSpectrumModel = WifiSpectrumValueHelper::GetSpectrumModel (GetFrequency (), channelWidth, GetBandBandwidth (), GetGuardBandwidth (channelWidth));
---
>           NS_LOG_DEBUG ("Creating spectrum model from frequency/width pair of (" << GetFrequency () << ", " << GetChannelWidth () << ")");
>           m_rxSpectrumModel = WifiSpectrumValueHelper::GetSpectrumModel (GetFrequency (), GetChannelWidth ());
123c231
< Ptr<Channel>
---
> Ptr<WifiChannel>
126c234
<   return m_channel;
---
>   return Ptr<WifiChannel> (0);
130c238
< SpectrumWifiPhy::SetChannel (const Ptr<SpectrumChannel> channel)
---
> SpectrumWifiPhy::SetChannel (Ptr<SpectrumChannel> channel)
136c244
< SpectrumWifiPhy::ResetSpectrumModel (void)
---
> SpectrumWifiPhy::SetPacketReceivedCallback (RxCallback callback)
138,145c246
<   NS_LOG_FUNCTION (this);
<   NS_ASSERT_MSG (IsInitialized (), "Executing method before run-time");
<   uint16_t channelWidth = GetChannelWidth ();
<   NS_LOG_DEBUG ("Run-time change of spectrum model from frequency/width pair of (" << GetFrequency () << ", " << channelWidth << ")");
<   // Replace existing spectrum model with new one, and must call AddRx ()
<   // on the SpectrumChannel to provide this new spectrum model to it
<   m_rxSpectrumModel = WifiSpectrumValueHelper::GetSpectrumModel (GetFrequency (), channelWidth, GetBandBandwidth (), GetGuardBandwidth (channelWidth));
<   m_channel->AddRx (m_wifiSpectrumPhyInterface);
---
>   m_rxCallback = callback;
149c250
< SpectrumWifiPhy::SetChannelNumber (uint8_t nch)
---
> SpectrumWifiPhy::AddOperationalChannel (uint16_t channelNumber)
151,153c252,260
<   NS_LOG_FUNCTION (this << +nch);
<   WifiPhy::SetChannelNumber (nch);
<   if (IsInitialized ())
---
>   m_operationalChannelList.push_back (channelNumber);
> }
> 
> std::vector<uint16_t>
> SpectrumWifiPhy::GetOperationalChannelList () const
> {
>   std::vector<uint16_t> channelList;
>   channelList.push_back (GetChannelNumber ());  // first channel of list
>   for (std::vector<uint16_t>::size_type i = 0; i != m_operationalChannelList.size (); i++)
155c262,265
<       ResetSpectrumModel ();
---
>       if (m_operationalChannelList[i] != GetChannelNumber ())
>         {
>           channelList.push_back (m_operationalChannelList[i]);
>         }
156a267
>   return channelList;
160c271
< SpectrumWifiPhy::SetFrequency (uint16_t freq)
---
> SpectrumWifiPhy::ClearOperationalChannelList ()
162,164c273,280
<   NS_LOG_FUNCTION (this << freq);
<   WifiPhy::SetFrequency (freq);
<   if (IsInitialized ())
---
>   m_operationalChannelList.clear ();
> }
> 
> void
> SpectrumWifiPhy::SetSleepMode (void)
> {
>   NS_LOG_FUNCTION (this);
>   switch (m_state->GetState ())
166c282,304
<       ResetSpectrumModel ();
---
>     case SpectrumWifiPhy::TX:
>       NS_LOG_DEBUG ("setting sleep mode postponed until end of current transmission");
>       Simulator::Schedule (GetDelayUntilIdle (), &SpectrumWifiPhy::SetSleepMode, this);
>       break;
>     case SpectrumWifiPhy::RX:
>       NS_LOG_DEBUG ("setting sleep mode postponed until end of current reception");
>       Simulator::Schedule (GetDelayUntilIdle (), &SpectrumWifiPhy::SetSleepMode, this);
>       break;
>     case SpectrumWifiPhy::SWITCHING:
>       NS_LOG_DEBUG ("setting sleep mode postponed until end of channel switching");
>       Simulator::Schedule (GetDelayUntilIdle (), &SpectrumWifiPhy::SetSleepMode, this);
>       break;
>     case SpectrumWifiPhy::CCA_BUSY:
>     case SpectrumWifiPhy::IDLE:
>       NS_LOG_DEBUG ("setting sleep mode");
>       m_state->SwitchToSleep ();
>       break;
>     case SpectrumWifiPhy::SLEEP:
>       NS_LOG_DEBUG ("already in sleep mode");
>       break;
>     default:
>       NS_ASSERT (false);
>       break;
171c309
< SpectrumWifiPhy::SetChannelWidth (uint16_t channelwidth)
---
> SpectrumWifiPhy::ResumeFromSleep (void)
173,175c311,312
<   NS_LOG_FUNCTION (this << channelwidth);
<   WifiPhy::SetChannelWidth (channelwidth);
<   if (IsInitialized ())
---
>   NS_LOG_FUNCTION (this);
>   switch (m_state->GetState ())
177c314,334
<       ResetSpectrumModel ();
---
>     case SpectrumWifiPhy::TX:
>     case SpectrumWifiPhy::RX:
>     case SpectrumWifiPhy::IDLE:
>     case SpectrumWifiPhy::CCA_BUSY:
>     case SpectrumWifiPhy::SWITCHING:
>       {
>         NS_LOG_DEBUG ("not in sleep mode, there is nothing to resume");
>         break;
>       }
>     case SpectrumWifiPhy::SLEEP:
>       {
>         NS_LOG_DEBUG ("resuming from sleep mode");
>         Time delayUntilCcaEnd = m_interference.GetEnergyDuration (DbmToW (GetCcaMode1Threshold ()));
>         m_state->SwitchFromSleep (delayUntilCcaEnd);
>         break;
>       }
>     default:
>       {
>         NS_ASSERT (false);
>         break;
>       }
182c339,345
< SpectrumWifiPhy::ConfigureStandard (WifiPhyStandard standard)
---
> SpectrumWifiPhy::SetReceiveOkCallback (RxOkCallback callback)
> {
>   m_state->SetReceiveOkCallback (callback);
> }
> 
> void
> SpectrumWifiPhy::SetReceiveErrorCallback (RxErrorCallback callback)
184,186c347,360
<   NS_LOG_FUNCTION (this << standard);
<   WifiPhy::ConfigureStandard (standard);
<   if (IsInitialized ())
---
>   m_state->SetReceiveErrorCallback (callback);
> }
> 
> void
> SpectrumWifiPhy::SwitchMaybeToCcaBusy (void)
> {
>   NS_LOG_FUNCTION (this);
>   //We are here because we have received the first bit of a packet and we are
>   //not going to be able to synchronize on it
>   //In this model, CCA becomes busy when the aggregation of all signals as
>   //tracked by the InterferenceHelper class is higher than the CcaBusyThreshold
> 
>   Time delayUntilCcaEnd = m_interference.GetEnergyDuration (DbmToW (GetCcaMode1Threshold ()));
>   if (!delayUntilCcaEnd.IsZero ())
188c362,363
<       ResetSpectrumModel ();
---
>       NS_LOG_DEBUG ("Calling SwitchMaybeToCcaBusy for " << delayUntilCcaEnd.As (Time::S));
>       m_state->SwitchMaybeToCcaBusy (delayUntilCcaEnd);
208,209c383
<   uint16_t channelWidth = GetChannelWidth ();
<   Ptr<SpectrumValue> filter = WifiSpectrumValueHelper::CreateRfFilter (GetFrequency (), channelWidth, GetBandBandwidth (), GetGuardBandwidth (channelWidth));
---
>   Ptr<SpectrumValue> filter = WifiSpectrumValueHelper::CreateRfFilter (GetFrequency (), GetChannelWidth ());
220,227d393
< 
<   // Do no further processing if signal is too weak
<   // Current implementation assumes constant RX power over the PPDU duration
<   if (WToDbm (rxPowerW) < GetRxSensitivity ())
<     {
<       NS_LOG_INFO ("Received signal too weak to process: " << WToDbm (rxPowerW) << " dBm");
<       return;
<     }
244,245c410,616
<   Ptr<WifiPpdu> ppdu = Copy (wifiRxParams->ppdu);
<   StartReceivePreamble (ppdu, rxPowerW);
---
>   Ptr<Packet> packet = wifiRxParams->packet->Copy ();
>   WifiPhyTag tag;
>   bool found = packet->PeekPacketTag (tag);
>   if (!found)
>     {
>       NS_FATAL_ERROR ("Received Wi-Fi Spectrum Signal with no WifiPhyTag");
>       return;
>     }
> 
>   WifiTxVector txVector = tag.GetWifiTxVector ();
>   if (txVector.GetNss () > GetNumberOfReceiveAntennas ())
>     {
>       /* failure. */
>       NotifyRxDrop (packet);
>       NS_LOG_INFO ("Reception ends in failure because less RX antennas than number of spatial streams");
>       SwitchMaybeToCcaBusy ();
>       return;
>     }
> 
>   enum WifiPreamble preamble = tag.GetWifiPreamble ();
>   enum mpduType mpdutype = tag.GetMpduType ();
> 
>   // At this point forward, processing parallels that of
>   // YansWifiPhy::StartReceivePreambleAndHeader ()
> 
>   AmpduTag ampduTag;
>   Time endRx = Simulator::Now () + rxDuration;
>   Time preambleAndHeaderDuration = CalculatePlcpPreambleAndHeaderDuration (txVector, preamble);
> 
>   Ptr<InterferenceHelper::Event> event;
>   event = m_interference.Add (packet->GetSize (),
>                               txVector,
>                               preamble,
>                               rxDuration,
>                               rxPowerW);
> 
>   switch (m_state->GetState ())
>     {
>     case SpectrumWifiPhy::SWITCHING:
>       NS_LOG_DEBUG ("drop packet because of channel switching");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
>       /*
>        * Packets received on the upcoming channel are added to the event list
>        * during the switching state. This way the medium can be correctly sensed
>        * when the device listens to the channel for the first time after the
>        * switching e.g. after channel switching, the channel may be sensed as
>        * busy due to other devices' tramissions started before the end of
>        * the switching.
>        */
>       if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
>         {
>           //that packet will be noise _after_ the completion of the
>           //channel switching.
>           SwitchMaybeToCcaBusy ();
>           return;
>         }
>       break;
>     case SpectrumWifiPhy::RX:
>       NS_LOG_DEBUG ("drop packet because already in Rx (power=" <<
>                     rxPowerW << "W)");
>       NotifyRxDrop (packet);
>       if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
>         {
>           //that packet will be noise _after_ the reception of the
>           //currently-received packet.
>           SwitchMaybeToCcaBusy ();
>           return;
>         }
>       break;
>     case SpectrumWifiPhy::TX:
>       NS_LOG_DEBUG ("drop packet because already in Tx (power=" <<
>                     rxPowerW << "W)");
>       NotifyRxDrop (packet);
>       if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
>         {
>           //that packet will be noise _after_ the transmission of the
>           //currently-transmitted packet.
>           SwitchMaybeToCcaBusy ();
>           return;
>         }
>       break;
>     case SpectrumWifiPhy::CCA_BUSY:
>     case SpectrumWifiPhy::IDLE:
>       if (rxPowerW > GetEdThresholdW ()) //checked here, no need to check in the payload reception (current implementation assumes constant rx power over the packet duration)
>         {
>           if (preamble == WIFI_PREAMBLE_NONE && m_mpdusNum == 0)
>             {
>               NS_LOG_DEBUG ("drop packet because no preamble has been received");
>               NotifyRxDrop (packet);
>               SwitchMaybeToCcaBusy ();
>               return;
>             }
>           else if (preamble == WIFI_PREAMBLE_NONE && m_plcpSuccess == false) //A-MPDU reception fails
>             {
>               NS_LOG_DEBUG ("Drop MPDU because no plcp has been received");
>               NotifyRxDrop (packet);
>               SwitchMaybeToCcaBusy ();
>               return;
>             }
>           else if (preamble != WIFI_PREAMBLE_NONE && packet->PeekPacketTag (ampduTag) && m_mpdusNum == 0)
>             {
>               //received the first MPDU in an MPDU
>               m_mpdusNum = ampduTag.GetRemainingNbOfMpdus () - 1;
>               m_rxMpduReferenceNumber++;
>             }
>           else if (preamble == WIFI_PREAMBLE_NONE && packet->PeekPacketTag (ampduTag) && m_mpdusNum > 0)
>             {
>               //received the other MPDUs that are part of the A-MPDU
>               if (ampduTag.GetRemainingNbOfMpdus () < m_mpdusNum)
>                 {
>                   NS_LOG_DEBUG ("Missing MPDU from the A-MPDU " << m_mpdusNum - ampduTag.GetRemainingNbOfMpdus ());
>                   m_mpdusNum = ampduTag.GetRemainingNbOfMpdus ();
>                 }
>               else
>                 {
>                   m_mpdusNum--;
>                 }
>             }
>           else if (preamble != WIFI_PREAMBLE_NONE && m_mpdusNum > 0 )
>             {
>               NS_LOG_DEBUG ("Didn't receive the last MPDUs from an A-MPDU " << m_mpdusNum);
>               m_mpdusNum = 0;
>             }
> 
>           NS_LOG_DEBUG ("sync to signal (power=" << rxPowerW << "W)");
>           //sync to signal
>           m_state->SwitchToRx (rxDuration);
>           NS_ASSERT (m_endPlcpRxEvent.IsExpired ());
>           NotifyRxBegin (packet);
>           m_interference.NotifyRxStart ();
> 
>           if (preamble != WIFI_PREAMBLE_NONE)
>             {
>               NS_ASSERT (m_endPlcpRxEvent.IsExpired ());
>               m_endPlcpRxEvent = Simulator::Schedule (preambleAndHeaderDuration, &SpectrumWifiPhy::StartReceivePacket, this,
>                                                       packet, txVector, preamble, mpdutype, event);
>             }
> 
>           NS_ASSERT (m_endRxEvent.IsExpired ());
>           m_endRxEvent = Simulator::Schedule (rxDuration, &SpectrumWifiPhy::EndReceive, this,
>                                               packet, preamble, mpdutype, event);
>         }
>       else
>         {
>           NS_LOG_DEBUG ("drop packet because signal power too Small (" <<
>                         rxPowerW << "<" << GetEdThresholdW () << ")");
>           NotifyRxDrop (packet);
>           m_plcpSuccess = false;
>           SwitchMaybeToCcaBusy ();
>           return;
>         }
>       break;
>     case SpectrumWifiPhy::SLEEP:
>       NS_LOG_DEBUG ("drop packet because in sleep mode");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
>       break;
>     }
> 
>   return;
> }
> 
> void
> SpectrumWifiPhy::StartReceivePacket (Ptr<Packet> packet,
>                                      WifiTxVector txVector,
>                                      enum WifiPreamble preamble,
>                                      enum mpduType mpdutype,
>                                      Ptr<InterferenceHelper::Event> event)
> {
>   NS_LOG_FUNCTION (this << packet << txVector.GetMode () << preamble << (uint32_t)mpdutype);
>   NS_ASSERT (IsStateRx ());
>   NS_ASSERT (m_endPlcpRxEvent.IsExpired ());
>   AmpduTag ampduTag;
>   WifiMode txMode = txVector.GetMode ();
> 
>   struct InterferenceHelper::SnrPer snrPer;
>   snrPer = m_interference.CalculatePlcpHeaderSnrPer (event);
> 
>   NS_LOG_DEBUG ("snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per);
> 
>   if (m_random->GetValue () > snrPer.per) //plcp reception succeeded
>     {
>       if (IsModeSupported (txMode) || IsMcsSupported (txMode))
>         {
>           NS_LOG_DEBUG ("receiving plcp payload"); //endReceive is already scheduled
>           m_plcpSuccess = true;
>         }
>       else //mode is not allowed
>         {
>           NS_LOG_DEBUG ("drop packet because it was sent using an unsupported mode (" << txMode << ")");
>           NotifyRxDrop (packet);
>           m_plcpSuccess = false;
>         }
>     }
>   else //plcp reception failed
>     {
>       NS_LOG_DEBUG ("drop packet because plcp preamble/header reception failed");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
>     }
> }
> 
> Ptr<WifiSpectrumPhyInterface>
> SpectrumWifiPhy::GetSpectrumPhy (void) const
> {
>   return m_wifiSpectrumPhyInterface;
255c626
< SpectrumWifiPhy::SetAntenna (const Ptr<AntennaModel> a)
---
> SpectrumWifiPhy::SetAntenna (Ptr<AntennaModel> a)
269a641,646
> void
> SpectrumWifiPhy::SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, WifiPreamble preamble)
> {
>   SendPacket (packet, txVector, preamble, NORMAL_MPDU);
> }
> 
271c648
< SpectrumWifiPhy::GetTxPowerSpectralDensity (uint16_t centerFrequency, uint16_t channelWidth, double txPowerW, WifiModulationClass modulationClass) const
---
> SpectrumWifiPhy::GetTxPowerSpectralDensity (uint32_t centerFrequency, uint32_t channelWidth, double txPowerW) const
275c652
<   switch (modulationClass)
---
>   switch (GetStandard ())
277,288c654,662
<     case WIFI_MOD_CLASS_OFDM:
<     case WIFI_MOD_CLASS_ERP_OFDM:
<       v = WifiSpectrumValueHelper::CreateOfdmTxPowerSpectralDensity (centerFrequency, channelWidth, txPowerW, GetGuardBandwidth (channelWidth));
<       break;
<     case WIFI_MOD_CLASS_DSSS:
<     case WIFI_MOD_CLASS_HR_DSSS:
<       NS_ABORT_MSG_IF (channelWidth != 22, "Invalid channel width for DSSS");
<       v = WifiSpectrumValueHelper::CreateDsssTxPowerSpectralDensity (centerFrequency, txPowerW, GetGuardBandwidth (channelWidth));
<       break;
<     case WIFI_MOD_CLASS_HT:
<     case WIFI_MOD_CLASS_VHT:
<       v = WifiSpectrumValueHelper::CreateHtOfdmTxPowerSpectralDensity (centerFrequency, channelWidth, txPowerW, GetGuardBandwidth (channelWidth));
---
>     case WIFI_PHY_STANDARD_80211a:
>     case WIFI_PHY_STANDARD_80211g:
>     case WIFI_PHY_STANDARD_holland:
>     case WIFI_PHY_STANDARD_80211_10MHZ:
>     case WIFI_PHY_STANDARD_80211_5MHZ:
>       v = WifiSpectrumValueHelper::CreateOfdmTxPowerSpectralDensity (centerFrequency, channelWidth, txPowerW);
>       break;
>     case WIFI_PHY_STANDARD_80211b:
>       v = WifiSpectrumValueHelper::CreateDsssTxPowerSpectralDensity (centerFrequency, txPowerW);
290,291c664,667
<     case WIFI_MOD_CLASS_HE:
<       v = WifiSpectrumValueHelper::CreateHeOfdmTxPowerSpectralDensity (centerFrequency, channelWidth, txPowerW, GetGuardBandwidth (channelWidth));
---
>     case WIFI_PHY_STANDARD_80211n_2_4GHZ:
>     case WIFI_PHY_STANDARD_80211n_5GHZ:
>     case WIFI_PHY_STANDARD_80211ac:
>       v = WifiSpectrumValueHelper::CreateHtOfdmTxPowerSpectralDensity (centerFrequency, channelWidth, txPowerW);
294c670
<       NS_FATAL_ERROR ("modulation class unknown: " << modulationClass);
---
>       NS_FATAL_ERROR ("Standard unknown: " << GetStandard ());
300,301c676,677
< uint16_t
< SpectrumWifiPhy::GetCenterFrequencyForChannelWidth (WifiTxVector txVector) const
---
> void
> SpectrumWifiPhy::SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, WifiPreamble preamble, enum mpduType mpdutype)
303,307c679,690
<   NS_LOG_FUNCTION (this << txVector);
<   uint16_t centerFrequencyForSupportedWidth = GetFrequency ();
<   uint16_t supportedWidth = GetChannelWidth ();
<   uint16_t currentWidth = txVector.GetChannelWidth ();
<   if (currentWidth != supportedWidth)
---
>   NS_LOG_FUNCTION (this << packet << txVector.GetMode ()
>                         << txVector.GetMode ().GetDataRate (txVector)
>                         << preamble << (uint32_t)txVector.GetTxPowerLevel () << (uint32_t)mpdutype);
>   /* Transmission can happen if:
>    *  - we are syncing on a packet. It is the responsability of the
>    *    MAC layer to avoid doing this but the PHY does nothing to
>    *    prevent it.
>    *  - we are idle
>    */
>   NS_ASSERT (!m_state->IsStateTx () && !m_state->IsStateSwitching ());
> 
>   if (m_state->IsStateSleep ())
309,310c692,694
<       uint16_t startingFrequency = centerFrequencyForSupportedWidth - (supportedWidth / 2);
<       return startingFrequency + (currentWidth / 2); // primary channel is in the lower part (for the time being)
---
>       NS_LOG_DEBUG ("Dropping packet because in sleep mode");
>       NotifyTxDrop (packet);
>       return;
312,313d695
<   return centerFrequencyForSupportedWidth;
< }
315,323c697,738
< void
< SpectrumWifiPhy::StartTx (Ptr<WifiPpdu> ppdu)
< {
<   NS_LOG_FUNCTION (this << ppdu);
<   WifiTxVector txVector = ppdu->GetTxVector ();
<   double txPowerDbm = GetTxPowerForTransmission (txVector) + GetTxGain ();
<   NS_LOG_DEBUG ("Start transmission: signal power before antenna gain=" << txPowerDbm << "dBm");
<   double txPowerWatts = DbmToW (txPowerDbm);
<   Ptr<SpectrumValue> txPowerSpectrum = GetTxPowerSpectralDensity (GetCenterFrequencyForChannelWidth (txVector), txVector.GetChannelWidth (), txPowerWatts, txVector.GetMode ().GetModulationClass ());
---
>   Time txDuration = CalculateTxDuration (packet->GetSize (), txVector, preamble, GetFrequency (), mpdutype, 1);
>   NS_ASSERT (txDuration > NanoSeconds (0));
> 
>   if (m_state->IsStateRx ())
>     {
>       m_endPlcpRxEvent.Cancel ();
>       m_endRxEvent.Cancel ();
>       m_interference.NotifyRxEnd ();
>     }
>   NotifyTxBegin (packet);
>   uint32_t dataRate500KbpsUnits;
>   if (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT || txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
>     {
>       dataRate500KbpsUnits = 128 + txVector.GetMode ().GetMcsValue ();
>     }
>   else
>     {
>       dataRate500KbpsUnits = txVector.GetMode ().GetDataRate (txVector.GetChannelWidth (), txVector.IsShortGuardInterval (), 1) * txVector.GetNss () / 500000;
>     }
>   if (mpdutype == MPDU_IN_AGGREGATE && preamble != WIFI_PREAMBLE_NONE)
>     {
>       //send the first MPDU in an MPDU
>       m_txMpduReferenceNumber++;
>     }
>   struct mpduInfo aMpdu;
>   aMpdu.type = mpdutype;
>   aMpdu.mpduRefNumber = m_txMpduReferenceNumber;
>   NotifyMonitorSniffTx (packet, (uint16_t) GetFrequency (), GetChannelNumber (), dataRate500KbpsUnits, preamble, txVector, aMpdu);
>   m_state->SwitchToTx (txDuration, packet, GetPowerDbm (txVector.GetTxPowerLevel ()), txVector, preamble);
>   //
>   // Spectrum elements added here
>   //
>   Ptr<Packet> newPacket = packet->Copy (); // obtain non-const Packet
>   WifiPhyTag oldtag;
>   newPacket->RemovePacketTag (oldtag);
>   WifiPhyTag tag (txVector, preamble, mpdutype);
>   newPacket->AddPacketTag (tag);
> 
>   NS_LOG_DEBUG ("Transmission signal power before antenna gain: " << GetPowerDbm (txVector.GetTxPowerLevel ()) << " dBm");
>   double txPowerWatts = DbmToW (GetPowerDbm (txVector.GetTxPowerLevel ()) + GetTxGain ());
> 
>   Ptr<SpectrumValue> txPowerSpectrum = GetTxPowerSpectralDensity (GetFrequency (), GetChannelWidth (), txPowerWatts);
325c740
<   txParams->duration = ppdu->GetTxDuration ();
---
>   txParams->duration = txDuration;
330,331c745,746
<   txParams->ppdu = ppdu;
<   NS_LOG_DEBUG ("Starting transmission with power " << WToDbm (txPowerWatts) << " dBm on channel " << +GetChannelNumber ());
---
>   txParams->packet = newPacket;
>   NS_LOG_DEBUG ("Starting transmission with power " << WToDbm (txPowerWatts) << " dBm on channel " << GetChannelNumber ());
336,337c751,752
< uint32_t
< SpectrumWifiPhy::GetBandBandwidth (void) const
---
> void
> SpectrumWifiPhy::RegisterListener (WifiPhyListener *listener)
339,369c754,760
<   uint32_t bandBandwidth = 0;
<   switch (GetStandard ())
<     {
<     case WIFI_PHY_STANDARD_80211a:
<     case WIFI_PHY_STANDARD_80211g:
<     case WIFI_PHY_STANDARD_holland:
<     case WIFI_PHY_STANDARD_80211b:
<     case WIFI_PHY_STANDARD_80211n_2_4GHZ:
<     case WIFI_PHY_STANDARD_80211n_5GHZ:
<     case WIFI_PHY_STANDARD_80211ac:
<       // Use OFDM subcarrier width of 312.5 KHz as band granularity
<       bandBandwidth = 312500;
<       break;
<     case WIFI_PHY_STANDARD_80211_10MHZ:
<       // Use OFDM subcarrier width of 156.25 KHz as band granularity
<       bandBandwidth = 156250;
<       break;
<     case WIFI_PHY_STANDARD_80211_5MHZ:
<       // Use OFDM subcarrier width of 78.125 KHz as band granularity
<       bandBandwidth = 78125;
<       break;
<     case WIFI_PHY_STANDARD_80211ax_2_4GHZ:
<     case WIFI_PHY_STANDARD_80211ax_5GHZ:
<       // Use OFDM subcarrier width of 78.125 KHz as band granularity
<       bandBandwidth = 78125;
<       break;
<     default:
<       NS_FATAL_ERROR ("Standard unknown: " << GetStandard ());
<       break;
<     }
<   return bandBandwidth;
---
>   m_state->RegisterListener (listener);
> }
> 
> void
> SpectrumWifiPhy::UnregisterListener (WifiPhyListener *listener)
> {
>   m_state->UnregisterListener (listener);
372,373c763,764
< uint16_t
< SpectrumWifiPhy::GetGuardBandwidth (uint16_t currentChannelWidth) const
---
> void
> SpectrumWifiPhy::EndReceive (Ptr<Packet> packet, enum WifiPreamble preamble, enum mpduType mpdutype, Ptr<InterferenceHelper::Event> event)
375,376c766,775
<   uint16_t guardBandwidth = 0;
<   if (currentChannelWidth == 22)
---
>   NS_LOG_FUNCTION (this << packet << event);
>   NS_ASSERT (IsStateRx ());
>   NS_ASSERT (event->GetEndTime () == Simulator::Now ());
> 
>   struct InterferenceHelper::SnrPer snrPer;
>   snrPer = m_interference.CalculatePlcpPayloadSnrPer (event);
>   m_interference.NotifyRxEnd ();
>   bool rxSucceeded;
> 
>   if (m_plcpSuccess == true)
378,379c777,812
<       //handle case of DSSS transmission
<       guardBandwidth = 10;
---
>       NS_LOG_DEBUG ("mode=" << (event->GetPayloadMode ().GetDataRate (event->GetTxVector ())) <<
>                     ", snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per << ", size=" << packet->GetSize ());
> 
>       if (m_random->GetValue () > snrPer.per)
>         {
>           NotifyRxEnd (packet);
>           uint32_t dataRate500KbpsUnits;
>           if ((event->GetPayloadMode ().GetModulationClass () == WIFI_MOD_CLASS_HT) || (event->GetPayloadMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT))
>             {
>               dataRate500KbpsUnits = 128 + event->GetPayloadMode ().GetMcsValue ();
>             }
>           else
>             {
>               dataRate500KbpsUnits = event->GetPayloadMode ().GetDataRate (event->GetTxVector ().GetChannelWidth (), event->GetTxVector ().IsShortGuardInterval (), 1) * event->GetTxVector ().GetNss () / 500000;
>             }
>           struct signalNoiseDbm signalNoise;
>           signalNoise.signal = RatioToDb (event->GetRxPowerW ()) + 30;
>           signalNoise.noise = RatioToDb (event->GetRxPowerW () / snrPer.snr) - GetRxNoiseFigure () + 30;
>           struct mpduInfo aMpdu;
>           aMpdu.type = mpdutype;
>           aMpdu.mpduRefNumber = m_rxMpduReferenceNumber;
>           NotifyMonitorSniffRx (packet, (uint16_t) GetFrequency (), GetChannelNumber (), dataRate500KbpsUnits, event->GetPreambleType (), event->GetTxVector (), aMpdu, signalNoise);
>           m_state->SwitchFromRxEndOk (packet, snrPer.snr, event->GetTxVector (), event->GetPreambleType ());
>           rxSucceeded = true;
>         }
>       else
>         {
>           /* failure. */
>           NotifyRxDrop (packet);
>           m_state->SwitchFromRxEndError (packet, snrPer.snr);
>           rxSucceeded = false;
>         }
>       if (!m_rxCallback.IsNull ())
>         {
>           m_rxCallback (rxSucceeded);
>         }
383,389c816,820
<       //In order to properly model out of band transmissions for OFDM, the guard
<       //band has been configured so as to expand the modeled spectrum up to the
<       //outermost referenced point in "Transmit spectrum mask" sections' PSDs of
<       //each PHY specification of 802.11-2016 standard. It thus ultimately corresponds
<       //to the currently considered channel bandwidth (which can be different from
<       //supported channel width).
<       guardBandwidth = currentChannelWidth;
---
>       m_state->SwitchFromRxEndError (packet, snrPer.snr);
>       if (!m_rxCallback.IsNull ())
>         {
>           m_rxCallback (false);
>         }
391c822,827
<   return guardBandwidth;
---
> 
>   if (preamble == WIFI_PREAMBLE_NONE && mpdutype == LAST_MPDU_IN_AGGREGATE)
>     {
>       m_plcpSuccess = false;
>     }
> 
diff ../../NS3-WiGig/src/wifi/model/spectrum-wifi-phy.h ../../ns-3-dev/src/wifi/model/spectrum-wifi-phy.h
30,31d29
< #include "ns3/spectrum-channel.h"
< #include "ns3/spectrum-model.h"
32a31,33
> #include "wifi-spectrum-phy-interface.h"
> #include "ns3/spectrum-channel.h"
> #include "ns3/spectrum-interference.h"
36,38d36
< class WifiSpectrumPhyInterface;
< class WifiPpdu;
< 
54,57d51
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
63,66d56
<   // Implementation of pure virtual method.
<   void StartTx (Ptr<WifiPpdu> ppdu);
<   Ptr<Channel> GetChannel (void) const;
< 
72,73c62
<   void SetChannel (const Ptr<SpectrumChannel> channel);
< 
---
>   void SetChannel (Ptr<SpectrumChannel> channel);
75,76c64,65
<    * Input method for delivering a signal from the spectrum channel
<    * and low-level PHY interface to this SpectrumWifiPhy instance.
---
>    * Add a channel number to the list of operational channels.  This method
>    * is used to support scanning for strongest base station.
78c67
<    * \param rxParams Input signal parameters
---
>    * \param channelNumber the channel number to add
80c69,81
<   void StartRx (Ptr<SpectrumSignalParameters> rxParams);
---
>   void AddOperationalChannel (uint16_t channelNumber);
>   /**
>    * Return a list of channels to which it may be possible to roam
>    * By default, this method will return the current channel number followed
>    * by any other channel numbers that have been added.
>    *
>    * \return vector of channel numbers to which it may be possible to roam
>    */
>   std::vector<uint16_t> GetOperationalChannelList (void) const;
>   /**
>    * Clear the list of operational channels.
>    */
>   void ClearOperationalChannelList (void);
83,85c84
<    * Get the center frequency of the channel corresponding the current TxVector rather than
<    * that of the supported channel width.
<    * Consider that this "primary channel" is on the lower part for the time being.
---
>    * Starting receiving the payload of a packet (i.e. the first bit of the packet has arrived).
87,88c86,90
<    * \param txVector the TXVECTOR that has the channel width that is to be used
<    * \return the center frequency in MHz corresponding to the channel width to be used
---
>    * \param packet the arriving packet
>    * \param txVector the TXVECTOR of the arriving packet
>    * \param preamble the preamble of the arriving packet
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
>    * \param event the corresponding event of the first time the packet arrives
90c92,96
<   uint16_t GetCenterFrequencyForChannelWidth (WifiTxVector txVector) const;
---
>   void StartReceivePacket (Ptr<Packet> packet,
>                            WifiTxVector txVector,
>                            WifiPreamble preamble,
>                            enum mpduType mpdutype,
>                            Ptr<InterferenceHelper::Event> event);
92a99,105
>    * Input method for delivering a signal from the spectrum channel
>    * and low-level Phy interface to this SpectrumWifiPhy instance.
>    *
>    * \param rxParams Input signal parameters
>    */
>   void StartRx (Ptr<SpectrumSignalParameters> rxParams);
>   /**
100a114,117
>    * \return pointer to WifiSpectrumPhyInterface associated with this Phy
>    */
>   Ptr<WifiSpectrumPhyInterface> GetSpectrumPhy (void) const;
>   /**
102,106c119,123
<    *                SpectrumSignalParameters (in case any objects downstream of the
<    *                SpectrumWifiPhy wish to adjust signal properties based on the
<    *                transmitted antenna model.  This antenna is also used when
<    *                the underlying WifiSpectrumPhyInterface::GetRxAntenna() method
<    *                is called.
---
>    * SpectrumSignalParameters (in case any objects downstream of the
>    * SpectrumWifiPhy wish to adjust signal properties based on the
>    * transmitted antenna model.  This antenna is also used when
>    * the underlying WifiSpectrumPhyInterface::GetRxAntenna() method
>    * is called.
109c126
<    * methods in the future if the modeling need for this arises
---
>    * methods in the future if the modelling need for this arises
111c128
<   void SetAntenna (const Ptr<AntennaModel> antenna);
---
>   void SetAntenna (Ptr<AntennaModel> antenna);
119,121c136,138
<    * \return the SpectrumModel that this SpectrumPhy expects to be used
<    *         for all SpectrumValues that are passed to StartRx. If 0 is
<    *         returned, it means that any model will be accepted.
---
>    * \return returns the SpectrumModel that this SpectrumPhy expects to be used
>    * for all SpectrumValues that are passed to StartRx. If 0 is
>    * returned, it means that any model will be accepted.
124d140
< 
126c142,143
<    * \return the width of each band (Hz)
---
>    * Callback invoked at the end of a frame reception, to notify whether
>    * the frame was received successfully (true) or not (false)
128,129c145
<   uint32_t GetBandBandwidth (void) const;
< 
---
>   typedef Callback<void,bool> RxCallback;
131,132c147,149
<    * \param currentChannelWidth channel width of the current transmission (MHz)
<    * \return the width of the guard band (MHz)
---
>    * Set the packet received callback (invoked at the end of a frame
>    * reception), to notify whether the frame was received successfully
>    * or not.
134,139c151
<    * Note: in order to properly model out of band transmissions for OFDM, the guard
<    * band has been configured so as to expand the modeled spectrum up to the
<    * outermost referenced point in "Transmit spectrum mask" sections' PSDs of
<    * each PHY specification of 802.11-2016 standard. It thus ultimately corresponds
<    * to the current channel bandwidth (which can be different from devices max
<    * channel width).
---
>    * \param callback the function to hook to the callback
141c153
<   uint16_t GetGuardBandwidth (uint16_t currentChannelWidth) const;
---
>   void SetPacketReceivedCallback (RxCallback callback);
144c156
<    * Callback invoked when the PHY model starts to process a signal
---
>    * Callback invoked when the Phy model starts to process a signal
153,158c165,173
<   // The following four methods call to the base WifiPhy class method
<   // but also generate a new SpectrumModel if called during runtime
<   virtual void SetChannelNumber (uint8_t id);
<   virtual void SetFrequency (uint16_t freq);
<   virtual void SetChannelWidth (uint16_t channelwidth);
<   virtual void ConfigureStandard (WifiPhyStandard standard);
---
>   virtual void SetReceiveOkCallback (WifiPhy::RxOkCallback callback);
>   virtual void SetReceiveErrorCallback (WifiPhy::RxErrorCallback callback);
>   virtual void SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, enum WifiPreamble preamble);
>   virtual void SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, enum WifiPreamble preamble, enum mpduType mpdutype);
>   virtual void RegisterListener (WifiPhyListener *listener);
>   virtual void UnregisterListener (WifiPhyListener *listener);
>   virtual void SetSleepMode (void);
>   virtual void ResumeFromSleep (void);
>   virtual Ptr<WifiChannel> GetChannel (void) const;
162,164c177,180
<   void DoDispose (void);
<   void DoInitialize (void);
< 
---
>   virtual void DoDispose (void);
>   virtual void DoInitialize (void);
>   virtual bool DoChannelSwitch (uint16_t id);
>   virtual bool DoFrequencySwitch (uint32_t frequency);
168,172c184
<    * \param centerFrequency center frequency (MHz)
<    * \param channelWidth channel width (MHz) of the channel for the current transmission
<    * \param txPowerW power in W to spread across the bands
<    * \param modulationClass the modulation class
<    * \return Pointer to SpectrumValue
---
>    * The last bit of the packet has arrived.
174,175c186,197
<    * This is a helper function to create the right TX PSD corresponding
<    * to the standard in use.
---
>    * \param packet the packet that the last bit has arrived
>    * \param preamble the preamble of the arriving packet
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
>    * \param event the corresponding event of the first time the packet arrives
>    */
>   void EndReceive (Ptr<Packet> packet, enum WifiPreamble preamble, enum mpduType mpdutype, Ptr<InterferenceHelper::Event> event);
> 
>   /**
>    * Check if Phy state should move to CCA busy state based on current
>    * state of interference tracker.  In this model, CCA becomes busy when
>    * the aggregation of all signals as tracked by the InterferenceHelper
>    * class is higher than the CcaMode1Threshold
177c199
<   Ptr<SpectrumValue> GetTxPowerSpectralDensity (uint16_t centerFrequency, uint16_t channelWidth, double txPowerW, WifiModulationClass modulationClass) const;
---
>   void SwitchMaybeToCcaBusy (void);
180c202,208
<    * Perform run-time spectrum model change
---
>    * \param centerFrequency center frequency (MHz)
>    * \param channelWidth channel width (MHz) of the channel
>    * \param txPowerW power in W to spread across the bands
>    * \return Ptr to SpectrumValue
>    *
>    * This is a helper function to create the right Tx PSD corresponding
>    * to the standard in use.
182c210
<   void ResetSpectrumModel (void);
---
>   Ptr<SpectrumValue> GetTxPowerSpectralDensity (uint32_t centerFrequency, uint32_t channelWidth, double txPowerW) const;
184a213
>   std::vector<uint16_t> m_operationalChannelList; //!< List of possible channels
186,190c215,220
<   Ptr<WifiSpectrumPhyInterface> m_wifiSpectrumPhyInterface; //!< Spectrum PHY interface
<   Ptr<AntennaModel> m_antenna;                              //!< antenna model
<   mutable Ptr<const SpectrumModel> m_rxSpectrumModel;       //!< receive spectrum model
<   bool m_disableWifiReception;                              //!< forces this PHY to fail to sync on any signal
<   TracedCallback<bool, uint32_t, double, Time> m_signalCb;  //!< Signal callback
---
>   Ptr<WifiSpectrumPhyInterface> m_wifiSpectrumPhyInterface;
>   Ptr<AntennaModel> m_antenna;
>   mutable Ptr<const SpectrumModel> m_rxSpectrumModel;
>   RxCallback m_rxCallback;
>   bool m_disableWifiReception;          //!< forces this Phy to fail to sync on any signal
>   TracedCallback<bool, uint32_t, double, Time> m_signalCb;
diff ../../NS3-WiGig/src/wifi/model/ssid.cc ../../ns-3-dev/src/wifi/model/ssid.cc
21a22
> #include "ns3/assert.h"
53a55,71
> Ssid::Ssid (char const ssid[32], uint8_t length)
> {
>   NS_ASSERT (length <= 32);
>   uint8_t len = 0;
>   while (len < length)
>     {
>       m_ssid[len] = ssid[len];
>       len++;
>     }
>   m_length = length;
>   while (len < 33)
>     {
>       m_ssid[len] = 0;
>       len++;
>     }
> }
> 
119a138,145
> /**
>  * Serialize SSID to the given ostream
>  *
>  * \param os
>  * \param ssid
>  *
>  * \return std::ostream
>  */
127,128c153,161
< std::istream &
< operator >> (std::istream &is, Ssid &ssid)
---
> /**
>  * Serialize from the given istream to this SSID.
>  *
>  * \param is
>  * \param ssid
>  *
>  * \return std::istream
>  */
> std::istream &operator >> (std::istream &is, Ssid &ssid)
diff ../../NS3-WiGig/src/wifi/model/ssid.h ../../ns-3-dev/src/wifi/model/ssid.h
24c24,27
< #include "wifi-information-element.h"
---
> #include <stdint.h>
> #include "ns3/buffer.h"
> #include "ns3/attribute-helper.h"
> #include "ns3/wifi-information-element.h"
38,40c41
<   /**
<    * Create SSID with broadcast SSID
<    */
---
>   // broadcast ssid
48,54c49,55
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
---
>   /**
>    * Create SSID from a given array of char and given length.
>    *
>    * \param ssid
>    * \param length
>    */
>   Ssid (char const ssid[32], uint8_t length);
79a81,85
>   WifiInformationElementId ElementId () const;
>   uint8_t GetInformationFieldSize () const;
>   void SerializeInformationField (Buffer::Iterator start) const;
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
86,93d91
< /**
<  * Serialize SSID to the given ostream
<  *
<  * \param os the output stream
<  * \param ssid the SSID
<  *
<  * \return std::ostream
<  */
95,102d92
< /**
<  * Serialize from the given istream to this SSID.
<  *
<  * \param is the input stream
<  * \param ssid the SSID
<  *
<  * \return std::istream
<  */
diff ../../NS3-WiGig/src/wifi/model/status-code.cc ../../ns-3-dev/src/wifi/model/status-code.cc
21a22,23
> #include <string>
> #include <ostream>
47,52d48
< StatusCodeValue
< StatusCode::GetStatusCodeValue (void) const
< {
<   return static_cast<StatusCodeValue> (m_code);
< }
< 
72a69,76
> /**
>  * Serialize StatusCode to the given ostream.
>  *
>  * \param os
>  * \param code
>  *
>  * \return std::ostream
>  */
diff ../../NS3-WiGig/src/wifi/model/status-code.h ../../ns-3-dev/src/wifi/model/status-code.h
23a24,25
> #include <stdint.h>
> #include <ostream>
28,40d29
< enum StatusCodeValue
< {
<   STATUS_CODE_SUCCESS = 0,
<   STATUS_CODE_FAILURE = 1,
<   STATUS_CODE_REJECTED_WITH_SUGGESTED_CHANGES = 39,
<   STATUS_CODE_REJECT_WITH_SCHEDULE = 83,
<   STATUS_CODE_PENDING_ADMITTING_FST_SESSION = 86,
<   STATUS_CODE_PERFORMING_FST_NOW = 87,
<   STATUS_CODE_PENDING_GAP_IN_BA_WINDOW = 88,
<   STATUS_CODE_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL = 99,
<   STATUS_CODE_DENIED_DUE_TO_SPECTRUM_MANAGEMENT = 103,
< };
< 
56,60d44
<   /**
<    * Set status code value.
<    * \param value The status code.
<    */
<   void SetStatusCodeValue (StatusCodeValue value);
69,74d52
<   /**
<    * Return the value of the status code.
<    *
<    * \return the value of the status code.
<    */
<   StatusCodeValue GetStatusCodeValue (void) const;
106c84
<   uint16_t m_code; ///< status code
---
>   uint16_t m_code;
109,116d86
< /**
<  * Serialize StatusCode to the given ostream.
<  *
<  * \param os the output stream
<  * \param code the StatusCode
<  *
<  * \return std::ostream
<  */
diff ../../NS3-WiGig/src/wifi/model/sta-wifi-mac.cc ../../ns-3-dev/src/wifi/model/sta-wifi-mac.cc
22a23
> #include "sta-wifi-mac.h"
24d24
< #include "ns3/packet.h"
26,27c26,29
< #include "sta-wifi-mac.h"
< #include "wifi-phy.h"
---
> #include "ns3/string.h"
> #include "ns3/pointer.h"
> #include "ns3/boolean.h"
> #include "ns3/trace-source-accessor.h"
28a31,36
> #include "dcf-manager.h"
> #include "mac-rx-middle.h"
> #include "mac-tx-middle.h"
> #include "wifi-mac-header.h"
> #include "msdu-aggregator.h"
> #include "amsdu-subframe-header.h"
30,33c38,56
< #include "snr-tag.h"
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "he-configuration.h"
---
> #include "ht-capabilities.h"
> #include "ht-operations.h"
> #include "vht-capabilities.h"
> 
> /*
>  * The state machine for this STA is:
>  --------------                                          -----------
>  | Associated |   <--------------------      ------->    | Refused |
>  --------------                        \    /            -----------
>     \                                   \  /
>      \    -----------------     -----------------------------
>       \-> | Beacon Missed | --> | Wait Association Response |
>           -----------------     -----------------------------
>                 \                       ^
>                  \                      |
>                   \    -----------------------
>                    \-> | Wait Probe Response |
>                        -----------------------
>  */
45c68
<     .SetParent<InfrastructureWifiMac> ()
---
>     .SetParent<RegularWifiMac> ()
48c71
<     .AddAttribute ("ProbeRequestTimeout", "The duration to actively probe the channel.",
---
>     .AddAttribute ("ProbeRequestTimeout", "The interval between two consecutive probe request attempts.",
52,56c75
<     .AddAttribute ("WaitBeaconTimeout", "The duration to dwell on a channel while passively scanning for beacon",
<                    TimeValue (MilliSeconds (120)),
<                    MakeTimeAccessor (&StaWifiMac::m_waitBeaconTimeout),
<                    MakeTimeChecker ())
<     .AddAttribute ("AssocRequestTimeout", "The interval between two consecutive association request attempts.",
---
>     .AddAttribute ("AssocRequestTimeout", "The interval between two consecutive assoc request attempts.",
81,84d99
<     .AddTraceSource ("BeaconArrival",
<                      "Time of beacons arrival from associated AP",
<                      MakeTraceSourceAccessor (&StaWifiMac::m_beaconArrival),
<                      "ns3::Time::TracedCallback")
90,92c105
<   : m_state (UNASSOCIATED),
<     m_aid (0),
<     m_waitBeaconEvent (),
---
>   : m_state (BEACON_MISSED),
95c108
<     m_beaconWatchdogEnd (Seconds (0))
---
>     m_beaconWatchdogEnd (Seconds (0.0))
104,105c117
< void
< StaWifiMac::DoInitialize (void)
---
> StaWifiMac::~StaWifiMac ()
108d119
<   StartScanning ();
111c122,123
< StaWifiMac::~StaWifiMac ()
---
> void
> StaWifiMac::SetMaxMissedBeacons (uint32_t missed)
113c125,126
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION (this << missed);
>   m_maxMissedBeacons = missed;
116,117c129,130
< uint16_t
< StaWifiMac::GetAssociationId (void) const
---
> void
> StaWifiMac::SetProbeRequestTimeout (Time timeout)
119,120c132,133
<   NS_ASSERT_MSG (IsAssociated (), "This station is not associated to any AP");
<   return m_aid;
---
>   NS_LOG_FUNCTION (this << timeout);
>   m_probeRequestTimeout = timeout;
124c137
< StaWifiMac::SetActiveProbing (bool enable)
---
> StaWifiMac::SetAssocRequestTimeout (Time timeout)
126,132c139,140
<   NS_LOG_FUNCTION (this << enable);
<   m_activeProbing = enable;
<   if (m_state == WAIT_PROBE_RESP || m_state == WAIT_BEACON)
<     {
<       NS_LOG_DEBUG ("STA is still scanning, reset scanning process");
<       StartScanning ();
<     }
---
>   NS_LOG_FUNCTION (this << timeout);
>   m_assocRequestTimeout = timeout;
135,136c143,144
< bool
< StaWifiMac::GetActiveProbing (void) const
---
> void
> StaWifiMac::StartActiveAssociation (void)
138c146,147
<   return m_activeProbing;
---
>   NS_LOG_FUNCTION (this);
>   TryToEnsureAssociated ();
142c151
< StaWifiMac::SetWifiPhy (const Ptr<WifiPhy> phy)
---
> StaWifiMac::SetActiveProbing (bool enable)
144,146c153,162
<   NS_LOG_FUNCTION (this << phy);
<   RegularWifiMac::SetWifiPhy (phy);
<   m_phy->SetCapabilitiesChangedCallback (MakeCallback (&StaWifiMac::PhyCapabilitiesChanged, this));
---
>   NS_LOG_FUNCTION (this << enable);
>   if (enable)
>     {
>       Simulator::ScheduleNow (&StaWifiMac::TryToEnsureAssociated, this);
>     }
>   else
>     {
>       m_probeRequestEvent.Cancel ();
>     }
>   m_activeProbing = enable;
149,150c165
< void
< StaWifiMac::SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> stationManager)
---
> bool StaWifiMac::GetActiveProbing (void) const
152,154c167
<   NS_LOG_FUNCTION (this << stationManager);
<   RegularWifiMac::SetWifiRemoteStationManager (stationManager);
<   m_stationManager->SetPcfSupported (GetPcfSupported ());
---
>   return m_activeProbing;
162c175
<   hdr.SetType (WIFI_MAC_MGT_PROBE_REQUEST);
---
>   hdr.SetProbeReq ();
172c185
<   if (GetHtSupported ())
---
>   if (m_htSupported || m_vhtSupported)
174,175c187,188
<       probe.AddWifiInformationElement (GetExtendedCapabilities ());
<       probe.AddWifiInformationElement (GetHtCapabilities ());
---
>       probe.SetHtCapabilities (GetHtCapabilities ());
>       hdr.SetNoOrder ();
177c190
<   if (GetVhtSupported ())
---
>   if (m_vhtSupported)
179,183c192
<       probe.AddWifiInformationElement (GetVhtCapabilities ());
<     }
<   if (GetHeSupported ())
<     {
<       probe.AddWifiInformationElement (GetHeCapabilities ());
---
>       probe.SetVhtCapabilities (GetVhtCapabilities ());
189c198
<   //use the non-QoS for these regardless of whether we have a QoS
---
>   //use the DCF for these regardless of whether we have a QoS
191c200,207
<   m_txop->Queue (packet, hdr);
---
>   m_dca->Queue (packet, hdr);
> 
>   if (m_probeRequestEvent.IsRunning ())
>     {
>       m_probeRequestEvent.Cancel ();
>     }
>   m_probeRequestEvent = Simulator::Schedule (m_probeRequestTimeout,
>                                              &StaWifiMac::ProbeRequestTimeout, this);
195c211
< StaWifiMac::SendAssociationRequest (bool isReassoc)
---
> StaWifiMac::SendAssociationRequest (void)
197c213
<   NS_LOG_FUNCTION (this << GetBssid () << isReassoc);
---
>   NS_LOG_FUNCTION (this << GetBssid ());
199c215
<   hdr.SetType (isReassoc ? WIFI_MAC_MGT_REASSOCIATION_REQUEST : WIFI_MAC_MGT_ASSOCIATION_REQUEST);
---
>   hdr.SetAssocReq ();
206c222,226
<   if (!isReassoc)
---
>   MgtAssocRequestHeader assoc;
>   assoc.SetSsid (GetSsid ());
>   assoc.SetSupportedRates (GetSupportedRates ());
>   assoc.SetCapabilities (GetCapabilities ());
>   if (m_htSupported || m_vhtSupported)
208,226c228,229
<       MgtAssocRequestHeader assoc;
<       assoc.SetSsid (GetSsid ());
<       assoc.SetSupportedRates (GetSupportedRates ());
<       assoc.SetCapabilities (GetCapabilities ());
<       assoc.SetListenInterval (0);
<       if (GetHtSupported ())
<         {
<           assoc.AddWifiInformationElement (GetExtendedCapabilities ());
<           assoc.AddWifiInformationElement (GetHtCapabilities ());
<         }
<       if (GetVhtSupported ())
<         {
<           assoc.AddWifiInformationElement (GetVhtCapabilities ());
<         }
<       if (GetHeSupported ())
<         {
<           assoc.AddWifiInformationElement (GetHeCapabilities ());
<         }
<       packet->AddHeader (assoc);
---
>       assoc.SetHtCapabilities (GetHtCapabilities ());
>       hdr.SetNoOrder ();
228c231
<   else
---
>   if (m_vhtSupported)
230,249c233
<       MgtReassocRequestHeader reassoc;
<       reassoc.SetCurrentApAddress (GetBssid ());
<       reassoc.SetSsid (GetSsid ());
<       reassoc.SetSupportedRates (GetSupportedRates ());
<       reassoc.SetCapabilities (GetCapabilities ());
<       reassoc.SetListenInterval (0);
<       if (GetHtSupported ())
<         {
<           reassoc.AddWifiInformationElement (GetExtendedCapabilities ());
<           reassoc.AddWifiInformationElement (GetHtCapabilities ());
<         }
<       if (GetVhtSupported ())
<         {
<           reassoc.AddWifiInformationElement (GetVhtCapabilities ());
<         }
<       if (GetHeSupported ())
<         {
<           reassoc.AddWifiInformationElement (GetHeCapabilities ());
<         }
<       packet->AddHeader (reassoc);
---
>       assoc.SetVhtCapabilities (GetVhtCapabilities ());
250a235
>   packet->AddHeader (assoc);
254c239
<   //use the non-QoS for these regardless of whether we have a QoS
---
>   //use the DCF for these regardless of whether we have a QoS
256c241
<   m_txop->Queue (packet, hdr);
---
>   m_dca->Queue (packet, hdr);
267,274d251
< StaWifiMac::SendCfPollResponse (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_ASSERT (GetPcfSupported ());
<   m_txop->SendCfFrame (WIFI_MAC_DATA_NULL, GetBssid ());
< }
< 
< void
290,295c267
<     case WAIT_BEACON:
<       /* we have initiated passive scanning, continue to wait
<          and gather beacons
<        */
<       break;
<     case UNASSOCIATED:
---
>     case BEACON_MISSED:
298c270
<        * We try to initiate a scan now.
---
>        * We try to initiate a probe request now.
301c273,277
<       StartScanning ();
---
>       if (m_activeProbing)
>         {
>           SetState (WAIT_PROBE_RESP);
>           SendProbeRequest ();
>         }
304,305c280,281
<       /* we have sent an association request so we do not need to
<          re-send an association request right now. We just need to
---
>       /* we have sent an assoc request so we do not need to
>          re-send an assoc request right now. We just need to
307c283
<          we get an association response.
---
>          we get an assoc response.
311,313c287,289
<       /* we have sent an association request and received a negative
<          association response. We wait until someone restarts an
<          association with a given SSID.
---
>       /* we have sent an assoc request and received a negative
>          assoc resp. We wait until someone restarts an
>          association with a given ssid.
320,350c296
< StaWifiMac::StartScanning (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_candidateAps.clear ();
<   if (m_probeRequestEvent.IsRunning ())
<     {
<       m_probeRequestEvent.Cancel ();
<     }
<   if (m_waitBeaconEvent.IsRunning ())
<     {
<       m_waitBeaconEvent.Cancel ();
<     }
<   if (GetActiveProbing ())
<     {
<       SetState (WAIT_PROBE_RESP);
<       SendProbeRequest ();
<       m_probeRequestEvent = Simulator::Schedule (m_probeRequestTimeout,
<                                                  &StaWifiMac::ScanningTimeout,
<                                                  this);
<     }
<   else
<     {
<       SetState (WAIT_BEACON);
<       m_waitBeaconEvent = Simulator::Schedule (m_waitBeaconTimeout,
<                                                &StaWifiMac::ScanningTimeout,
<                                                this);
<     }
< }
< 
< void
< StaWifiMac::ScanningTimeout (void)
---
> StaWifiMac::AssocRequestTimeout (void)
353,379c299,300
<   if (!m_candidateAps.empty ())
<     {
<       ApInfo bestAp = m_candidateAps.front();
<       m_candidateAps.erase(m_candidateAps.begin ());
<       NS_LOG_DEBUG ("Attempting to associate with BSSID " << bestAp.m_bssid);
<       Time beaconInterval;
<       if (bestAp.m_activeProbing)
<         {
<           UpdateApInfoFromProbeResp (bestAp.m_probeResp, bestAp.m_apAddr, bestAp.m_bssid);
<           beaconInterval = MicroSeconds (bestAp.m_probeResp.GetBeaconIntervalUs ());
<         }
<       else
<         {
<           UpdateApInfoFromBeacon (bestAp.m_beacon, bestAp.m_apAddr, bestAp.m_bssid);
<           beaconInterval = MicroSeconds (bestAp.m_beacon.GetBeaconIntervalUs ());
<         }
< 
<       Time delay = beaconInterval * m_maxMissedBeacons;
<       RestartBeaconWatchdog (delay);
<       SetState (WAIT_ASSOC_RESP);
<       SendAssociationRequest (false);
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Exhausted list of candidate AP; restart scanning");
<       StartScanning ();
<     }
---
>   SetState (WAIT_ASSOC_RESP);
>   SendAssociationRequest ();
383c304
< StaWifiMac::AssocRequestTimeout (void)
---
> StaWifiMac::ProbeRequestTimeout (void)
386,387c307,308
<   SetState (WAIT_ASSOC_RESP);
<   SendAssociationRequest (false);
---
>   SetState (WAIT_PROBE_RESP);
>   SendProbeRequest ();
405c326
<   SetState (UNASSOCIATED);
---
>   SetState (BEACON_MISSED);
434,448d354
< Ptr<MultiBandElement>
< StaWifiMac::GetMultiBandElement (void) const
< {
<   Ptr<MultiBandElement> multiband = Create<MultiBandElement> ();
<   multiband->SetStaRole (ROLE_NON_PCP_NON_AP);
<   multiband->SetStaMacAddressPresent (false); /* The same MAC address is used across all the bands */
<   multiband->SetBandID (Band_2_4GHz);
<   multiband->SetOperatingClass (18);          /* Europe */
<   multiband->SetChannelNumber (m_phy->GetChannelNumber ());
<   multiband->SetBssID (GetBssid ());
<   multiband->SetConnectionCapability (0);     /* Non-AP/Non-PCP */
<   multiband->SetFstSessionTimeout (m_fstTimeout);
<   return multiband;
< }
< 
450c356
< StaWifiMac::Enqueue (Ptr<Packet> packet, Mac48Address to)
---
> StaWifiMac::Enqueue (Ptr<const Packet> packet, Mac48Address to)
471c377
<   if (GetQosSupported ())
---
>   if (m_qosSupported)
494c400
<       hdr.SetType (WIFI_MAC_DATA);
---
>       hdr.SetTypeData ();
496c402
<   if (GetQosSupported ())
---
>   if (m_htSupported || m_vhtSupported)
498c404
<       hdr.SetNoOrder (); // explicitly set to 0 for the time being since HT control field is not yet implemented (set it to 1 when implemented)
---
>       hdr.SetNoOrder ();
507c413
<   if (GetQosSupported ())
---
>   if (m_qosSupported)
515c421
<       m_txop->Queue (packet, hdr);
---
>       m_dca->Queue (packet, hdr);
520c426
< StaWifiMac::Receive (Ptr<WifiMacQueueItem> mpdu)
---
> StaWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
522,524c428
<   NS_LOG_FUNCTION (this << *mpdu);
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
<   Ptr<const Packet> packet = mpdu->GetPacket ();
---
>   NS_LOG_FUNCTION (this << packet << hdr);
538,542c442
<   else if ((hdr->GetAddr1 () == GetAddress ()) && (hdr->GetAddr2 () == GetBssid ()) && hdr->IsCfPoll ())
<     {
<       SendCfPollResponse ();
<     }
<   if (hdr->IsData ())
---
>   else if (hdr->IsData ())
567c467
<               DeaggregateAmsduAndForward (mpdu);
---
>               DeaggregateAmsduAndForward (packet, hdr);
575c475
<       else if (hdr->HasData ())
---
>       else
582,583c482
<            || hdr->IsAssocReq ()
<            || hdr->IsReassocReq ())
---
>            || hdr->IsAssocReq ())
591d489
<       NS_LOG_DEBUG ("Beacon received");
593,594c491
<       Ptr<Packet> copy = packet->Copy ();
<       copy->RemoveHeader (beacon);
---
>       packet->RemoveHeader (beacon);
596d492
<       NS_ASSERT (capabilities.IsEss ());
604,616d499
<       Ptr<CfParameterSet> cfParameterSet = StaticCast<CfParameterSet> (beacon.GetInformationElement (std::make_pair (IE_CF_PARAMETER_SET, 0)));
<       if (cfParameterSet && (cfParameterSet->GetCFPCount () == 0))
<         {
<           //see section 9.3.2.2 802.11-1999
<           if (GetPcfSupported ())
<             {
<               m_low->DoNavStartNow (MicroSeconds (cfParameterSet->GetCFPMaxDurationUs ()));
<             }
<           else
<             {
<               m_low->DoNavStartNow (MicroSeconds (cfParameterSet->GetCFPDurRemainingUs ()));
<             }
<         }
619c502
<       for (uint8_t i = 0; i < m_phy->GetNBssMembershipSelectors (); i++)
---
>       for (uint32_t i = 0; i < m_phy->GetNBssMembershipSelectors (); i++)
621c504
<           uint8_t selector = m_phy->GetBssMembershipSelector (i);
---
>           uint32_t selector = m_phy->GetBssMembershipSelector (i);
638c521
<       if (goodBeacon && m_state == ASSOCIATED)
---
>       if (goodBeacon)
640d522
<           m_beaconArrival (Simulator::Now ());
643c525,560
<           UpdateApInfoFromBeacon (beacon, hdr->GetAddr2 (), hdr->GetAddr3 ());
---
>           SetBssid (hdr->GetAddr3 ());
>           bool isShortPreambleEnabled = capabilities.IsShortPreamble ();
>           if (m_erpSupported)
>             {
>               ErpInformation erpInformation = beacon.GetErpInformation ();
>               isShortPreambleEnabled &= !erpInformation.GetBarkerPreambleMode ();
>               if (erpInformation.GetUseProtection() == true)
>                 {
>                   m_stationManager->SetUseNonErpProtection (true);
>                 }
>               else
>                 {
>                   m_stationManager->SetUseNonErpProtection (false);
>                 }
>               if (capabilities.IsShortSlotTime () == true)
>                 {
>                   //enable short slot time
>                   SetSlot (MicroSeconds (9));
>                 }
>               else
>                 {
>                   //disable short slot time
>                   SetSlot (MicroSeconds (20));
>                 }
>             }
>             if (m_qosSupported)
>             {
>               EdcaParameterSet edcaParameters = beacon.GetEdcaParameterSet ();
>               //The value of the TXOP Limit field is specified as an unsigned integer, with the least significant octet transmitted first, in units of 32 μs.
>               SetEdcaParameters (AC_BE, edcaParameters.GetBeCWmin(), edcaParameters.GetBeCWmax(), edcaParameters.GetBeAifsn(), 32 * MicroSeconds (edcaParameters.GetBeTXOPLimit()));
>               SetEdcaParameters (AC_BK, edcaParameters.GetBkCWmin(), edcaParameters.GetBkCWmax(), edcaParameters.GetBkAifsn(), 32 * MicroSeconds (edcaParameters.GetBkTXOPLimit()));
>               SetEdcaParameters (AC_VI, edcaParameters.GetViCWmin(), edcaParameters.GetViCWmax(), edcaParameters.GetViAifsn(), 32 * MicroSeconds (edcaParameters.GetViTXOPLimit()));
>               SetEdcaParameters (AC_VO, edcaParameters.GetVoCWmin(), edcaParameters.GetVoCWmax(), edcaParameters.GetVoAifsn(), 32 * MicroSeconds (edcaParameters.GetVoTXOPLimit()));
>             }
>           m_stationManager->SetShortPreambleEnabled (isShortPreambleEnabled);
>           m_stationManager->SetShortSlotTimeEnabled (capabilities.IsShortSlotTime ());
645c562
<       if (goodBeacon && m_state == WAIT_BEACON)
---
>       if (goodBeacon && m_state == BEACON_MISSED)
647,657c564,565
<           NS_LOG_DEBUG ("Beacon received while scanning from " << hdr->GetAddr2 ());
<           SnrTag snrTag;
<           bool removed = copy->RemovePacketTag (snrTag);
<           NS_ASSERT (removed);
<           ApInfo apInfo;
<           apInfo.m_apAddr = hdr->GetAddr2 ();
<           apInfo.m_bssid = hdr->GetAddr3 ();
<           apInfo.m_activeProbing = false;
<           apInfo.m_snr = snrTag.Get ();
<           apInfo.m_beacon = beacon;
<           UpdateCandidateApList (apInfo);
---
>           SetState (WAIT_ASSOC_RESP);
>           SendAssociationRequest ();
665d572
<           NS_LOG_DEBUG ("Probe response received while scanning from " << hdr->GetAddr2 ());
667,668c574,575
<           Ptr<Packet> copy = packet->Copy ();
<           copy->RemoveHeader (probeResp);
---
>           packet->RemoveHeader (probeResp);
>           CapabilityInformation capabilities = probeResp.GetCapabilities ();
671c578
<               NS_LOG_DEBUG ("Probe response is not for our SSID");
---
>               //not a probe resp for our ssid.
674,683c581,650
<           SnrTag snrTag;
<           bool removed = copy->RemovePacketTag (snrTag);
<           NS_ASSERT (removed);
<           ApInfo apInfo;
<           apInfo.m_apAddr = hdr->GetAddr2 ();
<           apInfo.m_bssid = hdr->GetAddr3 ();
<           apInfo.m_activeProbing = true;
<           apInfo.m_snr = snrTag.Get ();
<           apInfo.m_probeResp = probeResp;
<           UpdateCandidateApList (apInfo);
---
>           SupportedRates rates = probeResp.GetSupportedRates ();
>           for (uint32_t i = 0; i < m_phy->GetNBssMembershipSelectors (); i++)
>             {
>               uint32_t selector = m_phy->GetBssMembershipSelector (i);
>               if (!rates.IsSupportedRate (selector))
>                 {
>                   return;
>                 }
>             }
>           for (uint32_t i = 0; i < m_phy->GetNModes (); i++)
>             {
>               WifiMode mode = m_phy->GetMode (i);
>               uint8_t nss = 1; // Assume 1 spatial stream
>               if (rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth (), false, nss)))
>                 {
>                   m_stationManager->AddSupportedMode (hdr->GetAddr2 (), mode);
>                   if (rates.IsBasicRate (mode.GetDataRate (m_phy->GetChannelWidth (), false, nss)))
>                     {
>                       m_stationManager->AddBasicMode (mode);
>                     }
>                 }
>             }
>             
>           bool isShortPreambleEnabled = capabilities.IsShortPreamble ();
>           if (m_erpSupported)
>             {
>               bool isErpAllowed = false;
>               for (uint32_t i = 0; i < m_phy->GetNModes (); i++)
>               {
>                 WifiMode mode = m_phy->GetMode (i);
>                 if (mode.GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM && rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth (), false, 1)))
>                   {
>                     isErpAllowed = true;
>                     break;
>                   }
>               }
>               if (!isErpAllowed)
>                 {
>                   //disable short slot time and set cwMin to 31
>                   SetSlot (MicroSeconds (20));
>                   ConfigureContentionWindow (31, 1023);
>                 }
>               else
>                 {
>                   ErpInformation erpInformation = probeResp.GetErpInformation ();
>                   isShortPreambleEnabled &= !erpInformation.GetBarkerPreambleMode ();
>                   if (m_stationManager->GetShortSlotTimeEnabled ())
>                     {
>                       //enable short slot time
>                       SetSlot (MicroSeconds (9));
>                     }
>                   else
>                     {
>                       //disable short slot time
>                       SetSlot (MicroSeconds (20));
>                     }
>                   ConfigureContentionWindow (15, 1023);
>                 }
>             }
>           m_stationManager->SetShortPreambleEnabled (isShortPreambleEnabled);
>           m_stationManager->SetShortSlotTimeEnabled (capabilities.IsShortSlotTime ());
>           SetBssid (hdr->GetAddr3 ());
>           Time delay = MicroSeconds (probeResp.GetBeaconIntervalUs () * m_maxMissedBeacons);
>           RestartBeaconWatchdog (delay);
>           if (m_probeRequestEvent.IsRunning ())
>             {
>               m_probeRequestEvent.Cancel ();
>             }
>           SetState (WAIT_ASSOC_RESP);
>           SendAssociationRequest ();
687c654
<   else if (hdr->IsAssocResp () || hdr->IsReassocResp ())
---
>   else if (hdr->IsAssocResp ())
692c659
<           packet->PeekHeader (assocResp);
---
>           packet->RemoveHeader (assocResp);
700,701c667,671
<               m_aid = assocResp.GetAssociationId ();
<               if (hdr->IsReassocResp ())
---
>               NS_LOG_DEBUG ("assoc completed");
>               CapabilityInformation capabilities = assocResp.GetCapabilities ();
>               SupportedRates rates = assocResp.GetSupportedRates ();
>               bool isShortPreambleEnabled = capabilities.IsShortPreamble ();
>               if (m_erpSupported)
703c673,704
<                   NS_LOG_DEBUG ("reassociation done");
---
>                   bool isErpAllowed = false;
>                   for (uint32_t i = 0; i < m_phy->GetNModes (); i++)
>                   {
>                     WifiMode mode = m_phy->GetMode (i);
>                     if (mode.GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM && rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth (), false, 1)))
>                       {
>                         isErpAllowed = true;
>                         break;
>                       }
>                   }
>                   if (!isErpAllowed)
>                     {
>                       //disable short slot time and set cwMin to 31
>                       SetSlot (MicroSeconds (20));
>                       ConfigureContentionWindow (31, 1023);
>                     }
>                   else
>                     {
>                       ErpInformation erpInformation = assocResp.GetErpInformation ();
>                       isShortPreambleEnabled &= !erpInformation.GetBarkerPreambleMode ();
>                       if (m_stationManager->GetShortSlotTimeEnabled ())
>                         {
>                           //enable short slot time
>                           SetSlot (MicroSeconds (9));
>                         }
>                       else
>                         {
>                           //disable short slot time
>                           SetSlot (MicroSeconds (20));
>                         }
>                       ConfigureContentionWindow (15, 1023);
>                     }
705c706,708
<               else
---
>               m_stationManager->SetShortPreambleEnabled (isShortPreambleEnabled);
>               m_stationManager->SetShortSlotTimeEnabled (capabilities.IsShortSlotTime ());
>               if (m_qosSupported)
707c710,715
<                   NS_LOG_DEBUG ("association completed");
---
>                   EdcaParameterSet edcaParameters = assocResp.GetEdcaParameterSet ();
>                   //The value of the TXOP Limit field is specified as an unsigned integer, with the least significant octet transmitted first, in units of 32 μs.
>                   SetEdcaParameters (AC_BE, edcaParameters.GetBeCWmin(), edcaParameters.GetBeCWmax(), edcaParameters.GetBeAifsn(), 32 * MicroSeconds (edcaParameters.GetBeTXOPLimit()));
>                   SetEdcaParameters (AC_BK, edcaParameters.GetBkCWmin(), edcaParameters.GetBkCWmax(), edcaParameters.GetBkAifsn(), 32 * MicroSeconds (edcaParameters.GetBkTXOPLimit()));
>                   SetEdcaParameters (AC_VI, edcaParameters.GetViCWmin(), edcaParameters.GetViCWmax(), edcaParameters.GetViAifsn(), 32 * MicroSeconds (edcaParameters.GetViTXOPLimit()));
>                   SetEdcaParameters (AC_VO, edcaParameters.GetVoCWmin(), edcaParameters.GetVoCWmax(), edcaParameters.GetVoAifsn(), 32 * MicroSeconds (edcaParameters.GetVoTXOPLimit()));
709,710c717
<               UpdateApInfoFromAssocResp (assocResp, hdr->GetAddr2 ());
<               if (!m_linkUp.IsNull ())
---
>               if (m_htSupported)
712c719,721
<                   m_linkUp ();
---
>                   HtCapabilities htcapabilities = assocResp.GetHtCapabilities ();
>                   HtOperations htOperations = assocResp.GetHtOperations ();
>                   m_stationManager->AddStationHtCapabilities (hdr->GetAddr2 (), htcapabilities);
714,718c723
<             }
<           else
<             {
<               NS_LOG_DEBUG ("association refused");
<               if (m_candidateAps.empty ())
---
>               if (m_vhtSupported)
720c725,726
<                   SetState (REFUSED);
---
>                   VhtCapabilities vhtcapabilities = assocResp.GetVhtCapabilities ();
>                   m_stationManager->AddStationVhtCapabilities (hdr->GetAddr2 (), vhtcapabilities);
722c728,729
<               else
---
> 
>               for (uint32_t i = 0; i < m_phy->GetNModes (); i++)
724c731,740
<                   ScanningTimeout ();
---
>                   WifiMode mode = m_phy->GetMode (i);
>                   uint8_t nss = 1; // Assume 1 spatial stream
>                   if (rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth (), false, nss)))
>                     {
>                       m_stationManager->AddSupportedMode (hdr->GetAddr2 (), mode);
>                       if (rates.IsBasicRate (mode.GetDataRate (m_phy->GetChannelWidth (), false, nss)))
>                         {
>                           m_stationManager->AddBasicMode (mode);
>                         }
>                     }
726,857c742
<             }
<         }
<       return;
<     }
< 
<   //Invoke the receive handler of our parent class to deal with any
<   //other frames. Specifically, this will handle Block Ack-related
<   //Management Action frames.
<   RegularWifiMac::Receive (Create<WifiMacQueueItem> (packet, *hdr));
< }
< 
< void
< StaWifiMac::UpdateCandidateApList (ApInfo newApInfo)
< {
<   NS_LOG_FUNCTION (this << newApInfo.m_bssid << newApInfo.m_apAddr << newApInfo.m_snr << newApInfo.m_activeProbing << newApInfo.m_beacon << newApInfo.m_probeResp);
<   // Remove duplicate ApInfo entry
<   for (std::vector<ApInfo>::iterator i = m_candidateAps.begin(); i != m_candidateAps.end(); ++i)
<     {
<       if (newApInfo.m_bssid == (*i).m_bssid)
<         {
<           m_candidateAps.erase(i);
<           break;
<         }
<     }
<   // Insert before the entry with lower SNR
<   for (std::vector<ApInfo>::iterator i = m_candidateAps.begin(); i != m_candidateAps.end(); ++i)
<     {
<       if (newApInfo.m_snr > (*i).m_snr)
<         {
<           m_candidateAps.insert (i, newApInfo);
<           return;
<         }
<     }
<   // If new ApInfo is the lowest, insert at back
<   m_candidateAps.push_back(newApInfo);
< }
< 
< void
< StaWifiMac::UpdateApInfoFromBeacon (MgtBeaconHeader beacon, Mac48Address apAddr, Mac48Address bssid)
< {
<   NS_LOG_FUNCTION (this << beacon << apAddr << bssid);
<   SetBssid (bssid);
<   CapabilityInformation capabilities = beacon.GetCapabilities ();
<   SupportedRates rates = beacon.GetSupportedRates ();
<   for (uint8_t i = 0; i < m_phy->GetNModes (); i++)
<     {
<       WifiMode mode = m_phy->GetMode (i);
<       if (rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
<         {
<           m_stationManager->AddSupportedMode (apAddr, mode);
<         }
<     }
<   bool isShortPreambleEnabled = capabilities.IsShortPreamble ();
<   if (GetErpSupported ())
<     {
<       Ptr<ErpInformation> erpInformation = StaticCast<ErpInformation> (beacon.GetInformationElement (std::make_pair (IE_ERP_INFORMATION, 0)));
<       isShortPreambleEnabled &= !erpInformation->GetBarkerPreambleMode ();
<       if (erpInformation && (erpInformation->GetUseProtection () != 0))
<         {
<           m_stationManager->SetUseNonErpProtection (true);
<         }
<       else
<         {
<           m_stationManager->SetUseNonErpProtection (false);
<         }
<       if (capabilities.IsShortSlotTime () == true)
<         {
<           //enable short slot time
<           SetSlot (MicroSeconds (9));
<         }
<       else
<         {
<           //disable short slot time
<           SetSlot (MicroSeconds (20));
<         }
<     }
<   if (GetQosSupported ())
<     {
<       bool qosSupported = false;
<       Ptr<EdcaParameterSet> edcaParameters = StaticCast<EdcaParameterSet> (beacon.GetInformationElement (std::make_pair (IE_EDCA_PARAMETER_SET, 0)));
<       if (edcaParameters->IsQosSupported ())
<         {
<           qosSupported = true;
<           //The value of the TXOP Limit field is specified as an unsigned integer, with the least significant octet transmitted first, in units of 32 μs.
<           SetEdcaParameters (AC_BE, edcaParameters->GetBeCWmin (), edcaParameters->GetBeCWmax (), edcaParameters->GetBeAifsn (), 32 * MicroSeconds (edcaParameters->GetBeTxopLimit ()));
<           SetEdcaParameters (AC_BK, edcaParameters->GetBkCWmin (), edcaParameters->GetBkCWmax (), edcaParameters->GetBkAifsn (), 32 * MicroSeconds (edcaParameters->GetBkTxopLimit ()));
<           SetEdcaParameters (AC_VI, edcaParameters->GetViCWmin (), edcaParameters->GetViCWmax (), edcaParameters->GetViAifsn (), 32 * MicroSeconds (edcaParameters->GetViTxopLimit ()));
<           SetEdcaParameters (AC_VO, edcaParameters->GetVoCWmin (), edcaParameters->GetVoCWmax (), edcaParameters->GetVoAifsn (), 32 * MicroSeconds (edcaParameters->GetVoTxopLimit ()));
<         }
<       m_stationManager->SetQosSupport (apAddr, qosSupported);
<     }
<   if (GetHtSupported ())
<     {
<       Ptr<HtCapabilities> htCapabilities = StaticCast<HtCapabilities> (beacon.GetInformationElement (std::make_pair (IE_HT_CAPABILITIES, 0)));
<       if (!htCapabilities->IsSupportedMcs (0))
<         {
<           m_stationManager->RemoveAllSupportedMcs (apAddr);
<         }
<       else
<         {
<           m_stationManager->AddStationHtCapabilities (apAddr, htCapabilities);
<           Ptr<HtOperation> htOperation = StaticCast<HtOperation> (beacon.GetInformationElement (std::make_pair (IE_HT_OPERATION, 0)));
<           if (htOperation->GetNonGfHtStasPresent ())
<             {
<               m_stationManager->SetUseGreenfieldProtection (true);
<             }
<           else
<             {
<               m_stationManager->SetUseGreenfieldProtection (false);
<             }
<           if (!GetVhtSupported () && GetHtConfiguration ()->GetRifsSupported () && htOperation->GetRifsMode ())
<             {
<               m_stationManager->SetRifsPermitted (true);
<             }
<           else
<             {
<               m_stationManager->SetRifsPermitted (false);
<             }
<         }
<     }
<   if (GetVhtSupported ())
<     {
<       Ptr<VhtCapabilities> vhtCapabilities = StaticCast<VhtCapabilities> (beacon.GetInformationElement (std::make_pair (IE_VHT_CAPABILITIES, 0)));
<       //we will always fill in RxHighestSupportedLgiDataRate field at TX, so this can be used to check whether it supports VHT
<       if (vhtCapabilities->GetRxHighestSupportedLgiDataRate () > 0)
<         {
<           m_stationManager->AddStationVhtCapabilities (apAddr, vhtCapabilities);
<           Ptr<VhtOperation> vhtOperation = StaticCast<VhtOperation> (beacon.GetInformationElement (std::make_pair (IE_VHT_OPERATION, 0)));
<           for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<             {
<               WifiMode mcs = m_phy->GetMcs (i);
<               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedRxMcs (mcs.GetMcsValue ()))
---
>               if (m_htSupported)
859c744,753
<                   m_stationManager->AddSupportedMcs (apAddr, mcs);
---
>                   HtCapabilities htcapabilities = assocResp.GetHtCapabilities ();
>                   for (uint32_t i = 0; i < m_phy->GetNMcs (); i++)
>                     {
>                       WifiMode mcs = m_phy->GetMcs (i);
>                       if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HT && htcapabilities.IsSupportedMcs (mcs.GetMcsValue ()))
>                         {
>                           m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
>                           //here should add a control to add basic MCS when it is implemented
>                         }
>                     }
861,879c755
<             }
<         }
<     }
<   if (GetHtSupported ())
<     {
<       Ptr<ExtendedCapabilities> extendedCapabilities = StaticCast<ExtendedCapabilities> (beacon.GetInformationElement (std::make_pair (IE_EXTENDED_CAPABILITIES, 0)));
<       //TODO: to be completed
<     }
<   if (GetHeSupported ())
<     {
<       Ptr<HeCapabilities> heCapabilities = StaticCast<HeCapabilities> (beacon.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<       if (heCapabilities->GetSupportedMcsAndNss () != 0)
<         {
<           m_stationManager->AddStationHeCapabilities (apAddr, heCapabilities);
<           Ptr<HeOperation> htCapabilities = StaticCast<HeOperation> (beacon.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_OPERATION)));
<           for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<             {
<               WifiMode mcs = m_phy->GetMcs (i);
<               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities->IsSupportedRxMcs (mcs.GetMcsValue ()))
---
>               if (m_vhtSupported)
881c757,770
<                   m_stationManager->AddSupportedMcs (apAddr, mcs);
---
>                   VhtCapabilities vhtcapabilities = assocResp.GetVhtCapabilities ();
>                   for (uint32_t i = 0; i < m_phy->GetNMcs (); i++)
>                     {
>                       WifiMode mcs = m_phy->GetMcs (i);
>                       if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtcapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
>                         {
>                           m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
>                           //here should add a control to add basic MCS when it is implemented
>                         }
>                     }
>                 }
>               if (!m_linkUp.IsNull ())
>                 {
>                   m_linkUp ();
883,944d771
<             }
<         }
<     }
<   m_stationManager->SetShortPreambleEnabled (isShortPreambleEnabled);
<   m_stationManager->SetShortSlotTimeEnabled (capabilities.IsShortSlotTime ());
< }
< 
< void
< StaWifiMac::UpdateApInfoFromProbeResp (MgtProbeResponseHeader probeResp, Mac48Address apAddr, Mac48Address bssid)
< {
<   NS_LOG_FUNCTION (this << probeResp << apAddr << bssid);
<   CapabilityInformation capabilities = probeResp.GetCapabilities ();
<   SupportedRates rates = probeResp.GetSupportedRates ();
<   for (uint8_t i = 0; i < m_phy->GetNBssMembershipSelectors (); i++)
<     {
<       uint8_t selector = m_phy->GetBssMembershipSelector (i);
<       if (!rates.IsBssMembershipSelectorRate (selector))
<         {
<           NS_LOG_DEBUG ("Supported rates do not fit with the BSS membership selector");
<           return;
<         }
<     }
<   for (uint8_t i = 0; i < m_phy->GetNModes (); i++)
<     {
<       WifiMode mode = m_phy->GetMode (i);
<       if (rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
<         {
<           m_stationManager->AddSupportedMode (apAddr, mode);
<           if (rates.IsBasicRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
<             {
<               m_stationManager->AddBasicMode (mode);
<             }
<         }
<     }
< 
<   bool isShortPreambleEnabled = capabilities.IsShortPreamble ();
<   if (GetErpSupported ())
<     {
<       bool isErpAllowed = false;
<       for (uint8_t i = 0; i < m_phy->GetNModes (); i++)
<         {
<           WifiMode mode = m_phy->GetMode (i);
<           if (mode.GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM && rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
<             {
<               isErpAllowed = true;
<               break;
<             }
<         }
<       if (!isErpAllowed)
<         {
<           //disable short slot time and set cwMin to 31
<           SetSlot (MicroSeconds (20));
<           ConfigureContentionWindow (31, 1023);
<         }
<       else
<         {
<           Ptr<ErpInformation> erpInformation = StaticCast<ErpInformation> (probeResp.GetInformationElement (std::make_pair (IE_ERP_INFORMATION, 0)));
<           isShortPreambleEnabled &= !erpInformation->GetBarkerPreambleMode ();
<           if (m_stationManager->GetShortSlotTimeEnabled ())
<             {
<               //enable short slot time
<               SetSlot (MicroSeconds (9));
948,949c775,776
<               //disable short slot time
<               SetSlot (MicroSeconds (20));
---
>               NS_LOG_DEBUG ("assoc refused");
>               SetState (REFUSED);
951d777
<           ConfigureContentionWindow (15, 1023);
952a779
>       return;
954,957d780
<   m_stationManager->SetShortPreambleEnabled (isShortPreambleEnabled);
<   m_stationManager->SetShortSlotTimeEnabled (capabilities.IsShortSlotTime ());
<   SetBssid (bssid);
< }
959,1120c782,785
< void
< StaWifiMac::UpdateApInfoFromAssocResp (MgtAssocResponseHeader assocResp, Mac48Address apAddr)
< {
<   NS_LOG_FUNCTION (this << assocResp << apAddr);
<   CapabilityInformation capabilities = assocResp.GetCapabilities ();
<   SupportedRates rates = assocResp.GetSupportedRates ();
<   bool isShortPreambleEnabled = capabilities.IsShortPreamble ();
<   if (GetErpSupported ())
<     {
<       bool isErpAllowed = false;
<       for (uint8_t i = 0; i < m_phy->GetNModes (); i++)
<         {
<           WifiMode mode = m_phy->GetMode (i);
<           if (mode.GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM && rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
<             {
<               isErpAllowed = true;
<               break;
<             }
<         }
<       if (!isErpAllowed)
<         {
<           //disable short slot time and set cwMin to 31
<           SetSlot (MicroSeconds (20));
<           ConfigureContentionWindow (31, 1023);
<         }
<       else
<         {
<           Ptr<ErpInformation> erpInformation = StaticCast<ErpInformation> (assocResp.GetInformationElement (std::make_pair (IE_ERP_INFORMATION, 0)));
<           isShortPreambleEnabled &= !erpInformation->GetBarkerPreambleMode ();
<           if (m_stationManager->GetShortSlotTimeEnabled ())
<             {
<               //enable short slot time
<               SetSlot (MicroSeconds (9));
<             }
<           else
<             {
<               //disable short slot time
<               SetSlot (MicroSeconds (20));
<             }
<           ConfigureContentionWindow (15, 1023);
<         }
<     }
<   m_stationManager->SetShortPreambleEnabled (isShortPreambleEnabled);
<   m_stationManager->SetShortSlotTimeEnabled (capabilities.IsShortSlotTime ());
<   if (GetQosSupported ())
<     {
<       bool qosSupported = false;
<       Ptr<EdcaParameterSet> edcaParameters = StaticCast<EdcaParameterSet> (assocResp.GetInformationElement (std::make_pair (IE_EDCA_PARAMETER_SET, 0)));
<       if (edcaParameters->IsQosSupported ())
<         {
<           qosSupported = true;
<           //The value of the TXOP Limit field is specified as an unsigned integer, with the least significant octet transmitted first, in units of 32 μs.
<           SetEdcaParameters (AC_BE, edcaParameters->GetBeCWmin (), edcaParameters->GetBeCWmax (), edcaParameters->GetBeAifsn (), 32 * MicroSeconds (edcaParameters->GetBeTxopLimit ()));
<           SetEdcaParameters (AC_BK, edcaParameters->GetBkCWmin (), edcaParameters->GetBkCWmax (), edcaParameters->GetBkAifsn (), 32 * MicroSeconds (edcaParameters->GetBkTxopLimit ()));
<           SetEdcaParameters (AC_VI, edcaParameters->GetViCWmin (), edcaParameters->GetViCWmax (), edcaParameters->GetViAifsn (), 32 * MicroSeconds (edcaParameters->GetViTxopLimit ()));
<           SetEdcaParameters (AC_VO, edcaParameters->GetVoCWmin (), edcaParameters->GetVoCWmax (), edcaParameters->GetVoAifsn (), 32 * MicroSeconds (edcaParameters->GetVoTxopLimit ()));
<         }
<       m_stationManager->SetQosSupport (apAddr, qosSupported);
<     }
<   if (GetHtSupported ())
<     {
<       Ptr<HtCapabilities> htCapabilities = StaticCast<HtCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_HT_CAPABILITIES, 0)));
<       if (!htCapabilities->IsSupportedMcs (0))
<         {
<           m_stationManager->RemoveAllSupportedMcs (apAddr);
<         }
<       else
<         {
<           m_stationManager->AddStationHtCapabilities (apAddr, htCapabilities);
<           Ptr<HtOperation> htOperation = StaticCast<HtOperation> (assocResp.GetInformationElement (std::make_pair (IE_HT_OPERATION, 0)));
<           if (htOperation->GetNonGfHtStasPresent ())
<             {
<               m_stationManager->SetUseGreenfieldProtection (true);
<             }
<           else
<             {
<               m_stationManager->SetUseGreenfieldProtection (false);
<             }
<           if (!GetVhtSupported () && GetHtConfiguration ()->GetRifsSupported () && htOperation->GetRifsMode ())
<             {
<               m_stationManager->SetRifsPermitted (true);
<             }
<           else
<             {
<               m_stationManager->SetRifsPermitted (false);
<             }
<         }
<     }
<   if (GetVhtSupported ())
<     {
<       Ptr<VhtCapabilities> vhtCapabilities = StaticCast<VhtCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_VHT_CAPABILITIES, 0)));      //we will always fill in RxHighestSupportedLgiDataRate field at TX, so this can be used to check whether it supports VHT
<       if (vhtCapabilities->GetRxHighestSupportedLgiDataRate () > 0)
<         {
<           m_stationManager->AddStationVhtCapabilities (apAddr, vhtCapabilities);
<           Ptr<VhtOperation> vhtOperation = StaticCast<VhtOperation> (assocResp.GetInformationElement (std::make_pair (IE_VHT_OPERATION, 0)));
<         }
<     }
<   if (GetHeSupported ())
<     {
<       Ptr<HeCapabilities> heCapabilities = StaticCast<HeCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<       if (heCapabilities->GetSupportedMcsAndNss () != 0)
<         {
<           m_stationManager->AddStationHeCapabilities (apAddr, heCapabilities);
<           Ptr<HeOperation> heOperation = StaticCast<HeOperation> (assocResp.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_OPERATION)));
<           GetHeConfiguration ()->SetAttribute ("BssColor", UintegerValue (heOperation->GetBssColor ()));
<         }
<     }
<   for (uint8_t i = 0; i < m_phy->GetNModes (); i++)
<     {
<       WifiMode mode = m_phy->GetMode (i);
<       if (rates.IsSupportedRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
<         {
<           m_stationManager->AddSupportedMode (apAddr, mode);
<           if (rates.IsBasicRate (mode.GetDataRate (m_phy->GetChannelWidth ())))
<             {
<               m_stationManager->AddBasicMode (mode);
<             }
<         }
<     }
<   if (GetHtSupported ())
<     {
<       Ptr<HtCapabilities> htCapabilities = StaticCast<HtCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_HT_CAPABILITIES,0)));
<       for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<         {
<           WifiMode mcs = m_phy->GetMcs (i);
<           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HT && htCapabilities->IsSupportedMcs (mcs.GetMcsValue ()))
<             {
<               m_stationManager->AddSupportedMcs (apAddr, mcs);
<               //here should add a control to add basic MCS when it is implemented
<             }
<         }
<     }
<   if (GetVhtSupported ())
<     {
<       Ptr<VhtCapabilities> vhtCapabilities = StaticCast<VhtCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_VHT_CAPABILITIES,0)));      for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<         {
<           WifiMode mcs = m_phy->GetMcs (i);
<           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedRxMcs (mcs.GetMcsValue ()))
<             {
<               m_stationManager->AddSupportedMcs (apAddr, mcs);
<               //here should add a control to add basic MCS when it is implemented
<             }
<         }
<     }
<   if (GetHtSupported ())
<     {
<       Ptr<ExtendedCapabilities> extendedCapabilities = StaticCast<ExtendedCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_EXTENDED_CAPABILITIES, 0)));
<       //TODO: to be completed
<     }
<   if (GetHeSupported ())
<     {
<       Ptr<HeCapabilities> heCapabilities = StaticCast<HeCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<       for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
<         {
<           WifiMode mcs = m_phy->GetMcs (i);
<           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities->IsSupportedRxMcs (mcs.GetMcsValue ()))
<             {
<               m_stationManager->AddSupportedMcs (apAddr, mcs);
<               //here should add a control to add basic MCS when it is implemented
<             }
<         }
<     }
---
>   //Invoke the receive handler of our parent class to deal with any
>   //other frames. Specifically, this will handle Block Ack-related
>   //Management Action frames.
>   RegularWifiMac::Receive (packet, hdr);
1127c792,793
<   for (uint8_t i = 0; i < m_phy->GetNModes (); i++)
---
>   uint8_t nss = 1;  // Number of spatial streams is 1 for non-MIMO modes
>   if (m_htSupported || m_vhtSupported)
1129,1136c795
<       WifiMode mode = m_phy->GetMode (i);
<       uint64_t modeDataRate = mode.GetDataRate (m_phy->GetChannelWidth ());
<       NS_LOG_DEBUG ("Adding supported rate of " << modeDataRate);
<       rates.AddSupportedRate (modeDataRate);
<     }
<   if (GetHtSupported ())
<     {
<       for (uint8_t i = 0; i < m_phy->GetNBssMembershipSelectors (); i++)
---
>       for (uint32_t i = 0; i < m_phy->GetNBssMembershipSelectors (); i++)
1140a800,806
>   for (uint32_t i = 0; i < m_phy->GetNModes (); i++)
>     {
>       WifiMode mode = m_phy->GetMode (i);
>       uint64_t modeDataRate = mode.GetDataRate (m_phy->GetChannelWidth (), false, nss);
>       NS_LOG_DEBUG ("Adding supported rate of " << modeDataRate);
>       rates.AddSupportedRate (modeDataRate);
>     }
1148,1153c814,815
<   capabilities.SetShortPreamble (m_phy->GetShortPhyPreambleSupported () || GetErpSupported ());
<   capabilities.SetShortSlotTime (GetShortSlotTimeSupported () && GetErpSupported ());
<   if (GetPcfSupported ())
<     {
<       capabilities.SetCfPollable ();
<     }
---
>   capabilities.SetShortPreamble (m_phy->GetShortPlcpPreambleSupported () || m_erpSupported);
>   capabilities.SetShortSlotTime (GetShortSlotTimeSupported () && m_erpSupported);
1174c836
< StaWifiMac::SetEdcaParameters (AcIndex ac, uint32_t cwMin, uint32_t cwMax, uint8_t aifsn, Time txopLimit)
---
> StaWifiMac::SetEdcaParameters (AcIndex ac, uint8_t cwMin, uint8_t cwMax, uint8_t aifsn, Time txopLimit)
1176c838
<   Ptr<QosTxop> edca = m_edca.find (ac)->second;
---
>   Ptr<EdcaTxopN> edca = m_edca.find (ac)->second;
1181,1192d842
< }
< 
< void
< StaWifiMac::PhyCapabilitiesChanged (void)
< {
<   NS_LOG_FUNCTION (this);
<   if (IsAssociated ())
<     {
<       NS_LOG_DEBUG ("PHY capabilities changed: send reassociation request");
<       SetState (WAIT_ASSOC_RESP);
<       SendAssociationRequest (true);
<     }
diff ../../NS3-WiGig/src/wifi/model/sta-wifi-mac.h ../../ns-3-dev/src/wifi/model/sta-wifi-mac.h
22d21
< 
26,31c25,31
< #include "infrastructure-wifi-mac.h"
< #include "mgt-headers.h"
< 
< class TwoLevelAggregationTest;
< class AmpduAggregationTest;
< class HeAggregationTest;
---
> #include "regular-wifi-mac.h"
> #include "ns3/event-id.h"
> #include "ns3/packet.h"
> #include "ns3/traced-callback.h"
> #include "supported-rates.h"
> #include "amsdu-subframe-header.h"
> #include "capability-information.h"
35,36c35
< class SupportedRates;
< class CapabilityInformation;
---
> class MgtAddBaRequestHeader;
41,42c40
<  * Struct to hold information regarding observed AP through
<  * active/passive scanning
---
>  * The Wifi MAC high model for a non-AP STA in a BSS.
44,106c42
< struct ApInfo
< {
<   Mac48Address m_bssid;               ///< BSSID
<   Mac48Address m_apAddr;              ///< AP MAC address
<   double m_snr;                       ///< SNR in linear scale
<   bool m_activeProbing;               ///< Flag whether active probing is used or not
<   MgtBeaconHeader m_beacon;           ///< Beacon header
<   MgtProbeResponseHeader m_probeResp; ///< Probe Response header
< };
< 
< /**
<  * \ingroup wifi
<  *
<  * The Wifi MAC high model for a non-AP STA in a BSS. The state
<  * machine is as follows:
<  *
<    \verbatim
<    ---------       --------------                                         -----------
<    | Start |       | Associated | <-------------------------        ----> | Refused |
<    ---------       --------------                           |      /      -----------
<       |              |   /------------------------------\   |     /
<       \              v   v                              |   v    /
<        \    ----------------     ---------------     -----------------------------
<         \-> | Unassociated | --> | Wait Beacon | --> | Wait Association Response |
<             ----------------     ---------------     -----------------------------
<                   \                  ^     ^ |              ^    ^ |
<                    \                 |     | |              |    | |
<                     \                v      -               /     -
<                      \    -----------------------          /
<                       \-> | Wait Probe Response | --------/
<                           -----------------------
<                                   ^ |
<                                   | |
<                                    -
<    \endverbatim
<  *
<  * Notes:
<  * 1. The state 'Start' is not included in #MacState and only used
<  *    for illustration purpose.
<  * 2. The Unassociated state is a transient state before STA starts the
<  *    scanning procedure which moves it into either Wait Beacon or Wait
<  *    Probe Response, based on whether passive or active scanning is
<  *    selected.
<  * 3. In Wait Beacon and Wait Probe Response, STA is gathering beacon or
<  *    probe response packets from APs, resulted in a list of candidate AP.
<  *    After the respective timeout, it then tries to associate to the best
<  *    AP (i.e., best SNR). STA will switch between the two states and
<  *    restart the scanning procedure if SetActiveProbing() called.
<  * 4. In the case when AP responded to STA's association request with a
<  *    refusal, STA will try to associate to the next best AP until the list
<  *    of candidate AP is exhausted which sends STA to Refused state.
<  *    - Note that this behavior is not currently tested since ns-3 does not
<   *     implement association refusal at present.
<  * 5. The transition from Wait Association Response to Unassociated
<  *    occurs if an association request fails without explicit
<  *    refusal (i.e., the AP fails to respond).
<  * 6. The transition from Associated to Wait Association Response
<  *    occurs when STA's PHY capabilities changed. In this state, STA
<  *    tries to reassociate with the previously associated AP.
<  * 7. The transition from Associated to Unassociated occurs if the number
<  *    of missed beacons exceeds the threshold.
<  */
< class StaWifiMac : public InfrastructureWifiMac
---
> class StaWifiMac : public RegularWifiMac
109,118d44
<   /// Allow test cases to access private members
<   friend class ::TwoLevelAggregationTest;
<   /// Allow test cases to access private members
<   friend class ::AmpduAggregationTest;
<   /// Allow test cases to access private members
<   friend class ::HeAggregationTest;
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
125,131d50
<    * Set up WifiRemoteStationManager associated with this StaWifiMac.
<    *
<    * \param stationManager the station manager attached to this MAC.
<    */
<   void SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> stationManager);
< 
<   /**
135c54
<    * The packet should be enqueued in a TX queue, and should be
---
>    * The packet should be enqueued in a tx queue, and should be
139c58
<   void Enqueue (Ptr<Packet> packet, Mac48Address to);
---
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to);
142c61,62
<    * \param phy the physical layer attached to this MAC.
---
>    * \param missed the number of beacons which must be missed
>    * before a new association sequence is started.
144,145c64
<   void SetWifiPhy (const Ptr<WifiPhy> phy);
< 
---
>   void SetMaxMissedBeacons (uint32_t missed);
147c66
<    * Return whether we are associated with an AP.
---
>    * \param timeout
149c68,69
<    * \return true if we are associated with an AP, false otherwise
---
>    * If no probe response is received within the specified
>    * timeout, the station sends a new probe request.
151,152c71
<   bool IsAssociated (void) const;
< 
---
>   void SetProbeRequestTimeout (Time timeout);
154c73
<    * Return the association ID.
---
>    * \param timeout
156c75,81
<    * \return the association ID
---
>    * If no association response is received within the specified
>    * timeout, the station sends a new association request.
>    */
>   void SetAssocRequestTimeout (Time timeout);
> 
>   /**
>    * Start an active association sequence immediately.
158c83
<   uint16_t GetAssociationId (void) const;
---
>   void StartActiveAssociation (void);
160,161d84
< protected:
<   Ptr<MultiBandElement> GetMultiBandElement (void) const;
170d92
<     WAIT_BEACON,
173c95
<     UNASSOCIATED,
---
>     BEACON_MISSED,
190,227c112
<   /**
<    * Handle a received packet.
<    *
<    * \param mpdu the received MPDU
<    */
<   void Receive (Ptr<WifiMacQueueItem> mpdu);
<   /**
<    * Update associated AP's information from beacon. If STA is not associated,
<    * this information will used for the association process.
<    *
<    * \param beacon the beacon header
<    * \param apAddr MAC address of the AP
<    * \param bssid MAC address of BSSID
<    */
<   void UpdateApInfoFromBeacon (MgtBeaconHeader beacon, Mac48Address apAddr, Mac48Address bssid);
<   /**
<    * Update AP's information from probe response. This information is required
<    * for the association process.
<    *
<    * \param probeResp the probe response header
<    * \param apAddr MAC address of the AP
<    * \param bssid MAC address of BSSID
<    */
<   void UpdateApInfoFromProbeResp (MgtProbeResponseHeader probeResp, Mac48Address apAddr, Mac48Address bssid);
<   /**
<    * Update AP's information from association response.
<    *
<    * \param assocResp the association response header
<    * \param apAddr MAC address of the AP
<    */
<   void UpdateApInfoFromAssocResp (MgtAssocResponseHeader assocResp, Mac48Address apAddr);
<   /**
<    * Update list of candidate AP to associate. The list should contain ApInfo sorted from
<    * best to worst SNR, with no duplicate.
<    *
<    * \param newApInfo the new ApInfo to be inserted
<    */
<   void UpdateCandidateApList (ApInfo newApInfo);
---
>   virtual void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
235,244c120,121
<    * Forward an association or reassociation request packet to the DCF.
<    * The standard is not clear on the correct queue for management frames if QoS is supported.
<    * We always use the DCF.
<    *
<    * \param isReassoc flag whether it is a reassociation request
<    *
<    */
<   void SendAssociationRequest (bool isReassoc);
<   /**
<    * Forward a CF-Poll response packet to the CFP queue.
---
>    * Forward an association request packet to the DCF. The standard is not clear on the correct
>    * queue for management frames if QoS is supported. We always use the DCF.
246c123
<   void SendCfPollResponse (void);
---
>   void SendAssociationRequest (void);
258,259c135,136
<    * Start the scanning process which trigger active or passive scanning based on the
<    * active probing flag.
---
>    * This method is called after the probe request timeout occurred. We switch the state to
>    * WAIT_PROBE_RESP and re-send a probe request.
261c138
<   void StartScanning (void);
---
>   void ProbeRequestTimeout (void);
263,265c140,142
<    * This method is called after wait beacon timeout or wait probe request timeout has
<    * occurred. This will trigger association process from beacons or probe responses
<    * gathered while scanning.
---
>    * Return whether we are associated with an AP.
>    *
>    * \return true if we are associated with an AP, false otherwise
267c144
<   void ScanningTimeout (void);
---
>   bool IsAssociated (void) const;
296c173
<   void SetState (MacState value);
---
>   void SetState (enum MacState value);
306c183
<   void SetEdcaParameters (AcIndex ac, uint32_t cwMin, uint32_t cwMax, uint8_t aifsn, Time txopLimit);
---
>   void SetEdcaParameters (AcIndex ac, uint8_t cwMin, uint8_t cwMax, uint8_t aifsn, Time txopLimit);
314,319c191,199
<   /**
<    * Indicate that PHY capabilities have changed.
<    */
<   void PhyCapabilitiesChanged (void);
< 
<   void DoInitialize (void);
---
>   enum MacState m_state;
>   Time m_probeRequestTimeout;
>   Time m_assocRequestTimeout;
>   EventId m_probeRequestEvent;
>   EventId m_assocRequestEvent;
>   EventId m_beaconWatchdog;
>   Time m_beaconWatchdogEnd;
>   uint32_t m_maxMissedBeacons;
>   bool m_activeProbing;
321,341c201,202
<   MacState m_state;            ///< MAC state
<   uint16_t m_aid;              ///< Association AID
<   Time m_waitBeaconTimeout;    ///< wait beacon timeout
<   Time m_probeRequestTimeout;  ///< probe request timeout
<   Time m_assocRequestTimeout;  ///< association request timeout
<   EventId m_waitBeaconEvent;   ///< wait beacon event
<   EventId m_probeRequestEvent; ///< probe request event
<   EventId m_assocRequestEvent; ///< association request event
<   EventId m_beaconWatchdog;    ///< beacon watchdog
<   Time m_beaconWatchdogEnd;    ///< beacon watchdog end
<   uint32_t m_maxMissedBeacons; ///< maximum missed beacons
<   bool m_activeProbing;        ///< active probing
<   std::vector<ApInfo> m_candidateAps; ///< list of candidate APs to associate to
<   // Note: std::multiset<ApInfo> might be a candidate container to implement
<   // this sorted list, but we are using a std::vector because we want to sort
<   // based on SNR but find duplicates based on BSSID, and in practice this
<   // candidate vector should not be too large.
< 
<   TracedCallback<Mac48Address> m_assocLogger;   ///< association logger
<   TracedCallback<Mac48Address> m_deAssocLogger; ///< disassociation logger
<   TracedCallback<Time>         m_beaconArrival; ///< beacon arrival logger
---
>   TracedCallback<Mac48Address> m_assocLogger;
>   TracedCallback<Mac48Address> m_deAssocLogger;
diff ../../NS3-WiGig/src/wifi/model/supported-rates.cc ../../ns-3-dev/src/wifi/model/supported-rates.cc
21d20
< #include "ns3/log.h"
22a22,23
> #include "ns3/assert.h"
> #include "ns3/log.h"
30d30
< #define BSS_MEMBERSHIP_SELECTOR_HE_PHY 125
59c59
< SupportedRates::AddSupportedRate (uint64_t bs)
---
> SupportedRates::AddSupportedRate (uint32_t bs)
64c64
<   if (IsSupportedRate (bs))
---
>   if (bs == BSS_MEMBERSHIP_SELECTOR_HT_PHY)
66c66,86
<       return;
---
>       // Encoding defined in Sec. 8.4.2.3, IEEE 802.11-2012
>       m_rates[m_nRates] = (BSS_MEMBERSHIP_SELECTOR_HT_PHY | 0x80);
>       m_nRates++;
>       NS_LOG_DEBUG ("add HT_PHY membership selector");
>     }
>   else if (bs == BSS_MEMBERSHIP_SELECTOR_VHT_PHY)
>     {
>       // Encoding defined in Sec. 8.4.2.3, IEEE 802.11-2012
>       m_rates[m_nRates] = (BSS_MEMBERSHIP_SELECTOR_VHT_PHY | 0x80);
>       m_nRates++;
>       NS_LOG_DEBUG ("add VHT_PHY membership selector");
>     }
>   else 
>     {
>       if (IsSupportedRate (bs))
>         {
>           return;
>         }
>       m_rates[m_nRates] = bs / 500000;
>       m_nRates++;
>       NS_LOG_DEBUG ("add rate=" << bs << ", n rates=" << (uint32_t)m_nRates);
68,70d87
<   m_rates[m_nRates] = static_cast<uint8_t> (bs / 500000);
<   m_nRates++;
<   NS_LOG_DEBUG ("add rate=" << bs << ", n rates=" << +m_nRates);
74c91
< SupportedRates::SetBasicRate (uint64_t bs)
---
> SupportedRates::SetBasicRate (uint32_t bs)
78c95
<   uint8_t rate = static_cast<uint8_t> (bs / 500000);
---
>   uint8_t rate = bs / 500000;
87c104
<           NS_LOG_DEBUG ("set basic rate=" << bs << ", n rates=" << +m_nRates);
---
>           NS_LOG_DEBUG ("set basic rate=" << bs << ", n rates=" << (uint32_t)m_nRates);
97c114
< SupportedRates::AddBssMembershipSelectorRate (uint64_t bs)
---
> SupportedRates::AddBssMembershipSelectorRate (uint32_t bs)
100,104c117,121
<   NS_ASSERT_MSG (bs == BSS_MEMBERSHIP_SELECTOR_HT_PHY ||
<  	         bs == BSS_MEMBERSHIP_SELECTOR_VHT_PHY ||
<  	         bs == BSS_MEMBERSHIP_SELECTOR_HE_PHY,
<                  "Value " << bs << " not a BSS Membership Selector");
<   uint8_t rate = static_cast<uint8_t> (bs / 500000);
---
>   if ((bs != BSS_MEMBERSHIP_SELECTOR_HT_PHY) && (bs != BSS_MEMBERSHIP_SELECTOR_VHT_PHY))
>     {
>       NS_ASSERT_MSG (false, "Value " << bs << " not a BSS Membership Selector");
>     }
>   uint32_t rate = (bs | 0x80); 
113c130
<   NS_LOG_DEBUG ("add BSS membership selector rate " << bs << " as rate " << +rate);
---
>   NS_LOG_DEBUG ("add BSS membership selector rate " << bs << " as rate " << m_nRates);
118c135
< SupportedRates::IsBasicRate (uint64_t bs) const
---
> SupportedRates::IsBasicRate (uint32_t bs) const
121c138
<   uint8_t rate = static_cast<uint8_t> (bs / 500000) | 0x80;
---
>   uint8_t rate = (bs / 500000) | 0x80;
133c150
< SupportedRates::IsSupportedRate (uint64_t bs) const
---
> SupportedRates::IsSupportedRate (uint32_t bs) const
136c153
<   uint8_t rate = static_cast<uint8_t> (bs / 500000);
---
>   uint8_t rate = bs / 500000;
149c166
< SupportedRates::IsBssMembershipSelectorRate (uint64_t bs) const
---
> SupportedRates::IsBssMembershipSelectorRate (uint32_t bs) const
152,154c169
<   if ((bs & 0x7f) == BSS_MEMBERSHIP_SELECTOR_HT_PHY
<       || (bs & 0x7f) == BSS_MEMBERSHIP_SELECTOR_VHT_PHY
<       || (bs & 0x7f) == BSS_MEMBERSHIP_SELECTOR_HE_PHY)
---
>   if ( (bs & 0x7f) == BSS_MEMBERSHIP_SELECTOR_HT_PHY || (bs & 0x7f) == BSS_MEMBERSHIP_SELECTOR_VHT_PHY)
296a312,319
> /**
>  * Serialize SupportedRates to the given ostream.
>  *
>  * \param os
>  * \param rates
>  *
>  * \return std::ostream
>  */
diff ../../NS3-WiGig/src/wifi/model/supported-rates.h ../../ns-3-dev/src/wifi/model/supported-rates.h
24c24,27
< #include "wifi-information-element.h"
---
> #include <stdint.h>
> #include <ostream>
> #include "ns3/buffer.h"
> #include "ns3/wifi-information-element.h"
50c53
<    * \param rates the extended supported rates
---
>    * \param rates
54c57,58
<   // Implementations of pure virtual methods of WifiInformationElement
---
>   void SetSupportedRates (SupportedRates *rates);
> 
60,65d63
<   /* This information element is a bit special in that it is only
<     included if there are more than 8 rates. To support this we
<     override the Serialize and GetSerializedSize methods of
<     WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
68c66,71
<    * Set supported rates.
---
>    * This information element is a bit special in that it is only
>    * included if there are more than 8 rates. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
70c73
<    * \param rates the supported rates
---
>    * \return an iterator
72,74c75,83
<   void SetSupportedRates (SupportedRates *rates);
< 
< 
---
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this supported rates
>    * information element.
>    *
>    * \return the serialized size of this supported rates
>    *         information element
>    */
>   uint16_t GetSerializedSize () const;
100d108
<   /// type conversion operator
101a110
>   SupportedRates& operator= (const SupportedRates&);
103,123c112,117
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
< 
<   /**
<    * assignment operator
<    *
<    * \param rates the rates to assign
<    * \returns the assigned value
<    */
<   SupportedRates& operator= (const SupportedRates& rates);
< 
<   /**
<    * This defines the maximum number of supported rates that a STA is
<    * allowed to have. Currently this number is set for IEEE 802.11b/g and SISO IEEE 802.11n
<    * stations which need 2 rates each from Clauses 15 and 18, and then 8
<    * from Clause 19.
<    */
---
> /**
>  * This defines the maximum number of supported rates that a STA is
>  * allowed to have. Currently this number is set for IEEE 802.11b/g and SISO IEE 802.11n
>  * stations which need 2 rates each from Clauses 15 and 18, and then 8
>  * from Clause 19.
>  */
129c123
<    * \param bs the rate to be added in bps
---
>    * \param bs the rate to be added
131c125
<   void AddSupportedRate (uint64_t bs);
---
>   void AddSupportedRate (uint32_t bs);
135c129
<    * \param bs the rate to be set in bps
---
>    * \param bs the rate to be set
137c131
<   void SetBasicRate (uint64_t bs);
---
>   void SetBasicRate (uint32_t bs);
144c138
<   void AddBssMembershipSelectorRate (uint64_t bs);
---
>   void AddBssMembershipSelectorRate (uint32_t bs);
150c144
<    * \param bs the rate to be checked in bps
---
>    * \param bs the rate to be checked
154c148
<   bool IsSupportedRate (uint64_t bs) const;
---
>   bool IsSupportedRate (uint32_t bs) const;
160c154
<    * \param bs the rate to be checked in bps
---
>    * \param bs the rate to be checked
164c158
<   bool IsBasicRate (uint64_t bs) const;
---
>   bool IsBasicRate (uint32_t bs) const;
170c164
<    * \param bs the rate to be checked in bps
---
>    * \param bs the rate to be checked
174c168
<   bool IsBssMembershipSelectorRate (uint64_t bs) const;
---
>   bool IsBssMembershipSelectorRate (uint32_t bs) const;
186c180
<    * \return the rate in bps
---
>    * \return the rate
190c184,190
<   /**
---
>   WifiInformationElementId ElementId () const;
>   uint8_t GetInformationFieldSize () const;
>   void SerializeInformationField (Buffer::Iterator start) const;
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
> 
>   /*
198c198
<   ExtendedSupportedRatesIE extended; //!< extended supported rates info element
---
>   ExtendedSupportedRatesIE extended;
203c203
<   uint8_t m_rates[MAX_SUPPORTED_RATES];  //!< List of supported bit rates (divided by 500000)
---
>   uint8_t m_rates[MAX_SUPPORTED_RATES];  //!< List of supported bitrate (divided by 500000)
206,213d205
< /**
<  * Serialize SupportedRates to the given ostream.
<  *
<  * \param os output stream
<  * \param rates the SupportedRates
<  *
<  * \return std::ostream
<  */
Only in ../../NS3-WiGig/src/wifi/model: threshold-preamble-detection-model.cc
Only in ../../NS3-WiGig/src/wifi/model: threshold-preamble-detection-model.h
Only in ../../NS3-WiGig/src/wifi/model: txop.cc
Only in ../../NS3-WiGig/src/wifi/model: txop.h
diff ../../NS3-WiGig/src/wifi/model/vht-capabilities.cc ../../ns-3-dev/src/wifi/model/vht-capabilities.cc
22a23,26
> #include "ns3/assert.h"
> #include "ns3/log.h"
> 
> NS_LOG_COMPONENT_DEFINE ("VhtCapabilities");
52,56d55
<   for (uint8_t i = 0; i < 8; i++) //set to 3 by default, i.e. #spatial streams not supported. 0 means supported up to MCS 7, not what we want to imply at this stage.
<     {
<       m_rxMcsMap[i] = 3;
<       m_txMcsMap[i] = 3;
<     }
66c65
< VhtCapabilities::SetVhtSupported (uint8_t vhtSupported)
---
> VhtCapabilities::SetVhtSupported (uint8_t vhtsupported)
68c67
<   m_vhtSupported = vhtSupported;
---
>   m_vhtSupported = vhtsupported;
74c73
<   //we should not be here if vht is not supported
---
>   //we should not be here if ht is not supported
115c114
<   uint32_t vhtinfo = i.ReadLsbtohU32 ();
---
>   uint16_t vhtinfo = i.ReadLsbtohU32 ();
184c183
<       n = (i * 2) + 32;
---
>       uint16_t n = (i * 2) + 32;
198c197
<       val |= (static_cast<uint64_t> (m_rxMcsMap[i]) & 0x03) << n;
---
>       val |= ((uint64_t)m_rxMcsMap[i] & 0x03) << n;
200c199
<   val |=  (static_cast<uint64_t> (m_rxHighestSupportedLongGuardIntervalDataRate) & 0x1fff) << 16;
---
>   val |=  ((uint64_t)m_rxHighestSupportedLongGuardIntervalDataRate & 0x1fff) << 16;
204c203
<       val |= (static_cast<uint64_t> (m_txMcsMap[i]) & 0x03) << n;
---
>       val |= ((uint64_t)m_txMcsMap[i] & 0x03) << n;
206c205
<   val |= (static_cast<uint64_t> (m_txHighestSupportedLongGuardIntervalDataRate) & 0x1fff) << 48;
---
>   val |= ((uint64_t)m_txHighestSupportedLongGuardIntervalDataRate & 0x1fff) << 48;
211c210
< VhtCapabilities::SetMaxMpduLength (uint16_t length)
---
> VhtCapabilities::SetMaxMpduLength (uint8_t length)
213,226c212,218
<   NS_ABORT_MSG_IF (length != 3895 && length != 7991 && length != 11454,
<                    "Invalid MPDU Max Length value");
<   if (length == 11454)
<     {
<       m_maxMpduLength = 2;
<     }
<   else if (length == 7991)
<     {
<       m_maxMpduLength = 1;
<     }
<   else
<     {
<       m_maxMpduLength = 0;
<     }
---
>   m_maxMpduLength = length;
> }
> 
> void
> VhtCapabilities::SetSupportedChannelWidthSet (uint8_t channelwidthset)
> {
>   m_supportedChannelWidthSet = channelwidthset;
230c222
< VhtCapabilities::SetSupportedChannelWidthSet (uint8_t channelWidthSet)
---
> VhtCapabilities::SetRxLdpc (uint8_t rxldpc)
232c224
<   m_supportedChannelWidthSet = channelWidthSet;
---
>   m_rxLdpc = rxldpc;
236c228
< VhtCapabilities::SetRxLdpc (uint8_t rxLdpc)
---
> VhtCapabilities::SetShortGuardIntervalFor80Mhz (uint8_t shortguardinterval)
238c230
<   m_rxLdpc = rxLdpc;
---
>   m_shortGuardIntervalFor80Mhz = shortguardinterval;
242c234
< VhtCapabilities::SetShortGuardIntervalFor80Mhz (uint8_t shortGuardInterval)
---
> VhtCapabilities::SetShortGuardIntervalFor160Mhz (uint8_t shortguardinterval)
244c236
<   m_shortGuardIntervalFor80Mhz = shortGuardInterval;
---
>   m_shortGuardIntervalFor160Mhz = shortguardinterval;
248c240
< VhtCapabilities::SetShortGuardIntervalFor160Mhz (uint8_t shortGuardInterval)
---
> VhtCapabilities::SetRxStbc (uint8_t rxstbc)
250c242
<   m_shortGuardIntervalFor160Mhz = shortGuardInterval;
---
>   m_rxStbc = rxstbc;
254c246
< VhtCapabilities::SetRxStbc (uint8_t rxStbc)
---
> VhtCapabilities::SetTxStbc (uint8_t txstbc)
256c248
<   m_rxStbc = rxStbc;
---
>   m_txStbc = txstbc;
260c252
< VhtCapabilities::SetTxStbc (uint8_t txStbc)
---
> VhtCapabilities::SetMaxAmpduLengthExponent (uint8_t exponent)
262c254
<   m_txStbc = txStbc;
---
>   m_maxAmpduLengthExponent = exponent;
266c258
< VhtCapabilities::SetMaxAmpduLength (uint32_t maxampdulength)
---
> VhtCapabilities::SetRxMcsMap (uint16_t map)
268c260,262
<   for (uint8_t i = 0; i <= 7; i++)
---
>   //Set each element in the map accoriding to the 2 bits representing it page 98 in the 11ac standard
>   uint8_t n;
>   for (uint8_t i = 0; i < 8; i++)
270,274c264,265
<       if ((1ul << (13 + i)) - 1 == maxampdulength)
<         {
<           m_maxAmpduLengthExponent = i;
<           return;
<         }
---
>       n = i * 2;
>       m_rxMcsMap[i] = (map >> n) & 0x03;
276d266
<   NS_ABORT_MSG ("Invalid A-MPDU Max Length value");
287a278,289
> VhtCapabilities::SetTxMcsMap (uint16_t map)
> {
>   //Set each element in the map accoriding to the 2 bits representing it page 98 in the 11ac standard
>   uint8_t n;
>   for (uint8_t i = 0; i < 8; i++)
>     {
>       n = i * 2;
>       m_txMcsMap[i] = (map >> n) & 0x03;
>     }
> }
> 
> void
334c336
< VhtCapabilities::SetRxHighestSupportedLgiDataRate (uint16_t supportedDatarate)
---
> VhtCapabilities::SetRxHighestSupportedLgiDataRate (uint16_t supporteddatarate)
336c338
<   m_rxHighestSupportedLongGuardIntervalDataRate = supportedDatarate;
---
>   m_rxHighestSupportedLongGuardIntervalDataRate = supporteddatarate;
340c342
< VhtCapabilities::SetTxHighestSupportedLgiDataRate (uint16_t supportedDatarate)
---
> VhtCapabilities::SetTxHighestSupportedLgiDataRate (uint16_t supporteddatarate)
342c344
<   m_txHighestSupportedLongGuardIntervalDataRate = supportedDatarate;
---
>   m_txHighestSupportedLongGuardIntervalDataRate = supporteddatarate;
345,346c347,348
< uint16_t
< VhtCapabilities::GetMaxMpduLength (void) const
---
> uint8_t
> VhtCapabilities::GetMaxMpduLength () const
348,360c350
<   if (m_maxMpduLength == 0)
<     {
<       return 3895;
<     }
<   if (m_maxMpduLength == 1)
<     {
<       return 7991;
<     }
<   if (m_maxMpduLength == 2)
<     {
<       return 11454;
<     }
<   NS_ABORT_MSG ("The value 3 is reserved");
---
>   return m_maxMpduLength;
375a366,377
> VhtCapabilities::GetShortGuardIntervalFor80Mhz () const
> {
>   return m_shortGuardIntervalFor80Mhz;
> }
> 
> uint8_t
> VhtCapabilities::GetShortGuardIntervalFor160Mhz () const
> {
>   return m_shortGuardIntervalFor160Mhz;
> }
> 
> uint8_t
387,388c389,390
< uint32_t
< VhtCapabilities::GetMaxAmpduLength (void) const
---
> uint8_t
> VhtCapabilities::GetMaxAmpduLengthExponent () const
390c392
<   return (1ul << (13 + m_maxAmpduLengthExponent)) - 1;
---
>   return m_maxAmpduLengthExponent;
412a415,440
> VhtCapabilities::GetRxMcsMap () const
> {
>   uint16_t val = 0;
>   uint8_t n;
>   for (uint8_t i = 0; i < 8; i++)
>     {
>       n = i * 2;
>       val |= (m_rxMcsMap[i] & 0x03) << n;
>     }
>   return val;
> }
> 
> uint16_t
> VhtCapabilities::GetTxMcsMap () const
> {
>   uint16_t val = 0;
>   uint8_t n;
>   for (uint8_t i = 0; i < 8; i++)
>     {
>       n = i * 2;
>       val |= (m_txMcsMap[i] & 0x03) << n;
>     }
>   return val;
> }
> 
> uint16_t
417a446,453
> uint16_t
> VhtCapabilities::GetTxHighestSupportedLgiDataRate () const
> {
>   return m_txHighestSupportedLongGuardIntervalDataRate;
> }
> 
> ATTRIBUTE_HELPER_CPP (VhtCapabilities);
> 
423a460,470
> }
> 
> std::istream &operator >> (std::istream &is,VhtCapabilities &VhtCapabilities)
> {
>   uint32_t c1;
>   uint64_t c2;
>   is >>  c1 >> c2;
>   VhtCapabilities.SetVhtCapabilitiesInfo (c1);
>   VhtCapabilities.SetSupportedMcsAndNssSet (c2);
> 
>   return is;
diff ../../NS3-WiGig/src/wifi/model/vht-capabilities.h ../../ns-3-dev/src/wifi/model/vht-capabilities.h
25c25,28
< #include "wifi-information-element.h"
---
> #include <stdint.h>
> #include "ns3/buffer.h"
> #include "ns3/attribute-helper.h"
> #include "ns3/wifi-information-element.h"
37a41
>   void SetVhtSupported (uint8_t vhtsupported);
39d42
<   // Implementations of pure virtual methods of WifiInformationElement
44,56d46
<   /* This information element is a bit special in that it is only
<      included if the STA is an VHT STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
<   /**
<    * Set the VHT supported field.
<    *
<    * \param vhtSupported the VHT supported field
<    */
<   void SetVhtSupported (uint8_t vhtSupported);
59c49
<    * Set the VHT Capabilities Info field in the VHT Capabilities information element.
---
>    * Set the VHT Capabilties Info field in the VHT Capabilities information element.
61c51
<    * \param ctrl the VHT Capabilities Info field in the VHT Capabilities information element
---
>    * \param ctrl the VHT Capabilties Info field in the VHT Capabilities information element
71,72c61,62
<   /**
<    * Return the VHT Capabilities Info field in the VHT Capabilities information element.
---
>   /*
>    * Return the VHT Capabilties Info field in the VHT Capabilities information element.
74c64
<    * \return the VHT Capabilities Info field in the VHT Capabilities information element
---
>    * \return the VHT Capabilties Info field in the VHT Capabilities information element
77c67
<   /**
---
>   /*
85,132c75,82
<   /**
<    * Set the maximum MPDU length.
<    *
<    * \param length the maximum MPDU length (3895, 7991 or 11454)
<    */
<   void SetMaxMpduLength (uint16_t length);
<   /**
<    * Set the supported channel width set.
<    *
<    * \param channelWidthSet the supported channel width set
<    */
<   void SetSupportedChannelWidthSet (uint8_t channelWidthSet);
<   /**
<    * Set the receive LDPC.
<    *
<    * \param rxLdpc the receive LDPC
<    */
<   void SetRxLdpc (uint8_t rxLdpc);
<   /**
<    * Set the short guard interval 80 MHz.
<    *
<    * \param shortGuardInterval the short guard interval 80 MHz
<    */
<   void SetShortGuardIntervalFor80Mhz (uint8_t shortGuardInterval);
<   /**
<    * Set the short guard interval 160 MHz.
<    *
<    * \param shortGuardInterval the short guard interval 160 MHz
<    */
<   void SetShortGuardIntervalFor160Mhz (uint8_t shortGuardInterval);
<   /**
<    * Set the receive STBC.
<    *
<    * \param rxStbc the receive STBC
<    */
<   void SetRxStbc (uint8_t rxStbc);
<   /**
<    * Set the transmit STBC.
<    *
<    * \param txStbc the receive STBC
<    */
<   void SetTxStbc (uint8_t txStbc);
<   /**
<    * Set the maximum AMPDU length.
<    *
<    * \param maxAmpduLength 2^(13 + x) - 1, x in the range 0 to 7
<    */
<   void SetMaxAmpduLength (uint32_t maxAmpduLength);
---
>   void SetMaxMpduLength (uint8_t length);
>   void SetSupportedChannelWidthSet (uint8_t channelwidthset);
>   void SetRxLdpc (uint8_t rxldpc);
>   void SetShortGuardIntervalFor80Mhz (uint8_t shortguardinterval);
>   void SetShortGuardIntervalFor160Mhz (uint8_t shortguardinterval);
>   void SetRxStbc (uint8_t rxstbc);
>   void SetTxStbc (uint8_t txstbc);
>   void SetMaxAmpduLengthExponent (uint8_t exponent);
134,144c84
<   /**
<    * Get the maximum MPDU length.
<    *
<    * \return the maximum MPDU length in bytes
<    */
<   uint16_t GetMaxMpduLength (void) const;
<   /**
<    * Get the supported channel width set.
<    *
<    * \returns the supported channel width set
<    */
---
>   uint8_t GetMaxMpduLength () const;
146,150d85
<   /**
<    * Get the receive LDPC.
<    *
<    * \returns the receive LDPC
<    */
152,156c87,88
<   /**
<    * Get the receive STBC.
<    *
<    * \returns the receive STBC
<    */
---
>   uint8_t GetShortGuardIntervalFor80Mhz () const;
>   uint8_t GetShortGuardIntervalFor160Mhz () const;
158,162d89
<   /**
<    * Get the transmit STBC.
<    *
<    * \returns the transmit STBC
<    */
163a91
>   uint8_t GetMaxAmpduLengthExponent () const;
164a93,101
>   // MCS and NSS field information
>   // For each value of NSS ranging from 1 to 8, we need to encode two bits.
>   // The value 0 indicates that the maximum MCS for that spatial stream is 7.
>   // The value 1 indicates that the maximum MCS for that spatial stream is 8.
>   // The value 2 indicates that the maximum MCS for that spatial stream is 9.
>   //
>   // The maps may be set all at once by passing in a 16-bit field corresponding
>   // to the above, or incrementally for each NSS separately, where the 
>   // MCS value must be in the range 7-9.
166,167c103
<    * \param mcs Max MCS value (between 7 and 9)
<    * \param nss Spatial stream for which the Max MCS value is being set
---
>    * \param map The 16-bit encoding of Max MCS for each of 8 spatial streams
169c105
<   void SetRxMcsMap (uint8_t mcs, uint8_t nss);
---
>   void SetRxMcsMap (uint16_t map);
174,180c110
<   void SetTxMcsMap (uint8_t mcs, uint8_t nss);
<   /**
<    * Set the receive highest supported LGI data rate.
<    *
<    * \param supportedDatarate receive highest supported LGI data rate
<    */
<   void SetRxHighestSupportedLgiDataRate (uint16_t supportedDatarate);
---
>   void SetRxMcsMap (uint8_t mcs, uint8_t nss);
182,184c112
<    * Set the transmit highest supported LGI data rate.
<    *
<    * \param supportedDatarate transmit highest supported LGI data rate
---
>    * \param map The 16-bit encoding of Max MCS for each of 8 spatial streams
186c114
<   void SetTxHighestSupportedLgiDataRate (uint16_t supportedDatarate);
---
>   void SetTxMcsMap (uint16_t map);
188,192c116,117
<    * Get the is MCS supported.
<    *
<    * \param mcs the MCS
<    * \param nss the NSS
<    * \returns the is MCS supported
---
>    * \param mcs Max MCS value (between 7 and 9)
>    * \param nss Spatial stream for which the Max MCS value is being set
194c119,122
<   bool IsSupportedMcs (uint8_t mcs, uint8_t nss) const;
---
>   void SetTxMcsMap (uint8_t mcs, uint8_t nss);
>   void SetRxHighestSupportedLgiDataRate (uint16_t supporteddatarate);
>   void SetTxHighestSupportedLgiDataRate (uint16_t supporteddatarate);
>   bool IsSupportedMcs (uint8_t mcs, uint8_t Nss) const;
196,200c124,125
<   /**
<    * Get the receive highest supported LGI data rate.
<    *
<    * \returns the receive highest supported LGI data rate.
<    */
---
>   uint16_t GetRxMcsMap () const;
>   uint16_t GetTxMcsMap () const;
201a127
>   uint16_t GetTxHighestSupportedLgiDataRate () const;
203,208d128
<   /**
<    * Returns true if transmit MCS is supported.
<    *
<    * \param mcs the MCS
<    * \returns whether transmit MCS is supported
<    */
210,215d129
<   /**
<    * Returns true if receive MCS is supported.
<    *
<    * \param mcs the MCS
<    * \returns whether receive MCS is supported
<    */
218,221c132,136
<   /**
<    * Return the maximum A-MPDU length.
<    *
<    * \return the maximum A-MPDU length in bytes
---
>   /*
>    * This information element is a bit special in that it is only
>    * included if the STA is an VHT STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
223c138,139
<   uint32_t GetMaxAmpduLength (void) const;
---
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   uint16_t GetSerializedSize () const;
228,246c144,162
<   uint8_t m_maxMpduLength;               ///< maximum MPDU length
<   uint8_t m_supportedChannelWidthSet;    ///< supported channel width set
<   uint8_t m_rxLdpc;                      ///< receive LDPC
<   uint8_t m_shortGuardIntervalFor80Mhz;  ///< short guard interval for 80 MHz
<   uint8_t m_shortGuardIntervalFor160Mhz; ///< short guard interval for 160 MHz
<   uint8_t m_txStbc;                      ///< transmit STBC
<   uint8_t m_rxStbc;                      ///< receive STBC
<   uint8_t m_suBeamformerCapable;         ///< SU beamformer capable
<   uint8_t m_suBeamformeeCapable;         ///< SU beamformee capable
<   uint8_t m_beamformeeStsCapable;        ///< beamformee STS capable
<   uint8_t m_numberOfSoundingDimensions;  ///< number of sounding dimensions
<   uint8_t m_muBeamformerCapable;         ///< MU beamformer capable
<   uint8_t m_muBeamformeeCapable;         ///< MU beamformee capable
<   uint8_t m_vhtTxopPs;                   ///< VHT TXOP PS
<   uint8_t m_htcVhtCapable;               ///< HTC VHT capable
<   uint8_t m_maxAmpduLengthExponent;      ///< maximum A-MPDU length exponent
<   uint8_t m_vhtLinkAdaptationCapable;    ///< VHT link adaptation capable
<   uint8_t m_rxAntennaPatternConsistency; ///< receive antenna pattern consistency
<   uint8_t m_txAntennaPatternConsistency; ///< transmit antenna pattern consistency
---
>   uint16_t m_maxMpduLength;
>   uint16_t m_supportedChannelWidthSet;
>   uint8_t m_rxLdpc;
>   uint8_t m_shortGuardIntervalFor80Mhz;
>   uint8_t m_shortGuardIntervalFor160Mhz;
>   uint8_t m_txStbc;
>   uint8_t m_rxStbc;
>   uint8_t m_suBeamformerCapable;
>   uint8_t m_suBeamformeeCapable;
>   uint8_t m_beamformeeStsCapable;
>   uint8_t m_numberOfSoundingDimensions;
>   uint8_t m_muBeamformerCapable;
>   uint8_t m_muBeamformeeCapable;
>   uint8_t m_vhtTxopPs;
>   uint8_t m_htcVhtCapable;
>   uint8_t m_maxAmpduLengthExponent;
>   uint8_t m_vhtLinkAdaptationCapable;
>   uint8_t m_rxAntennaPatternConsistency;
>   uint8_t m_txAntennaPatternConsistency;
249,252c165,168
<   std::vector<uint8_t> m_rxMcsMap;                        ///< receive MCS map
<   uint16_t m_rxHighestSupportedLongGuardIntervalDataRate; ///< receive highest supported long guard interval data rate
<   std::vector<uint8_t> m_txMcsMap;                        ///< transmit MCS map
<   uint16_t m_txHighestSupportedLongGuardIntervalDataRate; ///< transmit highest supported long guard interval data rate
---
>   std::vector<uint8_t> m_rxMcsMap;
>   uint16_t m_rxHighestSupportedLongGuardIntervalDataRate;
>   std::vector<uint8_t> m_txMcsMap;
>   uint16_t m_txHighestSupportedLongGuardIntervalDataRate;
254c170
<   /// This is used to decide if this element should be added to the frame or not
---
>   //This is used to decide if this element should be added to the frame or not
258,265d173
< /**
<  * output stream output operator
<  *
<  * \param os the output stream
<  * \param VhtCapabilities the VHT capabilities
<  *
<  * \returns output stream
<  */
266a175,177
> std::istream &operator >> (std::istream &is, VhtCapabilities &vhtcapabilities);
> 
> ATTRIBUTE_HELPER_HEADER (VhtCapabilities)
Only in ../../NS3-WiGig/src/wifi/model: vht-configuration.cc
Only in ../../NS3-WiGig/src/wifi/model: vht-configuration.h
Only in ../../NS3-WiGig/src/wifi/model: vht-operation.cc
Only in ../../NS3-WiGig/src/wifi/model: vht-operation.h
Only in ../../NS3-WiGig/src/wifi/model: wifi-ack-policy-selector.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-ack-policy-selector.h
Only in ../../ns-3-dev/src/wifi/model: wifi-channel.cc
Only in ../../ns-3-dev/src/wifi/model: wifi-channel.h
diff ../../NS3-WiGig/src/wifi/model/wifi-information-element.cc ../../ns-3-dev/src/wifi/model/wifi-information-element.cc
21c21
< #include "wifi-information-element.h"
---
> #include "ns3/wifi-information-element.h"
25,46d24
< Buffer::Iterator
< DeserializeExtensionElementID (Buffer::Iterator i, uint8_t &elementID, uint8_t &length, uint8_t &extElementID)
< {
<   Buffer::Iterator start = i;
<   elementID = i.ReadU8 ();
<   if (elementID != IE_EXTENSION)
<     {
<       return start;
<     }
<   length = i.ReadU8 ();
<   extElementID = i.ReadU8 ();
<   return i;
< }
< 
< Buffer::Iterator
< DeserializeElementID (Buffer::Iterator i, uint8_t &elementID, uint8_t &length)
< {
<   elementID = i.ReadU8 ();
<   length = i.ReadU8 ();
<   return i;
< }
< 
62,67d39
< WifiInformationElementId
< WifiInformationElement::ElementIdExt () const
< {
<   return 0;
< }
< 
73,83c45,46
<   if (ElementId () == IE_EXTENSION)
<     {
<       i.WriteU8 (ElementIdExt ());
<       SerializeInformationField (i);
<       i.Next (GetInformationFieldSize () - 1);
<     }
<   else
<     {
<       SerializeInformationField (i);
<       i.Next (GetInformationFieldSize ());
<     }
---
>   SerializeInformationField (i);
>   i.Next (GetInformationFieldSize ());
117,136d79
<   if (ElementId () == IE_EXTENSION)
<     {
<       uint8_t elementIdExt = i.ReadU8 ();
<       //If the element here isn't the one we're after then we immediately
<       //return the iterator we were passed indicating that we haven't
<       //taken anything from the buffer.
<       if (elementIdExt != ElementIdExt ())
<         {
<           return start;
<         }
<       DeserializeInformationField (i, length - 1);
<       i.Next (length - 1);
<     }
<   else
<     {
<       DeserializeInformationField (i, length);
<       i.Next (length);
<     }
<   return i;
< }
138,140d80
< Buffer::Iterator
< WifiInformationElement::DeserializeElementBody (Buffer::Iterator i, uint8_t length)
< {
142a83
> 
146a88,93
> WifiInformationElement::operator< (WifiInformationElement const & a) const
> {
>   return (ElementId () < a.ElementId ());
> }
> 
> bool
155,159d101
<     {
<       return false;
<     }
< 
<   if (ElementIdExt () != a.ElementIdExt ())
diff ../../NS3-WiGig/src/wifi/model/wifi-information-element.h ../../ns-3-dev/src/wifi/model/wifi-information-element.h
26d25
< #include "map"
44,47d42
< /**
<  * This type is used to represent an Information Element ID Extension.
<  */
< typedef uint8_t WifiInformationElementIdExtension;
51c46
<  * 802.11-2016. See the comments for WifiInformationElementId - this could
---
>  * 802.11-2007. See the comments for WifiInformationElementId - this could
54,227c49,120
< #define IE_SSID                                 ((WifiInformationElementId)0)
< #define IE_SUPPORTED_RATES                      ((WifiInformationElementId)1)
< #define IE_FH_PARAMETER_SET                     ((WifiInformationElementId)2)
< #define IE_DSSS_PARAMETER_SET                   ((WifiInformationElementId)3)
< #define IE_CF_PARAMETER_SET                     ((WifiInformationElementId)4)
< #define IE_TIM                                  ((WifiInformationElementId)5)
< #define IE_IBSS_PARAMETER_SET                   ((WifiInformationElementId)6)
< #define IE_COUNTRY                              ((WifiInformationElementId)7)
< #define IE_HOPPING_PATTERN_PARAMETERS           ((WifiInformationElementId)8)
< #define IE_HOPPING_PATTERN_TABLE                ((WifiInformationElementId)9)
< #define IE_REQUEST                              ((WifiInformationElementId)10)
< #define IE_BSS_LOAD                             ((WifiInformationElementId)11)
< #define IE_EDCA_PARAMETER_SET                   ((WifiInformationElementId)12)
< #define IE_TSPEC                                ((WifiInformationElementId)13)
< #define IE_TCLAS                                ((WifiInformationElementId)14)
< #define IE_SCHEDULE                             ((WifiInformationElementId)15)
< #define IE_CHALLENGE_TEXT                       ((WifiInformationElementId)16)
< // 17 to 31 are reserved
< #define IE_POWER_CONSTRAINT                     ((WifiInformationElementId)32)
< #define IE_POWER_CAPABILITY                     ((WifiInformationElementId)33)
< #define IE_TPC_REQUEST                          ((WifiInformationElementId)34)
< #define IE_TPC_REPORT                           ((WifiInformationElementId)35)
< #define IE_SUPPORTED_CHANNELS                   ((WifiInformationElementId)36)
< #define IE_CHANNEL_SWITCH_ANNOUNCEMENT          ((WifiInformationElementId)37)
< #define IE_MEASUREMENT_REQUEST                  ((WifiInformationElementId)38)
< #define IE_MEASUREMENT_REPORT                   ((WifiInformationElementId)39)
< #define IE_QUIET                                ((WifiInformationElementId)40)
< #define IE_IBSS_DFS                             ((WifiInformationElementId)41)
< #define IE_ERP_INFORMATION                      ((WifiInformationElementId)42)
< #define IE_TS_DELAY                             ((WifiInformationElementId)43)
< #define IE_TCLAS_PROCESSING                     ((WifiInformationElementId)44)
< #define IE_HT_CAPABILITIES                      ((WifiInformationElementId)45)
< #define IE_QOS_CAPABILITY                       ((WifiInformationElementId)46)
< // 47 is reserved
< #define IE_RSN                                  ((WifiInformationElementId)48)
< // 49 is reserved
< #define IE_EXTENDED_SUPPORTED_RATES             ((WifiInformationElementId)50)
< #define IE_AP_CHANNEL_REPORT                    ((WifiInformationElementId)51)
< #define IE_NEIGHBOR_REPORT                      ((WifiInformationElementId)52)
< #define IE_RCPI                                 ((WifiInformationElementId)53)
< #define IE_MOBILITY_DOMAIN                      ((WifiInformationElementId)54)
< #define IE_FAST_BSS_TRANSITION                  ((WifiInformationElementId)55)
< #define IE_TIMEOUT_INTERVAL                     ((WifiInformationElementId)56)
< #define IE_RIC_DATA                             ((WifiInformationElementId)57)
< #define IE_DSE_REGISTERED_LOCATION              ((WifiInformationElementId)58)
< #define IE_SUPPORTED_OPERATING_CLASSES          ((WifiInformationElementId)59)
< #define IE_EXTENDED_CHANNEL_SWITCH_ANNOUNCEMENT ((WifiInformationElementId)60)
< #define IE_HT_OPERATION                         ((WifiInformationElementId)61)
< #define IE_SECONDARY_CHANNEL_OFFSET             ((WifiInformationElementId)62)
< #define IE_BSS_AVERAGE_ACCESS_DELAY             ((WifiInformationElementId)63)
< #define IE_ANTENNA                              ((WifiInformationElementId)64)
< #define IE_RSNI                                 ((WifiInformationElementId)65)
< #define IE_MEASUREMENT_PILOT_TRANSMISSION       ((WifiInformationElementId)66)
< #define IE_BSS_AVAILABLE_ADMISSION_CAPACITY     ((WifiInformationElementId)67)
< #define IE_BSS_AC_ACCESS_DELAY                  ((WifiInformationElementId)68)
< #define IE_TIME_ADVERTISEMENT                   ((WifiInformationElementId)69)
< #define IE_RM_ENABLED_CAPACITIES                ((WifiInformationElementId)70)
< #define IE_MULTIPLE_BSSID                       ((WifiInformationElementId)71)
< #define IE_20_40_BSS_COEXISTENCE                ((WifiInformationElementId)72)
< #define IE_20_40_BSS_INTOLERANT_CHANNEL_REPORT  ((WifiInformationElementId)73)
< #define IE_OVERLAPPING_BSS_SCAN_PARAMETERS      ((WifiInformationElementId)74)
< #define IE_RIC_DESCRIPTOR                       ((WifiInformationElementId)75)
< #define IE_MANAGEMENT_MIC                       ((WifiInformationElementId)76)
< // 77 is reserved
< #define IE_EVENT_REQUEST                        ((WifiInformationElementId)78)
< #define IE_EVENT_REPORT                         ((WifiInformationElementId)79)
< #define IE_DIAGNOSTIC_REQUEST                   ((WifiInformationElementId)80)
< #define IE_DIAGNOSTIC_REPORT                    ((WifiInformationElementId)81)
< #define IE_LOCATION_PARAMETERS                  ((WifiInformationElementId)82)
< #define IE_NONTRANSMITTED_BSSID_CAPABILITY      ((WifiInformationElementId)83)
< #define IE_SSID_LIST                            ((WifiInformationElementId)84)
< #define IE_MULTIPLE_BSSID_INDEX                 ((WifiInformationElementId)85)
< #define IE_FMS_DESCRIPTOR                       ((WifiInformationElementId)86)
< #define IE_FMS_REQUEST                          ((WifiInformationElementId)87)
< #define IE_FMS_RESPONSE                         ((WifiInformationElementId)88)
< #define IE_QOS_TRAFFIC_CAPABILITY               ((WifiInformationElementId)89)
< #define IE_BSS_MAX_IDLE_PERIOD                  ((WifiInformationElementId)90)
< #define IE_TFS_REQUEST                          ((WifiInformationElementId)91)
< #define IE_TFS_RESPONSE                         ((WifiInformationElementId)92)
< #define IE_WNM_SLEEP_MODE                       ((WifiInformationElementId)93)
< #define IE_TIM_BROADCAST_REQUEST                ((WifiInformationElementId)94)
< #define IE_TIM_BROADCAST_RESPONSE               ((WifiInformationElementId)95)
< #define IE_COLLOCATED_INTERFERENCE_REPORT       ((WifiInformationElementId)96)
< #define IE_CHANNEL_USAGE                        ((WifiInformationElementId)97)
< #define IE_TIME_ZONE                            ((WifiInformationElementId)98)
< #define IE_DMS_REQUEST                          ((WifiInformationElementId)99)
< #define IE_DMS_RESPONSE                         ((WifiInformationElementId)100)
< #define IE_LINK_IDENTIFIER                      ((WifiInformationElementId)101)
< #define IE_WAKEUP_SCHEDULE_OLD                  ((WifiInformationElementId)102)
< // 103 is reserved
< #define IE_CHANNEL_SWITCH_TIMING                ((WifiInformationElementId)104)
< #define IE_PTI_CONTROL                          ((WifiInformationElementId)105)
< #define IE_TPU_BUFFER_STATUS                    ((WifiInformationElementId)106)
< #define IE_INTERWORKING                         ((WifiInformationElementId)107)
< #define IE_ADVERTISEMENT_PROTOCOL               ((WifiInformationElementId)108)
< #define IE_EXPEDITED_BANDWIDTH_REQUEST          ((WifiInformationElementId)109)
< #define IE_QOS_MAP_SET                          ((WifiInformationElementId)110)
< #define IE_ROAMING_CONSORTIUM                   ((WifiInformationElementId)111)
< #define IE_EMERGENCY_ALART_IDENTIFIER           ((WifiInformationElementId)112)
< #define IE_MESH_CONFIGURATION                   ((WifiInformationElementId)113)
< #define IE_MESH_ID                              ((WifiInformationElementId)114)
< #define IE_MESH_LINK_METRIC_REPORT              ((WifiInformationElementId)115)
< #define IE_CONGESTION_NOTIFICATION              ((WifiInformationElementId)116)
< #define IE_MESH_PEERING_MANAGEMENT              ((WifiInformationElementId)117)
< #define IE_MESH_CHANNEL_SWITCH_PARAMETERS       ((WifiInformationElementId)118)
< #define IE_MESH_AWAKE_WINDOW                    ((WifiInformationElementId)119)
< #define IE_BEACON_TIMING                        ((WifiInformationElementId)120)
< #define IE_MCCAOP_SETUP_REQUEST                 ((WifiInformationElementId)121)
< #define IE_MCCAOP_SETUP_REPLY                   ((WifiInformationElementId)122)
< #define IE_MCCAOP_ADVERTISEMENT                 ((WifiInformationElementId)123)
< #define IE_MCCAOP_TEARDOWN                      ((WifiInformationElementId)124)
< #define IE_GANN                                 ((WifiInformationElementId)125)
< #define IE_RANN                                 ((WifiInformationElementId)126)
< // 67 to 126 are reserved
< #define IE_EXTENDED_CAPABILITIES                ((WifiInformationElementId)127)
< // 128 to 129 are reserved
< #define IE_PREQ                                 ((WifiInformationElementId)130)
< #define IE_PREP                                 ((WifiInformationElementId)131)
< #define IE_PERR                                 ((WifiInformationElementId)132)
< // 133 to 136 are reserved
< #define IE_PROXY_UPDATE                         ((WifiInformationElementId)137)
< #define IE_PROXY_UPDATE_CONFIRMATION            ((WifiInformationElementId)138)
< #define IE_AUTHENTICATED_MESH_PEERING_EXCHANGE  ((WifiInformationElementId)139)
< #define IE_MIC                                  ((WifiInformationElementId)140)
< #define IE_DESTINATION_URI                      ((WifiInformationElementId)141)
< #define IE_UAPSD_COEXISTENCE                    ((WifiInformationElementId)142)
< // 143 to 173 are reserved
< #define IE_MCCAOP_ADVERTISEMENT_OVERVIEW        ((WifiInformationElementId)174)
< // 175 to 190 are reserved
< #define IE_VHT_CAPABILITIES                     ((WifiInformationElementId)191)
< #define IE_VHT_OPERATION                        ((WifiInformationElementId)192)
< #define IE_EXTENDED_BSS_LOAD                    ((WifiInformationElementId)193)
< #define IE_WIDE_BANDWIDTH_CHANNEL_SWITCH        ((WifiInformationElementId)194)
< #define IE_VHT_TRANSMIT_POWER_ENVELOPE          ((WifiInformationElementId)195)
< #define IE_CHANNEL_SWITCH_WRAPPER               ((WifiInformationElementId)196)
< #define IE_AID                                  ((WifiInformationElementId)197)
< #define IE_QUIET_CHANNEL                        ((WifiInformationElementId)198)
< #define IE_OPERATING_MODE_NOTIFICATION          ((WifiInformationElementId)199)
< // 200 to 220 are reserved
< #define IE_VENDOR_SPECIFIC                      ((WifiInformationElementId)221)
< // 222 to 254 are reserved
< #define IE_EXTENSION                            ((WifiInformationElementId)255)
< 
< #define IE_EXT_HE_CAPABILITIES                  ((WifiInformationElementId)35)
< #define IE_EXT_HE_OPERATION                     ((WifiInformationElementId)36)
< 
< // 143 to 190 are 802.11ad in 802.11-2012
< #define IE_WAKEUP_SCHEDULE                     ((WifiInformationElementId)143)
< #define IE_EXTENDED_SCHEDULE                   ((WifiInformationElementId)144)
< #define IE_STA_AVAILABILITY                    ((WifiInformationElementId)145)
< #define IE_DMG_TSPEC                           ((WifiInformationElementId)146)
< #define IE_NEXT_DMG_ATI                        ((WifiInformationElementId)147)
< #define IE_DMG_CAPABILITIES                    ((WifiInformationElementId)148)
< #define IE_DMG_OPERATION                       ((WifiInformationElementId)151)
< #define IE_DMG_BSS_PARAMETER_CHANGE            ((WifiInformationElementId)152)
< #define IE_DMG_BEAM_REFINEMENT                 ((WifiInformationElementId)153)
< #define IE_CHANNEL_MEASUREMENT_FEEDBACK        ((WifiInformationElementId)154)
< #define IE_AWAKE_WINDOW                        ((WifiInformationElementId)157)
< #define IE_MULTI_BAND                          ((WifiInformationElementId)158)
< #define IE_ADDBA_EXTENSION                     ((WifiInformationElementId)159)
< #define IE_NEXT_PCP_LIST                       ((WifiInformationElementId)160)
< #define IE_PCP_HANDOVER                        ((WifiInformationElementId)161)
< #define IE_DMG_LINK_MARGIN                     ((WifiInformationElementId)162)
< #define IE_SWITCHING_STREAM                    ((WifiInformationElementId)163)
< #define IE_SESSION_TRANSITION                  ((WifiInformationElementId)164)
< #define IE_DYNAMIC_TONE_PAIRING_REPORT         ((WifiInformationElementId)165)
< #define IE_CLUSTER_REPORT                      ((WifiInformationElementId)166)
< #define IE_RELAY_CAPABILITIES                  ((WifiInformationElementId)167)
< #define IE_RELAY_TRANSFER_PARAMETER_SET        ((WifiInformationElementId)168)
< #define IE_BEAMLINK_MAINENANCE                 ((WifiInformationElementId)169)
< #define IE_DMG_LINK_ADAPTATION_ACKNOWLEDGMENT  ((WifiInformationElementId)172)
< #define IE_QUIET_PERIOD_REQUEST                ((WifiInformationElementId)175)
< #define IE_QUIET_PERIOD_RESPONSE               ((WifiInformationElementId)177)
< #define IE_ECPAC_POLICY                        ((WifiInformationElementId)182)
---
> #define IE_SSID                                ((WifiInformationElementId)0)
> #define IE_SUPPORTED_RATES                     ((WifiInformationElementId)1)
> #define IE_FH_PARAMETER_SET                    ((WifiInformationElementId)2)
> #define IE_DS_PARAMETER_SET                    ((WifiInformationElementId)3)
> #define IE_CF_PARAMETER_SET                    ((WifiInformationElementId)4)
> #define IE_TIM                                 ((WifiInformationElementId)5)
> #define IE_IBSS_PARAMETER_SET                  ((WifiInformationElementId)6)
> #define IE_COUNTRY                             ((WifiInformationElementId)7)
> #define IE_HOPPING_PATTERN_PARAMETERS          ((WifiInformationElementId)8)
> #define IE_HOPPING_PATTERN_TABLE               ((WifiInformationElementId)9)
> #define IE_REQUEST                             ((WifiInformationElementId)10)
> #define IE_BSS_LOAD                            ((WifiInformationElementId)11)
> #define IE_EDCA_PARAMETER_SET                  ((WifiInformationElementId)12)
> #define IE_TSPEC                               ((WifiInformationElementId)13)
> #define IE_TCLAS                               ((WifiInformationElementId)14)
> #define IE_SCHEDULE                            ((WifiInformationElementId)15)
> #define IE_CHALLENGE_TEXT                      ((WifiInformationElementId)16)
> // 17 to 31 are reserved in 802.11-2007
> #define IE_POWER_CONSTRAINT                    ((WifiInformationElementId)32)
> #define IE_POWER_CAPABILITY                    ((WifiInformationElementId)33)
> #define IE_TPC_REQUEST                         ((WifiInformationElementId)34)
> #define IE_TPC_REPORT                          ((WifiInformationElementId)35)
> #define IE_SUPPORTED_CHANNELS                  ((WifiInformationElementId)36)
> #define IE_CHANNEL_SWITCH_ANNOUNCEMENT         ((WifiInformationElementId)37)
> #define IE_MEASUREMENT_REQUEST                 ((WifiInformationElementId)38)
> #define IE_MEASUREMENT_REPORT                  ((WifiInformationElementId)39)
> #define IE_QUIET                               ((WifiInformationElementId)40)
> #define IE_IBSS_DFS                            ((WifiInformationElementId)41)
> #define IE_ERP_INFORMATION                     ((WifiInformationElementId)42)
> #define IE_TS_DELAY                            ((WifiInformationElementId)43)
> #define IE_TCLAS_PROCESSING                    ((WifiInformationElementId)44)
> #define IE_HT_CAPABILITIES                     ((WifiInformationElementId)45)
> #define IE_QOS_CAPABILITY                      ((WifiInformationElementId)46)
> // 47 is reserved in 802.11-2007
> #define IE_RSN                                 ((WifiInformationElementId)48)
> // 49 is reserved in 802.11-2007
> #define IE_EXTENDED_SUPPORTED_RATES            ((WifiInformationElementId)50)
> // 51 to 60 are reserved in 802.11-2007
> #define IE_HT_OPERATIONS                       ((WifiInformationElementId)61)
> // 62 to 126 are reserved in 802.11-2007
> #define IE_EXTENDED_CAPABILITIES               ((WifiInformationElementId)127)
> // 128 to 190 are reserved in 802.11-2007
> #define IE_VHT_CAPABILITIES                    ((WifiInformationElementId)191)
> #define IE_VENDOR_SPECIFIC                     ((WifiInformationElementId)221)
> // 222 to 255 are reserved in 802.11-2007
> #define IE11S_LINK_METRIC_REPORT               ((WifiInformationElementId)115)
> #define IE11S_CONGESTION_NOTIFICATION          ((WifiInformationElementId)116)
> #define IE11S_SUPP_MBSS_REG_CLASSES_CHANNELS   ((WifiInformationElementId)23)
> #define IE11S_MESH_CHANNEL_SWITCH_ANNOUNCEMENT ((WifiInformationElementId)24)
> #define IE11S_MESH_TIM                         ((WifiInformationElementId)25)
> #define IE11S_AWAKE_WINDOW                     ((WifiInformationElementId)119)
> #define IE11S_BEACON_TIMING                    ((WifiInformationElementId)120)
> #define IE11S_MCCAOP_SETUP_REQUEST             ((WifiInformationElementId)121)
> #define IE11S_MCCAOP_SETUP_REPLY               ((WifiInformationElementId)122)
> #define IE11S_MCCAOP_ADVERTISEMENT             ((WifiInformationElementId)123)
> #define IE11S_MCCAOP_RESERVATION_TEARDOWN      ((WifiInformationElementId)31)
> #define IE11S_PORTAL_ANNOUNCEMENT              ((WifiInformationElementId)32)
> #define IE11S_PROXY_UPDATE                     ((WifiInformationElementId)137)
> #define IE11S_PROXY_UPDATE_CONFIRMATION        ((WifiInformationElementId)138)
> #define IE11S_ABBREVIATED_HANDSHAKE            ((WifiInformationElementId)39)
> /* begin of open80211s-compatible IDs */
> #define IE11S_MESH_CONFIGURATION               ((WifiInformationElementId)113)
> #define IE11S_MESH_ID                          ((WifiInformationElementId)114)
> #define IE11S_PEERING_MANAGEMENT               ((WifiInformationElementId)117)
> /* end of open80211s-compatible IDs */
> #define IE11S_RANN                             ((WifiInformationElementId)126)
> /* begin of open80211s-compatible IDs */
> #define IE11S_PREQ                             ((WifiInformationElementId)130)
> #define IE11S_PREP                             ((WifiInformationElementId)131)
> #define IE11S_PERR                             ((WifiInformationElementId)132)
> /* end of open80211s-compatible IDs */
> #define IE11S_MESH_PEERING_PROTOCOL_VERSION    ((WifiInformationElementId)74)
229,257d121
< /**
<  * Definition of the Element ID Extension field in 802.11ay_D5.0
<  */
< #define IE_EXTENSION_EDMG_CAPABILITIES                    ((WifiInformationElementIdExtension)61)
< #define IE_EXTENSION_EDMG_OPERATION                       ((WifiInformationElementIdExtension)62)
< #define IE_EXTENSION_EDMG_EXTENDED_SCHEDULE               ((WifiInformationElementIdExtension)63)
< #define IE_EXTENSION_EDMG_CHANNEL_MEASUREMENT_FEEDBACK    ((WifiInformationElementIdExtension)64)
< #define IE_EXTENSION_EDMG_GROUP_ID_SET                    ((WifiInformationElementIdExtension)65)
< #define IE_EXTENSION_EDMG_BRP_REQUEST                     ((WifiInformationElementIdExtension)66)
< #define IE_EXTENSION_EDMG_TRAINING_FIELD_SCHEDULE         ((WifiInformationElementIdExtension)67)
< #define IE_EXTENSION_EDMG_PARTIAL_SECTOR_SWEEP            ((WifiInformationElementIdExtension)68)
< #define IE_EXTENSION_MIMO_SETUP_CONTROL                   ((WifiInformationElementIdExtension)69)
< #define IE_EXTENSION_MIMO_POLL_CONTROL                    ((WifiInformationElementIdExtension)70)
< #define IE_EXTENSION_MIMO_FEEDBACK_CONTROL                ((WifiInformationElementIdExtension)71)
< #define IE_EXTENSION_MIMO_SELECTION_CONTROL               ((WifiInformationElementIdExtension)72)
< #define IE_EXTENSION_EDMG_FLOW_CONTROL_EXTENSION          ((WifiInformationElementIdExtension)73)
< #define IE_EXTENSION_QOS_TRIGGERED_UNSCHEDULED            ((WifiInformationElementIdExtension)74)
< #define IE_EXTENSION_UNSLICITED_BLOCK_ACK_EXTENSION       ((WifiInformationElementIdExtension)75)
< #define IE_EXTENSION_SEGMENATION_REASSEMBLY               ((WifiInformationElementIdExtension)76)
< #define IE_EXTENSION_TDD_SLOT_STRUCTURE                   ((WifiInformationElementIdExtension)77)
< #define IE_EXTENSION_TDD_SLOT_SCHEDULE                    ((WifiInformationElementIdExtension)78)
< #define IE_EXTENSION_TDD_ROUTE                            ((WifiInformationElementIdExtension)79)
< #define IE_EXTENSION_DIGITAL_BF_FEEDBACK                  ((WifiInformationElementIdExtension)80)
< #define IE_EXTENSION_TDD_BANDWIDTH_REQUEST                ((WifiInformationElementIdExtension)81)
< #define IE_EXTENSION_TDD_SYNCHRONIZATION                  ((WifiInformationElementIdExtension)82)
< #define IE_EXTENSION_EDMG_WIDE_BANDWIDTH_CHANNEL_SWITCH   ((WifiInformationElementIdExtension)83)
< #define IE_EXTENSION_DMG_DISCOVERY_ASSISTANCE             ((WifiInformationElementIdExtension)84)
< #define IE_EXTENSION_EXTENDED_LINK_MEASUREMENT            ((WifiInformationElementIdExtension)85)
< #define IE_EXTENSION_DMG_STA_TRANSCEIVER_PARAMETERS       ((WifiInformationElementIdExtension)86)
259,267d122
< /**
<  * Deserialize IE ID, length and Extension ID. The iterator passed in  must be
<  * pointing at the Element ID of an information element.
<  *
<  * \param i an iterator which points to where the IE should be read.
<  *
<  * \return an iterator
<  */
< Buffer::Iterator DeserializeExtensionElementID (Buffer::Iterator i, uint8_t &elementID, uint8_t &length, uint8_t &extElementID);
269,277d123
< /**
<  * Deserialize IE ID and length. The iterator passed in  must be
<  * pointing at the Element ID of an information element.
<  *
<  * \param i an iterator which points to where the IE should be read.
<  *
<  * \return an iterator
<  */
< Buffer::Iterator DeserializeElementID (Buffer::Iterator i, uint8_t &elementID, uint8_t &length);
351,359d196
<    * Deserialize IE Body. The iterator passed in must be pointing at
<    * the Element Body of an information element.
<    *
<    * \param i an iterator which points to where the IE body should be read.
<    *
<    * \return an iterator
<    */
<   Buffer::Iterator DeserializeElementBody (Buffer::Iterator i, uint8_t length);
<   /**
363c200
<    * \return the size of the serialized IE in bytes
---
>    * \return the size of the serialized IE
368,370c205
<   /**
<    * \returns Own unique Element ID
<    */
---
>   /// Own unique Element ID
401,405d235
<   /**
<    * \returns Own unique Element ID Extension
<    */
<   virtual WifiInformationElementId ElementIdExt () const;
< 
413a244,252
>    * Compare information elements using Element ID
>    *
>    * \param a another information element to compare with
>    *
>    * \return true if the Element ID is less than the other IE Element ID,
>    *         false otherwise
>    */
>   virtual bool operator< (WifiInformationElement const & a) const;
>   /**
425,430d263
< 
< typedef std::vector<Ptr<WifiInformationElement> > WifiInfoElementList;
< typedef std::pair<WifiInformationElementId, WifiInformationElementIdExtension> WifiInfoElementId;
< typedef std::vector<WifiInfoElementId> WifiInformationElementIdList;
< typedef std::map<WifiInfoElementId, Ptr<WifiInformationElement> > WifiInformationElementMap;
< typedef std::map<WifiInformationElementId, Ptr<WifiInformationElement> > WifiInformationSubelementMap;
diff ../../NS3-WiGig/src/wifi/model/wifi-information-element-vector.cc ../../ns-3-dev/src/wifi/model/wifi-information-element-vector.cc
21a22,23
> #include "ns3/packet.h"
> #include <algorithm>
75,89c77,83
<   NS_FATAL_ERROR ("This variant should not be called on a variable-sized header");
<   return 0;
< }
< 
< uint32_t
< WifiInformationElementVector::Deserialize (Buffer::Iterator start, Buffer::Iterator end)
< {
<   uint32_t size = start.GetDistanceFrom (end);
<   uint32_t remaining = size;
<   while (remaining > 0)
<     {
<       uint32_t deserialized = DeserializeSingleIe (start);
<       start.Next (deserialized);
<       NS_ASSERT (deserialized <= remaining);
<       remaining -= deserialized;
---
>   Buffer::Iterator i = start;
>   uint32_t size = start.GetSize ();
>   while (size > 0)
>     {
>       uint32_t deserialized = DeserializeSingleIe (i);
>       i.Next (deserialized);
>       size -= deserialized;
91,92c85
<   NS_ASSERT_MSG (remaining == 0, "Error in deserialization");
<   return size;
---
>   return i.GetDistanceFrom (start);
106d98
<     case 0: // eliminate compiler warning
108c100
<       NS_FATAL_ERROR ("Information element " << +id << " is not implemented");
---
>       NS_FATAL_ERROR ("Information element " << (uint16_t) id << " is not implemented");
128c120
<       os << "(";
---
>        os << "(";
130c122
<       os << ")";
---
>        os << ")";
133a126,131
> void
> WifiInformationElementVector::SetMaxSize (uint16_t size)
> {
>   m_maxSize = size;
> }
> 
168a167,181
> 
> 
> namespace {
> 
> struct PIEComparator
> {
>   bool
>   operator () (Ptr<WifiInformationElement> a, Ptr<WifiInformationElement> b) const
>   {
>     return ((*PeekPointer (a)) < (*PeekPointer (b)));
>   }
> };
> 
> }
> 
diff ../../NS3-WiGig/src/wifi/model/wifi-information-element-vector.h ../../ns-3-dev/src/wifi/model/wifi-information-element-vector.h
25c25,27
< #include "wifi-information-element.h"
---
> #include "ns3/header.h"
> #include "ns3/simple-ref-count.h"
> #include "ns3/wifi-information-element.h"
45,48d46
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
54,55c52,53
<    * \attention This variant should not be used but is implemented due to
<    * backward compatibility reasons
---
>    * \attention When you use RemoveHeader, WifiInformationElementVector supposes, that
>    * all buffer consists of information elements
57,58c55
<    * \param start buffer location to start deserializing from
<    * \return number of bytes deserialized
---
>    * \param start
61,70d57
<   /**
<    * Deserialize a number of WifiInformationElements 
<    *
<    * The size of this Header should equal start.GetDistanceFrom (end).
<    *
<    * \param start starting buffer location
<    * \param end ending buffer location
<    * \return number of bytes deserialized
<    */
<   virtual uint32_t Deserialize (Buffer::Iterator start, Buffer::Iterator end);
80a68,69
>   /// Set maximum size to control overflow of the max packet length
>   void SetMaxSize (uint16_t size);
83,86c72
<   /**
<    * Returns Begin of the vector
<    * \returns the begin of the vector
<    */
---
>   /// Returns Begin of the vector
88,91c74
<   /**
<    * Returns End of the vector
<    * \returns the end of the vector
<    */
---
>   /// Returns End of the vector
93,98c76
<   /**
<    * add an IE, if maxSize has exceeded, returns false
<    *
<    * \param element wifi information element to add
<    * \returns true is added
<    */
---
>   /// add an IE, if maxSize has exceeded, returns false
100,105c78
<   /**
<    * vector of pointers to information elements is the body of IeVector
<    *
<    * \param id the element id to find
<    * \returns the information element
<    */
---
>   /// vector of pointers to information elements is the body of IeVector
124,127c97
<   /**
<    * Current number of bytes
<    * \returns the number of bytes
<    */
---
>   /// Current number of bytes
130c100,101
<   uint16_t m_maxSize;   //!< Size in bytes (actually, max packet length)
---
>   /// Size in bytes (actually, max packet length)
>   uint16_t m_maxSize;
diff ../../NS3-WiGig/src/wifi/model/wifi-mac.cc ../../ns-3-dev/src/wifi/model/wifi-mac.cc
21,22d20
< #include "ns3/log.h"
< #include "ns3/packet.h"
24,29c22,25
< #include "txop.h"
< #include "ssid.h"
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "vht-configuration.h"
< #include "he-configuration.h"
---
> #include "dcf.h"
> #include "ns3/uinteger.h"
> #include "ns3/boolean.h"
> #include "ns3/trace-source-accessor.h"
33,34d28
< NS_LOG_COMPONENT_DEFINE ("WifiMac");
< 
36a31
> 
95c90
<   //This value must be revisited
---
>   //This value must be rivisited
102c97
<   //This value must be revisited
---
>   //This value must be rivisited
126a122,147
> void
> WifiMac::SetBasicBlockAckTimeout (Time blockAckTimeout)
> {
>   //this method must be implemented by QoS WifiMacs
> }
> 
> Time
> WifiMac::GetBasicBlockAckTimeout (void) const
> {
>   //this method must be implemented by QoS WifiMacs
>   return MicroSeconds (0);
> }
> 
> void
> WifiMac::SetCompressedBlockAckTimeout (Time blockAckTimeout)
> {
>   //this methos must be implemented by QoS WifiMacs
> }
> 
> Time
> WifiMac::GetCompressedBlockAckTimeout (void) const
> {
>   //this method must be implemented by QoS WifiMacs
>   return MicroSeconds (0);
> }
> 
133c154,159
<     .AddAttribute ("AckTimeout", "When this timeout expires, the Data/Ack handshake has failed.",
---
>     .AddAttribute ("CtsTimeout", "When this timeout expires, the RTS/CTS handshake has failed.",
>                    TimeValue (GetDefaultCtsAckTimeout ()),
>                    MakeTimeAccessor (&WifiMac::SetCtsTimeout,
>                                      &WifiMac::GetCtsTimeout),
>                    MakeTimeChecker ())
>     .AddAttribute ("AckTimeout", "When this timeout expires, the DATA/ACK handshake has failed.",
175c201
<                    MakeTimeAccessor (&WifiMac::SetMaxPropagationDelay),
---
>                    MakeTimeAccessor (&WifiMac::m_maxPropagationDelay),
188c214
<                      "A packet has been dropped in the MAC layer before transmission.",
---
>                      "A packet has been dropped in the MAC layer before being queued for transmission.",
204a231,236
>     //Not currently implemented in this device
>     /*
>     .AddTraceSource ("Sniffer",
>                      "Trace source simulating a non-promiscuous packet sniffer attached to the device",
>                      MakeTraceSourceAccessor (&WifiMac::m_snifferTrace))
>     */
210,222c242
< WifiMac::DoDispose ()
< {
<   m_device = 0;
< }
< 
< void
< WifiMac::SetDevice (const Ptr<NetDevice> device)
< {
<   m_device = device;
< }
< 
< Ptr<NetDevice>
< WifiMac::GetDevice (void) const
---
> WifiMac::SetMaxPropagationDelay (Time delay)
224c244
<   return m_device;
---
>   m_maxPropagationDelay = delay;
227,228c247,248
< void
< WifiMac::SetMaxPropagationDelay (Time delay)
---
> Time
> WifiMac::GetMsduLifetime (void) const
230,231c250
<   NS_LOG_FUNCTION (this << delay);
<   m_maxPropagationDelay = delay;
---
>   return Seconds (10);
271,277c290
< WifiMac::RegisterBandChangedCallback (BandChangedCallback callback)
< {
<   m_bandChangedCallback = callback;
< }
< 
< void
< WifiMac::ConfigureStandard (WifiPhyStandard standard)
---
> WifiMac::ConfigureStandard (enum WifiPhyStandard standard)
279,280d291
<   NS_LOG_FUNCTION (this << standard);
<   m_standard = standard;
310,322d320
<     case WIFI_PHY_STANDARD_80211ad:
<       Configure80211ad ();
<       break;
<     case WIFI_PHY_STANDARD_80211ay:
<       Configure80211ay ();
<       break;
<     case WIFI_PHY_STANDARD_80211ax_2_4GHZ:
<       Configure80211ax_2_4Ghz ();
<       break;
<     case WIFI_PHY_STANDARD_80211ax_5GHZ:
<       Configure80211ax_5Ghz ();
<       break;
<     case WIFI_PHY_STANDARD_UNSPECIFIED:
324c322
<       NS_FATAL_ERROR ("Wifi standard not found");
---
>       NS_ASSERT (false);
330,335d327
< WifiPhyStandard
< WifiMac::GetCurrentstandard (void) const
< {
<   return m_standard;
< }
< 
339d330
<   NS_LOG_FUNCTION (this);
343a335
>   SetCtsTimeout (MicroSeconds (16 + 44 + 9 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
350d341
<   NS_LOG_FUNCTION (this);
354a346
>   SetCtsTimeout (MicroSeconds (10 + 304 + 20 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
361d352
<   NS_LOG_FUNCTION (this);
369a361
>   SetCtsTimeout (MicroSeconds (10 + 304 + 20 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
376d367
<   NS_LOG_FUNCTION (this);
380a372
>   SetCtsTimeout (MicroSeconds (32 + 88 + 13 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
387d378
<   NS_LOG_FUNCTION (this);
391a383
>   SetCtsTimeout (MicroSeconds (64 + 176 + 21 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
398d389
<   NS_LOG_FUNCTION (this);
407d397
<   NS_LOG_FUNCTION (this);
417d406
<   NS_LOG_FUNCTION (this);
422,486c411
< WifiMac::Configure80211ax_2_4Ghz (void)
< {
<   NS_LOG_FUNCTION (this);
<   Configure80211n_2_4Ghz ();
< }
< 
< void
< WifiMac::Configure80211ax_5Ghz (void)
< {
<   NS_LOG_FUNCTION (this);
<   Configure80211ac ();
<   SetCompressedBlockAckTimeout (GetSifs () + GetSlot () + MicroSeconds (85) + GetDefaultMaxPropagationDelay () * 2);
< }
< 
< //// WIGIG ////
< /*
<  * Physical Layer Characteristics for IEEE 802.11ad.
<  */
< void
< WifiMac::Configure80211ad (void)
< {
<   SetRifs (MicroSeconds (1));	/* aRIFSTime in Table 21-31 */
<   SetSifs (MicroSeconds (3));	/* aSIFSTime in Table 21-31 */
<   SetSlot (MicroSeconds (5));	/* aSlotTime in Table 21-31 */
<   SetMaxPropagationDelay (NanoSeconds (100));	/* aAirPropagationTime << 0.1 usec in Table 21-31 */
<   SetPifs (GetSifs () + GetSlot ());	/* 802.11-2007 9.2.10 */
<   SetEifsNoDifs (GetSifs () + NanoSeconds (13164));
<   /* ACK is sent using SC-MCS1, ACK Size = 14 Bytes, PayloadDuration = 618 ns, TotalTx = 3091 ns */
< //  SetAckTimeout (GetSifs () + NanoSeconds (3091) + GetSlot () + GetMaxPropagationDelay () * 2);
<   /* We need to distinguish between two ACK MCS */
<   /* ACK is sent using MCS-0, ACK Size = 14 Bytes, PayloadDuration = 4218 ns, TotalTx = 13164 ns */
<   SetAckTimeout (GetSifs () + NanoSeconds (13164) + GetSlot () + GetMaxPropagationDelay () * 2);
<   /* BlockAck is sent using either MCS-0 or SC-MCS-1/4, we assume MCS-0 in our calculation */
<   /* BasicBlockAck Size = 152 Bytes */
<   SetBasicBlockAckTimeout (GetSifs () + GetSlot () + MicroSeconds (52) + GetDefaultMaxPropagationDelay () * 2);
<   /* CompressedBlockAck Size = 32 Bytes = 18.836 ns using MCS-0 */
<   SetCompressedBlockAckTimeout (GetSifs () + GetSlot () + MicroSeconds (19) + GetDefaultMaxPropagationDelay () * 2);
< }
< 
< /*
<  * Physical Layer Characteristics for IEEE 802.11ay.
<  */
< void
< WifiMac::Configure80211ay (void)
< {
<   SetRifs (MicroSeconds (1));	/* aRIFSTime in Table 21-31 */
<   SetSifs (MicroSeconds (3));	/* aSIFSTime in Table 21-31 */
<   SetSlot (MicroSeconds (5));	/* aSlotTime in Table 21-31 */
<   SetMaxPropagationDelay (NanoSeconds (100));	/* aAirPropagationTime << 0.1 usec in Table 21-31 */
<   SetPifs (GetSifs () + GetSlot ());	/* 802.11-2007 9.2.10 */
<   SetEifsNoDifs (GetSifs () + NanoSeconds (14473));
<   /* ACK is sent using SC-MCS1, ACK Size = 14 Bytes, PayloadDuration = 618 ns, TotalTx = 3091 */
< //  SetAckTimeout (GetSifs () + NanoSeconds (3091) + GetSlot () + GetMaxPropagationDelay () * 2);
<   /* We need to distinguish between two ACK MCS */
<   SetAckTimeout (GetSifs () + NanoSeconds (14473) + GetSlot () + GetMaxPropagationDelay () * 2);
<   /* BlockAck is sent using either MCS-0 or SC-MCS-1/4, we assume MCS-0 in our calculation */
<   /* BasicBlockAck Size = 152 Bytes */
<   SetBasicBlockAckTimeout (GetSifs () + GetSlot () + NanoSeconds (55927) + GetDefaultMaxPropagationDelay () * 2);
<   /* BasicBlockAck Size = 153 Bytes considering Window Size of 1024 and sent using EDMG_MCS0 */
<   SetCompressedBlockAckTimeout (GetSifs () + GetSlot () + NanoSeconds (56073) + GetDefaultMaxPropagationDelay () * 2);
< }
< //// WIGIG ////
< 
< void
< WifiMac::ConfigureDcf (Ptr<Txop> dcf, uint32_t cwmin, uint32_t cwmax, bool isDsss, AcIndex ac)
---
> WifiMac::ConfigureDcf (Ptr<Dcf> dcf, uint32_t cwmin, uint32_t cwmax, bool isDsss, enum AcIndex ac)
488,489c413
<   NS_LOG_FUNCTION (this << dcf << cwmin << cwmax << isDsss << ac);
<   /* see IEEE 802.11 section 7.3.2.29 */
---
>   /* see IEE802.11 section 7.3.2.29 */
540,560d463
< }
< 
< Ptr<HtConfiguration>
< WifiMac::GetHtConfiguration (void) const
< {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<       return device->GetHtConfiguration ();
< }
< 
< Ptr<VhtConfiguration>
< WifiMac::GetVhtConfiguration (void) const
< {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<       return device->GetVhtConfiguration ();
< }
< 
< Ptr<HeConfiguration>
< WifiMac::GetHeConfiguration (void) const
< {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<       return device->GetHeConfiguration ();
diff ../../NS3-WiGig/src/wifi/model/wifi-mac.h ../../ns-3-dev/src/wifi/model/wifi-mac.h
24,25c24,26
< #include "ns3/net-device.h"
< #include "wifi-phy-standard.h"
---
> #include "ns3/packet.h"
> #include "ns3/mac48-address.h"
> #include "wifi-phy.h"
26a28
> #include "ssid.h"
31,35c33
< class Ssid;
< class Txop;
< class HtConfiguration;
< class VhtConfiguration;
< class HeConfiguration;
---
> class Dcf;
49,54d46
<   virtual void DoDispose ();
< 
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
58,70d49
<    * Sets the device this PHY is associated with.
<    *
<    * \param device the device this PHY is associated with
<    */
<   void SetDevice (const Ptr<NetDevice> device);
<   /**
<    * Return the device this PHY is associated with
<    *
<    * \return the device this PHY is associated with
<    */
<   Ptr<NetDevice> GetDevice (void) const;
< 
<   /**
75c54
<    * \param sifs the SIFS duration
---
>    * \param sifs the sifs duration
86c65
<    * \param pifs the PIFS duration.
---
>    * \param pifs the pifs duration.
90c69
<    * \param rifs the RIFS duration.
---
>    * \param rifs the rifs duration.
94c73,77
<    * \param ackTimeout the duration of an Ack timeout.
---
>    * \param ctsTimeout the duration of a CTS timeout.
>    */
>   virtual void SetCtsTimeout (Time ctsTimeout) = 0;
>   /**
>    * \param ackTimeout the duration of an ACK timeout.
104c87
<    * \param ssid the current SSID of this MAC layer.
---
>    * \param ssid the current ssid of this MAC layer.
108,109d90
<    * Enable or disable short slot time feature.
<    *
144c125,129
<    * \return the current Ack timeout duration.
---
>    * \return the current CTS timeout duration.
>    */
>   virtual Time GetCtsTimeout (void) const = 0;
>   /**
>    * \return the current ACK timeout duration.
147a133,138
>    * \return the maximum lifetime of an MSDU.
>    *
>    * Unused for now.
>    */
>   Time GetMsduLifetime (void) const;
>   /**
158c149
<    * \return the SSID which this MAC layer is going to try to stay in.
---
>    * \return the ssid which this MAC layer is going to try to stay in.
166c157
<    * \return the BSSID of the network this device belongs to.
---
>    * \return the bssid of the network this device belongs to.
179c170
<    * The packet should be enqueued in a TX queue, and should be
---
>    * The packet should be enqueued in a tx queue, and should be
185c176
<   virtual void Enqueue (Ptr<Packet> packet, Mac48Address to, Mac48Address from) = 0;
---
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to, Mac48Address from) = 0;
190c181
<    * The packet should be enqueued in a TX queue, and should be
---
>    * The packet should be enqueued in a tx queue, and should be
194c185
<   virtual void Enqueue (Ptr<Packet> packet, Mac48Address to) = 0;
---
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to) = 0;
208c199
<    * \return the physical layer attached to this MAC
---
>    * return current attached WifiPhy device
212c203
<    * Remove currently attached WifiPhy device from this MAC.
---
>    * remove current attached WifiPhy device from this MAC.
225,226c216
<    * \param upCallback the callback to invoke when a packet must be
<    *        forwarded up the stack.
---
>    * \param upCallback the callback to invoke when a packet must be forwarded up the stack.
228c218
<   virtual void SetForwardUpCallback (Callback<void, Ptr<const Packet>, Mac48Address, Mac48Address> upCallback) = 0;
---
>   virtual void SetForwardUpCallback (Callback<void,Ptr<Packet>, Mac48Address, Mac48Address> upCallback) = 0;
237c227
<   /* Next functions are not pure virtual so non QoS WifiMacs are not
---
>   /* Next functions are not pure virtual so non Qos WifiMacs are not
242c232
<    * \param blockAckTimeout the duration for basic BlockAck timeout.
---
>    * \param blockAckTimeout the duration for basic block ACK timeout.
244c234
<    * Sets the timeout for basic BlockAck.
---
>    * Sets the timeout for basic block ACK.
246c236
<   virtual void SetBasicBlockAckTimeout (Time blockAckTimeout) = 0;
---
>   virtual void SetBasicBlockAckTimeout (Time blockAckTimeout);
248c238
<    * \return the current basic BlockAck timeout duration.
---
>    * \return the current basic block ACK timeout duration.
250c240
<   virtual Time GetBasicBlockAckTimeout (void) const = 0;
---
>   virtual Time GetBasicBlockAckTimeout (void) const;
252c242
<    * \param blockAckTimeout the duration for compressed BlockAck timeout
---
>    * \param blockAckTimeout
254c244
<    * Sets the timeout for compressed BlockAck.
---
>    * Sets the timeout for compressed block ACK.
256c246
<   virtual void SetCompressedBlockAckTimeout (Time blockAckTimeout) = 0;
---
>   virtual void SetCompressedBlockAckTimeout (Time blockAckTimeout);
258c248
<    * \return the current compressed BlockAck timeout duration.
---
>    * \return the current compressed block ACK timeout duration.
260c250
<   virtual Time GetCompressedBlockAckTimeout (void) const = 0;
---
>   virtual Time GetCompressedBlockAckTimeout (void) const;
301c291
<    * parameters such as SIFS time, slot time, timeout values, etc.,
---
>    * parameters such as sifs time, slot time, timeout values, etc.,
312,335d301
<    * \sa WifiMac::Configure80211ax_2_4Ghz
<    * \sa WifiMac::Configure80211ax_5Ghz
<    * \sa WifiMac::Configure80211ad
<    * \sa WifiMac::Configure80211ay
<    */
<   void ConfigureStandard (WifiPhyStandard standard);
<   WifiPhyStandard GetCurrentstandard (void) const;
< 
<   //// WIGIG ////
<   typedef Callback<void, WifiPhyStandard, Mac48Address, bool> BandChangedCallback;
<   void RegisterBandChangedCallback (BandChangedCallback callback);
<   virtual void NotifyBandChanged (WifiPhyStandard, Mac48Address address, bool isInitiator) = 0;
<   //// WIGIG ////
< 
<   /**
<    * \return pointer to HtConfiguration if it exists
<    */
<   Ptr<HtConfiguration> GetHtConfiguration (void) const;
<   /**
<    * \return pointer to VhtConfiguration if it exists
<    */
<   Ptr<VhtConfiguration> GetVhtConfiguration (void) const;
<   /**
<    * \return pointer to HeConfiguration if it exists
337c303
<   Ptr<HeConfiguration> GetHeConfiguration (void) const;
---
>   void ConfigureStandard (enum WifiPhyStandard standard);
343,344c309,310
<    * \param cwmin the minimum contention window for the DCF
<    * \param cwmax the maximum contention window for the DCF
---
>    * \param cwmin the minimum congestion window for the DCF
>    * \param cwmax the maximum congestion window for the DCF
350c316
<   void ConfigureDcf (Ptr<Txop> dcf, uint32_t cwmin, uint32_t cwmax, bool isDsss, AcIndex ac);
---
>   void ConfigureDcf (Ptr<Dcf> dcf, uint32_t cwmin, uint32_t cwmax, bool isDsss, enum AcIndex ac);
352,366d317
<   //// WIGIG ////
<   /**
<    * This method sets 802.11ad 60 GHz standards-compliant defaults for following attributes:
<    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
<    */
<   virtual void Configure80211ad (void);
<   /**
<    * This method sets 802.11ay 60 GHz standards-compliant defaults for following attributes:
<    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
<    */
<   virtual void Configure80211ay (void);
< 
<   WifiPhyStandard m_standard;
<   BandChangedCallback m_bandChangedCallback;
<   //// WIGIG ////
398c349
<    * Return default SIFS + default CTS-Ack delay
---
>    * Return default SIFS + default CTS-ACK delay
402c353
<    * \return the default CTS-Ack delay
---
>    * \return the default CTS-ACK delay
408c359
<    * \return the default CTS and Ack timeout
---
>    * \return the default CTS and ACK timeout
410c361
<    * Return the default CTS and Ack timeout.
---
>    * Return the default CTS and ACK timeout.
417c368
<    * Return the default basic BlockAck delay.
---
>    * Return the default basic block ACK delay.
420c371
<    * \return the default basic BlockAck delay
---
>    * \return the default basic block ACK delay
424c375
<    * Return the default basic BlockAck timeout.
---
>    * Return the default basic block ACK timeout.
426c377
<    * \return the default basic BlockAck timeout
---
>    * \return the default basic block ACK timeout
430c381
<    * Return the default compressed BlockAck delay.
---
>    * Return the default compressed block ACK delay.
433c384
<    * \return the default compressed BlockAck delay
---
>    * \return the default compressed block ACK delay
437c388
<    * Return the default compressed BlockAck timeout.
---
>    * Return the default compressed block ACK timeout.
439c390
<    * \return the default compressed BlockAck timeout
---
>    * \return the default compressed block ACK timeout
444c395
<    * \param standard the PHY standard to be used
---
>    * \param standard the phy standard to be used
447,448c398,399
<    * the configuration process for a requested PHY standard. Subclasses should
<    * implement this method to configure their DCF queues according to the
---
>    * the configuration process for a requested phy standard. Subclasses should
>    * implement this method to configure their dcf queues according to the
451c402
<   virtual void FinishConfigureStandard (WifiPhyStandard standard) = 0;
---
>   virtual void FinishConfigureStandard (enum WifiPhyStandard standard) = 0;
453,454c404
<   Time m_maxPropagationDelay; ///< maximum propagation delay
<   Ptr<NetDevice> m_device;    ///< Pointer to the device
---
>   Time m_maxPropagationDelay;
458c408
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
463c413
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
468c418
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
473,474c423,424
<    * This method sets 802.11 with 10 MHz channel spacing standards-compliant defaults
<    * for following attributes: SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * This method sets 802.11 with 10Mhz channel spacing standards-compliant defaults
>    * for following attributes: Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
478,479c428,429
<    * This method sets 802.11 with 5 MHz channel spacing standards-compliant defaults
<    * for following attributes: SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * This method sets 802.11 with 5Mhz channel spacing standards-compliant defaults
>    * for following attributes: Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
484c434
<    * SIFS, RIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Rifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
490c440
<    * SIFS, RIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Rifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
495c445
<   * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>   * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
498,508d447
<   /**
<    * This method sets 802.11ax 2.4 GHz standards-compliant defaults for following attributes:
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
<    * There is no support for short slot time.
<    */
<   void Configure80211ax_2_4Ghz (void);
<   /**
<    * This method sets 802.11ax 5 GHz standards-compliant defaults for following attributes:
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
<    */
<   void Configure80211ax_5Ghz (void);
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-header.cc ../../ns-3-dev/src/wifi/model/wifi-mac-header.cc
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
20,22c19,20
<  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
<  *          Mirko Banchi <mk.banchi@gmail.com>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
>  * Author: Mirko Banchi <mk.banchi@gmail.com>
25c23
< #include "ns3/nstime.h"
---
> #include "ns3/assert.h"
33d30
< /// type enumeration
38,39c35
<   TYPE_DATA = 2,
<   TYPE_Extension = 3  // Extension frame type for DMG.
---
>   TYPE_DATA = 2
42d37
< /// subtype enumeration
45c40
<   SUBTYPE_CTL_EXTENSION = 6, // Extension subtype for DMG Control Frame Extension.
---
>   //Reserved: 0 - 6
51,69c46
<   SUBTYPE_CTL_ACK = 13,
<   SUBTYPE_CTL_END = 14,
<   SUBTYPE_CTL_END_ACK = 15
< };
< 
< /*
<  * Enumeration for DMG Control Frame Extension.
<  */
< enum
< {
<   SUBTYPE_CTL_EXTENSION_POLL = 2,
<   SUBTYPE_CTL_EXTENSION_SPR = 3,
<   SUBTYPE_CTL_EXTENSION_GRANT = 4,
<   SUBTYPE_CTL_EXTENSION_DMG_CTS = 5,
<   SUBTYPE_CTL_EXTENSION_DMG_DTS = 6,
<   SUBTYPE_CTL_EXTENSION_GRANT_ACK = 7,
<   SUBTYPE_CTL_EXTENSION_SSW = 8,
<   SUBTYPE_CTL_EXTENSION_SSW_FBCK = 9,
<   SUBTYPE_CTL_EXTENSION_SSW_ACK = 10
---
>   SUBTYPE_CTL_ACK = 13
75,81c52,53
<     m_ctrlOrder (0),
<     m_amsduPresent (0),
<     m_dmgPpdu (false),
<     m_beamRefinementRequired (false),
<     m_beamTrackingRequired (false),
<     m_trainingFieldLength (0),
<     m_edmgTrainingFieldLength (0)
---
>     m_ctrlOrder (1),
>     m_amsduPresent (0)
138c110,180
< WifiMacHeader::SetType (WifiMacType type, bool resetToDsFromDs)
---
> WifiMacHeader::SetAssocReq (void)
> {
>   m_ctrlType = TYPE_MGT;
>   m_ctrlSubtype = 0;
> }
> 
> void
> WifiMacHeader::SetAssocResp (void)
> {
>   m_ctrlType = TYPE_MGT;
>   m_ctrlSubtype = 1;
> }
> 
> void
> WifiMacHeader::SetProbeReq (void)
> {
>   m_ctrlType = TYPE_MGT;
>   m_ctrlSubtype = 4;
> }
> 
> void
> WifiMacHeader::SetProbeResp (void)
> {
>   m_ctrlType = TYPE_MGT;
>   m_ctrlSubtype = 5;
> }
> 
> void
> WifiMacHeader::SetBeacon (void)
> {
>   m_ctrlType = TYPE_MGT;
>   m_ctrlSubtype = 8;
> }
> 
> void
> WifiMacHeader::SetBlockAckReq (void)
> {
>   m_ctrlType = TYPE_CTL;
>   m_ctrlSubtype = 8;
> }
> 
> void
> WifiMacHeader::SetBlockAck (void)
> {
>   m_ctrlType = TYPE_CTL;
>   m_ctrlSubtype = 9;
> }
> 
> void
> WifiMacHeader::SetTypeData (void)
> {
>   m_ctrlType = TYPE_DATA;
>   m_ctrlSubtype = 0;
> }
> 
> void
> WifiMacHeader::SetAction (void)
> {
>   m_ctrlType = TYPE_MGT;
>   m_ctrlSubtype = 0x0D;
> }
> 
> void
> WifiMacHeader::SetMultihopAction (void)
> {
>   m_ctrlType = TYPE_MGT;
>   m_ctrlSubtype = 0x0F;
> }
> 
> void
> WifiMacHeader::SetType (enum WifiMacType type)
166,218d207
<     case WIFI_MAC_CTL_END:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_END;
<       break;
<     case WIFI_MAC_CTL_END_ACK:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_END_ACK;
<       break;
<     case WIFI_MAC_CTL_DMG_POLL:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_POLL;
<       break;
<     case WIFI_MAC_CTL_DMG_SPR:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_SPR;
<       break;
<     case WIFI_MAC_CTL_DMG_GRANT:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_GRANT;
<       break;
<     case WIFI_MAC_CTL_DMG_CTS:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_DMG_CTS;
<       break;
<     case WIFI_MAC_CTL_DMG_DTS:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_DMG_DTS;
<       break;
<     case WIFI_MAC_CTL_DMG_SSW:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_SSW;
<       break;
<     case WIFI_MAC_CTL_DMG_SSW_FBCK:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_SSW_FBCK;
<       break;
<     case WIFI_MAC_CTL_DMG_SSW_ACK:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_SSW_ACK;
<       break;
<     case WIFI_MAC_CTL_DMG_GRANT_ACK:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_GRANT_ACK;
<       break;
331,339d319
<     case WIFI_MAC_EXTENSION_DMG_BEACON:
<       m_ctrlType = TYPE_Extension;
<       m_ctrlSubtype = 0;
<       break;
<     }
<   if (resetToDsFromDs)
<     {
<       m_ctrlToDs = 0;
<       m_ctrlFromDs = 0;
340a321,322
>   m_ctrlToDs = 0;
>   m_ctrlFromDs = 0;
346d327
<   NS_ASSERT (duration <= 32768);
353c334
<   int64_t duration_us = static_cast<int64_t> (ceil (static_cast<double> (duration.GetNanoSeconds ()) / 1000));
---
>   int64_t duration_us = ceil ((double)duration.GetNanoSeconds () / 1000);
358,359c339
< void
< WifiMacHeader::SetId (uint16_t id)
---
> void WifiMacHeader::SetId (uint16_t id)
364,365c344
< void
< WifiMacHeader::SetSequenceNumber (uint16_t seq)
---
> void WifiMacHeader::SetSequenceNumber (uint16_t seq)
370,371c349
< void
< WifiMacHeader::SetFragmentNumber (uint8_t frag)
---
> void WifiMacHeader::SetFragmentNumber (uint8_t frag)
376,377c354
< void
< WifiMacHeader::SetNoMoreFragments (void)
---
> void WifiMacHeader::SetNoMoreFragments (void)
382,383c359
< void
< WifiMacHeader::SetMoreFragments (void)
---
> void WifiMacHeader::SetMoreFragments (void)
388,389c364
< void
< WifiMacHeader::SetOrder (void)
---
> void WifiMacHeader::SetOrder (void)
394,395c369
< void
< WifiMacHeader::SetNoOrder (void)
---
> void WifiMacHeader::SetNoOrder (void)
400,401c374
< void
< WifiMacHeader::SetRetry (void)
---
> void WifiMacHeader::SetRetry (void)
406,407c379
< void
< WifiMacHeader::SetNoRetry (void)
---
> void WifiMacHeader::SetNoRetry (void)
412,425c384
< void
< WifiMacHeader::SetMoreData (void)
< {
<   m_ctrlMoreData = 1;
< }
< 
< void
< WifiMacHeader::SetNoMoreData (void)
< {
<   m_ctrlMoreData = 0;
< }
< 
< void
< WifiMacHeader::SetQosTid (uint8_t tid)
---
> void WifiMacHeader::SetQosTid (uint8_t tid)
430,431c389
< void
< WifiMacHeader::SetQosEosp ()
---
> void WifiMacHeader::SetQosEosp ()
436,437c394
< void
< WifiMacHeader::SetQosNoEosp ()
---
> void WifiMacHeader::SetQosNoEosp ()
442c399
< void WifiMacHeader::SetQosAckPolicy (QosAckPolicy policy)
---
> void WifiMacHeader::SetQosAckPolicy (enum QosAckPolicy policy)
533c490
< WifiMacType
---
> enum WifiMacType
542a500
>           break;
544a503
>           break;
546a506
>           break;
548a509
>           break;
550a512
>           break;
552a515
>           break;
554a518
>           break;
556a521
>           break;
558a524
>           break;
560a527
>           break;
562a530
>           break;
564a533
>           break;
566a536
>           break;
573a544
>           break;
575a547
>           break;
577a550
>           break;
579a553
>           break;
582,603c556
<         case SUBTYPE_CTL_EXTENSION:
<           switch (m_ctrlFrameExtension)
<             {
<             case SUBTYPE_CTL_EXTENSION_POLL:
<               return WIFI_MAC_CTL_DMG_POLL;
<             case SUBTYPE_CTL_EXTENSION_SPR:
<               return WIFI_MAC_CTL_DMG_SPR;
<             case SUBTYPE_CTL_EXTENSION_GRANT:
<               return WIFI_MAC_CTL_DMG_GRANT;
<             case SUBTYPE_CTL_EXTENSION_DMG_CTS:
<               return WIFI_MAC_CTL_DMG_CTS;
<             case SUBTYPE_CTL_EXTENSION_DMG_DTS:
<               return WIFI_MAC_CTL_DMG_DTS;
<             case SUBTYPE_CTL_EXTENSION_GRANT_ACK:
<               return WIFI_MAC_CTL_DMG_GRANT_ACK;
<             case SUBTYPE_CTL_EXTENSION_SSW:
<               return WIFI_MAC_CTL_DMG_SSW;
<             case SUBTYPE_CTL_EXTENSION_SSW_FBCK:
<               return WIFI_MAC_CTL_DMG_SSW_FBCK;
<             case SUBTYPE_CTL_EXTENSION_SSW_ACK:
<               return WIFI_MAC_CTL_DMG_SSW_ACK;
<             }
---
>           break;
610a564
>           break;
612a567
>           break;
614a570
>           break;
616a573
>           break;
618a576
>           break;
620a579
>           break;
622a582
>           break;
624a585
>           break;
626a588
>           break;
628a591
>           break;
630a594
>           break;
632a597
>           break;
634a600
>           break;
636a603
>           break;
638a606
>           break;
640,648c608
< 	break;
< 
<     case TYPE_Extension:
<       switch (m_ctrlSubtype)
<         {
<         case 0:
<           return WIFI_MAC_EXTENSION_DMG_BEACON;
<         }
<         break;
---
>       break;
652c612
<   return (WifiMacType) - 1;
---
>   return (enum WifiMacType) -1;
670a631
> 
692,698c653
< WifiMacHeader::IsExtension (void) const
< {
<   return (m_ctrlType == TYPE_Extension);
< }
< 
< bool
< WifiMacHeader::IsCfPoll (void) const
---
> WifiMacHeader::IsCfpoll (void) const
711,741d665
<     default:
<       return false;
<     }
< }
< 
< bool
< WifiMacHeader::IsCfEnd (void) const
< {
<   switch (GetType ())
<     {
<     case WIFI_MAC_CTL_END:
<     case WIFI_MAC_CTL_END_ACK:
<       return true;
<     default:
<       return false;
<     }
< }
< 
< bool
< WifiMacHeader::IsCfAck (void) const
< {
<   switch (GetType ())
<     {
<     case WIFI_MAC_DATA_CFACK:
<     case WIFI_MAC_DATA_CFACK_CFPOLL:
<     case WIFI_MAC_DATA_NULL_CFACK:
<     case WIFI_MAC_DATA_NULL_CFACK_CFPOLL:
<     case WIFI_MAC_CTL_END_ACK:
<       return true;
<     default:
<       return false;
743,759d666
<     }
< }
< 
< bool
< WifiMacHeader::HasData (void) const
< {
<   switch (GetType ())
<     {
<     case WIFI_MAC_DATA:
<     case WIFI_MAC_DATA_CFACK:
<     case WIFI_MAC_DATA_CFPOLL:
<     case WIFI_MAC_DATA_CFACK_CFPOLL:
<     case WIFI_MAC_QOSDATA:
<     case WIFI_MAC_QOSDATA_CFACK:
<     case WIFI_MAC_QOSDATA_CFPOLL:
<     case WIFI_MAC_QOSDATA_CFACK_CFPOLL:
<       return true;
761a669
>       break;
778,789d685
< WifiMacHeader::IsDmgCts (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_CTS);
< }
< 
< bool
< WifiMacHeader::IsDmgDts (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_DTS);
< }
< 
< bool
862,867d757
< WifiMacHeader::IsActionNoAck () const
< {
<   return (GetType () == WIFI_MAC_MGT_ACTION_NO_ACK);
< }
< 
< bool
885,926d774
< bool
< WifiMacHeader::IsDMGBeacon (void) const
< {
<   return (GetType () == WIFI_MAC_EXTENSION_DMG_BEACON);
< }
< 
< bool
< WifiMacHeader::IsSSW (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_SSW);
< }
< 
< bool
< WifiMacHeader::IsSSW_FBCK (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_SSW_FBCK);
< }
< 
< bool
< WifiMacHeader::IsSSW_ACK (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_SSW_ACK);
< }
< 
< bool
< WifiMacHeader::IsPollFrame (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_POLL);
< }
< 
< bool
< WifiMacHeader::IsSprFrame (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_SPR);
< }
< 
< bool
< WifiMacHeader::IsGrantFrame (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_GRANT);
< }
< 
951c799
< uint8_t
---
> uint16_t
964,969d811
< WifiMacHeader::IsMoreData (void) const
< {
<   return (m_ctrlMoreData == 1);
< }
< 
< bool
1003,1004c845,853
< WifiMacHeader::QosAckPolicy
< WifiMacHeader::GetQosAckPolicy (void) const
---
> bool
> WifiMacHeader::IsQosAmsdu (void) const
> {
>   NS_ASSERT (IsQosData ());
>   return (m_amsduPresent == 1);
> }
> 
> uint8_t
> WifiMacHeader::GetQosTid (void) const
1007c856,857
<   QosAckPolicy policy;
---
>   return m_qosTid;
> }
1008a859,861
> enum WifiMacHeader::QosAckPolicy
> WifiMacHeader::GetQosAckPolicy (void) const
> {
1012c865
<       policy = NORMAL_ACK;
---
>       return NORMAL_ACK;
1015c868
<       policy = NO_ACK;
---
>       return NO_ACK;
1018c871
<       policy = NO_EXPLICIT_ACK;
---
>       return NO_EXPLICIT_ACK;
1021c874
<       policy = BLOCK_ACK;
---
>       return BLOCK_ACK;
1023,1024d875
<     default:
<       NS_ABORT_MSG ("Unknown QoS Ack policy");
1026,1033c877,879
<   return policy;
< }
< 
< bool
< WifiMacHeader::IsQosAmsdu (void) const
< {
<   NS_ASSERT (IsQosData ());
<   return (m_amsduPresent == 1);
---
>   // NOTREACHED
>   NS_ASSERT (false);
>   return (enum QosAckPolicy) -1;
1037c883
< WifiMacHeader::GetQosTid (void) const
---
> WifiMacHeader::GetQosTxopLimit (void) const
1040c886
<   return m_qosTid;
---
>   return m_qosStuff;
1048a895,898
>   val |= (m_ctrlToDs << 8) & (0x1 << 8);
>   val |= (m_ctrlFromDs << 9) & (0x1 << 9);
>   val |= (m_ctrlMoreFrag << 10) & (0x1 << 10);
>   val |= (m_ctrlRetry << 11) & (0x1 << 11);
1052,1066d901
< 
<   if ((m_ctrlType == 1) && (m_ctrlSubtype == 6))
<     {
<       /* Frame Control for DMG */
<       val |= (m_ctrlFrameExtension << 8) & (0xf << 8);
<     }
<   else
<     {
<       /* Frame Control for Non-DMG */
<       val |= (m_ctrlToDs << 8) & (0x1 << 8);
<       val |= (m_ctrlFromDs << 9) & (0x1 << 9);
<       val |= (m_ctrlMoreFrag << 10) & (0x1 << 10);
<       val |= (m_ctrlRetry << 11) & (0x1 << 11);
<     }
< 
1078,1087c913
<   if (m_dmgPpdu)
<     {
<       val |= m_qosAmsduType << 8;
<       val |= m_qosRdg << 9;
<       val |= m_qosAcConstraint << 15;
<     }
<   else
<     {
<       val |= m_qosStuff << 8;
<     }
---
>   val |= m_qosStuff << 8;
1096,1115c922,928
< 
<   if ((m_ctrlType == 1) && (m_ctrlSubtype == 6))
<     {
<       /* Frame Control for DMG */
<       m_ctrlFrameExtension = (ctrl >> 8) & 0x0F;
<       m_ctrlMoreData = (ctrl >> 13) & 0x01;
<       m_ctrlWep = (ctrl >> 14) & 0x01;
<       m_ctrlOrder = (ctrl >> 15) & 0x01;
<     }
<   else
<     {
<       /* Frame Control for Non-DMG */
<       m_ctrlToDs = (ctrl >> 8) & 0x01;
<       m_ctrlFromDs = (ctrl >> 9) & 0x01;
<       m_ctrlMoreFrag = (ctrl >> 10) & 0x01;
<       m_ctrlRetry = (ctrl >> 11) & 0x01;
<       m_ctrlMoreData = (ctrl >> 13) & 0x01;
<       m_ctrlWep = (ctrl >> 14) & 0x01;
<       m_ctrlOrder = (ctrl >> 15) & 0x01;
<     }
---
>   m_ctrlToDs = (ctrl >> 8) & 0x01;
>   m_ctrlFromDs = (ctrl >> 9) & 0x01;
>   m_ctrlMoreFrag = (ctrl >> 10) & 0x01;
>   m_ctrlRetry = (ctrl >> 11) & 0x01;
>   m_ctrlMoreData = (ctrl >> 13) & 0x01;
>   m_ctrlWep = (ctrl >> 14) & 0x01;
>   m_ctrlOrder = (ctrl >> 15) & 0x01;
1117d929
< 
1124d935
< 
1132,1141c943
<   if (m_dmgPpdu)
<     {
<       m_qosAmsduType = (qos >> 8) & 0x1;
<       m_qosRdg = (qos >> 9) & 0x1;
<       m_qosAcConstraint = (qos >> 15) & 0x1;
<     }
<   else
<     {
<       m_qosStuff = (qos >> 8) & 0x00ff;
<     }
---
>   m_qosStuff = (qos >> 8) & 0x00ff;
1157,1160d958
<         case SUBTYPE_CTL_BACKREQ:
<         case SUBTYPE_CTL_BACKRESP:
<         case SUBTYPE_CTL_END:
<         case SUBTYPE_CTL_END_ACK:
1166a965,968
>         case SUBTYPE_CTL_BACKREQ:
>         case SUBTYPE_CTL_BACKRESP:
>           size = 2 + 2 + 6 + 6;
>           break;
1170,1186d971
<         case SUBTYPE_CTL_EXTENSION:
<           switch (m_ctrlFrameExtension)
<             {
<             case SUBTYPE_CTL_EXTENSION_POLL:
<             case SUBTYPE_CTL_EXTENSION_SPR:
<             case SUBTYPE_CTL_EXTENSION_GRANT:
<             case SUBTYPE_CTL_EXTENSION_DMG_CTS:
<             case SUBTYPE_CTL_EXTENSION_SSW:
<             case SUBTYPE_CTL_EXTENSION_SSW_FBCK:
<             case SUBTYPE_CTL_EXTENSION_SSW_ACK:
<             case SUBTYPE_CTL_EXTENSION_GRANT_ACK:
<               size = 2 + 2 + 6 + 6;
<               break;
<             case SUBTYPE_CTL_EXTENSION_DMG_DTS:
<               size = 2 + 2 + 6;
<               break;
<             }
1200,1202d984
<     case TYPE_Extension:
<       size = 2 + 2 + 6;
<       break;
1207,1257d988
< void
< WifiMacHeader::SetAsDmgPpdu (void)
< {
<   m_dmgPpdu = true;
<   m_ctrlOrder = 0;
< }
< 
< bool
< WifiMacHeader::IsDmgPpdu (void) const
< {
<   return m_dmgPpdu;
< }
< 
< void
< WifiMacHeader::SetQosAmsduType (AMSDU_Type type)
< {
<   m_qosAmsduType = static_cast<uint8_t> (type);
< }
< 
< void WifiMacHeader::SetQosRdGrant (bool value)
< {
<   m_qosRdg = value;
< }
< 
< void
< WifiMacHeader::SetQosAcConstraint (bool value)
< {
<   m_qosAcConstraint = value;
< }
< 
< AMSDU_Type
< WifiMacHeader::GetQosAmsduType (void) const
< {
<   NS_ASSERT (m_dmgPpdu && IsQosData ());
<   return static_cast<AMSDU_Type> (m_qosAmsduType);
< }
< 
< bool
< WifiMacHeader::IsQosRdGrant (void) const
< {
<   NS_ASSERT (m_dmgPpdu && IsQosData ());
<   return (m_qosRdg == 1);
< }
< 
< bool
< WifiMacHeader::GetQosAcConstraint (void) const
< {
<   NS_ASSERT (m_dmgPpdu && IsQosData ());
<   return m_qosAcConstraint;
< }
< 
1273,1286d1003
<       FOO (CTL_END);
<       FOO (CTL_END_ACK);
< 
<       FOO (CTL_DMG_POLL);
<       FOO (CTL_DMG_SPR);
<       FOO (CTL_DMG_GRANT);
<       FOO (CTL_DMG_CTS);
<       FOO (CTL_DMG_DTS);
<       FOO (CTL_DMG_GRANT_ACK);
<       FOO (CTL_DMG_SSW);
<       FOO (CTL_DMG_SSW_FBCK);
<       FOO (CTL_DMG_SSW_ACK);
< 
<       FOO (EXTENSION_DMG_BEACON);
1321d1037
< #ifndef _WIN32
1324d1039
< #endif
1367a1083,1088
>     case WIFI_MAC_CTL_BACKREQ:
>       break;
>     case WIFI_MAC_CTL_BACKRESP:
>       break;
>     case WIFI_MAC_CTL_CTLWRAPPER:
>       break;
1422,1436d1142
<     case WIFI_MAC_CTL_DMG_POLL:
<     case WIFI_MAC_CTL_DMG_SPR:
<     case WIFI_MAC_CTL_DMG_GRANT:
<     case WIFI_MAC_CTL_DMG_CTS:
<     case WIFI_MAC_CTL_DMG_DTS:
<     case WIFI_MAC_CTL_DMG_SSW:
<     case WIFI_MAC_CTL_DMG_SSW_FBCK:
<     case WIFI_MAC_CTL_DMG_SSW_ACK:
<     case WIFI_MAC_CTL_DMG_GRANT_ACK:
<     case WIFI_MAC_EXTENSION_DMG_BEACON:
<     case WIFI_MAC_CTL_BACKREQ:
<     case WIFI_MAC_CTL_BACKRESP:
<     case WIFI_MAC_CTL_CTLWRAPPER:
<     case WIFI_MAC_CTL_END:
<     case WIFI_MAC_CTL_END_ACK:
1451d1156
<     default:
1479,1482d1183
<         case SUBTYPE_CTL_BACKREQ:
<         case SUBTYPE_CTL_BACKRESP:
<         case SUBTYPE_CTL_END:
<         case SUBTYPE_CTL_END_ACK:
1488,1503c1189,1191
<         case SUBTYPE_CTL_EXTENSION:
<           switch (m_ctrlFrameExtension)
<             {
<             case SUBTYPE_CTL_EXTENSION_POLL:
<             case SUBTYPE_CTL_EXTENSION_SPR:
<             case SUBTYPE_CTL_EXTENSION_GRANT:
<             case SUBTYPE_CTL_EXTENSION_DMG_CTS:
<             case SUBTYPE_CTL_EXTENSION_GRANT_ACK:
<             case SUBTYPE_CTL_EXTENSION_SSW:
<             case SUBTYPE_CTL_EXTENSION_SSW_FBCK:
<             case SUBTYPE_CTL_EXTENSION_SSW_ACK:
<               WriteTo(i, m_addr2); // TA Address Field.
<               break;
<             case SUBTYPE_CTL_EXTENSION_DMG_DTS:
<               break;
<             }
---
>         case SUBTYPE_CTL_BACKREQ:
>         case SUBTYPE_CTL_BACKRESP:
>           WriteTo (i, m_addr2);
1525,1526d1212
<     case TYPE_Extension:
<       break;
1553,1556d1238
<         case SUBTYPE_CTL_BACKREQ:
<         case SUBTYPE_CTL_BACKRESP:
<         case SUBTYPE_CTL_END:
<         case SUBTYPE_CTL_END_ACK:
1562,1577c1244,1246
<         case SUBTYPE_CTL_EXTENSION:
<           switch (m_ctrlFrameExtension)
<             {
<             case SUBTYPE_CTL_EXTENSION_POLL:
<             case SUBTYPE_CTL_EXTENSION_SPR:
<             case SUBTYPE_CTL_EXTENSION_GRANT:
<             case SUBTYPE_CTL_EXTENSION_DMG_CTS:
<             case SUBTYPE_CTL_EXTENSION_GRANT_ACK:
<             case SUBTYPE_CTL_EXTENSION_SSW:
<             case SUBTYPE_CTL_EXTENSION_SSW_FBCK:
<             case SUBTYPE_CTL_EXTENSION_SSW_ACK:
<               ReadFrom(i, m_addr2); // TA Address Field.
<               break;
<             case SUBTYPE_CTL_EXTENSION_DMG_DTS:
<               break;
<             }
---
>         case SUBTYPE_CTL_BACKREQ:
>         case SUBTYPE_CTL_BACKRESP:
>           ReadFrom (i, m_addr2);
1594,1595d1262
<     case TYPE_Extension:
<       break;
1598,1671d1264
< }
< 
< /* 802.11ad Functions */
< 
< void
< WifiMacHeader::SetPacketType (PacketType type)
< {
<   m_brpPacketType = type;
< }
< 
< PacketType
< WifiMacHeader::GetPacketType (void) const
< {
<   return m_brpPacketType;
< }
< 
< void
< WifiMacHeader::SetTrainngFieldLength (uint8_t length)
< {
<   m_trainingFieldLength = length;
< }
< 
< uint8_t
< WifiMacHeader::GetTrainngFieldLength (void) const
< {
<   return m_trainingFieldLength;
< }
< 
< void
< WifiMacHeader::SetEdmgTrainingFieldLength (uint8_t length)
< {
<   m_edmgTrainingFieldLength = length;
< }
< 
< uint8_t
< WifiMacHeader::GetEdmgTrainingFieldLength (void) const
< {
<   return m_edmgTrainingFieldLength;
< }
< 
< void
< WifiMacHeader::RequestBeamRefinement (void)
< {
<   m_beamRefinementRequired = true;
< }
< 
< void
< WifiMacHeader::DisableBeamRefinement (void)
< {
<   m_beamRefinementRequired = false;
< }
< 
< bool
< WifiMacHeader::IsBeamRefinementRequested (void) const
< {
<   return (m_beamRefinementRequired == true);
< }
< 
< void
< WifiMacHeader::RequestBeamTracking (void)
< {
<   m_beamTrackingRequired = true;
< }
< 
< void
< WifiMacHeader::DisableBeamTracking (void)
< {
<   m_beamTrackingRequired = false;
< }
< 
< bool
< WifiMacHeader::IsBeamTrackingRequested (void) const
< {
<   return (m_beamTrackingRequired == true);
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-header.h ../../ns-3-dev/src/wifi/model/wifi-mac-header.h
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
20,22c19,20
<  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
<  *          Mirko Banchi <mk.banchi@gmail.com>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
>  * Author: Mirko Banchi <mk.banchi@gmail.com>
30c28,29
< #include "wifi-phy-standard.h"
---
> #include "ns3/nstime.h"
> #include <stdint.h>
34,35d32
< class Time;
< 
47,59d43
<   WIFI_MAC_CTL_END,
<   WIFI_MAC_CTL_END_ACK,
< 
<   // New Control Frames for 802.11ad.
<   WIFI_MAC_CTL_DMG_POLL,
<   WIFI_MAC_CTL_DMG_SPR,
<   WIFI_MAC_CTL_DMG_GRANT,
<   WIFI_MAC_CTL_DMG_CTS,
<   WIFI_MAC_CTL_DMG_DTS,
<   WIFI_MAC_CTL_DMG_SSW,
<   WIFI_MAC_CTL_DMG_SSW_FBCK,
<   WIFI_MAC_CTL_DMG_SSW_ACK,
<   WIFI_MAC_CTL_DMG_GRANT_ACK,
90,100d73
< 
<   /*
<    *  Extension Frames for DMG.
<    */
<   WIFI_MAC_EXTENSION_DMG_BEACON,
< };
< 
< enum AMSDU_Type
< {
<   AMSDU_TYPE_BASIC = 0,
<   AMSDU_TYPE_SHORT = 1,
112c85
<    * Ack policy for QoS frames.
---
>    * ACK policy for QoS frames.
134c107
<   virtual ~WifiMacHeader ();
---
>   ~WifiMacHeader ();
136,139d108
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
141,145c110,114
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
147a117,157
>    * Set Type/Subtype values for an association request header.
>    */
>   void SetAssocReq (void);
>   /**
>    * Set Type/Subtype values for an association response header.
>    */
>   void SetAssocResp (void);
>   /**
>    * Set Type/Subtype values for a probe request header.
>    */
>   void SetProbeReq (void);
>   /**
>    * Set Type/Subtype values for a probe response header.
>    */
>   void SetProbeResp (void);
>   /**
>    * Set Type/Subtype values for a beacon header.
>    */
>   void SetBeacon (void);
>   /**
>    * Set Type/Subtype values for a data packet with
>    * no subtype equal to 0.
>    */
>   void SetTypeData (void);
>   /**
>    * Set Type/Subtype values for an action header.
>    */
>   void SetAction ();
>   /**
>    * Set Type/Subtype values for a Block Ack Request header.
>    */
>   void SetBlockAckReq (void);
>   /**
>    * Set Type/Subtype values for a Block Ack header.
>    */
>   void SetBlockAck (void);
>   /**
>    * Set Type/Subtype values for a multihop action header.
>    */
>   void SetMultihopAction ();
>   /**
192,193d201
<    * \param resetToDsFromDs whether the ToDs and FromDs flags
<    *        should be reset.
195c203
<   void SetType (WifiMacType type, bool resetToDsFromDs = true);
---
>   void SetType (enum WifiMacType type);
244,251d251
<    * Set the More Data bit in the Frame Control field.
<    */
<   void SetMoreData (void);
<   /**
<    * Un-set the More Data bit in the Frame Control field.
<    */
<   void SetNoMoreData (void);
<   /**
266c266
<    * Set the QoS Ack policy in the QoS control field.
---
>    * Set the QoS ACK policy in the QoS control field.
268c268
<    * \param policy the Qos Ack policy
---
>    * \param policy
270c270
<   void SetQosAckPolicy (QosAckPolicy policy);
---
>   void SetQosAckPolicy (enum QosAckPolicy policy);
294c294
<    * \param txop the TXOP limit
---
>    * \param txop
306,330d305
<    * Set as DMG PPDU.
<    */
<   void SetAsDmgPpdu (void);
<   /**
<    * Check whether the curent PPDU is DMG
<    * \return True if the frame is DMG PPDU, otherwise false.
<    */
<   bool IsDmgPpdu (void) const;
<   /**
<    * Set the type of A-MSDU.
<    */
<   void SetQosAmsduType (AMSDU_Type type);
<   /**
<    * The RDG/More PPDU subfield of the HT Control field is interpreted differently depending on whether it is
<    * transmitted by an RD initiator or an RD responder, as defined in Table 8-13.
<    * \return
<    */
<   void SetQosRdGrant (bool value);
<   /**
<    * The AC Constraint subfield of the QoS Control field for DMG frames indicates whether the mapped AC of
<    * an RD data frame is constrained to a single AC, as defined in Table 8-12
<    * \return
<    */
<   void SetQosAcConstraint (bool value);
<   /**
368c343
<   WifiMacType GetType (void) const;
---
>   enum WifiMacType GetType (void) const;
380c355
<    * Data with QoS)
---
>    * DATA with QoS)
387c362
<    * possible values for QoS Data.
---
>    * possible values for QoS DATA.
393,399d367
<    * Return true if the header type is DATA and is not DATA_NULL.
<    *
<    * \return true if the header type is DATA and is not DATA_NULL,
<    *         false otherwise
<    */
<   bool HasData (void) const;
<   /**
412,417d379
<    * Return true if the Type is Extension.
<    *
<    * \return true if Type is Extension, false otherwise
<    */
<   bool IsExtension (void) const;
<   /**
422,434c384
<   bool IsCfPoll (void) const;
<   /**
<    * Return true if the header is a CF-Ack header.
<    *
<    * \return true if the header is a CF-Ack header, false otherwise
<    */
<   bool IsCfAck (void) const;
<   /**
<    * Return true if the header is a CF-End header.
<    *
<    * \return true if the header is a CF-End header, false otherwise
<    */
<   bool IsCfEnd (void) const;
---
>   bool IsCfpoll (void) const;
448c398
<    * Return true if the header is a DMG CTS header.
---
>    * Return true if the header is an ACK header.
450,462c400
<    * \return true if the header is a DMG CTS header, false otherwise
<    */
<   bool IsDmgCts (void) const;
<   /**
<    * Return true if the header is a DTS header.
<    *
<    * \return true if the header is a DTS header, false otherwise
<    */
<   bool IsDmgDts (void) const;
<   /**
<    * Return true if the header is an Ack header.
<    *
<    * \return true if the header is an Ack header, false otherwise
---
>    * \return true if the header is an ACK header, false otherwise
466c404
<    * Return true if the header is a BlockAckRequest header.
---
>    * Return true if the header is a Block ACK Request header.
468c406
<    * \return true if the header is a BlockAckRequest header, false otherwise
---
>    * \return true if the header is a Block ACK Request header, false otherwise
472c410
<    * Return true if the header is a BlockAck header.
---
>    * Return true if the header is a Block ACK header.
474c412
<    * \return true if the header is a BlockAck header, false otherwise
---
>    * \return true if the header is a Block ACK header, false otherwise
520,561d457
<    * Return true if the header is a DMG Beacon header.
<    *
<    * \return true if the header is a DMG Beacon header, false otherwise
<    */
<   bool IsDMGBeacon (void) const;
<   /**
<    * Return true if the header is a SSW header.
<    *
<    * \return true if the header is a SSW header, false otherwise
<    */
<   bool IsSSW (void) const;
<   /**
<    * Return true if the header is a SSW-Feedback header.
<    *
<    * \return true if the header is a SSW-Feedback header, false otherwise
<    */
<   bool IsSSW_FBCK (void) const;
<   /**
<    * Return true if the header is a SSW-ACK header.
<    *
<    * \return true if the header is a SSW-ACK header, false otherwise
<    */
<   bool IsSSW_ACK (void) const;
<   /**
<    * Return true if the header is a Poll header.
<    *
<    * \return true if the header is a Poll header, false otherwise
<    */
<   bool IsPollFrame (void) const;
<   /**
<    * Return true if the header is a SPR header.
<    *
<    * \return true if the header is a SPR header, false otherwise
<    */
<   bool IsSprFrame (void) const;
<   /**
<    * Return true if the header is a Grant header.
<    *
<    * \return true if the header is a Grant header, false otherwise
<    */
<   bool IsGrantFrame (void) const;
<   /**
584,590c480
<   bool IsAction (void) const;
<   /**
<    * Return true if the header is an Action No Ack header.
<    *
<    * \return true if the header is an Action No Ack header, false otherwise
<    */
<   bool IsActionNoAck (void) const;
---
>   bool IsAction () const;
597c487
<   bool IsMultihopAction (void) const;
---
>   bool IsMultihopAction () const;
627c517
<   uint8_t GetFragmentNumber (void) const;
---
>   uint16_t GetFragmentNumber (void) const;
635,640d524
<    * Return if the More Data bit is set.
<    *
<    * \return true if the More Data bit is set, false otherwise
<    */
<   bool IsMoreData (void) const;
<   /**
647c531
<    * Return if the QoS Ack policy is Block Ack.
---
>    * Return if the QoS ACK policy is Block ACK.
649c533
<    * \return true if the QoS Ack policy is Block Ack, false otherwise
---
>    * \return true if the QoS ACK policy is Block ACK, false otherwise
653c537
<    * Return if the QoS Ack policy is No Ack.
---
>    * Return if the QoS ACK policy is No ACK.
655c539
<    * \return true if the QoS Ack policy is No Ack, false otherwise
---
>    * \return true if the QoS ACK policy is No ACK, false otherwise
659c543
<    * Return if the QoS Ack policy is Normal Ack.
---
>    * Return if the QoS ACK policy is Normal ACK.
661c545
<    * \return true if the QoS Ack policy is No Ack, false otherwise
---
>    * \return true if the QoS ACK policy is No ACK, false otherwise
684c568
<    * Return the QoS Ack policy in the QoS control field.
---
>    * Return the QoS ACK Policy of a QoS header.
686c570
<    * \return the QoS Ack policy in the QoS control field
---
>    * \return the QoS ACK Policy of a QoS header
688c572
<   QosAckPolicy GetQosAckPolicy (void) const;
---
>   enum QosAckPolicy GetQosAckPolicy (void) const;
696,711d579
<    * Return the type of A-MSDU
<    *
<    * \return the type of A-MSDU
<    */
<   AMSDU_Type GetQosAmsduType (void) const;
<   /**
<    * Check if it is RD Grant.
<    *
<    * \return True if RDG is set, otherwise false.
<    */
<   bool IsQosRdGrant (void) const;
<   /**
<    * \return
<    */
<   bool GetQosAcConstraint (void) const;
<   /**
731,738d598
<   /**
<    * Request Beam Refinement Option.
<    */
<   void RequestBeamRefinement (void);
<   /**
<    * Disable Beam Refinement Option.
<    */
<   void DisableBeamRefinement (void);
740,782d599
<   bool IsBeamRefinementRequested (void) const;
<   /**
<    * Set BRP Packet Type.
<    * \param type The type of BRP packet.
<    */
<   void SetPacketType (PacketType type);
<   /**
<    * Get BRP Packet Type.
<    * \return The type of BRP packet.
<    */
<   PacketType GetPacketType (void) const;
<   /**
<    * Set the length of the training field.
<    * \param length The length of the training field.
<    */
<   void SetTrainngFieldLength (uint8_t length);
<   /**
<    * Get the length of the training field.
<    * \return The length of te training field.
<    */
<   uint8_t GetTrainngFieldLength (void) const;
<   /**
<    * Set the length of the EDMG training field.
<    * \param length The length of the EDMG training field.
<    */
<   void SetEdmgTrainingFieldLength (uint8_t length);
<   /**
<    * Get the length of the EDMG training field.
<    * \return The length of the EDMGtraining field.
<    */
<   uint8_t GetEdmgTrainingFieldLength (void) const;
<   /**
<    * Request Beam Tracking.
<    */
<   void RequestBeamTracking (void);
<   /**
<    * Disable Beam Tracking Capability.
<    */
<   void DisableBeamTracking (void);
<   /**
<    * \return True if Beam Tracking requested, otherwise false.
<    */
<   bool IsBeamTrackingRequested (void) const;
822,856c639,659
<   uint8_t m_ctrlType;     ///< control type
<   uint8_t m_ctrlSubtype;  ///< control subtype
<   uint8_t m_ctrlToDs;     ///< control to DS
<   uint8_t m_ctrlFromDs;   ///< control from DS
<   uint8_t m_ctrlMoreFrag; ///< control more fragments
<   uint8_t m_ctrlRetry;    ///< control retry
<   uint8_t m_ctrlMoreData; ///< control more data
<   uint8_t m_ctrlWep;      ///< control WEP
<   uint8_t m_ctrlOrder;    ///< control order (set to 1 for QoS Data and Management frames to signify that HT/VHT/HE control field is present, knowing that the latter are not implemented yet)
<   uint16_t m_duration;    ///< duration
<   Mac48Address m_addr1;   ///< address 1
<   Mac48Address m_addr2;   ///< address 2
<   Mac48Address m_addr3;   ///< address 3
<   uint8_t m_seqFrag;      ///< sequence fragment
<   uint16_t m_seqSeq;      ///< sequence sequence
<   Mac48Address m_addr4;   ///< address 4
<   uint8_t m_qosTid;       ///< QoS TID
<   uint8_t m_qosEosp;      ///< QoS EOSP
<   uint8_t m_qosAckPolicy; ///< QoS Ack policy
<   uint8_t m_amsduPresent; ///< A-MSDU present
<   uint8_t m_qosStuff;     ///< QoS stuff
< 
<   /* DMG QoS Control Field */
<   bool m_dmgPpdu;
<   uint8_t m_qosAmsduType;
<   uint8_t m_qosRdg;
<   uint8_t m_qosAcConstraint;
<   /* New fields for DMG Support. */
<   uint32_t m_ctrlFrameExtension;
<   bool m_beamRefinementRequired;
<   bool m_beamTrackingRequired;
<   PacketType m_brpPacketType;
<   uint8_t m_trainingFieldLength;
<   /* New fields for EDMG support */
<   uint8_t m_edmgTrainingFieldLength;
---
>   uint8_t m_ctrlType;
>   uint8_t m_ctrlSubtype;
>   uint8_t m_ctrlToDs;
>   uint8_t m_ctrlFromDs;
>   uint8_t m_ctrlMoreFrag;
>   uint8_t m_ctrlRetry;
>   uint8_t m_ctrlMoreData;
>   uint8_t m_ctrlWep;
>   uint8_t m_ctrlOrder;
>   uint16_t m_duration;
>   Mac48Address m_addr1;
>   Mac48Address m_addr2;
>   Mac48Address m_addr3;
>   uint8_t m_seqFrag;
>   uint16_t m_seqSeq;
>   Mac48Address m_addr4;
>   uint8_t m_qosTid;
>   uint8_t m_qosEosp;
>   uint8_t m_qosAckPolicy;
>   uint8_t m_amsduPresent;
>   uint16_t m_qosStuff;
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-queue.cc ../../ns-3-dev/src/wifi/model/wifi-mac-queue.cc
21d20
<  *          Stefano Avallone <stavallo@unina.it>
24a24,26
> #include "ns3/packet.h"
> #include "ns3/uinteger.h"
> #include "ns3/enum.h"
28,36d29
< #include "ns3/ipv4-header.h"
< #include "ns3/llc-snap-header.h"
< 
< #include <iostream>
< #include <fstream>
< 
< using namespace ns3;
< using namespace std;
< 
39,40d31
< NS_LOG_COMPONENT_DEFINE ("WifiMacQueue");
< 
42c33,41
< NS_OBJECT_TEMPLATE_CLASS_DEFINE (Queue, WifiMacQueueItem);
---
> 
> WifiMacQueue::Item::Item (Ptr<const Packet> packet,
>                           const WifiMacHeader &hdr,
>                           Time tstamp)
>   : packet (packet),
>     hdr (hdr),
>     tstamp (tstamp)
> {
> }
48c47
<     .SetParent<Queue<WifiMacQueueItem> > ()
---
>     .SetParent<Object> ()
51,56c50,53
<     .AddAttribute ("MaxSize",
<                    "The max queue size",
<                    QueueSizeValue (QueueSize ("500p")),
<                    MakeQueueSizeAccessor (&QueueBase::SetMaxSize,
<                                           &QueueBase::GetMaxSize),
<                    MakeQueueSizeChecker ())
---
>     .AddAttribute ("MaxPacketNumber", "If a packet arrives when there are already this number of packets, it is dropped.",
>                    UintegerValue (400),
>                    MakeUintegerAccessor (&WifiMacQueue::m_maxSize),
>                    MakeUintegerChecker<uint32_t> ())
58,59c55,56
<                    TimeValue (MilliSeconds (500)),
<                    MakeTimeAccessor (&WifiMacQueue::SetMaxDelay),
---
>                    TimeValue (MilliSeconds (500.0)),
>                    MakeTimeAccessor (&WifiMacQueue::m_maxDelay),
66,68d62
<     .AddTraceSource ("Expired", "MPDU dropped because its lifetime expired.",
<                      MakeTraceSourceAccessor (&WifiMacQueue::m_traceExpired),
<                      "ns3::WifiMacQueueItem::TracedCallback")
74,75c68
<   : m_expiredPacketsPresent (false),
<     NS_LOG_TEMPLATE_DEFINE ("WifiMacQueue")
---
>   : m_size (0)
81c74
<   NS_LOG_FUNCTION_NOARGS ();
---
>   Flush ();
84,87d76
< static std::list<Ptr<WifiMacQueueItem>> g_emptyWifiMacQueue;
< 
< const WifiMacQueue::ConstIterator WifiMacQueue::EMPTY = g_emptyWifiMacQueue.end ();
< 
89c78
< WifiMacQueue::SetMaxDelay (Time delay)
---
> WifiMacQueue::SetMaxSize (uint32_t maxSize)
91,92c80
<   NS_LOG_FUNCTION (this << delay);
<   m_maxDelay = delay;
---
>   m_maxSize = maxSize;
95,102c83,84
< Time
< WifiMacQueue::GetMaxDelay (void) const
< {
<   return m_maxDelay;
< }
< 
< bool
< WifiMacQueue::TtlExceeded (ConstIterator &it)
---
> void
> WifiMacQueue::SetMaxDelay (Time delay)
104,128c86
<   NS_LOG_FUNCTION (this);
< 
<   if (Simulator::Now () > (*it)->GetTimeStamp () + m_maxDelay)
<     {
<       NS_LOG_DEBUG ("Removing packet that stayed in the queue for too long (" <<
<                     Simulator::Now () - (*it)->GetTimeStamp () << ")");
<       m_traceExpired (*it);
<       // Ptr<Packet> copy = (*it)->GetPacket()->Copy();
<       // if (copy->GetSize() == 1480)
<       // {
<       //   LlcSnapHeader llc;
<       //   Ipv4Header iHD;
<       //   copy->RemoveHeader(llc);
<       //   copy->PeekHeader (iHD);
<       //   copy->AddHeader(llc);
<       //   uint8_t pri = iHD.GetPri();
<         // std::cout << int(pri) <<" queue packet drop by time\n";
< 
<       // }
<       auto curr = it++;
<       // std::cout << copy->GetSize() <<" queue packet drop by time\n";
<       DoRemove (curr);
<       return true;
<     }
<   return false;
---
>   m_maxDelay = delay;
131,132c89,90
< bool
< WifiMacQueue::Enqueue (Ptr<WifiMacQueueItem> item)
---
> uint32_t
> WifiMacQueue::GetMaxSize (void) const
134,135c92
<   NS_LOG_FUNCTION (this << *item);
<   return Insert (end (), item);
---
>   return m_maxSize;
138,139c95,96
< bool
< WifiMacQueue::PushFront (Ptr<WifiMacQueueItem> item)
---
> Time
> WifiMacQueue::GetMaxDelay (void) const
141,143c98
<   NS_LOG_FUNCTION (this << *item);
< 
<   return Insert (begin (), item);
---
>   return m_maxDelay;
147,177c102
< WifiMacQueue::LabelExceeded (uint32_t IncomingLabel,ConstIterator &it2)
< {
<   NS_LOG_FUNCTION (this);
<   //Remove all the packet in queue which size = 1480 and Label is smaller than IncomingLabel.
<       Ptr<Packet> copy = (*it2)->GetPacket()->Copy();
< 
<       if (copy->GetSize() == 1480)
<       {   
<         LlcSnapHeader llc;
<         Ipv4Header iHD;
<         copy->RemoveHeader(llc);
<         copy->PeekHeader (iHD);
<         copy->AddHeader(llc);
<         uint32_t FindingLabel = iHD.GetEncodedLabel();
< 
<         if (FindingLabel < IncomingLabel-10)
<         {
<           auto curr = it2++;
<           DoRemove (curr);
<           std::cout <<"Incoming " << IncomingLabel << ",Remove " << FindingLabel << "\n";
<         }
<       }
< }
< 
< 
< 
< double NowLable = 0;
< 
<  
< bool
< WifiMacQueue::Insert (ConstIterator pos, Ptr<WifiMacQueueItem> item)
---
> WifiMacQueue::Enqueue (Ptr<const Packet> packet, const WifiMacHeader &hdr)
179,245c104,105
<   NS_LOG_FUNCTION (this << *item);
<   NS_ASSERT_MSG (GetMaxSize ().GetUnit () == QueueSizeUnit::PACKETS,
<                  "WifiMacQueues must be in packet mode");
< 
< 
<   // insert the item if the queue is not full
<   // if (QueueBase::GetNPackets () < GetMaxSize ().GetValue ())
<   if (QueueBase::GetNPackets () < GetMaxSize ().GetValue ())
<     {
<       Ptr<Packet> copy = item->GetPacket()->Copy ();
<       if (item->GetPacket()->GetSize () == 1480)
<       {
<         LlcSnapHeader llc;
<         Ipv4Header iHD;
<         copy->RemoveHeader(llc);
<         copy->PeekHeader (iHD);
<         copy->AddHeader(llc);
<         // uint32_t m_RecvIncomingLabel = iHD.GetEncodedLabel();
<         // uint8_t pri = iHD.GetPri();
< 
<         // if (pri%2 ==1 )
<         // {
<           // std::cout << "1\n";
<           // ofstream fout;
<           // fout.open( "2_AP1_queue.txt" ,ios::app);
<           // fout << Simulator::Now ().GetSeconds () <<  " "  << QueueBase::GetNPackets () << "\n";
<           // fout.close();
<         // } 
<         // else if (pri%2 == 0)
<         // {
<           // std::cout << "AP222222222222222222222\n";
<             // ofstream fout;
<             // fout.open( "2_AP2_queue.txt" ,ios::app);
<             // fout << Simulator::Now ().GetSeconds () <<  " "  << QueueBase::GetNPackets () << "\n";
<             // fout.close();
<         // }
<         // uint8_t EncodeNumber = iHD.GetEncodedPacketNumber();
<         // std::cout << "m_RecvIncomingLabel =" << m_RecvIncomingLabel << "\n"; // I have the new label
< 
<         // if (m_RecvIncomingLabel > NowLable)
<         // {
<         //   NowLable = m_RecvIncomingLabel;
<         //   // ConstIterator it2 = begin ();
<         //   // while (it2 != end ())
<         //   // {
<         //   //   LabelExceeded(m_RecvIncomingLabel,it2);
<         //   //   it2++;
<         //   // }
<         //   return DoEnqueue (pos, item);
<         // }
<         // else //if (m_RecvIncomingLabel == NowLable)
<         // {
<         //   return DoEnqueue (pos, item);
<         // }
<         // return DoEnqueue (pos, item);
<       }
<       return DoEnqueue (pos, item);
<       // else
<       // {
<       //   return DoEnqueue (pos, item);
<       // }
<     }
<     // std::cout << QueueBase::GetNPackets () << "\n";
<   // the queue is full; scan the list in the attempt to remove stale packets
<   ConstIterator it = begin ();
< 
<   while (it != end ())
---
>   Cleanup ();
>   if (m_size == m_maxSize)
247c107
<       if (it == pos && TtlExceeded (it))
---
>       if (m_dropPolicy == DROP_NEWEST)
249c109
<           return DoEnqueue (it, item);
---
>           return;
251c111
<       if (TtlExceeded (it))
---
>       else if (m_dropPolicy == DROP_OLDEST)
253c113,114
<           return DoEnqueue (pos, item);
---
>           m_queue.pop_front ();
>           m_size--;
255,262d115
<       it++;
<     }
< 
<   // the queue is still full, remove the oldest item if the policy is drop oldest
<    if (m_dropPolicy == DROP_OLDEST)
<     {
<       NS_LOG_DEBUG ("Remove the oldest item in the queue");
<       DoRemove (begin ());
264,265c117,119
<     return DoEnqueue (pos, item);
<       // return 0;
---
>   Time now = Simulator::Now ();
>   m_queue.push_back (Item (packet, hdr, now));
>   m_size++;
268,284c122,123
< Ptr<WifiMacQueueItem>
< WifiMacQueue::Dequeue (void)
< {
<   NS_LOG_FUNCTION (this);
<   for (ConstIterator it = begin (); it != end (); )
<     {
<       if (!TtlExceeded (it))
<         {
<           return DoDequeue (it);
<         }
<     }
<   NS_LOG_DEBUG ("The queue is empty");
<   return 0;
< }
< 
< Ptr<WifiMacQueueItem>
< WifiMacQueue::DequeueByAddress (Mac48Address dest)
---
> void
> WifiMacQueue::Cleanup (void)
286,289c125
<   NS_LOG_FUNCTION (this << dest);
<   ConstIterator it = PeekByAddress (dest);
< 
<   if (it == end ())
---
>   if (m_queue.empty ())
291c127
<       return 0;
---
>       return;
293,300d128
<   return Dequeue (it);
< }
< 
< Ptr<WifiMacQueueItem>
< WifiMacQueue::DequeueByTid (uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << +tid);
<   ConstIterator it = PeekByTid (tid);
302c130,132
<   if (it == end ())
---
>   Time now = Simulator::Now ();
>   uint32_t n = 0;
>   for (PacketQueueI i = m_queue.begin (); i != m_queue.end (); )
304c134,142
<       return 0;
---
>       if (i->tstamp + m_maxDelay > now)
>         {
>           i++;
>         }
>       else
>         {
>           i = m_queue.erase (i);
>           n++;
>         }
306c144
<   return Dequeue (it);
---
>   m_size -= n;
309,310c147,148
< Ptr<WifiMacQueueItem>
< WifiMacQueue::DequeueByTidAndAddress (uint8_t tid, Mac48Address dest)
---
> Ptr<const Packet>
> WifiMacQueue::Dequeue (WifiMacHeader *hdr)
312,315c150,151
<   NS_LOG_FUNCTION (this << +tid << dest);
<   ConstIterator it = PeekByTidAndAddress (tid, dest);
< 
<   if (it == end ())
---
>   Cleanup ();
>   if (!m_queue.empty ())
317c153,157
<       return 0;
---
>       Item i = m_queue.front ();
>       m_queue.pop_front ();
>       m_size--;
>       *hdr = i.hdr;
>       return i.packet;
319c159
<   return Dequeue (it);
---
>   return 0;
322,323c162,163
< Ptr<WifiMacQueueItem>
< WifiMacQueue::DequeueFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets)
---
> Ptr<const Packet>
> WifiMacQueue::Peek (WifiMacHeader *hdr)
325,328c165,166
<   NS_LOG_FUNCTION (this);
<   ConstIterator it = PeekFirstAvailable (blockedPackets);
< 
<   if (it == end ())
---
>   Cleanup ();
>   if (!m_queue.empty ())
330c168,170
<       return 0;
---
>       Item i = m_queue.front ();
>       *hdr = i.hdr;
>       return i.packet;
332c172
<   return Dequeue (it);
---
>   return 0;
335,340c175,181
< Ptr<WifiMacQueueItem>
< WifiMacQueue::Dequeue (ConstIterator pos)
< {
<   NS_LOG_FUNCTION (this);
< 
<   if (!m_expiredPacketsPresent)
---
> Ptr<const Packet>
> WifiMacQueue::DequeueByTidAndAddress (WifiMacHeader *hdr, uint8_t tid,
>                                       WifiMacHeader::AddressType type, Mac48Address dest)
> {
>   Cleanup ();
>   Ptr<const Packet> packet = 0;
>   if (!m_queue.empty ())
342c183,184
<       if (TtlExceeded (pos))
---
>       PacketQueueI it;
>       for (it = m_queue.begin (); it != m_queue.end (); ++it)
344,359c186
<           NS_LOG_DEBUG ("Packet lifetime expired");
<           return 0;
<         }
<       return DoDequeue (pos);
<     }
< 
<   // remove stale items queued before the given position
<   ConstIterator it = begin ();
<   while (it != end ())
<     {
<       if (it == pos)
<         {
<           // reset the flag signaling the presence of expired packets before returning
<           m_expiredPacketsPresent = false;
< 
<           if (TtlExceeded (it))
---
>           if (it->hdr.IsQosData ())
361c188,196
<               return 0;
---
>               if (GetAddressForPacket (type, it) == dest
>                   && it->hdr.GetQosTid () == tid)
>                 {
>                   packet = it->packet;
>                   *hdr = it->hdr;
>                   m_queue.erase (it);
>                   m_size--;
>                   break;
>                 }
363,367d197
<           return DoDequeue (it);
<         }
<       else if (!TtlExceeded (it))
<         {
<           it++;
370,371c200
<   NS_LOG_DEBUG ("Invalid iterator");
<   return 0;
---
>   return packet;
374,375c203,205
< Ptr<const WifiMacQueueItem>
< WifiMacQueue::Peek (void) const
---
> Ptr<const Packet>
> WifiMacQueue::PeekByTidAndAddress (WifiMacHeader *hdr, uint8_t tid,
>                                    WifiMacHeader::AddressType type, Mac48Address dest, Time *timestamp)
377,378c207,208
<   NS_LOG_FUNCTION (this);
<   for (auto it = begin (); it != end (); it++)
---
>   Cleanup ();
>   if (!m_queue.empty ())
380,382c210,211
<       // skip packets that stayed in the queue for too long. They will be
<       // actually removed from the queue by the next call to a non-const method
<       if (Simulator::Now () <= (*it)->GetTimeStamp () + m_maxDelay)
---
>       PacketQueueI it;
>       for (it = m_queue.begin (); it != m_queue.end (); ++it)
384c213,222
<           return DoPeek (it);
---
>           if (it->hdr.IsQosData ())
>             {
>               if (GetAddressForPacket (type, it) == dest
>                   && it->hdr.GetQosTid () == tid)
>                 {
>                   *hdr = it->hdr;
>                   *timestamp = it->tstamp;
>                   return it->packet;
>                 }
>             }
386,387d223
<       // signal the presence of expired packets
<       m_expiredPacketsPresent = true;
389d224
<   NS_LOG_DEBUG ("The queue is empty");
393,394c228,229
< WifiMacQueue::ConstIterator
< WifiMacQueue::PeekByAddress (Mac48Address dest, ConstIterator pos) const
---
> bool
> WifiMacQueue::IsEmpty (void)
396,418c231,232
<   NS_LOG_FUNCTION (this << dest);
<   ConstIterator it = (pos != EMPTY ? pos : begin ());
<   while (it != end ())
<     {
<       // skip packets that stayed in the queue for too long. They will be
<       // actually removed from the queue by the next call to a non-const method
<       if (Simulator::Now () <= (*it)->GetTimeStamp () + m_maxDelay)
<         {
<           if (((*it)->GetHeader ().IsData () || (*it)->GetHeader ().IsQosData ())
<               && (*it)->GetDestinationAddress () == dest)
<             {
<               return it;
<             }
<         }
<       else
<         {
<           // signal the presence of expired packets
<           m_expiredPacketsPresent = true;
<         }
<       it++;
<     }
<   NS_LOG_DEBUG ("The queue is empty");
<   return end ();
---
>   Cleanup ();
>   return m_queue.empty ();
421,422c235,236
< WifiMacQueue::ConstIterator
< WifiMacQueue::PeekByTid (uint8_t tid, ConstIterator pos) const
---
> uint32_t
> WifiMacQueue::GetSize (void)
424,445c238,239
<   NS_LOG_FUNCTION (this << +tid);
<   ConstIterator it = (pos != EMPTY ? pos : begin ());
<   while (it != end ())
<     {
<       // skip packets that stayed in the queue for too long. They will be
<       // actually removed from the queue by the next call to a non-const method
<       if (Simulator::Now () <= (*it)->GetTimeStamp () + m_maxDelay)
<         {
<           if ((*it)->GetHeader ().IsQosData () && (*it)->GetHeader ().GetQosTid () == tid)
<             {
<               return it;
<             }
<         }
<       else
<         {
<           // signal the presence of expired packets
<           m_expiredPacketsPresent = true;
<         }
<       it++;
<     }
<   NS_LOG_DEBUG ("The queue is empty");
<   return end ();
---
>   Cleanup ();
>   return m_size;
448,449c242,243
< WifiMacQueue::ConstIterator
< WifiMacQueue::PeekByTidAndAddress (uint8_t tid, Mac48Address dest, ConstIterator pos) const
---
> void
> WifiMacQueue::Flush (void)
451,473c245,246
<   NS_LOG_FUNCTION (this << +tid << dest);
<   ConstIterator it = (pos != EMPTY ? pos : begin ());
<   while (it != end ())
<     {
<       // skip packets that stayed in the queue for too long. They will be
<       // actually removed from the queue by the next call to a non-const method
<       if (Simulator::Now () <= (*it)->GetTimeStamp () + m_maxDelay)
<         {
<           if ((*it)->GetHeader ().IsQosData () && (*it)->GetDestinationAddress () == dest
<               && (*it)->GetHeader ().GetQosTid () == tid)
<             {
<               return it;
<             }
<         }
<       else
<         {
<           // signal the presence of expired packets
<           m_expiredPacketsPresent = true;
<         }
<       it++;
<     }
<   NS_LOG_DEBUG ("The queue is empty");
<   return end ();
---
>   m_queue.erase (m_queue.begin (), m_queue.end ());
>   m_size = 0;
476,477c249,250
< WifiMacQueue::ConstIterator
< WifiMacQueue::PeekFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets, ConstIterator pos) const
---
> Mac48Address
> WifiMacQueue::GetAddressForPacket (enum WifiMacHeader::AddressType type, PacketQueueI it)
479,481c252
<   NS_LOG_FUNCTION (this);
<   ConstIterator it = (pos != EMPTY ? pos : begin ());
<   while (it != end ())
---
>   if (type == WifiMacHeader::ADDR1)
483,498c254
<       // skip packets that stayed in the queue for too long. They will be
<       // actually removed from the queue by the next call to a non-const method
<       if (Simulator::Now () <= (*it)->GetTimeStamp () + m_maxDelay)
<         {
<           if (!(*it)->GetHeader ().IsQosData () || !blockedPackets
<               || !blockedPackets->IsBlocked ((*it)->GetHeader ().GetAddr1 (), (*it)->GetHeader ().GetQosTid ()))
<             {
<               return it;
<             }
<         }
<       else
<         {
<           // signal the presence of expired packets
<           m_expiredPacketsPresent = true;
<         }
<       it++;
---
>       return it->hdr.GetAddr1 ();
500,509c256
<   NS_LOG_DEBUG ("The queue is empty");
<   return end ();
< }
< 
< Ptr<WifiMacQueueItem>
< WifiMacQueue::Remove (void)
< {
<   NS_LOG_FUNCTION (this);
< 
<   for (ConstIterator it = begin (); it != end (); )
---
>   if (type == WifiMacHeader::ADDR2)
511,514c258,262
<       if (!TtlExceeded (it))
<         {
<           return DoRemove (it);
<         }
---
>       return it->hdr.GetAddr2 ();
>     }
>   if (type == WifiMacHeader::ADDR3)
>     {
>       return it->hdr.GetAddr3 ();
516d263
<   NS_LOG_DEBUG ("The queue is empty");
523,524c270,271
<   NS_LOG_FUNCTION (this << packet);
<   for (ConstIterator it = begin (); it != end (); )
---
>   PacketQueueI it = m_queue.begin ();
>   for (; it != m_queue.end (); it++)
526c273
<       if (!TtlExceeded (it))
---
>       if (it->packet == packet)
528,534c275,277
<           if ((*it)->GetPacket () == packet)
<             {
<               DoRemove (it);
<               return true;
<             }
< 
<           it++;
---
>           m_queue.erase (it);
>           m_size--;
>           return true;
537d279
<   NS_LOG_DEBUG ("Packet " << packet << " not found in the queue");
541,576c283,284
< WifiMacQueue::ConstIterator
< WifiMacQueue::Remove (ConstIterator pos, bool removeExpired)
< {
<   NS_LOG_FUNCTION (this);
< 
<   if (!removeExpired)
<     {
<       ConstIterator curr = pos++;
<       DoRemove (curr);
<       return pos;
<     }
< 
<   // remove stale items queued before the given position
<   ConstIterator it = begin ();
<   while (it != end ())
<     {
<       if (it == pos)
<         {
<           // reset the flag signaling the presence of expired packets before returning
<           m_expiredPacketsPresent = false;
< 
<           ConstIterator curr = pos++;
<           DoRemove (curr);
<           return pos;
<         }
<       else if (!TtlExceeded (it))
<         {
<           it++;
<         }
<     }
<   NS_LOG_DEBUG ("Invalid iterator");
<   return end ();
< }
< 
< uint32_t
< WifiMacQueue::GetNPacketsByAddress (Mac48Address dest)
---
> void
> WifiMacQueue::PushFront (Ptr<const Packet> packet, const WifiMacHeader &hdr)
578,582c286,287
<   NS_LOG_FUNCTION (this << dest);
< 
<   uint32_t nPackets = 0;
< 
<   for (ConstIterator it = begin (); it != end (); )
---
>   Cleanup ();
>   if (m_size == m_maxSize)
584,592c289
<       if (!TtlExceeded (it))
<         {
<           if ((*it)->GetHeader ().IsData () && (*it)->GetDestinationAddress () == dest)
<             {
<               nPackets++;
<             }
< 
<           it++;
<         }
---
>       return;
594,595c291,293
<   NS_LOG_DEBUG ("returns " << nPackets);
<   return nPackets;
---
>   Time now = Simulator::Now ();
>   m_queue.push_front (Item (packet, hdr, now));
>   m_size++;
599c297,298
< WifiMacQueue::GetNPacketsByTidAndAddress (uint8_t tid, Mac48Address dest)
---
> WifiMacQueue::GetNPacketsByTidAndAddress (uint8_t tid, WifiMacHeader::AddressType type,
>                                           Mac48Address addr)
601c300
<   NS_LOG_FUNCTION (this << dest);
---
>   Cleanup ();
603c302
<   for (ConstIterator it = begin (); it != end (); )
---
>   if (!m_queue.empty ())
605c304,305
<       if (!TtlExceeded (it))
---
>       PacketQueueI it;
>       for (it = m_queue.begin (); it != m_queue.end (); it++)
607,608c307
<           if ((*it)->GetHeader ().IsQosData () && (*it)->GetDestinationAddress () == dest
<               && (*it)->GetHeader ().GetQosTid () == tid)
---
>           if (GetAddressForPacket (type, it) == addr)
610c309,312
<               nPackets++;
---
>               if (it->hdr.IsQosData () && it->hdr.GetQosTid () == tid)
>                 {
>                   nPackets++;
>                 }
612,613d313
< 
<           it++;
616d315
<   NS_LOG_DEBUG ("returns " << nPackets);
620,720c319,321
< //uint32_t
< //WifiMacQueue::GetNPacketsByTidAndAddress (uint8_t tid, WifiMacHeader::AddressType type,
< //                                          Mac48Address addr)
< //{
< //  NS_LOG_FUNCTION (this << addr);
< 
< //  uint32_t nPackets = 0;
< 
< //  for (ConstIterator it = begin (); it != end (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          if ((*it)->GetHeader ().IsQosData () && (*it)->GetAddress (type) == addr
< //              && (*it)->GetHeader ().GetQosTid () == tid)
< //            {
< //              nPackets++;
< //            }
< 
< //          it++;
< //        }
< //    }
< //  NS_LOG_DEBUG ("returns " << nPackets);
< //  return nPackets;
< //}
< 
< //void
< //WifiMacQueue::TransferPacketsByAddress (Mac48Address addr, Ptr<WifiMacQueue> destQueue)
< //{
< //  for (auto it = Head (); it != Tail (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          if (((*it)->GetHeader ().IsData ()) && ((*it)->GetHeader ().GetAddr1 () == addr))
< //            {
< //              /* Copy the item to the new Queue */
< //              Ptr<WifiMacQueueItem> item = Create<WifiMacQueueItem> ((*it)->GetPacket (), (*it)->GetHeader ());
< //              destQueue->Enqueue (item);
< //              it = m_packets.erase (it);
< //              m_nBytes -= item->GetSize ();
< //              m_nPackets--;
< //            }
< //          else
< //            {
< //              it++;
< //            }
< //        }
< //    }
< //}
< 
< //void
< //WifiMacQueue::QuickTransfer (Ptr<WifiMacQueue> destQueue)
< //{
< //  for (auto it = Head (); it != Tail (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          /* Copy the item to the new Queue */
< //          Ptr<WifiMacQueueItem> item = Create<WifiMacQueueItem> ((*it)->GetPacket (), (*it)->GetHeader ());
< //          destQueue->Enqueue (item);
< //          it = m_packets.erase (it);
< //          m_nBytes -= item->GetSize ();
< //          m_nPackets--;
< //        }
< //    }
< //}
< 
< //bool
< //WifiMacQueue::HasPacketsForReceiver (Mac48Address addr)
< //{
< //  for (auto it = Head (); it != Tail (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          if ((*it)->GetHeader ().GetAddr1 () == addr)
< //            {
< //              return true;
< //            }
< //          it++;
< //        }
< //    }
< //  return false;
< //}
< 
< //void
< //WifiMacQueue::ChangePacketsReceiverAddress (Mac48Address OriginalAddress, Mac48Address newAddress)
< //{
< //  for (auto it = Head (); it != Tail (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          if (((*it)->GetHeader ().IsData ()) && ((*it)->GetHeader ().GetAddr1 () == OriginalAddress))
< //            {
< //              (*it)->SetAddress (WifiMacHeader::ADDR1, newAddress);
< //            }
< //          it++;
< //        }
< //    }
< //}
< 
< bool
< WifiMacQueue::IsEmpty (void)
---
> Ptr<const Packet>
> WifiMacQueue::DequeueFirstAvailable (WifiMacHeader *hdr, Time &timestamp,
>                                      const QosBlockedDestinations *blockedPackets)
722,723c323,325
<   NS_LOG_FUNCTION (this);
<   for (ConstIterator it = begin (); it != end (); )
---
>   Cleanup ();
>   Ptr<const Packet> packet = 0;
>   for (PacketQueueI it = m_queue.begin (); it != m_queue.end (); it++)
725c327,328
<       if (!TtlExceeded (it))
---
>       if (!it->hdr.IsQosData ()
>           || !blockedPackets->IsBlocked (it->hdr.GetAddr1 (), it->hdr.GetQosTid ()))
727,728c330,335
<           NS_LOG_DEBUG ("returns false");
<           return false;
---
>           *hdr = it->hdr;
>           timestamp = it->tstamp;
>           packet = it->packet;
>           m_queue.erase (it);
>           m_size--;
>           return packet;
731,732c338
<   NS_LOG_DEBUG ("returns true");
<   return true;
---
>   return packet;
735,751c341,343
< uint32_t
< WifiMacQueue::GetNPackets (void)
< {
<   NS_LOG_FUNCTION (this);
<   // remove packets that stayed in the queue for too long
<   for (ConstIterator it = begin (); it != end (); )
<     {
<       if (!TtlExceeded (it))
<         {
<           it++;
<         }
<     }
<   return QueueBase::GetNPackets ();
< }
< 
< uint32_t
< WifiMacQueue::GetNBytes (void)
---
> Ptr<const Packet>
> WifiMacQueue::PeekFirstAvailable (WifiMacHeader *hdr, Time &timestamp,
>                                   const QosBlockedDestinations *blockedPackets)
753,755c345,346
<   NS_LOG_FUNCTION (this);
<   // remove packets that stayed in the queue for too long
<   for (ConstIterator it = begin (); it != end (); )
---
>   Cleanup ();
>   for (PacketQueueI it = m_queue.begin (); it != m_queue.end (); it++)
757c348,349
<       if (!TtlExceeded (it))
---
>       if (!it->hdr.IsQosData ()
>           || !blockedPackets->IsBlocked (it->hdr.GetAddr1 (), it->hdr.GetQosTid ()))
759c351,353
<           it++;
---
>           *hdr = it->hdr;
>           timestamp = it->tstamp;
>           return it->packet;
762c356
<   return QueueBase::GetNBytes ();
---
>   return 0;
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-queue.h ../../ns-3-dev/src/wifi/model/wifi-mac-queue.h
21d20
<  *          Stefano Avallone <stavallo@unina.it>
27,28c26,31
< #include "wifi-mac-queue-item.h"
< #include "ns3/queue.h"
---
> #include <list>
> #include <utility>
> #include "ns3/packet.h"
> #include "ns3/nstime.h"
> #include "ns3/object.h"
> #include "wifi-mac-header.h"
31d33
< 
34,41d35
< // The following explicit template instantiation declaration prevents modules
< // including this header file from implicitly instantiating Queue<WifiMacQueueItem>.
< // This would cause python examples using wifi to crash at runtime with the
< // following error message: "Trying to allocate twice the same UID:
< // ns3::Queue<WifiMacQueueItem>"
< extern template class Queue<WifiMacQueueItem>;
< 
< 
57c51
< class WifiMacQueue : public Queue<WifiMacQueueItem>
---
> class WifiMacQueue : public Object
60,63d53
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
68d57
<   /// drop policy
75,80c64,69
<   /// allow the usage of iterators and const iterators
<   using Queue<WifiMacQueueItem>::ConstIterator;
<   using Queue<WifiMacQueueItem>::Iterator;
<   using Queue<WifiMacQueueItem>::begin;
<   using Queue<WifiMacQueueItem>::end;
< 
---
>   /**
>    * Set the maximum queue size.
>    *
>    * \param maxSize the maximum queue size
>    */
>   void SetMaxSize (uint32_t maxSize);
87a77,82
>    * Return the maximum queue size.
>    *
>    * \return the maximum queue size
>    */
>   uint32_t GetMaxSize (void) const;
>   /**
95c90
<    * Enqueue the given Wifi MAC queue item at the <i>end</i> of the queue.
---
>    * Enqueue the given packet and its corresponding WifiMacHeader at the <i>end</i> of the queue.
97,98c92,93
<    * \param item the Wifi MAC queue item to be enqueued at the end
<    * \return true if success, false if the packet has been dropped
---
>    * \param packet the packet to be euqueued at the end
>    * \param hdr the header of the given packet
100c95
<   bool Enqueue (Ptr<WifiMacQueueItem> item);
---
>   void Enqueue (Ptr<const Packet> packet, const WifiMacHeader &hdr);
102c97
<    * Enqueue the given Wifi MAC queue item at the <i>front</i> of the queue.
---
>    * Enqueue the given packet and its corresponding WifiMacHeader at the <i>front</i> of the queue.
104,105c99,100
<    * \param item the Wifi MAC queue item to be enqueued at the front
<    * \return true if success, false if the packet has been dropped
---
>    * \param packet the packet to be euqueued at the end
>    * \param hdr the header of the given packet
107,115c102
<   bool PushFront (Ptr<WifiMacQueueItem> item);
<   /**
<    * Enqueue the given Wifi MAC queue item before the given position.
<    *
<    * \param pos the position before which the item is to be inserted
<    * \param item the Wifi MAC queue item to be enqueued
<    * \return true if success, false if the packet has been dropped
<    */
<   bool Insert (ConstIterator pos, Ptr<WifiMacQueueItem> item);
---
>   void PushFront (Ptr<const Packet> packet, const WifiMacHeader &hdr);
119,128c106
<    * \return the packet
<    */
<   Ptr<WifiMacQueueItem> Dequeue (void);
<   /**
<    * Search and return, if present in the queue, the first packet (either Data
<    * frame or QoS Data frame) having the receiver address equal to <i>addr</i>.
<    * This method removes the packet from the queue.
<    * It is typically used by ns3::Txop during the CF period.
<    *
<    * \param dest the given destination
---
>    * \param hdr the WifiMacHeader of the packet
132c110
<   Ptr<WifiMacQueueItem> DequeueByAddress (Mac48Address dest);
---
>   Ptr<const Packet> Dequeue (WifiMacHeader *hdr);
134,136c112
<    * Search and return, if present in the queue, the first packet having the
<    * TID equal to <i>tid</i>.
<    * This method removes the packet from the queue.
---
>    * Peek the packet in the front of the queue. The packet is not removed.
138c114
<    * \param tid the given TID
---
>    * \param hdr the WifiMacHeader of the packet
142c118
<   Ptr<WifiMacQueueItem> DequeueByTid (uint8_t tid);
---
>   Ptr<const Packet> Peek (WifiMacHeader *hdr);
144,147c120,123
<    * Search and return, if present in the queue, the first packet having the
<    * address indicated by <i>type</i> equal to <i>addr</i>, and TID
<    * equal to <i>tid</i>. This method removes the packet from the queue.
<    * It is typically used by ns3::QosTxop in order to perform correct MSDU
---
>    * Searchs and returns, if is present in this queue, first packet having
>    * address indicated by <i>type</i> equals to <i>addr</i>, and tid
>    * equals to <i>tid</i>. This method removes the packet from this queue.
>    * Is typically used by ns3::EdcaTxopN in order to perform correct MSDU
149a126
>    * \param hdr the header of the dequeued packet
151c128,129
<    * \param dest the given destination
---
>    * \param type the given address type
>    * \param addr the given destination
153c131
<    * \return the packet
---
>    * \return packet
155,179c133,142
<   Ptr<WifiMacQueueItem> DequeueByTidAndAddress (uint8_t tid,
<                                                 Mac48Address dest);
<   /**
<    * Return first available packet for transmission. A packet could be no available
<    * if it is a QoS packet with a TID and an address1 fields equal to <i>tid</i> and <i>addr</i>
<    * respectively that index a pending agreement in the BlockAckManager object.
<    * So that packet must not be transmitted until reception of an ADDBA response frame from station
<    * addressed by <i>addr</i>. This method removes the packet from queue.
<    *
<    * \param blockedPackets the destination address & TID pairs that are waiting for a BlockAck response
<    *
<    * \return the packet
<    */
<   Ptr<WifiMacQueueItem> DequeueFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets = nullptr);
<   /**
<    * Dequeue the item at position <i>pos</i> in the queue. Return a null
<    * pointer if the given iterator is invalid, the queue is empty or the
<    * lifetime of the item pointed to by the given iterator is expired.
<    *
<    * \param pos the position of the item to be dequeued
<    * \return the dequeued item, if any
<    */
<   Ptr<WifiMacQueueItem> Dequeue (WifiMacQueue::ConstIterator pos);
<   /**
<    * Peek the packet in the front of the queue. The packet is not removed.
---
>   Ptr<const Packet> DequeueByTidAndAddress (WifiMacHeader *hdr,
>                                             uint8_t tid,
>                                             WifiMacHeader::AddressType type,
>                                             Mac48Address addr);
>   /**
>    * Searchs and returns, if is present in this queue, first packet having
>    * address indicated by <i>type</i> equals to <i>addr</i>, and tid
>    * equals to <i>tid</i>. This method doesn't remove the packet from this queue.
>    * Is typically used by ns3::EdcaTxopN in order to perform correct MSDU
>    * aggregation (A-MSDU).
181,183c144,156
<    * \return the packet
<    */
<   Ptr<const WifiMacQueueItem> Peek (void) const;
---
>    * \param hdr the header of the dequeued packet
>    * \param tid the given TID
>    * \param type the given address type
>    * \param addr the given destination
>    * \param timestamp
>    *
>    * \return packet
>    */
>   Ptr<const Packet> PeekByTidAndAddress (WifiMacHeader *hdr,
>                                          uint8_t tid,
>                                          WifiMacHeader::AddressType type,
>                                          Mac48Address addr,
>                                          Time *timestamp);
185,189c158,160
<    * Search and return, if present in the queue, the first packet (either Data
<    * frame or QoS Data frame) having the receiver address equal to <i>addr</i>.
<    * If <i>pos</i> is a valid iterator, the search starts from the packet pointed
<    * to by the given iterator.
<    * This method does not remove the packet from the queue.
---
>    * If exists, removes <i>packet</i> from queue and returns true. Otherwise it
>    * takes no effects and return false. Deletion of the packet is
>    * performed in linear time (O(n)).
191,192c162
<    * \param dest the given destination
<    * \param pos the iterator pointing to the packet the search starts from
---
>    * \param packet the packet to be removed
194c164
<    * \return an iterator pointing to the peeked packet
---
>    * \return true if the packet was removed, false otherwise
196c166
<   ConstIterator PeekByAddress (Mac48Address dest, ConstIterator pos = EMPTY) const;
---
>   bool Remove (Ptr<const Packet> packet);
198,201c168,169
<    * Search and return, if present in the queue, the first packet having the
<    * TID equal to <i>tid</i>. If <i>pos</i> is a valid iterator, the search starts
<    * from the packet pointed to by the given iterator.
<    * This method does not remove the packet from the queue.
---
>    * Returns number of QoS packets having tid equals to <i>tid</i> and address
>    * specified by <i>type</i> equals to <i>addr</i>.
204c172,173
<    * \param pos the iterator pointing to the packet the search starts from
---
>    * \param type the given address type
>    * \param addr the given destination
206c175
<    * \return an iterator pointing to the peeked packet
---
>    * \return the number of QoS packets
208c177,179
<   ConstIterator PeekByTid (uint8_t tid, ConstIterator pos = EMPTY) const;
---
>   uint32_t GetNPacketsByTidAndAddress (uint8_t tid,
>                                        WifiMacHeader::AddressType type,
>                                        Mac48Address addr);
210,215c181,185
<    * Search and return, if present in the queue, the first packet having the
<    * receiver address equal to <i>dest</i>, and TID equal to <i>tid</i>.
<    * If <i>pos</i> is a valid iterator, the search starts from the packet pointed
<    * to by the given iterator. This method does not remove the packet from the queue.
<    * It is typically used by ns3::QosTxop in order to perform correct MSDU aggregation
<    * (A-MSDU).
---
>    * Returns first available packet for transmission. A packet could be no available
>    * if it's a QoS packet with a tid and an address1 fields equal to <i>tid</i> and <i>addr</i>
>    * respectively that index a pending agreement in the BlockAckManager object.
>    * So that packet must not be transmitted until reception of an ADDBA response frame from station
>    * addressed by <i>addr</i>. This method removes the packet from queue.
217,219c187,189
<    * \param tid the given TID
<    * \param dest the given destination
<    * \param pos the iterator pointing to the packet the search starts from
---
>    * \param hdr the header of the dequeued packet
>    * \param tStamp
>    * \param blockedPackets
221c191
<    * \return an iterator pointing to the peeked packet
---
>    * \return packet
223c193,195
<   ConstIterator PeekByTidAndAddress (uint8_t tid, Mac48Address dest, ConstIterator pos = EMPTY) const;
---
>   Ptr<const Packet> DequeueFirstAvailable (WifiMacHeader *hdr,
>                                            Time &tStamp,
>                                            const QosBlockedDestinations *blockedPackets);
225c197
<    * Return first available packet for transmission. The packet is not removed from queue.
---
>    * Returns first available packet for transmission. The packet isn't removed from queue.
227,228c199,201
<    * \param blockedPackets the destination address & TID pairs that are waiting for a BlockAck response
<    * \param pos the iterator pointing to the packet the search starts from
---
>    * \param hdr the header of the dequeued packet
>    * \param tStamp
>    * \param blockedPackets
230c203
<    * \return an iterator pointing to the peeked packet
---
>    * \return packet
232,233c205,207
<   ConstIterator PeekFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets = nullptr,
<                                     ConstIterator pos = EMPTY) const;
---
>   Ptr<const Packet> PeekFirstAvailable (WifiMacHeader *hdr,
>                                         Time &tStamp,
>                                         const QosBlockedDestinations *blockedPackets);
235,237c209
<    * Remove the packet in the front of the queue.
<    *
<    * \return the packet
---
>    * Flush the queue.
239c211,212
<   Ptr<WifiMacQueueItem> Remove (void);
---
>   void Flush (void);
> 
241,245c214
<    * If exists, removes <i>packet</i> from queue and returns true. Otherwise it
<    * takes no effects and return false. Deletion of the packet is
<    * performed in linear time (O(n)).
<    *
<    * \param packet the packet to be removed
---
>    * Return if the queue is empty.
247c216
<    * \return true if the packet was removed, false otherwise
---
>    * \return true if the queue is empty, false otherwise
249c218
<   bool Remove (Ptr<const Packet> packet);
---
>   bool IsEmpty (void);
251,254c220
<    * Remove the item at position <i>pos</i> in the queue and return an iterator
<    * pointing to the item following the removed one. If <i>removeExpired</i> is
<    * true, all the items in the queue from the head to the given position are
<    * removed if their lifetime expired.
---
>    * Return the current queue size.
256,258c222
<    * \param pos the position of the item to be removed
<    * \param removeExpired true to remove expired items
<    * \return an iterator pointing to the item following the removed one
---
>    * \return the current queue size
260c224,227
<   ConstIterator Remove (ConstIterator pos, bool removeExpired = false);
---
>   uint32_t GetSize (void);
> 
> 
> protected:
262,267c229
<    * Return the number of packets having destination address specified by
<    * <i>dest</i>.
<    *
<    * \param dest the given destination
<    *
<    * \return the number of packets
---
>    * Clean up the queue by removing packets that exceeded the maximum delay.
269c231,232
<   uint32_t GetNPacketsByAddress (Mac48Address dest);
---
>   virtual void Cleanup (void);
> 
271,277c234,235
<    * Return the number of QoS packets having TID equal to <i>tid</i> and
<    * destination address equal to <i>dest</i>.
<    *
<    * \param tid the given TID
<    * \param dest the given destination
<    *
<    * \return the number of QoS packets
---
>    * A struct that holds information about a packet for putting
>    * in a packet queue.
279c237,252
<   uint32_t GetNPacketsByTidAndAddress (uint8_t tid, Mac48Address dest);
---
>   struct Item
>   {
>     /**
>      * Create a struct with the given parameters.
>      *
>      * \param packet
>      * \param hdr
>      * \param tstamp
>      */
>     Item (Ptr<const Packet> packet,
>           const WifiMacHeader &hdr,
>           Time tstamp);
>     Ptr<const Packet> packet; //!< Actual packet
>     WifiMacHeader hdr;        //!< Wifi MAC header associated with the packet
>     Time tstamp;              //!< timestamp when the packet arrived at the queue
>   };
282,284c255
<    * \return true if the queue is empty; false otherwise
<    *
<    * Overrides the IsEmpty method provided by QueueBase
---
>    * typedef for packet (struct Item) queue.
286,287c257
<   bool IsEmpty (void);
< 
---
>   typedef std::list<struct Item> PacketQueue;
289,291c259
<    * \return The number of packets currently stored in the Queue
<    *
<    * Overrides the GetNPackets method provided by QueueBase
---
>    * typedef for packet (struct Item) queue reverse iterator.
293,294c261
<   uint32_t GetNPackets (void);
< 
---
>   typedef std::list<struct Item>::reverse_iterator PacketQueueRI;
296,298c263
<    * \return The number of bytes currently occupied by the packets in the Queue
<    *
<    * Overrides the GetNBytes method provided by QueueBase
---
>    * typedef for packet (struct Item) queue iterator.
300,305c265
<   uint32_t GetNBytes (void);
< 
<   static const ConstIterator EMPTY;         //!< Invalid iterator to signal an empty queue
< 
< 
< private:
---
>   typedef std::list<struct Item>::iterator PacketQueueI;
307,309c267,270
<    * Remove the item pointed to by the iterator <i>it</i> if it has been in the
<    * queue for too long. If the item is removed, the iterator is updated to
<    * point to the item that followed the erased one.
---
>    * Return the appropriate address for the given packet (given by PacketQueue iterator).
>    *
>    * \param type
>    * \param it
311,312c272
<    * \param it an iterator pointing to the item
<    * \return true if the item is removed, false otherwise
---
>    * \return the address
314,322c274
<   bool TtlExceeded (ConstIterator &it);
<   void LabelExceeded (uint32_t IncomingLabel,ConstIterator &it);
< 
<   Time m_maxDelay;                          //!< Time to live for packets in the queue
<   DropPolicy m_dropPolicy;                  //!< Drop behavior of queue
<   mutable bool m_expiredPacketsPresent;     //!< True if expired packets are in the queue
< 
<   /// Traced callback: fired when a packet is dropped due to lifetime expiration
<   TracedCallback<Ptr<const WifiMacQueueItem> > m_traceExpired;
---
>   Mac48Address GetAddressForPacket (enum WifiMacHeader::AddressType type, PacketQueueI it);
324c276,280
<   NS_LOG_TEMPLATE_DECLARE;                  //!< redefinition of the log component
---
>   PacketQueue m_queue; //!< Packet (struct Item) queue
>   uint32_t m_size;     //!< Current queue size
>   uint32_t m_maxSize;  //!< Queue capacity
>   Time m_maxDelay;     //!< Time to live for packets in the queue
>   enum DropPolicy m_dropPolicy; //!< Drop behavior of queue
Only in ../../NS3-WiGig/src/wifi/model: wifi-mac-queue-item.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-mac-queue-item.h
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-trailer.cc ../../ns-3-dev/src/wifi/model/wifi-mac-trailer.cc
21a22
> #include "ns3/assert.h"
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-trailer.h ../../ns-3-dev/src/wifi/model/wifi-mac-trailer.h
24a25
> #include <stdint.h>
42c43
<   virtual ~WifiMacTrailer ();
---
>   ~WifiMacTrailer ();
44,47d44
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
49,53c46,50
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
---
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual void Print (std::ostream &os) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (Buffer::Iterator start) const;
>   virtual uint32_t Deserialize (Buffer::Iterator start);
diff ../../NS3-WiGig/src/wifi/model/wifi-mode.cc ../../ns-3-dev/src/wifi/model/wifi-mode.cc
22,23d21
< #include <cmath>
< #include "ns3/log.h"
25a24,27
> #include "ns3/simulator.h"
> #include "ns3/assert.h"
> #include "ns3/log.h"
> #include <cmath>
28a31,39
> /**
>  * Check if the two WifiModes are identical.
>  *
>  * \param a WifiMode
>  * \param b WifiMode
>  *
>  * \return true if the two WifiModes are identical,
>  *         false otherwise
>  */
33,38c44,51
< 
< bool operator < (const WifiMode &a, const WifiMode &b)
< {
<   return a.GetUid () < b.GetUid ();
< }
< 
---
> /**
>  * Serialize WifiMode to ostream (human-readable).
>  *
>  * \param os std::ostream
>  * \param mode
>  *
>  * \return std::ostream
>  */
44c57,64
< 
---
> /**
>  * Serialize WifiMode from istream (human-readable).
>  *
>  * \param is std::istream
>  * \param mode
>  *
>  * \return std::istream
>  */
53,70d72
< bool
< WifiMode::IsAllowed (uint16_t channelWidth, uint8_t nss) const
< {
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   if (item->modClass == WIFI_MOD_CLASS_VHT)
<     {
<       if (item->mcsValue == 9 && channelWidth == 20 && nss != 3)
<         {
<           return false;
<         }
<       if (item->mcsValue == 6 && channelWidth == 80 && nss == 3)
<         {
<           return false;
<         }
<     }
<   return true;
< }
< 
72c74
< WifiMode::GetPhyRate (uint16_t channelWidth, uint16_t guardInterval, uint8_t nss) const
---
> WifiMode::GetPhyRate (uint32_t channelWidth, bool isShortGuardInterval, uint8_t nss) const
76,77c78,79
<   uint64_t dataRate, phyRate;
<   dataRate = GetDataRate (channelWidth, guardInterval, nss);
---
>   uint32_t dataRate, phyRate;
>   dataRate = GetDataRate (channelWidth, isShortGuardInterval, nss);
80,103d81
<     case WIFI_CODE_RATE_7_8:
<       phyRate = dataRate * 8 / 7;
<       break;
<     case WIFI_CODE_RATE_5_8:
<       phyRate = dataRate * 8 / 5;
<       break;
<     case WIFI_CODE_RATE_13_16:
<       phyRate = dataRate * 16 / 13;
<       break;
<     case WIFI_CODE_RATE_1_4:
<       phyRate = dataRate * 4;
<       break;
<     case WIFI_CODE_RATE_13_28:
<       phyRate = dataRate * 28 / 13;
<       break;
<     case WIFI_CODE_RATE_13_21:
<       phyRate = dataRate * 21 / 13;
<       break;
<     case WIFI_CODE_RATE_52_63:
<       phyRate = dataRate * 63 / 52;
<       break;
<     case WIFI_CODE_RATE_13_14:
<       phyRate = dataRate * 14 / 13;
<       break;
127,146c105
<   return GetPhyRate (txVector.GetChannelWidth (), txVector.GetGuardInterval (), txVector.GetNss ());
< }
< 
< uint64_t
< WifiMode::GetDataRate (uint16_t channelWidth) const
< {
<   return GetDataRate (channelWidth, 800, 1);
< }
< 
< uint64_t
< WifiMode::GetDataRate (WifiTxVector txVector) const
< {
<   return GetDataRate (txVector.GetChannelWidth (), txVector.GetGuardInterval (), txVector.GetNss ());
< }
< 
< uint64_t
< WifiMode::GetDmgDataRate (void) const
< {
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   return item->dataRate;
---
>   return GetPhyRate (txVector.GetChannelWidth (), txVector.IsShortGuardInterval (), txVector.GetNss ());
150c109
< WifiMode::GetDataRate (uint16_t channelWidth, uint16_t guardInterval, uint8_t nss) const
---
> WifiMode::GetDataRate (uint32_t channelWidth, bool isShortGuardInterval, uint8_t nss) const
154c113
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
---
>   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
156c115
<   uint16_t usableSubCarriers = 0;
---
>   uint32_t usableSubCarriers = 0;
159c118
<   uint16_t numberOfBitsPerSubcarrier = static_cast<uint16_t> (log2 (GetConstellationSize ()));
---
>   uint32_t numberOfBitsPerSubcarrier = log2 (GetConstellationSize ());
206c165
<       if (item->modClass == WIFI_MOD_CLASS_VHT)
---
>       if (item->modClass == WIFI_MOD_CLASS_VHT && item->mcsValue == 9 && nss != 3)
208c167
<           NS_ASSERT_MSG (IsAllowed (channelWidth, nss), "VHT MCS " << +item->mcsValue << " forbidden at " << channelWidth << " MHz when NSS is " << +nss);
---
>           NS_ASSERT_MSG (channelWidth != 20, "VHT MCS 9 forbidden at 20 MHz (only allowed when NSS = 3)");
210,214c169
< 
<       NS_ASSERT (guardInterval == 800 || guardInterval == 400);
<       symbolRate = (1 / (3.2 + (static_cast<double> (guardInterval) / 1000))) * 1e6;
< 
<       if (item->modClass == WIFI_MOD_CLASS_HT)
---
>       if (item->modClass == WIFI_MOD_CLASS_VHT && item->mcsValue == 6 && nss == 3)
216,227c171
<           switch (channelWidth)
<             {
<             case 20:
<             default:
<               usableSubCarriers = 52;
<               break;
<             case 40:
<             case 80:
<             case 160:
<               usableSubCarriers = 108;
<               break;
<             }
---
>           NS_ASSERT_MSG (channelWidth != 80, "VHT MCS 6 forbidden at 80 MHz when NSS = 3");
229c173,174
<       else //WIFI_MOD_CLASS_VHT
---
> 
>       if (!isShortGuardInterval)
231,246c176
<           switch (channelWidth)
<             {
<             case 20:
<             default:
<               usableSubCarriers = 52;
<               break;
<             case 40:
<               usableSubCarriers = 108;
<               break;
<             case 80:
<               usableSubCarriers = 234;
<               break;
<             case 160:
<               usableSubCarriers = 468;
<               break;
<             }
---
>           symbolRate = (1 / 4.0) * 1e6;
248,249c178
< 
<       switch (GetCodeRate ())
---
>       else
251,266c180
<         case WIFI_CODE_RATE_5_6:
<           codingRate = (5.0 / 6.0);
<           break;
<         case WIFI_CODE_RATE_3_4:
<           codingRate = (3.0 / 4.0);
<           break;
<         case WIFI_CODE_RATE_2_3:
<           codingRate = (2.0 / 3.0);
<           break;
<         case WIFI_CODE_RATE_1_2:
<           codingRate = (1.0 / 2.0);
<           break;
<         case WIFI_CODE_RATE_UNDEFINED:
<         default:
<           NS_FATAL_ERROR ("trying to get datarate for a mcs without any coding rate defined with nss: " << +nss);
<           break;
---
>           symbolRate = (1 / 3.6) * 1e6;
269,275d182
<       dataRate = lrint (ceil (symbolRate * usableSubCarriers * numberOfBitsPerSubcarrier * codingRate));
<     }
<   else if (item->modClass == WIFI_MOD_CLASS_HE)
<     {
<       NS_ASSERT (guardInterval == 800 || guardInterval == 1600 || guardInterval == 3200);
<       symbolRate = (1 / (12.8 + (static_cast<double> (guardInterval) / 1000))) * 1e6;
< 
280c187
<           usableSubCarriers = 234;
---
>           usableSubCarriers = 52;
283c190
<           usableSubCarriers = 468;
---
>           usableSubCarriers = 108;
286c193
<           usableSubCarriers = 980;
---
>           usableSubCarriers = 234;
289c196
<           usableSubCarriers = 1960;
---
>           usableSubCarriers = 468;
309c216
<           NS_FATAL_ERROR ("trying to get datarate for a mcs without any coding rate defined with nss: " << +nss);
---
>           NS_FATAL_ERROR ("trying to get datarate for a mcs without any coding rate defined with nss: " << (uint16_t) nss);
315,324d221
<   else if ((item->modClass == WIFI_MOD_CLASS_DMG_CTRL) ||
<            (item->modClass == WIFI_MOD_CLASS_DMG_SC) ||
<            (item->modClass == WIFI_MOD_CLASS_DMG_OFDM) ||
<            (item->modClass == WIFI_MOD_CLASS_DMG_LP_SC) ||
<            (item->modClass == WIFI_MOD_CLASS_EDMG_CTRL) ||
<            (item->modClass == WIFI_MOD_CLASS_EDMG_SC) ||
<            (item->modClass == WIFI_MOD_CLASS_EDMG_OFDM) )
<     {
<       return item->dataRate;
<     }
333c230,236
< WifiCodeRate
---
> uint64_t
> WifiMode::GetDataRate (WifiTxVector txVector) const
> {
>   return GetDataRate (txVector.GetChannelWidth (), txVector.IsShortGuardInterval (), txVector.GetNss ());
> }
> 
> enum WifiCodeRate
336c239
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
---
>   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
379,402d281
<   else if (item->modClass == WIFI_MOD_CLASS_HE)
<     {
<       switch (item->mcsValue)
<         {
<         case 0:
<         case 1:
<         case 3:
<           return WIFI_CODE_RATE_1_2;
<         case 2:
<         case 4:
<         case 6:
<         case 8:
<         case 10:
<           return WIFI_CODE_RATE_3_4;
<         case 5:
<           return WIFI_CODE_RATE_2_3;
<         case 7:
<         case 9:
<         case 11:
<           return WIFI_CODE_RATE_5_6;
<         default:
<           return WIFI_CODE_RATE_UNDEFINED;
<         }
<     }
412c291
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
---
>   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
433c312
<   else if (item->modClass == WIFI_MOD_CLASS_VHT || item->modClass == WIFI_MOD_CLASS_HE)
---
>   else if (item->modClass == WIFI_MOD_CLASS_VHT)
452,455d330
<         case 10:
<         case 11:
<           NS_ASSERT (item->modClass != WIFI_MOD_CLASS_VHT);
<           return 1024;
470c345
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
---
>   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
477c352
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
---
>   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
484,489c359,360
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   if (item->modClass == WIFI_MOD_CLASS_HT || item->modClass == WIFI_MOD_CLASS_VHT || item->modClass == WIFI_MOD_CLASS_HE
<       || item->modClass == WIFI_MOD_CLASS_DMG_CTRL || item->modClass == WIFI_MOD_CLASS_DMG_SC
<       || item->modClass == WIFI_MOD_CLASS_DMG_OFDM || item->modClass == WIFI_MOD_CLASS_DMG_LP_SC
<       || item->modClass == WIFI_MOD_CLASS_EDMG_CTRL || item->modClass == WIFI_MOD_CLASS_EDMG_SC
<       || item->modClass == WIFI_MOD_CLASS_EDMG_OFDM)
---
>   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
>   if (item->modClass == WIFI_MOD_CLASS_HT || item->modClass == WIFI_MOD_CLASS_VHT)
501,521d371
< uint64_t
< WifiMode::GetBandwidth (void) const
< {
<   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   return item->bandwidth;
< }
< 
< uint64_t
< WifiMode::GetPhyRate (void) const
< {
<   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   return item->phyRate;
< }
< 
< uint64_t
< WifiMode::GetDataRate (void) const
< {
<   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   return item->dataRate;
< }
< 
528c378
< WifiModulationClass
---
> enum WifiModulationClass
531c381
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
---
>   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
539,540c389,390
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   if (item->modClass >= WIFI_MOD_CLASS_HT)
---
>   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
>   if (item->modClass == WIFI_MOD_CLASS_HT || item->modClass == WIFI_MOD_CLASS_VHT)
542,543c392,393
<       WifiCodeRate codeRate = GetCodeRate ();
<       switch (GetConstellationSize ())
---
>       WifiCodeRate codeRate = GetCodeRate();
>       switch(GetConstellationSize())
547,549c397
<             {
<               dataRate = 6000000;
<             }
---
>             dataRate = 6000000;
551,553c399
<             {
<               dataRate = 9000000;
<             }
---
>             dataRate = 9000000;
555,557c401
<             {
<               NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
<             }
---
>             NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
561,563c405
<             {
<               dataRate = 12000000;
<             }
---
>             dataRate = 12000000;
565,567c407
<             {
<               dataRate = 18000000;
<             }
---
>             dataRate = 18000000;
569,571c409
<             {
<               NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
<             }
---
>             NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
575,577c413
<             {
<               dataRate = 24000000;
<             }
---
>             dataRate = 24000000;
579,581c415
<             {
<               dataRate = 36000000;
<             }
---
>             dataRate = 36000000;
583,585c417
<             {
<               NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
<             }
---
>             NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
589,591c421
<             {
<               dataRate = 48000000;
<             }
---
>             dataRate = 48000000;
593,595c423
<             {
<               dataRate = 54000000;
<             }
---
>             dataRate = 54000000;
597,599c425
<             {
<               NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
<             }
---
>             NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
602d427
<         case 1024:
604,606c429
<             {
<               dataRate = 54000000;
<             }
---
>             dataRate = 54000000;
608,610c431
<             {
<               NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
<             }
---
>             NS_FATAL_ERROR ("Trying to get reference rate for a MCS with wrong combination of coding rate and modulation");
613c434
<           NS_FATAL_ERROR ("Wrong constellation size");
---
>             NS_FATAL_ERROR ("Wrong constellation size");
646,647c467,468
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   switch (item->modClass)
---
>   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
>   switch(item->modClass)
671d491
<     case WIFI_MOD_CLASS_HE:
724c544
<                                  WifiModulationClass modClass,
---
>                                  enum WifiModulationClass modClass,
726c546
<                                  WifiCodeRate codingRate,
---
>                                  enum WifiCodeRate codingRate,
753,754c573,574
<   NS_ASSERT (modClass < WIFI_MOD_CLASS_HT);
<   //fill unused MCS item with a dummy value
---
>   NS_ASSERT (modClass != WIFI_MOD_CLASS_HT && modClass != WIFI_MOD_CLASS_VHT);
>   //fill unused mcs item with a dummy value
761,832d580
< WifiModeFactory::CreateWifiMode (std::string uniqueName,
<                                  uint8_t mcsValue,
<                                  WifiModulationClass modClass,
<                                  bool isMandatory,
<                                  uint64_t bandwidth,
<                                  uint64_t dataRate,
<                                  WifiCodeRate codingRate,
<                                  uint16_t constellationSize)
< {
<   WifiModeFactory *factory = GetFactory ();
<   uint32_t uid = factory->AllocateUid (uniqueName);
<   WifiModeItem *item = factory->Get (uid);
<   item->uniqueUid = uniqueName;
<   item->mcsValue = mcsValue;
<   item->modClass = modClass;
<   //The modulation class for this WifiMode must be valid.
<   NS_ASSERT (modClass != WIFI_MOD_CLASS_UNKNOWN);
<   item->bandwidth = bandwidth;
<   item->dataRate = dataRate;
<   item->codingRate = codingRate;
< 
<   switch (codingRate)
<     {
<     case WIFI_CODE_RATE_5_6:
<       item->phyRate = dataRate * 6 / 5;
<       break;
<     case WIFI_CODE_RATE_3_4:
<       item->phyRate = dataRate * 4 / 3;
<       break;
<     case WIFI_CODE_RATE_2_3:
<       item->phyRate = dataRate * 3 / 2;
<       break;
<     case WIFI_CODE_RATE_1_2:
<       item->phyRate = dataRate * 2 / 1;
<       break;
<     case WIFI_CODE_RATE_5_8:
<       item->phyRate = dataRate * 8 / 5;
<       break;
<     case WIFI_CODE_RATE_13_16:
<       item->phyRate = dataRate * 16 / 13;
<       break;
<     case WIFI_CODE_RATE_1_4:
<       item->phyRate = dataRate * 4 / 1;
<       break;
<     case WIFI_CODE_RATE_7_8:
<       item->phyRate = dataRate * 8 / 7;
<       break;
<     case WIFI_CODE_RATE_UNDEFINED:
<     default:
<       NS_ABORT_MSG ("Non-supported coding rate");
<       break;
<     }
< 
<   //Check for compatibility between modulation class and coding
<   //rate. If modulation class is DSSS then coding rate must be
<   //undefined, and vice versa. I could have done this with an
<   //assertion, but it seems better to always give the error (i.e.,
<   //not only in non-optimised builds) and the cycles that extra test
<   //here costs are only suffered at simulation setup.
<   if ((codingRate == WIFI_CODE_RATE_UNDEFINED) != (modClass == WIFI_MOD_CLASS_DSSS))
<     {
<       NS_FATAL_ERROR ("Error in creation of WifiMode named " << uniqueName << std::endl
<                                                              << "Code rate must be WIFI_CODE_RATE_UNDEFINED iff Modulation Class is WIFI_MOD_CLASS_DSSS");
<     }
< 
<   item->constellationSize = constellationSize;
<   item->isMandatory = isMandatory;
< 
<   return WifiMode (uid);
< }
< 
< WifiMode
835c583
<                                 WifiModulationClass modClass)
---
>                                 enum WifiModulationClass modClass)
843c591,592
<   NS_ASSERT (modClass >= WIFI_MOD_CLASS_HT);
---
>   //The modulation class must be either HT or VHT
>   NS_ASSERT (modClass == WIFI_MOD_CLASS_HT || modClass == WIFI_MOD_CLASS_VHT);
855c604
< WifiModeFactory::Search (std::string name) const
---
> WifiModeFactory::Search (std::string name)
902c651
<   uint32_t uid = static_cast<uint32_t> (m_itemList.size ());
---
>   uint32_t uid = m_itemList.size ();
907c656
< WifiModeFactory::WifiModeItem *
---
> struct WifiModeFactory::WifiModeItem *
diff ../../NS3-WiGig/src/wifi/model/wifi-mode.h ../../ns-3-dev/src/wifi/model/wifi-mode.h
24a25,26
> #include <stdint.h>
> #include <string>
25a28
> #include <ostream>
26a30
> #include "ns3/wifi-phy-standard.h"
59,72d62
<   /** DMG Control PHY (Clause 21.4) 802.11ad */
<   WIFI_MOD_CLASS_DMG_CTRL,
<   /** DMG OFDM PHY (Clause 21.5) 802.11ad */
<   WIFI_MOD_CLASS_DMG_OFDM,
<   /** DMG SC PHY (Clause 21.6) 802.11ad */
<   WIFI_MOD_CLASS_DMG_SC,
<   /** DMG Low-Power SC PHY (Clause 21.7) 802.11ad */
<   WIFI_MOD_CLASS_DMG_LP_SC,
<   /** DMG Control PHY (Clause 21.4) 802.11ay */
<   WIFI_MOD_CLASS_EDMG_CTRL,
<   /** DMG OFDM PHY (Clause 21.5) 802.11ay */
<   WIFI_MOD_CLASS_EDMG_OFDM,
<   /** DMG SC PHY (Clause 21.6) 802.11ay */
<   WIFI_MOD_CLASS_EDMG_SC,
74,76c64
<   WIFI_MOD_CLASS_VHT,
<   /** HE PHY (Clause 26) */
<   WIFI_MOD_CLASS_HE
---
>   WIFI_MOD_CLASS_VHT
97,113c85
<   WIFI_CODE_RATE_5_6,
<   /** Rate 5/8 */
<   WIFI_CODE_RATE_5_8,
<   /** Rate 13/16 */
<   WIFI_CODE_RATE_13_16,
<   /** Rate 1/4 - really 1/2 rep 2 */
<   WIFI_CODE_RATE_1_4,
<   /** Rate 13/28 */
<   WIFI_CODE_RATE_13_28,
<   /** Rate 13/21 */
<   WIFI_CODE_RATE_13_21,
<   /** Rate 52/63 */
<   WIFI_CODE_RATE_52_63,
<   /** Rate 13/14 */
<   WIFI_CODE_RATE_13_14,
<   /** Rate 7/8 */
<   WIFI_CODE_RATE_7_8,
---
>   WIFI_CODE_RATE_5_6
131d102
<    * \returns true if this <MCS, channel width, NSS> combination is allowed, false otherwise.
134,140c105
<    * \param nss the considered number of streams
<    */
<   bool IsAllowed (uint16_t channelWidth, uint8_t nss) const;
<   /**
<    *
<    * \param channelWidth the considered channel width in MHz
<    * \param guardInterval the considered guard interval duration in nanoseconds
---
>    * \param isShortGuardInterval whether short guard interval is considered or not
143c108
<    * \returns the physical bit rate of this signal in bps.
---
>    * \returns the physical bit rate of this signal.
146c111
<    * data rate is 3.25Mbps, the PHY rate is 6.5Mbps
---
>    * data rate is 3.25Mbps, the phy rate is 6.5Mbps
148c113
<   uint64_t GetPhyRate (uint16_t channelWidth, uint16_t guardInterval, uint8_t nss) const;
---
>   uint64_t GetPhyRate (uint32_t channelWidth, bool isShortGuardInterval, uint8_t nss) const;
152c117
<    * \returns the physical bit rate of this signal in bps.
---
>    * \returns the physical bit rate of this signal.
155c120
<    * data rate is 3.25Mbps, the PHY rate is 6.5Mbps
---
>    * data rate is 3.25Mbps, the phy rate is 6.5Mbps
161c126
<    * \param guardInterval the considered guard interval duration in nanoseconds
---
>    * \param isShortGuardInterval whether short guard interval is considered or not
164c129
<    * \returns the data bit rate of this signal in bps.
---
>    * \returns the data bit rate of this signal.
166c131
<   uint64_t GetDataRate (uint16_t channelWidth, uint16_t guardInterval, uint8_t nss) const;
---
>   uint64_t GetDataRate (uint32_t channelWidth, bool isShortGuardInterval, uint8_t nss) const;
174,185d138
<    * \param channelWidth the considered channel width in MHz
<    *
<    * \returns the data bit rate of this non-HT or non-VHT signal.
<   */
<   uint64_t GetDataRate (uint16_t channelWidth) const;
<   /**
<    *
<    * \returns the data bit rate of this DMG signal.
<    */
<   uint64_t GetDmgDataRate (void) const;
< 
<   /**
188c141
<   WifiCodeRate GetCodeRate (void) const;
---
>   enum WifiCodeRate GetCodeRate (void) const;
208c161
<    * \returns the UID associated to this wireless mode.
---
>    * \returns the uid associated to this wireless mode.
210c163
<    * Each specific wireless mode should have a different UID.
---
>    * Each specific wireless mode should have a different uid.
212c165
<    * should have different UIDs.
---
>    * should have different uids.
220c173
<   WifiModulationClass GetModulationClass () const;
---
>   enum WifiModulationClass GetModulationClass () const;  
231d183
<    * \param mode the WifiMode
237d188
<    * \param mode the WifiMode
258,272d208
<   /**
<    * \returns the number of Hz used by this signal
<    */
<   uint64_t GetBandwidth (void) const;
<   /**
<    * \returns the physical bit rate of this signal.
<    *
<    * If a transmission mode uses 1/2 FEC, and if its
<    * data rate is 3Mbps, the phy rate is 6Mbps
<    */
<   uint64_t GetPhyRate (void) const;
<   /**
<    * \returns the data bit rate of this signal.
<    */
<   uint64_t GetDataRate (void) const;
275d210
<   /// allow WifiModeFactory class access
276a212
>   friend class WifiPhyTag; // access the UID-based constructor
283c219
<   uint32_t m_uid; ///< UID
---
>   uint32_t m_uid;
286,294d221
< /**
<  * Check if the two WifiModes are identical.
<  *
<  * \param a WifiMode
<  * \param b WifiMode
<  *
<  * \return true if the two WifiModes are identical,
<  *         false otherwise
<  */
296,313d222
< /**
<  * Compare two WifiModes
<  *
<  * \param a WifiMode
<  * \param b WifiMode
<  *
<  * \return true if a is less than b,
<  *         false otherwise
<  */
< bool operator < (const WifiMode &a, const WifiMode &b);
< /**
<  * Serialize WifiMode to ostream (human-readable).
<  *
<  * \param os the output stream
<  * \param mode the WifiMode
<  *
<  * \return std::ostream
<  */
315,322d223
< /**
<  * Serialize WifiMode from istream (human-readable).
<  *
<  * \param is the input stream
<  * \param mode the WifiMode
<  *
<  * \return std::istream
<  */
350c251
<    *        must be unique across _all_ instances.
---
>    *        must be unique accross _all_ instances.
362c263
<    * Create a non-HT WifiMode.
---
>    * Create a WifiMode (not used for HT or VHT).
365c266
<                                   WifiModulationClass modClass,
---
>                                   enum WifiModulationClass modClass,
367c268
<                                   WifiCodeRate codingRate,
---
>                                   enum WifiCodeRate codingRate,
372,399d272
<    *        must be unique across _all_ instances.
<    * \param mcsValue the MCS value
<    * \param modClass the class of modulation
<    * \param isMandatory true if this WifiMode is mandatory, false otherwise.
<    * \param bandwidth the bandwidth (Hz) of the signal generated when the
<    *        associated WifiMode is used.
<    * \param dataRate the rate (bits/second) measured at the MAC SAP..
<    * \param codingRate if convolutional coding is used for this rate
<    *        then this parameter specifies the convolutional coding rate
<    *        used. If there is no explicit convolutional coding step (e.g.,
<    *        for DSSS rates) then the caller should set this parameter to
<    *        WIFI_CODE_RATE_UNCODED.
<    * \param constellationSize the order of the constellation used.
<    *
<    * \return WifiMode
<    *
<    * Create a WifiMode.
<    */
<   static WifiMode CreateWifiMode (std::string uniqueName,
<                                   uint8_t mcsValue,
<                                   WifiModulationClass modClass,
<                                   bool isMandatory,
<                                   uint64_t bandwidth,
<                                   uint64_t dataRate,
<                                   WifiCodeRate codingRate,
<                                   uint16_t constellationSize);
<   /**
<    * \param uniqueName the name of the associated WifiMode. This name
410c283
<                                  WifiModulationClass modClass);
---
>                                  enum WifiModulationClass modClass);
414d286
<   /// allow WifiMode class access
433,441c305,310
<     std::string uniqueUid; ///< unique UID
<     uint64_t bandwidth;
<     uint64_t dataRate;
<     uint64_t phyRate;
<     WifiModulationClass modClass; ///< modulation class
<     uint16_t constellationSize; ///< constellation size
<     WifiCodeRate codingRate; ///< coding rate
<     bool isMandatory; ///< flag to indicate whether this mode is mandatory
<     uint8_t mcsValue; ///< MCS value
---
>     std::string uniqueUid;
>     enum WifiModulationClass modClass;
>     uint16_t constellationSize;
>     enum WifiCodeRate codingRate;
>     bool isMandatory;
>     uint8_t mcsValue;
449c318
<    * \return the WifiMode
---
>    * \return WifiMode
451c320
<   WifiMode Search (std::string name) const;
---
>   WifiMode Search (std::string name);
455c324
<    * \param uniqueUid the unique UID
---
>    * \param uniqueUid
457c326
<    * \return the allocated UID index
---
>    * \return uid
461c330
<    * Return a WifiModeItem at the given UID index.
---
>    * Return a WifiModeItem at the given uid index.
463c332
<    * \param uid the UID index
---
>    * \param uid
465c334
<    * \return WifiModeItem at the given UID
---
>    * \return WifiModeItem at the given uid
472,473c341,342
<   typedef std::vector<WifiModeItem> WifiModeItemList;
<   WifiModeItemList m_itemList; ///< item list
---
>   typedef std::vector<struct WifiModeItem> WifiModeItemList;
>   WifiModeItemList m_itemList;
Only in ../../NS3-WiGig/src/wifi/model: wifi-mpdu-type.h
diff ../../NS3-WiGig/src/wifi/model/wifi-net-device.cc ../../ns-3-dev/src/wifi/model/wifi-net-device.cc
20a21,26
> #include "wifi-net-device.h"
> #include "regular-wifi-mac.h"
> #include "wifi-phy.h"
> #include "wifi-remote-station-manager.h"
> #include "wifi-channel.h"
> #include "qos-utils.h"
22c28,30
< #include "ns3/channel.h"
---
> #include "ns3/packet.h"
> #include "ns3/socket.h"
> #include "ns3/uinteger.h"
24d31
< #include "ns3/log.h"
26,43c33,34
< #include "ns3/uinteger.h"
< #include "wifi-net-device.h"
< #include "wifi-phy.h"
< #include "wifi-mac.h"
< #include "ht-configuration.h"
< #include "vht-configuration.h"
< #include "he-configuration.h"
< #include "ns3/ipv4-header.h"
< 
< #include "ns3/srnc.h"
< #include "ns3/srnc-header.h"
< #include "ns3/srnc-tag.h"
< 
< #include <iostream>
< #include <fstream>
< 
< using namespace ns3;
< using namespace std;
---
> #include "ns3/trace-source-accessor.h"
> #include "ns3/log.h"
65,66c56,57
<                    MakePointerAccessor (&WifiNetDevice::GetChannel),
<                    MakePointerChecker<Channel> ())
---
>                    MakePointerAccessor (&WifiNetDevice::DoGetChannel),
>                    MakePointerChecker<WifiChannel> ())
82,96d72
<     .AddAttribute ("HtConfiguration",
<                    "The HtConfiguration object.",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiNetDevice::GetHtConfiguration),
<                    MakePointerChecker<HtConfiguration> ())
<     .AddAttribute ("VhtConfiguration",
<                    "The VhtConfiguration object.",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiNetDevice::GetVhtConfiguration),
<                    MakePointerChecker<VhtConfiguration> ())
<     .AddAttribute ("HeConfiguration",
<                    "The HeConfiguration object.",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiNetDevice::GetHeConfiguration),
<                    MakePointerChecker<HeConfiguration> ())
117,146c93,99
<   if (m_mac)
<     {
<       m_mac->Dispose ();
<       m_mac = 0;
<     }
<   if (m_phy)
<     {
<       m_phy->Dispose ();
<       m_phy = 0;
<     }
<   if (m_stationManager)
<     {
<       m_stationManager->Dispose ();
<       m_stationManager = 0;
<     }
<   if (m_htConfiguration)
<     {
<       m_htConfiguration->Dispose ();
<       m_htConfiguration = 0;
<     }
<   if (m_vhtConfiguration)
<     {
<       m_vhtConfiguration->Dispose ();
<       m_vhtConfiguration = 0;
<     }
<   if (m_heConfiguration)
<     {
<       m_heConfiguration->Dispose ();
<       m_heConfiguration = 0;
<     }
---
>   m_mac->Dispose ();
>   m_phy->Dispose ();
>   m_stationManager->Dispose ();
>   m_mac = 0;
>   m_phy = 0;
>   m_stationManager = 0;
>   m_queueInterface = 0;
153,165c106,108
<   NS_LOG_FUNCTION_NOARGS ();
<   if (m_phy)
<     {
<       m_phy->Initialize ();
<     }
<   if (m_mac)
<     {
<       m_mac->Initialize ();
<     }
<   if (m_stationManager)
<     {
<       m_stationManager->Initialize ();
<     }
---
>   m_phy->Initialize ();
>   m_mac->Initialize ();
>   m_stationManager->Initialize ();
191c134,170
< WifiNetDevice::SetMac (const Ptr<WifiMac> mac)
---
> WifiNetDevice::NotifyNewAggregate (void)
> {
>   NS_LOG_FUNCTION (this);
>   if (m_queueInterface == 0)
>     {
>       Ptr<NetDeviceQueueInterface> ndqi = this->GetObject<NetDeviceQueueInterface> ();
>       //verify that it's a valid netdevice queue interface and that
>       //the netdevice queue interface was not set before
>       if (ndqi != 0)
>         {
>           m_queueInterface = ndqi;
>           if (m_mac == 0)
>             {
>               NS_LOG_WARN ("A mac has not been installed yet, using a single tx queue");
>             }
>           else
>             {
>               Ptr<RegularWifiMac> mac = DynamicCast<RegularWifiMac> (m_mac);
>               if (mac != 0)
>                 {
>                   BooleanValue qosSupported;
>                   mac->GetAttributeFailSafe ("QosSupported", qosSupported);
>                   if (qosSupported.Get ())
>                     {
>                       m_queueInterface->SetTxQueuesN (4);
>                       // register the select queue callback
>                       m_queueInterface->SetSelectQueueCallback (MakeCallback (&WifiNetDevice::SelectQueue, this));
>                     }
>                 }
>             }
>         }
>     }
>   NetDevice::NotifyNewAggregate ();
> }
> 
> void
> WifiNetDevice::SetMac (Ptr<WifiMac> mac)
198c177
< WifiNetDevice::SetPhy (const Ptr<WifiPhy> phy)
---
> WifiNetDevice::SetPhy (Ptr<WifiPhy> phy)
205c184
< WifiNetDevice::SetRemoteStationManager (const Ptr<WifiRemoteStationManager> manager)
---
> WifiNetDevice::SetRemoteStationManager (Ptr<WifiRemoteStationManager> manager)
246a226,231
> Ptr<WifiChannel>
> WifiNetDevice::DoGetChannel (void) const
> {
>   return m_phy->GetChannel ();
> }
> 
337,357d321
<   // Ptr<Node> RxNowNode = GetNode();
< 
<   // Ipv4Header iHD;
<   // packet->PeekHeader (iHD);
<   // uint32_t m_RecvIncomingLabel = iHD.GetEncodedLabel();
<   // uint8_t pri = iHD.GetPri();
<   // std::cout << "pkt size = " << packet->GetSize ()  << "nodeid = " << RxNowNodeID << "\n";
<   // if (RxNowNodeID  == 3)
<   // {
<   //   ofstream fout;
<   //   fout.open( "0_AP1_lable.txt" ,ios::app);
<   //   fout << Simulator::Now ().GetSeconds ()  <<  " "  << m_RecvIncomingLabel+(int(pri)/2)*10000 << "\n";
<   //   fout.close();
<   // }
<   // else if (RxNowNodeID  == 4)
<   // {
<   //   ofstream fout;
<   //   fout.open( "0_AP2_lable.txt" ,ios::app);
<   //   fout << Simulator::Now ().GetSeconds ()  <<  " "  << m_RecvIncomingLabel+(int(pri)/2)*10000 << "\n";
<   //   fout.close();
<   // }
360a325
> 
373c338
< WifiNetDevice::SetNode (const Ptr<Node> node)
---
> WifiNetDevice::SetNode (Ptr<Node> node)
392c357
< WifiNetDevice::ForwardUp (Ptr<const Packet> packet, Mac48Address from, Mac48Address to)
---
> WifiNetDevice::ForwardUp (Ptr<Packet> packet, Mac48Address from, Mac48Address to)
396c361
<   NetDevice::PacketType type;
---
>   enum NetDevice::PacketType type;
414d378
<   Ptr<Packet> copy = packet->Copy ();
418,419c382,383
<       copy->RemoveHeader (llc);
<       m_forwardUp (this, copy, llc.GetType (), from);
---
>       packet->RemoveHeader (llc);
>       m_forwardUp (this, packet, llc.GetType (), from);
423c387
<       copy->RemoveHeader (llc);
---
>       packet->RemoveHeader (llc);
425c389
< 
---
>     
428,429c392,393
<       m_mac->NotifyPromiscRx (copy);
<       m_promiscRx (this, copy, llc.GetType (), from, to, type);
---
>       m_mac->NotifyPromiscRx (packet);
>       m_promiscRx (this, packet, llc.GetType (), from, to, type);
480,481c444,445
< void
< WifiNetDevice::SetHtConfiguration (Ptr<HtConfiguration> htConfiguration)
---
> uint8_t
> WifiNetDevice::SelectQueue (Ptr<QueueItem> item) const
483,484c447
<   m_htConfiguration = htConfiguration;
< }
---
>   NS_LOG_FUNCTION (this << item);
486,490c449
< Ptr<HtConfiguration>
< WifiNetDevice::GetHtConfiguration (void) const
< {
<   return m_htConfiguration;
< }
---
>   NS_ASSERT (m_queueInterface != 0);
492,496c451,454
< void
< WifiNetDevice::SetVhtConfiguration (Ptr<VhtConfiguration> vhtConfiguration)
< {
<   m_vhtConfiguration = vhtConfiguration;
< }
---
>   if (m_queueInterface->GetNTxQueues () == 1)
>     {
>       return 0;
>     }
498,502c456,463
< Ptr<VhtConfiguration>
< WifiNetDevice::GetVhtConfiguration (void) const
< {
<   return m_vhtConfiguration;
< }
---
>   uint8_t dscp, priority = 0;
>   if (item->GetUint8Value (QueueItem::IP_DSFIELD, dscp))
>     {
>       // if the QoS map element is implemented, it should be used here
>       // to set the priority.
>       // User priority is set to the three most significant bits of the DS field
>       priority = dscp >> 5;
>     }
504,508c465,468
< void
< WifiNetDevice::SetHeConfiguration (Ptr<HeConfiguration> heConfiguration)
< {
<   m_heConfiguration = heConfiguration;
< }
---
>   // replace the priority tag
>   SocketPriorityTag priorityTag;
>   priorityTag.SetPriority (priority);
>   item->GetPacket ()->ReplacePacketTag (priorityTag);
510,513c470,473
< Ptr<HeConfiguration>
< WifiNetDevice::GetHeConfiguration (void) const
< {
<   return m_heConfiguration;
---
>   // if the admission control were implemented, here we should check whether
>   // the access category assigned to the packet should be downgraded
> 
>   return QosUtilsMapTidToAc (priority);
diff ../../NS3-WiGig/src/wifi/model/wifi-net-device.h ../../ns-3-dev/src/wifi/model/wifi-net-device.h
24a25
> #include "ns3/packet.h"
25a27,28
> #include "ns3/mac48-address.h"
> #include <string>
29a33
> class WifiChannel;
32,37d35
< class HtConfiguration;
< class VhtConfiguration;
< class HeConfiguration;
< 
< /// This value conforms to the 802.11 specification
< static const uint16_t MAX_MSDU_SIZE = 2304;
50c48
<  * This class holds together ns3::Channel, ns3::WifiPhy,
---
>  * This class holds together ns3::WifiChannel, ns3::WifiPhy,
56,59d53
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
66c60
<    * \param mac the MAC layer to use.
---
>    * \param mac the mac layer to use.
68c62
<   void SetMac (const Ptr<WifiMac> mac);
---
>   void SetMac (Ptr<WifiMac> mac);
70c64
<    * \param phy the PHY layer to use.
---
>    * \param phy the phy layer to use.
72c66
<   void SetPhy (const Ptr<WifiPhy> phy);
---
>   void SetPhy (Ptr<WifiPhy> phy);
76c70
<   void SetRemoteStationManager (const Ptr<WifiRemoteStationManager> manager);
---
>   void SetRemoteStationManager (Ptr<WifiRemoteStationManager> manager);
78c72
<    * \returns the MAC we are currently using.
---
>    * \returns the mac we are currently using.
82c76
<    * \returns the PHY we are currently using.
---
>    * \returns the phy we are currently using.
90,113d83
<   /**
<    * \param htConfiguration pointer to HtConfiguration
<    */
<   void SetHtConfiguration (Ptr<HtConfiguration> htConfiguration);
<   /**
<    * \return pointer to HtConfiguration if it exists
<    */
<   Ptr<HtConfiguration> GetHtConfiguration (void) const;
<   /**
<    * \param vhtConfiguration pointer to VhtConfiguration
<    */
<   void SetVhtConfiguration (Ptr<VhtConfiguration> vhtConfiguration);
<   /**
<    * \return pointer to VhtConfiguration if it exists
<    */
<   Ptr<VhtConfiguration> GetVhtConfiguration (void) const;
<   /**
<    * \param heConfiguration pointer to HeConfiguration
<    */
<   void SetHeConfiguration (Ptr<HeConfiguration> heConfiguration);
<   /**
<    * \return pointer to HeConfiguration if it exists
<    */
<   Ptr<HeConfiguration> GetHeConfiguration (void) const;
116,139c86,111
<   void SetIfIndex (const uint32_t index);
<   uint32_t GetIfIndex (void) const;
<   Ptr<Channel> GetChannel (void) const;
<   void SetAddress (Address address);
<   Address GetAddress (void) const;
<   bool SetMtu (const uint16_t mtu);
<   uint16_t GetMtu (void) const;
<   bool IsLinkUp (void) const;
<   void AddLinkChangeCallback (Callback<void> callback);
<   bool IsBroadcast (void) const;
<   Address GetBroadcast (void) const;
<   bool IsMulticast (void) const;
<   Address GetMulticast (Ipv4Address multicastGroup) const;
<   bool IsPointToPoint (void) const;
<   bool IsBridge (void) const;
<   bool Send (Ptr<Packet> packet, const Address& dest, uint16_t protocolNumber);
<   Ptr<Node> GetNode (void) const;
<   void SetNode (const Ptr<Node> node);
<   bool NeedsArp (void) const;
<   void SetReceiveCallback (NetDevice::ReceiveCallback cb);
<   Address GetMulticast (Ipv6Address addr) const;
<   bool SendFrom (Ptr<Packet> packet, const Address& source, const Address& dest, uint16_t protocolNumber);
<   void SetPromiscReceiveCallback (PromiscReceiveCallback cb);
<   bool SupportsSendFrom (void) const;
---
>   virtual void SetIfIndex (const uint32_t index);
>   virtual uint32_t GetIfIndex (void) const;
>   virtual Ptr<Channel> GetChannel (void) const;
>   virtual void SetAddress (Address address);
>   virtual Address GetAddress (void) const;
>   virtual bool SetMtu (const uint16_t mtu);
>   virtual uint16_t GetMtu (void) const;
>   virtual bool IsLinkUp (void) const;
>   virtual void AddLinkChangeCallback (Callback<void> callback);
>   virtual bool IsBroadcast (void) const;
>   virtual Address GetBroadcast (void) const;
>   virtual bool IsMulticast (void) const;
>   virtual Address GetMulticast (Ipv4Address multicastGroup) const;
>   virtual bool IsPointToPoint (void) const;
>   virtual bool IsBridge (void) const;
>   virtual bool Send (Ptr<Packet> packet, const Address& dest, uint16_t protocolNumber);
>   virtual Ptr<Node> GetNode (void) const;
>   virtual void SetNode (Ptr<Node> node);
>   virtual bool NeedsArp (void) const;
>   virtual void SetReceiveCallback (NetDevice::ReceiveCallback cb);
> 
>   virtual Address GetMulticast (Ipv6Address addr) const;
> 
>   virtual bool SendFrom (Ptr<Packet> packet, const Address& source, const Address& dest, uint16_t protocolNumber);
>   virtual void SetPromiscReceiveCallback (PromiscReceiveCallback cb);
>   virtual bool SupportsSendFrom (void) const;
143,144c115,117
<   void DoDispose (void);
<   void DoInitialize (void);
---
>   virtual void DoDispose (void);
>   virtual void DoInitialize (void);
>   virtual void NotifyNewAggregate (void);
149,151c122,124
<    * \param packet the packet to forward up
<    * \param from the source address
<    * \param to the destination address
---
>    * \param packet
>    * \param from
>    * \param to
153c126
<   void ForwardUp (Ptr<const Packet> packet, Mac48Address from, Mac48Address to);
---
>   void ForwardUp (Ptr<Packet> packet, Mac48Address from, Mac48Address to);
157,172c130,131
<   /**
<    * \brief Copy constructor
<    * \param o object to copy
<    *
<    * Defined and unimplemented to avoid misuse
<    */
<   WifiNetDevice (const WifiNetDevice &o);
< 
<   /**
<    * \brief Assignment operator
<    * \param o object to copy
<    * \returns the copied object
<    *
<    * Defined and unimplemented to avoid misuse
<    */
<   WifiNetDevice &operator = (const WifiNetDevice &o);
---
>   //This value conforms to the 802.11 specification
>   static const uint16_t MAX_MSDU_SIZE = 2304;
183a143,148
>    * Return the WifiChannel this device is connected to.
>    *
>    * \return WifiChannel
>    */
>   Ptr<WifiChannel> DoGetChannel (void) const;
>   /**
189,206c154,212
<   Ptr<Node> m_node; //!< the node
<   Ptr<WifiPhy> m_phy; //!< the phy
<   Ptr<WifiMac> m_mac; //!< the MAC
<   Ptr<WifiRemoteStationManager> m_stationManager; //!< the station manager
<   Ptr<HtConfiguration> m_htConfiguration; //!< the HtConfiguration
<   Ptr<VhtConfiguration> m_vhtConfiguration; //!< the VhtConfiguration
<   Ptr<HeConfiguration> m_heConfiguration; //!< the HeConfiguration
<   NetDevice::ReceiveCallback m_forwardUp; //!< forward up callback
<   NetDevice::PromiscReceiveCallback m_promiscRx; //!< promiscuous receive callback
< 
<   TracedCallback<Ptr<const Packet>, Mac48Address> m_rxLogger; //!< receive trace callback
<   TracedCallback<Ptr<const Packet>, Mac48Address> m_txLogger; //!< transmit trace callback
< 
<   uint32_t m_ifIndex; //!< IF index
<   bool m_linkUp; //!< link up
<   TracedCallback<> m_linkChanges; //!< link change callback
<   mutable uint16_t m_mtu; //!< MTU
<   bool m_configComplete; //!< configuration complete
---
>   /**
>    * \brief Determine the tx queue for a given packet
>    * \param item the packet
>    *
>    * Modelled after the Linux function ieee80211_select_queue (net/mac80211/wme.c).
>    * A SocketPriority tag is attached to the packet (or the existing one is
>    * replaced) to carry the user priority, which is set to the three most
>    * significant bits of the DS field (TOS field in case of IPv4 and Traffic
>    * Class field in case of IPv6). The Access Category corresponding to the
>    * user priority according to the QosUtilsMapTidToAc function is returned.
>    *
>    * The following table shows the mapping for the Diffserv Per Hop Behaviors.
>    *
>    * PHB  | TOS (binary) | UP  | Access Category
>    * -----|--------------|-----|-----------------
>    * EF   |   101110xx   |  5  |     AC_VI
>    * AF11 |   001010xx   |  1  |     AC_BK
>    * AF21 |   010010xx   |  2  |     AC_BK
>    * AF31 |   011010xx   |  3  |     AC_BE
>    * AF41 |   100010xx   |  4  |     AC_VI
>    * AF12 |   001100xx   |  1  |     AC_BK
>    * AF22 |   010100xx   |  2  |     AC_BK
>    * AF32 |   011100xx   |  3  |     AC_BE
>    * AF42 |   100100xx   |  4  |     AC_VI
>    * AF13 |   001110xx   |  1  |     AC_BK
>    * AF23 |   010110xx   |  2  |     AC_BK
>    * AF33 |   011110xx   |  3  |     AC_BE
>    * AF43 |   100110xx   |  4  |     AC_VI
>    * CS0  |   000000xx   |  0  |     AC_BE
>    * CS1  |   001000xx   |  1  |     AC_BK
>    * CS2  |   010000xx   |  2  |     AC_BK
>    * CS3  |   011000xx   |  3  |     AC_BE
>    * CS4  |   100000xx   |  4  |     AC_VI
>    * CS5  |   101000xx   |  5  |     AC_VI
>    * CS6  |   110000xx   |  6  |     AC_VO
>    * CS7  |   111000xx   |  7  |     AC_VO
>    *
>    * This method is called by the traffic control layer before enqueuing a
>    * packet in the queue disc, if a queue disc is installed on the outgoing
>    * device, or passing a packet to the device, otherwise.
>    */
>   uint8_t SelectQueue (Ptr<QueueItem> item) const;
> 
>   Ptr<Node> m_node;
>   Ptr<WifiPhy> m_phy;
>   Ptr<WifiMac> m_mac;
>   Ptr<WifiRemoteStationManager> m_stationManager;
>   Ptr<NetDeviceQueueInterface> m_queueInterface;   //!< NetDevice queue interface
>   NetDevice::ReceiveCallback m_forwardUp;
>   NetDevice::PromiscReceiveCallback m_promiscRx;
> 
>   TracedCallback<Ptr<const Packet>, Mac48Address> m_rxLogger;
>   TracedCallback<Ptr<const Packet>, Mac48Address> m_txLogger;
> 
>   uint32_t m_ifIndex;
>   bool m_linkUp;
>   TracedCallback<> m_linkChanges;
>   mutable uint16_t m_mtu;
>   bool m_configComplete;
diff ../../NS3-WiGig/src/wifi/model/wifi-phy.cc ../../ns-3-dev/src/wifi/model/wifi-phy.cc
21a22,26
> #include "wifi-phy.h"
> #include "wifi-mode.h"
> #include "wifi-channel.h"
> #include "wifi-preamble.h"
> #include "wifi-phy-state-helper.h"
22a28
> #include "ns3/assert.h"
23a30,33
> #include "ns3/boolean.h"
> #include "ns3/double.h"
> #include "ns3/uinteger.h"
> #include "ns3/enum.h"
25,41c35,37
< #include "ns3/mobility-model.h"
< #include "ns3/random-variable-stream.h"
< #include "ns3/error-model.h"
< #include "wifi-phy.h"
< #include "ampdu-tag.h"
< #include "wifi-utils.h"
< #include "frame-capture-model.h"
< #include "preamble-detection-model.h"
< #include "wifi-radio-energy-model.h"
< #include "error-rate-model.h"
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "he-configuration.h"
< #include "mpdu-aggregator.h"
< #include "wifi-psdu.h"
< #include "wifi-ppdu.h"
< #include "dmg-wifi-phy.h"
---
> #include "ns3/trace-source-accessor.h"
> #include "ns3/fatal-error.h"
> #include <cmath>
47a44,51
>  *       This destructor is needed.
>  ****************************************************************/
> 
> WifiPhyListener::~WifiPhyListener ()
> {
> }
> 
> /****************************************************************
57,59c61,63
<  * standard to represent this, as a wildcard.  If you want to limit the
<  * configuration of a particular channel/frequency/width to a particular
<  * standard(s), then you can specify one or more such bindings.
---
>  * standard to represent this, as a wildcard.  If you want to limit the 
>  * configuration of a particular channel/frequency/width to a particular 
>  * standard(s), then you can specify one or more such bindings. 
93c97,98
<   // Now the 5GHz channels; UNSPECIFIED for 802.11a/n/ac/ax channels
---
>   // Now the 5GHz channels; UNSPECIFIED for 802.11a/n channels, but limited
>   // to 802.11ac for the 80/160 MHz channels
120,123d124
<   { std::make_pair (169, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5845, 20) },
<   { std::make_pair (173, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5865, 20) },
<   { std::make_pair (177, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5885, 20) },
<   { std::make_pair (181, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5905, 20) },
127c128
<   { std::make_pair (54, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5270, 40) },
---
>   { std::make_pair (54, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5230, 40) },
132c133
<   { std::make_pair (126, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5630, 40) },
---
>   { std::make_pair (126, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5590, 40) },
137,138d137
<   { std::make_pair (167, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5835, 40) },
<   { std::make_pair (175, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5875, 40) },
140,146c139,144
<   { std::make_pair (42, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5210, 80) },
<   { std::make_pair (58, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5290, 80) },
<   { std::make_pair (106, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5530, 80) },
<   { std::make_pair (122, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5610, 80) },
<   { std::make_pair (138, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5690, 80) },
<   { std::make_pair (155, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5775, 80) },
<   { std::make_pair (171, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5855, 80) },
---
>   { std::make_pair (42, WIFI_PHY_STANDARD_80211ac), std::make_pair (5210, 80) },
>   { std::make_pair (58, WIFI_PHY_STANDARD_80211ac), std::make_pair (5290, 80) },
>   { std::make_pair (106, WIFI_PHY_STANDARD_80211ac), std::make_pair (5530, 80) },
>   { std::make_pair (122, WIFI_PHY_STANDARD_80211ac), std::make_pair (5610, 80) },
>   { std::make_pair (138, WIFI_PHY_STANDARD_80211ac), std::make_pair (5690, 80) },
>   { std::make_pair (155, WIFI_PHY_STANDARD_80211ac), std::make_pair (5775, 80) },
148,150c146,147
<   { std::make_pair (50, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5250, 160) },
<   { std::make_pair (114, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5570, 160) },
<   { std::make_pair (163, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5815, 160) },
---
>   { std::make_pair (50, WIFI_PHY_STANDARD_80211ac), std::make_pair (5250, 160) },
>   { std::make_pair (114, WIFI_PHY_STANDARD_80211ac), std::make_pair (5570, 160) },
152c149
<   // 802.11p (10 MHz channels at the 5.855-5.925 band
---
>   // 802.11p (10 MHz channels at the 5.855-5.925 band 
159,199c156
<   { std::make_pair (184, WIFI_PHY_STANDARD_80211_10MHZ), std::make_pair (5920, 10) },
<   //// WIGIG ////
<   /* 802.11ad (2.16 GHz channels at the 56.16-64.8 GHz band) */
<   { std::make_pair (1, WIFI_PHY_STANDARD_80211ad), std::make_pair (58320, 2160) },
<   { std::make_pair (2, WIFI_PHY_STANDARD_80211ad), std::make_pair (60480, 2160) },
<   { std::make_pair (3, WIFI_PHY_STANDARD_80211ad), std::make_pair (62640, 2160) },
<   { std::make_pair (4, WIFI_PHY_STANDARD_80211ad), std::make_pair (64800, 2160) },
<   { std::make_pair (5, WIFI_PHY_STANDARD_80211ad), std::make_pair (66960, 2160) },
<   { std::make_pair (6, WIFI_PHY_STANDARD_80211ad), std::make_pair (69120, 2160) },
< 
<   /* IEEE 802.11ay D5.0 Figure 28-7 – Channelization used by EDMG STAs */
<   { std::make_pair (1, WIFI_PHY_STANDARD_80211ay), std::make_pair (58320, 2160) },
<   { std::make_pair (2, WIFI_PHY_STANDARD_80211ay), std::make_pair (60480, 2160) },
<   { std::make_pair (3, WIFI_PHY_STANDARD_80211ay), std::make_pair (62640, 2160) },
<   { std::make_pair (4, WIFI_PHY_STANDARD_80211ay), std::make_pair (64800, 2160) },
<   { std::make_pair (5, WIFI_PHY_STANDARD_80211ay), std::make_pair (66960, 2160) },
<   { std::make_pair (6, WIFI_PHY_STANDARD_80211ay), std::make_pair (69120, 2160) },
<   { std::make_pair (7, WIFI_PHY_STANDARD_80211ay), std::make_pair (71280, 2160) },
<   { std::make_pair (8, WIFI_PHY_STANDARD_80211ay), std::make_pair (73440, 2160) },
< 
<   { std::make_pair (9, WIFI_PHY_STANDARD_80211ay), std::make_pair (59400, 4320) },
<   { std::make_pair (10, WIFI_PHY_STANDARD_80211ay), std::make_pair (61560, 4320) },
<   { std::make_pair (11, WIFI_PHY_STANDARD_80211ay), std::make_pair (63720, 4320) },
<   { std::make_pair (12, WIFI_PHY_STANDARD_80211ay), std::make_pair (65880, 4320) },
<   { std::make_pair (13, WIFI_PHY_STANDARD_80211ay), std::make_pair (68040, 4320) },
<   { std::make_pair (14, WIFI_PHY_STANDARD_80211ay), std::make_pair (70200, 4320) },
<   { std::make_pair (15, WIFI_PHY_STANDARD_80211ay), std::make_pair (72360, 4320) },
< 
<   { std::make_pair (17, WIFI_PHY_STANDARD_80211ay), std::make_pair (60480, 6480) },
<   { std::make_pair (18, WIFI_PHY_STANDARD_80211ay), std::make_pair (62640, 6480) },
<   { std::make_pair (19, WIFI_PHY_STANDARD_80211ay), std::make_pair (64800, 6480) },
<   { std::make_pair (20, WIFI_PHY_STANDARD_80211ay), std::make_pair (66960, 6480) },
<   { std::make_pair (21, WIFI_PHY_STANDARD_80211ay), std::make_pair (69120, 6480) },
<   { std::make_pair (22, WIFI_PHY_STANDARD_80211ay), std::make_pair (71280, 6480) },
< 
<   { std::make_pair (25, WIFI_PHY_STANDARD_80211ay), std::make_pair (61560, 8640) },
<   { std::make_pair (26, WIFI_PHY_STANDARD_80211ay), std::make_pair (63720, 8640) },
<   { std::make_pair (27, WIFI_PHY_STANDARD_80211ay), std::make_pair (65880, 8640) },
<   { std::make_pair (28, WIFI_PHY_STANDARD_80211ay), std::make_pair (68040, 8640) },
<   { std::make_pair (29, WIFI_PHY_STANDARD_80211ay), std::make_pair (70200, 8640) },
<   //// WIGIG ////
---
>   { std::make_pair (184, WIFI_PHY_STANDARD_80211_10MHZ), std::make_pair (5920, 10) }
213c170
<                    MakeUintegerChecker<uint16_t> ())
---
>                    MakeUintegerChecker<uint32_t> ())
215c172
<                    "Whether 5MHz, 10MHz, 20MHz, 22MHz, 40MHz, 80 MHz or 160 MHz or 2160.",
---
>                    "Whether 5MHz, 10MHz, 20MHz, 22MHz, 40MHz, 80 MHz or 160 MHz.",
219c176
<                    MakeUintegerChecker<uint16_t> (5, 2160))
---
>                    MakeUintegerChecker<uint32_t> ())
225c182
<                    MakeUintegerChecker<uint8_t> (0, 196))
---
>                    MakeUintegerChecker<uint16_t> ())
228,238c185,188
<                    "this threshold (dBm) to allow the PHY layer to detect the signal.",
<                    DoubleValue (-101.0),
<                    MakeDoubleAccessor (&WifiPhy::SetEdThreshold),
<                    MakeDoubleChecker<double> (),
<                    TypeId::DEPRECATED, "Replaced by RxSensitivity.")
<     .AddAttribute ("RxSensitivity",
<                    "The energy of a received signal should be higher than "
<                    "this threshold (dBm) for the PHY to detect the signal.",
<                    DoubleValue (-101.0),
<                    MakeDoubleAccessor (&WifiPhy::SetRxSensitivity,
<                                        &WifiPhy::GetRxSensitivity),
---
>                    "this threshold (dbm) to allow the PHY layer to detect the signal.",
>                    DoubleValue (-96.0),
>                    MakeDoubleAccessor (&WifiPhy::SetEdThreshold,
>                                        &WifiPhy::GetEdThreshold),
240,246c190,195
<     .AddAttribute ("CcaEdThreshold",
<                    "The energy of a non Wi-Fi received signal should be higher than "
<                    "this threshold (dBm) to allow the PHY layer to declare CCA BUSY state. "
<                    "This check is performed on the 20 MHz primary channel only.",
<                    DoubleValue (-62.0),
<                    MakeDoubleAccessor (&WifiPhy::SetCcaEdThreshold,
<                                        &WifiPhy::GetCcaEdThreshold),
---
>     .AddAttribute ("CcaMode1Threshold",
>                    "The energy of a received signal should be higher than "
>                    "this threshold (dbm) to allow the PHY layer to declare CCA BUSY state.",
>                    DoubleValue (-99.0),
>                    MakeDoubleAccessor (&WifiPhy::SetCcaMode1Threshold,
>                                        &WifiPhy::GetCcaMode1Threshold),
250c199
<                    DoubleValue (0.0),
---
>                    DoubleValue (1.0),
256c205
<                    DoubleValue (0.0),
---
>                    DoubleValue (1.0),
265c214
<                    MakeUintegerChecker<uint8_t> ())
---
>                    MakeUintegerChecker<uint32_t> ())
267c216
<                    "Maximum available transmission level (dBm).",
---
>                    "Maximum available transmission level (dbm).",
273c222
<                    "Minimum available transmission level (dBm).",
---
>                    "Minimum available transmission level (dbm).",
286c235,236
<                    MakeDoubleAccessor (&WifiPhy::SetRxNoiseFigure),
---
>                    MakeDoubleAccessor (&WifiPhy::SetRxNoiseFigure,
>                                        &WifiPhy::GetRxNoiseFigure),
298,306c248,249
<     .AddAttribute ("Antennas",
<                    "The number of antennas on the device.",
<                    UintegerValue (1),
<                    MakeUintegerAccessor (&WifiPhy::GetNumberOfAntennas,
<                                          &WifiPhy::SetNumberOfAntennas),
<                    MakeUintegerChecker<uint8_t> (1, 8))
<     .AddAttribute ("MaxSupportedTxSpatialStreams",
<                    "The maximum number of supported TX spatial streams."
<                    "This parameter is only valuable for 802.11n/ac/ax STAs and APs.",
---
>     .AddAttribute ("TxAntennas",
>                    "The number of supported Tx antennas.",
308,313c251,255
<                    MakeUintegerAccessor (&WifiPhy::GetMaxSupportedTxSpatialStreams,
<                                          &WifiPhy::SetMaxSupportedTxSpatialStreams),
<                    MakeUintegerChecker<uint8_t> (1, 8))
<     .AddAttribute ("MaxSupportedRxSpatialStreams",
<                    "The maximum number of supported RX spatial streams."
<                    "This parameter is only valuable for 802.11n/ac/ax STAs and APs.",
---
>                    MakeUintegerAccessor (&WifiPhy::GetNumberOfTransmitAntennas,
>                                          &WifiPhy::SetNumberOfTransmitAntennas),
>                    MakeUintegerChecker<uint32_t> ())
>     .AddAttribute ("RxAntennas",
>                    "The number of supported Rx antennas.",
315,317c257,259
<                    MakeUintegerAccessor (&WifiPhy::GetMaxSupportedRxSpatialStreams,
<                                          &WifiPhy::SetMaxSupportedRxSpatialStreams),
<                    MakeUintegerChecker<uint8_t> (1, 8))
---
>                    MakeUintegerAccessor (&WifiPhy::GetNumberOfReceiveAntennas,
>                                          &WifiPhy::SetNumberOfReceiveAntennas),
>                    MakeUintegerChecker<uint32_t> ())
319,320c261,274
<                    "Whether or not short guard interval is enabled for HT/VHT transmissions."
<                    "This parameter is only valuable for 802.11n/ac/ax STAs and APs.",
---
>                    "Whether or not short guard interval is enabled."
>                    "This parameter is only valuable for 802.11n/ac STAs and APs.",
>                    BooleanValue (false),
>                    MakeBooleanAccessor (&WifiPhy::GetGuardInterval,
>                                         &WifiPhy::SetGuardInterval),
>                    MakeBooleanChecker ())
>     .AddAttribute ("LdpcEnabled",
>                    "Whether or not LDPC is enabled.",
>                    BooleanValue (false),
>                    MakeBooleanAccessor (&WifiPhy::GetLdpc,
>                                         &WifiPhy::SetLdpc),
>                    MakeBooleanChecker ())
>     .AddAttribute ("STBCEnabled",
>                    "Whether or not STBC is enabled.",
322,333c276,278
<                    MakeBooleanAccessor (&WifiPhy::GetShortGuardInterval,
<                                         &WifiPhy::SetShortGuardInterval),
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Use the HtConfiguration instead")
<     .AddAttribute ("GuardInterval",
<                    "Whether 800ns, 1600ns or 3200ns guard interval is used for HE transmissions."
<                    "This parameter is only valuable for 802.11ax STAs and APs.",
<                    TimeValue (NanoSeconds (3200)),
<                    MakeTimeAccessor (&WifiPhy::GetGuardInterval,
<                                      &WifiPhy::SetGuardInterval),
<                    MakeTimeChecker (NanoSeconds (800), NanoSeconds (3200)),
<                    TypeId::DEPRECATED, "Use the HeConfiguration instead")
---
>                    MakeBooleanAccessor (&WifiPhy::GetStbc,
>                                         &WifiPhy::SetStbc),
>                    MakeBooleanChecker ())
340,341c285
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Use the HtConfiguration instead")
---
>                    MakeBooleanChecker ())
343c287
<                    "Whether or not short PHY preamble is supported."
---
>                    "Whether or not short PLCP preamble is supported."
345c289
<                    "Note: 802.11g APs and STAs always support short PHY preamble.",
---
>                    "Note: 802.11g APs and STAs always support short PLCP preamble.",
347,348c291,292
<                    MakeBooleanAccessor (&WifiPhy::GetShortPhyPreambleSupported,
<                                         &WifiPhy::SetShortPhyPreambleSupported),
---
>                    MakeBooleanAccessor (&WifiPhy::GetShortPlcpPreambleSupported,
>                                         &WifiPhy::SetShortPlcpPreambleSupported),
350,367d293
<     .AddAttribute ("FrameCaptureModel",
<                    "Ptr to an object that implements the frame capture model",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiPhy::m_frameCaptureModel),
<                    MakePointerChecker <FrameCaptureModel> ())
<     .AddAttribute ("PreambleDetectionModel",
<                    "Ptr to an object that implements the preamble detection model",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiPhy::m_preambleDetectionModel),
<                    MakePointerChecker <PreambleDetectionModel> ())
<     .AddAttribute ("PostReceptionErrorModel",
<                    "An optional packet error model can be added to the receive "
<                    "packet process after any propagation-based (SNR-based) error "
<                    "models have been applied. Typically this is used to force "
<                    "specific packet drops, for testing purposes.",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiPhy::m_postReceptionErrorModel),
<                    MakePointerChecker<ErrorModel> ())
373,377d298
<     .AddTraceSource ("PhyTxPsduBegin",
<                      "Trace source indicating a PSDU "
<                      "has begun transmitting over the channel medium",
<                      MakeTraceSourceAccessor (&WifiPhy::m_phyTxPsduBeginTrace),
<                      "ns3::WifiPhy::PsduTxBeginCallback")
380c301,304
<                      "has been completely transmitted over the channel.",
---
>                      "has been completely transmitted over the channel. "
>                      "NOTE: the only official WifiPhy implementation "
>                      "available to this date never fires "
>                      "this trace source.",
394,398d317
<     .AddTraceSource ("PhyRxPayloadBegin",
<                      "Trace source indicating the reception of the "
<                      "payload of a PPDU has begun",
<                      MakeTraceSourceAccessor (&WifiPhy::m_phyRxPayloadBeginTrace),
<                      "ns3::WifiPhy::PhyRxPayloadBeginTracedCallback")
420,423d338
<     .AddTraceSource ("EndOfHePreamble",
<                      "Trace source indicating the end of the 802.11ax preamble (after training fields)",
<                      MakeTraceSourceAccessor (&WifiPhy::m_phyEndOfHePreambleTrace),
<                      "ns3::WifiPhy::EndOfHePreambleTracedCallback")
429c344,346
<   : m_txMpduReferenceNumber (0xffffffff),
---
>   : m_mpdusNum (0),
>     m_plcpSuccess (false),
>     m_txMpduReferenceNumber (0xffffffff),
432,437c349
<     m_endPhyRxEvent (),
<     m_endPreambleDetectionEvent (),
<     m_endTxEvent (),
<     m_currentEvent (0),
<     m_wifiRadioEnergyModel (0),
<     m_isConstructed (false),
---
>     m_endPlcpRxEvent (),
438a351
>     m_isConstructed (false),
442,446d354
<     m_channelWidth (0),
<     m_powerRestricted (false),
<     m_channelAccessRequested (false),
<     m_txSpatialStreams (0),
<     m_rxSpatialStreams (0),
449c357,358
<     m_timeLastPreambleDetected (Seconds (0))
---
>     m_totalAmpduSize (0),
>     m_totalAmpduNumSymbols (0)
454d362
<   m_interference.SetWifiPhy (this);
466,469d373
<   m_endTxEvent.Cancel ();
<   m_endRxEvent.Cancel ();
<   m_endPhyRxEvent.Cancel ();
<   m_endPreambleDetectionEvent.Cancel ();
473,474d376
<   m_wifiRadioEnergyModel = 0;
<   m_postReceptionErrorModel = 0;
477d378
<   m_mcsIndexMap.clear ();
480c381
< void
---
> void 
483c384
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION (this); 
493,528d393
< Ptr<WifiPhyStateHelper>
< WifiPhy::GetState (void) const
< {
<   return m_state;
< }
< 
< void
< WifiPhy::SetReceiveOkCallback (RxOkCallback callback)
< {
<   m_state->SetReceiveOkCallback (callback);
< }
< 
< void
< WifiPhy::SetReceiveErrorCallback (RxErrorCallback callback)
< {
<   m_state->SetReceiveErrorCallback (callback);
< }
< 
< void
< WifiPhy::RegisterListener (WifiPhyListener *listener)
< {
<   m_state->RegisterListener (listener);
< }
< 
< void
< WifiPhy::UnregisterListener (WifiPhyListener *listener)
< {
<   m_state->UnregisterListener (listener);
< }
< 
< void
< WifiPhy::SetCapabilitiesChangedCallback (Callback<void> callback)
< {
<   m_capabilitiesChangedCallback = callback;
< }
< 
540c405
<   // drive the configuration, and frequency and channel number will be
---
>   // drive the configuration, and frequency and channel number will be 
552c417
<       NS_FATAL_ERROR ("Error, ChannelNumber " << +GetChannelNumber () << " was set by user, but neither a standard nor a frequency");
---
>       NS_FATAL_ERROR ("Error, ChannelNumber " << GetChannelNumber () << " was set by user, but neither a standard nor a frequency");
560c425,426
<   SetRxSensitivity (threshold);
---
>   NS_LOG_FUNCTION (this << threshold);
>   m_edThresholdW = DbmToW (threshold);
563,564c429,430
< void
< WifiPhy::SetRxSensitivity (double threshold)
---
> double
> WifiPhy::GetEdThresholdW (void) const
566,567c432
<   NS_LOG_FUNCTION (this << threshold);
<   m_rxSensitivityW = DbmToW (threshold);
---
>   return m_edThresholdW;
571c436
< WifiPhy::GetRxSensitivity (void) const
---
> WifiPhy::GetEdThreshold (void) const
573c438
<   return WToDbm (m_rxSensitivityW);
---
>   return WToDbm (m_edThresholdW);
577c442
< WifiPhy::SetCcaEdThreshold (double threshold)
---
> WifiPhy::SetCcaMode1Threshold (double threshold)
580c445
<   m_ccaEdThresholdW = DbmToW (threshold);
---
>   m_ccaMode1ThresholdW = DbmToW (threshold);
584c449
< WifiPhy::GetCcaEdThreshold (void) const
---
> WifiPhy::GetCcaMode1Threshold (void) const
586c451
<   return WToDbm (m_ccaEdThresholdW);
---
>   return WToDbm (m_ccaMode1ThresholdW);
594d458
<   m_interference.SetNumberOfReceiveAntennas (GetNumberOfAntennas ());
630c494
< WifiPhy::SetNTxPower (uint8_t n)
---
> WifiPhy::SetNTxPower (uint32_t n)
632c496
<   NS_LOG_FUNCTION (this << +n);
---
>   NS_LOG_FUNCTION (this << n);
636c500
< uint8_t
---
> uint32_t
669c533
< WifiPhy::SetGreenfield (bool greenfield)
---
> WifiPhy::SetLdpc (bool ldpc)
671,681c535,536
<   NS_LOG_FUNCTION (this << greenfield);
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           htConfiguration->SetGreenfieldSupported (greenfield);
<         }
<     }
<   m_greenfield = greenfield;
---
>   NS_LOG_FUNCTION (this << ldpc);
>   m_ldpc = ldpc;
685c540
< WifiPhy::GetGreenfield (void) const
---
> WifiPhy::GetLdpc (void) const
687,696c542
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           return htConfiguration->GetGreenfieldSupported ();
<         }
<     }
<   return m_greenfield;
---
>   return m_ldpc;
700c546
< WifiPhy::SetShortGuardInterval (bool shortGuardInterval)
---
> WifiPhy::SetStbc (bool stbc)
702,712c548,549
<   NS_LOG_FUNCTION (this << shortGuardInterval);
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           htConfiguration->SetShortGuardIntervalSupported (shortGuardInterval);
<         }
<     }
<   m_shortGuardInterval = shortGuardInterval;
---
>   NS_LOG_FUNCTION (this << stbc);
>   m_stbc = stbc;
716c553
< WifiPhy::GetShortGuardInterval (void) const
---
> WifiPhy::GetStbc (void) const
718,727c555,568
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           return htConfiguration->GetShortGuardIntervalSupported ();
<         }
<     }
<   return m_shortGuardInterval;
---
>   return m_stbc;
> }
> 
> void
> WifiPhy::SetGreenfield (bool greenfield)
> {
>   NS_LOG_FUNCTION (this << greenfield);
>   m_greenfield = greenfield;
> }
> 
> bool
> WifiPhy::GetGreenfield (void) const
> {
>   return m_greenfield;
731c572
< WifiPhy::SetGuardInterval (Time guardInterval)
---
> WifiPhy::SetGuardInterval (bool guardInterval)
734,743d574
<   NS_ASSERT (guardInterval == NanoSeconds (800) || guardInterval == NanoSeconds (1600) || guardInterval == NanoSeconds (3200));
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<       if (heConfiguration)
<         {
<           heConfiguration->SetGuardInterval (guardInterval);
<         }
<     }
747c578
< Time
---
> bool
750,758d580
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<       if (heConfiguration)
<         {
<           return heConfiguration->GetGuardInterval ();
<         }
<     }
763c585
< WifiPhy::SetShortPhyPreambleSupported (bool enable)
---
> WifiPhy::SetShortPlcpPreambleSupported (bool enable)
770c592
< WifiPhy::GetShortPhyPreambleSupported (void) const
---
> WifiPhy::GetShortPlcpPreambleSupported (void) const
776c598
< WifiPhy::SetDevice (const Ptr<NetDevice> device)
---
> WifiPhy::SetDevice (Ptr<NetDevice> device)
779,790d600
<   //TODO: to be removed once deprecated API is cleaned up
<   Ptr<HtConfiguration> htConfiguration = DynamicCast<WifiNetDevice> (device)->GetHtConfiguration ();
<   if (htConfiguration)
<     {
<       htConfiguration->SetShortGuardIntervalSupported (m_shortGuardInterval);
<       htConfiguration->SetGreenfieldSupported (m_greenfield);
<     }
<   Ptr<HeConfiguration> heConfiguration = DynamicCast<WifiNetDevice> (device)->GetHeConfiguration ();
<   if (heConfiguration)
<     {
<       heConfiguration->SetGuardInterval (m_guardInterval);
<     }
800c610
< WifiPhy::SetMobility (const Ptr<MobilityModel> mobility)
---
> WifiPhy::SetMobility (Ptr<MobilityModel> mobility)
806c616
< WifiPhy::GetMobility (void) const
---
> WifiPhy::GetMobility (void)
819c629
< WifiPhy::SetErrorRateModel (const Ptr<ErrorRateModel> rate)
---
> WifiPhy::SetErrorRateModel (Ptr<ErrorRateModel> rate)
822d631
<   m_interference.SetNumberOfReceiveAntennas (GetNumberOfAntennas ());
825,826c634,635
< void
< WifiPhy::SetPostReceptionErrorModel (const Ptr<ErrorModel> em)
---
> Ptr<ErrorRateModel>
> WifiPhy::GetErrorRateModel (void) const
828,848c637
<   NS_LOG_FUNCTION (this << em);
<   m_postReceptionErrorModel = em;
< }
< 
< void
< WifiPhy::SetFrameCaptureModel (const Ptr<FrameCaptureModel> model)
< {
<   m_frameCaptureModel = model;
<   m_frameCaptureModel->SetWifiPhy (this);
< }
< 
< void
< WifiPhy::SetPreambleDetectionModel (const Ptr<PreambleDetectionModel> model)
< {
<   m_preambleDetectionModel = model;
< }
< 
< void
< WifiPhy::SetWifiRadioEnergyModel (const Ptr<WifiRadioEnergyModel> wifiRadioEnergyModel)
< {
<   m_wifiRadioEnergyModel = wifiRadioEnergyModel;
---
>   return m_interference.GetErrorRateModel ();
882c671
< WifiPhy::ConfigureDefaultsForStandard (WifiPhyStandard standard)
---
> WifiPhy::ConfigureDefaultsForStandard (enum WifiPhyStandard standard)
914c703
<       // Channel number should be aligned by SetFrequency () to 0
---
>       // Channel number should be aligned by SetFrequency () to 0 
935,943d723
<     //// WIGIG ////
<     case WIFI_PHY_STANDARD_80211ad:
<     case WIFI_PHY_STANDARD_80211ay:
<       SetChannelWidth (2160);
<       SetFrequency (58320);
<       // Channel number should be aligned by SetFrequency () to 1
<       NS_ASSERT (GetChannelNumber () == 1);
<       break;
<     //// WIGIG ////
950,961d729
<     case WIFI_PHY_STANDARD_80211ax_2_4GHZ:
<       SetChannelWidth (20);
<       SetFrequency (2412);
<       // Channel number should be aligned by SetFrequency () to 1
<       NS_ASSERT (GetChannelNumber () == 1);
<       break;
<     case WIFI_PHY_STANDARD_80211ax_5GHZ:
<       SetChannelWidth (80);
<       SetFrequency (5210);
<       // Channel number should be aligned by SetFrequency () to 42
<       NS_ASSERT (GetChannelNumber () == 42);
<       break;
963d730
<     default:
965a733,735
>     default:
>       NS_ASSERT (false);
>       break;
1054,1078d823
< WifiPhy::PushMcs (WifiMode mode)
< {
<   NS_LOG_FUNCTION (this << mode);
< 
<   WifiModulationClass modulation = mode.GetModulationClass ();
<   NS_ASSERT (modulation == WIFI_MOD_CLASS_HT || modulation == WIFI_MOD_CLASS_VHT
<              || modulation == WIFI_MOD_CLASS_HE);
< 
<   m_mcsIndexMap[modulation][mode.GetMcsValue ()] = m_deviceMcsSet.size ();
<   m_deviceMcsSet.push_back (mode);
< }
< 
< void
< WifiPhy::RebuildMcsMap (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_mcsIndexMap.clear ();
<   uint8_t index = 0;
<   for (auto& mode : m_deviceMcsSet)
<     {
<       m_mcsIndexMap[mode.GetModulationClass ()][mode.GetMcsValue ()] = index++;
<     }
< }
< 
< void
1084c829
<   for (std::vector<uint8_t>::size_type i = 0; i < m_bssMembershipSelectorSet.size (); i++)
---
>   for (std::vector<uint32_t>::size_type i = 0; i < m_bssMembershipSelectorSet.size (); i++)
1095,1096c840,841
<       std::size_t index = m_deviceMcsSet.size () - 1;
<       for (std::vector<WifiMode>::reverse_iterator rit = m_deviceMcsSet.rbegin (); rit != m_deviceMcsSet.rend (); ++rit, --index)
---
>       size_t index = m_deviceMcsSet.size () - 1;
>       for (std::vector<WifiMode>::reverse_iterator rit = m_deviceMcsSet.rbegin (); rit != m_deviceMcsSet.rend(); ++rit, --index)
1098c843
<           if (m_deviceMcsSet[index].GetModulationClass () == WIFI_MOD_CLASS_HT)
---
>           if (m_deviceMcsSet[index].GetModulationClass ()== WIFI_MOD_CLASS_HT)
1103,1143c848,887
<       RebuildMcsMap ();
<       PushMcs (WifiPhy::GetHtMcs0 ());
<       PushMcs (WifiPhy::GetHtMcs1 ());
<       PushMcs (WifiPhy::GetHtMcs2 ());
<       PushMcs (WifiPhy::GetHtMcs3 ());
<       PushMcs (WifiPhy::GetHtMcs4 ());
<       PushMcs (WifiPhy::GetHtMcs5 ());
<       PushMcs (WifiPhy::GetHtMcs6 ());
<       PushMcs (WifiPhy::GetHtMcs7 ());
<       if (GetMaxSupportedTxSpatialStreams () > 1)
<         {
<           PushMcs (WifiPhy::GetHtMcs8 ());
<           PushMcs (WifiPhy::GetHtMcs9 ());
<           PushMcs (WifiPhy::GetHtMcs10 ());
<           PushMcs (WifiPhy::GetHtMcs11 ());
<           PushMcs (WifiPhy::GetHtMcs12 ());
<           PushMcs (WifiPhy::GetHtMcs13 ());
<           PushMcs (WifiPhy::GetHtMcs14 ());
<           PushMcs (WifiPhy::GetHtMcs15 ());
<         }
<       if (GetMaxSupportedTxSpatialStreams () > 2)
<         {
<           PushMcs (WifiPhy::GetHtMcs16 ());
<           PushMcs (WifiPhy::GetHtMcs17 ());
<           PushMcs (WifiPhy::GetHtMcs18 ());
<           PushMcs (WifiPhy::GetHtMcs19 ());
<           PushMcs (WifiPhy::GetHtMcs20 ());
<           PushMcs (WifiPhy::GetHtMcs21 ());
<           PushMcs (WifiPhy::GetHtMcs22 ());
<           PushMcs (WifiPhy::GetHtMcs23 ());
<         }
<       if (GetMaxSupportedTxSpatialStreams () > 3)
<         {
<           PushMcs (WifiPhy::GetHtMcs24 ());
<           PushMcs (WifiPhy::GetHtMcs25 ());
<           PushMcs (WifiPhy::GetHtMcs26 ());
<           PushMcs (WifiPhy::GetHtMcs27 ());
<           PushMcs (WifiPhy::GetHtMcs28 ());
<           PushMcs (WifiPhy::GetHtMcs29 ());
<           PushMcs (WifiPhy::GetHtMcs30 ());
<           PushMcs (WifiPhy::GetHtMcs31 ());
---
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs0 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs1 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs2 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs3 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs4 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs5 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs6 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs7 ());
>       if (GetSupportedTxSpatialStreams () > 1)
>         {
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs8 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs9 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs10 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs11 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs12 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs13 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs14 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs15 ());
>         }
>       if (GetSupportedTxSpatialStreams () > 2)
>         {
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs16 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs17 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs18 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs19 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs20 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs21 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs22 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs23 ());
>         }
>       if (GetSupportedTxSpatialStreams () > 3)
>         {
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs24 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs25 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs26 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs27 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs28 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs29 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs30 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs31 ());
1152c896
<   if (Is2_4Ghz (GetFrequency ()))
---
>   if (GetFrequency () >= 2400 && GetFrequency () <= 2500) //at 2.4 GHz
1157c901
<   if (Is5Ghz (GetFrequency ()))
---
>   if (GetFrequency () >= 5000 && GetFrequency () <= 6000) //at 5 GHz
1171,1180c915,924
<   PushMcs (WifiPhy::GetVhtMcs0 ());
<   PushMcs (WifiPhy::GetVhtMcs1 ());
<   PushMcs (WifiPhy::GetVhtMcs2 ());
<   PushMcs (WifiPhy::GetVhtMcs3 ());
<   PushMcs (WifiPhy::GetVhtMcs4 ());
<   PushMcs (WifiPhy::GetVhtMcs5 ());
<   PushMcs (WifiPhy::GetVhtMcs6 ());
<   PushMcs (WifiPhy::GetVhtMcs7 ());
<   PushMcs (WifiPhy::GetVhtMcs8 ());
<   PushMcs (WifiPhy::GetVhtMcs9 ());
---
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs0 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs1 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs2 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs3 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs4 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs5 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs6 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs7 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs8 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs9 ());
1185,1215c929,930
< void
< WifiPhy::Configure80211ax (void)
< {
<   NS_LOG_FUNCTION (this);
<   if (Is5Ghz (GetFrequency ()))
<     {
<       Configure80211ac ();
<     }
<   else
<     {
<       Configure80211n ();
<     }
< 
<   PushMcs (WifiPhy::GetHeMcs0 ());
<   PushMcs (WifiPhy::GetHeMcs1 ());
<   PushMcs (WifiPhy::GetHeMcs2 ());
<   PushMcs (WifiPhy::GetHeMcs3 ());
<   PushMcs (WifiPhy::GetHeMcs4 ());
<   PushMcs (WifiPhy::GetHeMcs5 ());
<   PushMcs (WifiPhy::GetHeMcs6 ());
<   PushMcs (WifiPhy::GetHeMcs7 ());
<   PushMcs (WifiPhy::GetHeMcs8 ());
<   PushMcs (WifiPhy::GetHeMcs9 ());
<   PushMcs (WifiPhy::GetHeMcs10 ());
<   PushMcs (WifiPhy::GetHeMcs11 ());
< 
<   m_bssMembershipSelectorSet.push_back (HE_PHY);
< }
< 
< bool
< WifiPhy::DefineChannelNumber (uint8_t channelNumber, WifiPhyStandard standard, uint16_t frequency, uint16_t channelWidth)
---
> bool 
> WifiPhy::DefineChannelNumber (uint16_t channelNumber, enum WifiPhyStandard standard, uint32_t frequency, uint32_t channelWidth)
1217c932
<   NS_LOG_FUNCTION (this << +channelNumber << standard << frequency << channelWidth);
---
>   NS_LOG_FUNCTION (this << channelNumber << standard << frequency << channelWidth);
1231,1232c946,947
< uint8_t
< WifiPhy::FindChannelNumberForFrequencyWidth (uint16_t frequency, uint16_t width) const
---
> uint16_t 
> WifiPhy::FindChannelNumberForFrequencyWidth (uint32_t frequency, uint32_t width) const
1242,1243c957,958
<           found = true;
<           break;
---
>            found = true;
>            break;
1249c964
<       NS_LOG_DEBUG ("Found, returning " << +it->first.first);
---
>       NS_LOG_DEBUG ("Found, returning " << it->first.first);
1260c975
< WifiPhy::ConfigureChannelForStandard (WifiPhyStandard standard)
---
> WifiPhy::ConfigureChannelForStandard (enum WifiPhyStandard standard)
1264c979
<   // takes precedence
---
>   // takes precedence 
1268,1269c983,985
<       // be found that matches Frequency and ChannelWidth. If so, configure
<       // the ChannelNumber to that channel number. If not, set ChannelNumber to zero.
---
>       // be found that matches Frequency and ChannelWidth.  If so, configure 
>       // the ChannelNumber to that channel number.  If not, set 
>       // ChannelNumber to zero.
1271c987
<       uint8_t channelNumberSearched = FindChannelNumberForFrequencyWidth (GetFrequency (), GetChannelWidth ());
---
>       uint32_t channelNumberSearched = FindChannelNumberForFrequencyWidth (GetFrequency (), GetChannelWidth ());
1274c990
<           NS_LOG_DEBUG ("Channel number found; setting to " << +channelNumberSearched);
---
>           NS_LOG_DEBUG ("Channel number found; setting to " << channelNumberSearched);
1285c1001
<       // If the channel number is known for this particular standard or for
---
>       // If the channel number is known for this particular standard or for 
1288c1004
<       NS_LOG_DEBUG ("Configuring for channel number " << +GetChannelNumber ());
---
>       NS_LOG_DEBUG ("Configuring for channel number " << GetChannelNumber ());
1298c1014
<           NS_FATAL_ERROR ("Error, ChannelNumber " << +GetChannelNumber () << " is unknown for this standard");
---
>           NS_FATAL_ERROR ("Error, ChannelNumber " << GetChannelNumber () << " is unknown for this standard");
1302c1018
<           NS_LOG_DEBUG ("Setting frequency to " << f.first << "; width to " << +f.second);
---
>           NS_LOG_DEBUG ("Setting frequency to " << f.first << "; width to " << f.second);
1310c1026
< WifiPhy::ConfigureStandard (WifiPhyStandard standard)
---
> WifiPhy::ConfigureStandard (enum WifiPhyStandard standard)
1328,1335c1044
<   DoConfigureStandard ();
< }
< 
< void
< WifiPhy::DoConfigureStandard (void)
< {
<   NS_LOG_FUNCTION (this);
<   switch (m_standard)
---
>   switch (standard)
1355a1065,1066
>       Configure80211n ();
>       break;
1362,1366d1072
<     case WIFI_PHY_STANDARD_80211ax_2_4GHZ:
<     case WIFI_PHY_STANDARD_80211ax_5GHZ:
<       Configure80211ax ();
<       break;
<     case WIFI_PHY_STANDARD_UNSPECIFIED:
1373c1079
< WifiPhyStandard
---
> enum WifiPhyStandard
1380c1086
< WifiPhy::SetFrequency (uint16_t frequency)
---
> WifiPhy::SetFrequency (uint32_t frequency)
1405c1111
<   uint8_t nch = FindChannelNumberForFrequencyWidth (frequency, GetChannelWidth ());
---
>   uint16_t nch = FindChannelNumberForFrequencyWidth (frequency, GetChannelWidth ());
1408c1114
<       NS_LOG_DEBUG ("Setting frequency " << frequency << " corresponds to channel " << +nch);
---
>       NS_LOG_DEBUG ("Setting frequency " << frequency << " corresponds to channel " << nch);
1411c1117
<           NS_LOG_DEBUG ("Channel frequency switched to " << frequency << "; channel number to " << +nch);
---
>           NS_LOG_DEBUG ("Channel frequency switched to " << frequency << "; channel number to " << nch);
1436c1142
< uint16_t
---
> uint32_t
1443c1149
< WifiPhy::SetChannelWidth (uint16_t channelWidth)
---
> WifiPhy::SetChannelWidth (uint32_t channelwidth)
1445,1458c1151,1153
<   NS_LOG_FUNCTION (this << channelWidth);
<   //// WIGIG ////
<   NS_ASSERT_MSG (channelWidth == 5 || channelWidth == 10 || channelWidth == 20 || channelWidth == 22
<                  || channelWidth == 40 || channelWidth == 80 || channelWidth == 160
<                  || channelWidth == 2160 || channelWidth == 4320 || channelWidth == 6480 || channelWidth == 8640,
<                  "wrong channel width value");
<   //// WIGIG ////
<   bool changed = (m_channelWidth != channelWidth);
<   m_channelWidth = channelWidth;
<   AddSupportedChannelWidth (channelWidth);
<   if (changed && !m_capabilitiesChangedCallback.IsNull ())
<     {
<       m_capabilitiesChangedCallback ();
<     }
---
>   NS_ASSERT_MSG (channelwidth == 5 || channelwidth == 10 || channelwidth == 20 || channelwidth == 22 || channelwidth == 40 || channelwidth == 80 || channelwidth == 160, "wrong channel width value");
>   m_channelWidth = channelwidth;
>   AddSupportedChannelWidth (channelwidth);
1461c1156
< uint16_t
---
> uint32_t
1468c1163
< WifiPhy::SetNumberOfAntennas (uint8_t antennas)
---
> WifiPhy::SetNumberOfTransmitAntennas (uint32_t tx)
1470,1472c1165,1166
<   NS_ASSERT_MSG (antennas > 0 && antennas <= 4, "unsupported number of antennas");
<   m_numberOfAntennas = antennas;
<   m_interference.SetNumberOfReceiveAntennas (antennas);
---
>   m_numberOfTransmitters = tx;
>   ConfigureHtDeviceMcsSet ();
1475,1476c1169,1170
< uint8_t
< WifiPhy::GetNumberOfAntennas (void) const
---
> void
> WifiPhy::SetNumberOfReceiveAntennas (uint32_t rx)
1478c1172
<   return m_numberOfAntennas;
---
>   m_numberOfReceivers = rx;
1481,1482c1175,1176
< void
< WifiPhy::SetMaxSupportedTxSpatialStreams (uint8_t streams)
---
> uint32_t
> WifiPhy::GetNumberOfTransmitAntennas (void) const
1484,1491c1178
<   NS_ASSERT (streams <= GetNumberOfAntennas ());
<   bool changed = (m_txSpatialStreams != streams);
<   m_txSpatialStreams = streams;
<   ConfigureHtDeviceMcsSet ();
<   if (changed && !m_capabilitiesChangedCallback.IsNull ())
<     {
<       m_capabilitiesChangedCallback ();
<     }
---
>   return m_numberOfTransmitters;
1494,1495c1181,1182
< uint8_t
< WifiPhy::GetMaxSupportedTxSpatialStreams (void) const
---
> uint32_t
> WifiPhy::GetNumberOfReceiveAntennas (void) const
1497c1184
<   return m_txSpatialStreams;
---
>   return m_numberOfReceivers;
1500,1501c1187,1188
< void
< WifiPhy::SetMaxSupportedRxSpatialStreams (uint8_t streams)
---
> uint8_t 
> WifiPhy::GetSupportedRxSpatialStreams (void) const
1503,1509c1190
<   NS_ASSERT (streams <= GetNumberOfAntennas ());
<   bool changed = (m_rxSpatialStreams != streams);
<   m_rxSpatialStreams = streams;
<   if (changed && !m_capabilitiesChangedCallback.IsNull ())
<     {
<       m_capabilitiesChangedCallback ();
<     }
---
>   return (static_cast<uint8_t> (GetNumberOfReceiveAntennas ()));
1512,1513c1193,1194
< uint8_t
< WifiPhy::GetMaxSupportedRxSpatialStreams (void) const
---
> uint8_t 
> WifiPhy::GetSupportedTxSpatialStreams (void) const
1515c1196
<   return m_rxSpatialStreams;
---
>   return (static_cast<uint8_t> (GetNumberOfTransmitAntennas ()));
1518c1199
< uint8_t
---
> uint32_t
1521c1202
<   return static_cast<uint8_t> (m_bssMembershipSelectorSet.size ());
---
>   return m_bssMembershipSelectorSet.size ();
1524,1525c1205,1206
< uint8_t
< WifiPhy::GetBssMembershipSelector (uint8_t selector) const
---
> uint32_t
> WifiPhy::GetBssMembershipSelector (uint32_t selector) const
1529a1211,1244
> WifiModeList
> WifiPhy::GetMembershipSelectorModes (uint32_t selector)
> {
>   uint32_t id = GetBssMembershipSelector (selector);
>   WifiModeList supportedmodes;
>   if (id == HT_PHY || id == VHT_PHY)
>     {
>       //mandatory MCS 0 to 7
>       supportedmodes.push_back (WifiPhy::GetHtMcs0 ());
>       supportedmodes.push_back (WifiPhy::GetHtMcs1 ());
>       supportedmodes.push_back (WifiPhy::GetHtMcs2 ());
>       supportedmodes.push_back (WifiPhy::GetHtMcs3 ());
>       supportedmodes.push_back (WifiPhy::GetHtMcs4 ());
>       supportedmodes.push_back (WifiPhy::GetHtMcs5 ());
>       supportedmodes.push_back (WifiPhy::GetHtMcs6 ());
>       supportedmodes.push_back (WifiPhy::GetHtMcs7 ());
>     }
>   if (id == VHT_PHY)
>     {
>       //mandatory MCS 0 to 9
>       supportedmodes.push_back (WifiPhy::GetVhtMcs0 ());
>       supportedmodes.push_back (WifiPhy::GetVhtMcs1 ());
>       supportedmodes.push_back (WifiPhy::GetVhtMcs2 ());
>       supportedmodes.push_back (WifiPhy::GetVhtMcs3 ());
>       supportedmodes.push_back (WifiPhy::GetVhtMcs4 ());
>       supportedmodes.push_back (WifiPhy::GetVhtMcs5 ());
>       supportedmodes.push_back (WifiPhy::GetVhtMcs6 ());
>       supportedmodes.push_back (WifiPhy::GetVhtMcs7 ());
>       supportedmodes.push_back (WifiPhy::GetVhtMcs8 ());
>       supportedmodes.push_back (WifiPhy::GetVhtMcs9 ());
>     }
>   return supportedmodes;
> }
> 
1531c1246
< WifiPhy::AddSupportedChannelWidth (uint16_t width)
---
> WifiPhy::AddSupportedChannelWidth (uint32_t width)
1545c1260
< std::vector<uint16_t>
---
> std::vector<uint32_t> 
1552c1267
< WifiPhy::GetFrequencyWidthForChannelNumberStandard (uint8_t channelNumber, WifiPhyStandard standard) const
---
> WifiPhy::GetFrequencyWidthForChannelNumberStandard (uint16_t channelNumber, enum WifiPhyStandard standard) const
1560c1275
< WifiPhy::SetChannelNumber (uint8_t nch)
---
> WifiPhy::SetChannelNumber (uint16_t nch)
1562c1277
<   NS_LOG_FUNCTION (this << +nch);
---
>   NS_LOG_FUNCTION (this << nch);
1596c1311
<           NS_LOG_DEBUG ("Setting frequency to " << f.first << "; width to " << +f.second);
---
>           NS_LOG_DEBUG ("Setting frequency to " << f.first << "; width to " << f.second);
1609c1324
<       NS_FATAL_ERROR ("Frequency not found for channel number " << +nch);
---
>       NS_FATAL_ERROR ("Frequency not found for channel number " << nch);
1613c1328
< uint8_t
---
> uint16_t
1620c1335
< WifiPhy::DoChannelSwitch (uint8_t nch)
---
> WifiPhy::DoChannelSwitch (uint16_t nch)
1622,1675d1336
<   m_powerRestricted = false;
<   m_channelAccessRequested = false;
<   if (!IsInitialized ())
<     {
<       //this is not channel switch, this is initialization
<       NS_LOG_DEBUG ("initialize to channel " << +nch);
<       return true;
<     }
< 
<   NS_ASSERT (!IsStateSwitching ());
<   switch (m_state->GetState ())
<     {
<     case WifiPhyState::RX:
<       NS_LOG_DEBUG ("drop packet because of channel switching while reception");
<       m_endPhyRxEvent.Cancel ();
<       m_endRxEvent.Cancel ();
<       m_endPreambleDetectionEvent.Cancel ();
<       goto switchChannel;
<       break;
<     case WifiPhyState::TX:
<       NS_LOG_DEBUG ("channel switching postponed until end of current transmission");
<       Simulator::Schedule (GetDelayUntilIdle (), &WifiPhy::SetChannelNumber, this, nch);
<       break;
<     case WifiPhyState::CCA_BUSY:
<     case WifiPhyState::IDLE:
<       if (m_endPreambleDetectionEvent.IsRunning ())
<         {
<           m_endPreambleDetectionEvent.Cancel ();
<           m_endRxEvent.Cancel ();
<         }
<       goto switchChannel;
<       break;
<     case WifiPhyState::SLEEP:
<       NS_LOG_DEBUG ("channel switching ignored in sleep mode");
<       break;
<     default:
<       NS_ASSERT (false);
<       break;
<     }
< 
<   return false;
< 
< switchChannel:
< 
<   NS_LOG_DEBUG ("switching channel " << +GetChannelNumber () << " -> " << +nch);
<   m_state->SwitchToChannelSwitching (GetChannelSwitchDelay ());
<   m_interference.EraseEvents ();
<   /*
<    * Needed here to be able to correctly sensed the medium for the first
<    * time after the switching. The actual switching is not performed until
<    * after m_channelSwitchDelay. Packets received during the switching
<    * state are added to the event list and are employed later to figure
<    * out the state of the medium after the switching.
<    */
1680c1341
< WifiPhy::DoFrequencySwitch (uint16_t frequency)
---
> WifiPhy::DoFrequencySwitch (uint32_t frequency)
1682,1735d1342
<   m_powerRestricted = false;
<   m_channelAccessRequested = false;
<   if (!IsInitialized ())
<     {
<       //this is not channel switch, this is initialization
<       NS_LOG_DEBUG ("start at frequency " << frequency);
<       return true;
<     }
< 
<   NS_ASSERT (!IsStateSwitching ());
<   switch (m_state->GetState ())
<     {
<     case WifiPhyState::RX:
<       NS_LOG_DEBUG ("drop packet because of channel/frequency switching while reception");
<       m_endPhyRxEvent.Cancel ();
<       m_endRxEvent.Cancel ();
<       m_endPreambleDetectionEvent.Cancel ();
<       goto switchFrequency;
<       break;
<     case WifiPhyState::TX:
<       NS_LOG_DEBUG ("channel/frequency switching postponed until end of current transmission");
<       Simulator::Schedule (GetDelayUntilIdle (), &WifiPhy::SetFrequency, this, frequency);
<       break;
<     case WifiPhyState::CCA_BUSY:
<     case WifiPhyState::IDLE:
<       if (m_endPreambleDetectionEvent.IsRunning ())
<         {
<           m_endPreambleDetectionEvent.Cancel ();
<           m_endRxEvent.Cancel ();
<         }
<       goto switchFrequency;
<       break;
<     case WifiPhyState::SLEEP:
<       NS_LOG_DEBUG ("frequency switching ignored in sleep mode");
<       break;
<     default:
<       NS_ASSERT (false);
<       break;
<     }
< 
<   return false;
< 
< switchFrequency:
< 
<   NS_LOG_DEBUG ("switching frequency " << GetFrequency () << " -> " << frequency);
<   m_state->SwitchToChannelSwitching (GetChannelSwitchDelay ());
<   m_interference.EraseEvents ();
<   /*
<    * Needed here to be able to correctly sensed the medium for the first
<    * time after the switching. The actual switching is not performed until
<    * after m_channelSwitchDelay. Packets received during the switching
<    * state are added to the event list and are employed later to figure
<    * out the state of the medium after the switching.
<    */
1739,1846d1345
< void
< WifiPhy::SetSleepMode (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_powerRestricted = false;
<   m_channelAccessRequested = false;
<   switch (m_state->GetState ())
<     {
<     case WifiPhyState::TX:
<       NS_LOG_DEBUG ("setting sleep mode postponed until end of current transmission");
<       Simulator::Schedule (GetDelayUntilIdle (), &WifiPhy::SetSleepMode, this);
<       break;
<     case WifiPhyState::RX:
<       NS_LOG_DEBUG ("setting sleep mode postponed until end of current reception");
<       Simulator::Schedule (GetDelayUntilIdle (), &WifiPhy::SetSleepMode, this);
<       break;
<     case WifiPhyState::SWITCHING:
<       NS_LOG_DEBUG ("setting sleep mode postponed until end of channel switching");
<       Simulator::Schedule (GetDelayUntilIdle (), &WifiPhy::SetSleepMode, this);
<       break;
<     case WifiPhyState::CCA_BUSY:
<     case WifiPhyState::IDLE:
<       NS_LOG_DEBUG ("setting sleep mode");
<       m_state->SwitchToSleep ();
<       break;
<     case WifiPhyState::SLEEP:
<       NS_LOG_DEBUG ("already in sleep mode");
<       break;
<     default:
<       NS_ASSERT (false);
<       break;
<     }
< }
< 
< void
< WifiPhy::SetOffMode (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_powerRestricted = false;
<   m_channelAccessRequested = false;
<   m_endPhyRxEvent.Cancel ();
<   m_endRxEvent.Cancel ();
<   m_endPreambleDetectionEvent.Cancel ();
<   m_endTxEvent.Cancel ();
<   m_state->SwitchToOff ();
< }
< 
< void
< WifiPhy::ResumeFromSleep (void)
< {
<   NS_LOG_FUNCTION (this);
<   switch (m_state->GetState ())
<     {
<     case WifiPhyState::TX:
<     case WifiPhyState::RX:
<     case WifiPhyState::IDLE:
<     case WifiPhyState::CCA_BUSY:
<     case WifiPhyState::SWITCHING:
<       {
<         NS_LOG_DEBUG ("not in sleep mode, there is nothing to resume");
<         break;
<       }
<     case WifiPhyState::SLEEP:
<       {
<         NS_LOG_DEBUG ("resuming from sleep mode");
<         Time delayUntilCcaEnd = m_interference.GetEnergyDuration (m_ccaEdThresholdW);
<         m_state->SwitchFromSleep (delayUntilCcaEnd);
<         break;
<       }
<     default:
<       {
<         NS_ASSERT (false);
<         break;
<       }
<     }
< }
< 
< void
< WifiPhy::ResumeFromOff (void)
< {
<   NS_LOG_FUNCTION (this);
<   switch (m_state->GetState ())
<     {
<     case WifiPhyState::TX:
<     case WifiPhyState::RX:
<     case WifiPhyState::IDLE:
<     case WifiPhyState::CCA_BUSY:
<     case WifiPhyState::SWITCHING:
<     case WifiPhyState::SLEEP:
<       {
<         NS_LOG_DEBUG ("not in off mode, there is nothing to resume");
<         break;
<       }
<     case WifiPhyState::OFF:
<       {
<         NS_LOG_DEBUG ("resuming from off mode");
<         Time delayUntilCcaEnd = m_interference.GetEnergyDuration (m_ccaEdThresholdW);
<         m_state->SwitchFromOff (delayUntilCcaEnd);
<         break;
<       }
<     default:
<       {
<         NS_ASSERT (false);
<         break;
<       }
<     }
< }
< 
1848c1347
< WifiPhy::GetHtPhyHeaderMode ()
---
> WifiPhy::GetHtPlcpHeaderMode (WifiMode payloadMode)
1854c1353
< WifiPhy::GetVhtPhyHeaderMode ()
---
> WifiPhy::GetVhtPlcpHeaderMode (WifiMode payloadMode)
1859,1870d1357
< WifiMode
< WifiPhy::GetHePhyHeaderMode ()
< {
<   return WifiPhy::GetHeMcs0 ();
< }
< 
< Time
< WifiPhy::GetPreambleDetectionDuration (void)
< {
<   return MicroSeconds (4);
< }
< 
1872c1359
< WifiPhy::GetPhyTrainingSymbolDuration (WifiTxVector txVector)
---
> WifiPhy::GetPlcpHtTrainingSymbolDuration (WifiPreamble preamble, WifiTxVector txVector)
1903c1390
<   switch (txVector.GetPreambleType ())
---
>   switch (preamble)
1909,1910c1396
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_VHT_MU:
---
>     case WIFI_PREAMBLE_VHT:
1912,1914d1397
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_HE_MU:
<       return MicroSeconds (4 + (8 * Ndltf));
1915a1399
>       //no training for non HT
1921c1405
< WifiPhy::GetPhyHtSigHeaderDuration (WifiPreamble preamble)
---
> WifiPhy::GetPlcpHtSigHeaderDuration (WifiPreamble preamble)
1936c1420
< WifiPhy::GetPhySigA1Duration (WifiPreamble preamble)
---
> WifiPhy::GetPlcpVhtSigA1Duration (WifiPreamble preamble)
1940,1944c1424,1425
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_MU:
<       //VHT-SIG-A1 and HE-SIG-A1
---
>     case WIFI_PREAMBLE_VHT:
>       //VHT-SIG-A1
1947c1428
<       // no SIG-A1
---
>       // no VHT-SIG-A1 for non VHT
1953c1434
< WifiPhy::GetPhySigA2Duration (WifiPreamble preamble)
---
> WifiPhy::GetPlcpVhtSigA2Duration (WifiPreamble preamble)
1957,1961c1438,1439
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_MU:
<       //VHT-SIG-A2 and HE-SIG-A2
---
>     case WIFI_PREAMBLE_VHT:
>       //VHT-SIG-A2
1964c1442
<       // no SIG-A2
---
>       // no VHT-SIG-A2 for non VHT
1970c1448
< WifiPhy::GetPhySigBDuration (WifiPreamble preamble)
---
> WifiPhy::GetPlcpVhtSigBDuration (WifiPreamble preamble)
1974,1975c1452,1453
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_MU:
---
>     case WIFI_PREAMBLE_VHT:
>       //VHT-SIG-B
1978c1456
<       // no SIG-B
---
>       // no VHT-SIG-B for non VHT
1984c1462
< WifiPhy::GetPhyHeaderMode (WifiTxVector txVector)
---
> WifiPhy::GetPlcpHeaderMode (WifiMode payloadMode, WifiPreamble preamble, WifiTxVector txVector)
1986,1987c1464
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   switch (preamble)
---
>   switch (payloadMode.GetModulationClass ())
1989,2054c1466,1499
<     //// WIGIG ////
<     case WIFI_PREAMBLE_DMG_CTRL:
<       return DmgWifiPhy::GetDMG_MCS0 ();
<     case WIFI_PREAMBLE_DMG_SC:
<       return DmgWifiPhy::GetDMG_MCS1 ();
<     case WIFI_PREAMBLE_DMG_OFDM:
<       return DmgWifiPhy::GetDMG_MCS13 ();
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       return DmgWifiPhy::GetEDMG_MCS0 ();
<     case WIFI_PREAMBLE_EDMG_SC:
<       return DmgWifiPhy::GetEDMG_SC_MCS1 ();
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       return DmgWifiPhy::GetEDMG_OFDM_MCS1 ();
<     //// WIGIG ////
<     case WIFI_PREAMBLE_LONG:
<     case WIFI_PREAMBLE_SHORT:
<       {
<         switch (txVector.GetMode ().GetModulationClass ())
<           {
<             case WIFI_MOD_CLASS_OFDM:
<               {
<                 switch (txVector.GetChannelWidth ())
<                   {
<                     case 5:
<                       return WifiPhy::GetOfdmRate1_5MbpsBW5MHz ();
<                     case 10:
<                       return WifiPhy::GetOfdmRate3MbpsBW10MHz ();
<                     case 20:
<                     default:
<                       //(Section 17.3.2 "PPDU frame format"; IEEE Std 802.11-2016)
<                       //actually this is only the first part of the PhyHeader,
<                       //because the last 16 bits of the PhyHeader are using the
<                       //same mode of the payload
<                       return WifiPhy::GetOfdmRate6Mbps ();
<                   }
<               }
<             case WIFI_MOD_CLASS_ERP_OFDM:
<               return WifiPhy::GetErpOfdmRate6Mbps ();
<             case WIFI_MOD_CLASS_DSSS:
<             case WIFI_MOD_CLASS_HR_DSSS:
<               {
<                 if (preamble == WIFI_PREAMBLE_LONG || txVector.GetMode () == WifiPhy::GetDsssRate1Mbps ())
<                   {
<                     //(Section 16.2.3 "PPDU field definitions" and Section 16.2.2.2 "Long PPDU format"; IEEE Std 802.11-2016)
<                     return WifiPhy::GetDsssRate1Mbps ();
<                   }
<                 else
<                   {
<                     //(Section 16.2.2.3 "Short PPDU format"; IEEE Std 802.11-2016)
<                     return WifiPhy::GetDsssRate2Mbps ();
<                   }
<               }
<             default:
<               NS_FATAL_ERROR ("unsupported modulation class");
<               return WifiMode ();
<           }
<       }
<     case WIFI_PREAMBLE_HT_MF:
<     case WIFI_PREAMBLE_HT_GF:
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_HE_ER_SU:
<     case WIFI_PREAMBLE_HE_MU:
<     case WIFI_PREAMBLE_HE_TB:
<       return WifiPhy::GetOfdmRate6Mbps ();
---
>     case WIFI_MOD_CLASS_OFDM:
>     case WIFI_MOD_CLASS_HT:
>     case WIFI_MOD_CLASS_VHT:
>       switch (txVector.GetChannelWidth ())
>         {
>         case 5:
>           return WifiPhy::GetOfdmRate1_5MbpsBW5MHz ();
>         case 10:
>           return WifiPhy::GetOfdmRate3MbpsBW10MHz ();
>         case 20:
>         case 40:
>         case 80:
>         case 160:
>         default:
>           //(Section 18.3.2 "PLCP frame format"; IEEE Std 802.11-2012)
>           //actually this is only the first part of the PlcpHeader,
>           //because the last 16 bits of the PlcpHeader are using the
>           //same mode of the payload
>           return WifiPhy::GetOfdmRate6Mbps ();
>         }
>     case WIFI_MOD_CLASS_ERP_OFDM:
>       return WifiPhy::GetErpOfdmRate6Mbps ();
>     case WIFI_MOD_CLASS_DSSS:
>     case WIFI_MOD_CLASS_HR_DSSS:
>       if (preamble == WIFI_PREAMBLE_LONG || payloadMode == WifiPhy::GetDsssRate1Mbps ())
>         {
>           //(Section 16.2.3 "PLCP field definitions" and Section 17.2.2.2 "Long PPDU format"; IEEE Std 802.11-2012)
>           return WifiPhy::GetDsssRate1Mbps ();
>         }
>       else //WIFI_PREAMBLE_SHORT
>         {
>           //(Section 17.2.2.3 "Short PPDU format"; IEEE Std 802.11-2012)
>           return WifiPhy::GetDsssRate2Mbps ();
>         }
2056c1501
<       NS_FATAL_ERROR ("unsupported preamble type");
---
>       NS_FATAL_ERROR ("unsupported modulation class");
2062c1507
< WifiPhy::GetPhyHeaderDuration (WifiTxVector txVector)
---
> WifiPhy::GetPlcpHeaderDuration (WifiTxVector txVector, WifiPreamble preamble)
2064,2065c1509
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   switch (txVector.GetPreambleType ())
---
>   if (preamble == WIFI_PREAMBLE_NONE)
2067,2090c1511,1515
<     //// WIGIG ////
<     case WIFI_PREAMBLE_DMG_CTRL:
<       /* From Annex L (L.5.2.5) */
<       return NanoSeconds (4654);
<     case WIFI_PREAMBLE_DMG_SC:
<       /* From Table 21-4 in 802.11ad spec 21.3.4 */
<       return NanoSeconds (582);
<     case WIFI_PREAMBLE_DMG_OFDM:
<       /* From Table 21-4 in 802.11ad spec 21.3.4 */
<       return NanoSeconds (242);
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       /* From Annex L (L.5.2.5) */
<       /* For EDMG STAs: the L-Header + EDMG-Header-A1 get encoded in the first LDCP codeword - same duration as L-Header (4654).
<        * EDMG-Header-A2 + bits from the payload get encoded in the second LDCP codeword - calculated by GetEDMG_HeaderA_Duration */
<       return NanoSeconds (4654) + GetEDMG_HeaderA_Duration (txVector);
<     case WIFI_PREAMBLE_EDMG_SC:
<       /* From Table 21-4 in 802.11ad spec 21.3.4 */
<       return NanoSeconds (582) + GetEDMG_HeaderA_Duration (txVector) + GetEDMG_HeaderB_Duration (txVector);
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       /* From Table 21-4 in 802.11ad spec 21.3.4 */
<       return NanoSeconds (242) + GetEDMG_HeaderA_Duration (txVector) + GetEDMG_HeaderB_Duration (txVector);
<     //// WIGIG ////
<     case WIFI_PREAMBLE_LONG:
<     case WIFI_PREAMBLE_SHORT:
---
>       return MicroSeconds (0);
>     }
>   switch (txVector.GetMode ().GetModulationClass ())
>     {
>     case WIFI_MOD_CLASS_OFDM:
2092c1517
<         switch (txVector.GetMode ().GetModulationClass ())
---
>         switch (txVector.GetChannelWidth ())
2094,2115c1519,1526
<           case WIFI_MOD_CLASS_OFDM:
<             {
<               switch (txVector.GetChannelWidth ())
<                 {
<                 case 20:
<                 default:
<                   //(Section 17.3.3 "PHY preamble (SYNC))" and Figure 17-4 "OFDM training structure"; IEEE Std 802.11-2016)
<                   //also (Section 17.3.2.4 "Timing related parameters" Table 17-5 "Timing-related parameters"; IEEE Std 802.11-2016)
<                   //We return the duration of the SIGNAL field only, since the
<                   //SERVICE field (which strictly speaking belongs to the PHY
<                   //header, see Section 17.3.2 and Figure 17-1) is sent using the
<                   //payload mode.
<                   return MicroSeconds (4);
<                 case 10:
<                   //(Section 17.3.2.4 "Timing related parameters" Table 17-5 "Timing-related parameters"; IEEE Std 802.11-2016)
<                   return MicroSeconds (8);
<                 case 5:
<                   //(Section 17.3.2.4 "Timing related parameters" Table 17-5 "Timing-related parameters"; IEEE Std 802.11-2016)
<                   return MicroSeconds (16);
<                 }
<             }
<           case WIFI_MOD_CLASS_ERP_OFDM:
---
>           case 20:
>           default:
>             //(Section 18.3.3 "PLCP preamble (SYNC))" and Figure 18-4 "OFDM training structure"; IEEE Std 802.11-2012)
>             //also (Section 18.3.2.4 "Timing related parameters" Table 18-5 "Timing-related parameters"; IEEE Std 802.11-2012)
>             //We return the duration of the SIGNAL field only, since the
>             //SERVICE field (which strictly speaking belongs to the PLCP
>             //header, see Section 18.3.2 and Figure 18-1) is sent using the
>             //payload mode.
2117,2130c1528,1542
<           case WIFI_MOD_CLASS_DSSS:
<           case WIFI_MOD_CLASS_HR_DSSS:
<             {
<               if ((preamble == WIFI_PREAMBLE_SHORT) && (txVector.GetMode ().GetDataRate (22) > 1000000))
<                 {
<                   //(Section 16.2.2.3 "Short PPDU format" and Figure 16-2 "Short PPDU format"; IEEE Std 802.11-2016)
<                   return MicroSeconds (24);
<                 }
<               else
<                 {
<                   //(Section 16.2.2.2 "Long PPDU format" and Figure 16-1 "Short PPDU format"; IEEE Std 802.11-2016)
<                   return MicroSeconds (48);
<                 }
<             }
---
>           case 10:
>             //(Section 18.3.2.4 "Timing related parameters" Table 18-5 "Timing-related parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (8);
>           case 5:
>             //(Section 18.3.2.4 "Timing related parameters" Table 18-5 "Timing-related parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (16);
>           }
>       }
>     case WIFI_MOD_CLASS_HT:
>       {
>         //L-SIG
>         //IEEE 802.11n Figure 20.1
>         switch (preamble)
>           {
>           case WIFI_PREAMBLE_HT_MF:
2132c1544,1545
<             NS_FATAL_ERROR ("modulation class is not matching the preamble type");
---
>             return MicroSeconds (4);
>           case WIFI_PREAMBLE_HT_GF:
2136,2139c1549,1550
<     case WIFI_PREAMBLE_HT_MF:
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_VHT_MU:
<       //L-SIG
---
>     case WIFI_MOD_CLASS_VHT:
>     case WIFI_MOD_CLASS_ERP_OFDM:
2141,2148c1552,1563
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_HE_ER_SU:
<     case WIFI_PREAMBLE_HE_MU:
<     case WIFI_PREAMBLE_HE_TB:
<       //LSIG + R-LSIG
<       return MicroSeconds (8);
<     case WIFI_PREAMBLE_HT_GF:
<       return MicroSeconds (0);
---
>     case WIFI_MOD_CLASS_DSSS:
>     case WIFI_MOD_CLASS_HR_DSSS:
>       if ((preamble == WIFI_PREAMBLE_SHORT) && (txVector.GetMode ().GetDataRate (22, 0, 1) > 1000000))
>         {
>           //(Section 17.2.2.3 "Short PPDU format" and Figure 17-2 "Short PPDU format"; IEEE Std 802.11-2012)
>           return MicroSeconds (24);
>         }
>       else //WIFI_PREAMBLE_LONG
>         {
>           //(Section 17.2.2.2 "Long PPDU format" and Figure 17-1 "Short PPDU format"; IEEE Std 802.11-2012)
>           return MicroSeconds (48);
>         }
2150c1565
<       NS_FATAL_ERROR ("unsupported preamble type");
---
>       NS_FATAL_ERROR ("unsupported modulation class");
2156c1571
< WifiPhy::GetStartOfPacketDuration (WifiTxVector txVector)
---
> WifiPhy::GetPlcpPreambleDuration (WifiTxVector txVector, WifiPreamble preamble)
2158,2165c1573,1577
<   return MicroSeconds (4);
< }
< 
< Time
< WifiPhy::GetPhyPreambleDuration (WifiTxVector txVector)
< {
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   switch (txVector.GetPreambleType ())
---
>   if (preamble == WIFI_PREAMBLE_NONE)
>     {
>       return MicroSeconds (0);
>     }
>   switch (txVector.GetMode ().GetModulationClass ())
2167,2195c1579
<     //// WIGIG ////
<     case WIFI_PREAMBLE_DMG_CTRL:
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       // CTRL Preamble = (6400 + 1152) Samples * Tc (Chip Time for SC), Tc = Tccp = 0.57ns.
<       // CTRL Preamble = 4.291 micro seconds.
<       return NanoSeconds (4291);
< 
<     case WIFI_PREAMBLE_DMG_SC:
<       // SC Preamble = 3328 Samples (STF: 2176 + CEF: 1152) * Tc (Chip Time for SC), Tc = 0.57ns.
<       // SC Preamble = 1.89 micro seconds.
<       return NanoSeconds (1891);
< 
<     case WIFI_PREAMBLE_DMG_OFDM:
<       // OFDM Preamble = 4992 Samples (STF: 2176 + CEF: 1152) * Ts (Chip Time for OFDM), Tc = 0.38ns.
<       // OFDM Preamble = 1.89 micro seconds.
<       return NanoSeconds (1891);
< 
<     case WIFI_PREAMBLE_EDMG_SC:
<       // SC Preamble = 3328 Samples (STF: 2176 + CEF: 1152) * Tc (Chip Time for SC), Tc = 0.57ns.
<       // SC Preamble = 1.89 micro seconds.
<       return NanoSeconds (1891) + GetEDMGPreambleDuration (txVector);
< 
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       // OFDM Preamble = 4992 Samples (STF: 2176 + CEF: 1152) * Ts (Chip Time for OFDM), Tc = 0.38ns.
<       // OFDM Preamble = 1.89 micro seconds.
<       return NanoSeconds (1891) + GetEDMGPreambleDuration (txVector);
<     //// WIGIG ////
<     case WIFI_PREAMBLE_LONG:
<     case WIFI_PREAMBLE_SHORT:
---
>     case WIFI_MOD_CLASS_OFDM:
2197c1581
<         switch (txVector.GetMode ().GetModulationClass ())
---
>         switch (txVector.GetChannelWidth ())
2199,2236c1583,1595
<             case WIFI_MOD_CLASS_OFDM:
<               {
<                 switch (txVector.GetChannelWidth ())
<                   {
<                     case 20:
<                     default:
<                       //(Section 17.3.3 "PHY preamble (SYNC))" Figure 17-4 "OFDM training structure"
<                       //also Section 17.3.2.3 "Modulation-dependent parameters" Table 17-4 "Modulation-dependent parameters"; IEEE Std 802.11-2016)
<                       return MicroSeconds (16);
<                     case 10:
<                       //(Section 17.3.3 "PHY preamble (SYNC))" Figure 17-4 "OFDM training structure"
<                       //also Section 17.3.2.3 "Modulation-dependent parameters" Table 17-4 "Modulation-dependent parameters"; IEEE Std 802.11-2016)
<                       return MicroSeconds (32);
<                     case 5:
<                       //(Section 17.3.3 "PHY preamble (SYNC))" Figure 17-4 "OFDM training structure"
<                       //also Section 17.3.2.3 "Modulation-dependent parameters" Table 17-4 "Modulation-dependent parameters"; IEEE Std 802.11-2016)
<                       return MicroSeconds (64);
<                   }
<               }
<             case WIFI_MOD_CLASS_ERP_OFDM:
<               return MicroSeconds (16);
<             case WIFI_MOD_CLASS_DSSS:
<             case WIFI_MOD_CLASS_HR_DSSS:
<               {
<                 if ((preamble == WIFI_PREAMBLE_SHORT) && (txVector.GetMode ().GetDataRate (22) > 1000000))
<                   {
<                     //(Section 17.2.2.3 "Short PPDU format)" Figure 17-2 "Short PPDU format"; IEEE Std 802.11-2012)
<                     return MicroSeconds (72);
<                   }
<                 else
<                   {
<                     //(Section 17.2.2.2 "Long PPDU format)" Figure 17-1 "Long PPDU format"; IEEE Std 802.11-2012)
<                     return MicroSeconds (144);
<                   }
<               }
<             default:
<               NS_FATAL_ERROR ("modulation class is not matching the preamble type");
<               return MicroSeconds (0);
---
>           case 20:
>           default:
>             //(Section 18.3.3 "PLCP preamble (SYNC))" Figure 18-4 "OFDM training structure"
>             //also Section 18.3.2.3 "Modulation-dependent parameters" Table 18-4 "Modulation-dependent parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (16);
>           case 10:
>             //(Section 18.3.3 "PLCP preamble (SYNC))" Figure 18-4 "OFDM training structure"
>             //also Section 18.3.2.3 "Modulation-dependent parameters" Table 18-4 "Modulation-dependent parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (32);
>           case 5:
>             //(Section 18.3.3 "PLCP preamble (SYNC))" Figure 18-4 "OFDM training structure"
>             //also Section 18.3.2.3 "Modulation-dependent parameters" Table 18-4 "Modulation-dependent parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (64);
2239,2246c1598,1600
<     case WIFI_PREAMBLE_HT_MF:
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_HE_ER_SU:
<     case WIFI_PREAMBLE_HE_MU:
<     case WIFI_PREAMBLE_HE_TB:
<       //L-STF + L-LTF
---
>     case WIFI_MOD_CLASS_VHT:
>     case WIFI_MOD_CLASS_HT:
>       //IEEE 802.11n Figure 20.1 the training symbols before L_SIG or HT_SIG
2248,2249c1602
<     case WIFI_PREAMBLE_HT_GF:
<       //HT-GF-STF + HT-LTF1
---
>     case WIFI_MOD_CLASS_ERP_OFDM:
2250a1604,1615
>     case WIFI_MOD_CLASS_DSSS:
>     case WIFI_MOD_CLASS_HR_DSSS:
>       if ((preamble == WIFI_PREAMBLE_SHORT) && (txVector.GetMode ().GetDataRate (22, 0, 1) > 1000000))
>         {
>           //(Section 17.2.2.3 "Short PPDU format)" Figure 17-2 "Short PPDU format"; IEEE Std 802.11-2012)
>           return MicroSeconds (72);
>         }
>       else //WIFI_PREAMBLE_LONG
>         {
>           //(Section 17.2.2.2 "Long PPDU format)" Figure 17-1 "Long PPDU format"; IEEE Std 802.11-2012)
>           return MicroSeconds (144);
>         }
2252c1617
<       NS_FATAL_ERROR ("unsupported preamble type");
---
>       NS_FATAL_ERROR ("unsupported modulation class");
2258c1623
< WifiPhy::GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype)
---
> WifiPhy::GetPayloadDuration (uint32_t size, WifiTxVector txVector, WifiPreamble preamble, double frequency)
2260,2262c1625
<   uint32_t totalAmpduSize;
<   double totalAmpduNumSymbols;
<   return GetPayloadDuration (size, txVector, frequency, mpdutype, false, totalAmpduSize, totalAmpduNumSymbols);
---
>   return GetPayloadDuration (size, txVector, preamble, frequency, NORMAL_MPDU, 0);
2266,2267c1629
< WifiPhy::GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype,
<                              bool incFlag, uint32_t &totalAmpduSize, double &totalAmpduNumSymbols)
---
> WifiPhy::GetPayloadDuration (uint32_t size, WifiTxVector txVector, WifiPreamble preamble, double frequency, enum mpduType mpdutype, uint8_t incFlag)
2272,2768d1633
<   if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_DMG_CTRL)
<     {
<       uint32_t Ncw;                       /* Number of LDPC codewords. */
<       uint32_t Ldpcw;                     /* Number of bits in the second and any subsequent codeword except the last. */
<       uint32_t Ldplcw;                    /* Number of bits in the last codeword. */
<       uint32_t DencodedSymmbols;          /* Number of differentailly encoded payload symbols. */
<       uint32_t Chips;                     /* Number of chips (After spreading using Ga32 Golay Sequence). */
<       uint32_t Nbits = (size - 8) * 8;    /* Number of bits in the payload part. */
< 
<       Ncw = 1 + (uint32_t) ceil ((double (size) - 6) * 8/168);
<       Ldpcw = (uint32_t) ceil ((double (size) - 6) * 8/(Ncw - 1));
<       Ldplcw = (size - 6) * 8 - (Ncw - 2) * Ldpcw;
<       DencodedSymmbols = (672 - (504 - Ldpcw)) * (Ncw - 2) + (672 - (504 - Ldplcw));
<       //      DencodedSymmbols = (Ldpcw + 168) * (Ncw-2) + Ldplcw + 168;
<       Chips = DencodedSymmbols * 32;
<       /* Make sure the result is in nanoseconds. */
<       double ret = double (Chips)/1.76;
<       NS_LOG_DEBUG ("bits " << Nbits << " Diff encoded Symmbols " << DencodedSymmbols << " rate " << payloadMode.GetDataRate() << " Payload Time " << ret << " ns");
< 
<       return NanoSeconds (ceil (ret));
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_DMG_LP_SC)
<     {
<       //        uint32_t Nbits = (size * 8);  /* Number of bits in the payload part. */
<       //        uint32_t Nrsc;                /* The total number of Reed Solomon codewords */
<       //        uint32_t Nrses;               /* The total number of Reed Solomon encoded symbols */
<       //        Nrsc = (uint32_t) ceil(Nbits/208);
<       //        Nrses = Nbits + Nrsc * 16;
< 
<       //        uint32_t Nsbc;                 /* Short Block code Size */
<       //        if (payloadMode.GetCodeRate() == WIFI_CODE_RATE_13_28)
<       //          Nsbc = 16;
<       //        else if (payloadMode.GetCodeRate() == WIFI_CODE_RATE_13_21)
<       //          Nsbc = 12;
<       //        else if (payloadMode.GetCodeRate() == WIFI_CODE_RATE_52_63)
<       //          Nsbc = 9;
<       //        else if (payloadMode.GetCodeRate() == WIFI_CODE_RATE_13_14)
<       //          Nsbc = 8;
<       //        else
<       //          NS_FATAL_ERROR("unsupported code rate");
< 
<       //        uint32_t Ncbps;               /* Ncbps = Number of coded bits per symbol. Check Table 21-21 for different constellations. */
<       //        if (payloadMode.GetConstellationSize() == 2)
<       //          Ncbps = 336;
<       //        else if (payloadMode.GetConstellationSize() == 4)
<       //          Ncbps = 2 * 336;
<       //          NS_FATAL_ERROR("unsupported constellation size");
< 
<       //        uint32_t Neb;                 /* Total number of encoded bits */
<       //        uint32_t Nblks;               /* Total number of 512 blocks containing 392 data symbols */
<       //        Neb = Nsbc * Nrses;
<       //        Nblks = (uint32_t) ceil(neb/());
<       return NanoSeconds (0);
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_DMG_SC)
<     {
<       /* 21.3.4 Timeing Related Parameters, Table 21-4 TData = (Nblks * 512 + 64) * Tc. */
<       /* 21.6.3.2.3.3 (4), Compute Nblks = The number of symbol blocks. */
< 
<       uint32_t Ncbpb; // Ncbpb = Number of coded bits per symbol block. Check Table 21-20 for different constellations.
<       if (payloadMode.GetConstellationSize () == 2)
<         Ncbpb = 448;
<       else if (payloadMode.GetConstellationSize () == 4)
<         Ncbpb = 2 * 448;
<       else if (payloadMode.GetConstellationSize () == 16)
<         Ncbpb = 4 * 448;
<       else if (payloadMode.GetConstellationSize () == 64)
<         Ncbpb = 6 * 448;
<       else
<         NS_FATAL_ERROR ("unsupported constellation size");
< 
<       uint32_t Nbits = (size * 8); /* Nbits = Number of bits in the payload part. */
<       uint32_t Ncbits;             /* Ncbits = Number of coded bits in the payload part. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_4)
<         Ncbits = Nbits * 4;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_2)
<         Ncbits = Nbits * 2;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_13_16)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 16.0 / 13);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_3_4)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 4.0 / 3);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 5);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_7_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 7);
<       else
<         NS_FATAL_ERROR ("unsupported code rate");
< 
<       uint16_t Lcw; /* The LDPC codeword length. */
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_7_8)
<         Lcw = 624;
<       else
<         Lcw = 672;
< 
<       uint32_t Ncw = (uint32_t) ceil (double (Ncbits) / double (Lcw));  /* Ncw = The number of LDPC codewords. */
<       uint32_t Nblks = (uint32_t) ceil (double (Ncw) * double (Lcw) / Ncbpb);  /* Nblks = The number of symbol blocks. */
< 
<       /* Make sure the result is in nanoseconds. */
<       uint32_t tData = lrint (ceil ((double (Nblks) * 512 + 64) / 1.76)); /* The duration of the data part */
<       NS_LOG_DEBUG ("bits " << Nbits << " cbits " << Ncbits
<                     << " Ncw " << Ncw
<                     << " Nblks " << Nblks
<                     << " rate " << payloadMode.GetDataRate() << " Payload Time " << tData << " ns");
< 
<       if (txVector.GetTrainngFieldLength () != 0)
<         {
<           if (tData < OFDMSCMin)
<             tData = OFDMSCMin;
<         }
<       return NanoSeconds (tData);
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_DMG_OFDM)
<     {
<       /* 21.3.4 Timeing Related Parameters, Table 21-4 TData = Nsym * Tsys(OFDM) */
<       /* 21.5.3.2.3.3 (5), Compute Nsym = Number of OFDM Symbols */
< 
<       uint32_t Ncbps; // Ncbps = Number of coded bits per symbol. Check Table 21-20 for different constellations.
<       if (payloadMode.GetConstellationSize () == 2)
<         Ncbps = 336;
<       else if (payloadMode.GetConstellationSize () == 4)
<         Ncbps = 2 * 336;
<       else if (payloadMode.GetConstellationSize () == 16)
<         Ncbps = 4 * 336;
<       else if (payloadMode.GetConstellationSize () == 64)
<         Ncbps = 6 * 336;
<       else
<         NS_FATAL_ERROR ("unsupported constellation size");
< 
<       uint32_t Nbits = (size * 8); /* Nbits = Number of bits in the payload part. */
<       uint32_t Ncbits;             /* Ncbits = Number of coded bits in the payload part. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_4)
<         Ncbits = Nbits * 4;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_2)
<         Ncbits = Nbits * 2;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_13_16)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 16.0 / 13);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_3_4)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 4.0 / 3);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 5);
<       else
<         NS_FATAL_ERROR ("unsupported code rate");
< 
<       uint32_t Ncw = (uint32_t) ceil (double (Ncbits) / 672.0);         /* Ncw = The number of LDPC codewords.  */
<       uint32_t Nsym = (uint32_t) ceil (double (Ncw * 672.0) / Ncbps);   /* Nsym = Number of OFDM Symbols. */
< 
<       /* Make sure the result is in nanoseconds */
<       uint32_t tData;       /* The duration of the data part */
<       tData = Nsym * 242;   /* Tsys(OFDM) = 242ns */
<       NS_LOG_DEBUG ("bits " << Nbits << " cbits " << Ncbits << " rate " << payloadMode.GetDataRate() << " Payload Time " << tData << " ns");
< 
<       if (txVector.GetTrainngFieldLength () != 0)
<         {
<           if (tData < OFDMBRPMin)
<             tData = OFDMBRPMin;
<         }
<       return NanoSeconds (tData);
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL)
<     {
<       uint32_t Ncw;                       /* Number of LDPC codewords. */
<       uint32_t Ldpcw;                     /* Number of bits in the second and any subsequent codeword except the last. */
<       uint32_t Ldplcw;                    /* Number of bits in the last codeword. */
<       uint32_t DencodedSymmbols;          /* Number of differentailly encoded payload symbols. */
<       uint32_t Chips;                     /* Number of chips (After spreading using Ga32 Golay Sequence). */
<       uint32_t Nbits = (size - 8) * 8;    /* Number of bits in the payload part. */
< 
<       Ncw = 1 + (uint32_t) ceil ((double (size) + L_EDMG_Header_A2) * 8/168);
<       Ldpcw = (uint32_t) ceil ((double (size) + L_EDMG_Header_A2) * 8/(Ncw - 1));
<       Ldplcw = (size + L_EDMG_Header_A2) * 8 - (Ncw - 2) * Ldpcw;
<       //DencodedSymmbols = (672 - (504 - Ldpcw)) * (Ncw - 3) + (672 - (504 - Ldplcw));
<       // Change to Ncw-3 once the duration of Header A is calculated properly
<       DencodedSymmbols = (Ldpcw + 168) * (Ncw-2) + (Ldplcw +168);
<       Chips = DencodedSymmbols * 32;
< 
<       /* Make sure the result is in nanoseconds. */
<       double ret = double (Chips)/1.76;
<       NS_LOG_DEBUG ("bits " << Nbits << " Diff encoded Symmbols " << DencodedSymmbols << " rate " << payloadMode.GetDataRate() << " Payload Time " << ret << " ns");
< 
<       return NanoSeconds (ceil (ret));
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_EDMG_SC)
<     {
<       /* 29.12.3.3 TXTIME calculation for EDMG SC mode, TData = (Nblks * 512 + Ngi) * Tc. */
<       /* 29.5.9.4 (d4), Compute Nblks = The number of symbol blocks. */
< 
<       //Once multiple users are enabled - calculate Nblcks for each user - then set Nblks to the maximum Nblks from all users - for loop for all users
<       uint16_t Nspb;  /* Number of symbols per SC symbol block for GI length. */
< 
<       if (txVector.GetGaurdIntervalType () == GI_SHORT)
<         Nspb = 480 * txVector.GetNCB ();
<       else if (txVector.GetGaurdIntervalType () == GI_NORMAL)
<         Nspb = 448 * txVector.GetNCB ();
<       else if (txVector.GetGaurdIntervalType () == GI_LONG)
<         Nspb = 384 * txVector.GetNCB ();
<       else
<         NS_FATAL_ERROR ("Unsupported guard interval length");
< 
<       // For now we are assuming that the same MCS is used for all STS
<       uint32_t Ncbps; // Ncbps = Number of coded bits per symbol. Check Table 21-20 for different constellations.
<       if (payloadMode.GetConstellationSize () == 2)
<         Ncbps = 1;
<       else if (payloadMode.GetConstellationSize () == 4)
<         Ncbps = 2;
<       else if (payloadMode.GetConstellationSize () == 16)
<         Ncbps = 4;
<       else if (payloadMode.GetConstellationSize () == 64)
<         Ncbps = 6;
<       else
<         NS_FATAL_ERROR ("unsupported constellation size");
< 
<       Ncbps = Ncbps * txVector.Get_NUM_STS ();
< 
<       uint32_t Nbits = (size * 8); /* Nbits = Number of bits in the payload part. */
<       uint32_t Ncbits;             /* Ncbits = Number of coded bits in the payload part. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_4)
<         Ncbits = Nbits * 4;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_2)
<         Ncbits = Nbits * 2;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_13_16)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 16.0 / 13);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_3_4)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 4.0 / 3);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 5);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_7_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 7);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_2_3)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 3.0 / 2);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_6)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 6.0 / 5);
<       else
<         NS_FATAL_ERROR ("unsupported code rate");
< 
<       uint16_t Lcw; /* The LDPC codeword length. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_2_3 || payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_6)
<         Lcw = 504;
<       else
<         Lcw = 672;
<       if (txVector.GetLdcpCwLength ())
<         {
<           Lcw = Lcw * 2;
<         }
< 
<       uint32_t Ncw = (uint32_t) ceil (double (Ncbits) / double (Lcw));  /* Ncw = The number of LDPC codewords. */
<       uint32_t Nblks = (uint32_t) ceil ((double (Ncw) * double (Lcw)) / (Ncbps * Nspb));  /* Nblks = The number of symbol blocks. */
< 
<       if (txVector.GetEDMGTrainingFieldLength () != 0)
<         {
<           if (Nblks < aBRPminSCblocks)
<             Nblks = aBRPminSCblocks;
<         }
< 
<       uint8_t Ngi = 0; /* the size of the guard interval */
< 
<       if (txVector.GetGaurdIntervalType () == GI_LONG)
<         Ngi = 128;
<       else if (txVector.GetGaurdIntervalType () == GI_NORMAL)
<         Ngi = 64;
<       else if (txVector.GetGaurdIntervalType () == GI_SHORT)
<         {
<           if ((txVector.GetNumUsers () == 1) && ((txVector.GetTransmitMask () != CH_BANDWIDTH_216) || (txVector.Get_NUM_STS () != 1)))
<             Ngi = 32;
<           else
<             Ngi = 64;
<         }
< 
<       /* Make sure the result is in nanoseconds. */
<       uint32_t tData = lrint (ceil ((double (Nblks) * 512 + Ngi) / 1.76)); /* The duration of the data part */
<       NS_LOG_DEBUG ("bits " << Nbits
<                     << " cbits " << Ncbits
<                     << " Ncbps " << Ncbps
<                     << " Nspb " << Nspb
<                     << " Ncw " << Ncw
<                     << " Nblks " << Nblks
<                     << " data-rate " << payloadMode.GetDataRate()
<                     << " phy-rate " << payloadMode.GetPhyRate ()
<                     << " Payload Time " << tData << " ns");
< 
<       return NanoSeconds (tData);
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_EDMG_OFDM)
<     {
<       /* 29.12.3.4 TXTIME calculation for EDMG OFDM mode, TData = (Nsym * (512 + Ngi)) * Ts */
<       /* 21.5.3.2.3.3 (5), Compute Nsym = Number of OFDM Symbols */
< 
<       //Once multiple users are enabled - calculate Nsym for each user - then set Nsym to the maximum Nsym from all users - for loop for all users
< 
<       uint32_t Nsd; // Nsd = Number of data subcarriers.
<       if (txVector.GetNCB () == 1)
<         Nsd = 336;
<       else if (txVector.GetNCB () == 2)
<         Nsd = 734;
<       else if (txVector.GetNCB () == 3)
<         Nsd = 1134;
<       else if (txVector.GetNCB () == 4)
<         Nsd = 1532;
<       else
<         NS_FATAL_ERROR("Unsupported number of continous channels");
< 
<       // Once multimple space-time streams are enabled - sum the Nbpsc for all space-time streams.
<       uint32_t Nbpsc; // Nbpsc = Number of coded bits per constellation point Check Table 115 (ayD4) for different constellations.
<       if (payloadMode.GetConstellationSize () == 2)
<         Nbpsc = 1;
<       else if (payloadMode.GetConstellationSize () == 4)
<         Nbpsc = 2;
<       else if (payloadMode.GetConstellationSize () == 16)
<         Nbpsc = 4;
<       else if (payloadMode.GetConstellationSize () == 64)
<         Nbpsc = 6;
<       else
<         NS_FATAL_ERROR ("unsupported constellation size");
< 
<       // For MIMO case
<       Nbpsc = Nbpsc * txVector.Get_NUM_STS ();
< 
<       uint32_t Ncbps; // Ncbps = Number of coded bits per symbol. Check Table 21-20 for different constellations.
<       Ncbps = Nsd * Nbpsc;
< 
<       uint32_t Nbits = (size * 8); /* Nbits = Number of bits in the payload part. */
<       uint32_t Ncbits;             /* Ncbits = Number of coded bits in the payload part. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_2)
<         Ncbits = Nbits * 2;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_7_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 7);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_13_16)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 16.0 / 13);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_3_4)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 4.0 / 3);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 5);
<       else
<         NS_FATAL_ERROR ("unsupported code rate");
< 
<       uint16_t Lcw; /* The LDPC codeword length. */
<       Lcw = 672;
<       if (txVector.GetLdcpCwLength ())
<         {
<           Lcw = Lcw * 2;
<         }
< 
<       uint32_t Ncw = (uint32_t) ceil (double (Ncbits) / double (Lcw)); /* Ncw = The number of LDPC codewords.  */
<       uint32_t Nsym = (uint32_t) ceil (double (Ncw * Lcw) / Ncbps);    /* Nsym = Number of OFDM Symbols. */
< 
<       if (txVector.GetEDMGTrainingFieldLength () != 0)
<         {
<           if (Nsym < aBRPminOFDMblocks)
<             Nsym = aBRPminOFDMblocks;
<         }
< 
<       uint8_t Ngi = 0; /* the size of the guard interval */
<       if (txVector.GetGaurdIntervalType () == GI_LONG)
<         Ngi = 192;
<       else if (txVector.GetGaurdIntervalType () == GI_NORMAL)
<         Ngi = 96;
<       else if (txVector.GetGaurdIntervalType () == GI_SHORT)
<         Ngi = 48;
< 
<       /* Make sure the result is in nanoseconds */
<       uint32_t tData;       /* The duration of the data part */
<       tData = lrint (ceil ((double (Nsym * (512 + Ngi)) / 2.64))); /* The duration of the data part */
<       NS_LOG_DEBUG ("bits " << Nbits << " cbits " << Ncbits << " rate " << payloadMode.GetDataRate() << " Payload Time " << tData << " ns");
< 
<       if (txVector.GetTrainngFieldLength () != 0)
<         {
<           if (tData < OFDMBRPMin)
<             tData = OFDMBRPMin;
<         }
<       return NanoSeconds (tData);
<     }
< 
<   double stbc = 1;
<   if (txVector.IsStbc ()
<       && (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_HT
<           || payloadMode.GetModulationClass () == WIFI_MOD_CLASS_VHT))
<     {
<       stbc = 2;
<     }
< 
<   double Nes = 1;
<   //todo: improve logic to reduce the number of if cases
<   //todo: extend to NSS > 4 for VHT rates
<   if (payloadMode == GetHtMcs21 ()
<       || payloadMode == GetHtMcs22 ()
<       || payloadMode == GetHtMcs23 ()
<       || payloadMode == GetHtMcs28 ()
<       || payloadMode == GetHtMcs29 ()
<       || payloadMode == GetHtMcs30 ()
<       || payloadMode == GetHtMcs31 ())
<     {
<       Nes = 2;
<     }
<   if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
<     {
<       if (txVector.GetChannelWidth () == 40
<           && txVector.GetNss () == 3
<           && payloadMode.GetMcsValue () >= 8)
<         {
<           Nes = 2;
<         }
<       if (txVector.GetChannelWidth () == 80
<           && txVector.GetNss () == 2
<           && payloadMode.GetMcsValue () >= 7)
<         {
<           Nes = 2;
<         }
<       if (txVector.GetChannelWidth () == 80
<           && txVector.GetNss () == 3
<           && payloadMode.GetMcsValue () >= 7)
<         {
<           Nes = 2;
<         }
<       if (txVector.GetChannelWidth () == 80
<           && txVector.GetNss () == 3
<           && payloadMode.GetMcsValue () == 9)
<         {
<           Nes = 3;
<         }
<       if (txVector.GetChannelWidth () == 80
<           && txVector.GetNss () == 4
<           && payloadMode.GetMcsValue () >= 4)
<         {
<           Nes = 2;
<         }
<       if (txVector.GetChannelWidth () == 80
<           && txVector.GetNss () == 4
<           && payloadMode.GetMcsValue () >= 7)
<         {
<           Nes = 3;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && payloadMode.GetMcsValue () >= 7)
<         {
<           Nes = 2;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && txVector.GetNss () == 2
<           && payloadMode.GetMcsValue () >= 4)
<         {
<           Nes = 2;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && txVector.GetNss () == 2
<           && payloadMode.GetMcsValue () >= 7)
<         {
<           Nes = 3;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && txVector.GetNss () == 3
<           && payloadMode.GetMcsValue () >= 3)
<         {
<           Nes = 2;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && txVector.GetNss () == 3
<           && payloadMode.GetMcsValue () >= 5)
<         {
<           Nes = 3;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && txVector.GetNss () == 3
<           && payloadMode.GetMcsValue () >= 7)
<         {
<           Nes = 4;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && txVector.GetNss () == 4
<           && payloadMode.GetMcsValue () >= 2)
<         {
<           Nes = 2;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && txVector.GetNss () == 4
<           && payloadMode.GetMcsValue () >= 4)
<         {
<           Nes = 3;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && txVector.GetNss () == 4
<           && payloadMode.GetMcsValue () >= 5)
<         {
<           Nes = 4;
<         }
<       if (txVector.GetChannelWidth () == 160
<           && txVector.GetNss () == 4
<           && payloadMode.GetMcsValue () >= 7)
<         {
<           Nes = 6;
<         }
<     }
< 
<   Time symbolDuration = Seconds (0);
2775a1641,1642
>         Time symbolDuration;
> 
2789,2812d1655
<         break;
<       }
<     case WIFI_MOD_CLASS_HT:
<     case WIFI_MOD_CLASS_VHT:
<       {
<         //if short GI data rate is used then symbol duration is 3.6us else symbol duration is 4us
<         //In the future has to create a station manager that only uses these data rates if sender and receiver support GI
<         uint16_t gi = txVector.GetGuardInterval ();
<         NS_ASSERT (gi == 400 || gi == 800);
<         symbolDuration = NanoSeconds (3200 + gi);
<       }
<       break;
<     case WIFI_MOD_CLASS_HE:
<       {
<         //if short GI data rate is used then symbol duration is 3.6us else symbol duration is 4us
<         //In the future has to create a station manager that only uses these data rates if sender and receiver support GI
<         uint16_t gi = txVector.GetGuardInterval ();
<         NS_ASSERT (gi == 800 || gi == 1600 || gi == 3200);
<         symbolDuration = NanoSeconds (12800 + gi);
<       }
<       break;
<     default:
<       break;
<     }
2814c1657,1660
<   double numDataBitsPerSymbol = payloadMode.GetDataRate (txVector) * symbolDuration.GetNanoSeconds () / 1e9;
---
>         //(Section 18.3.2.3 "Modulation-dependent parameters" Table 18-4 "Modulation-dependent parameters"; IEEE Std 802.11-2012)
>         //corresponds to N_{DBPS} in the table
>         double numDataBitsPerSymbol = payloadMode.GetDataRate (txVector.GetChannelWidth (), 0, 1) * symbolDuration.GetNanoSeconds () / 1e9;
>         double numSymbols;
2816,2860c1662,1703
<   double numSymbols = 0;
<   if (mpdutype == FIRST_MPDU_IN_AGGREGATE)
<     {
<       //First packet in an A-MPDU
<       numSymbols = (stbc * (16 + size * 8.0 + 6 * Nes) / (stbc * numDataBitsPerSymbol));
<       if (incFlag == 1)
<         {
<           totalAmpduSize += size;
<           totalAmpduNumSymbols += numSymbols;
<         }
<     }
<   else if (mpdutype == MIDDLE_MPDU_IN_AGGREGATE)
<     {
<       //consecutive packets in an A-MPDU
<       numSymbols = (stbc * size * 8.0) / (stbc * numDataBitsPerSymbol);
<       if (incFlag == 1)
<         {
<           totalAmpduSize += size;
<           totalAmpduNumSymbols += numSymbols;
<         }
<     }
<   else if (mpdutype == LAST_MPDU_IN_AGGREGATE)
<     {
<       //last packet in an A-MPDU
<       uint32_t totalSize = totalAmpduSize + size;
<       numSymbols = lrint (stbc * ceil ((16 + totalSize * 8.0 + 6 * Nes) / (stbc * numDataBitsPerSymbol)));
<       NS_ASSERT (totalAmpduNumSymbols <= numSymbols);
<       numSymbols -= totalAmpduNumSymbols;
<       if (incFlag == 1)
<         {
<           totalAmpduSize = 0;
<           totalAmpduNumSymbols = 0;
<         }
<     }
<   else if (mpdutype == NORMAL_MPDU || mpdutype == SINGLE_MPDU)
<     {
<       //Not an A-MPDU or single MPDU (i.e. the current payload contains both service and padding)
<       //The number of OFDM symbols in the data field when BCC encoding
<       //is used is given in equation 19-32 of the IEEE 802.11-2016 standard.
<       numSymbols = lrint (stbc * ceil ((16 + size * 8.0 + 6.0 * Nes) / (stbc * numDataBitsPerSymbol)));
<     }
<   else
<     {
<       NS_FATAL_ERROR ("Unknown MPDU type");
<     }
---
>         if (mpdutype == MPDU_IN_AGGREGATE && preamble != WIFI_PREAMBLE_NONE)
>           {
>             //First packet in an A-MPDU
>             numSymbols = ((16 + size * 8.0 + 6) / numDataBitsPerSymbol);
>             if (incFlag == 1)
>               {
>                 m_totalAmpduSize += size;
>                 m_totalAmpduNumSymbols += numSymbols;
>               }
>           }
>         else if (mpdutype == MPDU_IN_AGGREGATE && preamble == WIFI_PREAMBLE_NONE)
>           {
>             //consecutive packets in an A-MPDU
>             numSymbols = ((size * 8.0) / numDataBitsPerSymbol);
>             if (incFlag == 1)
>               {
>                 m_totalAmpduSize += size;
>                 m_totalAmpduNumSymbols += numSymbols;
>               }
>           }
>         else if (mpdutype == LAST_MPDU_IN_AGGREGATE && preamble == WIFI_PREAMBLE_NONE)
>           {
>             //last packet in an A-MPDU
>             uint32_t totalAmpduSize = m_totalAmpduSize + size;
>             numSymbols = lrint (ceil ((16 + totalAmpduSize * 8.0 + 6) / numDataBitsPerSymbol));
>             NS_ASSERT (m_totalAmpduNumSymbols <= numSymbols);
>             numSymbols -= m_totalAmpduNumSymbols;
>             if (incFlag == 1)
>               {
>                 m_totalAmpduSize = 0;
>                 m_totalAmpduNumSymbols = 0;
>               }
>           }
>         else if (mpdutype == NORMAL_MPDU && preamble != WIFI_PREAMBLE_NONE)
>           {
>             //Not an A-MPDU
>             numSymbols = lrint (ceil ((16 + size * 8.0 + 6.0) / numDataBitsPerSymbol));
>           }
>         else
>           {
>             NS_FATAL_ERROR ("Wrong combination of preamble and packet type");
>           }
2862,2866d1704
<   switch (payloadMode.GetModulationClass ())
<     {
<     case WIFI_MOD_CLASS_OFDM:
<     case WIFI_MOD_CLASS_ERP_OFDM:
<       {
2870c1708
<             return FemtoSeconds (static_cast<uint64_t> (numSymbols * symbolDuration.GetFemtoSeconds ())) + MicroSeconds (6);
---
>             return FemtoSeconds (numSymbols * symbolDuration.GetFemtoSeconds ()) + MicroSeconds (6);
2874c1712
<             return FemtoSeconds (static_cast<uint64_t> (numSymbols * symbolDuration.GetFemtoSeconds ()));
---
>             return FemtoSeconds (numSymbols * symbolDuration.GetFemtoSeconds ());
2880,2881c1718,1722
<         if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_HT && Is2_4Ghz (frequency)
<             && (mpdutype == NORMAL_MPDU || mpdutype == SINGLE_MPDU || mpdutype == LAST_MPDU_IN_AGGREGATE)) //at 2.4 GHz
---
>         Time symbolDuration;
>         double m_Stbc;
>         //if short GI data rate is used then symbol duration is 3.6us else symbol duration is 4us
>         //In the future has to create a stationmanager that only uses these data rates if sender and reciever support GI
>         if (txVector.IsShortGuardInterval ())
2883c1724
<             return FemtoSeconds (static_cast<uint64_t> (numSymbols * symbolDuration.GetFemtoSeconds ())) + MicroSeconds (6);
---
>             symbolDuration = NanoSeconds (3600);
2885c1726
<         else //at 5 GHz
---
>         else
2887c1728
<             return FemtoSeconds (static_cast<uint64_t> (numSymbols * symbolDuration.GetFemtoSeconds ()));
---
>             symbolDuration = MicroSeconds (4);
2889,2893c1730,1731
<       }
<     case WIFI_MOD_CLASS_HE:
<       {
<         if (Is2_4Ghz (frequency)
<             && ((mpdutype == NORMAL_MPDU || mpdutype == SINGLE_MPDU || mpdutype == LAST_MPDU_IN_AGGREGATE))) //at 2.4 GHz
---
> 
>         if (txVector.IsStbc ())
2895c1733
<             return FemtoSeconds (static_cast<uint64_t> (numSymbols * symbolDuration.GetFemtoSeconds ())) + MicroSeconds (6);
---
>             m_Stbc = 2;
2897c1735
<         else //at 5 GHz
---
>         else
2899c1737
<             return FemtoSeconds (static_cast<uint64_t> (numSymbols * symbolDuration.GetFemtoSeconds ()));
---
>             m_Stbc = 1;
2901,2909d1738
<       }
<     case WIFI_MOD_CLASS_DSSS:
<     case WIFI_MOD_CLASS_HR_DSSS:
<       return MicroSeconds (lrint (ceil ((size * 8.0) / (payloadMode.GetDataRate (22) / 1.0e6))));
<     default:
<       NS_FATAL_ERROR ("unsupported modulation class");
<       return MicroSeconds (0);
<     }
< }
2911,2925c1740,1849
< //// WIGIG ////
< Time
< WifiPhy::GetEDMGPreambleDuration (WifiTxVector txVector)
< {
<   switch (txVector.GetMode ().GetModulationClass ())
<     {
<     case WIFI_MOD_CLASS_EDMG_SC:
<       if ((txVector.GetNumUsers () == 1) && (txVector.GetTransmitMask () == CH_BANDWIDTH_216) && (txVector.Get_NUM_STS () == 1))
<         {
<           return NanoSeconds (0);
<         }
<       else if ((txVector.GetNumUsers () >= 1) && ((txVector.GetTransmitMask () != CH_BANDWIDTH_216) || (txVector.Get_NUM_STS () != 1)))
<         {
<           return NanoSeconds (1380 + (1152 + 1280 * (txVector.Get_SC_EDMG_CEF () - 1))/1.76);
<         }
---
>         //check tables 20-35 and 20-36 in the .11n standard to get cases when nes = 2
>         double Nes = 1;
>         if (payloadMode.GetUniqueName () == "HtMcs21"
>            || payloadMode.GetUniqueName () == "HtMcs22"
>            || payloadMode.GetUniqueName () == "HtMcs23"
>            || payloadMode.GetUniqueName () == "HtMcs28"
>            || payloadMode.GetUniqueName () == "HtMcs29"
>            || payloadMode.GetUniqueName () == "HtMcs30"
>            || payloadMode.GetUniqueName () == "HtMcs31")
>           {
>             Nes = 2;
>           }
>         //check tables 22-30 to 22-61 in the .11ac standard to get cases when nes > 1
>         //todo: improve logic to reduce the number of if cases
>         //todo: extend to NSS > 4 for VHT rates
>         if (txVector.GetChannelWidth () == 40
>             && txVector.GetNss () == 3
>             && payloadMode.GetMcsValue () >= 8)
>           {
>             Nes = 2;
>           }
>         if (txVector.GetChannelWidth () == 80
>             && txVector.GetNss () == 2
>             && payloadMode.GetMcsValue () >= 7)
>           {
>             Nes = 2;
>           }
>         if (txVector.GetChannelWidth () == 80
>             && txVector.GetNss () == 3
>             && payloadMode.GetMcsValue () >= 7)
>           {
>             Nes = 2;
>           }
>         if (txVector.GetChannelWidth () == 80
>             && txVector.GetNss () == 3
>             && payloadMode.GetMcsValue () == 9)
>           {
>             Nes = 3;
>           }
>         if (txVector.GetChannelWidth () == 80
>             && txVector.GetNss () == 4
>             && payloadMode.GetMcsValue () >= 4)
>           {
>             Nes = 2;
>           }
>         if (txVector.GetChannelWidth () == 80
>             && txVector.GetNss () == 4
>             && payloadMode.GetMcsValue () >= 7)
>           {
>             Nes = 3;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && payloadMode.GetMcsValue () >= 7)
>           {
>             Nes = 2;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && txVector.GetNss () == 2
>             && payloadMode.GetMcsValue () >= 4)
>           {
>             Nes = 2;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && txVector.GetNss () == 2
>             && payloadMode.GetMcsValue () >= 7)
>           {
>             Nes = 3;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && txVector.GetNss () == 3
>             && payloadMode.GetMcsValue () >= 3)
>           {
>             Nes = 2;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && txVector.GetNss () == 3
>             && payloadMode.GetMcsValue () >= 5)
>           {
>             Nes = 3;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && txVector.GetNss () == 3
>             && payloadMode.GetMcsValue () >= 7)
>           {
>             Nes = 4;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && txVector.GetNss () == 4
>             && payloadMode.GetMcsValue () >= 2)
>           {
>             Nes = 2;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && txVector.GetNss () == 4
>             && payloadMode.GetMcsValue () >= 4)
>           {
>             Nes = 3;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && txVector.GetNss () == 4
>             && payloadMode.GetMcsValue () >= 5)
>           {
>             Nes = 4;
>           }
>         if (txVector.GetChannelWidth () == 160
>             && txVector.GetNss () == 4
>             && payloadMode.GetMcsValue () >= 7)
>           {
>             Nes = 6;
>           }
2927,2930c1851,1853
<     case WIFI_MOD_CLASS_EDMG_OFDM:
<       // OFDM Preamble = 4992 Samples (STF: 2176 + CEF: 1152) * Ts (Chip Time for OFDM), Tc = 0.38ns.
<       // OFDM Preamble = 1.89 micro seconds.
<       return NanoSeconds (1450 + (704 * txVector.Get_OFDM_EDMG_CEF ())/1.76);
---
>         //IEEE Std 802.11n, section 20.3.11, equation (20-32)
>         double numDataBitsPerSymbol = payloadMode.GetDataRate (txVector.GetChannelWidth (), txVector.IsShortGuardInterval (), txVector.GetNss ()) * symbolDuration.GetNanoSeconds () / 1e9;
>         double numSymbols;
2932,2936c1855,1896
<     default:
<       NS_FATAL_ERROR ("Unsupported EDMG preamble");
<       return MicroSeconds (0);
<     }
< }
---
>         if (mpdutype == MPDU_IN_AGGREGATE && preamble != WIFI_PREAMBLE_NONE)
>           {
>             //First packet in an A-MPDU
>             numSymbols = (m_Stbc * (16 + size * 8.0 + 6 * Nes) / (m_Stbc * numDataBitsPerSymbol));
>             if (incFlag == 1)
>               {
>                 m_totalAmpduSize += size;
>                 m_totalAmpduNumSymbols += numSymbols;
>               }
>           }
>         else if (mpdutype == MPDU_IN_AGGREGATE && preamble == WIFI_PREAMBLE_NONE)
>           {
>             //consecutive packets in an A-MPDU
>             numSymbols = (m_Stbc * size * 8.0) / (m_Stbc * numDataBitsPerSymbol);
>             if (incFlag == 1)
>               {
>                 m_totalAmpduSize += size;
>                 m_totalAmpduNumSymbols += numSymbols;
>               }
>           }
>         else if (mpdutype == LAST_MPDU_IN_AGGREGATE && preamble == WIFI_PREAMBLE_NONE)
>           {
>             //last packet in an A-MPDU
>             uint32_t totalAmpduSize = m_totalAmpduSize + size;
>             numSymbols = lrint (m_Stbc * ceil ((16 + totalAmpduSize * 8.0 + 6 * Nes) / (m_Stbc * numDataBitsPerSymbol)));
>             NS_ASSERT (m_totalAmpduNumSymbols <= numSymbols);
>             numSymbols -= m_totalAmpduNumSymbols;
>             if (incFlag == 1)
>               {
>                 m_totalAmpduSize = 0;
>                 m_totalAmpduNumSymbols = 0;
>               }
>           }
>         else if (mpdutype == NORMAL_MPDU && preamble != WIFI_PREAMBLE_NONE)
>           {
>             //Not an A-MPDU
>             numSymbols = lrint (m_Stbc * ceil ((16 + size * 8.0 + 6.0 * Nes) / (m_Stbc * numDataBitsPerSymbol)));
>           }
>         else
>           {
>             NS_FATAL_ERROR ("Wrong combination of preamble and packet type");
>           }
2938,2952c1898,1905
< Time
< WifiPhy::GetEDMG_HeaderA_Duration (WifiTxVector txVector)
< {
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   switch (preamble)
<     {
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       {
< //        uint32_t Ncw;                       /* Number of LDPC codewords. */
< //        uint32_t Ldpcw;                     /* Number of bits in the second and any subsequent codeword except the last. */
< //        Ncw = 1 + (uint32_t) ceil ((double (size) + L_EDMG_Header_A2) * 8/168);
< //        Ldpcw = (uint32_t) ceil ((double (size) + L_EDMG_Header_A2) * 8/(Ncw - 1));
< //        double ret = double ((Ldpcw + 168) * 32)/1.76;
< //        return NanoSeconds (ceil (ret));
<         return NanoSeconds (0);
---
>         if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_HT && frequency >= 2400 && frequency <= 2500 && ((mpdutype == NORMAL_MPDU && preamble != WIFI_PREAMBLE_NONE) || (mpdutype == LAST_MPDU_IN_AGGREGATE && preamble == WIFI_PREAMBLE_NONE))) //at 2.4 GHz
>           {
>             return FemtoSeconds (numSymbols * symbolDuration.GetFemtoSeconds ()) + MicroSeconds (6);
>           }
>         else //at 5 GHz
>           {
>             return FemtoSeconds (numSymbols * symbolDuration.GetFemtoSeconds ());
>           }
2954,2999c1907,1913
< 
<     case WIFI_PREAMBLE_EDMG_SC:
<       if ((txVector.GetNumUsers () == 1) && (txVector.GetTransmitMask () == CH_BANDWIDTH_216) && (txVector.Get_NUM_STS () == 1))
<         {
<           return NanoSeconds (580);
<         }
<       else if ((txVector.GetNumUsers () >= 1) && ((txVector.GetTransmitMask () != CH_BANDWIDTH_216) || (txVector.Get_NUM_STS () != 1)))
<         {
<           return NanoSeconds (620);
<         }
< 
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       return NanoSeconds (620);
< 
<     default:
<       NS_FATAL_ERROR ("Unsupported EDMG preamble for Header-A");
<       return MicroSeconds (0);
<     }
< }
< 
< Time
< WifiPhy::GetEDMG_HeaderB_Duration (WifiTxVector txVector)
< {
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   switch (preamble)
<     {
<     case WIFI_PREAMBLE_EDMG_SC:
<       if (txVector.GetNumUsers () == 1)
<         {
<           return NanoSeconds (0);
<         }
<       else if (txVector.GetNumUsers () >= 1)
<         {
<           return NanoSeconds (290);
<         }
< 
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       if (txVector.GetNumUsers () == 1)
<         {
<           return NanoSeconds (0);
<         }
<       else if (txVector.GetNumUsers () >= 1)
<         {
<           return NanoSeconds ((512 + txVector.GetGuardInterval ())/2.64);
<         }
< 
---
>     case WIFI_MOD_CLASS_DSSS:
>     case WIFI_MOD_CLASS_HR_DSSS:
>       //(Section 17.2.3.6 "Long PLCP LENGTH field"; IEEE Std 802.11-2012)
>       NS_LOG_LOGIC (" size=" << size
>                              << " mode=" << payloadMode
>                              << " rate=" << payloadMode.GetDataRate (22, 0, 1));
>       return MicroSeconds (lrint (ceil ((size * 8.0) / (payloadMode.GetDataRate (22, 0, 1) / 1.0e6))));
3001c1915
<       NS_FATAL_ERROR ("Unsupported EDMG preamble for Header-B");
---
>       NS_FATAL_ERROR ("unsupported modulation class");
3007c1921
< WifiPhy::GetLastRxDuration (void) const
---
> WifiPhy::CalculatePlcpPreambleAndHeaderDuration (WifiTxVector txVector, WifiPreamble preamble)
3009,3023c1923,1929
<   return m_rxDuration;
< }
< //// WIGIG ////
< 
< Time
< WifiPhy::CalculatePhyPreambleAndHeaderDuration (WifiTxVector txVector)
< {
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   Time duration = GetPhyPreambleDuration (txVector)
<     + GetPhyHeaderDuration (txVector)
<     + GetPhyHtSigHeaderDuration (preamble)
<     + GetPhySigA1Duration (preamble)
<     + GetPhySigA2Duration (preamble)
<     + GetPhyTrainingSymbolDuration (txVector)
<     + GetPhySigBDuration (preamble);
---
>   Time duration = GetPlcpPreambleDuration (txVector, preamble)
>     + GetPlcpHeaderDuration (txVector, preamble)
>     + GetPlcpHtSigHeaderDuration (preamble)
>     + GetPlcpVhtSigA1Duration (preamble)
>     + GetPlcpVhtSigA2Duration (preamble)
>     + GetPlcpHtTrainingSymbolDuration (preamble, txVector)
>     + GetPlcpVhtSigBDuration (preamble);
3028c1934
< WifiPhy::CalculateTxDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency)
---
> WifiPhy::CalculateTxDuration (uint32_t size, WifiTxVector txVector, WifiPreamble preamble, double frequency, enum mpduType mpdutype, uint8_t incFlag)
3030,3031c1936,1937
<   Time duration = CalculatePhyPreambleAndHeaderDuration (txVector)
<     + GetPayloadDuration (size, txVector, frequency);
---
>   Time duration = CalculatePlcpPreambleAndHeaderDuration (txVector, preamble)
>     + GetPayloadDuration (size, txVector, preamble, frequency, mpdutype, incFlag);
3035,3227c1941,1942
< void
< WifiPhy::NotifyTxBegin (Ptr<const WifiPsdu> psdu, double txPowerW)
< {
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyTxBeginTrace (mpdu->GetProtocolDataUnit (), txPowerW);
<     }
< }
< 
< void
< WifiPhy::NotifyTxEnd (Ptr<const WifiPsdu> psdu)
< {
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyTxEndTrace (mpdu->GetProtocolDataUnit ());
<     }
< }
< 
< void
< WifiPhy::NotifyTxDrop (Ptr<const WifiPsdu> psdu)
< {
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyTxDropTrace (mpdu->GetProtocolDataUnit ());
<     }
< }
< 
< void
< WifiPhy::NotifyRxBegin (Ptr<const WifiPsdu> psdu)
< {
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyRxBeginTrace (mpdu->GetProtocolDataUnit ());
<     }
< }
< 
< void
< WifiPhy::NotifyRxEnd (Ptr<const WifiPsdu> psdu)
< {
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyRxEndTrace (mpdu->GetProtocolDataUnit ());
<     }
< }
< 
< void
< WifiPhy::NotifyRxDrop (Ptr<const WifiPsdu> psdu, WifiPhyRxfailureReason reason)
< {
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyRxDropTrace (mpdu->GetProtocolDataUnit (), reason);
<     }
< }
< 
< void
< WifiPhy::NotifyMonitorSniffRx (Ptr<const WifiPsdu> psdu, uint16_t channelFreqMhz, WifiTxVector txVector,
<                                SignalNoiseDbm signalNoise, std::vector<bool> statusPerMpdu)
< {
<   MpduInfo aMpdu;
<   if (psdu->IsAggregate ())
<     {
<       //Expand A-MPDU
<       NS_ASSERT_MSG (txVector.IsAggregation (), "TxVector with aggregate flag expected here according to PSDU");
<       aMpdu.mpduRefNumber = ++m_rxMpduReferenceNumber;
<       size_t nMpdus = psdu->GetNMpdus ();
<       NS_ASSERT_MSG (statusPerMpdu.size () == nMpdus, "Should have one reception status per MPDU");
<       aMpdu.type = (psdu->IsSingle ()) ? SINGLE_MPDU: FIRST_MPDU_IN_AGGREGATE;
<       for (size_t i = 0; i < nMpdus;)
<         {
<           if (statusPerMpdu.at (i)) //packet received without error, hand over to sniffer
<             {
<               m_phyMonitorSniffRxTrace (psdu->GetAmpduSubframe (i), channelFreqMhz, txVector, aMpdu, signalNoise);
<             }
<           ++i;
<           aMpdu.type = (i == (nMpdus - 1)) ? LAST_MPDU_IN_AGGREGATE : MIDDLE_MPDU_IN_AGGREGATE;
<         }
<     }
<   else
<     {
<       aMpdu.type = NORMAL_MPDU;
<       NS_ASSERT_MSG (statusPerMpdu.size () == 1, "Should have one reception status for normal MPDU");
<       m_phyMonitorSniffRxTrace (psdu->GetPacket (), channelFreqMhz, txVector, aMpdu, signalNoise);
<     }
< }
< 
< void
< WifiPhy::NotifyMonitorSniffTx (Ptr<const WifiPsdu> psdu, uint16_t channelFreqMhz, WifiTxVector txVector)
< {
<   MpduInfo aMpdu;
<   if (psdu->IsAggregate ())
<     {
<       //Expand A-MPDU
<       NS_ASSERT_MSG (txVector.IsAggregation (), "TxVector with aggregate flag expected here according to PSDU");
<       aMpdu.mpduRefNumber = ++m_rxMpduReferenceNumber;
<       size_t nMpdus = psdu->GetNMpdus ();
<       aMpdu.type = (psdu->IsSingle ()) ? SINGLE_MPDU: FIRST_MPDU_IN_AGGREGATE;
<       for (size_t i = 0; i < nMpdus;)
<         {
<           m_phyMonitorSniffTxTrace (psdu->GetAmpduSubframe (i), channelFreqMhz, txVector, aMpdu);
<           ++i;
<           aMpdu.type = (i == (nMpdus - 1)) ? LAST_MPDU_IN_AGGREGATE : MIDDLE_MPDU_IN_AGGREGATE;
<         }
<     }
<   else
<     {
<       aMpdu.type = NORMAL_MPDU;
<       m_phyMonitorSniffTxTrace (psdu->GetPacket (), channelFreqMhz, txVector, aMpdu);
<     }
< }
< 
< void
< WifiPhy::NotifyEndOfHePreamble (HePreambleParameters params)
< {
<   m_phyEndOfHePreambleTrace (params);
< }
< 
< void
< WifiPhy::Send (Ptr<const WifiPsdu> psdu, WifiTxVector txVector)
< {
<   NS_LOG_FUNCTION (this << *psdu << txVector);
<   /* Transmission can happen if:
<    *  - we are syncing on a packet. It is the responsibility of the
<    *    MAC layer to avoid doing this but the PHY does nothing to
<    *    prevent it.
<    *  - we are idle
<    */
<   NS_ASSERT (!m_state->IsStateTx () && !m_state->IsStateSwitching ());
<   NS_ASSERT (m_endTxEvent.IsExpired ());
< 
<   if (txVector.GetNss () > GetMaxSupportedTxSpatialStreams ())
<     {
<       NS_FATAL_ERROR ("Unsupported number of spatial streams!");
<     }
< 
<   if (m_state->IsStateSleep ())
<     {
<       NS_LOG_DEBUG ("Dropping packet because in sleep mode");
<       NotifyTxDrop (psdu);
<       return;
<     }
< 
<   Time txDuration = CalculateTxDuration (psdu->GetSize (), txVector, GetFrequency ());
<   NS_ASSERT (txDuration.IsStrictlyPositive ());
< 
<   if ((m_currentEvent != 0) && (m_currentEvent->GetEndTime () > (Simulator::Now () + m_state->GetDelayUntilIdle ())))
<     {
<       //that packet will be noise _after_ the transmission.
<       MaybeCcaBusyDuration ();
<     }
< 
<   if (m_currentEvent != 0)
<     {
<       AbortCurrentReception (RECEPTION_ABORTED_BY_TX);
<     }
< 
<   if (m_powerRestricted)
<     {
<       NS_LOG_DEBUG ("Transmitting with power restriction");
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Transmitting without power restriction");
<     }
< 
<   if (m_state->GetState () == WifiPhyState::OFF)
<     {
<       NS_LOG_DEBUG ("Transmission canceled because device is OFF");
<       return;
<     }
< 
<   double txPowerW = DbmToW (GetTxPowerForTransmission (txVector) + GetTxGain ());
<   NotifyTxBegin (psdu, txPowerW);
<   m_phyTxPsduBeginTrace (psdu, txVector, txPowerW);
<   NotifyMonitorSniffTx (psdu, GetFrequency (), txVector);
<   m_state->SwitchToTx (txDuration, psdu->GetPacket (), GetPowerDbm (txVector.GetTxPowerLevel ()), txVector);
< 
<   Ptr<WifiPpdu> ppdu = Create<WifiPpdu> (psdu, txVector, txDuration, GetFrequency ());
< 
<   if (m_wifiRadioEnergyModel != 0 && m_wifiRadioEnergyModel->GetMaximumTimeInState (WifiPhyState::TX) < txDuration)
<     {
<       ppdu->SetTruncatedTx ();
<     }
< 
<   m_endTxEvent = Simulator::Schedule (txDuration, &WifiPhy::NotifyTxEnd, this, psdu);
< 
<   StartTx (ppdu);
< 
<   m_channelAccessRequested = false;
<   m_powerRestricted = false;
< }
< 
< void
< WifiPhy::StartReceiveHeader (Ptr<Event> event)
---
> Time
> WifiPhy::CalculateTxDuration (uint32_t size, WifiTxVector txVector, WifiPreamble preamble, double frequency)
3229,3275c1944
<   NS_LOG_FUNCTION (this << *event);
<   NS_ASSERT (!IsStateRx ());
<   NS_ASSERT (m_endPhyRxEvent.IsExpired ());
<   NS_ASSERT (m_currentEvent != 0);
<   NS_ASSERT (event->GetStartTime () == m_currentEvent->GetStartTime ());
<   NS_ASSERT (event->GetEndTime () == m_currentEvent->GetEndTime ());
< 
<   InterferenceHelper::SnrPer snrPer = m_interference.CalculateNonHtPhyHeaderSnrPer (event);
<   double snr = snrPer.snr;
<   NS_LOG_DEBUG ("snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per);
< 
<   if (!m_preambleDetectionModel || (m_preambleDetectionModel->IsPreambleDetected (event->GetRxPowerW (), snr, m_channelWidth)))
<     {
<       NotifyRxBegin (event->GetPsdu ());
< 
<       m_timeLastPreambleDetected = Simulator::Now ();
<       WifiTxVector txVector = event->GetTxVector ();
< 
<       if ((txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT) && (txVector.GetPreambleType () == WIFI_PREAMBLE_HT_GF))
<         {
<           //No non-HT PHY header for HT GF
<           Time remainingPreambleHeaderDuration = CalculatePhyPreambleAndHeaderDuration (txVector) - GetPreambleDetectionDuration ();
<           m_state->SwitchMaybeToCcaBusy (remainingPreambleHeaderDuration);
<           m_endPhyRxEvent = Simulator::Schedule (remainingPreambleHeaderDuration, &WifiPhy::StartReceivePayload, this, event);
<         }
<       else
<         {
<           //Schedule end of non-HT PHY header
<           Time remainingPreambleAndNonHtHeaderDuration = GetPhyPreambleDuration (txVector) + GetPhyHeaderDuration (txVector) - GetPreambleDetectionDuration ();
<           m_state->SwitchMaybeToCcaBusy (remainingPreambleAndNonHtHeaderDuration);
<           m_endPhyRxEvent = Simulator::Schedule (remainingPreambleAndNonHtHeaderDuration, &WifiPhy::ContinueReceiveHeader, this, event);
<         }
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Drop packet because PHY preamble detection failed");
<       NotifyRxDrop (event->GetPsdu (), PREAMBLE_DETECT_FAILURE);
<       m_interference.NotifyRxEnd ();
<       m_currentEvent = 0;
< 
<       // Like CCA-SD, CCA-ED is governed by the 4μs CCA window to flag CCA-BUSY
<       // for any received signal greater than the CCA-ED threshold.
<       if (event->GetEndTime () > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           MaybeCcaBusyDuration ();
<         }
<     }
---
>   return CalculateTxDuration (size, txVector, preamble, frequency, NORMAL_MPDU, 0);
3279c1948
< WifiPhy::ContinueReceiveHeader (Ptr<Event> event)
---
> WifiPhy::NotifyTxBegin (Ptr<const Packet> packet)
3281,3304c1950
<   NS_LOG_FUNCTION (this << *event);
<   NS_ASSERT (m_endPhyRxEvent.IsExpired ());
< 
<   InterferenceHelper::SnrPer snrPer;
<   snrPer = m_interference.CalculateNonHtPhyHeaderSnrPer (event);
< 
<   if (m_random->GetValue () > snrPer.per) //non-HT PHY header reception succeeded
<     {
<       NS_LOG_DEBUG ("Received non-HT PHY header");
<       WifiTxVector txVector = event->GetTxVector ();
<       Time remainingRxDuration = event->GetEndTime () - Simulator::Now ();
<       m_state->SwitchMaybeToCcaBusy (remainingRxDuration);
<       Time remainingPreambleHeaderDuration = CalculatePhyPreambleAndHeaderDuration (txVector) - GetPhyPreambleDuration (txVector) - GetPhyHeaderDuration (txVector);
<       m_endPhyRxEvent = Simulator::Schedule (remainingPreambleHeaderDuration, &WifiPhy::StartReceivePayload, this, event);
<     }
<   else //non-HT PHY header reception failed
<     {
<       NS_LOG_DEBUG ("Abort reception because non-HT PHY header reception failed");
<       AbortCurrentReception (L_SIG_FAILURE);
<       if (event->GetEndTime () > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           MaybeCcaBusyDuration ();
<         }
<     }
---
>   m_phyTxBeginTrace (packet);
3308c1954
< WifiPhy::StartReceivePreamble (Ptr<WifiPpdu> ppdu, double rxPowerW)
---
> WifiPhy::NotifyTxEnd (Ptr<const Packet> packet)
3310,3443c1956
<   NS_LOG_FUNCTION (this << *ppdu << rxPowerW);
<   WifiTxVector txVector = ppdu->GetTxVector ();
<   Time rxDuration = ppdu->GetTxDuration ();
<   Ptr<const WifiPsdu> psdu = ppdu->GetPsdu ();
<   Ptr<Event> event = m_interference.Add (ppdu, txVector, rxDuration, rxPowerW);
<   Time endRx = Simulator::Now () + rxDuration;
< 
<   if (m_state->GetState () == WifiPhyState::OFF)
<     {
<       NS_LOG_DEBUG ("Cannot start RX because device is OFF");
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           MaybeCcaBusyDuration ();
<         }
<       return;
<     }
< 
<   if (ppdu->IsTruncatedTx ())
<     {
<       NS_LOG_DEBUG ("Packet reception stopped because transmitter has been switched off");
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           MaybeCcaBusyDuration ();
<         }
<       return;
<     }
< 
<   if (!txVector.GetModeInitialized ())
<     {
<       //If SetRate method was not called above when filling in txVector, this means the PHY does support the rate indicated in PHY SIG headers
<       NS_LOG_DEBUG ("drop packet because of unsupported RX mode");
<       NotifyRxDrop (psdu, UNSUPPORTED_SETTINGS);
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           MaybeCcaBusyDuration ();
<         }
<       return;
<     }
< 
<   switch (m_state->GetState ())
<     {
<     case WifiPhyState::SWITCHING:
<       NS_LOG_DEBUG ("drop packet because of channel switching");
<       NotifyRxDrop (psdu, CHANNEL_SWITCHING);
<       /*
<        * Packets received on the upcoming channel are added to the event list
<        * during the switching state. This way the medium can be correctly sensed
<        * when the device listens to the channel for the first time after the
<        * switching e.g. after channel switching, the channel may be sensed as
<        * busy due to other devices' transmissions started before the end of
<        * the switching.
<        */
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           //that packet will be noise _after_ the completion of the channel switching.
<           MaybeCcaBusyDuration ();
<         }
<       break;
<     case WifiPhyState::RX:
<       NS_ASSERT (m_currentEvent != 0);
<       if (m_frameCaptureModel != 0
<           && m_frameCaptureModel->IsInCaptureWindow (m_timeLastPreambleDetected)
<           && m_frameCaptureModel->CaptureNewFrame (m_currentEvent, event))
<         {
<           AbortCurrentReception (FRAME_CAPTURE_PACKET_SWITCH);
<           NS_LOG_DEBUG ("Switch to new packet");
<           StartRx (event, rxPowerW);
<         }
<       else
<         {
<           NS_LOG_DEBUG ("Drop packet because already in Rx (power=" <<
<                         rxPowerW << "W)");
<           NotifyRxDrop (psdu, RXING);
<           if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<             {
<               //that packet will be noise _after_ the reception of the currently-received packet.
<               MaybeCcaBusyDuration ();
<             }
<         }
<       break;
<     case WifiPhyState::TX:
<       NS_LOG_DEBUG ("Drop packet because already in Tx (power=" <<
<                     rxPowerW << "W)");
<       NotifyRxDrop (psdu, TXING);
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           //that packet will be noise _after_ the transmission of the currently-transmitted packet.
<           MaybeCcaBusyDuration ();
<         }
<       break;
<     case WifiPhyState::CCA_BUSY:
<       if (m_currentEvent != 0)
<         {
<           if (m_frameCaptureModel != 0
<               && m_frameCaptureModel->IsInCaptureWindow (m_timeLastPreambleDetected)
<               && m_frameCaptureModel->CaptureNewFrame (m_currentEvent, event))
<             {
<               AbortCurrentReception (FRAME_CAPTURE_PACKET_SWITCH);
<               NS_LOG_DEBUG ("Switch to new packet");
<               StartRx (event, rxPowerW);
<             }
<           else
<             {
<               NS_LOG_DEBUG ("Drop packet because already in Rx (power=" <<
<                             rxPowerW << "W)");
<               NotifyRxDrop (psdu, RXING);
<               if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<                 {
<                   //that packet will be noise _after_ the reception of the currently-received packet.
<                   MaybeCcaBusyDuration ();
<                 }
<             }
<         }
<       else
<         {
<           StartRx (event, rxPowerW);
<         }
<       break;
<     case WifiPhyState::IDLE:
<       StartRx (event, rxPowerW);
<       break;
<     case WifiPhyState::SLEEP:
<       NS_LOG_DEBUG ("Drop packet because in sleep mode");
<       NotifyRxDrop (psdu, SLEEPING);
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           //that packet will be noise _after_ the sleep period.
<           MaybeCcaBusyDuration ();
<         }
<       break;
<     default:
<       NS_FATAL_ERROR ("Invalid WifiPhy state.");
<       break;
<     }
---
>   m_phyTxEndTrace (packet);
3447c1960
< WifiPhy::MaybeCcaBusyDuration ()
---
> WifiPhy::NotifyTxDrop (Ptr<const Packet> packet)
3449,3463c1962
<   //We are here because we have received the first bit of a packet and we are
<   //not going to be able to synchronize on it
<   //In this model, CCA becomes busy when the aggregation of all signals as
<   //tracked by the InterferenceHelper class is higher than the CcaBusyThreshold
< 
<   Time delayUntilCcaEnd = m_interference.GetEnergyDuration (m_ccaEdThresholdW);
<   if (!delayUntilCcaEnd.IsZero ())
<     {
<       NS_LOG_DEBUG ("In CCA Busy State for " << delayUntilCcaEnd);
<       m_state->SwitchMaybeToCcaBusy (delayUntilCcaEnd);
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Not in CCA Busy State");
<     }
---
>   m_phyTxDropTrace (packet);
3467c1966
< WifiPhy::StartReceivePayload (Ptr<Event> event)
---
> WifiPhy::NotifyRxBegin (Ptr<const Packet> packet)
3469,3526c1968
<   NS_LOG_FUNCTION (this << *event);
<   NS_ASSERT (m_endPhyRxEvent.IsExpired ());
<   NS_ASSERT (m_endRxEvent.IsExpired ());
<   WifiTxVector txVector = event->GetTxVector ();
<   WifiMode txMode = txVector.GetMode ();
<   bool canReceivePayload;
<   if (txMode.GetModulationClass () >= WIFI_MOD_CLASS_HT)
<     {
<       InterferenceHelper::SnrPer snrPer;
<       snrPer = m_interference.CalculateHtPhyHeaderSnrPer (event);
<       NS_LOG_DEBUG ("snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per);
<       canReceivePayload = (m_random->GetValue () > snrPer.per);
<     }
<   else
<     {
<       //If we are here, this means non-HT PHY header was already successfully received
<       canReceivePayload = true;
<     }
<   Time payloadDuration = event->GetEndTime () - event->GetStartTime () - CalculatePhyPreambleAndHeaderDuration (txVector);
<   if (canReceivePayload) //PHY reception succeeded
<     {
<       if (txVector.GetNss () > GetMaxSupportedRxSpatialStreams ())
<         {
<           NS_LOG_DEBUG ("Packet reception could not be started because not enough RX antennas");
<           NotifyRxDrop (event->GetPsdu (), UNSUPPORTED_SETTINGS);
<         }
<       else if ((txVector.GetChannelWidth () >= 40) && (txVector.GetChannelWidth () > GetChannelWidth ()))
<         {
<           NS_LOG_DEBUG ("Packet reception could not be started because not enough channel width");
<           NotifyRxDrop (event->GetPsdu (), UNSUPPORTED_SETTINGS);
<         }
<       else if (!IsModeSupported (txMode) && !IsMcsSupported (txMode))
<         {
<           NS_LOG_DEBUG ("Drop packet because it was sent using an unsupported mode (" << txMode << ")");
<           NotifyRxDrop (event->GetPsdu (), UNSUPPORTED_SETTINGS);
<         }
<       else
<         {
<           m_state->SwitchToRx (payloadDuration);
<           m_endRxEvent = Simulator::Schedule (payloadDuration, &WifiPhy::EndReceive, this, event);
<           NS_LOG_DEBUG ("Receiving PSDU");
<           m_phyRxPayloadBeginTrace (txVector, payloadDuration); //this callback (equivalent to PHY-RXSTART primitive) is triggered only if headers have been correctly decoded and that the mode within is supported
<           if (txMode.GetModulationClass () == WIFI_MOD_CLASS_HE)
<             {
<               HePreambleParameters params;
<               params.rssiW = event->GetRxPowerW ();
<               params.bssColor = event->GetTxVector ().GetBssColor ();
<               NotifyEndOfHePreamble (params);
<             }
<           return;
<         }
<     }
<   else //PHY reception failed
<     {
<       NS_LOG_DEBUG ("Drop packet because HT PHY header reception failed");
<       NotifyRxDrop (event->GetPsdu (), SIG_A_FAILURE);
<     }
<   m_endRxEvent = Simulator::Schedule (payloadDuration, &WifiPhy::ResetReceive, this, event);
---
>   m_phyRxBeginTrace (packet);
3530c1972
< WifiPhy::EndReceive (Ptr<Event> event)
---
> WifiPhy::NotifyRxEnd (Ptr<const Packet> packet)
3532,3632c1974
<   Time psduDuration = event->GetEndTime () - event->GetStartTime ();
<   NS_LOG_FUNCTION (this << *event << psduDuration);
<   NS_ASSERT (GetLastRxEndTime () == Simulator::Now ());
<   NS_ASSERT (event->GetEndTime () == Simulator::Now ());
< 
<   double snr = m_interference.CalculateSnr (event);
<   std::vector<bool> statusPerMpdu;
<   SignalNoiseDbm signalNoise;
< 
<   Ptr<const WifiPsdu> psdu = event->GetPsdu ();
<   Time relativeStart = NanoSeconds (0);
<   bool receptionOkAtLeastForOneMpdu = false;
<   std::pair<bool, SignalNoiseDbm> rxInfo;
<   WifiTxVector txVector = event->GetTxVector ();
<   size_t nMpdus = psdu->GetNMpdus ();
<   if (nMpdus > 1)
<     {
<       //Extract all MPDUs of the A-MPDU to compute per-MPDU PER stats
<       Time remainingAmpduDuration = psduDuration;
<       MpduType mpdutype = FIRST_MPDU_IN_AGGREGATE;
<       auto mpdu = psdu->begin ();
<       uint32_t totalAmpduSize = 0;
<       double totalAmpduNumSymbols = 0.0;
<       for (size_t i = 0; i < nMpdus && mpdu != psdu->end (); ++mpdu)
<         {
<           Time mpduDuration = GetPayloadDuration (psdu->GetAmpduSubframeSize (i), txVector,
<                                                   GetFrequency (), mpdutype, true, totalAmpduSize, totalAmpduNumSymbols);
<           remainingAmpduDuration -= mpduDuration;
<           if (i == (nMpdus - 1) && !remainingAmpduDuration.IsZero ()) //no more MPDU coming
<             {
<               mpduDuration += remainingAmpduDuration; //apply a correction just in case rounding had induced slight shift
<             }
<           rxInfo = GetReceptionStatus (Create<WifiPsdu> (*mpdu, false),
<                                        event, relativeStart, mpduDuration);
<           NS_LOG_DEBUG ("Extracted MPDU #" << i << ": duration: " << mpduDuration.GetNanoSeconds () << "ns" <<
<                         ", correct reception: " << rxInfo.first <<
<                         ", Signal/Noise: " << rxInfo.second.signal << "/" << rxInfo.second.noise << "dBm");
<           signalNoise = rxInfo.second; //same information for all MPDUs
<           statusPerMpdu.push_back (rxInfo.first);
<           receptionOkAtLeastForOneMpdu |= rxInfo.first;
< 
<           //Prepare next iteration
<           ++i;
<           relativeStart += mpduDuration;
<           mpdutype = (i == (nMpdus - 1)) ? LAST_MPDU_IN_AGGREGATE : MIDDLE_MPDU_IN_AGGREGATE;
<         }
<     }
<   else
<     {
<       rxInfo = GetReceptionStatus (psdu, event, relativeStart, psduDuration);
<       signalNoise = rxInfo.second; //same information for all MPDUs
<       statusPerMpdu.push_back (rxInfo.first);
<       receptionOkAtLeastForOneMpdu = rxInfo.first;
<     }
< 
<   NotifyRxEnd (psdu);
< 
<   if (receptionOkAtLeastForOneMpdu)
<     {
<       NotifyMonitorSniffRx (psdu, GetFrequency (), txVector, signalNoise, statusPerMpdu);
<       m_state->SwitchFromRxEndOk (Copy (psdu), snr, txVector, statusPerMpdu);
<     }
<   else
<     {
<       m_state->SwitchFromRxEndError (Copy (psdu), snr);
<     }
< 
<   m_interference.NotifyRxEnd ();
<   m_currentEvent = 0;
<   MaybeCcaBusyDuration ();
< }
< 
< std::pair<bool, SignalNoiseDbm>
< WifiPhy::GetReceptionStatus (Ptr<const WifiPsdu> psdu, Ptr<Event> event, Time relativeMpduStart, Time mpduDuration)
< {
<   NS_LOG_FUNCTION (this << *psdu << *event << relativeMpduStart << mpduDuration);
<   InterferenceHelper::SnrPer snrPer;
<   snrPer = m_interference.CalculatePayloadSnrPer (event, std::make_pair (relativeMpduStart, relativeMpduStart + mpduDuration));
< 
<   NS_LOG_DEBUG ("mode=" << (event->GetTxVector ().GetMode ().GetDataRate (event->GetTxVector ())) <<
<                 ", snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per << ", size=" << psdu->GetSize () <<
<                 ", relativeStart = " << relativeMpduStart.GetNanoSeconds () << "ns, duration = " << mpduDuration.GetNanoSeconds () << "ns");
< 
<   // There are two error checks: PER and receive error model check.
<   // PER check models is typical for Wi-Fi and is based on signal modulation;
<   // Receive error model is optional, if we have an error model and
<   // it indicates that the packet is corrupt, drop the packet.
<   SignalNoiseDbm signalNoise;
<   signalNoise.signal = WToDbm (event->GetRxPowerW ());
<   signalNoise.noise = WToDbm (event->GetRxPowerW () / snrPer.snr);
<   if (m_random->GetValue () > snrPer.per &&
<       !(m_postReceptionErrorModel && m_postReceptionErrorModel->IsCorrupt (psdu->GetPacket ()->Copy ())))
<     {
<       NS_LOG_DEBUG ("Reception succeeded: " << psdu);
<       return std::make_pair (true, signalNoise);
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Reception failed: " << psdu);
<       return std::make_pair (false, signalNoise);
<     }
---
>   m_phyRxEndTrace (packet);
3636c1978
< WifiPhy::EndReceiveInterBss (void)
---
> WifiPhy::NotifyRxDrop (Ptr<const Packet> packet)
3638,3642c1980
<   NS_LOG_FUNCTION (this);
<   if (!m_channelAccessRequested)
<     {
<       m_powerRestricted = false;
<     }
---
>   m_phyRxDropTrace (packet);
3646c1984
< WifiPhy::ResetReceive (Ptr<Event> event)
---
> WifiPhy::NotifyMonitorSniffRx (Ptr<const Packet> packet, uint16_t channelFreqMhz, uint16_t channelNumber, uint32_t rate, WifiPreamble preamble, WifiTxVector txVector, struct mpduInfo aMpdu, struct signalNoiseDbm signalNoise)
3648,3653c1986
<   NS_LOG_FUNCTION (this << *event);
<   NS_ASSERT (event->GetEndTime () == Simulator::Now ());
<   NS_ASSERT (!IsStateRx ());
<   m_interference.NotifyRxEnd ();
<   m_currentEvent = 0;
<   MaybeCcaBusyDuration ();
---
>   m_phyMonitorSniffRxTrace (packet, channelFreqMhz, channelNumber, rate, preamble, txVector, aMpdu, signalNoise);
3656d1988
< //// WIGIG ////
3658c1990
< WifiPhy::EndAllocationPeriod (void)
---
> WifiPhy::NotifyMonitorSniffTx (Ptr<const Packet> packet, uint16_t channelFreqMhz, uint16_t channelNumber, uint32_t rate, WifiPreamble preamble, WifiTxVector txVector, struct mpduInfo aMpdu)
3660c1992
<   NS_ABORT_MSG ("Should not be called for normal WifiPhy");
---
>   m_phyMonitorSniffTxTrace (packet, channelFreqMhz, channelNumber, rate, preamble, txVector, aMpdu);
3662d1993
< //// WIGIG ////
3664,3669d1994
< void
< WifiPhy::NotifyChannelAccessRequested (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_channelAccessRequested = true;
< }
4462,4537c2787,2788
< // Clause 26
< 
< WifiMode
< WifiPhy::GetHeMcs0 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs0", 0, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
< 
< WifiMode
< WifiPhy::GetHeMcs1 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs1", 1, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
< 
< WifiMode
< WifiPhy::GetHeMcs2 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs2", 2, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
< 
< WifiMode
< WifiPhy::GetHeMcs3 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs3", 3, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
< 
< WifiMode
< WifiPhy::GetHeMcs4 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs4", 4, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
< 
< WifiMode
< WifiPhy::GetHeMcs5 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs5", 5, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
< 
< WifiMode
< WifiPhy::GetHeMcs6 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs6", 6, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
< 
< WifiMode
< WifiPhy::GetHeMcs7 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs7", 7, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
< 
< WifiMode
< WifiPhy::GetHeMcs8 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs8", 8, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
< 
< WifiMode
< WifiPhy::GetHeMcs9 ()
---
> bool
> WifiPhy::IsValidTxVector (WifiTxVector txVector)
4539,4542c2790,2792
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs9", 9, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
---
>   uint32_t chWidth = txVector.GetChannelWidth();
>   uint8_t nss = txVector.GetNss();
>   std::string modeName = txVector.GetMode().GetUniqueName();
4544,4550c2794,2818
< WifiMode
< WifiPhy::GetHeMcs10 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs10", 10, WIFI_MOD_CLASS_HE);
<   return mcs;
< }
---
>   if (chWidth == 20)
>     {
>       if (nss != 3 && nss != 6)
>         {
>           return (modeName != "VhtMcs9");
>         }
>     }
>   else if (chWidth == 80)
>     {
>       if (nss == 3 || nss == 7)
>         {
>           return (modeName != "VhtMcs6");
>         }
>       else if (nss == 6)
>         {
>           return (modeName != "VhtMcs9");
>         }
>     }
>   else if (chWidth == 160)
>     {
>       if (nss == 3)
>         {
>           return (modeName != "VhtMcs9");
>         }
>     }
4552,4557c2820
< WifiMode
< WifiPhy::GetHeMcs11 ()
< {
<   static WifiMode mcs =
<     WifiModeFactory::CreateWifiMcs ("HeMcs11", 11, WIFI_MOD_CLASS_HE);
<   return mcs;
---
>   return true;
4563c2826
<   for (uint8_t i = 0; i < GetNModes (); i++)
---
>   for (uint32_t i = 0; i < GetNModes (); i++)
4576,4578c2839
<   WifiModulationClass modulation = mcs.GetModulationClass ();
<   if (modulation == WIFI_MOD_CLASS_HT || modulation == WIFI_MOD_CLASS_VHT
<       || modulation == WIFI_MOD_CLASS_HE)
---
>   for (uint32_t i = 0; i < GetNMcs (); i++)
4580c2841,2844
<       return IsMcsSupported (modulation, mcs.GetMcsValue ());
---
>       if (mcs == GetMcs (i))
>         {
>           return true;
>         }
4585,4599c2849
< bool
< WifiPhy::IsMcsSupported (WifiModulationClass mc, uint8_t mcs) const
< {
<   if (m_mcsIndexMap.find (mc) == m_mcsIndexMap.end ())
<     {
<       return false;
<     }
<   if (m_mcsIndexMap.at (mc).find (mcs) == m_mcsIndexMap.at (mc).end ())
<     {
<       return false;
<     }
<   return true;
< }
< 
< uint8_t
---
> uint32_t
4602c2852
<   return static_cast<uint8_t> (m_deviceRateSet.size ());
---
>   return m_deviceRateSet.size ();
4606c2856
< WifiPhy::GetMode (uint8_t mode) const
---
> WifiPhy::GetMode (uint32_t mode) const
4614c2864
<   return static_cast<uint8_t> (m_deviceMcsSet.size ());
---
>   return m_deviceMcsSet.size ();
4623,4624c2873,2874
< WifiMode
< WifiPhy::GetMcs (WifiModulationClass modulation, uint8_t mcs) const
---
> double
> WifiPhy::DbToRatio (double dB) const
4626,4632c2876,2877
<   NS_ASSERT_MSG (IsMcsSupported (modulation, mcs), "Unsupported MCS");
<   uint8_t index = m_mcsIndexMap.at (modulation).at (mcs);
<   NS_ASSERT (index < m_deviceMcsSet.size ());
<   WifiMode mode = m_deviceMcsSet[index];
<   NS_ASSERT (mode.GetModulationClass () == modulation);
<   NS_ASSERT (mode.GetMcsValue () == mcs);
<   return mode;
---
>   double ratio = std::pow (10.0, dB / 10.0);
>   return ratio;
4635,4636c2880,2881
< WifiMode
< WifiPhy::GetHtMcs (uint8_t mcs) const
---
> double
> WifiPhy::DbmToW (double dBm) const
4638c2883,2884
<   return GetMcs (WIFI_MOD_CLASS_HT, mcs);
---
>   double mW = std::pow (10.0, dBm / 10.0);
>   return mW / 1000.0;
4641,4642c2887,2888
< WifiMode
< WifiPhy::GetVhtMcs (uint8_t mcs) const
---
> double
> WifiPhy::WToDbm (double w) const
4644c2890
<   return GetMcs (WIFI_MOD_CLASS_VHT, mcs);
---
>   return 10.0 * std::log10 (w * 1000.0);
4647,4648c2893,2894
< WifiMode
< WifiPhy::GetHeMcs (uint8_t mcs) const
---
> double
> WifiPhy::RatioToDb (double ratio) const
4650c2896
<   return GetMcs (WIFI_MOD_CLASS_HE, mcs);
---
>   return 10.0 * std::log10 (ratio);
4654c2900
< WifiPhy::IsStateCcaBusy (void) const
---
> WifiPhy::IsStateCcaBusy (void)
4660c2906
< WifiPhy::IsStateIdle (void) const
---
> WifiPhy::IsStateIdle (void)
4666c2912,2918
< WifiPhy::IsStateRx (void) const
---
> WifiPhy::IsStateBusy (void)
> {
>   return m_state->IsStateBusy ();
> }
> 
> bool
> WifiPhy::IsStateRx (void)
4672c2924
< WifiPhy::IsStateTx (void) const
---
> WifiPhy::IsStateTx (void)
4678c2930
< WifiPhy::IsStateSwitching (void) const
---
> WifiPhy::IsStateSwitching (void)
4684c2936
< WifiPhy::IsStateSleep (void) const
---
> WifiPhy::IsStateSleep (void)
4689,4690c2941,2942
< bool
< WifiPhy::IsStateOff (void) const
---
> Time
> WifiPhy::GetStateDuration (void)
4692c2944
<   return m_state->IsStateOff ();
---
>   return m_state->GetStateDuration ();
4707,4821d2958
< Time
< WifiPhy::GetLastRxEndTime (void) const
< {
<   return m_state->GetLastRxEndTime ();
< }
< 
< void
< WifiPhy::SwitchMaybeToCcaBusy (void)
< {
<   NS_LOG_FUNCTION (this);
<   //We are here because we have received the first bit of a packet and we are
<   //not going to be able to synchronize on it
<   //In this model, CCA becomes busy when the aggregation of all signals as
<   //tracked by the InterferenceHelper class is higher than the CcaBusyThreshold
< 
<   Time delayUntilCcaEnd = m_interference.GetEnergyDuration (m_ccaEdThresholdW);
<   if (!delayUntilCcaEnd.IsZero ())
<     {
<       NS_LOG_DEBUG ("Calling SwitchMaybeToCcaBusy for " << delayUntilCcaEnd.As (Time::S));
<       m_state->SwitchMaybeToCcaBusy (delayUntilCcaEnd);
<     }
< }
< 
< void
< WifiPhy::AbortCurrentReception (WifiPhyRxfailureReason reason)
< {
<   NS_LOG_FUNCTION (this << reason);
<   if (m_endPreambleDetectionEvent.IsRunning ())
<     {
<       m_endPreambleDetectionEvent.Cancel ();
<     }
<   if (m_endPhyRxEvent.IsRunning ())
<     {
<       m_endPhyRxEvent.Cancel ();
<     }
<   if (m_endRxEvent.IsRunning ())
<     {
<       m_endRxEvent.Cancel ();
<     }
<   NotifyRxDrop (m_currentEvent->GetPsdu (), reason);
<   m_interference.NotifyRxEnd ();
<   if (reason == OBSS_PD_CCA_RESET)
<     {
<       m_state->SwitchFromRxAbort ();
<     }
<   m_currentEvent = 0;
< }
< 
< void
< WifiPhy::ResetCca (bool powerRestricted, double txPowerMaxSiso, double txPowerMaxMimo)
< {
<   NS_LOG_FUNCTION (this << powerRestricted << txPowerMaxSiso << txPowerMaxMimo);
<   m_powerRestricted = powerRestricted;
<   m_txPowerMaxSiso = txPowerMaxSiso;
<   m_txPowerMaxMimo = txPowerMaxMimo;
<   NS_ASSERT ((m_currentEvent->GetEndTime () - Simulator::Now ()).IsPositive ());
<   Simulator::Schedule (m_currentEvent->GetEndTime () - Simulator::Now (), &WifiPhy::EndReceiveInterBss, this);
<   AbortCurrentReception (OBSS_PD_CCA_RESET);
< }
< 
< double
< WifiPhy::GetTxPowerForTransmission (WifiTxVector txVector) const
< {
<   NS_LOG_FUNCTION (this << m_powerRestricted);
<   if (!m_powerRestricted)
<     {
<       return GetPowerDbm (txVector.GetTxPowerLevel ());
<     }
<   else
<     {
<       if (txVector.GetNss () > 1)
<         {
<           return std::min (m_txPowerMaxMimo, GetPowerDbm (txVector.GetTxPowerLevel ()));
<         }
<       else
<         {
<           return std::min (m_txPowerMaxSiso, GetPowerDbm (txVector.GetTxPowerLevel ()));
<         }
<     }
< }
< 
< void
< WifiPhy::StartRx (Ptr<Event> event, double rxPowerW)
< {
<   NS_LOG_FUNCTION (this << *event << rxPowerW);
< 
<   NS_LOG_DEBUG ("sync to signal (power=" << rxPowerW << "W)");
<   m_interference.NotifyRxStart (); //We need to notify it now so that it starts recording events
< 
<   if (!m_endPreambleDetectionEvent.IsRunning ())
<     {
<       Time startOfPreambleDuration = GetPreambleDetectionDuration ();
<       Time remainingRxDuration = event->GetDuration () - startOfPreambleDuration;
<       m_endPreambleDetectionEvent = Simulator::Schedule (startOfPreambleDuration, &WifiPhy::StartReceiveHeader, this, event);
<     }
<   else if ((m_frameCaptureModel != 0) && (rxPowerW > m_currentEvent->GetRxPowerW ()))
<     {
<       NS_LOG_DEBUG ("Received a stronger signal during preamble detection: drop current packet and switch to new packet");
<       NotifyRxDrop (m_currentEvent->GetPsdu (), PREAMBLE_DETECTION_PACKET_SWITCH);
<       m_interference.NotifyRxEnd ();
<       m_endPreambleDetectionEvent.Cancel ();
<       m_interference.NotifyRxStart ();
<       Time startOfPreambleDuration = GetPreambleDetectionDuration ();
<       Time remainingRxDuration = event->GetDuration () - startOfPreambleDuration;
<       m_endPreambleDetectionEvent = Simulator::Schedule (startOfPreambleDuration, &WifiPhy::StartReceiveHeader, this, event);
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Drop packet because RX is already decoding preamble");
<       NotifyRxDrop (event->GetPsdu (), BUSY_DECODING_PREAMBLE);
<       return;
<     }
<   m_currentEvent = event;
< }
< 
4829a2967,2988
> std::ostream& operator<< (std::ostream& os, enum WifiPhy::State state)
> {
>   switch (state)
>     {
>     case WifiPhy::IDLE:
>       return (os << "IDLE");
>     case WifiPhy::CCA_BUSY:
>       return (os << "CCA_BUSY");
>     case WifiPhy::TX:
>       return (os << "TX");
>     case WifiPhy::RX:
>       return (os << "RX");
>     case WifiPhy::SWITCHING:
>       return (os << "SWITCHING");
>     case WifiPhy::SLEEP:
>       return (os << "SLEEP");
>     default:
>       NS_FATAL_ERROR ("Invalid WifiPhy state");
>       return (os << "INVALID");
>     }
> }
> 
4834,4836d2992
< /**
<  * Constructor class
<  */
4920,4931d3075
<     ns3::WifiPhy::GetHeMcs0 ();
<     ns3::WifiPhy::GetHeMcs1 ();
<     ns3::WifiPhy::GetHeMcs2 ();
<     ns3::WifiPhy::GetHeMcs3 ();
<     ns3::WifiPhy::GetHeMcs4 ();
<     ns3::WifiPhy::GetHeMcs5 ();
<     ns3::WifiPhy::GetHeMcs6 ();
<     ns3::WifiPhy::GetHeMcs7 ();
<     ns3::WifiPhy::GetHeMcs8 ();
<     ns3::WifiPhy::GetHeMcs9 ();
<     ns3::WifiPhy::GetHeMcs10 ();
<     ns3::WifiPhy::GetHeMcs11 ();
4933c3077
< } g_constructor; ///< the constructor
---
> } g_constructor;
diff ../../NS3-WiGig/src/wifi/model/wifi-phy.h ../../ns-3-dev/src/wifi/model/wifi-phy.h
24a25,27
> #include <stdint.h>
> #include <map>
> #include "ns3/callback.h"
26,28c29,39
< #include "ns3/deprecated.h"
< #include "ns3/error-model.h"
< #include "wifi-mpdu-type.h"
---
> #include "ns3/packet.h"
> #include "ns3/object.h"
> #include "ns3/nstime.h"
> #include "ns3/ptr.h"
> #include "ns3/mobility-model.h"
> #include "ns3/random-variable-stream.h"
> #include "wifi-mode.h"
> #include "wifi-preamble.h"
> #include "wifi-phy-standard.h"
> #include "ns3/traced-callback.h"
> #include "wifi-tx-vector.h"
31,32c42,44
< #include "wifi-phy-state-helper.h"
< #include "wigig-data-types.h"
---
> #include "ns3/net-device.h"
> #include "ns3/node.h"
> #include "wifi-channel.h"
36d47
< #define HE_PHY 125
40,42d50
< class Channel;
< class NetDevice;
< class MobilityModel;
44,49d51
< class FrameCaptureModel;
< class PreambleDetectionModel;
< class WifiRadioEnergyModel;
< class UniformRandomVariable;
< class WifiPsdu;
< class WifiPpdu;
52c54
<  * Enumeration of the possible reception failure reasons.
---
>  * This enumeration defines the type of an MPDU.
54c56
< enum WifiPhyRxfailureReason
---
> enum mpduType
56,73c58,63
<   UNKNOWN = 0,
<   UNSUPPORTED_SETTINGS,
<   CHANNEL_SWITCHING,
<   RXING,
<   TXING,
<   SLEEPING,
<   BUSY_DECODING_PREAMBLE,
<   PREAMBLE_DETECT_FAILURE,
<   RECEPTION_ABORTED_BY_TX,
<   L_SIG_FAILURE,
<   SIG_A_FAILURE,
<   PREAMBLE_DETECTION_PACKET_SWITCH,
<   FRAME_CAPTURE_PACKET_SWITCH,
<   OBSS_PD_CCA_RESET,
<   //// WIGIG ////
<   DMG_HEADER_FAILURE,
<   ALLOCATION_ENDED
<   //// WIGIG ////
---
>   /** The MPDU is not part of an A-MPDU */
>   NORMAL_MPDU = 0,
>   /** The MPDU is part of an A-MPDU, but is not the last aggregate */
>   MPDU_IN_AGGREGATE,
>   /** The MPDU is the last aggregate in an A-MPDU */
>   LAST_MPDU_IN_AGGREGATE
76,84c66
< 
< /**
< * \brief Stream insertion operator.
< *
< * \param os the stream
< * \param reason the failure reason
< * \returns a reference to the stream
< */
< inline std::ostream& operator<< (std::ostream& os, WifiPhyRxfailureReason reason)
---
> struct signalNoiseDbm
86,132c68,69
<   switch (reason)
<     {
<     case UNSUPPORTED_SETTINGS:
<       return (os << "UNSUPPORTED_SETTINGS");
<     case CHANNEL_SWITCHING:
<       return (os << "CHANNEL_SWITCHING");
<     case RXING:
<       return (os << "RXING");
<     case TXING:
<       return (os << "TXING");
<     case SLEEPING:
<       return (os << "SLEEPING");
<     case BUSY_DECODING_PREAMBLE:
<       return (os << "BUSY_DECODING_PREAMBLE");
<     case PREAMBLE_DETECT_FAILURE:
<       return (os << "PREAMBLE_DETECT_FAILURE");
<     case RECEPTION_ABORTED_BY_TX:
<       return (os << "RECEPTION_ABORTED_BY_TX");
<     case L_SIG_FAILURE:
<       return (os << "L_SIG_FAILURE");
<     case SIG_A_FAILURE:
<       return (os << "SIG_A_FAILURE");
<     case PREAMBLE_DETECTION_PACKET_SWITCH:
<       return (os << "PREAMBLE_DETECTION_PACKET_SWITCH");
<     case FRAME_CAPTURE_PACKET_SWITCH:
<       return (os << "FRAME_CAPTURE_PACKET_SWITCH");
<     case OBSS_PD_CCA_RESET:
<       return (os << "OBSS_PD_CCA_RESET");
<     //// WIGIG ////
<     case DMG_HEADER_FAILURE:
<       return (os << "DMG_HEADER_FAILURE");
<     case ALLOCATION_ENDED:
<       return (os << "ALLOCATION_ENDED");
<     //// WIGIG ////
<     case UNKNOWN:
<     default:
<       NS_FATAL_ERROR ("Unknown reason");
<       return (os << "UNKNOWN");
<     }
< }
< 
< 
< /// SignalNoiseDbm structure
< struct SignalNoiseDbm
< {
<   double signal; ///< in dBm
<   double noise; ///< in dBm
---
>   double signal; //in dBm
>   double noise; //in dBm
135,136c72
< /// MpduInfo structure
< struct MpduInfo
---
> struct mpduInfo
138,146c74,75
<   MpduType type; ///< type
<   uint32_t mpduRefNumber; ///< MPDU ref number
< };
< 
< /// Parameters for receive HE preamble
< struct HePreambleParameters
< {
<   double rssiW; ///< RSSI in W
<   uint8_t bssColor; ///< BSS color
---
>   enum mpduType type;
>   uint32_t mpduRefNumber;
150,152c79
<  * \brief 802.11 PHY layer model
<  * \ingroup wifi
<  *
---
>  * \brief receive notifications about phy events.
154c81
< class WifiPhy : public Object
---
> class WifiPhyListener
157,164c84
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
<   static TypeId GetTypeId (void);
< 
<   WifiPhy ();
<   virtual ~WifiPhy ();
---
>   virtual ~WifiPhyListener ();
167c87
<    * Return the WifiPhyStateHelper of this PHY
---
>    * \param duration the expected duration of the packet reception.
169c89,96
<    * \return the WifiPhyStateHelper of this PHY
---
>    * We have received the first bit of a packet. We decided
>    * that we could synchronize on this packet. It does not mean
>    * we will be able to successfully receive completely the
>    * whole packet. It means that we will report a BUSY status until
>    * one of the following happens:
>    *   - NotifyRxEndOk
>    *   - NotifyRxEndError
>    *   - NotifyTxStart
171,172c98
<   Ptr<WifiPhyStateHelper> GetState (void) const;
< 
---
>   virtual void NotifyRxStart (Time duration) = 0;
174,175c100,102
<    * \param callback the callback to invoke
<    *        upon successful packet reception.
---
>    * We have received the last bit of a packet for which
>    * NotifyRxStart was invoked first and, the packet has
>    * been successfully received.
177c104
<   void SetReceiveOkCallback (RxOkCallback callback);
---
>   virtual void NotifyRxEndOk (void) = 0;
179,180c106,108
<    * \param callback the callback to invoke
<    *        upon erroneous packet reception.
---
>    * We have received the last bit of a packet for which
>    * NotifyRxStart was invoked first and, the packet has
>    * _not_ been successfully received.
182,183c110
<   void SetReceiveErrorCallback (RxErrorCallback callback);
< 
---
>   virtual void NotifyRxEndError (void) = 0;
185c112,113
<    * \param listener the new listener
---
>    * \param duration the expected transmission duration.
>    * \param txPowerDbm the nominal tx power in dBm
187,188c115,119
<    * Add the input listener to the list of objects to be notified of
<    * PHY-level events.
---
>    * We are about to send the first bit of the packet.
>    * We do not send any event to notify the end of
>    * transmission. Listeners should assume that the
>    * channel implicitely reverts to the idle state
>    * unless they have received a cca busy report.
190c121
<   void RegisterListener (WifiPhyListener *listener);
---
>   virtual void NotifyTxStart (Time duration, double txPowerDbm) = 0;
192c123
<    * \param listener the listener to be unregistered
---
>    * \param duration the expected busy duration.
194,195c125,135
<    * Remove the input listener from the list of objects to be notified of
<    * PHY-level events.
---
>    * This method does not really report a real state
>    * change as opposed to the other methods in this class.
>    * It merely reports that, unless the medium is reported
>    * busy through NotifyTxStart or NotifyRxStart/End,
>    * it will be busy as defined by the currently selected
>    * CCA mode.
>    *
>    * Typical client code which wants to have a clear picture
>    * of the CCA state will need to keep track of the time at
>    * which the last NotifyCcaBusyStart method is called and
>    * what duration it reported.
197,198c137
<   void UnregisterListener (WifiPhyListener *listener);
< 
---
>   virtual void NotifyMaybeCcaBusyStart (Time duration) = 0;
200c139,143
<    * \param callback the callback to invoke when PHY capabilities have changed.
---
>    * \param duration the expected channel switching duration.
>    *
>    * We do not send any event to notify the end of
>    * channel switching. Listeners should assume that the
>    * channel implicitely reverts to the idle or busy states.
202,203c145
<   void SetCapabilitiesChangedCallback (Callback<void> callback);
< 
---
>   virtual void NotifySwitchingStart (Time duration) = 0;
205,208c147
<    * Start receiving the PHY preamble of a PPDU (i.e. the first bit of the preamble has arrived).
<    *
<    * \param ppdu the arriving PPDU
<    * \param rxPowerW the receive power in W
---
>    * Notify listeners that we went to sleep
210,211c149
<   void StartReceivePreamble (Ptr<WifiPpdu> ppdu, double rxPowerW);
< 
---
>   virtual void NotifySleep (void) = 0;
213,215c151
<    * Start receiving the PHY header of a PPDU (i.e. after the end of receiving the preamble).
<    *
<    * \param event the event holding incoming PPDU's information
---
>    * Notify listeners that we woke up
217c153,155
<   virtual void StartReceiveHeader (Ptr<Event> event);
---
>   virtual void NotifyWakeup (void) = 0;
> };
> 
218a157,164
> /**
>  * \brief 802.11 PHY layer model
>  * \ingroup wifi
>  *
>  */
> class WifiPhy : public Object
> {
> public:
220,222c166
<    * Continue receiving the PHY header of a PPDU (i.e. after the end of receiving the non-HT header part).
<    *
<    * \param event the event holding incoming PPDU's information
---
>    * The state of the PHY layer.
224,225c168,202
<   virtual void ContinueReceiveHeader (Ptr<Event> event);
< 
---
>   enum State
>   {
>     /**
>      * The PHY layer is IDLE.
>      */
>     IDLE,
>     /**
>      * The PHY layer has sense the medium busy through the CCA mechanism
>      */
>     CCA_BUSY,
>     /**
>      * The PHY layer is sending a packet.
>      */
>     TX,
>     /**
>      * The PHY layer is receiving a packet.
>      */
>     RX,
>     /**
>      * The PHY layer is switching to other channel.
>      */
>     SWITCHING,
>     /**
>      * The PHY layer is sleeping.
>      */
>     SLEEP
>   };
> 
>   /**
>    * arg1: packet received successfully
>    * arg2: snr of packet
>    * arg3: TXVECTOR of packet
>    * arg4: type of preamble used for packet.
>    */
>   typedef Callback<void, Ptr<Packet>, double, WifiTxVector, enum WifiPreamble> RxOkCallback;
227,229c204,205
<    * Start receiving the PSDU (i.e. the first symbol of the PSDU has arrived).
<    *
<    * \param event the event holding incoming PPDU's information
---
>    * arg1: packet received unsuccessfully
>    * arg2: snr of packet
231c207,212
<   void StartReceivePayload (Ptr<Event> event);
---
>   typedef Callback<void, Ptr<Packet>, double> RxErrorCallback;
> 
>   static TypeId GetTypeId (void);
> 
>   WifiPhy ();
>   virtual ~WifiPhy ();
234,236c215,216
<    * The last symbol of the PPDU has arrived.
<    *
<    * \param event the corresponding event of the first time the packet arrives (also storing packet and TxVector information)
---
>    * \param callback the callback to invoke
>    *        upon successful packet reception.
238,239c218
<   void EndReceive (Ptr<Event> event);
< 
---
>   virtual void SetReceiveOkCallback (RxOkCallback callback) = 0;
241,243c220,221
<    * Reset PHY at the end of the packet under reception after it has failed the PHY header.
<    *
<    * \param event the corresponding event of the first time the packet arrives (also storing packet and TxVector information)
---
>    * \param callback the callback to invoke
>    *        upon erroneous packet reception.
245c223
<   void ResetReceive (Ptr<Event> event);
---
>   virtual void SetReceiveErrorCallback (RxErrorCallback callback) = 0;
248,249c226,230
<    * For HE receptions only, check and possibly modify the transmit power restriction state at
<    * the end of PPDU reception.
---
>    * \param packet the packet to send
>    * \param txVector the TXVECTOR that has tx parameters such as mode, the transmission mode to use to send
>    *        this packet, and txPowerLevel, a power level to use to send this packet. The real transmission
>    *        power is calculated as txPowerMin + txPowerLevel * (txPowerMax - txPowerMin) / nTxLevels
>    * \param preamble the type of preamble to use to send this packet.
251,252c232
<   void EndReceiveInterBss (void);
< 
---
>   virtual void SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, enum WifiPreamble preamble) = 0;
254,256c234,236
<    * \param psdu the PSDU to send
<    * \param txVector the TXVECTOR that has TX parameters such as mode, the transmission mode to use to send
<    *        this PSDU, and txPowerLevel, a power level to use to send the whole PPDU. The real transmission
---
>    * \param packet the packet to send
>    * \param txVector the TXVECTOR that has tx parameters such as mode, the transmission mode to use to send
>    *        this packet, and txPowerLevel, a power level to use to send this packet. The real transmission
257a238,239
>    * \param preamble the type of preamble to use to send this packet.
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
259c241
<   virtual void Send (Ptr<const WifiPsdu> psdu, WifiTxVector txVector);
---
>   virtual void SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, enum WifiPreamble preamble, enum mpduType mpdutype) = 0;
262c244,247
<    * \param ppdu the PPDU to send
---
>    * \param listener the new listener
>    *
>    * Add the input listener to the list of objects to be notified of
>    * PHY-level events.
264,265c249
<   virtual void StartTx (Ptr<WifiPpdu> ppdu) = 0;
<   //// WIGIG ////
---
>   virtual void RegisterListener (WifiPhyListener *listener) = 0;
267c251,254
<    * End current allocation period.
---
>    * \param listener the listener to be unregistered
>    *
>    * Remove the input listener from the list of objects to be notified of
>    * PHY-level events.
269,270c256
<   virtual void EndAllocationPeriod (void);
<   //// WIGIG ////
---
>   virtual void UnregisterListener (WifiPhyListener *listener) = 0;
275c261
<   void SetSleepMode (void);
---
>   virtual void SetSleepMode (void) = 0;
279,287c265
<   void ResumeFromSleep (void);
<   /**
<    * Put in off mode.
<    */
<   void SetOffMode (void);
<   /**
<    * Resume from off mode.
<    */
<   void ResumeFromOff (void);
---
>   virtual void ResumeFromSleep (void) = 0;
292c270
<   bool IsStateIdle (void) const;
---
>   virtual bool IsStateIdle (void);
296c274,278
<   bool IsStateCcaBusy (void) const;
---
>   virtual bool IsStateCcaBusy (void);
>   /**
>    * \return true of the current state of the PHY layer is not WifiPhy::IDLE, false otherwise.
>    */
>   virtual bool IsStateBusy (void);
300c282
<   bool IsStateRx (void) const;
---
>   virtual bool IsStateRx (void);
304c286
<   bool IsStateTx (void) const;
---
>   virtual bool IsStateTx (void);
308c290
<   bool IsStateSwitching (void) const;
---
>   virtual bool IsStateSwitching (void);
312c294
<   bool IsStateSleep (void) const;
---
>   virtual bool IsStateSleep (void);
314c296
<    * \return true if the current state of the PHY layer is WifiPhy::OFF, false otherwise.
---
>    * \return the amount of time since the current state has started.
316,321c298
<   bool IsStateOff (void) const;
<   /**
<    * \return the current state of the PHY layer.
<    */
<   WifiPhyState GetPhyState (void) const;
< 
---
>   virtual Time GetStateDuration (void);
328c305
<   Time GetDelayUntilIdle (void);
---
>   virtual Time GetDelayUntilIdle (void);
335c312,313
<   Time GetLastRxStartTime (void) const;
---
>   virtual Time GetLastRxStartTime (void) const;
> 
337c315,318
<    * Return the end time of the last received packet.
---
>    * \param size the number of bytes in the packet to send
>    * \param txVector the TXVECTOR used for the transmission of this packet
>    * \param preamble the type of preamble to use for this packet.
>    * \param frequency the channel center frequency (MHz)
339c320
<    * \return the end time of the last received packet
---
>    * \return the total amount of time this PHY will stay busy for the transmission of these bytes.
341,342c322
<   Time GetLastRxEndTime (void) const;
< 
---
>   Time CalculateTxDuration (uint32_t size, WifiTxVector txVector, enum WifiPreamble preamble, double frequency);
345a326
>    * \param preamble the type of preamble to use for this packet.
346a328,329
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
>    * \param incFlag this flag is used to indicate that the static variables need to be update or not. This function is called a couple of times for the same packet so static variables should not be increased each time.
350c333
<   static Time CalculateTxDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency);
---
>   Time CalculateTxDuration (uint32_t size, WifiTxVector txVector, enum WifiPreamble preamble, double frequency, enum mpduType mpdutype, uint8_t incFlag);
353a337
>    * \param preamble the type of preamble to use for this packet.
355,360c339
<    * \return the total amount of time this PHY will stay busy for the transmission of the PHY preamble and PHY header.
<    */
<   static Time CalculatePhyPreambleAndHeaderDuration (WifiTxVector txVector);
<   /**
<    *
<    * \return the preamble detection duration, which is the time correlation needs to detect the start of an incoming frame.
---
>    * \return the total amount of time this PHY will stay busy for the transmission of the PLCP preamble and PLCP header.
362c341,342
<   virtual Time GetPreambleDetectionDuration (void);
---
>   Time CalculatePlcpPreambleAndHeaderDuration (WifiTxVector txVector, enum WifiPreamble preamble);
> 
363a344
>    * \param preamble the type of preamble
368c349
<   static Time GetPhyTrainingSymbolDuration (WifiTxVector txVector);
---
>   static Time GetPlcpHtTrainingSymbolDuration (WifiPreamble preamble, WifiTxVector txVector);
369a351,352
>    * \param payloadMode the WifiMode use for the transmission of the payload
>    *
371c354
<    *         in Mixed Format and Greenfield format PHY header
---
>    *         in Mixed Format and greenfield format PLCP header
373c356
<   static WifiMode GetHtPhyHeaderMode ();
---
>   static WifiMode GetHtPlcpHeaderMode (WifiMode payloadMode);
374a358,359
>    * \param payloadMode the WifiMode use for the transmission of the payload
>    *
377,381c362
<   static WifiMode GetVhtPhyHeaderMode ();
<   /**
<    * \return the WifiMode used for the transmission of the HE-STF, HE-LTF and HE-SIG-B fields
<    */
<   static WifiMode GetHePhyHeaderMode ();
---
>   static WifiMode GetVhtPlcpHeaderMode (WifiMode payloadMode);
385c366
<    * \return the duration of the HT-SIG in Mixed Format and Greenfield format PHY header
---
>    * \return the duration of the HT-SIG in Mixed Format and greenfield format PLCP header
387c368
<   static Time GetPhyHtSigHeaderDuration (WifiPreamble preamble);
---
>   static Time GetPlcpHtSigHeaderDuration (WifiPreamble preamble);
391c372
<    * \return the duration of the SIG-A1 in PHY header
---
>    * \return the duration of the VHT-SIG-A1 in PLCP header
393c374
<   static Time GetPhySigA1Duration (WifiPreamble preamble);
---
>   static Time GetPlcpVhtSigA1Duration (WifiPreamble preamble);
397c378
<    * \return the duration of the SIG-A2 in PHY header
---
>    * \return the duration of the VHT-SIG-A2 in PLCP header
399c380
<   static Time GetPhySigA2Duration (WifiPreamble preamble);
---
>   static Time GetPlcpVhtSigA2Duration (WifiPreamble preamble);
403c384
<    * \return the duration of the SIG-B in PHY header
---
>    * \return the duration of the VHT-SIG-B in PLCP header
405c386
<   static Time GetPhySigBDuration (WifiPreamble preamble);
---
>   static Time GetPlcpVhtSigBDuration (WifiPreamble preamble);
406a388,389
>    * \param payloadMode the WifiMode use for the transmission of the payload
>    * \param preamble the type of preamble
409c392
<    * \return the WifiMode used for the transmission of the PHY header
---
>    * \return the WifiMode used for the transmission of the PLCP header
411c394
<   static WifiMode GetPhyHeaderMode (WifiTxVector txVector);
---
>   static WifiMode GetPlcpHeaderMode (WifiMode payloadMode, WifiPreamble preamble, WifiTxVector txVector);
413a397
>    * \param preamble the type of preamble
415c399
<    * \return the duration of the PHY header
---
>    * \return the duration of the PLCP header
417c401
<   static Time GetPhyHeaderDuration (WifiTxVector txVector);
---
>   static Time GetPlcpHeaderDuration (WifiTxVector txVector, WifiPreamble preamble);
419a404
>    * \param preamble the type of preamble
421c406
<    * \return the duration of the PHY preamble
---
>    * \return the duration of the PLCP preamble
423c408
<   static Time GetPhyPreambleDuration (WifiTxVector txVector);
---
>   static Time GetPlcpPreambleDuration (WifiTxVector txVector, WifiPreamble preamble);
426a412
>    * \param preamble the type of preamble to use for this packet
428d413
<    * \param mpdutype the type of the MPDU as defined in WifiPhy::MpduType.
432c417
<   static Time GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype = NORMAL_MPDU);
---
>   Time GetPayloadDuration (uint32_t size, WifiTxVector txVector, WifiPreamble preamble, double frequency);
435a421
>    * \param preamble the type of preamble to use for this packet
437,444c423,424
<    * \param mpdutype the type of the MPDU as defined in WifiPhy::MpduType.
<    * \param incFlag this flag is used to indicate that the variables need to be update or not
<    * This function is called a couple of times for the same packet so variables should not be increased each time.
<    * \param totalAmpduSize the total size of the previously transmitted MPDUs for the concerned A-MPDU.
<    * If incFlag is set, this parameter will be updated.
<    * \param totalAmpduNumSymbols the number of symbols previously transmitted for the MPDUs in the concerned A-MPDU,
<    * used for the computation of the number of symbols needed for the last MPDU.
<    * If incFlag is set, this parameter will be updated.
---
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
>    * \param incFlag this flag is used to indicate that the static variables need to be update or not. This function is called a couple of times for the same packet so static variables should not be increased each time
448,493c428
<   static Time GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype, bool incFlag, uint32_t &totalAmpduSize, double &totalAmpduNumSymbols);
< 
<   //// WIGIG ////
<   /**
<    * \param txVector the transmission parameters used for this packet
<    *
<    * \return the duration of the EDMG header A
<    */
<   static Time GetEDMG_HeaderA_Duration (WifiTxVector txVector);
<   /**
<    * \param txVector the transmission parameters used for this packet
<    *
<    * \return the duration of the EDMG preamble
<    */
<   static Time GetEDMGPreambleDuration (WifiTxVector txVector);
<   /**
<    * \param txVector the transmission parameters used for this packet
<    *
<    * \return the duration of the EDMG header B
<    */
<   static Time GetEDMG_HeaderB_Duration (WifiTxVector txVector);
<   //// WIGIG ////
< 
<   /**
<    * \param size the number of bytes in the packet to send
<    * \param txvector the transmission parameters used for this packet
<    * \param preamble the type of preamble to use for this packet.
<    *
<    * \return the number of bits in the PPDU.
<    */
<   uint64_t CaluclateTransmittedBits (uint32_t size, WifiTxVector txvector);
<   /**
<    * \return the duration of the last received packet.
<    */
<   Time GetLastRxDuration (void) const;
<   /**
<    * \return the duration of the last transmitted packet.
<    */
<   Time GetLastTxDuration (void) const;
< 
<   /**
<    * \param txVector the transmission parameters used for this packet
<    *
<    * \return the duration until the start of the packet
<    */
<   static Time GetStartOfPacketDuration (WifiTxVector txVector);
---
>   Time GetPayloadDuration (uint32_t size, WifiTxVector txVector, WifiPreamble preamble, double frequency, enum mpduType mpdutype, uint8_t incFlag);
512c447
<   uint8_t GetNModes (void) const;
---
>   virtual uint32_t GetNModes (void) const;
532c467
<   WifiMode GetMode (uint8_t mode) const;
---
>   virtual WifiMode GetMode (uint32_t mode) const;
541c476
<   bool IsModeSupported (WifiMode mode) const;
---
>   virtual bool IsModeSupported (WifiMode mode) const;
545,555c480
<    * \param mcs the wifi mode to check
<    *
<    * \return true if the given mode is supported,
<    *         false otherwise
<    */
<   bool IsMcsSupported (WifiMode mcs) const;
<   /**
<    * Check if the given MCS of the given modulation class is supported by the PHY.
<    *
<    * \param mc the modulation class
<    * \param mcs the MCS value
---
>    * \param mode the wifi mode to check
560c485
<   bool IsMcsSupported (WifiModulationClass mc, uint8_t mcs) const;
---
>   virtual bool IsMcsSupported (WifiMode mcs) const;
566,567c491,492
<    * \return the minimum SNR which is required to achieve
<    *          the requested BER for the specified transmission vector. (W/W)
---
>    * \return the minimum snr which is required to achieve
>    *          the requested ber for the specified transmission vector. (W/W)
569c494
<   double CalculateSnr (WifiTxVector txVector, double ber) const;
---
>   virtual double CalculateSnr (WifiTxVector txVector, double ber) const;
578c503
<   * \return the membership selector whose index is specified.
---
>   * \return the memebership selector whose index is specified.
580c505
<   uint8_t GetNBssMembershipSelectors (void) const;
---
>   virtual uint32_t GetNBssMembershipSelectors (void) const;
590c515
<   * \return the membership selector whose index is specified.
---
>   * \return the memebership selector whose index is specified.
592c517,531
<   uint8_t GetBssMembershipSelector (uint8_t selector) const;
---
>   virtual uint32_t GetBssMembershipSelector (uint32_t selector) const;
>   /**
>    * The WifiPhy::GetMembershipSelectorModes() method is used
>    * (e.g., by a WifiRemoteStationManager) to determine the set of
>    * transmission/reception modes that this WifiPhy(-derived class)
>    * can support - a set of WifiMode objects which we call the
>    * BssMembershipSelectorSet, and which is stored as WifiPhy::m_bssMembershipSelectorSet.
>    *
>    * \param selector index in array of supported memberships
>    *
>    * \return a WifiModeList that contains the WifiModes associrated with the selected index.
>    *
>    * \sa WifiPhy::GetMembershipSelectorModes()
>    */
>   virtual WifiModeList GetMembershipSelectorModes (uint32_t selector);
602c541
<   uint8_t GetNMcs (void) const;
---
>   virtual uint8_t GetNMcs (void) const;
614,655c553
<   WifiMode GetMcs (uint8_t mcs) const;
<   /**
<    * Get the WifiMode object corresponding to the given MCS of the given
<    * modulation class.
<    *
<    * \param modulation the modulation class
<    * \param mcs the MCS value
<    *
<    * \return the WifiMode object corresponding to the given MCS of the given
<    *         modulation class
<    */
<   WifiMode GetMcs (WifiModulationClass modulation, uint8_t mcs) const;
<   /**
<    * Get the WifiMode object corresponding to the given MCS of the
<    * HT modulation class.
<    *
<    * \param mcs the MCS value
<    *
<    * \return the WifiMode object corresponding to the given MCS of the
<    *         HT modulation class
<    */
<   WifiMode GetHtMcs (uint8_t mcs) const;
<   /**
<    * Get the WifiMode object corresponding to the given MCS of the
<    * VHT modulation class.
<    *
<    * \param mcs the MCS value
<    *
<    * \return the WifiMode object corresponding to the given MCS of the
<    *         VHT modulation class
<    */
<   WifiMode GetVhtMcs (uint8_t mcs) const;
<   /**
<    * Get the WifiMode object corresponding to the given MCS of the
<    * HE modulation class.
<    *
<    * \param mcs the MCS value
<    *
<    * \return the WifiMode object corresponding to the given MCS of the
<    *         HE modulation class
<    */
<   WifiMode GetHeMcs (uint8_t mcs) const;
---
>   virtual WifiMode GetMcs (uint8_t mcs) const;
662c560
<    * where Starting channel frequency is standard-dependent,
---
>    * where Starting channel frequency is standard-dependent, see SetStandard()
664c562
<    * This method may fail to take action if the PHY model determines that
---
>    * This method may fail to take action if the Phy model determines that
669c567
<   virtual void SetChannelNumber (uint8_t id);
---
>   virtual void SetChannelNumber (uint16_t id);
675c573
<   uint8_t GetChannelNumber (void) const;
---
>   virtual uint16_t GetChannelNumber (void) const;
679c577
<   Time GetChannelSwitchDelay (void) const;
---
>   virtual Time GetChannelSwitchDelay (void) const;
686,692c584
<   virtual void ConfigureStandard (WifiPhyStandard standard);
<   /**
<    * Configure the PHY-level parameters for different Wi-Fi standard.
<    *
<    * \param standard the Wi-Fi standard
<    */
<   virtual void DoConfigureStandard (void);
---
>   virtual void ConfigureStandard (enum WifiPhyStandard standard);
699c591
<   WifiPhyStandard GetStandard (void) const;
---
>   virtual enum WifiPhyStandard GetStandard (void) const;
703c595
<    * WifiPhyStandard) may then be used to lookup a pair (frequency,
---
>    * WifiPhyStandard) may then be used to lookup a pair (frequency, 
716c608
<   bool DefineChannelNumber (uint8_t channelNumber, WifiPhyStandard standard, uint16_t frequency, uint16_t channelWidth);
---
>   bool DefineChannelNumber (uint16_t channelNumber, enum WifiPhyStandard standard, uint32_t frequency, uint32_t channelWidth);
721c613
<   typedef std::pair<uint8_t, WifiPhyStandard> ChannelNumberStandardPair;
---
>   typedef std::pair<uint16_t, enum WifiPhyStandard> ChannelNumberStandardPair;
723c615
<    * A pair of a center Frequency (MHz) and a ChannelWidth (MHz)
---
>    * A pair of a center Frequency and a ChannelWidth
725c617
<   typedef std::pair<uint16_t, uint16_t> FrequencyWidthPair;
---
>   typedef std::pair<uint32_t, uint32_t> FrequencyWidthPair;
728c620
<    * Return the Channel this WifiPhy is connected to.
---
>    * Return the WifiChannel this WifiPhy is connected to.
730c622
<    * \return the Channel this WifiPhy is connected to
---
>    * \return the WifiChannel this WifiPhy is connected to
732c624
<   virtual Ptr<Channel> GetChannel (void) const = 0;
---
>   virtual Ptr<WifiChannel> GetChannel (void) const = 0;
1204,1216d1095
< 
<   /**
<    * Return MCS 0 from HE MCS values.
<    *
<    * \return MCS 0 from HE MCS values
<    */
<   static WifiMode GetHeMcs0 ();
<   /**
<    * Return MCS 1 from HE MCS values.
<    *
<    * \return MCS 1 from HE MCS values
<    */
<   static WifiMode GetHeMcs1 ();
1218c1097,1099
<    * Return MCS 2 from HE MCS values.
---
>    * The standard disallows certain combinations of WifiMode, number of
>    * spatial streams, and channel widths.  This method can be used to
>    * check whether this WifiTxVector contains an invalid combination.
1220c1101,1102
<    * \return MCS 2 from HE MCS values
---
>    * \param txVector the WifiTxVector to inspect
>    * \return true if the WifiTxVector parameters are allowed by the standard
1222,1276c1104
<   static WifiMode GetHeMcs2 ();
<   /**
<    * Return MCS 3 from HE MCS values.
<    *
<    * \return MCS 3 from HE MCS values
<    */
<   static WifiMode GetHeMcs3 ();
<   /**
<    * Return MCS 4 from HE MCS values.
<    *
<    * \return MCS 4 from HE MCS values
<    */
<   static WifiMode GetHeMcs4 ();
<   /**
<    * Return MCS 5 from HE MCS values.
<    *
<    * \return MCS 5 from HE MCS values
<    */
<   static WifiMode GetHeMcs5 ();
<   /**
<    * Return MCS 6 from HE MCS values.
<    *
<    * \return MCS 6 from HE MCS values
<    */
<   static WifiMode GetHeMcs6 ();
<   /**
<    * Return MCS 7 from HE MCS values.
<    *
<    * \return MCS 7 from HE MCS values
<    */
<   static WifiMode GetHeMcs7 ();
<   /**
<    * Return MCS 8 from HE MCS values.
<    *
<    * \return MCS 8 from HE MCS values
<    */
<   static WifiMode GetHeMcs8 ();
<   /**
<    * Return MCS 9 from HE MCS values.
<    *
<    * \return MCS 9 from HE MCS values
<    */
<   static WifiMode GetHeMcs9 ();
<   /**
<    * Return MCS 10 from HE MCS values.
<    *
<    * \return MCS 10 from HE MCS values
<    */
<   static WifiMode GetHeMcs10 ();
<   /**
<    * Return MCS 11 from HE MCS values.
<    *
<    * \return MCS 11 from HE MCS values
<    */
<   static WifiMode GetHeMcs11 ();
---
>   static bool IsValidTxVector (WifiTxVector txVector);
1282,1283c1110
<    * \param psdu the PSDU being transmitted
<    * \param txPowerW the transmit power in Watts
---
>    * \param packet the packet being transmitted
1285c1112
<   void NotifyTxBegin (Ptr<const WifiPsdu> psdu, double txPowerW);
---
>   void NotifyTxBegin (Ptr<const Packet> packet);
1290c1117
<    * \param psdu the PSDU being transmitted
---
>    * \param packet the packet that was transmitted
1292c1119
<   void NotifyTxEnd (Ptr<const WifiPsdu> psdu);
---
>   void NotifyTxEnd (Ptr<const Packet> packet);
1297c1124
<    * \param psdu the PSDU being transmitted
---
>    * \param packet the packet that was failed to transmitted
1299c1126
<   void NotifyTxDrop (Ptr<const WifiPsdu> psdu);
---
>   void NotifyTxDrop (Ptr<const Packet> packet);
1304c1131
<    * \param psdu the PSDU being transmitted
---
>    * \param packet the packet being received
1306c1133
<   void NotifyRxBegin (Ptr<const WifiPsdu> psdu);
---
>   void NotifyRxBegin (Ptr<const Packet> packet);
1311c1138
<    * \param psdu the PSDU being transmitted
---
>    * \param packet the packet received
1313c1140
<   void NotifyRxEnd (Ptr<const WifiPsdu> psdu);
---
>   void NotifyRxEnd (Ptr<const Packet> packet);
1318,1319c1145
<    * \param psdu the PSDU being transmitted
<    * \param reason the reason the packet was dropped
---
>    * \param packet the packet that was not successfully received
1321c1147
<   void NotifyRxDrop (Ptr<const WifiPsdu> psdu, WifiPhyRxfailureReason reason);
---
>   void NotifyRxDrop (Ptr<const Packet> packet);
1324c1150
<    * Public method used to fire a MonitorSniffer trace for a wifi PSDU being received.
---
>    * Public method used to fire a MonitorSniffer trace for a wifi packet being received.
1326,1328d1151
<    * This method will extract all MPDUs if packet is an A-MPDU and will fire tracedCallback.
<    * The A-MPDU reference number (RX side) is set within the method. It must be a different value
<    * for each A-MPDU but the same for each subframe within one A-MPDU.
1330c1153
<    * \param psdu the PSDU being received
---
>    * \param packet the packet being received
1338,1346c1161,1172
<    * \param txVector the TXVECTOR that holds RX parameters
<    * \param signalNoise signal power and noise power in dBm (noise power includes the noise figure)
<    * \param statusPerMpdu reception status per MPDU
<    */
<   void NotifyMonitorSniffRx (Ptr<const WifiPsdu> psdu,
<                              uint16_t channelFreqMhz,
<                              WifiTxVector txVector,
<                              SignalNoiseDbm signalNoise,
<                              std::vector<bool> statusPerMpdu);
---
>    * \param channelNumber the channel on which the packet is received
>    * \param rate the PHY data rate in units of 500kbps (i.e., the same
>    *        units used both for the radiotap and for the prism header)
>    * \param preamble the preamble of the packet
>    * \param txVector the TXVECTOR that holds rx parameters
>    * \param aMpdu the type of the packet (0 is not A-MPDU, 1 is a MPDU that is part of an A-MPDU and 2 is the last MPDU in an A-MPDU)
>    *        and the A-MPDU reference number (must be a different value for each A-MPDU but the same for each subframe within one A-MPDU)
>    * \param signalNoise signal power and noise power in dBm
>    */
>   void NotifyMonitorSniffRx (Ptr<const Packet> packet, uint16_t channelFreqMhz,
>                              uint16_t channelNumber, uint32_t rate, WifiPreamble preamble,
>                              WifiTxVector txVector, struct mpduInfo aMpdu, struct signalNoiseDbm signalNoise);
1360c1186,1190
<    * \param txVector the TXVECTOR that holds RX parameters
---
>    * \param channelNumber the channel on which the packet is received
>    * \param rate the PHY data rate in units of 500kbps (i.e., the same
>    *        units used both for the radiotap and for the prism header)
>    * \param preamble the preamble of the packet
>    * \param txVector the TXVECTOR that holds rx parameters
1367,1371c1197,1199
<   typedef void (* MonitorSnifferRxCallback)(Ptr<const Packet> packet,
<                                             uint16_t channelFreqMhz,
<                                             WifiTxVector txVector,
<                                             MpduInfo aMpdu,
<                                             SignalNoiseDbm signalNoise);
---
>   typedef void (* MonitorSnifferRxCallback)(Ptr<const Packet> packet, uint16_t channelFreqMhz,
>                                             uint16_t channelNumber, uint32_t rate, WifiPreamble preamble,
>                                             WifiTxVector txVector, struct mpduInfo aMpdu, struct signalNoiseDbm signalNoise);
1374c1202
<    * Public method used to fire a MonitorSniffer trace for a wifi PSDU being transmitted.
---
>    * Public method used to fire a MonitorSniffer trace for a wifi packet being transmitted.
1376,1378d1203
<    * This method will extract all MPDUs if packet is an A-MPDU and will fire tracedCallback.
<    * The A-MPDU reference number (RX side) is set within the method. It must be a different value
<    * for each A-MPDU but the same for each subframe within one A-MPDU.
1380c1205
<    * \param psdu the PSDU being received
---
>    * \param packet the packet being transmitted
1383c1208,1214
<    * \param txVector the TXVECTOR that holds TX parameters
---
>    * \param channelNumber the channel on which the packet is transmitted
>    * \param rate the PHY data rate in units of 500kbps (i.e., the same
>    *        units used both for the radiotap and for the prism header)
>    * \param preamble the preamble of the packet
>    * \param txVector the TXVECTOR that holds tx parameters
>    * \param aMpdu the type of the packet (0 is not A-MPDU, 1 is a MPDU that is part of an A-MPDU and 2 is the last MPDU in an A-MPDU)
>    *        and the A-MPDU reference number (must be a different value for each A-MPDU but the same for each subframe within one A-MPDU)
1385,1387c1216,1218
<   void NotifyMonitorSniffTx (Ptr<const WifiPsdu> psdu,
<                              uint16_t channelFreqMhz,
<                              WifiTxVector txVector);
---
>   void NotifyMonitorSniffTx (Ptr<const Packet> packet, uint16_t channelFreqMhz,
>                              uint16_t channelNumber, uint32_t rate, WifiPreamble preamble,
>                              WifiTxVector txVector, struct mpduInfo aMpdu);
1395c1226,1230
<    * \param txVector the TXVECTOR that holds TX parameters
---
>    * \param channelNumber the channel on which the packet is transmitted
>    * \param rate the PHY data rate in units of 500kbps (i.e., the same
>    *        units used both for the radiotap and for the prism header)
>    * \param preamble the preamble of the packet
>    * \param txVector the TXVECTOR that holds tx parameters
1401,1436c1236,1238
<   typedef void (* MonitorSnifferTxCallback)(const Ptr<const Packet> packet,
<                                             uint16_t channelFreqMhz,
<                                             WifiTxVector txVector,
<                                             MpduInfo aMpdu);
< 
<   /**
<    * TracedCallback signature for PSDU transmit events.
<    *
<    * \param psdu the PSDU being transmitted
<    * \param txVector the TXVECTOR holding the TX parameters
<    * \param txPowerW the transmit power in Watts
<    */
<   typedef void (* PsduTxBeginCallback)(Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW);
< 
<   /**
<    * Public method used to fire a EndOfHePreamble trace once both HE SIG fields have been received, as well as training fields.
<    *
<    * \param params the HE preamble parameters
<    */
<   void NotifyEndOfHePreamble (HePreambleParameters params);
< 
<   /**
<    * TracedCallback signature for end of HE-SIG-A events.
<    *
<    *
<    * \param params the HE preamble parameters
<    */
<   typedef void (* EndOfHePreambleCallback)(HePreambleParameters params);
< 
<   /**
<    * TracedCallback signature for start of PSDU reception events.
<    *
<    * \param txVector the TXVECTOR decoded from the PHY header
<    * \param psduDuration the duration of the PSDU
<    */
<   typedef void (* PhyRxPayloadBeginTracedCallback)(WifiTxVector txVector, Time psduDuration);
---
>   typedef void (* MonitorSnifferTxCallback)(const Ptr<const Packet> packet, uint16_t channelFreqMhz,
>                                             uint16_t channelNumber, uint32_t rate, WifiPreamble preamble,
>                                             WifiTxVector txVector, struct mpduInfo aMpdu);
1451c1253
<    * this threshold (dBm) to allow the PHY layer to detect the signal.
---
>    * this threshold (dbm) to allow the PHY layer to detect the signal.
1453,1455c1255
<    * \param threshold the energy detection threshold in dBm
<    *
<    * \deprecated
---
>    * \param threshold the energy detction threshold in dBm
1459,1461c1259
<    * Sets the receive sensitivity threshold (dBm).
<    * The energy of a received signal should be higher than
<    * this threshold to allow the PHY layer to detect the signal.
---
>    * Return the energy detection threshold (dBm).
1463c1261
<    * \param threshold the receive sensitivity threshold in dBm
---
>    * \return the energy detection threshold in dBm
1465c1263
<   void SetRxSensitivity (double threshold);
---
>   double GetEdThreshold (void) const;
1467c1265
<    * Return the receive sensitivity threshold (dBm).
---
>    * Return the energy detection threshold.
1469c1267
<    * \return the receive sensitivity threshold in dBm
---
>    * \return the energy detection threshold.
1471c1269
<   double GetRxSensitivity (void) const;
---
>   double GetEdThresholdW (void) const;
1479c1277
<   void SetCcaEdThreshold (double threshold);
---
>   void SetCcaMode1Threshold (double threshold);
1485c1283
<   double GetCcaEdThreshold (void) const;
---
>   double GetCcaMode1Threshold (void) const;
1509c1307
<   double GetTxPowerStart (void) const;
---
>   virtual double GetTxPowerStart (void) const;
1521c1319
<   double GetTxPowerEnd (void) const;
---
>   virtual double GetTxPowerEnd (void) const;
1529c1327
<   void SetNTxPower (uint8_t n);
---
>   void SetNTxPower (uint32_t n);
1535c1333
<   uint8_t GetNTxPower (void) const;
---
>   virtual uint32_t GetNTxPower (void) const;
1560d1357
< 
1566c1363
<   void SetDevice (const Ptr<NetDevice> device);
---
>   void SetDevice (Ptr<NetDevice> device);
1583c1380
<   void SetMobility (const Ptr<MobilityModel> mobility);
---
>   void SetMobility (Ptr<MobilityModel> mobility);
1593c1390
<   Ptr<MobilityModel> GetMobility (void) const;
---
>   Ptr<MobilityModel> GetMobility (void);
1598c1395
<   virtual void SetFrequency (uint16_t freq);
---
>   virtual void SetFrequency (uint32_t freq);
1600c1397
<    * \return the operating center frequency (MHz)
---
>    * \return the operating center frequency (MHz) 
1602c1399
<   uint16_t GetFrequency (void) const;
---
>   virtual uint32_t GetFrequency (void) const;
1604c1401
<    * \param antennas the number of antennas on this node.
---
>    * \param tx the number of transmitters on this node.
1606c1403
<   void SetNumberOfAntennas (uint8_t antennas);
---
>   virtual void SetNumberOfTransmitAntennas (uint32_t tx);
1608c1405
<    * \return the number of antennas on this device
---
>    * \return the number of transmit antenna on this device
1610c1407
<   uint8_t GetNumberOfAntennas (void) const;
---
>   virtual uint32_t GetNumberOfTransmitAntennas (void) const;
1612,1614c1409,1411
<    * \param streams the maximum number of supported TX spatial streams.
<    */
<   void SetMaxSupportedTxSpatialStreams (uint8_t streams);
---
>   * \param rx the number of receivers on this node.
>   */
>   virtual void SetNumberOfReceiveAntennas (uint32_t rx);
1616c1413
<    * \return the maximum number of supported TX spatial streams
---
>    * \return the number of receivers on this node.
1618c1415,1416
<   uint8_t GetMaxSupportedTxSpatialStreams (void) const;
---
>   virtual uint32_t GetNumberOfReceiveAntennas (void) const;
> 
1620c1418,1420
<    * \param streams the maximum number of supported RX spatial streams.
---
>    * Enable or disable short/long guard interval.
>    *
>    * \param guardInterval Enable or disable guard interval
1622c1422
<   void SetMaxSupportedRxSpatialStreams (uint8_t streams);
---
>   virtual void SetGuardInterval (bool guardInterval);
1624c1424,1426
<    * \return the maximum number of supported RX spatial streams
---
>    * Return whether guard interval is being used.
>    *
>    * \return true if guard interval is being used, false otherwise
1626c1428
<   uint8_t GetMaxSupportedRxSpatialStreams (void) const;
---
>   virtual bool GetGuardInterval (void) const;
1628,1632c1430,1431
<    * Enable or disable support for HT/VHT short guard interval.
<    *
<    * \param shortGuardInterval Enable or disable support for short guard interval
<    *
<    * \deprecated
---
>    * Enable or disable LDPC.
>    * \param ldpc Enable or disable LDPC
1634c1433
<   void SetShortGuardInterval (bool shortGuardInterval);
---
>   virtual void SetLdpc (bool ldpc);
1636,1638c1435
<    * Return whether short guard interval is supported.
<    *
<    * \return true if short guard interval is supported, false otherwise
---
>    * Return if LDPC is supported.
1640c1437
<    * \deprecated
---
>    * \return true if LDPC is supported, false otherwise
1642c1439
<   bool GetShortGuardInterval (void) const;
---
>   virtual bool GetLdpc (void) const;
1644c1441
<    * \param guardInterval the supported HE guard interval
---
>    * Enable or disable STBC.
1646c1443
<    * \deprecated
---
>    * \param stbc Enable or disable STBC
1648c1445
<   void SetGuardInterval (Time guardInterval);
---
>   virtual void SetStbc (bool stbc);
1650c1447
<    * \return the supported HE guard interval
---
>    * Return whether STBC is supported.
1652c1449
<    * \deprecated
---
>    * \return true if STBC is supported, false otherwise
1654c1451
<   Time GetGuardInterval (void) const;
---
>   virtual bool GetStbc (void) const;
1659,1660d1455
<    *
<    * \deprecated
1662c1457
<   void SetGreenfield (bool greenfield);
---
>   virtual void SetGreenfield (bool greenfield);
1667,1668d1461
<    *
<    * \deprecated
1670c1463
<   bool GetGreenfield (void) const;
---
>   virtual bool GetGreenfield (void) const;
1672c1465
<    * Enable or disable short PHY preamble.
---
>    * Enable or disable short PLCP preamble.
1674c1467
<    * \param preamble sets whether short PHY preamble is supported or not
---
>    * \param preamble sets whether short PLCP preamble is supported or not
1676c1469
<   void SetShortPhyPreambleSupported (bool preamble);
---
>   virtual void SetShortPlcpPreambleSupported (bool preamble);
1678c1471
<    * Return whether short PHY preamble is supported.
---
>    * Return whether short PLCP preamble is supported.
1680c1473
<    * \returns if short PHY preamble is supported or not
---
>    * \returns if short PLCP preamble is supported or not
1682c1475
<   bool GetShortPhyPreambleSupported (void) const;
---
>   virtual bool GetShortPlcpPreambleSupported (void) const;
1689,1701c1482
<   void SetErrorRateModel (const Ptr<ErrorRateModel> rate);
<   /**
<    * Attach a receive ErrorModel to the WifiPhy.
<    *
<    * The WifiPhy may optionally include an ErrorModel in
<    * the packet receive chain. The error model is additive
<    * to any modulation-based error model based on SNR, and
<    * is typically used to force specific packet losses or
<    * for testing purposes.
<    *
<    * \param em Pointer to the ErrorModel.
<    */
<   void SetPostReceptionErrorModel (const Ptr<ErrorModel> em);
---
>   void SetErrorRateModel (Ptr<ErrorRateModel> rate);
1703c1484
<    * Sets the frame capture model.
---
>    * Return the error rate model this PHY is using.
1705c1486
<    * \param frameCaptureModel the frame capture model
---
>    * \return the error rate model this PHY is using
1707c1488,1489
<   void SetFrameCaptureModel (const Ptr<FrameCaptureModel> frameCaptureModel);
---
>   Ptr<ErrorRateModel> GetErrorRateModel (void) const;
> 
1709,1711c1491
<    * Sets the preamble detection model.
<    *
<    * \param preambleDetectionModel the preamble detection model
---
>    * \return the channel width
1713c1493
<   void SetPreambleDetectionModel (const Ptr<PreambleDetectionModel> preambleDetectionModel);
---
>   virtual uint32_t GetChannelWidth (void) const;
1715,1717c1495
<    * Sets the wifi radio energy model.
<    *
<    * \param wifiRadioEnergyModel the wifi radio energy model
---
>    * \param channelwidth channel width
1719,1720c1497
<   void SetWifiRadioEnergyModel (const Ptr<WifiRadioEnergyModel> wifiRadioEnergyModel);
< 
---
>   virtual void SetChannelWidth (uint32_t channelwidth);
1722c1499
<    * \return the channel width in MHz
---
>    * \param channelwidth channel width (in MHz) to support
1724c1501
<   uint16_t GetChannelWidth (void) const;
---
>   virtual void AddSupportedChannelWidth (uint32_t channelwidth);
1726c1503
<    * \param channelWidth the channel width (in MHz)
---
>    * \return a vector containing the supported channel widths, values in MHz
1728c1505
<   virtual void SetChannelWidth (uint16_t channelWidth);
---
>   virtual std::vector<uint32_t> GetSupportedChannelWidthSet (void) const;
1730c1507
<    * \param width the channel width (in MHz) to support
---
>    * \return the maximum number of supported Rx spatial streams
1732c1509
<   void AddSupportedChannelWidth (uint16_t width);
---
>   virtual uint8_t GetSupportedRxSpatialStreams (void) const;
1734c1511
<    * \return a vector containing the supported channel widths, values in MHz
---
>    * \return the maximum number of supported Tx spatial streams
1736,1737c1513
<   std::vector<uint16_t> GetSupportedChannelWidthSet (void) const;
< 
---
>   virtual uint8_t GetSupportedTxSpatialStreams (void) const;
1739,1740c1515
<    * Get the power of the given power level in dBm.
<    * In SpectrumWifiPhy implementation, the power levels are equally spaced (in dBm).
---
>    * Convert from dBm to Watts.
1742c1517
<    * \param power the power level
---
>    * \param dbm the power in dBm
1744c1519
<    * \return the transmission power in dBm at the given power level
---
>    * \return the equivalent Watts for the given dBm
1746,1747c1521
<   double GetPowerDbm (uint8_t power) const;
< 
---
>   double DbmToW (double dbm) const;
1749c1523,1525
<    * Reset PHY to IDLE, with some potential TX power restrictions for the next transmission.
---
>    * Convert from dB to ratio.
>    *
>    * \param db
1751,1753c1527
<    * \param powerRestricted flag whether the transmit power is restricted for the next transmission
<    * \param txPowerMaxSiso the SISO transmit power restriction for the next transmission in dBm
<    * \param txPowerMaxMimo the MIMO transmit power restriction for the next transmission in dBm
---
>    * \return ratio
1755c1529
<   void ResetCca (bool powerRestricted, double txPowerMaxSiso = 0, double txPowerMaxMimo = 0);
---
>   double DbToRatio (double db) const;
1757c1531
<    * Compute the transmit power (in dBm) for the next transmission.
---
>    * Convert from Watts to dBm.
1759,1760c1533,1535
<    * \param txVector the TXVECTOR
<    * \return the transmit power in dBm for the next transmission
---
>    * \param w the power in Watts
>    *
>    * \return the equivalent dBm for the given Watts
1762c1537
<   double GetTxPowerForTransmission (WifiTxVector txVector) const;
---
>   double WToDbm (double w) const;
1764,1768c1539,1543
<    * Notify the PHY that an access to the channel was requested.
<    * This is typically called by the channel access manager to
<    * to notify the PHY about an ongoing transmission.
<    * The PHY will use this information to determine whether
<    * it should use power restriction as imposed by OBSS_PD SR.
---
>    * Convert from ratio to dB.
>    *
>    * \param ratio
>    *
>    * \return dB
1770,1771c1545
<   void NotifyChannelAccessRequested (void);
< 
---
>   double RatioToDb (double ratio) const;
1779c1553
<    * The default implementation does nothing and returns true.  This method
---
>    * The default implementation does nothing and returns true.  This method 
1787c1561
<   bool DoChannelSwitch (uint8_t id);
---
>   virtual bool DoChannelSwitch (uint16_t id);
1793c1567
<    * \param frequency frequency to try to switch to in MHz
---
>    * \param frequency frequency to try to switch to
1797c1571
<   bool DoFrequencySwitch (uint16_t frequency);
---
>   virtual bool DoFrequencySwitch (uint32_t frequency);
1800,1808c1574,1575
<    * Check if PHY state should move to CCA busy state based on current
<    * state of interference tracker.  In this model, CCA becomes busy when
<    * the aggregation of all signals as tracked by the InterferenceHelper
<    * class is higher than the CcaEdThreshold
<    */
<   void SwitchMaybeToCcaBusy (void);
<   /**
<    * Due to newly arrived signal, the current reception cannot be continued and has to be aborted
<    * \param reason the reason the reception is aborted
---
>    * Get the power of the given power level in dBm.
>    * In SpectrumWifiPhy implementation, the power levels are equally spaced (in dBm).
1809a1577,1579
>    * \param power the power level
>    *
>    * \return the transmission power in dBm at the given power level
1811,1816c1581,1582
<   void AbortCurrentReception (WifiPhyRxfailureReason reason);
<   /**
<    * Eventually switch to CCA busy
<    */
<   void MaybeCcaBusyDuration (void);
< 
---
>   double GetPowerDbm (uint8_t power) const;
>   
1820a1587,1588
>   uint16_t m_mpdusNum;                 //!< carries the number of expected mpdus that are part of an A-MPDU
>   bool m_plcpSuccess;                  //!< Flag if the PLCP of the packet or the first MPDU in an A-MPDU has been received
1822a1591,1593
>   
>   EventId m_endRxEvent;
>   EventId m_endPlcpRxEvent;
1824,1879c1595
<   EventId m_endRxEvent;                //!< the end of receive event
<   EventId m_endPhyRxEvent;             //!< the end of PHY receive event
<   EventId m_endPreambleDetectionEvent; //!< the end of preamble detection event
< 
<   EventId m_endTxEvent;                //!< the end of transmit event
< 
<   Time m_txDuration;                   //!< Total time spent in sending packets with their preamble.
<   Time m_rxDuration;                   //!< Duration of the last received packet.
< 
<   /**
<    * This vector holds the set of transmission modes that this
<    * WifiPhy(-derived class) can support. In conversation we call this
<    * the DeviceRateSet (not a term you'll find in the standard), and
<    * it is a superset of standard-defined parameters such as the
<    * OperationalRateSet, and the BSSBasicRateSet (which, themselves,
<    * have a superset/subset relationship).
<    *
<    * Mandatory rates relevant to this WifiPhy can be found by
<    * iterating over this vector looking for WifiMode objects for which
<    * WifiMode::IsMandatory() is true.
<    *
<    * A quick note is appropriate here (well, here is as good a place
<    * as any I can find)...
<    *
<    * In the standard there is no text that explicitly precludes
<    * production of a device that does not support some rates that are
<    * mandatory (according to the standard) for PHYs that the device
<    * happens to fully or partially support.
<    *
<    * This approach is taken by some devices which choose to only support,
<    * for example, 6 and 9 Mbps ERP-OFDM rates for cost and power
<    * consumption reasons (i.e., these devices don't need to be designed
<    * for and waste current on the increased linearity requirement of
<    * higher-order constellations when 6 and 9 Mbps more than meet their
<    * data requirements). The wording of the standard allows such devices
<    * to have an OperationalRateSet which includes 6 and 9 Mbps ERP-OFDM
<    * rates, despite 12 and 24 Mbps being "mandatory" rates for the
<    * ERP-OFDM PHY.
<    *
<    * Now this doesn't actually have any impact on code, yet. It is,
<    * however, something that we need to keep in mind for the
<    * future. Basically, the key point is that we can't be making
<    * assumptions like "the Operational Rate Set will contain all the
<    * mandatory rates".
<    */
<   WifiModeList m_deviceRateSet;
<   WifiModeList m_deviceMcsSet; //!< the device MCS set
< 
<   Ptr<Event> m_currentEvent; //!< Hold the current event
<   Ptr<WifiRadioEnergyModel> m_wifiRadioEnergyModel; //!< Wifi radio energy model
<   Ptr<FrameCaptureModel> m_frameCaptureModel; //!< Frame capture model
< 
<   Time m_lastTxDuration;
<   bool m_isConstructed;                     //!< true when ready to set frequency
< 
< protected:
---
> private:
1885c1601
<    * these values needs to be deferred until after attribute construction
---
>    * these values needs to be deferred until after attribute construction 
1888c1604
<    * DoInitialize () is called.
---
>    * DoInitialize () is called.  
1916,1919d1631
<   /**
<    * Configure WifiPhy with appropriate channel frequency and
<    * supported rates for Holland.
<    */
1932,1937c1644
<    * Configure WifiPhy with appropriate channel frequency and
<    * supported rates for 802.11ax standard.
<    */
<   void Configure80211ax (void);
<   /**
<    * Configure the device MCS set with the appropriate HtMcs modes for
---
>    * Configure the device Mcs set with the appropriate HtMcs modes for
1942,1951d1648
<    * Add the given MCS to the device MCS set.
<    *
<    * \param mode the MCS to add to the device MCS set
<    */
<   void PushMcs (WifiMode mode);
<   /**
<    * Rebuild the mapping of MCS values to indices in the device MCS set.
<    */
<   void RebuildMcsMap (void);
<   /**
1953c1650
<    * This method is called when defaults for each standard must be
---
>    * This method is called when defaults for each standard must be 
1958c1655
<   void ConfigureDefaultsForStandard (WifiPhyStandard standard);
---
>   virtual void ConfigureDefaultsForStandard (enum WifiPhyStandard standard);
1967c1664
<   void ConfigureChannelForStandard (WifiPhyStandard standard);
---
>   virtual void ConfigureChannelForStandard (enum WifiPhyStandard standard);
1971,1972c1668,1669
<    * \param frequency The center frequency to use in MHz
<    * \param width The channel width to use in MHz
---
>    * \param frequency The center frequency to use
>    * \param width The channel width to use
1975c1672
<   uint8_t FindChannelNumberForFrequencyWidth (uint16_t frequency, uint16_t width) const;
---
>   uint16_t FindChannelNumberForFrequencyWidth (uint32_t frequency, uint32_t width) const;
1982,2004c1679
<   FrequencyWidthPair GetFrequencyWidthForChannelNumberStandard (uint8_t channelNumber, WifiPhyStandard standard) const;
< 
<   /**
<    * Starting receiving the PPDU after having detected the medium is idle or after a reception switch.
<    *
<    * \param event the event holding incoming PPDU's information
<    * \param rxPowerW the receive power in W
<    */
<   virtual void StartRx (Ptr<Event> event, double rxPowerW);
<   /**
<    * Get the reception status for the provided MPDU and notify.
<    *
<    * \param psdu the arriving MPDU formatted as a PSDU
<    * \param event the event holding incoming PPDU's information
<    * \param relativeMpduStart the relative start time of the MPDU within the A-MPDU. 0 for normal MPDUs
<    * \param mpduDuration the duration of the MPDU
<    *
<    * \return information on MPDU reception: status, signal power (dBm), and noise power (in dBm)
<    */
<   std::pair<bool, SignalNoiseDbm> GetReceptionStatus (Ptr<const WifiPsdu> psdu,
<                                                       Ptr<Event> event,
<                                                       Time relativeMpduStart,
<                                                       Time mpduDuration);
---
>   FrequencyWidthPair GetFrequencyWidthForChannelNumberStandard (uint16_t channelNumber, enum WifiPhyStandard standard) const;
2012,2019c1687
<   TracedCallback<Ptr<const Packet>, double > m_phyTxBeginTrace;
<   /**
<    * The trace source fired when a PSDU begins the transmission process on
<    * the medium.
<    *
<    * \see class CallBackTraceSource
<    */
<   TracedCallback<Ptr<const WifiPsdu>, WifiTxVector, double /* TX power (W) */> m_phyTxPsduBeginTrace;
---
>   TracedCallback<Ptr<const Packet> > m_phyTxBeginTrace;
2030c1698
<    * The trace source fired when the PHY layer drops a packet as it tries
---
>    * The trace source fired when the phy layer drops a packet as it tries
2046,2061d1713
<    * The trace source fired when the reception of the PHY payload (PSDU) begins.
<    *
<    * This traced callback models the behavior of the PHY-RXSTART
<    * primitive which is launched upon correct decoding of
<    * the PHY header and support of modes within.
<    * We thus assume that it is sent just before starting
<    * the decoding of the payload, since it's there that
<    * support of the header's content is checked. In addition,
<    * it's also at that point that the correct decoding of
<    * HT-SIG, VHT-SIGs, and HE-SIGs are checked.
<    *
<    * \see class CallBackTraceSource
<    */
<   TracedCallback<WifiTxVector, Time> m_phyRxPayloadBeginTrace;
< 
<   /**
2070c1722
<    * The trace source fired when the PHY layer drops a packet it has received.
---
>    * The trace source fired when the phy layer drops a packet it has received.
2074c1726
<   TracedCallback<Ptr<const Packet>, WifiPhyRxfailureReason > m_phyRxDropTrace;
---
>   TracedCallback<Ptr<const Packet> > m_phyRxDropTrace;
2077c1729
<    * A trace source that emulates a Wi-Fi device in monitor mode
---
>    * A trace source that emulates a wifi device in monitor mode
2086c1738
<    *       const references because of their sizes.
---
>    * const  references because of their sizes.
2088c1740,1741
<   TracedCallback<Ptr<const Packet>, uint16_t, WifiTxVector, MpduInfo, SignalNoiseDbm> m_phyMonitorSniffRxTrace;
---
>   TracedCallback<Ptr<const Packet>, uint16_t, uint16_t, uint32_t,
>                  WifiPreamble, WifiTxVector, struct mpduInfo, struct signalNoiseDbm> m_phyMonitorSniffRxTrace;
2091c1744
<    * A trace source that emulates a Wi-Fi device in monitor mode
---
>    * A trace source that emulates a wifi device in monitor mode
2102,2103c1755,1757
<   TracedCallback<Ptr<const Packet>, uint16_t, WifiTxVector, MpduInfo> m_phyMonitorSniffTxTrace;
< 
---
>   TracedCallback<Ptr<const Packet>, uint16_t, uint16_t, uint32_t,
>                  WifiPreamble, WifiTxVector, struct mpduInfo> m_phyMonitorSniffTxTrace;
>     
2105c1759,1764
<    * A trace source that indicates the end of both HE SIG fields as well as training fields for received 802.11ax packets
---
>    * This vector holds the set of transmission modes that this
>    * WifiPhy(-derived class) can support. In conversation we call this
>    * the DeviceRateSet (not a term you'll find in the standard), and
>    * it is a superset of standard-defined parameters such as the
>    * OperationalRateSet, and the BSSBasicRateSet (which, themselves,
>    * have a superset/subset relationship).
2107c1766,1792
<    * \see class CallBackTraceSource
---
>    * Mandatory rates relevant to this WifiPhy can be found by
>    * iterating over this vector looking for WifiMode objects for which
>    * WifiMode::IsMandatory() is true.
>    *
>    * A quick note is appropriate here (well, here is as good a place
>    * as any I can find)...
>    *
>    * In the standard there is no text that explicitly precludes
>    * production of a device that does not support some rates that are
>    * mandatory (according to the standard) for PHYs that the device
>    * happens to fully or partially support.
>    *
>    * This approach is taken by some devices which choose to only support,
>    * for example, 6 and 9 Mbps ERP-OFDM rates for cost and power
>    * consumption reasons (i.e., these devices don't need to be designed
>    * for and waste current on the increased linearity requirement of
>    * higher-order constellations when 6 and 9 Mbps more than meet their
>    * data requirements). The wording of the standard allows such devices
>    * to have an OperationalRateSet which includes 6 and 9 Mbps ERP-OFDM
>    * rates, despite 12 and 24 Mbps being "mandatory" rates for the
>    * ERP-OFDM PHY.
>    *
>    * Now this doesn't actually have any impact on code, yet. It is,
>    * however, something that we need to keep in mind for the
>    * future. Basically, the key point is that we can't be making
>    * assumptions like "the Operational Rate Set will contain all the
>    * mandatory rates".
2109,2112c1794,1795
<   TracedCallback<HePreambleParameters> m_phyEndOfHePreambleTrace;
< 
<   /// Maps MCS values to indices in m_deviceMcsSet, for HT, VHT and HE modulation classes
<   std::map<WifiModulationClass, std::map<uint8_t /* MCS value */, uint8_t /* index */>> m_mcsIndexMap;
---
>   WifiModeList m_deviceRateSet;
>   WifiModeList m_deviceMcsSet;
2114c1797
<   std::vector<uint8_t> m_bssMembershipSelectorSet; //!< the BSS membership selector set
---
>   std::vector<uint32_t> m_bssMembershipSelectorSet;
2116,2118c1799,1802
<   WifiPhyStandard m_standard;               //!< WifiPhyStandard
<   uint16_t m_channelCenterFrequency;        //!< Center frequency in MHz
<   uint16_t m_initialFrequency;              //!< Store frequency until initialization (MHz)
---
>   enum WifiPhyStandard m_standard;     //!< WifiPhyStandard
>   bool m_isConstructed;                //!< true when ready to set frequency
>   uint32_t m_channelCenterFrequency;   //!< Center frequency in MHz
>   uint32_t m_initialFrequency;         //!< Store frequency until initialization
2120c1804
<   uint16_t m_channelWidth;                  //!< Channel width (MHz)
---
>   uint32_t m_channelWidth;             //!< Channel width
2122,2123c1806,1807
<   double   m_rxSensitivityW;      //!< Receive sensitivity threshold in watts
<   double   m_ccaEdThresholdW;     //!< Clear channel assessment (CCA) threshold in watts
---
>   double m_edThresholdW;          //!< Energy detection threshold in watts
>   double   m_ccaMode1ThresholdW;  //!< Clear channel assessment (CCA) threshold in watts
2128,2150c1812,1828
<   uint8_t  m_nTxPower;            //!< Number of available transmission power levels
< 
<   bool m_powerRestricted;        //!< Flag whether transmit power is restricted by OBSS PD SR
<   double m_txPowerMaxSiso;       //!< SISO maximum transmit power due to OBSS PD SR power restriction (dBm)
<   double m_txPowerMaxMimo;       //!< MIMO maximum transmit power due to OBSS PD SR power restriction (dBm)
<   bool m_channelAccessRequested; //!< Flag if channels access has been requested (used for OBSS_PD SR)
< 
<   bool     m_greenfield;         //!< Flag if GreenField format is supported (deprecated)
<   bool     m_shortGuardInterval; //!< Flag if HT/VHT short guard interval is supported (deprecated)
<   bool     m_shortPreamble;      //!< Flag if short PHY preamble is supported
< 
<   Time m_guardInterval; //!< Supported HE guard interval (deprecated)
< 
<   uint8_t m_numberOfAntennas;  //!< Number of transmitters
<   uint8_t m_txSpatialStreams;  //!< Number of supported TX spatial streams
<   uint8_t m_rxSpatialStreams;  //!< Number of supported RX spatial streams
< 
<   typedef std::map<ChannelNumberStandardPair,FrequencyWidthPair> ChannelToFrequencyWidthMap; //!< channel to frequency width map typedef
<   static ChannelToFrequencyWidthMap m_channelToFrequencyWidth;                               //!< the channel to frequency width map
< 
<   std::vector<uint16_t> m_supportedChannelWidthSet; //!< Supported channel width set (MHz)
<   uint8_t               m_channelNumber;            //!< Operating channel number
<   uint8_t               m_initialChannelNumber;     //!< Initial channel number
---
>   uint32_t m_nTxPower;            //!< Number of available transmission power levels
>   
>   bool     m_ldpc;                  //!< Flag if LDPC is used
>   bool     m_stbc;                  //!< Flag if STBC is used
>   bool     m_greenfield;            //!< Flag if GreenField format is supported
>   bool     m_guardInterval;         //!< Flag if short guard interval is used
>   bool     m_shortPreamble;         //!< Flag if short PLCP preamble is supported
> 
>   uint32_t m_numberOfTransmitters;     //!< Number of transmitters
>   uint32_t m_numberOfReceivers;        //!< Number of receivers
> 
>   typedef std::map<ChannelNumberStandardPair,FrequencyWidthPair> ChannelToFrequencyWidthMap;
>   static ChannelToFrequencyWidthMap m_channelToFrequencyWidth;
> 
>   std::vector<uint32_t> m_supportedChannelWidthSet; //!< Supported channel width
>   uint16_t             m_channelNumber;  //!< Operating channel number
>   uint16_t             m_initialChannelNumber;  //!< Initial channel number
2153c1831,1833
< 
---
>   uint32_t m_totalAmpduSize;     //!< Total size of the previously transmitted MPDUs in an A-MPDU, used for the computation of the number of symbols needed for the last MPDU in the A-MPDU
>   double m_totalAmpduNumSymbols; //!< Number of symbols previously transmitted for the MPDUs in an A-MPDU, used for the computation of the number of symbols needed for the last MPDU in the A-MPDU
>   
2156,2161d1835
< 
<   Ptr<PreambleDetectionModel> m_preambleDetectionModel; //!< Preamble detection model
<   Ptr<ErrorModel> m_postReceptionErrorModel;            //!< Error model for receive packet events
<   Time m_timeLastPreambleDetected;                      //!< Record the time the last preamble was detected
< 
<   Callback<void> m_capabilitiesChangedCallback;         //!< Callback when PHY capabilities changed
2162a1837,1843
> 
> /**
>  * \param os          output stream
>  * \param state       wifi state to stringify
>  * \return output stream
>  */
> std::ostream& operator<< (std::ostream& os, enum WifiPhy::State state);
Only in ../../NS3-WiGig/src/wifi/model: wifi-phy-header.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-phy-header.h
Only in ../../NS3-WiGig/src/wifi/model: wifi-phy-listener.h
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-standard.h ../../ns-3-dev/src/wifi/model/wifi-phy-standard.h
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
19,20c18
<  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
<  *          Hany Assasa <Hany.assasa@gmail.com>
---
>  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
50c48
<   /** HT PHY for the 2.4 GHz band (clause 20) */
---
>   /** HT OFDM PHY for the 2.4 GHz band (clause 20) */
52c50
<   /** HT PHY for the 5 GHz band (clause 20) */
---
>   /** HT OFDM PHY for the 5 GHz band (clause 20) */
54,58c52
<   /** PHY for 802.11ad (Clause 21) */
<   WIFI_PHY_STANDARD_80211ad,
<   /** PHY for 802.11ay (Clause 29) */
<   WIFI_PHY_STANDARD_80211ay,
<   /** VHT PHY (clause 22) */
---
>   /** VHT OFDM PHY (clause 22) */
60,63d53
<   /** HE PHY for the 2.4 GHz band (clause 26) */
<   WIFI_PHY_STANDARD_80211ax_2_4GHZ,
<   /** HE PHY for the 5 GHz band (clause 26) */
<   WIFI_PHY_STANDARD_80211ax_5GHZ,
66,75d55
< };
< 
< /**
<  * \ingroup wifi
<  * Identifies the TRN Field to appended to the end of the packet.
<  */
< enum PacketType {
<   TRN_R  = 0,
<   TRN_T  = 1,
<   TRN_RT = 2,
Only in ../../NS3-WiGig/src/wifi/model: wifi-phy-state.h
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-state-helper.cc ../../ns-3-dev/src/wifi/model/wifi-phy-state-helper.cc
21c21
< #include <algorithm>
---
> #include "wifi-phy-state-helper.h"
24,28c24,25
< #include "ns3/packet.h"
< #include "wifi-phy-state-helper.h"
< #include "wifi-tx-vector.h"
< #include "wifi-phy-listener.h"
< #include "wifi-psdu.h"
---
> #include "ns3/trace-source-accessor.h"
> #include <algorithm>
63,64c60,61
<   : m_sleeping (false),
<     m_isOff (false),
---
>   : m_rxing (false),
>     m_sleeping (false),
80c77
< WifiPhyStateHelper::SetReceiveOkCallback (RxOkCallback callback)
---
> WifiPhyStateHelper::SetReceiveOkCallback (WifiPhy::RxOkCallback callback)
86c83
< WifiPhyStateHelper::SetReceiveErrorCallback (RxErrorCallback callback)
---
> WifiPhyStateHelper::SetReceiveErrorCallback (WifiPhy::RxErrorCallback callback)
108c105
< WifiPhyStateHelper::IsStateIdle (void) const
---
> WifiPhyStateHelper::IsStateIdle (void)
110c107
<   return (GetState () == WifiPhyState::IDLE);
---
>   return (GetState () == WifiPhy::IDLE);
114c111
< WifiPhyStateHelper::IsStateCcaBusy (void) const
---
> WifiPhyStateHelper::IsStateBusy (void)
116c113
<   return (GetState () == WifiPhyState::CCA_BUSY);
---
>   return (GetState () != WifiPhy::IDLE);
120c117
< WifiPhyStateHelper::IsStateRx (void) const
---
> WifiPhyStateHelper::IsStateCcaBusy (void)
122c119
<   return (GetState () == WifiPhyState::RX);
---
>   return (GetState () == WifiPhy::CCA_BUSY);
126c123
< WifiPhyStateHelper::IsStateTx (void) const
---
> WifiPhyStateHelper::IsStateRx (void)
128c125
<   return (GetState () == WifiPhyState::TX);
---
>   return (GetState () == WifiPhy::RX);
132c129
< WifiPhyStateHelper::IsStateSwitching (void) const
---
> WifiPhyStateHelper::IsStateTx (void)
134c131
<   return (GetState () == WifiPhyState::SWITCHING);
---
>   return (GetState () == WifiPhy::TX);
138c135
< WifiPhyStateHelper::IsStateSleep (void) const
---
> WifiPhyStateHelper::IsStateSwitching (void)
140c137
<   return (GetState () == WifiPhyState::SLEEP);
---
>   return (GetState () == WifiPhy::SWITCHING);
144c141
< WifiPhyStateHelper::IsStateOff (void) const
---
> WifiPhyStateHelper::IsStateSleep (void)
146c143
<   return (GetState () == WifiPhyState::OFF);
---
>   return (GetState () == WifiPhy::SLEEP);
150c147,153
< WifiPhyStateHelper::GetDelayUntilIdle (void) const
---
> WifiPhyStateHelper::GetStateDuration (void)
> {
>   return Simulator::Now () - m_previousStateChangeTime;
> }
> 
> Time
> WifiPhyStateHelper::GetDelayUntilIdle (void)
156c159
<     case WifiPhyState::RX:
---
>     case WifiPhy::RX:
159c162
<     case WifiPhyState::TX:
---
>     case WifiPhy::TX:
162c165
<     case WifiPhyState::CCA_BUSY:
---
>     case WifiPhy::CCA_BUSY:
165c168
<     case WifiPhyState::SWITCHING:
---
>     case WifiPhy::SWITCHING:
168,170c171,175
<     case WifiPhyState::IDLE:
<     case WifiPhyState::SLEEP:
<     case WifiPhyState::OFF:
---
>     case WifiPhy::IDLE:
>       retval = Seconds (0);
>       break;
>     case WifiPhy::SLEEP:
>       NS_FATAL_ERROR ("Cannot determine when the device will wake up.");
188,195c193,194
< Time
< WifiPhyStateHelper::GetLastRxEndTime (void) const
< {
<   return m_endRx;
< }
< 
< WifiPhyState
< WifiPhyStateHelper::GetState (void) const
---
> enum WifiPhy::State
> WifiPhyStateHelper::GetState (void)
197,200d195
<   if (m_isOff)
<     {
<       return WifiPhyState::OFF;
<     }
203c198
<       return WifiPhyState::SLEEP;
---
>       return WifiPhy::SLEEP;
207c202
<       return WifiPhyState::TX;
---
>       return WifiPhy::TX;
209c204
<   else if (m_endRx > Simulator::Now ())
---
>   else if (m_rxing)
211c206
<       return WifiPhyState::RX;
---
>       return WifiPhy::RX;
215c210
<       return WifiPhyState::SWITCHING;
---
>       return WifiPhy::SWITCHING;
219c214
<       return WifiPhyState::CCA_BUSY;
---
>       return WifiPhy::CCA_BUSY;
223c218
<       return WifiPhyState::IDLE;
---
>       return WifiPhy::IDLE;
230d224
<   NS_LOG_FUNCTION (this);
240d233
<   NS_LOG_FUNCTION (this);
250d242
<   NS_LOG_FUNCTION (this);
260d251
<   NS_LOG_FUNCTION (this);
270d260
<   NS_LOG_FUNCTION (this);
280d269
<   NS_LOG_FUNCTION (this);
290d278
<   NS_LOG_FUNCTION (this);
298,307d285
< WifiPhyStateHelper::NotifyOff (void)
< {
<   NS_LOG_FUNCTION (this);
<   for (Listeners::const_iterator i = m_listeners.begin (); i != m_listeners.end (); i++)
<     {
<       (*i)->NotifyOff ();
<     }
< }
< 
< void
310d287
<   NS_LOG_FUNCTION (this);
318,327d294
< WifiPhyStateHelper::NotifyOn (void)
< {
<   NS_LOG_FUNCTION (this);
<   for (Listeners::const_iterator i = m_listeners.begin (); i != m_listeners.end (); i++)
<     {
<       (*i)->NotifyOn ();
<     }
< }
< 
< void
330d296
<   NS_LOG_FUNCTION (this);
343,352c309
<       Time ccaBusyDuration = idleStart - ccaBusyStart;
<       if (ccaBusyDuration.IsStrictlyPositive ())
<         {
<           m_stateLogger (ccaBusyStart, ccaBusyDuration, WifiPhyState::CCA_BUSY);
<         }
<     }
<   Time idleDuration = now - idleStart;
<   if (idleDuration.IsStrictlyPositive ())
<     {
<       m_stateLogger (idleStart, idleDuration, WifiPhyState::IDLE);
---
>       m_stateLogger (ccaBusyStart, idleStart - ccaBusyStart, WifiPhy::CCA_BUSY);
353a311
>   m_stateLogger (idleStart, now - idleStart, WifiPhy::IDLE);
358c316
<                                 WifiTxVector txVector)
---
>                                 WifiTxVector txVector, WifiPreamble preamble)
360,361c318
<   NS_LOG_FUNCTION (this << txDuration << packet << txPowerDbm << txVector);
<   m_txTrace (packet, txVector.GetMode (), txVector.GetPreambleType (), txVector.GetTxPowerLevel ());
---
>   m_txTrace (packet, txVector.GetMode (), preamble, txVector.GetTxPowerLevel ());
365c322
<     case WifiPhyState::RX:
---
>     case WifiPhy::RX:
369c326,327
<       m_stateLogger (m_startRx, now - m_startRx, WifiPhyState::RX);
---
>       m_rxing = false;
>       m_stateLogger (m_startRx, now - m_startRx, WifiPhy::RX);
372c330
<     case WifiPhyState::CCA_BUSY:
---
>     case WifiPhy::CCA_BUSY:
377c335
<         m_stateLogger (ccaStart, now - ccaStart, WifiPhyState::CCA_BUSY);
---
>         m_stateLogger (ccaStart, now - ccaStart, WifiPhy::CCA_BUSY);
379c337
<     case WifiPhyState::IDLE:
---
>     case WifiPhy::IDLE:
381a340,341
>     case WifiPhy::SWITCHING:
>     case WifiPhy::SLEEP:
386c346
<   m_stateLogger (now, txDuration, WifiPhyState::TX);
---
>   m_stateLogger (now, txDuration, WifiPhy::TX);
396d355
<   NS_LOG_FUNCTION (this << rxDuration);
397a357
>   NS_ASSERT (!m_rxing);
401c361
<     case WifiPhyState::IDLE:
---
>     case WifiPhy::IDLE:
404c364
<     case WifiPhyState::CCA_BUSY:
---
>     case WifiPhy::CCA_BUSY:
409c369
<         m_stateLogger (ccaStart, now - ccaStart, WifiPhyState::CCA_BUSY);
---
>         m_stateLogger (ccaStart, now - ccaStart, WifiPhy::CCA_BUSY);
411,412c371,375
<     default:
<       NS_FATAL_ERROR ("Invalid WifiPhy state " << GetState ());
---
>     case WifiPhy::SWITCHING:
>     case WifiPhy::RX:
>     case WifiPhy::TX:
>     case WifiPhy::SLEEP:
>       NS_FATAL_ERROR ("Invalid WifiPhy state.");
415a379
>   m_rxing = true;
425d388
<   NS_LOG_FUNCTION (this << switchingDuration);
429c392
<     case WifiPhyState::RX:
---
>     case WifiPhy::RX:
433c396,397
<       m_stateLogger (m_startRx, now - m_startRx, WifiPhyState::RX);
---
>       m_rxing = false;
>       m_stateLogger (m_startRx, now - m_startRx, WifiPhy::RX);
436c400
<     case WifiPhyState::CCA_BUSY:
---
>     case WifiPhy::CCA_BUSY:
441c405
<         m_stateLogger (ccaStart, now - ccaStart, WifiPhyState::CCA_BUSY);
---
>         m_stateLogger (ccaStart, now - ccaStart, WifiPhy::CCA_BUSY);
443c407
<     case WifiPhyState::IDLE:
---
>     case WifiPhy::IDLE:
445a410,412
>     case WifiPhy::TX:
>     case WifiPhy::SWITCHING:
>     case WifiPhy::SLEEP:
456c423
<   m_stateLogger (now, switchingDuration, WifiPhyState::SWITCHING);
---
>   m_stateLogger (now, switchingDuration, WifiPhy::SWITCHING);
465c432
< WifiPhyStateHelper::SwitchFromRxEndOk (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu)
---
> WifiPhyStateHelper::SwitchFromRxEndOk (Ptr<Packet> packet, double snr, WifiTxVector txVector, enum WifiPreamble preamble)
467,471c434
<   NS_LOG_FUNCTION (this << *psdu << snr << txVector << statusPerMpdu.size () <<
<                    std::all_of(statusPerMpdu.begin(), statusPerMpdu.end(), [](bool v) { return v; })); //returns true if all true
<   NS_ASSERT (statusPerMpdu.size () != 0);
<   NS_ASSERT (m_endRx == Simulator::Now ());
<   m_rxOkTrace (psdu->GetPacket (), snr, txVector.GetMode (), txVector.GetPreambleType ());
---
>   m_rxOkTrace (packet, snr, txVector.GetMode (), preamble);
476c439
<       m_rxOkCallback (psdu, snr, txVector, statusPerMpdu);
---
>       m_rxOkCallback (packet, snr, txVector, preamble);
477a441
> 
481c445
< WifiPhyStateHelper::SwitchFromRxEndError (Ptr<WifiPsdu> psdu, double snr)
---
> WifiPhyStateHelper::SwitchFromRxEndError (Ptr<Packet> packet, double snr)
483,485c447
<   NS_LOG_FUNCTION (this << *psdu << snr);
<   NS_ASSERT (m_endRx == Simulator::Now ());
<   m_rxErrorTrace (psdu->GetPacket (), snr);
---
>   m_rxErrorTrace (packet, snr);
490c452
<       m_rxErrorCallback (psdu);
---
>       m_rxErrorCallback (packet, snr);
494,538d455
< //// WIGIG ////
< 
< void
< WifiPhyStateHelper::ReportPsduRxOk (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu)
< {
<   NS_LOG_FUNCTION (this << *psdu << snr << txVector << statusPerMpdu.size () <<
<                    std::all_of(statusPerMpdu.begin(), statusPerMpdu.end(), [](bool v) { return v; })); //returns true if all true
<   NS_ASSERT (statusPerMpdu.size () != 0);
<   m_rxOkTrace (psdu->GetPacket (), snr, txVector.GetMode (), txVector.GetPreambleType ());
<   if (!m_rxOkCallback.IsNull ())
<     {
<       m_rxOkCallback (psdu, snr, txVector, statusPerMpdu);
<     }
< }
< 
< void
< WifiPhyStateHelper::SwitchFromRxEndOk (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_ASSERT (m_endRx == Simulator::Now ());
<   NotifyRxEndOk ();
<   DoSwitchFromRx ();
< }
< 
< void
< WifiPhyStateHelper::ReportPsduEndError (Ptr<WifiPsdu> psdu, double snr)
< {
<   NS_LOG_FUNCTION (this << *psdu << snr);
<   m_rxErrorTrace (psdu->GetPacket (), snr);
<   if (!m_rxErrorCallback.IsNull ())
<     {
<       m_rxErrorCallback (psdu);
<     }
< }
< 
< void
< WifiPhyStateHelper::SwitchFromRxEndError (void)
< {
<   NS_LOG_FUNCTION (this);
<   NotifyRxEndOk ();
<   DoSwitchFromRx ();
< }
< 
< //// WIGIG ////
< 
542c459,461
<   NS_LOG_FUNCTION (this);
---
>   NS_ASSERT (IsStateRx ());
>   NS_ASSERT (m_rxing);
> 
544c463
<   m_stateLogger (m_startRx, now - m_startRx, WifiPhyState::RX);
---
>   m_stateLogger (m_startRx, now - m_startRx, WifiPhy::RX);
546c465,466
<   m_endRx = Simulator::Now ();
---
>   m_rxing = false;
> 
553,557c473
<   NS_LOG_FUNCTION (this << duration);
<   if (GetState () != WifiPhyState::RX)
<     {
<       NotifyMaybeCcaBusyStart (duration);
<     }
---
>   NotifyMaybeCcaBusyStart (duration);
561c477,481
<     case WifiPhyState::IDLE:
---
>     case WifiPhy::SWITCHING:
>       break;
>     case WifiPhy::SLEEP:
>       break;
>     case WifiPhy::IDLE:
564,566c484,488
<     case WifiPhyState::RX:
<       return;
<     default:
---
>     case WifiPhy::CCA_BUSY:
>       break;
>     case WifiPhy::RX:
>       break;
>     case WifiPhy::TX:
569c491
<   if (GetState () != WifiPhyState::CCA_BUSY)
---
>   if (GetState () != WifiPhy::CCA_BUSY)
579d500
<   NS_LOG_FUNCTION (this);
583c504
<     case WifiPhyState::IDLE:
---
>     case WifiPhy::IDLE:
586c507
<     case WifiPhyState::CCA_BUSY:
---
>     case WifiPhy::CCA_BUSY:
591c512
<         m_stateLogger (ccaStart, now - ccaStart, WifiPhyState::CCA_BUSY);
---
>         m_stateLogger (ccaStart, now - ccaStart, WifiPhy::CCA_BUSY);
593c514,517
<     default:
---
>     case WifiPhy::RX:
>     case WifiPhy::SWITCHING:
>     case WifiPhy::TX:
>     case WifiPhy::SLEEP:
607d530
<   NS_LOG_FUNCTION (this << duration);
610c533
<   m_stateLogger (m_startSleep, now - m_startSleep, WifiPhyState::SLEEP);
---
>   m_stateLogger (m_startSleep, now - m_startSleep, WifiPhy::SLEEP);
615,684d537
<   m_endCcaBusy = std::max (m_endCcaBusy, now + duration);
<   if (m_endCcaBusy > now)
<     {
<       NotifyMaybeCcaBusyStart (m_endCcaBusy - now);
<     }
< }
< 
< void
< WifiPhyStateHelper::SwitchFromRxAbort (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_ASSERT (IsStateRx ());
<   NotifyRxEndOk ();
<   DoSwitchFromRx ();
<   m_endCcaBusy = Simulator::Now ();
<   NotifyMaybeCcaBusyStart (Seconds (0));
<   NS_ASSERT (IsStateIdle ());
< }
< 
< void
< WifiPhyStateHelper::SwitchToOff (void)
< {
<   NS_LOG_FUNCTION (this);
<   Time now = Simulator::Now ();
<   switch (GetState ())
<     {
<     case WifiPhyState::RX:
<       /* The packet which is being received as well
<        * as its endRx event are cancelled by the caller.
<        */
<       m_stateLogger (m_startRx, now - m_startRx, WifiPhyState::RX);
<       m_endRx = now;
<       break;
<     case WifiPhyState::TX:
<       /* The packet which is being transmitted as well
<        * as its endTx event are cancelled by the caller.
<        */
<       m_stateLogger (m_startTx, now - m_startTx, WifiPhyState::TX);
<       m_endTx = now;
<       break;
<     case WifiPhyState::IDLE:
<       LogPreviousIdleAndCcaBusyStates ();
<       break;
<     case WifiPhyState::CCA_BUSY:
<       {
<         Time ccaStart = Max (m_endRx, m_endTx);
<         ccaStart = Max (ccaStart, m_startCcaBusy);
<         ccaStart = Max (ccaStart, m_endSwitching);
<         m_stateLogger (ccaStart, now - ccaStart, WifiPhyState::CCA_BUSY);
<       } break;
<     default:
<       NS_FATAL_ERROR ("Invalid WifiPhy state.");
<       break;
<     }
<   m_previousStateChangeTime = now;
<   m_isOff = true;
<   NotifyOff ();
<   NS_ASSERT (IsStateOff ());
< }
< 
< void
< WifiPhyStateHelper::SwitchFromOff (Time duration)
< {
<   NS_LOG_FUNCTION (this << duration);
<   NS_ASSERT (IsStateOff ());
<   Time now = Simulator::Now ();
<   m_previousStateChangeTime = now;
<   m_isOff = false;
<   NotifyOn ();
<   //update m_endCcaBusy after the off period
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-state-helper.h ../../ns-3-dev/src/wifi/model/wifi-phy-state-helper.h
24,25c24
< #include "ns3/object.h"
< #include "ns3/callback.h"
---
> #include "wifi-phy.h"
27,29c26,27
< #include "ns3/nstime.h"
< #include "wifi-phy-state.h"
< #include "wifi-preamble.h"
---
> #include "ns3/object.h"
> #include <vector>
33,56d30
< class WifiPhyListener;
< class WifiTxVector;
< class WifiMode;
< class Packet;
< class WifiPsdu;
< 
< /**
<  * Callback if PSDU successfully received (i.e. if aggregate,
<  * it means that at least one MPDU of the A-MPDU was received,
<  * considering that the per-MPDU reception status is also provided).
<  *
<  * arg1: PSDU received successfully
<  * arg2: SNR of PSDU in linear scale
<  * arg3: TXVECTOR of PSDU
<  * arg4: vector of per-MPDU status of reception.
<  */
< typedef Callback<void, Ptr<WifiPsdu>, double, WifiTxVector, std::vector<bool>> RxOkCallback;
< /**
<  * Callback if PSDU unsuccessfully received
<  *
<  * arg1: PSDU received unsuccessfully
<  */
< typedef Callback<void, Ptr<WifiPsdu>> RxErrorCallback;
< 
65,68d38
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
76c46
<    * \param callback the RxOkCallback to set
---
>    * \param callback
78c48
<   void SetReceiveOkCallback (RxOkCallback callback);
---
>   void SetReceiveOkCallback (WifiPhy::RxOkCallback callback);
82c52
<    * \param callback the RxErrorCallback to set
---
>    * \param callback
84c54
<   void SetReceiveErrorCallback (RxErrorCallback callback);
---
>   void SetReceiveErrorCallback (WifiPhy::RxErrorCallback callback);
88c58
<    * \param listener the WifiPhyListener to register
---
>    * \param listener
94c64
<    * \param listener the WifiPhyListener to unregister
---
>    * \param listener
102c72
<   WifiPhyState GetState (void) const;
---
>   enum WifiPhy::State GetState (void);
108c78
<   bool IsStateCcaBusy (void) const;
---
>   bool IsStateCcaBusy (void);
114c84,90
<   bool IsStateIdle (void) const;
---
>   bool IsStateIdle (void);
>   /**
>    * Check whether the current state is not IDLE.
>    *
>    * \return true if the current state is not IDLE, false otherwise
>    */
>   bool IsStateBusy (void);
120c96
<   bool IsStateRx (void) const;
---
>   bool IsStateRx (void);
126c102
<   bool IsStateTx (void) const;
---
>   bool IsStateTx (void);
132c108
<   bool IsStateSwitching (void) const;
---
>   bool IsStateSwitching (void);
138c114
<   bool IsStateSleep (void) const;
---
>   bool IsStateSleep (void);
140c116
<    * Check whether the current state is OFF.
---
>    * Return the elapsed time of the current state.
142c118
<    * \return true if the current state is OFF, false otherwise
---
>    * \return the elapsed time of the current state
144c120
<   bool IsStateOff (void) const;
---
>   Time GetStateDuration (void);
150c126
<   Time GetDelayUntilIdle (void) const;
---
>   Time GetDelayUntilIdle (void);
157,162d132
<   /**
<    * Return the time the last RX end.
<    *
<    * \return the time the last RX end.
<    */
<   Time GetLastRxEndTime (void) const;
169,170c139,141
<    * \param txPowerDbm the nominal TX power in dBm
<    * \param txVector the TX vector of the packet
---
>    * \param txPowerDbm the nominal tx power in dBm
>    * \param txVector the tx vector of the packet
>    * \param preamble the preamble of the packet
172c143
<   void SwitchToTx (Time txDuration, Ptr<const Packet> packet, double txPowerDbm, WifiTxVector txVector);
---
>   void SwitchToTx (Time txDuration, Ptr<const Packet> packet, double txPowerDbm, WifiTxVector txVector, WifiPreamble preamble);
185,193d155
<   /*
<    * Switch from RX after the reception was successful.
<    *
<    * \param psdu the successfully received PSDU
<    * \param snr the SNR of the received PSDU in linear scale
<    * \param txVector TXVECTOR of the PSDU
<    * \param statusPerMpdu reception status per MPDU
<    */
<   void SwitchFromRxEndOk (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu);
195,204c157
<    * Switch from RX after the reception failed.
<    *
<    * \param psdu the PSDU that we failed to received
<    * \param snr the SNR of the received PSDU in linear scale
<    */
<   void SwitchFromRxEndError (Ptr<WifiPsdu> psdu, double snr);
< 
<   //// WIGIG ////
<   /**
<    * Report correct reception of an PSDU and keep waiting for the TRN Field.
---
>    * Switch from RX after the reception was successful.
206c159
<    * \param psdu the successfully received PSDU
---
>    * \param packet the successfully received packet
209c162
<    * \param statusPerMpdu reception status per MPDU
---
>    * \param preamble the preamble of the received packet
211c164
<   void ReportPsduRxOk (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu);
---
>   void SwitchFromRxEndOk (Ptr<Packet> packet, double snr, WifiTxVector txVector, enum WifiPreamble preamble);
213,217c166
<    * Switch from RX after the reception was successful.
<    */
<   void SwitchFromRxEndOk (void);
<   /**
<    * Report erroronous reception of PSDU and keep waiting for the TRN Field.
---
>    * Switch from RX after the reception failed.
219c168
<    * \param psdu the PSDU that we failed to received
---
>    * \param packet the packet that we failed to received
222,228c171
<   void ReportPsduEndError (Ptr<WifiPsdu> psdu, double snr);
<   /**
<    * Switch from RX after the reception failed.
<    */
<   void SwitchFromRxEndError (void);
<   //// WIGIG ////
< 
---
>   void SwitchFromRxEndError (Ptr<Packet> packet, double snr);
245,258c188,190
<   /**
<    * Abort current reception
<    */
<   void SwitchFromRxAbort (void);
<   /**
<    * Switch to off mode.
<    */
<   void SwitchToOff (void);
<   /**
<    * Switch from off mode.
<    *
<    * \param duration the duration of CCA busy state
<    */
<   void SwitchFromOff (Time duration);
---
> 
>   /** \todo Why is this public? */
>   TracedCallback<Time, Time, enum WifiPhy::State> m_stateLogger;
263c195
<    * \param [in] start Time when the \pname{state} started.
---
>    * \param [in] start Time when the \p state started.
265c197
<    *             the \pname{state}.
---
>    *             the \p state.
268c200,201
<   typedef void (* StateTracedCallback)(Time start, Time duration, WifiPhyState state);
---
>   typedef void (* StateTracedCallback)
>     (Time start, Time duration, WifiPhy::State state);
271c204
<    * TracedCallback signature for receive end OK event.
---
>    * TracedCallback signature for receive end ok event.
274c207
<    * \param [in] snr    The SNR of the received packet in linear scale.
---
>    * \param [in] snr    The SNR of the received packet.
278c211,212
<   typedef void (* RxOkTracedCallback)(Ptr<const Packet> packet, double snr, WifiMode mode, WifiPreamble preamble);
---
>   typedef void (* RxOkTracedCallback)
>     (Ptr<const Packet> packet, double snr, WifiMode mode, WifiPreamble preamble);
284c218
<    * \param [in] snr          The SNR of the received packet in linear scale.
---
>    * \param [in] snr          The SNR of the received packet.
286c220,221
<   typedef void (* RxEndErrorTracedCallback)(Ptr<const Packet> packet, double snr);
---
>   typedef void (* RxEndErrorTracedCallback)
>     (Ptr<const Packet> packet, double snr);
296,297c231,233
<   typedef void (* TxTracedCallback)(Ptr<const Packet> packet, WifiMode mode,
<                                     WifiPreamble preamble, uint8_t power);
---
>   typedef void (* TxTracedCallback)
>     (Ptr<const Packet> packet, WifiMode mode,
>      WifiPreamble preamble, uint8_t power);
305,307d240
<   /**
<    * typedef for a list of WifiPhyListeners iterator
<    */
319c252
<    * \param txPowerDbm the nominal TX power in dBm
---
>    * \param txPowerDbm the nominal tx power in dBm
354,357d286
<    * Notify all WifiPhyListener that we are going to switch off
<    */
<   void NotifyOff (void);
<   /**
365,373d293
<   /**
<    * Notify all WifiPhyListener that we are going to switch on
<    */
<   void NotifyOn (void);
< 
<   /**
<    * The trace source fired when state is changed.
<    */
<   TracedCallback<Time, Time, WifiPhyState> m_stateLogger;
376,394c296,313
<   bool m_sleeping; ///< sleeping
<   bool m_isOff; ///< switched off
<   Time m_endTx; ///< end transmit
<   Time m_endRx; ///< end receive
<   Time m_endCcaBusy; ///< end CCA busy
<   Time m_endSwitching; ///< end switching
<   Time m_startTx; ///< start transmit
<   Time m_startRx; ///< start receive
<   Time m_startCcaBusy; ///< start CCA busy
<   Time m_startSwitching; ///< start switching
<   Time m_startSleep; ///< start sleep
<   Time m_previousStateChangeTime; ///< previous state change time
< 
<   Listeners m_listeners; ///< listeners
<   TracedCallback<Ptr<const Packet>, double, WifiMode, WifiPreamble> m_rxOkTrace; ///< receive OK trace callback
<   TracedCallback<Ptr<const Packet>, double> m_rxErrorTrace; ///< receive error trace callback
<   TracedCallback<Ptr<const Packet>, WifiMode, WifiPreamble, uint8_t> m_txTrace; ///< transmit trace callback
<   RxOkCallback m_rxOkCallback; ///< receive OK callback
<   RxErrorCallback m_rxErrorCallback; ///< receive error callback
---
>   bool m_sleeping;
>   Time m_endTx;
>   Time m_endRx;
>   Time m_endCcaBusy;
>   Time m_endSwitching;
>   Time m_startTx;
>   Time m_startRx;
>   Time m_startCcaBusy;
>   Time m_startSwitching;
>   Time m_startSleep;
>   Time m_previousStateChangeTime;
> 
>   Listeners m_listeners;
>   TracedCallback<Ptr<const Packet>, double, WifiMode, enum WifiPreamble> m_rxOkTrace;
>   TracedCallback<Ptr<const Packet>, double> m_rxErrorTrace;
>   TracedCallback<Ptr<const Packet>,WifiMode,WifiPreamble,uint8_t> m_txTrace;
>   WifiPhy::RxOkCallback m_rxOkCallback;
>   WifiPhy::RxErrorCallback m_rxErrorCallback;
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-tag.cc ../../ns-3-dev/src/wifi/model/wifi-phy-tag.cc
20,21c20
< 
< #include "wifi-phy-tag.h"
---
> #include <ns3/wifi-phy-tag.h>
43c42
<   return 3;
---
>   return (4 + (6 * 1) + 4 + 2);
49,51c48,56
<   i.WriteU8 (static_cast<uint8_t> (m_preamble));
<   i.WriteU8 (static_cast<uint8_t> (m_modulation));
<   i.WriteU8 (m_frameComplete);
---
>   i.WriteU32 (m_wifiTxVector.GetMode ().GetUid ());
>   i.WriteU8 (m_wifiTxVector.GetTxPowerLevel ());
>   i.WriteU8 (m_wifiTxVector.GetRetries ());
>   i.WriteU8 (m_wifiTxVector.IsShortGuardInterval ());
>   i.WriteU8 (m_wifiTxVector.GetNss ());
>   i.WriteU8 (m_wifiTxVector.GetNess ());
>   i.WriteU8 (m_wifiTxVector.IsStbc ());
>   i.WriteU32 (m_wifiPreamble);
>   i.WriteU16 (m_mpduType);
57,59c62,70
<   m_preamble = static_cast<WifiPreamble> (i.ReadU8 ());
<   m_modulation = static_cast<WifiModulationClass> (i.ReadU8 ());
<   m_frameComplete = i.ReadU8 ();
---
>   m_wifiTxVector.SetMode (WifiMode (i.ReadU32 ()));
>   m_wifiTxVector.SetTxPowerLevel (i.ReadU8 ());
>   m_wifiTxVector.SetRetries (i.ReadU8 ());
>   m_wifiTxVector.SetShortGuardInterval (i.ReadU8 ());
>   m_wifiTxVector.SetNss (i.ReadU8 ());
>   m_wifiTxVector.SetNess (i.ReadU8 ());
>   m_wifiTxVector.SetStbc (i.ReadU8 ());
>   m_wifiPreamble = i.ReadU32 ();
>   m_mpduType = static_cast<enum mpduType> (i.ReadU16 ());
61d71
< 
65c75
<   os << +m_preamble << " " << +m_modulation << " " << m_frameComplete;
---
>   os << m_wifiTxVector << " " << (m_wifiPreamble ? "SP " : "LP ") << m_mpduType;
72,75c82,85
< WifiPhyTag::WifiPhyTag (WifiPreamble preamble, WifiModulationClass modulation, uint8_t frameComplete)
<   : m_preamble (preamble),
<     m_modulation (modulation),
<     m_frameComplete (frameComplete)
---
> WifiPhyTag::WifiPhyTag (WifiTxVector txVector, WifiPreamble preamble, enum mpduType mpdutype)
>   : m_wifiTxVector (txVector),
>     m_wifiPreamble (preamble),
>     m_mpduType (mpdutype)
79,80c89,90
< WifiPreamble
< WifiPhyTag::GetPreambleType (void) const
---
> WifiTxVector
> WifiPhyTag::GetWifiTxVector (void) const
82c92
<   return m_preamble;
---
>   return m_wifiTxVector;
85,86c95,96
< WifiModulationClass
< WifiPhyTag::GetModulation (void) const
---
> WifiPreamble
> WifiPhyTag::GetWifiPreamble (void) const
88c98
<   return m_modulation;
---
>   return ((enum WifiPreamble) m_wifiPreamble);
91,92c101,102
< uint8_t
< WifiPhyTag::GetFrameComplete (void) const
---
> enum mpduType
> WifiPhyTag::GetMpduType (void) const
94c104
<   return m_frameComplete;
---
>   return m_mpduType;
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-tag.h ../../ns-3-dev/src/wifi/model/wifi-phy-tag.h
20d19
< 
24,26c23,26
< #include "ns3/tag.h"
< #include "wifi-preamble.h"
< #include "wifi-mode.h"
---
> #include <ns3/tag.h>
> #include <ns3/wifi-tx-vector.h>
> #include <ns3/wifi-preamble.h>
> #include <ns3/wifi-phy.h>
39,42d38
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
44c40
<   TypeId GetInstanceTypeId (void) const;
---
>   virtual TypeId GetInstanceTypeId (void) const;
52,54c48,50
<    * \param preamble the preamble type
<    * \param modulation the modulation
<    * \param frameComplete the frameComplete
---
>    * \param txVector the WifiTxVector
>    * \param preamble the WifiPreamble
>    * \param mpduType the mpduType
56c52
<   WifiPhyTag (WifiPreamble preamble, WifiModulationClass modulation, uint8_t frameComplete);
---
>   WifiPhyTag (WifiTxVector txVector, WifiPreamble preamble, enum mpduType mpdutype);
58,59c54,55
<    * Getter for preamble parameter
<    * \return the preamble type
---
>    * Getter for WifiTxVector parameter
>    * \return the WifiTxVector
61c57
<   WifiPreamble GetPreambleType (void) const;
---
>   WifiTxVector GetWifiTxVector (void) const;
63,64c59,60
<    * Getter for modulation parameter
<    * \return the modulation
---
>    * Getter for WifiPreamble parameter
>    * \return preamble the WifiPreamble
66c62
<   WifiModulationClass GetModulation (void) const;
---
>   WifiPreamble GetWifiPreamble (void) const;
68,69c64,65
<    * Getter for frameComplete parameter
<    * \return the frameComplete parameter, i.e. 0 if the frame is not complete, 1 otherwise.
---
>    * Getter for mpduType parameter
>    * \return mpduType the mpduType
71c67
<   uint8_t GetFrameComplete (void) const;
---
>   enum mpduType GetMpduType (void) const;
74,78c70,73
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (TagBuffer i) const;
<   void Deserialize (TagBuffer i);
<   void Print (std::ostream &os) const;
< 
---
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (TagBuffer i) const;
>   virtual void Deserialize (TagBuffer i);
>   virtual void Print (std::ostream &os) const;
81,83c76,78
<   WifiPreamble m_preamble;          ///< preamble type
<   WifiModulationClass m_modulation; ///< modulation used for transmission
<   uint8_t m_frameComplete;          ///< Used to indicate that TX stopped sending before the end of the frame
---
>   WifiTxVector m_wifiTxVector;
>   int32_t m_wifiPreamble;
>   enum mpduType m_mpduType;
Only in ../../NS3-WiGig/src/wifi/model: wifi-ppdu.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-ppdu.h
diff ../../NS3-WiGig/src/wifi/model/wifi-preamble.h ../../ns-3-dev/src/wifi/model/wifi-preamble.h
24,25d23
< #include "ns3/fatal-error.h"
< 
38,51c36,37
<   WIFI_PREAMBLE_VHT_SU,
<   WIFI_PREAMBLE_VHT_MU,
<   //// WIGIG ////
<   WIFI_PREAMBLE_DMG_CTRL,
<   WIFI_PREAMBLE_DMG_SC,
<   WIFI_PREAMBLE_DMG_OFDM,
<   WIFI_PREAMBLE_EDMG_CTRL,
<   WIFI_PREAMBLE_EDMG_SC,
<   WIFI_PREAMBLE_EDMG_OFDM,
<   //// WIGIG ////
<   WIFI_PREAMBLE_HE_SU,
<   WIFI_PREAMBLE_HE_ER_SU,
<   WIFI_PREAMBLE_HE_MU,
<   WIFI_PREAMBLE_HE_TB
---
>   WIFI_PREAMBLE_VHT,
>   WIFI_PREAMBLE_NONE
53,103d38
< 
< /**
< * \brief Stream insertion operator.
< *
< * \param os the stream
< * \param preamble the preamble
< * \returns a reference to the stream
< */
< inline std::ostream& operator<< (std::ostream& os, WifiPreamble preamble)
< {
<   switch (preamble)
<     {
<     //// WIGIG ////
<     case WIFI_PREAMBLE_DMG_CTRL:
<       return (os << "DMG_CTRL");
<     case WIFI_PREAMBLE_DMG_SC:
<       return (os << "DMG_SC");
<     case WIFI_PREAMBLE_DMG_OFDM:
<       return (os << "DMG_OFDM");
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       return (os << "EDMG_CTRL");
<     case WIFI_PREAMBLE_EDMG_SC:
<       return (os << "EDMG_SC");
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       return (os << "EDMG_OFDM");
<       //// WIGIG ////
<     case WIFI_PREAMBLE_LONG:
<       return (os << "LONG");
<     case WIFI_PREAMBLE_SHORT:
<       return (os << "SHORT");
<     case WIFI_PREAMBLE_HT_MF:
<       return (os << "HT_MF");
<     case WIFI_PREAMBLE_HT_GF:
<       return (os << "HT_GF");
<     case WIFI_PREAMBLE_VHT_SU:
<       return (os << "VHT_SU");
<     case WIFI_PREAMBLE_VHT_MU:
<       return (os << "VHT_MU");
<     case WIFI_PREAMBLE_HE_SU:
<       return (os << "HE_SU");
<     case WIFI_PREAMBLE_HE_ER_SU:
<       return (os << "HE_ER_SU");
<     case WIFI_PREAMBLE_HE_MU:
<       return (os << "HE_MU");
<     case WIFI_PREAMBLE_HE_TB:
<       return (os << "HE_TB");
<     default:
<       NS_FATAL_ERROR ("Invalid preamble");
<       return (os << "INVALID");
<     }
< }
Only in ../../NS3-WiGig/src/wifi/model: wifi-psdu.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-psdu.h
diff ../../NS3-WiGig/src/wifi/model/wifi-radio-energy-model.cc ../../ns-3-dev/src/wifi/model/wifi-radio-energy-model.cc
21a22
> #include "ns3/double.h"
22a24
> #include "ns3/trace-source-accessor.h"
54c56
<                    "The radio TX current in Ampere.",
---
>                    "The radio Tx current in Ampere.",
60c62
<                    "The radio RX current in Ampere.",
---
>                    "The radio Rx current in Ampere.",
77c79
<     .AddAttribute ("TxCurrentModel", "A pointer to the attached TX current model.",
---
>     .AddAttribute ("TxCurrentModel", "A pointer to the attached tx current model.",
85c87
<   ;
---
>   ; 
90,93d91
<   : m_source (0),
<     m_currentState (WifiPhyState::IDLE),
<     m_lastUpdateTime (Seconds (0.0)),
<     m_nPendingChangeState (0)
95a94,97
>   m_currentState = WifiPhy::IDLE;  // initially IDLE
>   m_lastUpdateTime = Seconds (0.0);
>   m_nPendingChangeState = 0;
>   m_isSupersededChangeState = false;
96a99
>   m_source = NULL;
100c103
<   // set callback for updating the TX current
---
>   // set callback for updating the tx current
107d109
<   m_txCurrentModel = 0;
112c114
< WifiRadioEnergyModel::SetEnergySource (const Ptr<EnergySource> source)
---
> WifiRadioEnergyModel::SetEnergySource (Ptr<EnergySource> source)
117,119d118
<   m_switchToOffEvent.Cancel ();
<   Time durationToOff = GetMaximumTimeInState (m_currentState);
<   m_switchToOffEvent = Simulator::Schedule (durationToOff, &WifiRadioEnergyModel::ChangeState, this, WifiPhyState::OFF);
126,137c125
< 
<   Time duration = Simulator::Now () - m_lastUpdateTime;
<   NS_ASSERT (duration.IsPositive ()); // check if duration is valid
< 
<   // energy to decrease = current * voltage * time
<   double supplyVoltage = m_source->GetSupplyVoltage ();
<   double energyToDecrease = duration.GetSeconds () * GetStateA (m_currentState) * supplyVoltage;
< 
<   // notify energy source
<   m_source->UpdateEnergySource ();
< 
<   return m_totalEnergyConsumption + energyToDecrease;
---
>   return m_totalEnergyConsumption;
224c212
< WifiPhyState
---
> WifiPhy::State
256c244
< WifiRadioEnergyModel::SetTxCurrentModel (const Ptr<WifiTxCurrentModel> model)
---
> WifiRadioEnergyModel::SetTxCurrentModel (Ptr<WifiTxCurrentModel> model)
270,282d257
< Time
< WifiRadioEnergyModel::GetMaximumTimeInState (int state) const
< {
<   if (state == WifiPhyState::OFF)
<     {
<       NS_FATAL_ERROR ("Requested maximum remaining time for OFF state");
<     }
<   double remainingEnergy = m_source->GetRemainingEnergy ();
<   double supplyVoltage = m_source->GetSupplyVoltage ();
<   double current = GetStateA (state);
<   return Seconds (remainingEnergy / (current * supplyVoltage));
< }
< 
288,303d262
<   m_nPendingChangeState++;
< 
<   if (m_nPendingChangeState > 1 && newState == WifiPhyState::OFF)
<     {
<       SetWifiRadioState ((WifiPhyState) newState);
<       m_nPendingChangeState--;
<       return;
<     }
< 
<   if (newState != WifiPhyState::OFF)
<     {
<       m_switchToOffEvent.Cancel ();
<       Time durationToOff = GetMaximumTimeInState (newState);
<       m_switchToOffEvent = Simulator::Schedule (durationToOff, &WifiRadioEnergyModel::ChangeState, this, WifiPhyState::OFF);
<     }
< 
305c264
<   NS_ASSERT (duration.IsPositive ()); // check if duration is valid
---
>   NS_ASSERT (duration.GetNanoSeconds () >= 0); // check if duration is valid
307a267
>   double energyToDecrease = 0.0;
309c269,291
<   double energyToDecrease = duration.GetSeconds () * GetStateA (m_currentState) * supplyVoltage;
---
>   switch (m_currentState)
>     {
>     case WifiPhy::IDLE:
>       energyToDecrease = duration.GetSeconds () * m_idleCurrentA * supplyVoltage;
>       break;
>     case WifiPhy::CCA_BUSY:
>       energyToDecrease = duration.GetSeconds () * m_ccaBusyCurrentA * supplyVoltage;
>       break;
>     case WifiPhy::TX:
>       energyToDecrease = duration.GetSeconds () * m_txCurrentA * supplyVoltage;
>       break;
>     case WifiPhy::RX:
>       energyToDecrease = duration.GetSeconds () * m_rxCurrentA * supplyVoltage;
>       break;
>     case WifiPhy::SWITCHING:
>       energyToDecrease = duration.GetSeconds () * m_switchingCurrentA * supplyVoltage;
>       break;
>     case WifiPhy::SLEEP:
>       energyToDecrease = duration.GetSeconds () * m_sleepCurrentA * supplyVoltage;
>       break;
>     default:
>       NS_FATAL_ERROR ("WifiRadioEnergyModel:Undefined radio state: " << m_currentState);
>     }
313d294
<   NS_ASSERT (m_totalEnergyConsumption <= m_source->GetInitialEnergy ());
317a299,300
>   m_nPendingChangeState++;
> 
328c311
<   if (m_nPendingChangeState <= 1 && m_currentState != WifiPhyState::OFF)
---
>   if (!m_isSupersededChangeState)
331c314
<       SetWifiRadioState ((WifiPhyState) newState);
---
>       SetWifiRadioState ((WifiPhy::State) newState);
337a321,322
>   m_isSupersededChangeState = (m_nPendingChangeState > 1);
> 
365,377d349
< void
< WifiRadioEnergyModel::HandleEnergyChanged (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_LOG_DEBUG ("WifiRadioEnergyModel:Energy is changed!");
<   if (m_currentState != WifiPhyState::OFF)
<     {
<       m_switchToOffEvent.Cancel ();
<       Time durationToOff = GetMaximumTimeInState (m_currentState);
<       m_switchToOffEvent = Simulator::Schedule (durationToOff, &WifiRadioEnergyModel::ChangeState, this, WifiPhyState::OFF);
<     }
< }
< 
398c370
< WifiRadioEnergyModel::GetStateA (int state) const
---
> WifiRadioEnergyModel::DoGetCurrentA (void) const
400c372,373
<   switch (state)
---
>   NS_LOG_FUNCTION (this);
>   switch (m_currentState)
402c375
<     case WifiPhyState::IDLE:
---
>     case WifiPhy::IDLE:
404c377
<     case WifiPhyState::CCA_BUSY:
---
>     case WifiPhy::CCA_BUSY:
406c379
<     case WifiPhyState::TX:
---
>     case WifiPhy::TX:
408c381
<     case WifiPhyState::RX:
---
>     case WifiPhy::RX:
410c383
<     case WifiPhyState::SWITCHING:
---
>     case WifiPhy::SWITCHING:
412c385
<     case WifiPhyState::SLEEP:
---
>     case WifiPhy::SLEEP:
414,415c387,388
<     case WifiPhyState::OFF:
<       return 0.0;
---
>     default:
>       NS_FATAL_ERROR ("WifiRadioEnergyModel:Undefined radio state:" << m_currentState);
417,423d389
<   NS_FATAL_ERROR ("WifiRadioEnergyModel: undefined radio state " << state);
< }
< 
< double
< WifiRadioEnergyModel::DoGetCurrentA (void) const
< {
<   return GetStateA (m_currentState);
427c393
< WifiRadioEnergyModel::SetWifiRadioState (const WifiPhyState state)
---
> WifiRadioEnergyModel::SetWifiRadioState (const WifiPhy::State state)
434c400
<     case WifiPhyState::IDLE:
---
>     case WifiPhy::IDLE:
437c403
<     case WifiPhyState::CCA_BUSY:
---
>     case WifiPhy::CCA_BUSY:
440c406
<     case WifiPhyState::TX:
---
>     case WifiPhy::TX:
443c409
<     case WifiPhyState::RX:
---
>     case WifiPhy::RX:
446c412
<     case WifiPhyState::SWITCHING:
---
>     case WifiPhy::SWITCHING:
449c415
<     case WifiPhyState::SLEEP:
---
>     case WifiPhy::SLEEP:
452,454d417
<     case WifiPhyState::OFF:
<       stateName = "OFF";
<       break;
498c461
<   m_changeStateCallback (WifiPhyState::RX);
---
>   m_changeStateCallback (WifiPhy::RX);
510c473
<   m_changeStateCallback (WifiPhyState::IDLE);
---
>   m_changeStateCallback (WifiPhy::IDLE);
521c484
<   m_changeStateCallback (WifiPhyState::IDLE);
---
>   m_changeStateCallback (WifiPhy::IDLE);
537c500
<   m_changeStateCallback (WifiPhyState::TX);
---
>   m_changeStateCallback (WifiPhy::TX);
551c514
<   m_changeStateCallback (WifiPhyState::CCA_BUSY);
---
>   m_changeStateCallback (WifiPhy::CCA_BUSY);
565c528
<   m_changeStateCallback (WifiPhyState::SWITCHING);
---
>   m_changeStateCallback (WifiPhy::SWITCHING);
579c542
<   m_changeStateCallback (WifiPhyState::SLEEP);
---
>   m_changeStateCallback (WifiPhy::SLEEP);
584c547
< WifiRadioEnergyModelPhyListener::NotifyWakeup (void)
---
> WifiRadioEnergyModelPhyListener::NotifyWakeup(void)
591c554
<   m_changeStateCallback (WifiPhyState::IDLE);
---
>   m_changeStateCallback (WifiPhy::IDLE);
594,615c557,559
< void
< WifiRadioEnergyModelPhyListener::NotifyOff (void)
< {
<   NS_LOG_FUNCTION (this);
<   if (m_changeStateCallback.IsNull ())
<     {
<       NS_FATAL_ERROR ("WifiRadioEnergyModelPhyListener:Change state callback not set!");
<     }
<   m_changeStateCallback (WifiPhyState::OFF);
<   m_switchToIdleEvent.Cancel ();
< }
< 
< void
< WifiRadioEnergyModelPhyListener::NotifyOn (void)
< {
<   NS_LOG_FUNCTION (this);
<   if (m_changeStateCallback.IsNull ())
<     {
<       NS_FATAL_ERROR ("WifiRadioEnergyModelPhyListener:Change state callback not set!");
<     }
<   m_changeStateCallback (WifiPhyState::IDLE);
< }
---
> /*
>  * Private function state here.
>  */
625c569
<   m_changeStateCallback (WifiPhyState::IDLE);
---
>   m_changeStateCallback (WifiPhy::IDLE);
diff ../../NS3-WiGig/src/wifi/model/wifi-radio-energy-model.h ../../ns-3-dev/src/wifi/model/wifi-radio-energy-model.h
18,19c18
<  * Authors: Sidharth Nabar <snabar@uw.edu>
<  *          He Wu <mdzz@u.washington.edu>
---
>  * Authors: Sidharth Nabar <snabar@uw.edu>, He Wu <mdzz@u.washington.edu>
26,27d24
< #include "ns3/traced-value.h"
< #include "ns3/event-id.h"
29,30c26,28
< #include "wifi-phy-listener.h"
< #include "wifi-phy-state.h"
---
> #include "ns3/event-id.h"
> #include "ns3/traced-value.h"
> #include "ns3/wifi-phy.h"
46c44
<    * Callback type for updating the transmit current based on the nominal TX power.
---
>    * Callback type for updating the transmit current based on the nominal tx power.
61c59
<    * \brief Sets the update TX current callback.
---
>    * \brief Sets the update tx current callback.
63c61
<    * \param callback Update TX current callback.
---
>    * \param callback Update tx current callback.
74c72
<   void NotifyRxStart (Time duration);
---
>   virtual void NotifyRxStart (Time duration);
84c82
<   void NotifyRxEndOk (void);
---
>   virtual void NotifyRxEndOk (void);
94c92
<   void NotifyRxEndError (void);
---
>   virtual void NotifyRxEndError (void);
101c99
<    * \param txPowerDbm the nominal TX power in dBm
---
>    * \param txPowerDbm the nominal tx power in dBm
105c103
<   void NotifyTxStart (Time duration, double txPowerDbm);
---
>   virtual void NotifyTxStart (Time duration, double txPowerDbm);
112c110
<   void NotifyMaybeCcaBusyStart (Time duration);
---
>   virtual void NotifyMaybeCcaBusyStart (Time duration);
119,129c117
<   void NotifySwitchingStart (Time duration);
< 
<   /**
<    * Defined in ns3::WifiPhyListener
<    */
<   void NotifySleep (void);
< 
<   /**
<    * Defined in ns3::WifiPhyListener
<    */
<   void NotifyOff (void);
---
>   virtual void NotifySwitchingStart (Time duration);
134c122
<   void NotifyWakeup (void);
---
>   virtual void NotifySleep (void);
139,140c127
<   void NotifyOn (void);
< 
---
>   virtual void NotifyWakeup (void);
147a135
> private:
155,156c143,144
<    * Callback used to update the TX current stored in WifiRadioEnergyModel based on
<    * the nominal TX power used to transmit the current frame.
---
>    * Callback used to update the tx current stored in WifiRadioEnergyModel based on 
>    * the nominal tx power used to transmit the current frame.
160c148
<   EventId m_switchToIdleEvent; ///< switch to idle event
---
>   EventId m_switchToIdleEvent;
162a151
> // -------------------------------------------------------------------------- //
167c156
<  *
---
>  * 
170c159
<  * The different types of transactions that are defined are:
---
>  * The different types of transactions that are defined are: 
184c173
<  *
---
>  * 
186,187c175,176
<  * "Demystifying 802.11n power consumption", Proceedings of HotPower'10
<  *
---
>  * "Demystifying 802.11n power consumption", Proceedings of HotPower'10 
>  * 
189c178
<  *
---
>  * 
191c180
<  *
---
>  * 
193c182
<  *
---
>  * 
195c184
<  *
---
>  * 
197c186
<  *
---
>  * 
200c189
<  *
---
>  * 
202c191
<  *
---
>  * 
204c193
<  *
---
>  * 
206c195
<  *
---
>  * 
208c197
<  *
---
>  * 
210c199
<  * transmit power can also be achieved through a wifi TX current model.
---
>  * transmit power can also be achieved through a wifi tx current model.
226,229c215
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
---
> public:
241c227
<   void SetEnergySource (const Ptr<EnergySource> source);
---
>   virtual void SetEnergySource (Ptr<EnergySource> source);
244c230
<    * \returns Total energy consumption of the wifi device in watts.
---
>    * \returns Total energy consumption of the wifi device.
248c234
<   double GetTotalEnergyConsumption (void) const;
---
>   virtual double GetTotalEnergyConsumption (void) const;
251,255d236
<   /**
<    * \brief Gets idle current in Amperes.
<    *
<    * \returns idle current of the wifi device.
<    */
257,261d237
<   /**
<    * \brief Sets idle current in Amperes.
<    *
<    * \param idleCurrentA the idle current
<    */
263,267d238
<   /**
<    * \brief Gets CCA busy current in Amperes.
<    *
<    * \returns CCA Busy current of the wifi device.
<    */
269,273d239
<   /**
<    * \brief Sets CCA busy current in Amperes.
<    *
<    * \param ccaBusyCurrentA the CCA busy current
<    */
275,279d240
<   /**
<    * \brief Gets transmit current in Amperes.
<    *
<    * \returns transmit current of the wifi device.
<    */
281,285d241
<   /**
<    * \brief Sets transmit current in Amperes.
<    *
<    * \param txCurrentA the transmit current
<    */
287,291d242
<   /**
<    * \brief Gets receive current in Amperes.
<    *
<    * \returns receive current of the wifi device.
<    */
293,297d243
<   /**
<    * \brief Sets receive current in Amperes.
<    *
<    * \param rxCurrentA the receive current
<    */
299,303d244
<   /**
<    * \brief Gets switching current in Amperes.
<    *
<    * \returns switching current of the wifi device.
<    */
305,309d245
<   /**
<    * \brief Sets switching current in Amperes.
<    *
<    * \param switchingCurrentA the switching current
<    */
311,315d246
<   /**
<    * \brief Gets sleep current in Amperes.
<    *
<    * \returns sleep current of the wifi device.
<    */
317,321d247
<   /**
<    * \brief Sets sleep current in Amperes.
<    *
<    * \param sleepCurrentA the sleep current
<    */
327c253
<   WifiPhyState GetCurrentState (void) const;
---
>   WifiPhy::State GetCurrentState (void) const;
344c270
<    * \param model the model used to compute the wifi TX current.
---
>    * \param model the model used to compute the wifi tx current.
346c272
<   void SetTxCurrentModel (const Ptr<WifiTxCurrentModel> model);
---
>   void SetTxCurrentModel (Ptr<WifiTxCurrentModel> model);
349,352c275,278
<    * \brief Calls the CalcTxCurrent method of the TX current model to
<    *        compute the TX current based on such model
<    *
<    * \param txPowerDbm the nominal TX power in dBm
---
>    * \brief Calls the CalcTxCurrent method of the tx current model to
>    *        compute the tx current based on such model
>    * 
>    * \param txPowerDbm the nominal tx power in dBm
363,370c289
<   void ChangeState (int newState);
< 
<   /**
<    * \param state the wifi state
<    *
<    * \returns the time the radio can stay in that state based on the remaining energy.
<    */
<   Time GetMaximumTimeInState (int state) const;
---
>   virtual void ChangeState (int newState);
377c296
<   void HandleEnergyDepletion (void);
---
>   virtual void HandleEnergyDepletion (void);
384,391c303
<   void HandleEnergyRecharged (void);
< 
<   /**
<    * \brief Handles energy changed.
<    *
<    * Implements DeviceEnergyModel::HandleEnergyChanged
<    */
<   void HandleEnergyChanged (void);
---
>   virtual void HandleEnergyRecharged (void);
403,409c315
<    * \param state the wifi state
<    * \returns draw of device in Amperes, at given state.
<    */
<   double GetStateA (int state) const;
< 
<   /**
<    * \returns Current draw of device in Amperes, at current state.
---
>    * \returns Current draw of device, at current state.
413c319
<   double DoGetCurrentA (void) const;
---
>   virtual double DoGetCurrentA (void) const;
421c327
<   void SetWifiRadioState (const WifiPhyState state);
---
>   void SetWifiRadioState (const WifiPhy::State state);
423c329,330
<   Ptr<EnergySource> m_source; ///< energy source
---
> private:
>   Ptr<EnergySource> m_source;
426,432c333,339
<   double m_txCurrentA; ///< transmit current in Amperes
<   double m_rxCurrentA; ///< receive current in Amperes
<   double m_idleCurrentA; ///< idle current in Amperes
<   double m_ccaBusyCurrentA; ///< CCA busy current in Amperes
<   double m_switchingCurrentA; ///< switching current in Amperes
<   double m_sleepCurrentA; ///< sleep current in Amperes
<   Ptr<WifiTxCurrentModel> m_txCurrentModel; ///< current model
---
>   double m_txCurrentA;
>   double m_rxCurrentA;
>   double m_idleCurrentA;
>   double m_ccaBusyCurrentA;
>   double m_switchingCurrentA;
>   double m_sleepCurrentA;
>   Ptr<WifiTxCurrentModel> m_txCurrentModel;
434c341
<   /// This variable keeps track of the total energy consumed by this model in watts.
---
>   // This variable keeps track of the total energy consumed by this model.
438,439c345,346
<   WifiPhyState m_currentState;  ///< current state the radio is in
<   Time m_lastUpdateTime;          ///< time stamp of previous energy update
---
>   WifiPhy::State m_currentState;  // current state the radio is in
>   Time m_lastUpdateTime;          // time stamp of previous energy update
441c348,349
<   uint8_t m_nPendingChangeState; ///< pending state change
---
>   uint8_t m_nPendingChangeState;
>   bool m_isSupersededChangeState;
443c351
<   /// Energy depletion callback
---
>   // Energy depletion callback
446c354
<   /// Energy recharged callback
---
>   // Energy recharged callback
449c357
<   /// WifiPhy listener
---
>   // WifiPhy listener
451,452d358
< 
<   EventId m_switchToOffEvent; ///< switch to off event
Only in ../../NS3-WiGig/src/wifi/model: wifi-remote-station-info.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-remote-station-info.h
diff ../../NS3-WiGig/src/wifi/model/wifi-remote-station-manager.cc ../../ns-3-dev/src/wifi/model/wifi-remote-station-manager.cc
20a21,24
> #include <iostream>
> #include "wifi-remote-station-manager.h"
> #include "ns3/simulator.h"
> #include "ns3/assert.h"
21a26
> #include "ns3/tag.h"
22a28
> #include "ns3/double.h"
25,30c31,33
< #include "ns3/simulator.h"
< #include "wifi-remote-station-manager.h"
< #include "dmg-wifi-mac.h"
< #include "wifi-phy.h"
< #include "wifi-mac.h"
< #include "wifi-utils.h"
---
> #include "ns3/wifi-phy.h"
> #include "ns3/wifi-mac.h"
> #include "ns3/trace-source-accessor.h"
33,37c36,39
< #include "ht-configuration.h"
< #include "vht-configuration.h"
< #include "he-configuration.h"
< #include "wifi-net-device.h"
< #include "dmg-wifi-phy.h"
---
> 
> /***************************************************************
>  *           Packet Mode Tagger
>  ***************************************************************/
42a45,277
> class HighLatencyDataTxVectorTag : public Tag
> {
> public:
>   HighLatencyDataTxVectorTag ();
>   HighLatencyDataTxVectorTag (WifiTxVector dataTxVector);
>   /**
>    * \returns the transmission mode to use to send this packet
>    */
>   WifiTxVector GetDataTxVector (void) const;
> 
>   static TypeId GetTypeId (void);
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (TagBuffer i) const;
>   virtual void Deserialize (TagBuffer i);
>   virtual void Print (std::ostream &os) const;
> private:
>   WifiTxVector m_dataTxVector;
> };
> 
> HighLatencyDataTxVectorTag::HighLatencyDataTxVectorTag ()
> {
> }
> 
> HighLatencyDataTxVectorTag::HighLatencyDataTxVectorTag (WifiTxVector dataTxVector)
>   : m_dataTxVector (dataTxVector)
> {
> }
> 
> WifiTxVector
> HighLatencyDataTxVectorTag::GetDataTxVector (void) const
> {
>   return m_dataTxVector;
> }
> 
> TypeId
> HighLatencyDataTxVectorTag::GetTypeId (void)
> {
>   static TypeId tid = TypeId ("ns3::HighLatencyDataTxVectorTag")
>     .SetParent<Tag> ()
>     .SetGroupName ("Wifi")
>     .AddConstructor<HighLatencyDataTxVectorTag> ()
>   ;
>   return tid;
> }
> 
> TypeId
> HighLatencyDataTxVectorTag::GetInstanceTypeId (void) const
> {
>   return GetTypeId ();
> }
> 
> uint32_t
> HighLatencyDataTxVectorTag::GetSerializedSize (void) const
> {
>   return sizeof (WifiTxVector);
> }
> 
> void
> HighLatencyDataTxVectorTag::Serialize (TagBuffer i) const
> {
>   i.Write ((uint8_t *)&m_dataTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyDataTxVectorTag::Deserialize (TagBuffer i)
> {
>   i.Read ((uint8_t *)&m_dataTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyDataTxVectorTag::Print (std::ostream &os) const
> {
>   os << "Data=" << m_dataTxVector;
> }
> 
> class HighLatencyRtsTxVectorTag : public Tag
> {
> public:
>   HighLatencyRtsTxVectorTag ();
>   HighLatencyRtsTxVectorTag (WifiTxVector rtsTxVector);
>   /**
>    * \returns the transmission mode to use to send the RTS prior to the
>    *          transmission of the data packet itself.
>    */
>   WifiTxVector GetRtsTxVector (void) const;
> 
>   static TypeId GetTypeId (void);
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (TagBuffer i) const;
>   virtual void Deserialize (TagBuffer i);
>   virtual void Print (std::ostream &os) const;
> private:
>   WifiTxVector m_rtsTxVector;
> };
> 
> HighLatencyRtsTxVectorTag::HighLatencyRtsTxVectorTag ()
> {
> }
> 
> HighLatencyRtsTxVectorTag::HighLatencyRtsTxVectorTag (WifiTxVector rtsTxVector)
>   : m_rtsTxVector (rtsTxVector)
> {
> }
> 
> WifiTxVector
> HighLatencyRtsTxVectorTag::GetRtsTxVector (void) const
> {
>   return m_rtsTxVector;
> }
> 
> TypeId
> HighLatencyRtsTxVectorTag::GetTypeId (void)
> {
>   static TypeId tid = TypeId ("ns3::HighLatencyRtsTxVectorTag")
>     .SetParent<Tag> ()
>     .SetGroupName ("Wifi")
>     .AddConstructor<HighLatencyRtsTxVectorTag> ()
>   ;
>   return tid;
> }
> 
> TypeId
> HighLatencyRtsTxVectorTag::GetInstanceTypeId (void) const
> {
>   return GetTypeId ();
> }
> 
> uint32_t
> HighLatencyRtsTxVectorTag::GetSerializedSize (void) const
> {
>   return sizeof (WifiTxVector);
> }
> 
> void
> HighLatencyRtsTxVectorTag::Serialize (TagBuffer i) const
> {
>   i.Write ((uint8_t *)&m_rtsTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyRtsTxVectorTag::Deserialize (TagBuffer i)
> {
>   i.Read ((uint8_t *)&m_rtsTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyRtsTxVectorTag::Print (std::ostream &os) const
> {
>   os << "Rts=" << m_rtsTxVector;
> }
> 
> class HighLatencyCtsToSelfTxVectorTag : public Tag
> {
> public:
>   HighLatencyCtsToSelfTxVectorTag ();
>   HighLatencyCtsToSelfTxVectorTag (WifiTxVector ctsToSelfTxVector);
>   /**
>    * \returns the transmission mode to use for the CTS-to-self.
>    */
>   WifiTxVector GetCtsToSelfTxVector (void) const;
> 
>   static TypeId GetTypeId (void);
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (TagBuffer i) const;
>   virtual void Deserialize (TagBuffer i);
>   virtual void Print (std::ostream &os) const;
> private:
>   WifiTxVector m_ctsToSelfTxVector;
> };
> 
> HighLatencyCtsToSelfTxVectorTag::HighLatencyCtsToSelfTxVectorTag ()
> {
> }
> 
> HighLatencyCtsToSelfTxVectorTag::HighLatencyCtsToSelfTxVectorTag (WifiTxVector ctsToSelfTxVector)
>   : m_ctsToSelfTxVector (ctsToSelfTxVector)
> {
> }
> 
> WifiTxVector
> HighLatencyCtsToSelfTxVectorTag::GetCtsToSelfTxVector (void) const
> {
>   return m_ctsToSelfTxVector;
> }
> 
> TypeId
> HighLatencyCtsToSelfTxVectorTag::GetTypeId (void)
> {
>   static TypeId tid = TypeId ("ns3::HighLatencyCtsToSelfTxVectorTag")
>     .SetParent<Tag> ()
>     .SetGroupName ("Wifi")
>     .AddConstructor<HighLatencyCtsToSelfTxVectorTag> ()
>   ;
>   return tid;
> }
> 
> TypeId
> HighLatencyCtsToSelfTxVectorTag::GetInstanceTypeId (void) const
> {
>   return GetTypeId ();
> }
> 
> uint32_t
> HighLatencyCtsToSelfTxVectorTag::GetSerializedSize (void) const
> {
>   return sizeof (WifiTxVector);
> }
> 
> void
> HighLatencyCtsToSelfTxVectorTag::Serialize (TagBuffer i) const
> {
>   i.Write ((uint8_t *)&m_ctsToSelfTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyCtsToSelfTxVectorTag::Deserialize (TagBuffer i)
> {
>   i.Read ((uint8_t *)&m_ctsToSelfTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyCtsToSelfTxVectorTag::Print (std::ostream &os) const
> {
>   os << "Cts To Self=" << m_ctsToSelfTxVector;
> }
> 
> } //namespace ns3
> 
> namespace ns3 {
> 
50a286,295
>     .AddAttribute ("IsLowLatency",
>                    "If true, we attempt to modelize a so-called low-latency device: "
>                    "a device where decisions about tx parameters can be made on a per-packet basis and "
>                    "feedback about the transmission of each packet is obtained before sending the next. "
>                    "Otherwise, we modelize a high-latency device, that is a device where we cannot update "
>                    "our decision about tx parameters after every packet transmission.",
>                    TypeId::ATTR_GET,
>                    BooleanValue (true), //this value is ignored because there is no setter
>                    MakeBooleanAccessor (&WifiRemoteStationManager::IsLowLatency),
>                    MakeBooleanChecker ())
52,53c297,298
<                    "The maximum number of retransmission attempts for any packet with size <= RtsCtsThreshold. "
<                    "This value will not have any effect on some rate control algorithms.",
---
>                    "The maximum number of retransmission attempts for an RTS. "
>                    " This value will not have any effect on some rate control algorithms.",
55c300
<                    MakeUintegerAccessor (&WifiRemoteStationManager::SetMaxSsrc),
---
>                    MakeUintegerAccessor (&WifiRemoteStationManager::m_maxSsrc),
58c303
<                    "The maximum number of retransmission attempts for any packet with size > RtsCtsThreshold. "
---
>                    "The maximum number of retransmission attempts for a DATA packet. "
60,61c305,306
<                    UintegerValue (4),
<                    MakeUintegerAccessor (&WifiRemoteStationManager::SetMaxSlrc),
---
>                    UintegerValue (7),
>                    MakeUintegerAccessor (&WifiRemoteStationManager::m_maxSlrc),
67c312
<                    MakeUintegerAccessor (&WifiRemoteStationManager::SetRtsCtsThreshold),
---
>                    MakeUintegerAccessor (&WifiRemoteStationManager::m_rtsCtsThreshold),
73c318
<                    UintegerValue (65535),
---
>                    UintegerValue (2346),
88c333
<     .AddAttribute ("ErpProtectionMode",
---
>     .AddAttribute ("ProtectionMode",
91,97c336,337
<                    MakeEnumAccessor (&WifiRemoteStationManager::m_erpProtectionMode),
<                    MakeEnumChecker (WifiRemoteStationManager::RTS_CTS, "Rts-Cts",
<                                     WifiRemoteStationManager::CTS_TO_SELF, "Cts-To-Self"))
<     .AddAttribute ("HtProtectionMode",
<                    "Protection mode used when non-HT STAs are connected to a HT AP: Rts-Cts or Cts-To-Self",
<                    EnumValue (WifiRemoteStationManager::CTS_TO_SELF),
<                    MakeEnumAccessor (&WifiRemoteStationManager::m_htProtectionMode),
---
>                    MakeEnumAccessor (&WifiRemoteStationManager::SetProtectionMode,
>                                      &WifiRemoteStationManager::GetProtectionMode),
116,125d355
<     //// WIGIG ////
<     .AddTraceSource ("MacTxOK",
<                      "The transmission of an MPDU packet by the MAC layer has successed",
<                      MakeTraceSourceAccessor (&WifiRemoteStationManager::m_macTxOk),
<                      "ns3::Mac48Address::TracedCallback")
<     .AddTraceSource ("MacRxOK",
<                      "The reception of an MPDU packet by the MAC layer has successed",
<                      MakeTraceSourceAccessor (&WifiRemoteStationManager::m_macRxOk),
<                      "ns3::WifiRemoteStationManager::MacRxOkTracedCallback")
<     //// WIGIG ////
131,135c361,362
<   : m_pcfSupported (false),
<     //// WIGIG ////
<     m_dmgSupported (false),
<     m_edmgSupported (false),
<     //// WIGIG ////
---
>   : m_htSupported (false),
>     m_vhtSupported (false),
137,138d363
<     m_useNonHtProtection (false),
<     m_useGreenfieldProtection (false),
140,141c365
<     m_shortSlotTimeEnabled (false),
<     m_rifsPermitted (false)
---
>     m_shortSlotTimeEnabled (false)
143d366
<   NS_LOG_FUNCTION (this);
148d370
<   NS_LOG_FUNCTION (this);
154,155c376,385
<   NS_LOG_FUNCTION (this);
<   Reset ();
---
>   for (StationStates::const_iterator i = m_states.begin (); i != m_states.end (); i++)
>     {
>       delete (*i);
>     }
>   m_states.clear ();
>   for (Stations::const_iterator i = m_stations.begin (); i != m_stations.end (); i++)
>     {
>       delete (*i);
>     }
>   m_stations.clear ();
159c389
< WifiRemoteStationManager::SetupPhy (const Ptr<WifiPhy> phy)
---
> WifiRemoteStationManager::SetupPhy (Ptr<WifiPhy> phy)
161d390
<   NS_LOG_FUNCTION (this << phy);
164c393
<   //this in order to find the relevant mandatory rates when choosing a
---
>   //this in order to find the relevant mandatory rates when chosing a
166c395
<   //acknowledgments.
---
>   //acknowledgements.
168,180c397,398
<   //// WIGIG ////
<   if (HasDmgSupported () || HasEdmgSupported ())
<     {
<       /* For data transmission DMG/EDMG MCS-1 is selected */
<       m_defaultTxMode = phy->GetMode (1);
<     }
<   else
<     {
<       m_defaultTxMode = phy->GetMode (0);
<     }
<   //// WIGIG ////
<   NS_ASSERT (m_defaultTxMode.IsMandatory ());
<   if (GetHtSupported ())
---
>   m_defaultTxMode = phy->GetMode (0);
>   if (HasHtSupported () || HasVhtSupported ())
188c406
< WifiRemoteStationManager::SetupMac (const Ptr<WifiMac> mac)
---
> WifiRemoteStationManager::SetupMac (Ptr<WifiMac> mac)
190d407
<   NS_LOG_FUNCTION (this << mac);
197a415,420
> WifiRemoteStationManager::SetHtSupported (bool enable)
> {
>   m_htSupported = enable;
> }
> 
> void
200d422
<   NS_LOG_FUNCTION (this << maxSsrc);
207d428
<   NS_LOG_FUNCTION (this << maxSlrc);
214d434
<   NS_LOG_FUNCTION (this << threshold);
221d440
<   NS_LOG_FUNCTION (this << threshold);
226c445
< WifiRemoteStationManager::SetShortPreambleEnabled (bool enable)
---
> WifiRemoteStationManager::SetProtectionMode (WifiRemoteStationManager::ProtectionMode mode)
228,229c447
<   NS_LOG_FUNCTION (this << enable);
<   m_shortPreambleEnabled = enable;
---
>   m_protectionMode = mode;
233c451
< WifiRemoteStationManager::SetShortSlotTimeEnabled (bool enable)
---
> WifiRemoteStationManager::SetShortPreambleEnabled (bool enable)
235,236c453
<   NS_LOG_FUNCTION (this << enable);
<   m_shortSlotTimeEnabled = enable;
---
>   m_shortPreambleEnabled = enable;
240c457
< WifiRemoteStationManager::SetRifsPermitted (bool allow)
---
> WifiRemoteStationManager::SetShortSlotTimeEnabled (bool enable)
242,243c459
<   NS_LOG_FUNCTION (this << allow);
<   m_rifsPermitted = allow;
---
>   m_shortSlotTimeEnabled = enable;
258,259c474,475
< bool
< WifiRemoteStationManager::GetRifsPermitted (void) const
---
> WifiRemoteStationManager::ProtectionMode
> WifiRemoteStationManager::GetProtectionMode (void) const
261c477
<   return m_rifsPermitted;
---
>   return m_protectionMode;
265c481
< WifiRemoteStationManager::GetHtSupported (void) const
---
> WifiRemoteStationManager::HasHtSupported (void) const
267,297c483
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<   Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<   if (htConfiguration)
<     {
<       return true;
<     }
<   return false;
< }
< 
< bool
< WifiRemoteStationManager::GetVhtSupported (void) const
< {
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<   Ptr<VhtConfiguration> vhtConfiguration = device->GetVhtConfiguration ();
<   if (vhtConfiguration)
<     {
<       return true;
<     }
<   return false;
< }
< 
< bool
< WifiRemoteStationManager::GetHeSupported (void) const
< {
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<   Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<   if (heConfiguration)
<     {
<       return true;
<     }
<   return false;
---
>   return m_htSupported;
301,307c487
< WifiRemoteStationManager::SetPcfSupported (bool enable)
< {
<   m_pcfSupported = enable;
< }
< 
< bool
< WifiRemoteStationManager::GetPcfSupported (void) const
---
> WifiRemoteStationManager::SetVhtSupported (bool enable)
309c489
<   return m_pcfSupported;
---
>   m_vhtSupported = enable;
313c493
< WifiRemoteStationManager::GetGreenfieldSupported (void) const
---
> WifiRemoteStationManager::HasVhtSupported (void) const
315,325c495
<   if (GetHtSupported ())
<     {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       NS_ASSERT (htConfiguration); //If HT is supported, we should have a HT configuration attached
<       if (htConfiguration->GetGreenfieldSupported ())
<         {
<           return true;
<         }
<     }
<   return false;
---
>   return m_vhtSupported;
328,329c498,499
< bool
< WifiRemoteStationManager::GetShortGuardIntervalSupported (void) const
---
> uint32_t
> WifiRemoteStationManager::GetMaxSsrc (void) const
331,341c501
<   if (GetHtSupported ())
<     {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       NS_ASSERT (htConfiguration); //If HT is supported, we should have a HT configuration attached
<       if (htConfiguration->GetShortGuardIntervalSupported ())
<         {
<           return true;
<         }
<     }
<   return false;
---
>   return m_maxSsrc;
344,345c504,505
< uint16_t
< WifiRemoteStationManager::GetGuardInterval (void) const
---
> uint32_t
> WifiRemoteStationManager::GetMaxSlrc (void) const
347,355c507
<   uint16_t gi = 0;
<   if (GetHeSupported ())
<     {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<       Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<       NS_ASSERT (heConfiguration); //If HE is supported, we should have a HE configuration attached
<       gi = static_cast<uint16_t>(heConfiguration->GetGuardInterval ().GetNanoSeconds ());
<     }
<   return gi;
---
>   return m_maxSlrc;
358,360c510,511
< //// WIGIG ////
< void
< WifiRemoteStationManager::SetDmgSupported (bool enable)
---
> uint32_t
> WifiRemoteStationManager::GetRtsCtsThreshold (void) const
362c513
<   m_dmgSupported = enable;
---
>   return m_rtsCtsThreshold;
365,366c516,517
< bool
< WifiRemoteStationManager::HasDmgSupported (void) const
---
> uint32_t
> WifiRemoteStationManager::GetFragmentationThreshold (void) const
368c519
<   return m_dmgSupported;
---
>   return DoGetFragmentationThreshold ();
372,384c523
< WifiRemoteStationManager::SetEdmgSupported (bool enable)
< {
<   m_edmgSupported = enable;
< }
< 
< bool
< WifiRemoteStationManager::HasEdmgSupported (void) const
< {
<   return m_edmgSupported;
< }
< 
< bool
< WifiRemoteStationManager::IsWiGigSupported (void) const
---
> WifiRemoteStationManager::Reset (Mac48Address address)
386,394c525,531
<   return (m_dmgSupported || m_edmgSupported);
< }
< 
< //// WIGIG ////
< 
< uint32_t
< WifiRemoteStationManager::GetFragmentationThreshold (void) const
< {
<   return DoGetFragmentationThreshold ();
---
>   NS_LOG_FUNCTION (this << address);
>   NS_ASSERT (!address.IsGroup ());
>   WifiRemoteStationState *state = LookupState (address);
>   state->m_operationalRateSet.clear ();
>   state->m_operationalMcsSet.clear ();
>   AddSupportedMode (address, GetDefaultMode ());
>   AddSupportedMcs (address, GetDefaultMcs ());
398c535
< WifiRemoteStationManager::AddSupportedPhyPreamble (Mac48Address address, bool isShortPreambleSupported)
---
> WifiRemoteStationManager::AddSupportedPlcpPreamble (Mac48Address address, bool isShortPreambleSupported)
439c576
<   for (uint8_t i = 0; i < m_wifiPhy->GetNModes (); i++)
---
>   for (uint32_t i = 0; i < m_wifiPhy->GetNModes (); i++)
449,459d585
< //// WIGIG ////
< void
< WifiRemoteStationManager::RemoveAllSupportedModes (Mac48Address address)
< {
<   NS_LOG_FUNCTION (this << address);
<   NS_ASSERT (!address.IsGroup ());
<   WifiRemoteStationState *state = LookupState (address);
<   state->m_operationalRateSet.clear ();
< }
< //// WIGIG ////
< 
467c593
<   for (uint8_t i = 0; i < m_wifiPhy->GetNMcs (); i++)
---
>   for (uint32_t i = 0; i < m_wifiPhy->GetNMcs (); i++)
474,482d599
< WifiRemoteStationManager::RemoveAllSupportedMcs (Mac48Address address)
< {
<   NS_LOG_FUNCTION (this << address);
<   NS_ASSERT (!address.IsGroup ());
<   WifiRemoteStationState *state = LookupState (address);
<   state->m_operationalMcsSet.clear ();
< }
< 
< void
512,517d628
< WifiRemoteStationManager::GetQosSupported (Mac48Address address) const
< {
<   return LookupState (address)->m_qosSupported;
< }
< 
< bool
547d657
< //// WIGIG //// (MODIFIED)
549c659
< WifiRemoteStationManager::RecordWaitAssocTxOk (Mac48Address address, uint8_t associationID)
---
> WifiRemoteStationManager::RecordWaitAssocTxOk (Mac48Address address)
552,554c662
<   WifiRemoteStationState *state = LookupState (address);
<   state->m_state = WifiRemoteStationState::WAIT_ASSOC_TX_OK;
<   state->m_aid = associationID;
---
>   LookupState (address)->m_state = WifiRemoteStationState::WAIT_ASSOC_TX_OK;
557c665
< uint8_t
---
> void
561,563c669
<   WifiRemoteStationState *state = LookupState (address);
<   state->m_state = WifiRemoteStationState::GOT_ASSOC_TX_OK;
<   return state->m_aid;
---
>   LookupState (address)->m_state = WifiRemoteStationState::GOT_ASSOC_TX_OK;
565d670
< //// WIGIG ////
581d685
< //// WIGIG ////
583,591c687
< WifiRemoteStationManager::RecordLinkSnr (Mac48Address address, double snr)
< {
<   NS_LOG_FUNCTION (this << address << snr);
<   NS_ASSERT (!address.IsGroup ());
<   LookupState (address)->m_linkSnr = snr;
< }
< 
< double
< WifiRemoteStationManager::GetLinkSnr (Mac48Address address) const
---
> WifiRemoteStationManager::PrepareForQueue (Mac48Address address, const WifiMacHeader *header, Ptr<const Packet> packet)
593,594c689,711
<   NS_ASSERT (!address.IsGroup ());
<   return LookupState (address)->m_linkSnr;
---
>   NS_LOG_FUNCTION (this << address << *header << packet);
>   if (IsLowLatency () || address.IsGroup ())
>     {
>       return;
>     }
>   WifiRemoteStation *station = Lookup (address, header);
>   WifiTxVector rts = DoGetRtsTxVector (station);
>   WifiTxVector data = DoGetDataTxVector (station);
>   WifiTxVector ctstoself = DoGetCtsToSelfTxVector ();
>   HighLatencyDataTxVectorTag datatag;
>   HighLatencyRtsTxVectorTag rtstag;
>   HighLatencyCtsToSelfTxVectorTag ctstoselftag;
>   //first, make sure that the tag is not here anymore.
>   ConstCast<Packet> (packet)->RemovePacketTag (datatag);
>   ConstCast<Packet> (packet)->RemovePacketTag (rtstag);
>   ConstCast<Packet> (packet)->RemovePacketTag (ctstoselftag);
>   datatag = HighLatencyDataTxVectorTag (data);
>   rtstag = HighLatencyRtsTxVectorTag (rts);
>   ctstoselftag = HighLatencyCtsToSelfTxVectorTag (ctstoself);
>   //and then, add it back
>   packet->AddPacketTag (datatag);
>   packet->AddPacketTag (rtstag);
>   packet->AddPacketTag (ctstoselftag);
596d712
< //// WIGIG ////
599c715
< WifiRemoteStationManager::GetDataTxVector (const WifiMacHeader &header)
---
> WifiRemoteStationManager::GetDataTxVector (Mac48Address address, const WifiMacHeader *header, Ptr<const Packet> packet)
601,621c717,718
<   NS_LOG_FUNCTION (this << header);
<   Mac48Address address = header.GetAddr1 ();
<   //// WIGIG ////
<   /* Beam Tracking is Requested */
<   if (header.IsBeamTrackingRequested ())
<     {
<       WifiTxVector v = DoGetDataTxVector (Lookup (address));
<       v.RequestBeamTracking ();
<       v.SetPacketType (header.GetPacketType ());
<       v.SetTrainngFieldLength (header.GetTrainngFieldLength ());
<       v.SetEDMGTrainingFieldLength (header.GetEdmgTrainingFieldLength ());
<       v.Set_TRN_SEQ_LEN (StaticCast<DmgWifiMac> (m_wifiMac)->GetTrnSeqLength ());
<       v.SetChannelAggregation (StaticCast<DmgWifiMac> (m_wifiMac)->GetChannelAggregation ());
<       v.Set_EDMG_TRN_P (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_P ());
<       v.Set_EDMG_TRN_M (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_M ());
<       v.Set_EDMG_TRN_N (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_N ());
<       v.Set_RxPerTxUnits (StaticCast<DmgWifiMac> (m_wifiMac)->Get_RxPerTxUnits ());
<       return v;
<     }
<   //// WIGIG ////
<   if (!header.IsMgt () && address.IsGroup ())
---
>   NS_LOG_FUNCTION (this << address << *header << packet);
>   if (address.IsGroup ())
623d719
<       WifiMode mode = GetNonUnicastMode ();
625,626c721
<       v.SetMode (mode);
<       v.SetPreambleType (GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (address)));
---
>       v.SetMode (GetNonUnicastMode ());
628,630c723,724
<       v.SetChannelWidth (GetChannelWidthForTransmission (mode, m_wifiPhy->GetChannelWidth ()));
<       v.SetGuardInterval (ConvertGuardIntervalToNanoSeconds (mode, DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ())));
<       v.SetNTx (1);
---
>       v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
>       v.SetShortGuardInterval (m_wifiPhy->GetGuardInterval ());
633,661c727
<       v.SetStbc (0);
<       return v;
<     }
<   //// WIGIG ////
< //  if ((header.IsMgt () || header.IsBlockAckReq ()) && m_dmgSupported && !m_edmgSupported)
< //    {
< //      WifiTxVector v;
< //      v.SetMode (WifiMode ("DMG_MCS0"));
< //      v.SetPreambleType (WIFI_PREAMBLE_LONG);
< //      v.SetTxPowerLevel (m_defaultTxPowerLevel);
< //      v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
< //      return v;
< //    }
< //  if ((header.IsMgt () || header.IsBlockAckReq ()) && m_edmgSupported)
< //    {
< //      WifiTxVector v;
< //      v.SetMode (WifiMode ("EDMG_MCS0"));
< //      v.SetPreambleType (WIFI_PREAMBLE_LONG);
< //      v.SetTxPowerLevel (m_defaultTxPowerLevel);
< //      v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
< //      return v;
< //    }
<   if (header.IsMgt () && m_dmgSupported && !m_edmgSupported)
<     {
<       WifiTxVector v;
<       v.SetMode (WifiMode ("DMG_MCS0"));
<       v.SetPreambleType (WIFI_PREAMBLE_DMG_CTRL);
<       v.SetTxPowerLevel (m_defaultTxPowerLevel);
<       v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
---
>       v.SetStbc (false);
664c730
<   if (header.IsMgt () && m_edmgSupported)
---
>   if (!IsLowLatency ())
666,717c732,739
<       WifiTxVector v;
<       v.SetMode (WifiMode ("EDMG_MCS0"));
<       v.SetPreambleType (WIFI_PREAMBLE_EDMG_CTRL);
<       v.SetTxPowerLevel (m_defaultTxPowerLevel);
<       v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
<       v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
<       return v;
<     }
<   //// WIGIG ////
<   WifiTxVector txVector;
<   if (header.IsMgt () && !m_dmgSupported && !m_edmgSupported)     //// WIGIG ////
<     {
<       //Use the lowest basic rate for management frames
<       WifiMode mgtMode;
<       if (GetNBasicModes () > 0)
<         {
<           mgtMode = GetBasicMode (0);
<         }
<       else
<         {
<           mgtMode = GetDefaultMode ();
<         }
<       txVector.SetMode (mgtMode);
<       txVector.SetPreambleType (GetPreambleForTransmission (mgtMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (address)));
<       txVector.SetTxPowerLevel (m_defaultTxPowerLevel);
<       txVector.SetChannelWidth (GetChannelWidthForTransmission (mgtMode, m_wifiPhy->GetChannelWidth ()));
<       txVector.SetGuardInterval (ConvertGuardIntervalToNanoSeconds (mgtMode, DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ())));
<     }
<   else
<     {
<       txVector = DoGetDataTxVector (Lookup (address));
<       /* Check if the packet should be transmitted in MIMO mode */
<       if (m_edmgSupported)
<         {
<           DATA_COMMUNICATION_MODE dataMode = StaticCast<DmgWifiMac> (m_wifiMac)->GetStationDataCommunicationMode (address);
<           if (dataMode != DATA_MODE_SISO)
<             {
<               NS_LOG_DEBUG ("Communication with this station should be done in MIMO mode");
<               /* Note: For now we assume that the number of antennas used to communicate with the station is equal to the number of STS */
<               txVector.SetNumberOfTxChains (StaticCast<DmgWifiMac> (m_wifiMac)->GetStationNStreams (address));
<               txVector.Set_NUM_STS (StaticCast<DmgWifiMac> (m_wifiMac)->GetStationNStreams (address));
<             }
<           txVector.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
<         }
<     }
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<   Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<   if (heConfiguration)
<     {
<       UintegerValue bssColor;
<       heConfiguration->GetAttribute ("BssColor", bssColor);
<       txVector.SetBssColor (bssColor.Get ());
---
>       HighLatencyDataTxVectorTag datatag;
>       bool found;
>       found = ConstCast<Packet> (packet)->PeekPacketTag (datatag);
>       NS_ASSERT (found);
>       //cast found to void, to suppress 'found' set but not used
>       //compiler warning
>       (void) found;
>       return datatag.GetDataTxVector ();
719c741
<   return txVector;
---
>   return DoGetDataTxVector (Lookup (address, header));
722d743
< //// WIGIG ////
724c745,746
< WifiRemoteStationManager::GetDmgTxVector (Mac48Address address, const WifiMacHeader *header, Ptr<const Packet> packet)
---
> WifiRemoteStationManager::GetCtsToSelfTxVector (const WifiMacHeader *header,
>                                                 Ptr<const Packet> packet)
726,780c748,749
<   NS_LOG_FUNCTION (this << address << *header << packet);
<   WifiTxVector v;
< 
<   if (header->IsActionNoAck ()) /* BRP Frame */
<     {
<       if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ad)
<         {
<           v.SetMode (WifiMode ("DMG_MCS0")); /* The BRP Frame shall be transmitted at DMG MCS0 */
<         }
<       else if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<         {
<           v.SetMode (WifiMode ("EDMG_MCS0")); /* The BRP Frame shall be transmitted at DMG MCS0 */
<         }
<       v.SetPacketType (header->GetPacketType ());
<       v.SetTrainngFieldLength (header->GetTrainngFieldLength ());
<       v.SetEDMGTrainingFieldLength (header->GetEdmgTrainingFieldLength ());
<       v.SetChannelAggregation (StaticCast<DmgWifiMac> (m_wifiMac)->GetChannelAggregation ());
<       if (header->GetEdmgTrainingFieldLength () != 0)
<         {
<           v.Set_TRN_SEQ_LEN (StaticCast<DmgWifiMac> (m_wifiMac)->GetTrnSeqLength ());
<           v.Set_EDMG_TRN_P (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_P ());
<           v.Set_EDMG_TRN_M (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_M ());
<           v.Set_EDMG_TRN_N (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_N ());
<           v.Set_RxPerTxUnits (StaticCast<DmgWifiMac> (m_wifiMac)->Get_RxPerTxUnits ());
<           v.SetBrpCdown (StaticCast<DmgWifiMac> (m_wifiMac)->GetBrpCdown ());
<         }
<       v.SetSender (m_wifiMac->GetAddress ());
<     }
<   else if (header->IsDMGBeacon () || header->IsSSW () || header->IsSSW_FBCK () || header->IsSSW_ACK ()) /* Beamforming Training (SLS) */
<     {
<       if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ad)
<         {
<           v.SetMode (WifiMode ("DMG_MCS0"));
<         }
<       else if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<         {
<           v.SetMode (WifiMode ("EDMG_MCS0"));
<         }
<       // EDMG SPs are allowed to append TRN-R fields to DMG Beacons
<       if ((header->IsDMGBeacon ()) && (header->GetEdmgTrainingFieldLength () != 0) && (header->GetPacketType () == TRN_R))
<         {
<           v.SetPacketType (TRN_R);
<           v.SetEDMGTrainingFieldLength (header->GetEdmgTrainingFieldLength ());
<           v.Set_TRN_SEQ_LEN (StaticCast<DmgWifiMac> (m_wifiMac)->GetTrnSeqLength ());
<           v.SetChannelAggregation (StaticCast<DmgWifiMac> (m_wifiMac)->GetChannelAggregation ());
<           v.SetSender (m_wifiMac->GetAddress ());
<           v.SetDMGBeacon (true);
<         }
<       else
<         {
<           v.SetEDMGTrainingFieldLength (0);
<         }
<       v.SetTrainngFieldLength (0);
<     }
<   else if (header->IsPollFrame () || header->IsGrantFrame () || header->IsSprFrame ()) /* Dynamic Polling */
---
>   NS_LOG_FUNCTION (this << *header << packet);
>   if (!IsLowLatency ())
782,791c751,758
<       if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ad)
<         {
<           v.SetMode (WifiMode ("DMG_MCS1"));
<         }
<       else if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<         {
<           v.SetMode (WifiMode ("EDMG_MCS1"));
<         }
<       v.SetTrainngFieldLength (0);
<       v.SetEDMGTrainingFieldLength (0);
---
>       HighLatencyCtsToSelfTxVectorTag ctstoselftag;
>       bool found;
>       found = ConstCast<Packet> (packet)->PeekPacketTag (ctstoselftag);
>       NS_ASSERT (found);
>       //cast found to void, to suppress 'found' set but not used
>       //compiler warning
>       (void) found;
>       return ctstoselftag.GetCtsToSelfTxVector ();
793,799c760
< 
<   v.SetPreambleType (GetPreambleForTransmission (v.GetMode ().GetModulationClass ()));
<   v.SetTxPowerLevel (m_defaultTxPowerLevel);
<   v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
<   v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
< 
<   return v;
---
>   return DoGetCtsToSelfTxVector ();
801d761
< //// WIGIG ////
804c764
< WifiRemoteStationManager::GetCtsToSelfTxVector (void)
---
> WifiRemoteStationManager::DoGetCtsToSelfTxVector (void)
806,825c766
<   WifiMode defaultMode = GetDefaultMode ();
<   WifiPreamble defaultPreamble;
<   if (defaultMode.GetModulationClass () == WIFI_MOD_CLASS_HE)
<     {
<       defaultPreamble = WIFI_PREAMBLE_HE_SU;
<     }
<   else if (defaultMode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
<     {
<       defaultPreamble = WIFI_PREAMBLE_VHT_SU;
<     }
<   else if (defaultMode.GetModulationClass () == WIFI_MOD_CLASS_HT)
<     {
<       defaultPreamble = WIFI_PREAMBLE_HT_MF;
<     }
<   else
<     {
<       defaultPreamble = WIFI_PREAMBLE_LONG;
<     }
< 
<   return WifiTxVector (defaultMode,
---
>   return WifiTxVector (GetDefaultMode (),
827,830d767
<                        defaultPreamble,
<                        ConvertGuardIntervalToNanoSeconds (defaultMode, DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ())),
<                        GetNumberOfAntennas (),
<                        GetMaxNumberOfTransmitStreams (),
832c769,772
<                        GetChannelWidthForTransmission (defaultMode, m_wifiPhy->GetChannelWidth ()),
---
>                        m_wifiPhy->GetChannelWidth (),
>                        m_wifiPhy->GetGuardInterval (),
>                        GetNumberOfTransmitAntennas (),
>                        GetNumberOfTransmitAntennas (),
838c778,779
< WifiRemoteStationManager::GetRtsTxVector (Mac48Address address)
---
> WifiRemoteStationManager::GetRtsTxVector (Mac48Address address, const WifiMacHeader *header,
>                                           Ptr<const Packet> packet)
840,857c781,783
<   NS_LOG_FUNCTION (this << address);
<   if (address.IsGroup ())
<     {
<         WifiMode mode = GetNonUnicastMode ();
<         WifiTxVector v;
<         v.SetMode (mode);
<         v.SetPreambleType (GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (address)));
<         v.SetTxPowerLevel (m_defaultTxPowerLevel);
<         v.SetChannelWidth (GetChannelWidthForTransmission (mode, m_wifiPhy->GetChannelWidth ()));
<         v.SetGuardInterval (ConvertGuardIntervalToNanoSeconds (mode, DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ())));
<         v.SetNTx (1);
<         v.SetNss (1);
<         v.SetNess (0);
<         v.SetStbc (0);
<         return v;
<     }
<   //// WIGIG ////
<   if (HasDmgSupported () || HasEdmgSupported ())
---
>   NS_LOG_FUNCTION (this << address << *header << packet);
>   NS_ASSERT (!address.IsGroup ());
>   if (!IsLowLatency ())
859c785,792
<       return GetDmgControlTxVector ();
---
>       HighLatencyRtsTxVectorTag rtstag;
>       bool found;
>       found = ConstCast<Packet> (packet)->PeekPacketTag (rtstag);
>       NS_ASSERT (found);
>       //cast found to void, to suppress 'found' set but not used
>       //compiler warning
>       (void) found;
>       return rtstag.GetRtsTxVector ();
861,862c794
<   //// WIGIG ////
<   return DoGetRtsTxVector (Lookup (address));
---
>   return DoGetRtsTxVector (Lookup (address, header));
870,871c802,803
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
<   m_ssrc[ac]++;
---
>   WifiRemoteStation *station = Lookup (address, header);
>   station->m_ssrc++;
873c805
<   DoReportRtsFailed (Lookup (address));
---
>   DoReportRtsFailed (station);
877,878c809
< WifiRemoteStationManager::ReportDataFailed (Mac48Address address, const WifiMacHeader *header,
<                                             uint32_t packetSize)
---
> WifiRemoteStationManager::ReportDataFailed (Mac48Address address, const WifiMacHeader *header)
882,891c813,814
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
<   bool longMpdu = (packetSize + header->GetSize () + WIFI_MAC_FCS_LENGTH) > m_rtsCtsThreshold;
<   if (longMpdu)
<     {
<       m_slrc[ac]++;
<     }
<   else
<     {
<       m_ssrc[ac]++;
<     }
---
>   WifiRemoteStation *station = Lookup (address, header);
>   station->m_slrc++;
893c816
<   DoReportDataFailed (Lookup (address));
---
>   DoReportDataFailed (station);
902,907c825,827
<   WifiRemoteStation *station = Lookup (address);
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
<   station->m_state->m_info.NotifyTxSuccess (m_ssrc[ac]);
<   m_ssrc[ac] = 0;
<   m_macTxOk (address);
<   m_txCallbackOk (address);
---
>   WifiRemoteStation *station = Lookup (address, header);
>   station->m_state->m_info.NotifyTxSuccess (station->m_ssrc);
>   station->m_ssrc = 0;
913,914c833
<                                         double ackSnr, WifiMode ackMode, double dataSnr,
<                                         WifiTxVector dataTxVector, uint32_t packetSize)
---
>                                         double ackSnr, WifiMode ackMode, double dataSnr)
916c835
<   NS_LOG_FUNCTION (this << address << *header << ackSnr << ackMode << dataSnr << dataTxVector << packetSize);
---
>   NS_LOG_FUNCTION (this << address << *header << ackSnr << ackMode << dataSnr);
918,933c837,840
<   WifiRemoteStation *station = Lookup (address);
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
<   bool longMpdu = (packetSize + header->GetSize () + WIFI_MAC_FCS_LENGTH) > m_rtsCtsThreshold;
<   if (longMpdu)
<     {
<       station->m_state->m_info.NotifyTxSuccess (m_slrc[ac]);
<       m_slrc[ac] = 0;
<     }
<   else
<     {
<       station->m_state->m_info.NotifyTxSuccess (m_ssrc[ac]);
<       m_ssrc[ac] = 0;
<     }
<   m_macTxOk (address);
<   m_txCallbackOk (address);
<   DoReportDataOk (station, ackSnr, ackMode, dataSnr, dataTxVector.GetChannelWidth (), dataTxVector.GetNss ());
---
>   WifiRemoteStation *station = Lookup (address, header);
>   station->m_state->m_info.NotifyTxSuccess (station->m_slrc);
>   station->m_slrc = 0;
>   DoReportDataOk (station, ackSnr, ackMode, dataSnr);
941,942c848
<   WifiRemoteStation *station = Lookup (address);
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
---
>   WifiRemoteStation *station = Lookup (address, header);
944c850
<   m_ssrc[ac] = 0;
---
>   station->m_ssrc = 0;
950,951c856
< WifiRemoteStationManager::ReportFinalDataFailed (Mac48Address address, const WifiMacHeader *header,
<                                                  uint32_t packetSize)
---
> WifiRemoteStationManager::ReportFinalDataFailed (Mac48Address address, const WifiMacHeader *header)
955,956c860
<   WifiRemoteStation *station = Lookup (address);
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
---
>   WifiRemoteStation *station = Lookup (address, header);
958,966c862
<   bool longMpdu = (packetSize + header->GetSize () + WIFI_MAC_FCS_LENGTH) > m_rtsCtsThreshold;
<   if (longMpdu)
<     {
<       m_slrc[ac] = 0;
<     }
<   else
<     {
<       m_ssrc[ac] = 0;
<     }
---
>   station->m_slrc = 0;
972c868,869
< WifiRemoteStationManager::ReportRxOk (Mac48Address address, const WifiMacHeader *header, double rxSnr, WifiMode txMode)
---
> WifiRemoteStationManager::ReportRxOk (Mac48Address address, const WifiMacHeader *header,
>                                       double rxSnr, WifiMode txMode)
974c871
<   NS_LOG_FUNCTION (this << address << rxSnr << txMode);
---
>   NS_LOG_FUNCTION (this << address << *header << rxSnr << txMode);
979,982c876,877
<   m_rxSnr = rxSnr;
<   m_rxCallbackOk (address);
<   m_macRxOk (header->GetType (), address, rxSnr);
<   DoReportRxOk (Lookup (address), rxSnr, txMode);
---
>   WifiRemoteStation *station = Lookup (address, header);
>   DoReportRxOk (station, rxSnr, txMode);
986,988c881,882
< WifiRemoteStationManager::ReportAmpduTxStatus (Mac48Address address,
<                                                uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                                                double rxSnr, double dataSnr, WifiTxVector dataTxVector)
---
> WifiRemoteStationManager::ReportAmpduTxStatus (Mac48Address address, uint8_t tid,
>                                                uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus, double rxSnr, double dataSnr)
990c884
<   NS_LOG_FUNCTION (this << address << +nSuccessfulMpdus << +nFailedMpdus << rxSnr << dataSnr << dataTxVector);
---
>   NS_LOG_FUNCTION (this << address << (uint16_t)tid << nSuccessfulMpdus << nFailedMpdus << rxSnr << dataSnr);
992,996c886,887
<   for (uint8_t i = 0; i < nFailedMpdus; i++)
<     {
<       m_macTxDataFailed (address);
<     }
<   DoReportAmpduTxStatus (Lookup (address), nSuccessfulMpdus, nFailedMpdus, rxSnr, dataSnr, dataTxVector.GetChannelWidth (), dataTxVector.GetNss ());
---
>   WifiRemoteStation *station = Lookup (address, tid);
>   DoReportAmpduTxStatus (station, nSuccessfulMpdus, nFailedMpdus, rxSnr, dataSnr);
1000c891,892
< WifiRemoteStationManager::NeedRts (const WifiMacHeader &header, uint32_t size)
---
> WifiRemoteStationManager::NeedRts (Mac48Address address, const WifiMacHeader *header,
>                                    Ptr<const Packet> packet, WifiTxVector txVector)
1002,1004d893
<   NS_LOG_FUNCTION (this << header << size);
<   Mac48Address address = header.GetAddr1 ();
<   WifiTxVector txVector = GetDataTxVector (header);
1006,1010c895,896
<   if (address.IsGroup ())
<     {
<       return false;
<     }
<   if (m_erpProtectionMode == RTS_CTS
---
>   NS_LOG_FUNCTION (this << address << *header << packet << mode);
>   if (m_protectionMode == RTS_CTS
1012,1014c898,899
<           || (mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
<           || (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
<           || (mode.GetModulationClass () == WIFI_MOD_CLASS_HE))
---
>       || (mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
>       || (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT))
1020,1029c905
<   else if (m_htProtectionMode == RTS_CTS
<            && ((mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
<                || (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT))
<            && m_useNonHtProtection
<            && !(m_erpProtectionMode != RTS_CTS && m_useNonErpProtection))
<     {
<       NS_LOG_DEBUG ("WifiRemoteStationManager::NeedRTS returning true to protect non-HT stations");
<       return true;
<     }
<   else if (m_edmgSupported)
---
>   if (address.IsGroup ())
1031,1036c907
<       DATA_COMMUNICATION_MODE dataMode = StaticCast<DmgWifiMac> (m_wifiMac)->GetStationDataCommunicationMode (address);
<       if (dataMode != DATA_MODE_SISO)
<         {
<           NS_LOG_DEBUG ("WifiRemoteStationManager::NeedRTS returning true to protect MIMO transmission");
<           return true;
<         }
---
>       return false;
1038,1039c909,910
<   bool normally = (size > m_rtsCtsThreshold);
<   return DoNeedRts (Lookup (address), size, normally);
---
>   bool normally = (packet->GetSize () + header->GetSize () + WIFI_MAC_FCS_LENGTH) > GetRtsCtsThreshold ();
>   return DoNeedRts (Lookup (address, header), packet, normally);
1047c918
<   if (m_erpProtectionMode == CTS_TO_SELF
---
>   if (m_protectionMode == CTS_TO_SELF
1049,1051c920,921
<           || (mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
<           || (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
<           || (mode.GetModulationClass () == WIFI_MOD_CLASS_HE))
---
>       || (mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
>       || (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT))
1057,1065d926
<   else if (m_htProtectionMode == CTS_TO_SELF
<            && ((mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
<                || (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT))
<            && m_useNonHtProtection
<            && !(m_erpProtectionMode != CTS_TO_SELF && m_useNonErpProtection))
<     {
<       NS_LOG_DEBUG ("WifiRemoteStationManager::NeedCtsToSelf returning true to protect non-HT stations");
<       return true;
<     }
1068c929
<       //search for the BSS Basic Rate set, if the used mode is in the basic set then there is no need for CTS To Self
---
>     //search for the BSS Basic Rate set, if the used mode is in the basic set then there is no need for Cts To Self
1077c938
<       if (GetHtSupported ())
---
>       if (HasHtSupported ())
1079c940
<           //search for the BSS Basic MCS set, if the used mode is in the basic set then there is no need for CTS To Self
---
>           //search for the BSS Basic MCS set, if the used mode is in the basic set then there is no need for Cts To Self
1098d958
<   NS_LOG_FUNCTION (this << enable);
1108,1127d967
< void
< WifiRemoteStationManager::SetUseNonHtProtection (bool enable)
< {
<   NS_LOG_FUNCTION (this << enable);
<   m_useNonHtProtection = enable;
< }
< 
< bool
< WifiRemoteStationManager::GetUseNonHtProtection (void) const
< {
<   return m_useNonHtProtection;
< }
< 
< void
< WifiRemoteStationManager::SetUseGreenfieldProtection (bool enable)
< {
<   NS_LOG_FUNCTION (this << enable);
<   m_useGreenfieldProtection = enable;
< }
< 
1129c969,970
< WifiRemoteStationManager::GetUseGreenfieldProtection (void) const
---
> WifiRemoteStationManager::NeedRtsRetransmission (Mac48Address address, const WifiMacHeader *header,
>                                                  Ptr<const Packet> packet)
1131c972,977
<   return m_useGreenfieldProtection;
---
>   NS_LOG_FUNCTION (this << address << packet << *header);
>   NS_ASSERT (!address.IsGroup ());
>   WifiRemoteStation *station = Lookup (address, header);
>   bool normally = station->m_ssrc < GetMaxSsrc ();
>   NS_LOG_DEBUG ("WifiRemoteStationManager::NeedDataRetransmission count: " << station->m_ssrc << " result: " << std::boolalpha << normally);
>   return DoNeedRtsRetransmission (station, packet, normally);
1135,1136c981,982
< WifiRemoteStationManager::NeedRetransmission (Mac48Address address, const WifiMacHeader *header,
<                                               Ptr<const Packet> packet)
---
> WifiRemoteStationManager::NeedDataRetransmission (Mac48Address address, const WifiMacHeader *header,
>                                                   Ptr<const Packet> packet)
1140,1155c986,989
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
<   bool longMpdu = (packet->GetSize () + header->GetSize () + WIFI_MAC_FCS_LENGTH) > m_rtsCtsThreshold;
<   uint32_t retryCount, maxRetryCount;
<   if (longMpdu)
<     {
<       retryCount = m_slrc[ac];
<       maxRetryCount = m_maxSlrc;
<     }
<   else
<     {
<       retryCount = m_ssrc[ac];
<       maxRetryCount = m_maxSsrc;
<     }
<   bool normally = retryCount < maxRetryCount;
<   NS_LOG_DEBUG ("WifiRemoteStationManager::NeedRetransmission count: " << retryCount << " result: " << std::boolalpha << normally);
<   return DoNeedRetransmission (Lookup (address), packet, normally);
---
>   WifiRemoteStation *station = Lookup (address, header);
>   bool normally = station->m_slrc < GetMaxSlrc ();
>   NS_LOG_DEBUG ("WifiRemoteStationManager::NeedDataRetransmission count: " << station->m_slrc << " result: " << std::boolalpha << normally);
>   return DoNeedDataRetransmission (station, packet, normally);
1166a1001
>   WifiRemoteStation *station = Lookup (address, header);
1169c1004
<   return DoNeedFragmentation (Lookup (address), packet, normally);
---
>   return DoNeedFragmentation (station, packet, normally);
1281c1116,1294
< //// WIGIG ////
---
> bool
> WifiRemoteStationManager::IsAllowedControlAnswerModulationClass (enum WifiModulationClass modClassReq, enum WifiModulationClass modClassAnswer) const
> {
>   switch (modClassReq)
>     {
>     case WIFI_MOD_CLASS_DSSS:
>       return (modClassAnswer == WIFI_MOD_CLASS_DSSS);
>     case WIFI_MOD_CLASS_HR_DSSS:
>       return (modClassAnswer == WIFI_MOD_CLASS_DSSS || modClassAnswer == WIFI_MOD_CLASS_HR_DSSS);
>     case WIFI_MOD_CLASS_ERP_OFDM:
>       return (modClassAnswer == WIFI_MOD_CLASS_DSSS || modClassAnswer == WIFI_MOD_CLASS_HR_DSSS || modClassAnswer == WIFI_MOD_CLASS_ERP_OFDM);
>     case WIFI_MOD_CLASS_OFDM:
>       return (modClassAnswer == WIFI_MOD_CLASS_OFDM);
>     case WIFI_MOD_CLASS_HT:
>     case WIFI_MOD_CLASS_VHT:
>       return true;
>     default:
>       NS_FATAL_ERROR ("Modulation class not defined");
>       return false;
>     }
> }
> 
> WifiMode
> WifiRemoteStationManager::GetControlAnswerMode (Mac48Address address, WifiMode reqMode)
> {
>   /**
>    * The standard has relatively unambiguous rules for selecting a
>    * control response rate (the below is quoted from IEEE 802.11-2012,
>    * Section 9.7):
>    *
>    * To allow the transmitting STA to calculate the contents of the
>    * Duration/ID field, a STA responding to a received frame shall
>    * transmit its Control Response frame (either CTS or ACK), other
>    * than the BlockAck control frame, at the highest rate in the
>    * BSSBasicRateSet parameter that is less than or equal to the
>    * rate of the immediately previous frame in the frame exchange
>    * sequence (as defined in Annex G) and that is of the same
>    * modulation class (see Section 9.7.8) as the received frame...
>    */
>   NS_LOG_FUNCTION (this << address << reqMode);
>   WifiMode mode = GetDefaultMode ();
>   bool found = false;
>   //First, search the BSS Basic Rate set
>   for (WifiModeListIterator i = m_bssBasicRateSet.begin (); i != m_bssBasicRateSet.end (); i++)
>     {
>       if ((!found || i->IsHigherDataRate (mode))
>           && (!i->IsHigherDataRate (reqMode))
>           && (IsAllowedControlAnswerModulationClass (reqMode.GetModulationClass (), i->GetModulationClass ())))
>         {
>           mode = *i;
>           //We've found a potentially-suitable transmit rate, but we
>           //need to continue and consider all the basic rates before
>           //we can be sure we've got the right one.
>           found = true;
>         }
>     }
>   if (HasHtSupported () || HasVhtSupported ())
>     {
>       if (!found)
>         {
>           mode = GetDefaultMcs ();
>           for (WifiModeListIterator i = m_bssBasicMcsSet.begin (); i != m_bssBasicMcsSet.end (); i++)
>             {
>               if ((!found || i->IsHigherDataRate (mode))
>                   && (!i->IsHigherDataRate (reqMode))
>                   && (i->GetModulationClass () == reqMode.GetModulationClass ()))
>                 {
>                   mode = *i;
>                   //We've found a potentially-suitable transmit rate, but we
>                   //need to continue and consider all the basic rates before
>                   //we can be sure we've got the right one.
>                   found = true;
>                 }
>             }
>         }
>     }
>   //If we found a suitable rate in the BSSBasicRateSet, then we are
>   //done and can return that mode.
>   if (found)
>     {
>       NS_LOG_DEBUG ("WifiRemoteStationManager::GetControlAnswerMode returning " << mode);
>       return mode;
>     }
> 
>   /**
>    * If no suitable basic rate was found, we search the mandatory
>    * rates. The standard (IEEE 802.11-2007, Section 9.6) says:
>    *
>    *   ...If no rate contained in the BSSBasicRateSet parameter meets
>    *   these conditions, then the control frame sent in response to a
>    *   received frame shall be transmitted at the highest mandatory
>    *   rate of the PHY that is less than or equal to the rate of the
>    *   received frame, and that is of the same modulation class as the
>    *   received frame. In addition, the Control Response frame shall
>    *   be sent using the same PHY options as the received frame,
>    *   unless they conflict with the requirement to use the
>    *   BSSBasicRateSet parameter.
>    *
>    * \todo Note that we're ignoring the last sentence for now, because
>    * there is not yet any manipulation here of PHY options.
>    */
>   for (uint32_t idx = 0; idx < m_wifiPhy->GetNModes (); idx++)
>     {
>       WifiMode thismode = m_wifiPhy->GetMode (idx);
>       /* If the rate:
>        *
>        *  - is a mandatory rate for the PHY, and
>        *  - is equal to or faster than our current best choice, and
>        *  - is less than or equal to the rate of the received frame, and
>        *  - is of the same modulation class as the received frame
>        *
>        * ...then it's our best choice so far.
>        */
>       if (thismode.IsMandatory ()
>           && (!found || thismode.IsHigherDataRate (mode))
>           && (!thismode.IsHigherDataRate (reqMode))
>           && (IsAllowedControlAnswerModulationClass (reqMode.GetModulationClass (), thismode.GetModulationClass ())))
>         {
>           mode = thismode;
>           //As above; we've found a potentially-suitable transmit
>           //rate, but we need to continue and consider all the
>           //mandatory rates before we can be sure we've got the right one.
>           found = true;
>         }
>     }
>   if (HasHtSupported () || HasVhtSupported ())
>     {
>       for (uint32_t idx = 0; idx < m_wifiPhy->GetNMcs (); idx++)
>         {
>           WifiMode thismode = m_wifiPhy->GetMcs (idx);
>           if (thismode.IsMandatory ()
>               && (!found || thismode.IsHigherDataRate (mode))
>               && (!thismode.IsHigherCodeRate(reqMode))
>               && (thismode.GetModulationClass () == reqMode.GetModulationClass ()))
>             {
>               mode = thismode;
>               //As above; we've found a potentially-suitable transmit
>               //rate, but we need to continue and consider all the
>               //mandatory rates before we can be sure we've got the right one.
>               found = true;
>             }
> 
>         }
>     }
> 
>   /**
>    * If we still haven't found a suitable rate for the response then
>    * someone has messed up the simulation config. This probably means
>    * that the WifiPhyStandard is not set correctly, or that a rate that
>    * is not supported by the PHY has been explicitly requested in a
>    * WifiRemoteStationManager (or descendant) configuration.
>    *
>    * Either way, it is serious - we can either disobey the standard or
>    * fail, and I have chosen to do the latter...
>    */
>   if (!found)
>     {
>       NS_FATAL_ERROR ("Can't find response rate for " << reqMode);
>     }
> 
>   NS_LOG_DEBUG ("WifiRemoteStationManager::GetControlAnswerMode returning " << mode);
>   return mode;
> }
> 
> WifiTxVector
> WifiRemoteStationManager::GetCtsTxVector (Mac48Address address, WifiMode rtsMode)
> {
>   NS_ASSERT (!address.IsGroup ());
>   WifiTxVector v;
>   v.SetMode (GetControlAnswerMode (address, rtsMode));
>   v.SetTxPowerLevel (DoGetCtsTxPowerLevel (address, v.GetMode ()));
>   v.SetChannelWidth (DoGetCtsTxChannelWidth (address, v.GetMode ()));
>   v.SetShortGuardInterval (DoGetCtsTxGuardInterval (address, v.GetMode ()));
>   v.SetNss (DoGetCtsTxNss (address, v.GetMode ()));
>   v.SetNess (DoGetCtsTxNess (address, v.GetMode ()));
>   v.SetStbc (DoGetCtsTxStbc (address, v.GetMode ()));
>   return v;
> }
> 
1283c1296
< WifiRemoteStationManager::GetDmgControlTxVector (void)
---
> WifiRemoteStationManager::GetAckTxVector (Mac48Address address, WifiMode dataMode)
1285c1298
<   WifiMode mode = m_wifiPhy->GetMode (0);
---
>   NS_ASSERT (!address.IsGroup ());
1287,1291c1300,1306
<   v.SetMode (mode);
<   v.SetTxPowerLevel (m_defaultTxPowerLevel);
<   v.SetPreambleType (GetPreambleForTransmission (mode.GetModulationClass ()));
<   v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
<   v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
---
>   v.SetMode (GetControlAnswerMode (address, dataMode));
>   v.SetTxPowerLevel (DoGetAckTxPowerLevel (address, v.GetMode ()));
>   v.SetChannelWidth (DoGetAckTxChannelWidth (address, v.GetMode ()));
>   v.SetShortGuardInterval (DoGetAckTxGuardInterval (address, v.GetMode ()));
>   v.SetNss (DoGetAckTxNss (address, v.GetMode ()));
>   v.SetNess (DoGetAckTxNess (address, v.GetMode ()));
>   v.SetStbc (DoGetAckTxStbc (address, v.GetMode ()));
1296c1311
< WifiRemoteStationManager::GetDmgLowestScVector (void)
---
> WifiRemoteStationManager::GetBlockAckTxVector (Mac48Address address, WifiMode blockAckReqMode)
1298c1313
<   WifiMode mode = m_wifiPhy->GetMode (1);
---
>   NS_ASSERT (!address.IsGroup ());
1300,1304c1315,1321
<   v.SetMode (mode); // DMG/EDMG SC Modulation Class (MCS1)
<   v.SetTxPowerLevel (m_defaultTxPowerLevel);
<   v.SetPreambleType (GetPreambleForTransmission (mode.GetModulationClass ()));
<   v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
<   v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
---
>   v.SetMode (GetControlAnswerMode (address, blockAckReqMode));
>   v.SetTxPowerLevel (DoGetBlockAckTxPowerLevel (address, v.GetMode ()));
>   v.SetChannelWidth (DoGetBlockAckTxChannelWidth (address, v.GetMode ()));
>   v.SetShortGuardInterval (DoGetBlockAckTxGuardInterval (address, v.GetMode ()));
>   v.SetNss (DoGetBlockAckTxNss (address, v.GetMode ()));
>   v.SetNess (DoGetBlockAckTxNess (address, v.GetMode ()));
>   v.SetStbc (DoGetBlockAckTxStbc (address, v.GetMode ()));
1307c1324,1431
< //// WIGIG ////
---
> 
> uint8_t
> WifiRemoteStationManager::DoGetCtsTxPowerLevel (Mac48Address address, WifiMode ctsMode)
> {
>   return m_defaultTxPowerLevel;
> }
> 
> uint32_t
> WifiRemoteStationManager::DoGetCtsTxChannelWidth (Mac48Address address, WifiMode ctsMode)
> {
>   return m_wifiPhy->GetChannelWidth ();
> }
> 
> bool
> WifiRemoteStationManager::DoGetCtsTxGuardInterval (Mac48Address address, WifiMode ctsMode)
> {
>   return m_wifiPhy->GetGuardInterval ();
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetCtsTxNss (Mac48Address address, WifiMode ctsMode)
> {
>   return 1;
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetCtsTxNess (Mac48Address address, WifiMode ctsMode)
> {
>   return 0;
> }
> 
> bool
> WifiRemoteStationManager::DoGetCtsTxStbc (Mac48Address address, WifiMode ctsMode)
> {
>   return m_wifiPhy->GetStbc ();
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetAckTxPowerLevel (Mac48Address address, WifiMode ackMode)
> {
>   return m_defaultTxPowerLevel;
> }
> 
> uint32_t
> WifiRemoteStationManager::DoGetAckTxChannelWidth (Mac48Address address, WifiMode ctsMode)
> {
>   return m_wifiPhy->GetChannelWidth ();
> }
> 
> bool
> WifiRemoteStationManager::DoGetAckTxGuardInterval (Mac48Address address, WifiMode ackMode)
> {
>   return m_wifiPhy->GetGuardInterval ();
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetAckTxNss (Mac48Address address, WifiMode ackMode)
> {
>   return 1;
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetAckTxNess (Mac48Address address, WifiMode ackMode)
> {
>   return 0;
> }
> 
> bool
> WifiRemoteStationManager::DoGetAckTxStbc (Mac48Address address, WifiMode ackMode)
> {
>   return m_wifiPhy->GetStbc ();
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetBlockAckTxPowerLevel (Mac48Address address, WifiMode blockAckMode)
> {
>   return m_defaultTxPowerLevel;
> }
> 
> uint32_t
> WifiRemoteStationManager::DoGetBlockAckTxChannelWidth (Mac48Address address, WifiMode ctsMode)
> {
>   return m_wifiPhy->GetChannelWidth ();
> }
> 
> bool
> WifiRemoteStationManager::DoGetBlockAckTxGuardInterval (Mac48Address address, WifiMode blockAckMode)
> {
>   return m_wifiPhy->GetGuardInterval ();
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetBlockAckTxNss (Mac48Address address, WifiMode blockAckMode)
> {
>   return 1;
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetBlockAckTxNess (Mac48Address address, WifiMode blockAckMode)
> {
>   return 0;
> }
> 
> bool
> WifiRemoteStationManager::DoGetBlockAckTxStbc (Mac48Address address, WifiMode blockAckMode)
> {
>   return m_wifiPhy->GetStbc ();
> }
1339,1341d1462
<   state->m_htCapabilities = 0;
<   state->m_vhtCapabilities = 0;
<   state->m_heCapabilities = 0;
1343c1464,1466
<   state->m_guardInterval = GetGuardInterval ();
---
>   state->m_shortGuardInterval = m_wifiPhy->GetGuardInterval ();
>   state->m_greenfield = m_wifiPhy->GetGreenfield ();
>   state->m_rx = 1;
1346,1349c1469,1471
<   state->m_qosSupported = false;
<   state->m_dmgSupported = false;
<   state->m_edmgSupported = false;
<   state->m_linkSnr = -100;
---
>   state->m_stbc = false;
>   state->m_htSupported = false;
>   state->m_vhtSupported = false;
1356c1478
< WifiRemoteStationManager::Lookup (Mac48Address address) const
---
> WifiRemoteStationManager::Lookup (Mac48Address address, const WifiMacHeader *header) const
1358c1480,1495
<   NS_LOG_FUNCTION (this << address);
---
>   uint8_t tid;
>   if (header->IsQosData ())
>     {
>       tid = header->GetQosTid ();
>     }
>   else
>     {
>       tid = 0;
>     }
>   return Lookup (address, tid);
> }
> 
> WifiRemoteStation *
> WifiRemoteStationManager::Lookup (Mac48Address address, uint8_t tid) const
> {
>   NS_LOG_FUNCTION (this << address << (uint16_t)tid);
1361c1498,1499
<       if ((*i)->m_state->m_address == address)
---
>       if ((*i)->m_tid == tid
>           && (*i)->m_state->m_address == address)
1369a1508,1510
>   station->m_tid = tid;
>   station->m_ssrc = 0;
>   station->m_slrc = 0;
1375,1384c1516
< WifiRemoteStationManager::SetQosSupport (Mac48Address from, bool qosSupported)
< {
<   NS_LOG_FUNCTION (this << from << qosSupported);
<   WifiRemoteStationState *state;
<   state = LookupState (from);
<   state->m_qosSupported = qosSupported;
< }
< 
< void
< WifiRemoteStationManager::AddStationHtCapabilities (Mac48Address from, Ptr<HtCapabilities> htCapabilities)
---
> WifiRemoteStationManager::AddStationHtCapabilities (Mac48Address from, HtCapabilities htCapabilities)
1390c1522,1523
<   if (htCapabilities->GetSupportedChannelWidth () == 1)
---
>   state->m_shortGuardInterval = htCapabilities.GetShortGuardInterval20 ();
>   if (htCapabilities.GetSupportedChannelWidth () == 1)
1398,1407c1531,1533
<   SetQosSupport (from, true);
<   for (uint8_t j = 0; j < m_wifiPhy->GetNMcs (); j++)
<     {
<       WifiMode mcs = m_wifiPhy->GetMcs (j);
<       if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HT && htCapabilities->IsSupportedMcs (mcs.GetMcsValue ()))
<         {
<           AddSupportedMcs (from, mcs);
<         }
<     }
<   state->m_htCapabilities = htCapabilities;
---
>   state->m_htSupported = true;
>   state->m_greenfield = htCapabilities.GetGreenfield ();
>   state->m_rx = htCapabilities.GetRxHighestSupportedAntennas ();
1411c1537
< WifiRemoteStationManager::AddStationVhtCapabilities (Mac48Address from, Ptr<VhtCapabilities> vhtCapabilities)
---
> WifiRemoteStationManager::AddStationVhtCapabilities (Mac48Address from, VhtCapabilities vhtCapabilities)
1417c1543
<   if (vhtCapabilities->GetSupportedChannelWidthSet () == 1)
---
>   if (vhtCapabilities.GetSupportedChannelWidthSet () == 1)
1431,1558c1557
<   for (uint8_t i = 1; i <= m_wifiPhy->GetMaxSupportedTxSpatialStreams (); i++)
<     {
<       for (uint8_t j = 0; j < m_wifiPhy->GetNMcs (); j++)
<         {
<           WifiMode mcs = m_wifiPhy->GetMcs (j);
<           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedMcs (mcs.GetMcsValue (), i))
<             {
<               AddSupportedMcs (from, mcs);
<             }
<         }
<     }
<   state->m_vhtCapabilities = vhtCapabilities;
< }
< 
< //// WIGIG ////
< void
< WifiRemoteStationManager::AddStationDmgCapabilities (Mac48Address from, Ptr<DmgCapabilities> dmgCapabilities)
< {
<   //Used by all stations to record DMG capabilities of remote stations
<   NS_LOG_FUNCTION (this << from << dmgCapabilities);
<   WifiRemoteStationState *state;
<   state = LookupState (from);
<   state->m_qosSupported = true;
<   state->m_dmgSupported = true;
<   state->m_dmgCapabilities = dmgCapabilities;
< }
< 
< void
< WifiRemoteStationManager::AddStationEdmgCapabilities (Mac48Address from, Ptr<EdmgCapabilities> edmgCapabilities)
< {
<   //Used by all stations to record EDMG capabilities of remote stations
<   NS_LOG_FUNCTION (this << from << edmgCapabilities);
<   WifiRemoteStationState *state;
<   state = LookupState (from);
<   state->m_qosSupported = true;
<   state->m_edmgSupported = true;
<   state->m_edmgCapabilities = edmgCapabilities;
< }
< 
< Ptr<const DmgCapabilities>
< WifiRemoteStationManager::GetStationDmgCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_dmgCapabilities;
< }
< 
< Ptr<const EdmgCapabilities>
< WifiRemoteStationManager::GetStationEdmgCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_edmgCapabilities;
< }
< 
< //// WIGIG ////
< 
< void
< WifiRemoteStationManager::AddStationHeCapabilities (Mac48Address from, Ptr<HeCapabilities> heCapabilities)
< {
<   //Used by all stations to record HE capabilities of remote stations
<   NS_LOG_FUNCTION (this << from << heCapabilities);
<   WifiRemoteStationState *state;
<   state = LookupState (from);
<   if (Is5Ghz (m_wifiPhy->GetFrequency ()))
<     {
<       if (heCapabilities->GetChannelWidthSet () & 0x04)
<         {
<           state->m_channelWidth = 160;
<         }
<       else if (heCapabilities->GetChannelWidthSet () & 0x02)
<         {
<           state->m_channelWidth = 80;
<         }
<       //For other cases at 5 GHz, the supported channel width is set by the VHT capabilities
<     }
<   else if (Is2_4Ghz (m_wifiPhy->GetFrequency ()))
<     {
<       if (heCapabilities->GetChannelWidthSet () & 0x01)
<         {
<           state->m_channelWidth = 40;
<         }
<       else
<         {
<           state->m_channelWidth = 20;
<         }
<     }
<   if (heCapabilities->GetHeLtfAndGiForHePpdus () >= 2)
<     {
<       state->m_guardInterval = 800;
<     }
<   else if (heCapabilities->GetHeLtfAndGiForHePpdus () == 1)
<     {
<       state->m_guardInterval = 1600;
<     }
<   else
<     {
<       state->m_guardInterval = 3200;
<     }
<   for (uint8_t i = 1; i <= m_wifiPhy->GetMaxSupportedTxSpatialStreams (); i++)
<     {
<       for (uint8_t j = 0; j < m_wifiPhy->GetNMcs (); j++)
<         {
<           WifiMode mcs = m_wifiPhy->GetMcs (j);
<           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE
<               && heCapabilities->GetHighestNssSupported () >= i
<               && heCapabilities->GetHighestMcsSupported () >= j)
<             {
<               AddSupportedMcs (from, mcs);
<             }
<         }
<     }
<   state->m_heCapabilities = heCapabilities;
<   SetQosSupport (from, true);
< }
< 
< Ptr<const HtCapabilities>
< WifiRemoteStationManager::GetStationHtCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_htCapabilities;
< }
< 
< Ptr<const VhtCapabilities>
< WifiRemoteStationManager::GetStationVhtCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_vhtCapabilities;
< }
< 
< Ptr<const HeCapabilities>
< WifiRemoteStationManager::GetStationHeCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_heCapabilities;
---
>   state->m_vhtSupported = true;
1564,1570c1563
<   Ptr<const HtCapabilities> htCapabilities = LookupState (address)->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return false;
<     }
<   return htCapabilities->GetGreenfield ();
---
>   return LookupState (address)->m_greenfield;
1589,1593d1581
<   for (StationStates::const_iterator i = m_states.begin (); i != m_states.end (); i++)
<     {
<       delete (*i);
<     }
<   m_states.clear ();
1599a1588
>   m_bssBasicRateSet.push_back (m_defaultTxMode);
1601,1602c1590,1591
<   m_ssrc.fill (0);
<   m_slrc.fill (0);
---
>   m_bssBasicMcsSet.push_back (m_defaultTxMcs);
>   NS_ASSERT (m_defaultTxMode.IsMandatory ());
1609c1598
<   if (mode.GetModulationClass () >= WIFI_MOD_CLASS_HT)
---
>   if (mode.GetModulationClass () == WIFI_MOD_CLASS_HT || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
1611c1600
<       NS_FATAL_ERROR ("It is not allowed to add a HT rate in the BSSBasicRateSet!");
---
>       NS_FATAL_ERROR ("It is not allowed to add a (V)HT rate in the BSSBasicRateSet!");
1613c1602
<   for (uint8_t i = 0; i < GetNBasicModes (); i++)
---
>   for (uint32_t i = 0; i < GetNBasicModes (); i++)
1623c1612
< uint8_t
---
> uint32_t
1626c1615
<   return static_cast<uint8_t> (m_bssBasicRateSet.size ());
---
>   return m_bssBasicRateSet.size ();
1630c1619
< WifiRemoteStationManager::GetBasicMode (uint8_t i) const
---
> WifiRemoteStationManager::GetBasicMode (uint32_t i) const
1641,1647c1630,1636
<     {
<       if (i->GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM)
<         {
<           continue;
<         }
<       size++;
<     }
---
>   {
>     if (i->GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM)
>       {
>         continue;
>       }
>     size++;
>   }
1652c1641
< WifiRemoteStationManager::GetNonErpBasicMode (uint8_t i) const
---
> WifiRemoteStationManager::GetNonErpBasicMode (uint32_t i) const
1658,1672c1647,1661
<     {
<       if (i == index)
<         {
<           found = true;
<         }
<       if (j->GetModulationClass () != WIFI_MOD_CLASS_ERP_OFDM)
<         {
<           if (found)
<             {
<               break;
<             }
<         }
<       index++;
<       j++;
<     }
---
>   {
>     if (i == index)
>       {
>         found = true;
>       }
>     if (j->GetModulationClass () != WIFI_MOD_CLASS_ERP_OFDM)
>       {
>         if (found)
>           {
>             break;
>           }
>       }
>     index++;
>     j++;
>   }
1679,1680c1668,1669
<   NS_LOG_FUNCTION (this << +mcs.GetMcsValue ());
<   for (uint8_t i = 0; i < GetNBasicMcs (); i++)
---
>   NS_LOG_FUNCTION (this << (uint32_t)mcs.GetMcsValue ());
>   for (uint32_t i = 0; i < GetNBasicMcs (); i++)
1690c1679
< uint8_t
---
> uint32_t
1693c1682
<   return static_cast<uint8_t> (m_bssBasicMcsSet.size ());
---
>   return m_bssBasicMcsSet.size ();
1697c1686
< WifiRemoteStationManager::GetBasicMcs (uint8_t i) const
---
> WifiRemoteStationManager::GetBasicMcs (uint32_t i) const
1708,1715c1697
<       if (GetNBasicModes () > 0)
<         {
<           return GetBasicMode (0);
<         }
<       else
<         {
<           return GetDefaultMode ();
<         }
---
>       return GetBasicMode (0);
1725c1707
<                                      uint32_t size, bool normally)
---
>                                      Ptr<const Packet> packet, bool normally)
1731,1732c1713,1721
< WifiRemoteStationManager::DoNeedRetransmission (WifiRemoteStation *station,
<                                                 Ptr<const Packet> packet, bool normally)
---
> WifiRemoteStationManager::DoNeedRtsRetransmission (WifiRemoteStation *station,
>                                                    Ptr<const Packet> packet, bool normally)
> {
>   return normally;
> }
> 
> bool
> WifiRemoteStationManager::DoNeedDataRetransmission (WifiRemoteStation *station,
>                                                     Ptr<const Packet> packet, bool normally)
1745c1734
< WifiRemoteStationManager::DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus, double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> WifiRemoteStationManager::DoReportAmpduTxStatus (WifiRemoteStation *station, uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus, double rxSnr, double dataSnr)
1751c1740
< WifiRemoteStationManager::GetSupported (const WifiRemoteStation *station, uint8_t i) const
---
> WifiRemoteStationManager::GetSupported (const WifiRemoteStation *station, uint32_t i) const
1758c1747
< WifiRemoteStationManager::GetMcsSupported (const WifiRemoteStation *station, uint8_t i) const
---
> WifiRemoteStationManager::GetMcsSupported (const WifiRemoteStation *station, uint32_t i) const
1765c1754
< WifiRemoteStationManager::GetNonErpSupported (const WifiRemoteStation *station, uint8_t i) const
---
> WifiRemoteStationManager::GetNonErpSupported (const WifiRemoteStation *station, uint32_t i) const
1768c1757
<   //IEEE 802.11g standard defines that if the protection mechanism is enabled, RTS, CTS and CTS-To-Self
---
>   //IEEE 802.11g standard defines that if the protection mechanism is enabled, Rts, Cts and Cts-To-Self
1774,1788c1763,1777
<     {
<       if (i == index)
<         {
<           found = true;
<         }
<       if (j->GetModulationClass () != WIFI_MOD_CLASS_ERP_OFDM)
<         {
<           if (found)
<             {
<               break;
<             }
<         }
<       index++;
<       j++;
<     }
---
>   {
>     if (i == index)
>       {
>         found = true;
>       }
>     if (j->GetModulationClass () != WIFI_MOD_CLASS_ERP_OFDM)
>       {
>         if (found)
>           {
>             break;
>           }
>       }
>     index++;
>     j++;
>   }
1792,1798c1781
< Mac48Address
< WifiRemoteStationManager::GetAddress (const WifiRemoteStation *station) const
< {
<   return station->m_state->m_address;
< }
< 
< uint16_t
---
> uint32_t
1805,1817c1788
< WifiRemoteStationManager::GetShortGuardIntervalSupported (const WifiRemoteStation *station) const
< {
<   Ptr<const HtCapabilities> htCapabilities = station->m_state->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return false;
<     }
<   return htCapabilities->GetShortGuardInterval20 ();
< }
< 
< uint16_t
< WifiRemoteStationManager::GetGuardInterval (const WifiRemoteStation *station) const
---
> WifiRemoteStationManager::GetShortGuardInterval (const WifiRemoteStation *station) const
1819c1790
<   return station->m_state->m_guardInterval;
---
>   return station->m_state->m_shortGuardInterval;
1825,1831c1796
<   Ptr<const HtCapabilities> htCapabilities = station->m_state->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return false;
<     }
<   return htCapabilities->GetGreenfield ();
---
>   return station->m_state->m_greenfield;
1840,1841c1805,1806
< uint8_t
< WifiRemoteStationManager::GetNumberOfSupportedStreams (const WifiRemoteStation *station) const
---
> bool
> WifiRemoteStationManager::GetStbc (const WifiRemoteStation *station) const
1843,1849c1808
<   Ptr<const HtCapabilities> htCapabilities = station->m_state->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return 1;
<     }
<   return htCapabilities->GetRxHighestSupportedAntennas ();
---
>   return station->m_state->m_stbc;
1852a1812,1817
> WifiRemoteStationManager::GetNumberOfSupportedRxAntennas (const WifiRemoteStation *station) const
> {
>   return station->m_state->m_rx;
> }
> 
> uint32_t
1857a1823,1828
> uint32_t
> WifiRemoteStationManager::GetShortRetryCount (const WifiRemoteStation *station) const
> {
>   return station->m_ssrc;
> }
> 
1870,1882d1840
< //// WIGIG ////
< void
< WifiRemoteStationManager::RegisterTxOkCallback (Callback<void, Mac48Address> callback)
< {
<   m_txCallbackOk = callback;
< }
< 
< void
< WifiRemoteStationManager::RegisterRxOkCallback (Callback<void, Mac48Address> callback)
< {
<   m_rxCallbackOk = callback;
< }
< 
1884,1890c1842
< WifiRemoteStationManager::GetNAssociatedStation (void) const
< {
<   return m_states.size ();
< }
< 
< double
< WifiRemoteStationManager::GetRxSnr (void) const
---
> WifiRemoteStationManager::GetLongRetryCount (const WifiRemoteStation *station) const
1892c1844
<   return m_rxSnr;
---
>   return station->m_slrc;
1894d1845
< //// WIGIG ////
1896c1847
< uint8_t
---
> uint32_t
1899,1905c1850
<   return static_cast<uint8_t> (station->m_state->m_operationalRateSet.size ());
< }
< 
< bool
< WifiRemoteStationManager::GetQosSupported (const WifiRemoteStation *station) const
< {
<   return station->m_state->m_qosSupported;
---
>   return station->m_state->m_operationalRateSet.size ();
1911c1856
<   return (station->m_state->m_htCapabilities != 0);
---
>   return station->m_state->m_htSupported;
1917,1923c1862
<   return (station->m_state->m_vhtCapabilities != 0);
< }
< 
< bool
< WifiRemoteStationManager::GetHeSupported (const WifiRemoteStation *station) const
< {
<   return (station->m_state->m_heCapabilities != 0);
---
>   return station->m_state->m_vhtSupported;
1926c1865
< uint8_t
---
> uint32_t
1929c1868
<   return static_cast<uint8_t> (station->m_state->m_operationalMcsSet.size ());
---
>   return station->m_state->m_operationalMcsSet.size ();
1937,1943c1876,1882
<     {
<       if (i->GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM)
<         {
<           continue;
<         }
<       size++;
<     }
---
>   {
>     if (i->GetModulationClass () == WIFI_MOD_CLASS_ERP_OFDM)
>       {
>         continue;
>       }
>     size++;
>   }
1947,1978c1886,1887
< uint16_t
< WifiRemoteStationManager::GetChannelWidthSupported (Mac48Address address) const
< {
<   return LookupState (address)->m_channelWidth;
< }
< 
< bool
< WifiRemoteStationManager::GetShortGuardIntervalSupported (Mac48Address address) const
< {
<   Ptr<const HtCapabilities> htCapabilities = LookupState (address)->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return false;
<     }
<   return htCapabilities->GetShortGuardInterval20 ();
< }
< 
< uint8_t
< WifiRemoteStationManager::GetNumberOfSupportedStreams (Mac48Address address) const
< {
<   Ptr<const HtCapabilities> htCapabilities = LookupState (address)->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return 1;
<     }
<   return htCapabilities->GetRxHighestSupportedAntennas ();
< }
< 
< uint8_t
< WifiRemoteStationManager::GetNMcsSupported (Mac48Address address) const
---
> void
> WifiRemoteStationManager::SetDefaultTxPowerLevel (uint8_t txPower)
1980c1889
<   return static_cast<uint8_t> (LookupState (address)->m_operationalMcsSet.size ());
---
>   m_defaultTxPowerLevel = txPower;
1983,1984c1892,1893
< bool
< WifiRemoteStationManager::GetHtSupported (Mac48Address address) const
---
> uint32_t
> WifiRemoteStationManager::GetNumberOfTransmitAntennas (void)
1986c1895
<   return (LookupState (address)->m_htCapabilities != 0);
---
>   return m_wifiPhy->GetNumberOfTransmitAntennas ();
1989,1990c1898,1901
< bool
< WifiRemoteStationManager::GetVhtSupported (Mac48Address address) const
---
> WifiRemoteStationInfo::WifiRemoteStationInfo ()
>   : m_memoryTime (Seconds (1.0)),
>     m_lastUpdate (Seconds (0.0)),
>     m_failAvg (0.0)
1992d1902
<   return (LookupState (address)->m_vhtCapabilities != 0);
1995,1996c1905,1906
< bool
< WifiRemoteStationManager::GetHeSupported (Mac48Address address) const
---
> double
> WifiRemoteStationInfo::CalculateAveragingCoefficient ()
1998c1908,1911
<   return (LookupState (address)->m_heCapabilities != 0);
---
>   double retval = std::exp ((double)(m_lastUpdate.GetMicroSeconds () - Simulator::Now ().GetMicroSeconds ())
>                             / (double)m_memoryTime.GetMicroSeconds ());
>   m_lastUpdate = Simulator::Now ();
>   return retval;
2002c1915
< WifiRemoteStationManager::SetDefaultTxPowerLevel (uint8_t txPower)
---
> WifiRemoteStationInfo::NotifyTxSuccess (uint32_t retryCounter)
2004c1917,1918
<   m_defaultTxPowerLevel = txPower;
---
>   double coefficient = CalculateAveragingCoefficient ();
>   m_failAvg = (double)retryCounter / (1 + (double)retryCounter) * (1.0 - coefficient) + coefficient * m_failAvg;
2007,2008c1921,1922
< uint8_t
< WifiRemoteStationManager::GetNumberOfAntennas (void) const
---
> void
> WifiRemoteStationInfo::NotifyTxFailed ()
2010c1924,1925
<   return m_wifiPhy->GetNumberOfAntennas ();
---
>   double coefficient = CalculateAveragingCoefficient ();
>   m_failAvg = (1.0 - coefficient) + coefficient * m_failAvg;
2013,2014c1928,1929
< uint8_t
< WifiRemoteStationManager::GetMaxNumberOfTransmitStreams (void) const
---
> double
> WifiRemoteStationInfo::GetFrameErrorRate () const
2016c1931
<   return m_wifiPhy->GetMaxSupportedTxSpatialStreams ();
---
>   return m_failAvg;
2019,2020c1934
< bool
< WifiRemoteStationManager::UseGreenfieldForDestination (Mac48Address dest) const
---
> WifiRemoteStation::~WifiRemoteStation ()
2022c1936
<   return (GetGreenfieldSupported () && GetGreenfieldSupported (dest) && !GetUseGreenfieldProtection ());
---
>   NS_LOG_FUNCTION (this);
diff ../../NS3-WiGig/src/wifi/model/wifi-remote-station-manager.h ../../ns-3-dev/src/wifi/model/wifi-remote-station-manager.h
24c24,26
< #include <array>
---
> #include <vector>
> #include <utility>
> #include "ns3/mac48-address.h"
25a28
> #include "ns3/packet.h"
27,28c30
< #include "ns3/data-rate.h"
< #include "ns3/mac48-address.h"
---
> #include "ns3/nstime.h"
30,32c32
< #include "wifi-utils.h"
< #include "qos-utils.h"
< #include "wifi-remote-station-info.h"
---
> #include "wifi-tx-vector.h"
35,40d34
< #include "he-capabilities.h"
< //// WIGIG ////
< #include "dmg-capabilities.h"
< #include "edmg-capabilities.h"
< #include "wifi-mac-header.h"
< //// WIGIG ////
43a38,39
> struct WifiRemoteStation;
> struct WifiRemoteStationState;
47,48d42
< class Packet;
< class WifiTxVector;
51,71c45
<  * Enumeration for type of station
<  */
< enum TypeOfStation
< {
<   DMG_STA,
<   DMG_AP,
<   DMG_ADHOC,
<   STA,
<   AP,
<   ADHOC_STA,
<   MESH,
<   HT_STA,
<   HT_AP,
<   HT_ADHOC_STA,
<   OCB
< };
< 
< struct WifiRemoteStationState;
< 
< /**
<  * \brief hold per-remote-station state.
---
>  * \brief Tid independent remote station statistics
73,79c47,48
<  * The state in this class is used to keep track
<  * of association status if we are in an infrastructure
<  * network and to perform the selection of TX parameters
<  * on a per-packet basis.
<  *
<  * This class is typically subclassed and extended by
<  * rate control implementations
---
>  * Structure is similar to struct sta_info in Linux kernel (see
>  * net/mac80211/sta_info.h)
81,90c50
< struct WifiRemoteStation
< {
<   virtual ~WifiRemoteStation () {};
<   WifiRemoteStationState *m_state;  //!< Remote station state
< };
< 
< /**
<  * A struct that holds information about each remote station.
<  */
< struct WifiRemoteStationState
---
> class WifiRemoteStationInfo
91a52,53
> public:
>   WifiRemoteStationInfo ();
93c55,57
<    * State of the station
---
>    * \brief Updates average frame error rate when data or RTS was transmitted successfully.
>    *
>    * \param retryCounter is slrc or ssrc value at the moment of success transmission.
95,102c59,64
<   enum
<   {
<     BRAND_NEW,
<     DISASSOC,
<     WAIT_ASSOC_TX_OK,
<     GOT_ASSOC_TX_OK
<   } m_state;
< 
---
>   void NotifyTxSuccess (uint32_t retryCounter);
>   /// Updates average frame error rate when final data or RTS has failed.
>   void NotifyTxFailed ();
>   /// Return frame error rate (probability that frame is corrupted due to transmission error).
>   double GetFrameErrorRate () const;
> private:
104,110c66,71
<    * This member is the list of WifiMode objects that comprise the
<    * OperationalRateSet parameter for this remote station. This list
<    * is constructed through calls to
<    * WifiRemoteStationManager::AddSupportedMode(), and an API that
<    * allows external access to it is available through
<    * WifiRemoteStationManager::GetNSupported() and
<    * WifiRemoteStationManager::GetSupported().
---
>    * \brief Calculate averaging coefficient for frame error rate. Depends on time of the last update.
>    *
>    * \attention Calling this method twice gives different results,
>    * because it resets time of last update.
>    *
>    * \return average coefficient for frame error rate
112,134c73,79
<   WifiModeList m_operationalRateSet; //!< operational rate set
<   WifiModeList m_operationalMcsSet;  //!< operational MCS set
<   Mac48Address m_address;            //!< Mac48Address of the remote station
<   WifiRemoteStationInfo m_info;      //!< remote station info
<   Ptr<const HtCapabilities> m_htCapabilities;     //!< remote station HT capabilities
<   Ptr<const VhtCapabilities> m_vhtCapabilities;   //!< remote station VHT capabilities
<   Ptr<const HeCapabilities> m_heCapabilities;     //!< remote station HE capabilities
<   Ptr<const DmgCapabilities> m_dmgCapabilities;   //!< remote station DMG capabilities
<   Ptr<const EdmgCapabilities> m_edmgCapabilities; //!< remote station EDMG capabilities
< 
<   uint16_t m_channelWidth;    //!< Channel width (in MHz) supported by the remote station
<   uint16_t m_guardInterval;   //!< HE Guard interval duration (in nanoseconds) supported by the remote station
<   uint8_t m_ness;             //!< Number of extended spatial streams of the remote station
<   bool m_aggregation;         //!< Flag if MPDU aggregation is used by the remote station
<   bool m_shortPreamble;       //!< Flag if short PHY preamble is supported by the remote station
<   bool m_shortSlotTime;       //!< Flag if short ERP slot time is supported by the remote station
<   //// WIGIG ////
<   bool m_dmgSupported;        //!< Flag if DMG is supported by the station
<   bool m_edmgSupported;       //!< Flag if EDMG is supported by the station
<   uint8_t m_aid;              //!< Association identifier assigned to the station.
<   double m_linkSnr;           //!< The SNR of the link after beamforming training.
<   //// WIGIG ////
<   bool m_qosSupported;        //!< Flag if QoS is supported by the station
---
>   double CalculateAveragingCoefficient ();
>   /// averaging coefficient depends on the memory time
>   Time m_memoryTime;
>   /// when last update has occured
>   Time m_lastUpdate;
>   /// moving percentage of failed frames
>   double m_failAvg;
146,149d90
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
154,155c95
< 
<   /// ProtectionMode enumeration
---
>   
163,171d102
<    * A vector of WifiRemoteStations
<    */
<   typedef std::vector <WifiRemoteStation *> Stations;
<   /**
<    * A vector of WifiRemoteStationStates
<    */
<   typedef std::vector <WifiRemoteStationState *> StationStates;
< 
<   /**
177c108
<   virtual void SetupPhy (const Ptr<WifiPhy> phy);
---
>   virtual void SetupPhy (Ptr<WifiPhy> phy);
182c113
<    * \param mac the MAC of this device
---
>    * \param phy the PHY of this device
184c115
<   virtual void SetupMac (const Ptr<WifiMac> mac);
---
>   virtual void SetupMac (Ptr<WifiMac> mac);
186a118,141
>    * Return the maximum STA short retry count (SSRC).
>    *
>    * \return the maximum SSRC
>    */
>   uint32_t GetMaxSsrc (void) const;
>   /**
>    * Return the maximum STA long retry count (SLRC).
>    *
>    * \return the maximum SLRC
>    */
>   uint32_t GetMaxSlrc (void) const;
>   /**
>    * Return the RTS threshold.
>    *
>    * \return the RTS threshold
>    */
>   uint32_t GetRtsCtsThreshold (void) const;
>   /**
>    * Return the fragmentation threshold.
>    *
>    * \return the fragmentation threshold
>    */
>   uint32_t GetFragmentationThreshold (void) const;
>   /**
204,210d158
< 
<   /**
<    * Return the fragmentation threshold.
<    *
<    * \return the fragmentation threshold
<    */
<   uint32_t GetFragmentationThreshold (void) const;
223,230d170
< 
<   /**
<    * Records QoS support of the remote station.
<    *
<    * \param from the address of the station being recorded
<    * \param qosSupported whether the station supports QoS
<    */
<   void SetQosSupport (Mac48Address from, bool qosSupported);
235c175
<    * \param htCapabilities the HT capabilities of the station
---
>    * \param htcapabilities the HT capabilities of the station
237c177
<   void AddStationHtCapabilities (Mac48Address from, Ptr<HtCapabilities> htcapabilities);
---
>   void AddStationHtCapabilities (Mac48Address from, HtCapabilities htcapabilities);
242,249c182
<    * \param vhtCapabilities the VHT capabilities of the station
<    */
<   void AddStationVhtCapabilities (Mac48Address from, Ptr<VhtCapabilities> vhtcapabilities);
<   /**
<    * Records HE capabilities of the remote station.
<    *
<    * \param from the address of the station being recorded
<    * \param heCapabilities the HE capabilities of the station
---
>    * \param vhtcapabilities the VHT capabilities of the station
251,252c184
<   void AddStationHeCapabilities (Mac48Address from, Ptr<HeCapabilities> heCapabilities);
<   //// WIGIG ////
---
>   void AddStationVhtCapabilities (Mac48Address from,VhtCapabilities vhtcapabilities);
254c186
<    * Records DMG capabilities of the remote station.
---
>    * Enable or disable HT capability support.
256,257c188
<    * \param from the address of the station being recorded
<    * \param dmgCapabilities the DMG capabilities of the station
---
>    * \param enable enable or disable HT capability support
259,303c190
<   void AddStationDmgCapabilities (Mac48Address from, Ptr<DmgCapabilities> dmgCapabilities);
<   /**
<    * Records EDMG capabilities of the remote station.
<    *
<    * \param from the address of the station being recorded
<    * \param edmgCapabilities the EDMG capabilities of the station
<    */
<   void AddStationEdmgCapabilities (Mac48Address from, Ptr<EdmgCapabilities> edmgCapabilities);
<   /**
<    * Return the DMG capabilities sent by the remote station.
<    *
<    * \param from the address of the remote station
<    * \return the DMG capabilities sent by the remote station
<    */
<   Ptr<const DmgCapabilities> GetStationDmgCapabilities (Mac48Address from);
<   /**
<    * Return the EDMG capabilities sent by the remote station.
<    *
<    * \param from the address of the remote station
<    * \return the EDMG capabilities sent by the remote station
<    */
<   Ptr<const EdmgCapabilities> GetStationEdmgCapabilities (Mac48Address from);
< 
<   //// WIGIG ////
<   /**
<    * Return the HT capabilities sent by the remote station.
<    *
<    * \param from the address of the remote station
<    * \return the HT capabilities sent by the remote station
<    */
<   Ptr<const HtCapabilities> GetStationHtCapabilities (Mac48Address from);
<   /**
<    * Return the VHT capabilities sent by the remote station.
<    *
<    * \param from the address of the remote station
<    * \return the VHT capabilities sent by the remote station
<    */
<   Ptr<const VhtCapabilities> GetStationVhtCapabilities (Mac48Address from);
<   /**
<    * Return the HE capabilities sent by the remote station.
<    *
<    * \param from the address of the remote station
<    * \return the HE capabilities sent by the remote station
<    */
<   Ptr<const HeCapabilities> GetStationHeCapabilities (Mac48Address from);
---
>   virtual void SetHtSupported (bool enable);
309,327c196
<   bool GetHtSupported (void) const;
<   /**
<    * Return whether the device has VHT capability support enabled.
<    *
<    * \return true if VHT capability support is enabled, false otherwise
<    */
<   bool GetVhtSupported (void) const;
<   /**
<    * Return whether the device has HE capability support enabled.
<    *
<    * \return true if HE capability support is enabled, false otherwise
<    */
<   bool GetHeSupported (void) const;
<   /**
<    * Enable or disable PCF capability support.
<    *
<    * \param enable enable or disable PCF capability support
<    */
<   void SetPcfSupported (bool enable);
---
>   bool HasHtSupported (void) const;
329c198
<    * Return whether the device has PCF capability support enabled.
---
>    * Enable or disable VHT capability support.
331c200
<    * \return true if PCF capability support is enabled, false otherwise
---
>    * \param enable enable or disable VHT capability support
333c202
<   bool GetPcfSupported (void) const;
---
>   virtual void SetVhtSupported (bool enable);
335c204
<    * Return whether the device has HT Greenfield support enabled.
---
>    * Return whether the device has VHT capability support enabled.
337c206
<    * \return true if HT Grenfield support is enabled, false otherwise
---
>    * \return true if VHT capability support is enabled, false otherwise
339c208
<   bool GetGreenfieldSupported (void) const;
---
>   bool HasVhtSupported (void) const;
341c210
<    * Return whether the device has SGI support enabled.
---
>    * Sets the protection mode.
343c212
<    * \return true if SGI support is enabled, false otherwise
---
>    * \param mode the protection mode
345c214
<   bool GetShortGuardIntervalSupported (void) const;
---
>   void SetProtectionMode (ProtectionMode mode);
347c216
<    * Return the supported HE guard interval duration (in nanoseconds).
---
>    * Return the protection mode.
349c218
<    * \return the supported HE guard interval duration (in nanoseconds)
---
>    * \return the protection mode
351c220
<   uint16_t GetGuardInterval (void) const;
---
>   ProtectionMode GetProtectionMode (void) const;
361c230
<    * \return true if protection for non-ERP stations is enabled,
---
>    * \return true if protection for non-ERP stations is enabled, 
366,392c235
<    * Enable or disable protection for non-HT stations.
<    *
<    * \param enable enable or disable protection for non-HT stations
<    */
<   void SetUseNonHtProtection (bool enable);
<   /**
<    * Return whether the device supports protection of non-HT stations.
<    *
<    * \return true if protection for non-HT stations is enabled,
<    *         false otherwise
<    */
<   bool GetUseNonHtProtection (void) const;
<   /**
<    * Enable or disable protection for stations that do not support HT Greenfield format.
<    *
<    * \param enable enable or disable protection for stations that do not support HT Greenfield format
<    */
<   void SetUseGreenfieldProtection (bool enable);
<   /**
<    * Return whether protection for stations that do not support HT Greenfield format is enabled.
<    *
<    * \return true if protection for stations that do not support HT Greenfield is enabled,
<    *         false otherwise
<    */
<   bool GetUseGreenfieldProtection (void) const;
<   /**
<    * Enable or disable short PHY preambles.
---
>    * Enable or disable short PLCP preambles.
394c237
<    * \param enable enable or disable short PHY preambles
---
>    * \param enable enable or disable short PLCP preambles
398c241
<    * Return whether the device uses short PHY preambles.
---
>    * Return whether the device uses short PLCP preambles.
400c243
<    * \return true if short PHY preambles are enabled,
---
>    * \return true if short PLCP preambles are enabled,
417,429d259
<   /**
<    * Permit or prohibit RIFS.
<    *
<    * \param allow permit or prohibit RIFS
<    */
<   void SetRifsPermitted (bool allow);
<   /**
<    * Return whether the device can use RIFS.
<    *
<    * \return true if RIFS is permitted,
<    *         false otherwise
<    */
<   bool GetRifsPermitted (void) const;
431,462d260
<   //// WIGIG ////
<   /**
<    * Enable or disable DMG capability support.
<    *
<    * \param enable enable or disable DMG capability support
<    */
<   void SetDmgSupported (bool enable);
<   /**
<    * Return whether the device has DMG capability support enabled.
<    *
<    * \return true if DMG capability support is enabled, false otherwise
<    */
<   bool HasDmgSupported (void) const;
<   /**
<    * Enable or disable EDMG capability support.
<    *
<    * \param enable enable or disable EDMG capability support
<    */
<   void SetEdmgSupported (bool enable);
<   /**
<    * Return whether the device has EDMG capability support enabled.
<    *
<    * \return true if EDMG capability support is enabled, false otherwise
<    */
<   bool HasEdmgSupported (void) const;
<   /**
<    * Return whether the device has DMG or EDMG capability support enabled.
<    *
<    * \return true if either the DMG or the EDMG capability support is enabled, false otherwise.
<    */
<   bool IsWiGigSupported (void) const;
<   //// WIGIG ////
487c285
<   uint8_t GetNBasicModes (void) const;
---
>   uint32_t GetNBasicModes (void) const;
495c293
<   WifiMode GetBasicMode (uint8_t i) const;
---
>   WifiMode GetBasicMode (uint32_t i) const;
509c307
<   WifiMode GetNonErpBasicMode (uint8_t i) const;
---
>   WifiMode GetNonErpBasicMode (uint32_t i) const;
520c318
<    * Return whether the station supports short PHY preamble or not.
---
>    * Return whether the station supports short PLCP preamble or not.
524c322
<    * \return true if short PHY preamble is supported by the station,
---
>    * \return true if short PLCP preamble is supported by the station,
538,546d335
<    * Return whether the given station is QoS capable.
<    *
<    * \param address the address of the station
<    *
<    * \return true if the station has QoS capabilities,
<    *         false otherwise
<    */
<   bool GetQosSupported (Mac48Address address) const;
<   /**
564c353
<   uint8_t GetNBasicMcs (void) const;
---
>   uint32_t GetNBasicMcs (void) const;
570c359
<    * \return the basic MCS at the given list index
---
>    * \return the basic mcs at the given list index
572c361
<   WifiMode GetBasicMcs (uint8_t i) const;
---
>   WifiMode GetBasicMcs (uint32_t i) const;
580,639d368
<   /**
<    * Return the channel width supported by the station.
<    *
<    * \param address the address of the station
<    *
<    * \return the channel width supported by the station
<    */
<   uint16_t GetChannelWidthSupported (Mac48Address address) const;
<   /**
<    * Return whether the station supports HT/VHT short guard interval.
<    *
<    * \param address the address of the station
<    *
<    * \return true if the station supports HT/VHT short guard interval,
<    *         false otherwise
<    */
<   bool GetShortGuardIntervalSupported (Mac48Address address) const;
<   /**
<    * Return the number of spatial streams supported by the station.
<    *
<    * \param address the address of the station
<    *
<    * \return the number of spatial streams supported by the station
<    */
<   uint8_t GetNumberOfSupportedStreams (Mac48Address address) const;
<   /**
<    * Return the number of MCS supported by the station.
<    *
<    * \param address the address of the station
<    *
<    * \return the number of MCS supported by the station
<    */
<   uint8_t GetNMcsSupported (Mac48Address address) const;
<   /**
<    * Return whether the station supports HT or not.
<    *
<    * \param address the address of the station
<    *
<    * \return true if HT is supported by the station,
<    *         false otherwise
<    */
<   bool GetHtSupported (Mac48Address address) const;
<   /**
<    * Return whether the station supports VHT or not.
<    *
<    * \param address the address of the station
<    *
<    * \return true if VHT is supported by the station,
<    *         false otherwise
<    */
<   bool GetVhtSupported (Mac48Address address) const;
<   /**
<    * Return whether the station supports HE or not.
<    *
<    * \param address the address of the station
<    *
<    * \return true if HE is supported by the station,
<    *         false otherwise
<    */
<   bool GetHeSupported (Mac48Address address) const;
648a378,385
>    * Invoked in an AP upon disassociation of a
>    * specific STA.
>    *
>    * \param address the address of the STA
>    */
>   void Reset (Mac48Address address);
> 
>   /**
675,681c412
<    * Invoked in a STA or AP to delete all of the supported MCS by a destination.
<    *
<    * \param address the address of the station being recorded
<    */
<   void RemoveAllSupportedMcs (Mac48Address address);
<   /**
<    * Record whether the short PHY preamble is supported by the station.
---
>    * Record whether the short PLCP preamble is supported by the station.
684c415
<    * \param isShortPreambleSupported whether or not short PHY preamble is supported by the station
---
>    * \param isShortPreambleSupported whether or not short PLCP preamble is supported by the station
686c417
<   void AddSupportedPhyPreamble (Mac48Address address, bool isShortPreambleSupported);
---
>   void AddSupportedPlcpPreamble (Mac48Address address, bool isShortPreambleSupported);
722d452
<   //// WIGIG //// (MODIFIED)
728d457
<    * \param assocaitionID The association identifier that we provide to the station.
730c459
<   void RecordWaitAssocTxOk (Mac48Address address, uint8_t associationID = 0);
---
>   void RecordWaitAssocTxOk (Mac48Address address);
736d464
<    * \return Association identifier assigned to the station.
738,739c466
<   uint8_t RecordGotAssocTxOk (Mac48Address address);
<   //// WIGIG ////
---
>   void RecordGotAssocTxOk (Mac48Address address);
754d480
<   //// WIGIG ////
756,769c482,484
<    * Invoked in a STA or AP to delete all of the suppported MCS by a destination.
<    *
<    * \param address the address of the station being recorded
<    */
<   void RemoveAllSupportedModes (Mac48Address address);
<   /**
<    * Records link's SNR value with a particular station after performing beamforming training.
<    *
<    * \param address The MAC address of the peer station.
<    * \param snr The SNR in dB of the link after performing beamforming training.
<    */
<   void RecordLinkSnr (Mac48Address address, double snr);
<   /**
<    * Return the latest SNR value after performing beamforming training with a the specified station.
---
>    * \param address remote address
>    * \param header MAC header
>    * \param packet the packet to queue
771,772c486,489
<    * \param address The MAC address of the peer station.
<    * \return The SNR in dB of the link after performing beamforming training.
---
>    * This method is typically invoked just before queuing a packet for transmission.
>    * It is a no-op unless the IsLowLatency attribute of the attached ns3::WifiRemoteStationManager
>    * is set to false, in which case, the tx parameters of the packet are calculated and stored in
>    * the packet as a tag. These tx parameters are later retrieved from GetDadaMode and GetRtsMode.
774,775c491,493
<   double GetLinkSnr (Mac48Address address) const;
<   //// WIGIG ////
---
>   void PrepareForQueue (Mac48Address address, const WifiMacHeader *header,
>                         Ptr<const Packet> packet);
> 
776a495
>    * \param address remote address
777a497
>    * \param packet the packet to send
781,782c501,502
<   WifiTxVector GetDataTxVector (const WifiMacHeader &header);
<   //// WIGIG ////
---
>   WifiTxVector GetDataTxVector (Mac48Address address, const WifiMacHeader *header,
>                                 Ptr<const Packet> packet);
788c508,509
<    * \return the transmission mode to use to send this DMG packet
---
>    * \return the TXVECTOR to use to send the RTS prior to the
>    *         transmission of the data packet itself.
790,791c511,512
<   WifiTxVector GetDmgTxVector (Mac48Address address, const WifiMacHeader *header, Ptr<const Packet> packet);
<   //// WIGIG ////
---
>   WifiTxVector GetRtsTxVector (Mac48Address address, const WifiMacHeader *header,
>                                Ptr<const Packet> packet);
793c514,515
<    * \param address remote address
---
>    * \param header MAC header
>    * \param packet the packet to send
795c517
<    * \return the TXVECTOR to use to send the RTS prior to the
---
>    * \return the transmission mode to use to send the CTS-to-self prior to the
798c520,521
<   WifiTxVector GetRtsTxVector (Mac48Address address);
---
>   WifiTxVector GetCtsToSelfTxVector (const WifiMacHeader *header,
>                                      Ptr<const Packet> packet);
801c524
<    * it is implemented in wifi remote station manager
---
>    * it is implemented in wifiremote station manager
806c529
<   WifiTxVector GetCtsToSelfTxVector (void);
---
>   WifiTxVector DoGetCtsToSelfTxVector (void);
822d544
<    * \param packetSize the size of the DATA packet
824,825c546
<   void ReportDataFailed (Mac48Address address, const WifiMacHeader *header,
<                          uint32_t packetSize);
---
>   void ReportDataFailed (Mac48Address address, const WifiMacHeader *header);
827c548
<    * Should be invoked whenever we receive the CTS associated to an RTS
---
>    * Should be invoked whenever we receive the Cts associated to an RTS
840c561
<    * Should be invoked whenever we receive the ACK associated to a data packet
---
>    * Should be invoked whenever we receive the Ack associated to a data packet
848,849d568
<    * \param dataTxVector the TXVECTOR of the DATA we sent
<    * \param packetSize the size of the DATA packet
852,854c571
<                      double ackSnr, WifiMode ackMode,
<                      double dataSnr, WifiTxVector dataTxVector,
<                      uint32_t packetSize);
---
>                      double ackSnr, WifiMode ackMode, double dataSnr);
857c574
<    * NeedRetransmission returns false
---
>    * NeedRtsRetransmission returns false
865c582
<    * NeedRetransmission returns false
---
>    * NeedDataRetransmission returns false
869d585
<    * \param packetSize the size of the DATA packet
871,872c587
<   void ReportFinalDataFailed (Mac48Address address, const WifiMacHeader *header,
<                               uint32_t packetSize);
---
>   void ReportFinalDataFailed (Mac48Address address, const WifiMacHeader *header);
874c589
<    * Typically called per A-MPDU, either when a Block ACK was successfully
---
>    * Typically called per A-MPDU, either when a Block ACK was successfully 
878c593,594
<    * \param nSuccessfulMpdus number of successfully transmitted MPDUs
---
>    * \param tid TID of the DATA packet
>    * \param nSuccessfulMpdus number of successfully transmitted MPDUs.
880c596
<    * \param nFailedMpdus number of unsuccessfully transmitted MPDUs
---
>    * \param nFailedMpdus number of unsuccessfully transmitted MPDUs.
883d598
<    * \param dataTxVector the TXVECTOR of the MPDUs we sent
885,886c600
<   void ReportAmpduTxStatus (Mac48Address address, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                             double rxSnr, double dataSnr, WifiTxVector dataTxVector);
---
>   void ReportAmpduTxStatus (Mac48Address address, uint8_t tid, uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus, double rxSnr, double dataSnr);
891,892c605,606
<    * \param rxSnr the SNR of the packet received
<    * \param txMode the transmission mode used for the packet received
---
>    * \param rxSnr the snr of the packet received
>    * \param txMode the transmission mode used for the packet received.
899a614
>    * \param address remote address
901c616,617
<    * \param size the size of the frame to send in bytes
---
>    * \param packet the packet to send
>    * \param txVector the TXVECTOR of the packet to send
904c620
<    *         frame before sending it, false otherwise.
---
>    *         packet before sending it, false otherwise.
906c622,623
<   bool NeedRts (const WifiMacHeader &header, uint32_t size);
---
>   bool NeedRts (Mac48Address address, const WifiMacHeader *header,
>                 Ptr<const Packet> packet, WifiTxVector txVector);
908c625
<    * Return if we need to do CTS-to-self before sending a DATA.
---
>    * Return if we need to do Cts-to-self before sending a DATA.
912c629
<    * \return true if CTS-to-self is needed,
---
>    * \return true if Cts-to-self is needed,
921a639,648
>    * \return true if we want to restart a failed RTS/CTS handshake,
>    *         false otherwise.
>    */
>   bool NeedRtsRetransmission (Mac48Address address, const WifiMacHeader *header,
>                               Ptr<const Packet> packet);
>   /**
>    * \param address remote address
>    * \param header MAC header
>    * \param packet the packet to send
>    *
925,926c652,653
<   bool NeedRetransmission (Mac48Address address, const WifiMacHeader *header,
<                            Ptr<const Packet> packet);
---
>   bool NeedDataRetransmission (Mac48Address address, const WifiMacHeader *header,
>                                Ptr<const Packet> packet);
968a696,716
>    * \param address remote address
>    * \param rtsMode the transmission mode used to send an RTS we just received
>    *
>    * \return the transmission mode to use for the CTS to complete the RTS/CTS handshake.
>    */
>   WifiTxVector GetCtsTxVector (Mac48Address address, WifiMode rtsMode);
>   /**
>    * \param address
>    * \param dataMode the transmission mode used to send an ACK we just received
>    *
>    * \return the transmission mode to use for the ACK to complete the data/ACK handshake.
>    */
>   WifiTxVector GetAckTxVector (Mac48Address address, WifiMode dataMode);
>   /**
>    * \param address
>    * \param dataMode the transmission mode used to send an ACK we just received
>    *
>    * \return the transmission mode to use for the ACK to complete the data/ACK handshake.
>    */
>   WifiTxVector GetBlockAckTxVector (Mac48Address address, WifiMode dataMode);
>   /**
985,997c733
<    * \return the number of antennas supported by the PHY layer
<    */
<   uint8_t GetNumberOfAntennas (void) const;
<   /**
<    * \return the maximum number of spatial streams supported by the PHY layer
<    */
<   uint8_t GetMaxNumberOfTransmitStreams (void) const;
<   /**
<    * \returns whether HT greenfield should be used for a given destination address.
<    *
<    * \param dest the destination address
<    *
<    * \return whether HT greenfield should be used for a given destination address
---
>    * \return the number of transmit antennas supported by the phy layer
999c735
<   bool UseGreenfieldForDestination (Mac48Address dest) const;
---
>   uint32_t GetNumberOfTransmitAntennas (void);
1004,1005c740
<    * \param [in] oldPower The previous power (in dBm).
<    * \param [in] newPower The new power (in dBm).
---
>    * \param [in] power The new power.
1008c743
<   typedef void (*PowerChangeTracedCallback)(double oldPower, double newPower, Mac48Address remoteAddress);
---
>   typedef void (*PowerChangeTracedCallback)(uint8_t power, Mac48Address remoteAddress);
1013,1014c748
<    * \param [in] oldRate The previous data rate.
<    * \param [in] newRate The new data rate.
---
>    * \param [in] rate The new rate.
1017c751
<   typedef void (*RateChangeTracedCallback)(DataRate oldRate, DataRate newRate, Mac48Address remoteAddress);
---
>   typedef void (*RateChangeTracedCallback)(uint32_t rate, Mac48Address remoteAddress);
1019,1042d752
<   //// WIGIG ////
<   /**
<    * \return the DMG Control transmission mode (MCS0).
<    */
<   WifiTxVector GetDmgControlTxVector (void);
<   /**
<    * \return the DMG Lowest SC transmission mode (MCS1).
<    */
<   WifiTxVector GetDmgLowestScVector (void);
<   /**
<    * Return the number of associated stations.
<    *
<    * \return Number of associated stations.
<    */
<   uint32_t GetNAssociatedStation (void) const;
<   /**
<    * Return the value of the last received SNR.
<    *
<    * \return the value of the last received SNR.
<    */
<   double GetRxSnr (void) const;
<   void RegisterTxOkCallback (Callback<void, Mac48Address> callback);
<   void RegisterRxOkCallback (Callback<void, Mac48Address> callback);
<   //// WIGIG ////
1055c765
<   WifiMode GetSupported (const WifiRemoteStation *station, uint8_t i) const;
---
>   WifiMode GetSupported (const WifiRemoteStation *station, uint32_t i) const;
1063,1072c773
<   uint8_t GetNSupported (const WifiRemoteStation *station) const;
<   /**
<    * Return whether the given station is QoS capable.
<    *
<    * \param station the station being queried
<    *
<    * \return true if the station has QoS capabilities,
<    *         false otherwise
<    */
<   bool GetQosSupported (const WifiRemoteStation *station) const;
---
>   uint32_t GetNSupported (const WifiRemoteStation *station) const;
1092,1100d792
<    * Return whether the given station is HE capable.
<    *
<    * \param station the station being queried
<    *
<    * \return true if the station has HE capabilities,
<    *         false otherwise
<    */
<   bool GetHeSupported (const WifiRemoteStation *station) const;
<   /**
1109c801
<   WifiMode GetMcsSupported (const WifiRemoteStation *station, uint8_t i) const;
---
>   WifiMode GetMcsSupported (const WifiRemoteStation *station, uint32_t i) const;
1117c809
<   uint8_t GetNMcsSupported (const WifiRemoteStation *station) const;
---
>   uint32_t GetNMcsSupported (const WifiRemoteStation *station) const;
1126c818
<   WifiMode GetNonErpSupported (const WifiRemoteStation *station, uint8_t i) const;
---
>   WifiMode GetNonErpSupported (const WifiRemoteStation *station, uint32_t i) const;
1136,1143d827
<    * Return the address of the station.
<    *
<    * \param station the station being queried
<    *
<    * \return the address of the station
<    */
<   Mac48Address GetAddress (const WifiRemoteStation *station) const;
<   /**
1150c834
<   uint16_t GetChannelWidth (const WifiRemoteStation *station) const;
---
>   uint32_t GetChannelWidth (const WifiRemoteStation *station) const;
1152c836
<    * Return whether the given station supports HT/VHT short guard interval.
---
>    * Return whether the given station supports short guard interval.
1156c840
<    * \return true if the station supports HT/VHT short guard interval,
---
>    * \return true if the station supports short guard interval,
1159c843
<   bool GetShortGuardIntervalSupported (const WifiRemoteStation *station) const;
---
>   bool GetShortGuardInterval (const WifiRemoteStation *station) const;
1161c845
<    * Return the HE guard interval duration supported by the station.
---
>    * Return whether the given station supports A-MPDU.
1165c849,850
<    * \return the HE guard interval duration (in nanoseconds) supported by the station
---
>    * \return true if the station supports MPDU aggregation,
>    *         false otherwise
1167c852
<   uint16_t GetGuardInterval (const WifiRemoteStation *station) const;
---
>   bool GetAggregation (const WifiRemoteStation *station) const;
1169c854
<    * Return whether the given station supports A-MPDU.
---
>    * Return whether the given station supports space-time block coding (STBC).
1173c858
<    * \return true if the station supports MPDU aggregation,
---
>    * \return true if the station supports STBC,
1176c861
<   bool GetAggregation (const WifiRemoteStation *station) const;
---
>   bool GetStbc (const WifiRemoteStation *station) const;
1188c873
<    * Return the number of supported streams the station has.
---
>    * Return the number of receive antennas the station has.
1192c877
<    * \return the number of supported streams the station has
---
>    * \return the number of receive antennas the station has
1194c879
<   uint8_t GetNumberOfSupportedStreams (const WifiRemoteStation *station) const;
---
>   uint8_t GetNumberOfSupportedRxAntennas (const WifiRemoteStation *station) const;
1202c887,903
<   uint8_t GetNess (const WifiRemoteStation *station) const;
---
>   uint32_t GetNess (const WifiRemoteStation *station) const;
>   /**
>    * Return the long retry limit of the given station.
>    *
>    * \param station the station being queried
>    *
>    * \return the long retry limit of the the station
>    */
>   uint32_t GetLongRetryCount (const WifiRemoteStation *station) const;
>   /**
>    * Return the short retry limit of the given station.
>    *
>    * \param station the station being queried
>    *
>    * \return the short retry limit of the the station
>    */
>   uint32_t GetShortRetryCount (const WifiRemoteStation *station) const;
1207c908
<    * \return a pointer to the WifiPhy
---
>    * \return WifiPhy
1213c914
<    * \return a pointer to the WifiMac
---
>    * \return WifiMac
1221,1223c922,924
<    * \param size the size of the frame to send in bytes
<    * \param normally indicates whether the normal 802.11 RTS enable mechanism would
<    *        request that the RTS is sent or not.
---
>    * \param packet the packet to send
>    * \param normally indicates whether the normal 802.11 rts enable mechanism would
>    *        request that the rts is sent or not.
1225c926
<    * \return true if we want to use an RTS/CTS handshake for this frame before sending it,
---
>    * \return true if we want to use an RTS/CTS handshake for this packet before sending it,
1231c932,946
<                           uint32_t size, bool normally);
---
>                           Ptr<const Packet> packet, bool normally);
>   /**
>    * \param station the station that we need to communicate
>    * \param packet the packet to send
>    * \param normally indicates whether the normal 802.11 rts enable mechanism would
>    *        request that the rts is retransmitted or not.
>    *
>    * \return true if we want to restart a failed RTS/CTS handshake,
>    *         false otherwise.
>    *
>    * Note: This method is called after an rts/cts handshake has been attempted
>    *       and has failed.
>    */
>   virtual bool DoNeedRtsRetransmission (WifiRemoteStation *station,
>                                         Ptr<const Packet> packet, bool normally);
1240,1241c955,956
<    * Note: This method is called after any unicast packet transmission (control, management,
<    *       or data) has been attempted and has failed.
---
>    * Note: This method is called after a unicast packet transmission has been attempted
>    *       and has failed.
1243,1244c958,959
<   virtual bool DoNeedRetransmission (WifiRemoteStation *station,
<                                      Ptr<const Packet> packet, bool normally);
---
>   virtual bool DoNeedDataRetransmission (WifiRemoteStation *station,
>                                          Ptr<const Packet> packet, bool normally);
1258a974,980
>    * \return whether this manager is a manager designed to work in low-latency environments.
>    *
>    * Note: In this context, low vs high latency is defined in <i>IEEE 802.11 Rate Adaptation:
>    * A Practical Approach</i>, by M. Lacage, M.H. Manshaei, and T. Turletti.
>    */
>   virtual bool IsLowLatency (void) const = 0;
>   /**
1274c996
<    * \return the transmission mode to use to send an RTS to the station
---
>    * \return the transmission mode to use to send an rts to the station
1276,1277c998,999
<    * Note: This method is called before sending an RTS to a station
<    *       to decide which transmission mode to use for the RTS.
---
>    * Note: This method is called before sending an rts to a station
>    *       to decide which transmission mode to use for the rts.
1279a1002,1038
>   /**
>    * \param address the address of the recipient of the CTS
>    * \param ctsMode the mode to be used for the CTS
>    *
>    * \return the power level to be used to send the CTS
>    */
>   virtual uint8_t DoGetCtsTxPowerLevel (Mac48Address address, WifiMode ctsMode);
>   /**
>    * \param address the address of the recipient of the ACK
>    * \param ackMode the mode to be used for the ACK
>    *
>    * \return the power level to be used to send the ACK
>    */
>   virtual uint8_t DoGetAckTxPowerLevel (Mac48Address address, WifiMode ackMode);
>   /**
>    * \param address the address of the recipient of the Block ACK
>    * \param blockAckMode the mode to be used for the Block ACK
>    *
>    * \return the power level to be used to send the Block ACK
>    */
>   virtual uint8_t DoGetBlockAckTxPowerLevel (Mac48Address address, WifiMode blockAckMode);
> 
>   virtual uint32_t DoGetCtsTxChannelWidth (Mac48Address address, WifiMode ctsMode);
>   virtual bool DoGetCtsTxGuardInterval (Mac48Address address, WifiMode ctsMode);
>   virtual uint8_t DoGetCtsTxNss (Mac48Address address, WifiMode ctsMode);
>   virtual uint8_t DoGetCtsTxNess (Mac48Address address, WifiMode ctsMode);
>   virtual bool  DoGetCtsTxStbc (Mac48Address address, WifiMode ctsMode);
>   virtual uint32_t DoGetAckTxChannelWidth (Mac48Address address, WifiMode ctsMode);
>   virtual bool DoGetAckTxGuardInterval (Mac48Address address, WifiMode ackMode);
>   virtual uint8_t DoGetAckTxNss (Mac48Address address, WifiMode ackMode);
>   virtual uint8_t DoGetAckTxNess (Mac48Address address, WifiMode ackMode);
>   virtual bool DoGetAckTxStbc (Mac48Address address, WifiMode ackMode);
>   virtual uint32_t DoGetBlockAckTxChannelWidth (Mac48Address address, WifiMode ctsMode);
>   virtual bool DoGetBlockAckTxGuardInterval (Mac48Address address, WifiMode blockAckMode);
>   virtual uint8_t DoGetBlockAckTxNss (Mac48Address address, WifiMode blockAckMode);
>   virtual uint8_t DoGetBlockAckTxNess (Mac48Address address, WifiMode blockAckMode);
>   virtual bool DoGetBlockAckTxStbc (Mac48Address address, WifiMode blockAckMode);
1314,1315d1072
<    * \param dataChannelWidth the channel width (in MHz) of the DATA we sent
<    * \param dataNss the number of spatial streams used to send the DATA
1317,1318c1074,1075
<   virtual void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                                double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss) = 0;
---
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr) = 0;
1355,1356d1111
<    * \param dataChannelWidth the channel width (in MHz) of the A-MPDU we sent
<    * \param dataNss the number of spatial streams used to send the A-MPDU
1358,1359c1113
<   virtual void DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                                       double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   virtual void DoReportAmpduTxStatus (WifiRemoteStation *station, uint32_t nSuccessfulMpdus, uint32_t nFailedMpdus, double rxSnr, double dataSnr);
1369c1123,1134
<    * Return the station associated with the given address.
---
>    * Return the station associated with the given address and TID.
>    *
>    * \param address the address of the station
>    * \param tid the TID
>    *
>    * \return WifiRemoteStation corresponding to the address
>    */
>   WifiRemoteStation* Lookup (Mac48Address address, uint8_t tid) const;
>   /// Find a remote station by its remote address and TID taken from MAC header
>   /**
>    * Return the station associated with the given address and MAC header.
>    * It simply gets TID from the MAC header and calls Lookup with tid.
1371a1137
>    * \param header MAC header
1375c1141,1155
<   WifiRemoteStation* Lookup (Mac48Address address) const;
---
>   WifiRemoteStation* Lookup (Mac48Address address, const WifiMacHeader *header) const;
> 
>   /**
>    * Return whether the modulation class of the selected mode for the 
>    * control answer frame is allowed.
>    *
>    * \param modClassReq modulation class of the request frame
>    * \param modClassAnswer modulation class of the answer frame
>    *
>    * \return true if the modulation class of the selected mode for the 
>    * control answer frame is allowed, false otherwise
>    */
>   bool IsAllowedControlAnswerModulationClass (enum WifiModulationClass modClassReq, enum WifiModulationClass modClassAnswer) const;
> 
>   WifiMode GetControlAnswerMode (Mac48Address address, WifiMode reqMode);
1400a1181,1189
>    * A vector of WifiRemoteStations
>    */
>   typedef std::vector <WifiRemoteStation *> Stations;
>   /**
>    * A vector of WifiRemoteStationStates
>    */
>   typedef std::vector <WifiRemoteStationState *> StationStates;
> 
>   /**
1426,1427c1215,1216
<   WifiModeList m_bssBasicRateSet; //!< basic rate set
<   WifiModeList m_bssBasicMcsSet;  //!< basic MCS set
---
>   WifiModeList m_bssBasicRateSet;
>   WifiModeList m_bssBasicMcsSet;
1433c1222
<   WifiMode m_defaultTxMcs;  //!< The default transmission modulation-coding scheme (MCS)
---
>   WifiMode m_defaultTxMcs;   //!< The default transmission modulation-coding scheme (MCS)
1435,1440c1224,1225
<   bool m_pcfSupported; //!< Flag if PCF capability is supported
<   //// WIGIG ////
<   bool m_dmgSupported; //!< Flag if DMG capability is supported
<   bool m_edmgSupported;//!< Flag if EDMG capability is supported
<   double m_rxSnr;      //!< The value of the last received SNR.
<   //// WIGIG ////
---
>   bool m_htSupported;  //!< Flag if HT capability is supported
>   bool m_vhtSupported; //!< Flag if VHT capability is supported
1443,1444c1228,1229
<   uint32_t m_rtsCtsThreshold;             //!< Threshold for RTS/CTS
<   uint32_t m_fragmentationThreshold;      //!< Current threshold for fragmentation
---
>   uint32_t m_rtsCtsThreshold;  //!< Threshold for RTS/CTS
>   uint32_t m_fragmentationThreshold;  //!< Current threshold for fragmentation
1446,1458c1231,1236
<   uint8_t m_defaultTxPowerLevel;          //!< Default transmission power level
<   WifiMode m_nonUnicastMode;      //!< Transmission mode for non-unicast Data frames
<   bool m_useNonErpProtection;     //!< flag if protection for non-ERP stations against ERP transmissions is enabled
<   bool m_useNonHtProtection;      //!< flag if protection for non-HT stations against HT transmissions is enabled
<   bool m_useGreenfieldProtection; //!< flag if protection for stations that do not support HT Greenfield format is enabled
<   bool m_shortPreambleEnabled;    //!< flag if short PHY preamble is enabled
<   bool m_shortSlotTimeEnabled;    //!< flag if short slot time is enabled
<   bool m_rifsPermitted;           //!< flag if RIFS is enabled
<   ProtectionMode m_erpProtectionMode; //!< Protection mode for ERP stations when non-ERP stations are detected
<   ProtectionMode m_htProtectionMode;  //!< Protection mode for HT stations when non-HT stations are detected
< 
<   std::array<uint32_t, AC_BE_NQOS> m_ssrc; //!< short retry count per AC
<   std::array<uint32_t, AC_BE_NQOS> m_slrc; //!< long retry count per AC
---
>   uint8_t m_defaultTxPowerLevel;  //!< Default tranmission power level
>   WifiMode m_nonUnicastMode;  //!< Transmission mode for non-unicast DATA frames
>   bool m_useNonErpProtection; //!< flag if protection for non-ERP stations against ERP transmissions is enabled
>   bool m_shortPreambleEnabled; //!< flag if short PLCP preamble is enabled
>   bool m_shortSlotTimeEnabled; //!< flag if short slot time is enabled
>   ProtectionMode m_protectionMode; //!< Protection mode for ERP stations when non-ERP stations are detected
1478c1256,1262
<   //// WIGIG ////
---
> };
> 
> /**
>  * A struct that holds information about each remote station.
>  */
> struct WifiRemoteStationState
> {
1480c1264
<    * The trace source fired when the transmission of a single MPDU has successed.
---
>    * State of the station
1482,1485c1266,1273
<   TracedCallback<Mac48Address> m_macTxOk;
<   Callback<void, Mac48Address> m_txCallbackOk;
<   Callback<void, Mac48Address> m_rxCallbackOk;
<   TracedCallback<WifiMacType, Mac48Address, double> m_macRxOk;   /* Trace for Successful WifiMAC Reception */
---
>   enum
>   {
>     BRAND_NEW,
>     DISASSOC,
>     WAIT_ASSOC_TX_OK,
>     GOT_ASSOC_TX_OK
>   } m_state;
> 
1487,1491c1275,1281
<    * TracedCallback signature for MAC Rx OK.
<    *
<    * \param type The type of the WifiMAC Header.
<    * \param address The MAC address of the station.
<    * \param snr The snr value in linear scale.
---
>    * This member is the list of WifiMode objects that comprise the
>    * OperationalRateSet parameter for this remote station. This list
>    * is constructed through calls to
>    * WifiRemoteStationManager::AddSupportedMode(), and an API that
>    * allows external access to it is available through
>    * WifiRemoteStationManager::GetNSupported() and
>    * WifiRemoteStationManager::GetSupported().
1493,1494c1283,1318
<   typedef void (* MacRxOkCallback)(WifiMacType type, Mac48Address address, double snr);
<   //// WIGIG ////
---
>   WifiModeList m_operationalRateSet;
>   WifiModeList m_operationalMcsSet;
>   Mac48Address m_address;  //!< Mac48Address of the remote station
>   WifiRemoteStationInfo m_info;
> 
>   uint32_t m_channelWidth;    //!< Channel width (in MHz) supported by the remote station
>   bool m_shortGuardInterval;  //!< Flag if short guard interval is supported by the remote station
>   uint8_t m_rx;               //!< Number of supported RX streams by the remote station
>   uint32_t m_ness;            //!< Number of streams in beamforming of the remote station
>   bool m_stbc;                //!< Flag if STBC is supported by the remote station
>   bool m_aggregation;         //!< Flag if MPDU aggregation is used by the remote station
>   bool m_greenfield;          //!< Flag if greenfield is supported by the remote station
>   bool m_shortPreamble;       //!< Flag if short PLCP preamble is supported by the remote station
>   bool m_shortSlotTime;       //!< Flag if short ERP slot time is supported by the remote station
>   bool m_htSupported;         //!< Flag if HT is supported by the station
>   bool m_vhtSupported;        //!< Flag if VHT is supported by the station
> };
> 
> /**
>  * \brief hold per-remote-station state.
>  *
>  * The state in this class is used to keep track
>  * of association status if we are in an infrastructure
>  * network and to perform the selection of tx parameters
>  * on a per-packet basis.
>  *
>  * This class is typically subclassed and extended by
>  * rate control implementations
>  */
> struct WifiRemoteStation
> {
>   virtual ~WifiRemoteStation ();
>   WifiRemoteStationState *m_state;  //!< Remote station state
>   uint32_t m_ssrc;                  //!< STA short retry count
>   uint32_t m_slrc;                  //!< STA long retry count
>   uint8_t m_tid;                    //!< traffic ID
diff ../../NS3-WiGig/src/wifi/model/wifi-spectrum-phy-interface.cc ../../ns-3-dev/src/wifi/model/wifi-spectrum-phy-interface.cc
21,24c21,31
< #include "ns3/log.h"
< #include "ns3/spectrum-value.h"
< #include "ns3/mobility-model.h"
< #include "ns3/net-device.h"
---
> #include <ns3/ptr.h>
> #include <ns3/object.h>
> #include <ns3/net-device.h>
> #include <ns3/mobility-model.h>
> #include <ns3/wifi-phy.h>
> #include <ns3/spectrum-phy.h>
> #include <ns3/spectrum-signal-parameters.h>
> #include <ns3/log.h>
> #include <ns3/spectrum-value.h>
> #include <ns3/antenna-model.h>
> 
57c64
< void WifiSpectrumPhyInterface::SetSpectrumWifiPhy (const Ptr<SpectrumWifiPhy> spectrumWifiPhy)
---
> void WifiSpectrumPhyInterface::SetSpectrumWifiPhy (Ptr<SpectrumWifiPhy> spectrumWifiPhy)
75c82
< WifiSpectrumPhyInterface::SetDevice (const Ptr<NetDevice> d)
---
> WifiSpectrumPhyInterface::SetDevice (Ptr<NetDevice> d)
81c88
< WifiSpectrumPhyInterface::SetMobility (const Ptr<MobilityModel> m)
---
> WifiSpectrumPhyInterface::SetMobility (Ptr<MobilityModel> m)
87c94
< WifiSpectrumPhyInterface::SetChannel (const Ptr<SpectrumChannel> c)
---
> WifiSpectrumPhyInterface::SetChannel (Ptr<SpectrumChannel> c)
110a118
> 
diff ../../NS3-WiGig/src/wifi/model/wifi-spectrum-phy-interface.h ../../ns-3-dev/src/wifi/model/wifi-spectrum-phy-interface.h
20d19
< 
24c23,25
< #include "ns3/spectrum-phy.h"
---
> #include <ns3/ptr.h>
> #include <ns3/object.h>
> #include <ns3/spectrum-phy.h>
44,47d44
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
54c51
<   void SetSpectrumWifiPhy (const Ptr<SpectrumWifiPhy> phy);
---
>   void SetSpectrumWifiPhy (Ptr<SpectrumWifiPhy> phy);
57,65c54,61
<   Ptr<NetDevice> GetDevice () const;
<   void SetDevice (const Ptr<NetDevice> d);
<   void SetMobility (const Ptr<MobilityModel> m);
<   Ptr<MobilityModel> GetMobility ();
<   void SetChannel (const Ptr<SpectrumChannel> c);
<   Ptr<const SpectrumModel> GetRxSpectrumModel () const;
<   Ptr<AntennaModel> GetRxAntenna ();
<   void StartRx (Ptr<SpectrumSignalParameters> params);
< 
---
>   virtual Ptr<NetDevice> GetDevice () const;
>   virtual void SetDevice (Ptr<NetDevice> d);
>   virtual void SetMobility (Ptr<MobilityModel> m);
>   virtual Ptr<MobilityModel> GetMobility ();
>   virtual void SetChannel (Ptr<SpectrumChannel> c);
>   virtual Ptr<const SpectrumModel> GetRxSpectrumModel () const;
>   virtual Ptr<AntennaModel> GetRxAntenna ();
>   virtual void StartRx (Ptr<SpectrumSignalParameters> params);
69,71c65,67
<   Ptr<SpectrumWifiPhy> m_spectrumWifiPhy; ///< spectrum PHY
<   Ptr<NetDevice> m_netDevice; ///< the device
<   Ptr<SpectrumChannel> m_channel; ///< spectrum channel
---
>   Ptr<SpectrumWifiPhy> m_spectrumWifiPhy;
>   Ptr<NetDevice> m_netDevice;
>   Ptr<SpectrumChannel> m_channel;
diff ../../NS3-WiGig/src/wifi/model/wifi-spectrum-signal-parameters.cc ../../ns-3-dev/src/wifi/model/wifi-spectrum-signal-parameters.cc
22,23c22,24
< #include "ns3/log.h"
< #include "wifi-ppdu.h"
---
> #include <ns3/log.h>
> #include <ns3/packet.h>
> #include <ns3/ptr.h>
39c40
<   ppdu = p.ppdu;
---
>   packet = p.packet;
diff ../../NS3-WiGig/src/wifi/model/wifi-spectrum-signal-parameters.h ../../ns-3-dev/src/wifi/model/wifi-spectrum-signal-parameters.h
25c25
< #include "ns3/spectrum-signal-parameters.h"
---
> #include <ns3/spectrum-signal-parameters.h>
29c29
< class WifiPpdu;
---
> class Packet;
49,50d48
<    *
<    * \param p the wifi spectrum signal parameters
54c52,55
<   Ptr<WifiPpdu> ppdu; ///< The PPDU being transmitted
---
>   /**
>    * The packet being transmitted with this signal
>    */
>   Ptr<Packet> packet;
diff ../../NS3-WiGig/src/wifi/model/wifi-tx-current-model.cc ../../ns-3-dev/src/wifi/model/wifi-tx-current-model.cc
20a21
> #include "wifi-tx-current-model.h"
21a23
> #include "ns3/boolean.h"
23,24c25,27
< #include "wifi-tx-current-model.h"
< #include "wifi-utils.h"
---
> #include "ns3/string.h"
> #include "ns3/pointer.h"
> #include <cmath>
29a33,34
> // ------------------------------------------------------------------------- //
> 
49a55,63
> double
> WifiTxCurrentModel::DbmToW (double dbm)
> {
>   double mW = std::pow (10.0, dbm / 10.0);
>   return mW / 1000.0;
> }
> 
> // ------------------------------------------------------------------------- //
> 
61c75,76
<                    MakeDoubleAccessor (&LinearWifiTxCurrentModel::m_eta),
---
>                    MakeDoubleAccessor (&LinearWifiTxCurrentModel::SetEta,
>                                        &LinearWifiTxCurrentModel::GetEta),
65c80,81
<                    MakeDoubleAccessor (&LinearWifiTxCurrentModel::m_voltage),
---
>                    MakeDoubleAccessor (&LinearWifiTxCurrentModel::SetVoltage,
>                                        &LinearWifiTxCurrentModel::GetVoltage),
67c83
<     .AddAttribute ("IdleCurrent", "The current in the IDLE state (in Ampere).",
---
>     .AddAttribute ("IdleCurrent", "The current in the IDLE state (in Watts).",
69c85,86
<                    MakeDoubleAccessor (&LinearWifiTxCurrentModel::m_idleCurrent),
---
>                    MakeDoubleAccessor (&LinearWifiTxCurrentModel::SetIdleCurrent,
>                                        &LinearWifiTxCurrentModel::GetIdleCurrent),
77d93
<   NS_LOG_FUNCTION (this);
82c98,133
<   NS_LOG_FUNCTION (this);
---
> }
> 
> void
> LinearWifiTxCurrentModel::SetEta (double eta)
> {
>   m_eta = eta;
> }
> 
> void
> LinearWifiTxCurrentModel::SetVoltage (double voltage)
> {
>   m_voltage = voltage;
> }
> 
> void
> LinearWifiTxCurrentModel::SetIdleCurrent (double idleCurrent)
> {
>   m_idleCurrent = idleCurrent;
> }
> 
> double
> LinearWifiTxCurrentModel::GetEta (void) const
> {
>   return m_eta;
> }
> 
> double
> LinearWifiTxCurrentModel::GetVoltage (void) const
> {
>   return m_voltage;
> }
> 
> double
> LinearWifiTxCurrentModel::GetIdleCurrent (void) const
> {
>   return m_idleCurrent;
88d138
<   NS_LOG_FUNCTION (this << txPowerDbm);
90a141,142
> 
> // ------------------------------------------------------------------------- //
diff ../../NS3-WiGig/src/wifi/model/wifi-tx-current-model.h ../../ns-3-dev/src/wifi/model/wifi-tx-current-model.h
6c6
<  * it under the terms of the GNU General Public License version 2 as
---
>  * it under the terms of the GNU General Public License version 2 as 
30,31c30,31
<  *
<  * \brief Model the transmit current as a function of the transmit power and mode
---
>  * 
>  * \brief Modelize the transmit current as a function of the transmit power and mode
37,40d36
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
47c43
<    * \param txPowerDbm the nominal TX power in dBm
---
>    * \param txPowerDbm the nominal tx power in dBm
50a47,54
> 
>   /**
>    * Convert from dBm to Watts.
>    *
>    * \param dbm the power in dBm
>    * \return the equivalent Watts for the given dBm
>    */
>   static double DbmToW (double dbm);
64,65c68,69
<  *
<  * The efficiency \f$ \eta \f$ of the power amplifier is given by
---
>  * 
>  * The efficiency \f$ \eta \f$ of the power amplifier is given by 
68c72
<  *
---
>  * 
73c77
<  *
---
>  * 
78,79c82,83
<  *
<  * If the TX current corresponding to a given nominal transmit power is known, the efficiency
---
>  * 
>  * If the tx current corresponding to a given nominal transmit power is known, the efficiency
82c86
<  *
---
>  * 
87,90d90
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
94a95,101
>   
>   /**
>    * \param eta (dimension-less)
>    *
>    * Set the power amplifier efficiency.
>    */
>   void SetEta (double eta);
96c103,120
<   double CalcTxCurrent (double txPowerDbm) const;
---
>   /**
>    * \param voltage (Volts)
>    *
>    * Set the supply voltage.
>    */
>   void SetVoltage (double voltage);
> 
>   /**
>    * \param idleCurrent (Ampere)
>    *
>    * Set the current in the IDLE state.
>    */
>   void SetIdleCurrent (double idleCurrent);
> 
>   /**
>    * \return the power amplifier efficiency.
>    */
>   double GetEta (void) const;
97a122,132
>   /**
>    * \return the supply voltage.
>    */
>   double GetVoltage (void) const;
> 
>   /**
>    * \return the current in the IDLE state.
>    */
>   double GetIdleCurrent (void) const;
> 
>   double CalcTxCurrent (double txPowerDbm) const;
100,102c135,137
<   double m_eta; ///< ETA
<   double m_voltage; ///< voltage in Volts
<   double m_idleCurrent; ///< idle current in Amperes
---
>   double m_eta;
>   double m_voltage;
>   double m_idleCurrent;
diff ../../NS3-WiGig/src/wifi/model/wifi-tx-vector.cc ../../ns-3-dev/src/wifi/model/wifi-tx-vector.cc
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
21d19
<  *          Hany Assasa <hany.assasa@gmail.com>
24c22,23
< #include "wifi-tx-vector.h"
---
> #include "ns3/wifi-tx-vector.h"
> #include "ns3/fatal-error.h"
29c28
<   : m_preamble (WIFI_PREAMBLE_LONG),
---
>   : m_retries (0),
31,32c30
<     m_guardInterval (800),
<     m_nTx (1),
---
>     m_shortGuardInterval (false),
37,38c35,36
<     m_bssColor (0),
<     m_modeInitialized (false)
---
>     m_modeInitialized (false),
>     m_txPowerLevelInitialized (false)
40d37
<   DoInitialize ();
43,47c40,42
< WifiTxVector::WifiTxVector (WifiMode mode,
<                             uint8_t powerLevel,
<                             WifiPreamble preamble,
<                             uint16_t channelWidth,
<                             bool aggregation)
---
> WifiTxVector::WifiTxVector (WifiMode mode, uint8_t powerLevel, uint8_t retries,
>                             bool shortGuardInterval, uint8_t nss, uint8_t ness,
>                             uint32_t channelWidth, bool aggregation, bool stbc)
50c45
<     m_preamble (preamble),
---
>     m_retries (retries),
52,80c47
<     m_guardInterval (800),
<     m_nTx (1),
<     m_nss (1),
<     m_ness (0),
<     m_aggregation (aggregation),
<     m_stbc (false),
<     m_bssColor (0),
<     m_modeInitialized (true)
< {
<   DoInitialize ();
< }
< 
< WifiTxVector::WifiTxVector (WifiMode mode,
<                             uint8_t powerLevel,
<                             WifiPreamble preamble,
<                             uint16_t guardInterval,
<                             uint8_t nTx,
<                             uint8_t nss,
<                             uint8_t ness,
<                             uint16_t channelWidth,
<                             bool aggregation,
<                             bool stbc,
<                             uint8_t bssColor)
<   : m_mode (mode),
<     m_txPowerLevel (powerLevel),
<     m_preamble (preamble),
<     m_channelWidth (channelWidth),
<     m_guardInterval (guardInterval),
<     m_nTx (nTx),
---
>     m_shortGuardInterval (shortGuardInterval),
85,113c52,53
<     m_bssColor (bssColor),
<     m_modeInitialized (true)
< {
<   DoInitialize ();
< }
< 
< void
< WifiTxVector::DoInitialize (void)
< {
<   m_traingFieldLength = 0;
<   m_beamTrackingRequest = false;
<   m_lastRssi = 0;
<   m_numSts = 1;
<   m_numUsers = 1;
<   m_guardIntervalType = GI_NORMAL;
<   m_chBandwidth = 1;    // This corresponds to EDMG Channel 2 with 2.16 GHz bandwidth.
<   m_NCB = 1;
<   m_chAggregation = false;
<   m_nTxChains = 1;
<   m_shortLongLDCP = false;
<   m_edmgTrnLength = 0;
<   m_TrnSeqLen = TRN_SEQ_LENGTH_NORMAL;
<   m_isDMGBeacon = false;
<   m_trnRxPattern = QUASI_OMNI;
<   m_isControlTrailerPresent = false;
< }
< 
< bool
< WifiTxVector::GetModeInitialized (void) const
---
>     m_modeInitialized (true),
>     m_txPowerLevelInitialized (true)
115d54
<   return m_modeInitialized;
130a70,73
>   if (!m_txPowerLevelInitialized)
>     {
>       NS_FATAL_ERROR ("WifiTxVector txPowerLevel must be set before using");
>     }
134,135c77,78
< WifiPreamble
< WifiTxVector::GetPreambleType (void) const
---
> uint8_t
> WifiTxVector::GetRetries (void) const
137c80
<   return m_preamble;
---
>   return m_retries;
140c83
< uint16_t
---
> uint32_t
146,153c89,90
< uint16_t
< WifiTxVector::GetGuardInterval (void) const
< {
<   return m_guardInterval;
< }
< 
< uint8_t
< WifiTxVector::GetNTx (void) const
---
> bool
> WifiTxVector::IsShortGuardInterval (void) const
155c92
<   return m_nTx;
---
>   return m_shortGuardInterval;
192a130
>   m_txPowerLevelInitialized = true;
196c134
< WifiTxVector::SetPreambleType (WifiPreamble preamble)
---
> WifiTxVector::SetRetries (uint8_t retries)
198c136
<   m_preamble = preamble;
---
>   m_retries = retries;
202c140
< WifiTxVector::SetChannelWidth (uint16_t channelWidth)
---
> WifiTxVector::SetChannelWidth (uint32_t channelWidth)
208c146
< WifiTxVector::SetGuardInterval (uint16_t guardInterval)
---
> WifiTxVector::SetShortGuardInterval (bool guardinterval)
210,216c148
<   m_guardInterval = guardInterval;
< }
< 
< void
< WifiTxVector::SetNTx (uint8_t nTx)
< {
<   m_nTx = nTx;
---
>   m_shortGuardInterval = guardinterval;
243,290d174
< void
< WifiTxVector::SetBssColor (uint8_t color)
< {
<   m_bssColor = color;
< }
< 
< uint8_t
< WifiTxVector::GetBssColor (void) const
< {
<   return m_bssColor;
< }
< 
< bool
< WifiTxVector::IsValid (void) const
< {
<   if (!GetModeInitialized ())
<     {
<       return false;
<     }
<   std::string modeName = m_mode.GetUniqueName ();
<   if (m_channelWidth == 20)
<     {
<       if (m_nss != 3 && m_nss != 6)
<         {
<           return (modeName != "VhtMcs9");
<         }
<     }
<   else if (m_channelWidth == 80)
<     {
<       if (m_nss == 3 || m_nss == 7)
<         {
<           return (modeName != "VhtMcs6");
<         }
<       else if (m_nss == 6)
<         {
<           return (modeName != "VhtMcs9");
<         }
<     }
<   else if (m_channelWidth == 160)
<     {
<       if (m_nss == 3)
<         {
<           return (modeName != "VhtMcs9");
<         }
<     }
<   return true;
< }
< 
294,295c178,179
<     " txpwrlvl: " << +v.GetTxPowerLevel () <<
<     " preamble: " << v.GetPreambleType () <<
---
>     " txpwrlvl: " << (uint32_t)v.GetTxPowerLevel () <<
>     " retries: " << (uint32_t)v.GetRetries () <<
297,300c181,183
<     " GI: " << v.GetGuardInterval () <<
<     " NTx: " << +v.GetNTx () <<
<     " Nss: " << +v.GetNss () <<
<     " Ness: " << +v.GetNess () <<
---
>     " Short GI: " << v.IsShortGuardInterval () <<
>     " Nss: " << (uint32_t)v.GetNss () <<
>     " Ness: " << (uint32_t)v.GetNess () <<
305,663d187
< 
< //// WIGIG ////
< 
< void
< WifiTxVector::SetPacketType (PacketType type)
< {
<   m_packetType = type;
< }
< 
< PacketType
< WifiTxVector::GetPacketType (void) const
< {
<   return m_packetType;
< }
< 
< void
< WifiTxVector::SetTrainngFieldLength (uint8_t length)
< {
<   m_traingFieldLength = length;
< }
< 
< uint8_t
< WifiTxVector::GetTrainngFieldLength (void) const
< {
<   return m_traingFieldLength;
< }
< 
< void
< WifiTxVector::SetEDMGTrainingFieldLength (uint8_t length)
< {
<   m_edmgTrnLength = length;
< }
< 
< uint8_t
< WifiTxVector::GetEDMGTrainingFieldLength (void) const
< {
<   return m_edmgTrnLength;
< }
< 
< void
< WifiTxVector::RequestBeamTracking (void)
< {
<   m_beamTrackingRequest = true;
< }
< 
< bool
< WifiTxVector::IsBeamTrackingRequested (void) const
< {
<   return m_beamTrackingRequest;
< }
< 
< void
< WifiTxVector::SetLastRssi (uint8_t level)
< {
<   m_lastRssi = level;
< }
< 
< uint8_t
< WifiTxVector::GetLastRssi (void) const
< {
<   return m_lastRssi;
< }
< 
< void
< WifiTxVector::Set_NUM_STS (uint8_t num)
< {
<   NS_ASSERT (num > 0 && num <= 8);
<   m_numSts = num;
< }
< 
< uint8_t
< WifiTxVector::Get_NUM_STS (void) const
< {
<   return m_numSts;
< }
< 
< uint8_t
< WifiTxVector::Get_SC_EDMG_CEF (void) const
< {
<   if ((m_numSts == 1) || (m_numSts == 2))
<     {
<       return 1;
<     }
<   else if ((m_numSts == 3) || (m_numSts == 4))
<     {
<       return 2;
<     }
<   else
<     {
<       return 4;
<     }
< }
< 
< uint8_t
< WifiTxVector::Get_OFDM_EDMG_CEF (void) const
< {
<   if ((m_numSts == 1) || (m_numSts == 2))
<     {
<       return 2;
<     }
<   else if ((m_numSts == 3) || (m_numSts == 4))
<     {
<       return m_numSts;
<     }
<   else if ((m_numSts == 5) || (m_numSts == 6))
<     {
<       return 6;
<     }
<   else
<     {
<       return 8;
<     }
< }
< void
< WifiTxVector::SetNumUsers (uint8_t num)
< {
<   m_numUsers = num;
< }
< 
< uint8_t
< WifiTxVector::GetNumUsers (void) const
< {
<   return m_numUsers;
< }
< 
< void
< WifiTxVector::SetGaurdIntervalType (GuardIntervalLength gi)
< {
<   m_guardIntervalType = gi;
< }
< 
< GuardIntervalLength
< WifiTxVector::GetGaurdIntervalType (void) const
< {
<   return m_guardIntervalType;
< }
< 
< void
< WifiTxVector::SetPrimaryChannelNumber (uint8_t primaryCh)
< {
<   m_primaryChannel = primaryCh;
< }
< 
< uint8_t
< WifiTxVector::GetPrimaryChannelNumber (void) const
< {
<   return m_primaryChannel;
< }
< 
< void
< WifiTxVector::SetChBandwidth (EDMG_CHANNEL_CONFIG chConfig)
< {
<   m_primaryChannel = chConfig.primayChannel;
<   m_chBandwidth = chConfig.ch_bandwidth;
<   m_NCB = chConfig.NCB;
<   m_mask = chConfig.mask;
< }
< 
< void
< WifiTxVector::SetChannelConfiguration (uint8_t primaryCh, uint8_t bw)
< {
<   EDMG_CHANNEL_CONFIG chConfig = FindChannelConfiguration (primaryCh, bw);
<   m_primaryChannel = primaryCh;
<   m_channelWidth = chConfig.channelWidth;
<   SetChBandwidth (chConfig);
< }
< 
< uint8_t
< WifiTxVector::GetChBandwidth (void) const
< {
<   return m_chBandwidth;
< }
< 
< EDMG_TRANSMIT_MASK
< WifiTxVector::GetTransmitMask (void) const
< {
<   return m_mask;
< }
< 
< uint8_t
< WifiTxVector::GetNCB (void) const
< {
<   return m_NCB;
< }
< 
< void
< WifiTxVector::SetChannelAggregation (bool chAggregation)
< {
<   m_chAggregation = chAggregation;
< }
< 
< bool
< WifiTxVector::GetChannelAggregation (void) const
< {
<   return m_chAggregation;
< }
< 
< void
< WifiTxVector::SetNumberOfTxChains (uint8_t nTxChains)
< {
<   m_nTxChains = nTxChains;
< }
< 
< uint8_t
< WifiTxVector::GetNumberOfTxChains (void) const
< {
<   return m_nTxChains;
< }
< 
< void
< WifiTxVector::SetLdcpCwLength (bool cwLength)
< {
<   m_shortLongLDCP = cwLength;
< }
< 
< bool
< WifiTxVector::GetLdcpCwLength (void) const
< {
<   return m_shortLongLDCP;
< }
< void
< WifiTxVector::Set_TRN_SEQ_LEN (TRN_SEQ_LENGTH number)
< {
<   m_TrnSeqLen = number;
< }
< 
< TRN_SEQ_LENGTH
< WifiTxVector::Get_TRN_SEQ_LEN (void) const
< {
<   return m_TrnSeqLen;
< }
< 
< void
< WifiTxVector::Set_EDMG_TRN_P (uint8_t number)
< {
<   m_edmgTrnP = number;
< }
< 
< uint8_t
< WifiTxVector::Get_EDMG_TRN_P (void) const
< {
<   return m_edmgTrnP;
< }
< 
< void
< WifiTxVector::Set_EDMG_TRN_M (uint8_t number)
< {
<   m_edmgTrnM = number;
< }
< 
< uint8_t
< WifiTxVector::Get_EDMG_TRN_M (void) const
< {
<   return m_edmgTrnM;
< }
< 
< void
< WifiTxVector::Set_EDMG_TRN_N (uint8_t number)
< {
<   m_edmgTrnN = number;
< }
< 
< uint8_t
< WifiTxVector::Get_EDMG_TRN_N (void) const
< {
<   return m_edmgTrnN;
< }
< 
< uint8_t
< WifiTxVector::Get_TRN_T (void) const
< {
<   if (m_TrnSeqLen == TRN_SEQ_LENGTH_NORMAL)
<     {
<       return 2;
<     }
<   else if (m_TrnSeqLen == TRN_SEQ_LENGTH_LONG)
<     {
<       return 1;
<     }
<   else if (m_TrnSeqLen == TRN_SEQ_LENGTH_SHORT)
<     {
<       return 4;
<     }
<   else
<     NS_FATAL_ERROR ("Unvalid TRN Subfield Sequence Length");
< }
< 
< void
< WifiTxVector::Set_RxPerTxUnits (uint8_t number)
< {
<   m_rxPerTxUnits = number;
< }
< 
< uint8_t
< WifiTxVector::Get_RxPerTxUnits (void) const
< {
<   return m_rxPerTxUnits;
< }
< 
< void
< WifiTxVector::SetSender (Mac48Address sender)
< {
<   m_sender = sender;
< }
< 
< Mac48Address
< WifiTxVector::GetSender (void) const
< {
<   return m_sender;
< }
< 
< void
< WifiTxVector::SetDMGBeacon (bool beacon)
< {
<   m_isDMGBeacon = beacon;
< }
< 
< bool
< WifiTxVector::IsDMGBeacon (void) const
< {
<   return m_isDMGBeacon;
< }
< 
< void
< WifiTxVector::SetTrnRxPattern (rxPattern trnRxPattern)
< {
<   m_trnRxPattern = trnRxPattern;
< }
< 
< rxPattern
< WifiTxVector::GetTrnRxPattern (void) const
< {
<   return m_trnRxPattern;
< }
< 
< void
< WifiTxVector::SetBrpCdown (uint8_t brpCdown)
< {
<   m_brpCdown = brpCdown;
< }
< 
< uint8_t
< WifiTxVector::GetBrpCdown (void) const
< {
<   return m_brpCdown;
< }
< 
< void
< WifiTxVector::SetControlTrailerPresent (bool flag)
< {
<   m_isControlTrailerPresent = flag;
< }
< 
< bool
< WifiTxVector::IsControlTrailerPresent (void) const
< {
<   return m_isControlTrailerPresent;
< }
< //// WIGIG ////
diff ../../NS3-WiGig/src/wifi/model/wifi-tx-vector.h ../../ns-3-dev/src/wifi/model/wifi-tx-vector.h
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
21d19
<  *          Hany Assasa <hany.assasa@gmail.com>
27,32c25,26
< #include "ns3/mac48-address.h"
< #include "ns3/nstime.h"
< #include "wifi-mode.h"
< #include "wifi-preamble.h"
< #include "wifi-phy-standard.h"
< #include "wigig-data-types.h"
---
> #include <ns3/wifi-mode.h>
> #include <ostream>
36,57d29
< /**
<  * The EDMG SC Guard Interval Length.
<  */
< enum GuardIntervalLength {
<   GI_SHORT  = 0,
<   GI_NORMAL = 1,
<   GI_LONG   = 2,
< };
< 
< /**
<  * EDMG TRN Sequence Length.
<  */
< enum TRN_SEQ_LENGTH {
<   TRN_SEQ_LENGTH_NORMAL = 0,
<   TRN_SEQ_LENGTH_LONG   = 1,
<   TRN_SEQ_LENGTH_SHORT  = 2,
< };
< 
< enum rxPattern {
<   QUASI_OMNI,
<   DIRECTIONAL
< };
62,63c34,35
<  * used for a transmission. See IEEE 802.11-2016 16.2.5 "Transmit PHY",
<  * and also 8.3.4.1 "PHY SAP peer-to-peer service primitive
---
>  * used for a transmission. See IEEE 802.11-2007 15.2.6 "Transmit PLCP",
>  * and also 15.4.4.2 "PMD_SAP peer-to-peer service primitive
81c53
<  * 16). TXVECTOR is defined also for the other PHYs, however they
---
>  * 15). TXVECTOR is defined also for the other PHYs, however they
98,114c70,71
<    * \param preamble preamble type
<    * \param channelWidth the channel width in MHz
<    * \param aggregation enable or disable MPDU aggregation
<    */
<   WifiTxVector (WifiMode mode,
<                 uint8_t powerLevel,
<                 WifiPreamble preamble,
<                 uint16_t channelWidth,
<                 bool aggregation);
<   /**
<    * Create a TXVECTOR with the given parameters.
<    *
<    * \param mode WifiMode
<    * \param powerLevel transmission power level
<    * \param preamble preamble type
<    * \param guardInterval the guard interval duration in nanoseconds
<    * \param nTx the number of TX antennas
---
>    * \param retries retries
>    * \param shortGuardInterval enable or disable short guard interval
120d76
<    * \param bssColor the BSS color
124,126c80,81
<                 WifiPreamble preamble,
<                 uint16_t guardInterval,
<                 uint8_t nTx,
---
>                 uint8_t retries,
>                 bool shortGuardInterval,
129c84
<                 uint16_t channelWidth,
---
>                 uint32_t channelWidth,
131,136c86
<                 bool stbc,
<                 uint8_t bssColor = 0);
<   /**
<    * \returns whether mode has been initialized
<    */
<   bool GetModeInitialized (void) const;
---
>                 bool stbc);
144c94
<   * \param mode the payload WifiMode
---
>   * \param mode
154c104
<    * \param powerlevel the transmission power level
---
>    * \param powerlevel
158c108
<    * \returns the preamble type
---
>    * \returns the number of retries
160c110
<   WifiPreamble GetPreambleType (void) const;
---
>   uint8_t GetRetries (void) const;
162c112
<    * Sets the preamble type
---
>    * Sets the number of retries
164c114
<    * \param preamble the preamble type
---
>    * \param retries
166c116
<   void SetPreambleType (WifiPreamble preamble);
---
>   void SetRetries (uint8_t retries);
170c120
<   uint16_t GetChannelWidth (void) const;
---
>   uint32_t GetChannelWidth (void) const;
174c124
<    * \param channelWidth the channel width (in MHz)
---
>    * \param channelWidth
176c126
<   void SetChannelWidth (uint16_t channelWidth);
---
>   void SetChannelWidth (uint32_t channelWidth);
178c128
<    * \returns the guard interval duration (in nanoseconds)
---
>    * \returns if ShortGuardInterval is used or not
180c130
<   uint16_t GetGuardInterval (void) const;
---
>   bool IsShortGuardInterval (void) const;
182c132
<   * Sets the guard interval duration (in nanoseconds)
---
>   * Sets if short gurad interval is being used
184c134
<   * \param guardInterval the guard interval duration (in nanoseconds)
---
>   * \param guardinterval enable or disable short guard interval
186c136
<   void SetGuardInterval (uint16_t guardInterval);
---
>   void SetShortGuardInterval (bool guardinterval);
188,198c138
<    * \returns the number of TX antennas
<    */
<   uint8_t GetNTx (void) const;
<   /**
<    * Sets the number of TX antennas
<    *
<    * \param nTx the number of TX antennas
<    */
<   void SetNTx (uint8_t nTx);
<   /**
<    * \returns the number of spatial streams
---
>    * \returns the number of Nss
204c144
<    * \param nss the number of spatial streams
---
>    * \param nss
208c148
<    * \returns the number of extended spatial streams
---
>    * \returns the number of Ness
214c154
<    * \param ness the number of extended spatial streams
---
>    * \param ness
226c166
<    * \param aggregation whether the PSDU contains A-MPDU or not.
---
>    * \param aggregated whether the PSDU contains A-MPDU or not.
242,324d181
<   /**
<    * Set the BSS color
<    * \param color the BSS color
<    */
<   void SetBssColor (uint8_t color);
<   /**
<    * Get the BSS color
<    * \return the BSS color
<    */
<   uint8_t GetBssColor (void) const;
<   /**
<    * The standard disallows certain combinations of WifiMode, number of
<    * spatial streams, and channel widths.  This method can be used to
<    * check whether this WifiTxVector contains an invalid combination.
<    *
<    * \return true if the WifiTxVector parameters are allowed by the standard
<    */
<   bool IsValid (void) const;
< 
<   //// WIGIG ////
<   /** IEEE 802.11ad DMG Tx Vector **/
< 
<   /**
<    * Set BRP Packet Type.
<    * \param type The type of BRP packet.
<    */
<   void SetPacketType (PacketType type);
<   /**
<    * Get BRP Packet Type.
<    * \return The type of BRP packet.
<    */
<   PacketType GetPacketType (void) const;
<   /**
<    * Set the length of te training field.
<    * \param length The length of the training field.
<    */
<   void SetTrainngFieldLength (uint8_t length);
<   /**
<    * Get the length of te training field.
<    * \return The length of te training field.
<    */
<   uint8_t GetTrainngFieldLength (void) const;
<   /**
<    * Request Beam Tracking.
<    */
<   void RequestBeamTracking (void);
<   /**
<    * \return True if Beam Tracking requested, otherwise false.
<    */
<   bool IsBeamTrackingRequested (void) const;
<   /**
<    * In the TXVECTOR, LAST_RSSI indicates the received power level of
<    * the last packet with a valid PHY header that was received a SIFS period
<    * before transmission of the current packet; otherwise, it is 0.
<    *
<    * In the RXVECTOR, LAST_RSSI indicates the value of the LAST_RSSI
<    * field from the PCLP header of the received packet. Valid values are
<    * integers in the range of 0 to 15:
<    * — Values of 2 to 14 represent power levels (–71+value×2) dBm.
<    * — A value of 15 represents power greater than or equal to –42 dBm.
<    * — A value of 1 represents power less than or equal to –68 dBm.
<    * — A value of 0 indicates that the previous packet was not received a
<    * SIFS period before the current transmission.
<    *
<    * \param length The length of the training field.
<    */
<   void SetLastRssi (uint8_t level);
<   /**
<    * Get the level of Last RSSI.
<    * \return The level of Last RSSI.
<    */
<   uint8_t GetLastRssi (void) const;
< 
< public:
<   uint8_t remainingTrnUnits;
<   uint8_t remainingTrnSubfields;
<   uint8_t remainingTSubfields;
<   uint8_t remainingPSubfields;
<   uint8_t repeatSameAWVSubfield;
<   uint8_t repeatSameAWVUnit;
<   Time edmgTrnSubfieldDuration;
< 
<   /** IEEE 802.11ay EDMG Tx Vector **/
326,563d182
<   /**
<    * Indicates the number of space-time streams. Value is an integer in the
<    * range 1 to 8 for an SU PPDU. For an MU PPDU, values are integers in the
<    * range 1 to 2 per user in the TXVECTOR, and 0 to 2 per user in the RXVECTOR.
<    * The sum of NUM_STS over all users is in the range of 1 to 8.
<    * \param num
<    */
<   void Set_NUM_STS (uint8_t num);
<   uint8_t Get_NUM_STS (void) const;
<   /**
<    * Indicates the number of EDMG CEF Fields transmitted when using SC mode.
<    * Depends on the number of space-time streams as specified in 29.12.3.3.
<    */
<   uint8_t Get_SC_EDMG_CEF (void) const;
<   /**
<    * Indicates the number of EDMG CEF Fields transmitted when using OFDM mode.
<    * Depends on the number of space-time streams as specified in 29.12.3.3.
<    */
<   uint8_t Get_OFDM_EDMG_CEF (void) const;
<   /**
<    * Indicates the number of users with nonzero space-time streams.
<    * Integer: range 1 to 8 in case of 1 space-time stream per user,
<    * range 1 to 4 in case of 2 space-time streams per user.
<    * \param num
<    */
<   void SetNumUsers (uint8_t num);
<   uint8_t GetNumUsers (void) const;
<   /**
<    * Indicates the length of the guard interval.
<    * Enumerated Type:
<    * - ShortGI
<    * - NormalGI
<    * - LongGI
<    * \param gi
<    */
<   void SetGaurdIntervalType (GuardIntervalLength gi);
<   GuardIntervalLength GetGaurdIntervalType (void) const;
<   /**
<    * Set the primary 2.16 GHz channel number.
<    * \param primaryCh The pimrary 2.16 GHz channel number.
<    */
<   void SetPrimaryChannelNumber (uint8_t primaryCh);
<   /**
<    * Get the primary 2.16 channel number.
<    * \return The primary 2.16 channel number.
<    */
<   uint8_t GetPrimaryChannelNumber (void) const;
<   /**
<    * Set channels on which the PPDU is transmitted and the value of the BW field in the EDMG Header-A.
<    * In the RXVECTOR, indicates the value of the BW field in the EDMG Header-A of a received PPDU.
<    * This parameter is a bitmap. Valid values for this parameter and the CHANNEL_AGGREGATION parameter
<    *  are indicated in Table 28-21, Table 28-22 and Table 28-23.
<    * \param bandwdith
<    */
<   void SetChBandwidth (EDMG_CHANNEL_CONFIG bandwdith);
<   /**
<    * \return The current EDMG channel bandwidth.
<    */
<   uint8_t GetChBandwidth (void) const;
<   /**
<    * Set channel configuration for the current transmission.
<    * \param primaryCh The primary 2.16 GHz channel number.
<    * \param bw The channels over which the PPDU is transmitted.
<    */
<   void SetChannelConfiguration (uint8_t primaryCh, uint8_t bw);
<   /**
<    * \return the current transmit mask corresponding to the current channel configuration.
<    */
<   EDMG_TRANSMIT_MASK GetTransmitMask (void) const;
<   /**
<    * Get the Number of contiguous 2.16 GHz channels, NCB = 1 for 2.16 GHz
<    * and 2.16+2.16 GHz, NCB = 2 for 4.32 GHz and 4.32+4.32 GHz, N CB = 3 for
<    * 6.48 GHz, and NCB = 4 for 8.64 GHz channel
<    * \return The number of continous channels.
<    */
<   uint8_t GetNCB (void) const;
<   /**
<    * Indicate whether Channel Aggregation is used or not.
<    * \param chAggregation
<    */
<   void SetChannelAggregation (bool chAggregation);
<   /**
<    * True if Channel Aggregation is used and false otherwise.
<    * \return if channel aggregation is used.
<    */
<   bool GetChannelAggregation (void) const;
<   /**
<    * Set the number of TX Chains used for transmission of the packet.
<    * \param nTxChains
<    */
<   void SetNumberOfTxChains (uint8_t nTxChains);
<   /**
<    * Return the number of tx chains used for transmission of the packet.
<    * \return  number of active tx chains.
<    */
<   uint8_t GetNumberOfTxChains (void) const;
<   /**
<    * Set the LDCP codeword length. Set to 0 for LDPC
<    * codeword of length 672, 624, 504, or 468. Set to 1 for LDPC codeword of
<    * length 1344, 1248, 1008, or 936.
<    * \param cwlength Short or Long LDCP CW length.
<    */
<   void SetLdcpCwLength (bool cwLength);
<   /**
<    * Get the LDCP codeword length. 0 means LDPC
<    * codeword of length 672, 624, 504, or 468. 1 means LDPC codeword of
<    * length 1344, 1248, 1008, or 936.
<    * \return Short or Long LDCP CW length.
<    */
<   bool GetLdcpCwLength (void) const;
<   /**
<    * Set the number of EDMG TRN units in the training field.
<    * \param length The number of EDMG TRN units.
<    */
<   void SetEDMGTrainingFieldLength (uint8_t length);
<   /**
<    * Get the number of EDMG TRN units in the training field.
<    * \return The number of EDMG TRN units.
<    */
<   uint8_t GetEDMGTrainingFieldLength (void) const;
<   /**
<    * Indicates the number of TRN subfields at the beginning of a TRN-Unit
<    * which are transmitted with the same AWV.
<    * \param number
<    */
<   void Set_EDMG_TRN_P (uint8_t number);
<   /**
<    * Returns the number of TRN subfields at the beginning of a TRN-Unit
<    * which are transmitted with the same AWV as defined in 29.9.2.2.3
<    * \param number
<    */
<   uint8_t Get_EDMG_TRN_P (void) const;
<   /**
<    * If EDMG_PACKET_TYPE is TRN-T-PACKET or TRN-R/T-PACKET, indicates the
<    * number of TRN subfields in a TRN-Unit that may be used for transmit
<    * training, as defined in 29.9.2.2.
<    * The parameter is reserved if TRN-LEN is 0. The parameter is reserved
<    * if EDMG_PACKET_TYPE is TRN-R-PACKET.
<    * \param number
<    */
<   void Set_EDMG_TRN_M (uint8_t number);
<   /**
<    * Returns the number of TRN Subfields used for transmit training as defined in 29.9.2.2.3.
<    * \param number
<    */
<   uint8_t Get_EDMG_TRN_M (void) const;
<   /**
<    * Indicates the number of consecutive TRN subfields within the EDMG
<    * TRN-Unit M of a TRN-Unit which are transmitted using the same AWV.
<    * \param number
<    */
<   void Set_EDMG_TRN_N (uint8_t number);
<   /**
<    * Returns the number of consecutive TRN subfields within the EDMG-Unit M
<    * which are transmitted using the same AWV as defined in 29.9.2.2.3
<    * \param number
<    */
<   uint8_t Get_EDMG_TRN_N (void) const;
<   /**
<    * Indicates the length of the Golay sequence to be used to transmit the
<    * TRN subfields present in the TRN field of the PPDU. Enumerated Type:
<    * - Normal: The Golay sequence has a length of 128×NCB.
<    * - Long: The Golay sequence has a length of 256× NCB.
<    * - Short: The Golay sequence has a length of 64× NCB.
<    * NCB represents the integer number of contiguous 2.16 GHz channels over
<    * which the TRN subfield is transmitted and 1 ≤ NCB ≤ 4.
<    * \param number
<    */
<   void Set_TRN_SEQ_LEN (TRN_SEQ_LENGTH number);
<   /**
<    * Returns the length of the Golay sequence to be used to transmit the
<    * TRN subfields present in the TRN field of the PPDU.
<    * \param number
<    */
<   TRN_SEQ_LENGTH Get_TRN_SEQ_LEN (void) const;
<   /**
<    * If EDMG_PACKET_TYPE is TRN-T-PACKET or TRN-R/T-PACKET, returns the number of
<    * TRN subfields repeated at the start of the TRN field with the same AWV as the
<    * rest of the packet and used as a transional period before the training.
<    * Can have the values 1,2 or 4 depending on the value of m_TrnSeqLen so that
<    * the duration of transmission of the T subfields remains the same.
<    */
<   uint8_t Get_TRN_T (void) const;
<   /**
<    * If EDMG_PACKET_TYPE is TRN-R/T-PACKET, indicates the number of
<    * TRN units repeated with the same AWV in order to perform RX training
<    * at the responder.
<    * \param number
<    */
<   void Set_RxPerTxUnits (uint8_t number);
<   /**
<    * Returns the number of TRN units repeated with the same AWV in order
<    * to perform RX training at the responder as defined in 29.9.2.2.3.
<    */
<   uint8_t Get_RxPerTxUnits (void) const;
<   /**
<    * Set the MAC address of the sender of the packet.
<    */
<   void SetSender (Mac48Address sender);
<   /**
<    * Returns the MAC address of the sender of the packet.
<   */
<   Mac48Address GetSender (void) const;
<   /**
<    * Whether the transmitted packet is a DMG beacon or not.
<    */
<   void SetDMGBeacon (bool beacon);
<   /**
<    * Returns whether the transmitted packet is a DMG beacon or not.
<   */
<   bool IsDMGBeacon (void) const;
<   /**
<    * Indicates the receive antenna pattern to be used
<    * when measuring TRN-Units present in a received PPDU.
<   */
<   void SetTrnRxPattern (rxPattern trnRxPattern);
<   /**
<    * Returns the receive antenna pattern to be used
<    * when measuring TRN-Units present in a received PPDU.
<   */
<   rxPattern GetTrnRxPattern (void) const;
<   /**
<    * Sets the BRP CDOWN value of the packet in EDMG BRP Packets
<    */
<   void SetBrpCdown (uint8_t brpCdown);
<   /**
<    * Returns the BRP CDOWN value in EDMG BRP Packets.
<   */
<   uint8_t GetBrpCdown (void) const;
<   /**
<    * Sets the flag for presence of a control trailer in the packet.
<    */
<   void SetControlTrailerPresent (bool flag);
<   /**
<    * Returns whether a control trailer is present in the packet.
<   */
<   bool IsControlTrailerPresent (void) const;
<   //// WIGIG ////
566,567d184
<   void DoInitialize(void);
< 
574,580c191,197
<   WifiPreamble m_preamble;       /**< preamble */
<   uint16_t m_channelWidth;       /**< channel width in MHz */
<   uint16_t m_guardInterval;      /**< guard interval duration in nanoseconds */
<   uint8_t  m_nTx;                /**< number of TX antennas */
<   uint8_t  m_nss;                /**< number of spatial streams */
<   uint8_t  m_ness;               /**< number of spatial streams in beamforming */
<   bool     m_aggregation;        /**< Flag whether the PSDU contains A-MPDU. */
---
>   uint8_t  m_retries;            /**< The DATA_RETRIES/RTS_RETRIES parameter
>                                  for Click radiotap information */
>   uint32_t m_channelWidth;       /**< channel width in MHz */
>   bool     m_shortGuardInterval; /**< true if short GI is going to be used */
>   uint8_t  m_nss;                /**< number of streams */
>   uint8_t  m_ness;               /**< number of streams in beamforming */
>   bool     m_aggregation;        /** Flag whether the PSDU contains A-MPDU. */
582,620d198
<   uint8_t  m_bssColor;           /**< BSS color */
< 
<   bool     m_modeInitialized;         /**< Internal initialization flag */
<   bool     m_txPowerLevelInitialized; /**< Internal initialization flag */
< 
<   //// WIGIG ////
<   /** IEEE 802.11ad DMG Tx Vector **/
<   PacketType  m_packetType;               //!< BRP-RX, BRP-TX or BRP-RX/TX packet.
<   uint8_t     m_traingFieldLength;        //!< The length of the training field (Number of TRN-Units).
<   bool        m_beamTrackingRequest;      //!< Flag to indicate the need for beam tracking.
<   uint8_t     m_lastRssi;                 //!< Last Received Signal Strength Indicator.
< 
<   /** IEEE 802.11ay EDMG Tx Vector **/
< 
<   /* EDMG Header-A */
<   uint8_t m_numSts;                       //!< The number of space-time streams.
<   uint8_t m_numUsers;
<   GuardIntervalLength m_guardIntervalType;
<   uint8_t m_chBandwidth;
<   uint8_t m_primaryChannel;               //!< The primary 2.16 GHz channel.
<   uint8_t m_NCB;                          //!< Number of bonded channels.
<   EDMG_TRANSMIT_MASK m_mask;              //!< The EDMG transmit mask (Represent the numfer of channels).
<   bool m_chAggregation;                   //!< Flag to indicate whether channel aggregation is used or not.
<   uint8_t m_nTxChains;                    //!< The number of Tx Chains used for the transmission of the packet.
<   bool m_shortLongLDCP;                   //!< Flag to indicate whether the LDCP codewords have a short or long length.
<   uint8_t m_edmgTrnLength;                //!< The length of the EDMG training field (Number of EDMG TRN-Units).
<   uint8_t m_edmgTrnP;                     //!< Number of TRN Subfields repeated at the start of a unit with the same AWV.
<   uint8_t m_edmgTrnM;                     //!< In BRP-TX and BRP-RX/TX packets the number of TRN Subfields that can be used for training.
<   uint8_t m_edmgTrnN;                     //!< In BRP-TX packets the number of TRN Subfields in a unit transmitted with the same AWV.
<   TRN_SEQ_LENGTH m_TrnSeqLen;             //!< Length of the Golay Sequence used in the TRN Subfields.
<   uint8_t m_rxPerTxUnits;                 //!< In BRP-RX/TX packets the number of times a TRN unit is repeated for RX training at the responder.
<   rxPattern m_trnRxPattern;               //!< Indicates the receive antenna pattern to be used when measuring TRN-Units present in a received PPDU.
< 
<   /* Helper values needed for PHY processing of TRN fields */
<   Mac48Address m_sender;                  //!< MAC address of the sender of the packet.
<   bool m_isDMGBeacon;                     //!< Flag that specifies whether the transmitted packet is a DMG beacon or not.
<   uint8_t m_brpCdown;                     //!< BRP CDOWN value of the packet
<   //// WIGIG ////
<   bool m_isControlTrailerPresent;           //!< Flag that specifies if a control trailer is added at the end of the packet
621a200,201
>   bool     m_modeInitialized;         //*< Internal initialization flag */
>   bool     m_txPowerLevelInitialized; //*< Internal initialization flag */
627,628c207,208
<  * \param os the output stream
<  * \param v the WifiTxVector to stringify
---
>  * \param os
>  * \param v
630c210
<  * \return ouput stream
---
>  * \return ostream
Only in ../../NS3-WiGig/src/wifi/model: wifi-utils.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-utils.h
Only in ../../NS3-WiGig/src/wifi/model: wigig-data-types.cc
Only in ../../NS3-WiGig/src/wifi/model: wigig-data-types.h
diff ../../NS3-WiGig/src/wifi/model/yans-error-rate-model.cc ../../ns-3-dev/src/wifi/model/yans-error-rate-model.cc
22c22
< #include "ns3/log.h"
---
> #include <cmath>
24,25d23
< #include "dsss-error-rate-model.h"
< #include "wifi-utils.h"
26a25
> #include "ns3/log.h"
50c49,55
< YansErrorRateModel::GetBpskBer (double snr, uint32_t signalSpread, uint64_t phyRate) const
---
> YansErrorRateModel::Log2 (double val) const
> {
>   return std::log (val) / std::log (2.0);
> }
> 
> double
> YansErrorRateModel::GetBpskBer (double snr, uint32_t signalSpread, uint32_t phyRate) const
61c66
< YansErrorRateModel::GetQamBer (double snr, unsigned int m, uint32_t signalSpread, uint64_t phyRate) const
---
> YansErrorRateModel::GetQamBer (double snr, unsigned int m, uint32_t signalSpread, uint32_t phyRate) const
65c70
<   double z = std::sqrt ((1.5 * log2 (m) * EbNo) / (m - 1.0));
---
>   double z = std::sqrt ((1.5 * Log2 (m) * EbNo) / (m - 1.0));
68c73
<   double ber = z2 / log2 (m);
---
>   double ber = z2 / Log2 (m);
141,142c146,147
< YansErrorRateModel::GetFecBpskBer (double snr, uint64_t nbits,
<                                    uint32_t signalSpread, uint64_t phyRate,
---
> YansErrorRateModel::GetFecBpskBer (double snr, double nbits,
>                                    uint32_t signalSpread, uint32_t phyRate,
159c164
< YansErrorRateModel::GetFecQamBer (double snr, uint64_t nbits,
---
> YansErrorRateModel::GetFecQamBer (double snr, uint32_t nbits,
161c166
<                                   uint64_t phyRate,
---
>                                   uint32_t phyRate,
178c183
<   double pms = std::pow (1 - pmu, nbits);
---
>   double pms = std::pow (1 - pmu, static_cast<double> (nbits));
183c188
< YansErrorRateModel::GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint64_t nbits) const
---
> YansErrorRateModel::GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint32_t nbits) const
189,190c194
<       || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT
<       || mode.GetModulationClass () == WIFI_MOD_CLASS_HE)
---
>       || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
199c203
<                                     mode.GetPhyRate (txVector), //PHY rate
---
>                                     mode.GetPhyRate (txVector), //phy rate
208c212
<                                     mode.GetPhyRate (txVector), //PHY rate
---
>                                     mode.GetPhyRate (txVector), //phy rate
220c224
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
231c235
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
245c249
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
256c260
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
270c274
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
282c286
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
293c297
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
307c311
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
319c323
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
327,353d330
<       else if (mode.GetConstellationSize () == 1024)
<         {
<           if (mode.GetCodeRate () == WIFI_CODE_RATE_5_6)
<             {
<               return GetFecQamBer (snr,
<                                    nbits,
<                                    txVector.GetChannelWidth () * 1000000, // signal spread
<                                    mode.GetPhyRate (txVector), //PHY rate
<                                    1024, // m
<                                    4,  // dFree
<                                    14,  // adFree
<                                    69  // adFreePlusOne
<                                    );
<             }
<           else
<             {
<               return GetFecQamBer (snr,
<                                    nbits,
<                                    txVector.GetChannelWidth () * 1000000, // signal spread
<                                    mode.GetPhyRate (txVector), //PHY rate
<                                    1024, // m
<                                    5,  // dFree
<                                    8,  // adFree
<                                    31  // adFreePlusOne
<                                    );
<             }
<         }
357c334
<       switch (mode.GetDataRate (20))
---
>       switch (mode.GetDataRate (20, 0, 1))
diff ../../NS3-WiGig/src/wifi/model/yans-error-rate-model.h ../../ns-3-dev/src/wifi/model/yans-error-rate-model.h
23a24,25
> #include <stdint.h>
> #include "wifi-mode.h"
24a27
> #include "dsss-error-rate-model.h"
42c45
<  *      Digital Communications, 2001 edition
---
>  *      Digitial Communications, 2001 edition
44c47
<  *      approximations for DQPSK transmission bit error rate", G. Ferrari and G.E. Corazza
---
>  *      approximations for dqpsk transmission bit error rate", G. Ferrari and G.E. Corazza
47c50
<  *      performance of the IEEE 802.11b complementary code-key signal sets",
---
>  *      performance of the ieee 802.11b complementarycode-key signal sets",
56,59d58
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
64c63
<   virtual double GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint64_t nbits) const;
---
>   virtual double GetChunkSuccessRate (WifiMode mode, WifiTxVector txVector, double snr, uint32_t nbits) const;
68a68,75
>    * Return the logarithm of the given value to base 2.
>    *
>    * \param val
>    *
>    * \return the logarithm of val to base 2.
>    */
>   double Log2 (double val) const;
>   /**
77c84
<   double GetBpskBer (double snr, uint32_t signalSpread, uint64_t phyRate) const;
---
>   double GetBpskBer (double snr, uint32_t signalSpread, uint32_t phyRate) const;
88c95
<   double GetQamBer (double snr, unsigned int m, uint32_t signalSpread, uint64_t phyRate) const;
---
>   double GetQamBer (double snr, unsigned int m, uint32_t signalSpread, uint32_t phyRate) const;
138,139c145,146
<   double GetFecBpskBer (double snr, uint64_t nbits,
<                         uint32_t signalSpread, uint64_t phyRate,
---
>   double GetFecBpskBer (double snr, double nbits,
>                         uint32_t signalSpread, uint32_t phyRate,
153c160
<   double GetFecQamBer (double snr, uint64_t nbits,
---
>   double GetFecQamBer (double snr, uint32_t nbits,
155c162
<                        uint64_t phyRate,
---
>                        uint32_t phyRate,
diff ../../NS3-WiGig/src/wifi/model/yans-wifi-channel.cc ../../ns-3-dev/src/wifi/model/yans-wifi-channel.cc
20a21
> #include "ns3/packet.h"
22,23c23
< #include "ns3/log.h"
< #include "ns3/pointer.h"
---
> #include "ns3/mobility-model.h"
25a26,29
> #include "ns3/log.h"
> #include "ns3/pointer.h"
> #include "ns3/object-factory.h"
> #include "yans-wifi-channel.h"
28,33d31
< #include "ns3/mobility-model.h"
< #include "yans-wifi-channel.h"
< #include "yans-wifi-phy.h"
< #include "wifi-utils.h"
< #include "wifi-ppdu.h"
< #include "wifi-psdu.h"
45c43
<     .SetParent<Channel> ()
---
>     .SetParent<WifiChannel> ()
62d59
<   NS_LOG_FUNCTION (this);
67c64
<   NS_LOG_FUNCTION (this);
---
>   NS_LOG_FUNCTION_NOARGS ();
72c69
< YansWifiChannel::SetPropagationLossModel (const Ptr<PropagationLossModel> loss)
---
> YansWifiChannel::SetPropagationLossModel (Ptr<PropagationLossModel> loss)
74d70
<   NS_LOG_FUNCTION (this << loss);
79c75
< YansWifiChannel::SetPropagationDelayModel (const Ptr<PropagationDelayModel> delay)
---
> YansWifiChannel::SetPropagationDelayModel (Ptr<PropagationDelayModel> delay)
81d76
<   NS_LOG_FUNCTION (this << delay);
86c81,82
< YansWifiChannel::Send (Ptr<YansWifiPhy> sender, Ptr<const WifiPpdu> ppdu, double txPowerDbm) const
---
> YansWifiChannel::Send (Ptr<YansWifiPhy> sender, Ptr<const Packet> packet, double txPowerDbm,
>                        WifiTxVector txVector, WifiPreamble preamble, enum mpduType mpdutype, Time duration) const
88,89c84
<   NS_LOG_FUNCTION (this << sender << ppdu << txPowerDbm);
<   Ptr<MobilityModel> senderMobility = sender->GetMobility ();
---
>   Ptr<MobilityModel> senderMobility = sender->GetMobility ()->GetObject<MobilityModel> ();
91c86,87
<   for (PhyList::const_iterator i = m_phyList.begin (); i != m_phyList.end (); i++)
---
>   uint32_t j = 0;
>   for (PhyList::const_iterator i = m_phyList.begin (); i != m_phyList.end (); i++, j++)
95c91
<           //For now don't account for inter channel interference nor channel bonding
---
>           //For now don't account for inter channel interference
106,107c102,103
<           Ptr<WifiPpdu> copy = Copy (ppdu);
<           Ptr<NetDevice> dstNetDevice = (*i)->GetDevice ();
---
>           Ptr<Packet> copy = packet->Copy ();
>           Ptr<Object> dstNetDevice = m_phyList[j]->GetDevice ();
115c111
<               dstNode = dstNetDevice->GetNode ()->GetId ();
---
>               dstNode = dstNetDevice->GetObject<NetDevice> ()->GetNode ()->GetId ();
117a114,120
>           struct Parameters parameters;
>           parameters.rxPowerDbm = rxPowerDbm;
>           parameters.type = mpdutype;
>           parameters.duration = duration;
>           parameters.txVector = txVector;
>           parameters.preamble = preamble;
> 
119,120c122,123
<                                           delay, &YansWifiChannel::Receive,
<                                           (*i), copy, rxPowerDbm);
---
>                                           delay, &YansWifiChannel::Receive, this,
>                                           j, copy, parameters);
126c129
< YansWifiChannel::Receive (Ptr<YansWifiPhy> phy, Ptr<WifiPpdu> ppdu, double rxPowerDbm)
---
> YansWifiChannel::Receive (uint32_t i, Ptr<Packet> packet, struct Parameters parameters) const
128,136c131
<   NS_LOG_FUNCTION (phy << ppdu << rxPowerDbm);
<   // Do no further processing if signal is too weak
<   // Current implementation assumes constant RX power over the PPDU duration
<   if ((rxPowerDbm + phy->GetRxGain ()) < phy->GetRxSensitivity ())
<     {
<       NS_LOG_INFO ("Received signal too weak to process: " << rxPowerDbm << " dBm");
<       return;
<     }
<   phy->StartReceivePreamble (ppdu, DbmToW (rxPowerDbm + phy->GetRxGain ()));
---
>   m_phyList[i]->StartReceivePreambleAndHeader (packet, parameters.rxPowerDbm, parameters.txVector, parameters.preamble, parameters.type, parameters.duration);
139c134
< std::size_t
---
> uint32_t
146c141
< YansWifiChannel::GetDevice (std::size_t i) const
---
> YansWifiChannel::GetDevice (uint32_t i) const
154d148
<   NS_LOG_FUNCTION (this << phy);
161d154
<   NS_LOG_FUNCTION (this << stream);
diff ../../NS3-WiGig/src/wifi/model/yans-wifi-channel.h ../../ns-3-dev/src/wifi/model/yans-wifi-channel.h
24c24,32
< #include "ns3/channel.h"
---
> #include <vector>
> #include <stdint.h>
> #include "ns3/packet.h"
> #include "wifi-channel.h"
> #include "wifi-mode.h"
> #include "wifi-preamble.h"
> #include "wifi-tx-vector.h"
> #include "yans-wifi-phy.h"
> #include "ns3/nstime.h"
31,34c39,47
< class YansWifiPhy;
< class Packet;
< class Time;
< class WifiPpdu;
---
> 
> struct Parameters
> {
>   double rxPowerDbm;
>   enum mpduType type;
>   Time duration;
>   WifiTxVector txVector;
>   WifiPreamble preamble;
> };
37c50
<  * \brief a channel to interconnect ns3::YansWifiPhy objects.
---
>  * \brief A Yans wifi channel
39a53,55
>  * This wifi channel implements the propagation model described in
>  * "Yet Another Network Simulator", (http://cutebugs.net/files/wns2-yans.pdf).
>  *
41,43c57,59
<  * class and supports an ns3::PropagationLossModel and an
<  * ns3::PropagationDelayModel.  By default, no propagation models are set;
<  * it is the caller's responsibility to set them before using the channel.
---
>  * class and contains a ns3::PropagationLossModel and a ns3::PropagationDelayModel.
>  * By default, no propagation models are set so, it is the caller's responsability
>  * to set them before using the channel.
45c61
< class YansWifiChannel : public Channel
---
> class YansWifiChannel : public WifiChannel
48,51d63
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
58,59c70,71
<   virtual std::size_t GetNDevices (void) const;
<   virtual Ptr<NetDevice> GetDevice (std::size_t i) const;
---
>   virtual uint32_t GetNDevices (void) const;
>   virtual Ptr<NetDevice> GetDevice (uint32_t i) const;
71c83
<   void SetPropagationLossModel (const Ptr<PropagationLossModel> loss);
---
>   void SetPropagationLossModel (Ptr<PropagationLossModel> loss);
75c87
<   void SetPropagationDelayModel (const Ptr<PropagationDelayModel> delay);
---
>   void SetPropagationDelayModel (Ptr<PropagationDelayModel> delay);
78,80c90,96
<    * \param sender the PHY object from which the packet is originating.
<    * \param ppdu the PPDU to send
<    * \param txPowerDbm the TX power associated to the packet, in dBm
---
>    * \param sender the device from which the packet is originating.
>    * \param packet the packet to send
>    * \param txPowerDbm the tx power associated to the packet
>    * \param txVector the TXVECTOR associated to the packet
>    * \param preamble the preamble associated to the packet
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
>    * \param duration the transmission duration associated to the packet
83,85c99,101
<    * currently invoked only from YansWifiPhy::StartTx.  The channel
<    * attempts to deliver the PPDU to all other YansWifiPhy objects
<    * on the channel (except for the sender).
---
>    * currently invoked only from WifiPhy::Send. YansWifiChannel
>    * delivers packets only between PHYs with the same m_channelNumber,
>    * e.g. PHYs that are operating on the same channel.
87c103,104
<   void Send (Ptr<YansWifiPhy> sender, Ptr<const WifiPpdu> ppdu, double txPowerDbm) const;
---
>   void Send (Ptr<YansWifiPhy> sender, Ptr<const Packet> packet, double txPowerDbm,
>              WifiTxVector txVector, WifiPreamble preamble, enum mpduType mpdutype, Time duration) const;
110c127
<    * bit of the PPDU has arrived.
---
>    * bit of the packet has arrived.
112,114c129,133
<    * \param receiver the device to which the packet is destined
<    * \param ppdu the PPDU being sent
<    * \param txPowerDbm the TX power associated to the packet being sent (dBm)
---
>    * \param i index of the corresponding YansWifiPhy in the PHY list
>    * \param packet the packet being sent
>    * \param atts a vector containing the received power in dBm and the packet type
>    * \param txVector the TXVECTOR of the packet
>    * \param preamble the type of preamble being used to send the packet
116c135
<   static void Receive (Ptr<YansWifiPhy> receiver, Ptr<WifiPpdu> ppdu, double txPowerDbm);
---
>   void Receive (uint32_t i, Ptr<Packet> packet, struct Parameters parameters) const;
diff ../../NS3-WiGig/src/wifi/model/yans-wifi-phy.cc ../../ns-3-dev/src/wifi/model/yans-wifi-phy.cc
23d22
< #include "ns3/log.h"
26c25,32
< #include "wifi-ppdu.h"
---
> #include "wifi-phy-state-helper.h"
> #include "ns3/simulator.h"
> #include "ns3/packet.h"
> #include "ns3/assert.h"
> #include "ns3/log.h"
> #include "ns3/double.h"
> #include "ampdu-tag.h"
> #include <cmath>
60d65
<   WifiPhy::DoDispose ();
63c68,172
< Ptr<Channel>
---
> bool
> YansWifiPhy::DoChannelSwitch (uint16_t nch)
> {
>   if (!IsInitialized ())
>     {
>       //this is not channel switch, this is initialization
>       NS_LOG_DEBUG ("initialize to channel " << nch);
>       return true;
>     }
> 
>   NS_ASSERT (!IsStateSwitching ());
>   switch (m_state->GetState ())
>     {
>     case YansWifiPhy::RX:
>       NS_LOG_DEBUG ("drop packet because of channel switching while reception");
>       m_endPlcpRxEvent.Cancel ();
>       m_endRxEvent.Cancel ();
>       goto switchChannel;
>       break;
>     case YansWifiPhy::TX:
>       NS_LOG_DEBUG ("channel switching postponed until end of current transmission");
>       Simulator::Schedule (GetDelayUntilIdle (), &WifiPhy::SetChannelNumber, this, nch);
>       break;
>     case YansWifiPhy::CCA_BUSY:
>     case YansWifiPhy::IDLE:
>       goto switchChannel;
>       break;
>     case YansWifiPhy::SLEEP:
>       NS_LOG_DEBUG ("channel switching ignored in sleep mode");
>       break;
>     default:
>       NS_ASSERT (false);
>       break;
>     }
> 
>   return false;
> 
> switchChannel:
> 
>   NS_LOG_DEBUG ("switching channel " << GetChannelNumber () << " -> " << nch);
>   m_state->SwitchToChannelSwitching (GetChannelSwitchDelay ());
>   m_interference.EraseEvents ();
>   /*
>    * Needed here to be able to correctly sensed the medium for the first
>    * time after the switching. The actual switching is not performed until
>    * after m_channelSwitchDelay. Packets received during the switching
>    * state are added to the event list and are employed later to figure
>    * out the state of the medium after the switching.
>    */
>   return true;
> }
> 
> bool
> YansWifiPhy::DoFrequencySwitch (uint32_t frequency)
> {
>   if (!IsInitialized ())
>     {
>       //this is not channel switch, this is initialization
>       NS_LOG_DEBUG ("start at frequency " << frequency);
>       return true;
>     }
> 
>   NS_ASSERT (!IsStateSwitching ());
>   switch (m_state->GetState ())
>     {
>     case YansWifiPhy::RX:
>       NS_LOG_DEBUG ("drop packet because of channel/frequency switching while reception");
>       m_endPlcpRxEvent.Cancel ();
>       m_endRxEvent.Cancel ();
>       goto switchFrequency;
>       break;
>     case YansWifiPhy::TX:
>       NS_LOG_DEBUG ("channel/frequency switching postponed until end of current transmission");
>       Simulator::Schedule (GetDelayUntilIdle (), &WifiPhy::SetFrequency, this, frequency);
>       break;
>     case YansWifiPhy::CCA_BUSY:
>     case YansWifiPhy::IDLE:
>       goto switchFrequency;
>       break;
>     case YansWifiPhy::SLEEP:
>       NS_LOG_DEBUG ("frequency switching ignored in sleep mode");
>       break;
>     default:
>       NS_ASSERT (false);
>       break;
>     }
> 
>   return false;
> 
> switchFrequency:
> 
>   NS_LOG_DEBUG ("switching frequency " << GetFrequency () << " -> " << frequency);
>   m_state->SwitchToChannelSwitching (GetChannelSwitchDelay ());
>   m_interference.EraseEvents ();
>   /*
>    * Needed here to be able to correctly sensed the medium for the first
>    * time after the switching. The actual switching is not performed until
>    * after m_channelSwitchDelay. Packets received during the switching
>    * state are added to the event list and are employed later to figure
>    * out the state of the medium after the switching.
>    */
>   return true;
> }
> 
> Ptr<WifiChannel>
70c179
< YansWifiPhy::SetChannel (const Ptr<YansWifiChannel> channel)
---
> YansWifiPhy::SetChannel (Ptr<YansWifiChannel> channel)
72d180
<   NS_LOG_FUNCTION (this << channel);
78c186,463
< YansWifiPhy::StartTx (Ptr<WifiPpdu> ppdu)
---
> YansWifiPhy::SetSleepMode (void)
> {
>   NS_LOG_FUNCTION (this);
>   switch (m_state->GetState ())
>     {
>     case YansWifiPhy::TX:
>       NS_LOG_DEBUG ("setting sleep mode postponed until end of current transmission");
>       Simulator::Schedule (GetDelayUntilIdle (), &YansWifiPhy::SetSleepMode, this);
>       break;
>     case YansWifiPhy::RX:
>       NS_LOG_DEBUG ("setting sleep mode postponed until end of current reception");
>       Simulator::Schedule (GetDelayUntilIdle (), &YansWifiPhy::SetSleepMode, this);
>       break;
>     case YansWifiPhy::SWITCHING:
>       NS_LOG_DEBUG ("setting sleep mode postponed until end of channel switching");
>       Simulator::Schedule (GetDelayUntilIdle (), &YansWifiPhy::SetSleepMode, this);
>       break;
>     case YansWifiPhy::CCA_BUSY:
>     case YansWifiPhy::IDLE:
>       NS_LOG_DEBUG ("setting sleep mode");
>       m_state->SwitchToSleep ();
>       break;
>     case YansWifiPhy::SLEEP:
>       NS_LOG_DEBUG ("already in sleep mode");
>       break;
>     default:
>       NS_ASSERT (false);
>       break;
>     }
> }
> 
> void
> YansWifiPhy::ResumeFromSleep (void)
> {
>   NS_LOG_FUNCTION (this);
>   switch (m_state->GetState ())
>     {
>     case YansWifiPhy::TX:
>     case YansWifiPhy::RX:
>     case YansWifiPhy::IDLE:
>     case YansWifiPhy::CCA_BUSY:
>     case YansWifiPhy::SWITCHING:
>       {
>         NS_LOG_DEBUG ("not in sleep mode, there is nothing to resume");
>         break;
>       }
>     case YansWifiPhy::SLEEP:
>       {
>         NS_LOG_DEBUG ("resuming from sleep mode");
>         Time delayUntilCcaEnd = m_interference.GetEnergyDuration (DbmToW (GetCcaMode1Threshold ()));
>         m_state->SwitchFromSleep (delayUntilCcaEnd);
>         break;
>       }
>     default:
>       {
>         NS_ASSERT (false);
>         break;
>       }
>     }
> }
> 
> void
> YansWifiPhy::SetReceiveOkCallback (RxOkCallback callback)
> {
>   m_state->SetReceiveOkCallback (callback);
> }
> 
> void
> YansWifiPhy::SetReceiveErrorCallback (RxErrorCallback callback)
> {
>   m_state->SetReceiveErrorCallback (callback);
> }
> 
> void
> YansWifiPhy::StartReceivePreambleAndHeader (Ptr<Packet> packet,
>                                             double rxPowerDbm,
>                                             WifiTxVector txVector,
>                                             enum WifiPreamble preamble,
>                                             enum mpduType mpdutype,
>                                             Time rxDuration)
> {
>   //This function should be later split to check separately whether plcp preamble and plcp header can be successfully received.
>   //Note: plcp preamble reception is not yet modeled.
>   NS_LOG_FUNCTION (this << packet << rxPowerDbm << txVector.GetMode () << preamble << (uint32_t)mpdutype);
>   AmpduTag ampduTag;
>   rxPowerDbm += GetRxGain ();
>   double rxPowerW = DbmToW (rxPowerDbm);
>   Time endRx = Simulator::Now () + rxDuration;
>   Time preambleAndHeaderDuration = CalculatePlcpPreambleAndHeaderDuration (txVector, preamble);
> 
>   Ptr<InterferenceHelper::Event> event;
>   event = m_interference.Add (packet->GetSize (),
>                               txVector,
>                               preamble,
>                               rxDuration,
>                               rxPowerW);
> 
>   switch (m_state->GetState ())
>     {
>     case YansWifiPhy::SWITCHING:
>       NS_LOG_DEBUG ("drop packet because of channel switching");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
>       /*
>        * Packets received on the upcoming channel are added to the event list
>        * during the switching state. This way the medium can be correctly sensed
>        * when the device listens to the channel for the first time after the
>        * switching e.g. after channel switching, the channel may be sensed as
>        * busy due to other devices' tramissions started before the end of
>        * the switching.
>        */
>       if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
>         {
>           //that packet will be noise _after_ the completion of the
>           //channel switching.
>           goto maybeCcaBusy;
>         }
>       break;
>     case YansWifiPhy::RX:
>       NS_LOG_DEBUG ("drop packet because already in Rx (power=" <<
>                     rxPowerW << "W)");
>       NotifyRxDrop (packet);
>       if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
>         {
>           //that packet will be noise _after_ the reception of the
>           //currently-received packet.
>           goto maybeCcaBusy;
>         }
>       break;
>     case YansWifiPhy::TX:
>       NS_LOG_DEBUG ("drop packet because already in Tx (power=" <<
>                     rxPowerW << "W)");
>       NotifyRxDrop (packet);
>       if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
>         {
>           //that packet will be noise _after_ the transmission of the
>           //currently-transmitted packet.
>           goto maybeCcaBusy;
>         }
>       break;
>     case YansWifiPhy::CCA_BUSY:
>     case YansWifiPhy::IDLE:
>       if (rxPowerW > GetEdThresholdW ()) //checked here, no need to check in the payload reception (current implementation assumes constant rx power over the packet duration)
>         {
>           if (preamble == WIFI_PREAMBLE_NONE && (m_mpdusNum == 0 || m_plcpSuccess == false))
>             {
>               m_plcpSuccess = false;
>               m_mpdusNum = 0;
>               NS_LOG_DEBUG ("drop packet because no PLCP preamble/header has been received");
>               NotifyRxDrop (packet);
>               goto maybeCcaBusy;
>             }
>           else if (preamble != WIFI_PREAMBLE_NONE && packet->PeekPacketTag (ampduTag) && m_mpdusNum == 0)
>             {
>               //received the first MPDU in an MPDU
>               m_mpdusNum = ampduTag.GetRemainingNbOfMpdus ();
>               m_rxMpduReferenceNumber++;
>             }
>           else if (preamble == WIFI_PREAMBLE_NONE && packet->PeekPacketTag (ampduTag) && m_mpdusNum > 0)
>             {
>               //received the other MPDUs that are part of the A-MPDU
>               if (ampduTag.GetRemainingNbOfMpdus () < (m_mpdusNum - 1))
>                 {
>                   NS_LOG_DEBUG ("Missing MPDU from the A-MPDU " << m_mpdusNum - ampduTag.GetRemainingNbOfMpdus ());
>                   m_mpdusNum = ampduTag.GetRemainingNbOfMpdus ();
>                 }
>               else
>                 {
>                   m_mpdusNum--;
>                 }
>             }
>           else if (preamble != WIFI_PREAMBLE_NONE && packet->PeekPacketTag (ampduTag) && m_mpdusNum > 0)
>             {
>               NS_LOG_DEBUG ("New A-MPDU started while " << m_mpdusNum << " MPDUs from previous are lost");
>               m_mpdusNum = ampduTag.GetRemainingNbOfMpdus ();
>             }
>           else if (preamble != WIFI_PREAMBLE_NONE && m_mpdusNum > 0 )
>             {
>               NS_LOG_DEBUG ("Didn't receive the last MPDUs from an A-MPDU " << m_mpdusNum);
>               m_mpdusNum = 0;
>             }
> 
>           NS_LOG_DEBUG ("sync to signal (power=" << rxPowerW << "W)");
>           //sync to signal
>           m_state->SwitchToRx (rxDuration);
>           NS_ASSERT (m_endPlcpRxEvent.IsExpired ());
>           NotifyRxBegin (packet);
>           m_interference.NotifyRxStart ();
> 
>           if (preamble != WIFI_PREAMBLE_NONE)
>             {
>               NS_ASSERT (m_endPlcpRxEvent.IsExpired ());
>               m_endPlcpRxEvent = Simulator::Schedule (preambleAndHeaderDuration, &YansWifiPhy::StartReceivePacket, this,
>                                                       packet, txVector, preamble, mpdutype, event);
>             }
> 
>           NS_ASSERT (m_endRxEvent.IsExpired ());
>           m_endRxEvent = Simulator::Schedule (rxDuration, &YansWifiPhy::EndReceive, this,
>                                               packet, preamble, mpdutype, event);
>         }
>       else
>         {
>           NS_LOG_DEBUG ("drop packet because signal power too Small (" <<
>                         rxPowerW << "<" << GetEdThresholdW () << ")");
>           NotifyRxDrop (packet);
>           m_plcpSuccess = false;
>           goto maybeCcaBusy;
>         }
>       break;
>     case YansWifiPhy::SLEEP:
>       NS_LOG_DEBUG ("drop packet because in sleep mode");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
>       break;
>     }
> 
>   return;
> 
> maybeCcaBusy:
>   //We are here because we have received the first bit of a packet and we are
>   //not going to be able to synchronize on it
>   //In this model, CCA becomes busy when the aggregation of all signals as
>   //tracked by the InterferenceHelper class is higher than the CcaBusyThreshold
> 
>   Time delayUntilCcaEnd = m_interference.GetEnergyDuration (DbmToW (GetCcaMode1Threshold ()));
>   if (!delayUntilCcaEnd.IsZero ())
>     {
>       m_state->SwitchMaybeToCcaBusy (delayUntilCcaEnd);
>     }
> }
> 
> void
> YansWifiPhy::StartReceivePacket (Ptr<Packet> packet,
>                                  WifiTxVector txVector,
>                                  enum WifiPreamble preamble,
>                                  enum mpduType mpdutype,
>                                  Ptr<InterferenceHelper::Event> event)
> {
>   NS_LOG_FUNCTION (this << packet << txVector.GetMode () << preamble << (uint32_t)mpdutype);
>   NS_ASSERT (IsStateRx ());
>   NS_ASSERT (m_endPlcpRxEvent.IsExpired ());
>   WifiMode txMode = txVector.GetMode ();
> 
>   struct InterferenceHelper::SnrPer snrPer;
>   snrPer = m_interference.CalculatePlcpHeaderSnrPer (event);
> 
>   NS_LOG_DEBUG ("snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per);
> 
>   if (m_random->GetValue () > snrPer.per) //plcp reception succeeded
>     {
>       if (IsModeSupported (txMode) || IsMcsSupported (txMode))
>         {
>           NS_LOG_DEBUG ("receiving plcp payload"); //endReceive is already scheduled
>           m_plcpSuccess = true;
>         }
>       else //mode is not allowed
>         {
>           NS_LOG_DEBUG ("drop packet because it was sent using an unsupported mode (" << txMode << ")");
>           NotifyRxDrop (packet);
>           m_plcpSuccess = false;
>         }
>     }
>   else //plcp reception failed
>     {
>       NS_LOG_DEBUG ("drop packet because plcp preamble/header reception failed");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
>     }
> }
> 
> void
> YansWifiPhy::SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, WifiPreamble preamble)
> {
>   SendPacket (packet, txVector, preamble, NORMAL_MPDU);
> }
> 
> void
> YansWifiPhy::SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, WifiPreamble preamble, enum mpduType mpdutype)
80,83c465,579
<   NS_LOG_FUNCTION (this << ppdu);
<   WifiTxVector txVector = ppdu->GetTxVector ();
<   NS_LOG_DEBUG ("Start transmission: signal power before antenna gain=" << GetPowerDbm (txVector.GetTxPowerLevel ()) << "dBm");
<   m_channel->Send (this, ppdu, GetTxPowerForTransmission (txVector) + GetTxGain ());
---
>   NS_LOG_FUNCTION (this << packet << txVector.GetMode () 
>     << txVector.GetMode ().GetDataRate (txVector)
>     << preamble << (uint32_t)txVector.GetTxPowerLevel () << (uint32_t)mpdutype);
>   /* Transmission can happen if:
>    *  - we are syncing on a packet. It is the responsability of the
>    *    MAC layer to avoid doing this but the PHY does nothing to
>    *    prevent it.
>    *  - we are idle
>    */
>   NS_ASSERT (!m_state->IsStateTx () && !m_state->IsStateSwitching ());
> 
>   if (m_state->IsStateSleep ())
>     {
>       NS_LOG_DEBUG ("Dropping packet because in sleep mode");
>       NotifyTxDrop (packet);
>       return;
>     }
> 
>   Time txDuration = CalculateTxDuration (packet->GetSize (), txVector, preamble, GetFrequency (), mpdutype, 1);
>   NS_ASSERT (txDuration > NanoSeconds (0));
> 
>   if (m_state->IsStateRx ())
>     {
>       m_endPlcpRxEvent.Cancel ();
>       m_endRxEvent.Cancel ();
>       m_interference.NotifyRxEnd ();
>     }
>   NotifyTxBegin (packet);
>   uint32_t dataRate500KbpsUnits;
>   if (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT || txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT)
>     {
>       dataRate500KbpsUnits = 128 + txVector.GetMode ().GetMcsValue ();
>     }
>   else
>     {
>       dataRate500KbpsUnits = txVector.GetMode ().GetDataRate (txVector.GetChannelWidth (), txVector.IsShortGuardInterval (), 1) * txVector.GetNss () / 500000;
>     }
>   if (mpdutype == MPDU_IN_AGGREGATE && preamble != WIFI_PREAMBLE_NONE)
>     {
>       //send the first MPDU in an MPDU
>       m_txMpduReferenceNumber++;
>     }
>   struct mpduInfo aMpdu;
>   aMpdu.type = mpdutype;
>   aMpdu.mpduRefNumber = m_txMpduReferenceNumber;
>   NotifyMonitorSniffTx (packet, (uint16_t)GetFrequency (), GetChannelNumber (), dataRate500KbpsUnits, preamble, txVector, aMpdu);
>   m_state->SwitchToTx (txDuration, packet, GetPowerDbm (txVector.GetTxPowerLevel ()), txVector, preamble);
>   m_channel->Send (this, packet, GetPowerDbm (txVector.GetTxPowerLevel ()) + GetTxGain (), txVector, preamble, mpdutype, txDuration);
> }
> 
> void
> YansWifiPhy::RegisterListener (WifiPhyListener *listener)
> {
>   m_state->RegisterListener (listener);
> }
> 
> void
> YansWifiPhy::UnregisterListener (WifiPhyListener *listener)
> {
>   m_state->UnregisterListener (listener);
> }
> 
> void
> YansWifiPhy::EndReceive (Ptr<Packet> packet, enum WifiPreamble preamble, enum mpduType mpdutype, Ptr<InterferenceHelper::Event> event)
> {
>   NS_LOG_FUNCTION (this << packet << event);
>   NS_ASSERT (IsStateRx ());
>   NS_ASSERT (event->GetEndTime () == Simulator::Now ());
> 
>   struct InterferenceHelper::SnrPer snrPer;
>   snrPer = m_interference.CalculatePlcpPayloadSnrPer (event);
>   m_interference.NotifyRxEnd ();
> 
>   if (m_plcpSuccess == true)
>     {
>       NS_LOG_DEBUG ("mode=" << (event->GetPayloadMode ().GetDataRate (event->GetTxVector ())) <<
>                     ", snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per << ", size=" << packet->GetSize ());
> 
>       if (m_random->GetValue () > snrPer.per)
>         {
>           NotifyRxEnd (packet);
>           uint32_t dataRate500KbpsUnits;
>           if ((event->GetPayloadMode ().GetModulationClass () == WIFI_MOD_CLASS_HT) || (event->GetPayloadMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT))
>             {
>               dataRate500KbpsUnits = 128 + event->GetPayloadMode ().GetMcsValue ();
>             }
>           else
>             {
>               dataRate500KbpsUnits = event->GetPayloadMode ().GetDataRate (event->GetTxVector ().GetChannelWidth (), event->GetTxVector ().IsShortGuardInterval (), 1) * event->GetTxVector ().GetNss () / 500000;
>             }
>           struct signalNoiseDbm signalNoise;
>           signalNoise.signal = RatioToDb (event->GetRxPowerW ()) + 30;
>           signalNoise.noise = RatioToDb (event->GetRxPowerW () / snrPer.snr) - GetRxNoiseFigure () + 30;
>           struct mpduInfo aMpdu;
>           aMpdu.type = mpdutype;
>           aMpdu.mpduRefNumber = m_rxMpduReferenceNumber;
>           NotifyMonitorSniffRx (packet, (uint16_t)GetFrequency (), GetChannelNumber (), dataRate500KbpsUnits, event->GetPreambleType (), event->GetTxVector (), aMpdu, signalNoise);
>           m_state->SwitchFromRxEndOk (packet, snrPer.snr, event->GetTxVector (), event->GetPreambleType ());
>         }
>       else
>         {
>           /* failure. */
>           NotifyRxDrop (packet);
>           m_state->SwitchFromRxEndError (packet, snrPer.snr);
>         }
>     }
>   else
>     {
>       m_state->SwitchFromRxEndError (packet, snrPer.snr);
>     }
> 
>   if (preamble == WIFI_PREAMBLE_NONE && mpdutype == LAST_MPDU_IN_AGGREGATE)
>     {
>       m_plcpSuccess = false;
>     }
diff ../../NS3-WiGig/src/wifi/model/yans-wifi-phy.h ../../ns-3-dev/src/wifi/model/yans-wifi-phy.h
31d30
< class WifiPpdu;
51,54d49
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
60,63d54
<   // Implementation of pure virtual method.
<   void StartTx (Ptr<WifiPpdu> ppdu);
<   virtual Ptr<Channel> GetChannel (void) const;
< 
69c60,101
<   void SetChannel (const Ptr<YansWifiChannel> channel);
---
>   void SetChannel (Ptr<YansWifiChannel> channel);
> 
>   /**
>    * Starting receiving the plcp of a packet (i.e. the first bit of the preamble has arrived).
>    *
>    * \param packet the arriving packet
>    * \param rxPowerDbm the receive power in dBm
>    * \param txVector the TXVECTOR of the arriving packet
>    * \param preamble the preamble of the arriving packet
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
>    * \param rxDuration the duration needed for the reception of the packet
>    */
>   void StartReceivePreambleAndHeader (Ptr<Packet> packet,
>                                       double rxPowerDbm,
>                                       WifiTxVector txVector,
>                                       WifiPreamble preamble,
>                                       enum mpduType mpdutype,
>                                       Time rxDuration);
>   /**
>    * Starting receiving the payload of a packet (i.e. the first bit of the packet has arrived).
>    *
>    * \param packet the arriving packet
>    * \param txVector the TXVECTOR of the arriving packet
>    * \param preamble the preamble of the arriving packet
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
>    * \param event the corresponding event of the first time the packet arrives
>    */
>   void StartReceivePacket (Ptr<Packet> packet,
>                            WifiTxVector txVector,
>                            WifiPreamble preamble,
>                            enum mpduType mpdutype,
>                            Ptr<InterferenceHelper::Event> event);
> 
>   virtual void SetReceiveOkCallback (WifiPhy::RxOkCallback callback);
>   virtual void SetReceiveErrorCallback (WifiPhy::RxErrorCallback callback);
>   virtual void SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, enum WifiPreamble preamble);
>   virtual void SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, enum WifiPreamble preamble, enum mpduType mpdutype);
>   virtual void RegisterListener (WifiPhyListener *listener);
>   virtual void UnregisterListener (WifiPhyListener *listener);
>   virtual void SetSleepMode (void);
>   virtual void ResumeFromSleep (void);
>   virtual Ptr<WifiChannel> GetChannel (void) const;
74c106,107
< 
---
>   virtual bool DoChannelSwitch (uint16_t id);
>   virtual bool DoFrequencySwitch (uint32_t frequency);
77c110,120
<   Ptr<YansWifiChannel> m_channel; //!< YansWifiChannel that this YansWifiPhy is connected to
---
>   /**
>    * The last bit of the packet has arrived.
>    *
>    * \param packet the packet that the last bit has arrived
>    * \param preamble the preamble of the arriving packet
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::mpduType.
>    * \param event the corresponding event of the first time the packet arrives
>    */
>   void EndReceive (Ptr<Packet> packet, enum WifiPreamble preamble, enum mpduType mpdutype, Ptr<InterferenceHelper::Event> event);
> 
>   Ptr<YansWifiChannel> m_channel;        //!< YansWifiChannel that this YansWifiPhy is connected to
