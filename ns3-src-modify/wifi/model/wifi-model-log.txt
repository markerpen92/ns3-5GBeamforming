diff ../../NS3-WiGig/src/wifi/model/aarfcd-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/aarfcd-wifi-manager.cc
45a46
>   uint32_t m_retry; ///< retry
89c90
<                    "Minimum value for RTS window of AARF-CD",
---
>                    "Minimum value for Rts window of Aarf-CD",
94c95
<                    "Maximum value for RTS window of AARF-CD",
---
>                    "Maximum value for Rts window of Aarf-CD",
128,145d128
< void
< AarfcdWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
152c135
<   //AARF fields below
---
>   //aarf fields below
158a142
>   station->m_retry = 0;
161c145
<   //AARF-CD specific fields below
---
>   //aarf-cd specific fields below
181c165
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *)st;
183a168
>   station->m_retry++;
198c183
<       if (station->m_failed >= 2)
---
>       if (station->m_retry >= 2)
205c190
<       NS_ASSERT (station->m_failed >= 1);
---
>       NS_ASSERT (station->m_retry >= 1);
208c193
<       if (station->m_failed == 1)
---
>       if (station->m_retry == 1)
229c214
<       NS_ASSERT (station->m_failed >= 1);
---
>       NS_ASSERT (station->m_retry >= 1);
232c217
<       if (((station->m_failed - 1) % 2) == 1)
---
>       if (((station->m_retry - 1) % 2) == 1)
247c232
<       if (station->m_failed >= 2)
---
>       if (station->m_retry >= 2)
267c252
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
273,274c258,259
< AarfcdWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                    double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> AarfcdWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                    double ackSnr, WifiMode ackMode, double dataSnr)
276,277c261,262
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
281a267
>   station->m_retry = 0;
321c307
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
324a311
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
333c320
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
340c327
<   /// \todo we could/should implement the AARF algorithm for
---
>   /// \todo we could/should implement the Aarf algorithm for
342c329
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
345a333
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
358c346
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
364c352
<                               uint32_t size, bool normally)
---
>                               Ptr<const Packet> packet, bool normally)
366,367c354,355
<   NS_LOG_FUNCTION (this << st << size << normally);
<   AarfcdWifiRemoteStation *station = static_cast<AarfcdWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << packet << normally);
>   AarfcdWifiRemoteStation *station = (AarfcdWifiRemoteStation *) st;
372a361,366
> bool
> AarfcdWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
418a413,442
> }
> 
> void
> AarfcdWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> AarfcdWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> AarfcdWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/aarfcd-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/aarfcd-wifi-manager.h
40c40
<  * This RAA does not support HT modes and will error
---
>  * This RAA does not support HT, VHT nor HE modes and will error
42c42
<  * that supports 802.11n or higher.
---
>  * that has VhtSupported, HtSupported or HeSupported set.
54a55,58
>   // Inherited from WifiRemoteStationManager
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
57,58c61
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   // overridden from base class
73c76
<    * \param station the station that we failed to send Data
---
>    * \param station the station that we failed to send DATA
78,79c81,82
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
85c88,89
<                   uint32_t size, bool normally);
---
>                   Ptr<const Packet> packet, bool normally);
>   bool IsLowLatency (void) const;
118,119c122,123
<   //AARF fields below
<   uint32_t m_minTimerThreshold;   ///< minimum timer threshold
---
>   //aarf fields below
>   uint32_t m_minTimerThreshold; ///< minimum timer threshold
121c125
<   double m_successK;              ///< Multiplication factor for the success threshold
---
>   double m_successK; ///< Multiplication factor for the success threshold
123c127
<   double m_timerK;                ///< Multiplication factor for the timer threshold
---
>   double m_timerK; ///< Multiplication factor for the timer threshold
125,127c129,131
<   //AARF-CD fields below
<   uint32_t m_minRtsWnd;               ///< minimum RTS window
<   uint32_t m_maxRtsWnd;               ///< maximum RTS window
---
>   //aarf-cd fields below
>   uint32_t m_minRtsWnd; ///< minimum RTS window
>   uint32_t m_maxRtsWnd; ///< maximum RTS window
129c133
<   bool m_turnOnRtsAfterRateIncrease;  ///< turn on RTS after rate increase
---
>   bool m_turnOnRtsAfterRateIncrease; ///< turn on RTS after rate increase
diff ../../NS3-WiGig/src/wifi/model/aarf-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/aarf-wifi-manager.cc
43a44
>   uint32_t m_retry; ///< retry
102,119d102
< void
< AarfWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
131a115
>   station->m_retry = 0;
151c135
<  * \param st the station that we failed to send Data
---
>  * \param st the station that we failed to send DATA
157c141
<   AarfWifiRemoteStation *station = static_cast<AarfWifiRemoteStation*> (st);
---
>   AarfWifiRemoteStation *station = (AarfWifiRemoteStation *)st;
159a144
>   station->m_retry++;
164,165c149,150
<       NS_ASSERT (station->m_failed >= 1);
<       if (station->m_failed == 1)
---
>       NS_ASSERT (station->m_retry >= 1);
>       if (station->m_retry == 1)
181,182c166,167
<       NS_ASSERT (station->m_failed >= 1);
<       if (((station->m_failed - 1) % 2) == 1)
---
>       NS_ASSERT (station->m_retry >= 1);
>       if (((station->m_retry - 1) % 2) == 1)
192c177
<       if (station->m_failed >= 2)
---
>       if (station->m_retry >= 2)
215,216c200,201
< AarfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> AarfWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                  double ackSnr, WifiMode ackMode, double dataSnr)
218,219c203,204
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   AarfWifiRemoteStation *station = static_cast<AarfWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   AarfWifiRemoteStation *station = (AarfWifiRemoteStation *) st;
223a209
>   station->m_retry = 0;
253c239
<   AarfWifiRemoteStation *station = static_cast<AarfWifiRemoteStation*> (st);
---
>   AarfWifiRemoteStation *station = (AarfWifiRemoteStation *) st;
256a243
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
265c252
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
272c259
<   /// \todo we could/should implement the AARF algorithm for
---
>   /// \todo we could/should implement the Aarf algorithm for
274c261
<   AarfWifiRemoteStation *station = static_cast<AarfWifiRemoteStation*> (st);
---
>   AarfWifiRemoteStation *station = (AarfWifiRemoteStation *) st;
277a265
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
290c278
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
291a280,315
> }
> 
> bool
> AarfWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
> void
> AarfWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> AarfWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> AarfWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/aarf-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/aarf-wifi-manager.h
38c38
<  * This RAA does not support HT modes and will error
---
>  * This RAA does not support HT, VHT nor HE modes and will error
40c40
<  * that supports 802.11n or higher.
---
>  * that has VhtSupported, HtSupported or HeSupported set.
52a53,56
>   // Inherited from WifiRemoteStationManager
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
55,56c59
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
64,65c67,68
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
69a73
>   bool IsLowLatency (void) const;
71c75
<   uint32_t m_minTimerThreshold;   ///< minimum timer threshold
---
>   uint32_t m_minTimerThreshold; ///< minimum timer threshold
73c77
<   double m_successK;              ///< Multiplication factor for the success threshold
---
>   double m_successK; ///< Multiplication factor for the success threshold
75c79
<   double m_timerK;                ///< Multiplication factor for the timer threshold
---
>   double m_timerK; ///< Multiplication factor for the timer threshold
diff ../../NS3-WiGig/src/wifi/model/adhoc-wifi-mac.cc ../../ns-3-dev-git/src/wifi/model/adhoc-wifi-mac.cc
75c75
< AdhocWifiMac::Enqueue (Ptr<Packet> packet, Mac48Address to)
---
> AdhocWifiMac::Enqueue (Ptr<const Packet> packet, Mac48Address to)
80,81c80,82
<       //In ad hoc mode, we assume that every destination supports all the rates we support.
<       if (GetHtSupported ())
---
>       //In ad hoc mode, we assume that every destination supports all
>       //the rates we support.
>       if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
83a85,87
>         }
>       if (GetHtSupported ())
>         {
136c140
<   if (GetHtSupported ())
---
>   if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
138c142
<       hdr.SetNoOrder (); // explicitly set to 0 for the time being since HT control field is not yet implemented (set it to 1 when implemented)
---
>       hdr.SetNoOrder (); // explicitly set to 0 for the time being since HT/VHT/HE control field is not yet implemented (set it to 1 when implemented)
170,184d173
< Ptr<MultiBandElement>
< AdhocWifiMac::GetMultiBandElement (void) const
< {
<   Ptr<MultiBandElement> multiband = Create<MultiBandElement> ();
<   multiband->SetStaRole (ROLE_IBSS_STA);
<   multiband->SetStaMacAddressPresent (false); /* The same MAC address is used across all the bands */
<   multiband->SetBandID (Band_60GHz);
<   multiband->SetOperatingClass (18);          /* Europe */
<   multiband->SetChannelNumber (1);
<   multiband->SetBssID (GetAddress ());
<   multiband->SetConnectionCapability (1);     /* AP */
<   multiband->SetFstSessionTimeout (1);
<   return multiband;
< }
< 
186c175
< AdhocWifiMac::Receive (Ptr<WifiMacQueueItem> mpdu)
---
> AdhocWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
188,189c177
<   NS_LOG_FUNCTION (this << *mpdu);
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
---
>   NS_LOG_FUNCTION (this << packet << hdr);
195,196c183,185
<       //In ad hoc mode, we assume that every destination supports all the rates we support.
<       if (GetHtSupported ())
---
>       //In ad hoc mode, we assume that every destination supports all
>       //the rates we support.
>       if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
200a190,193
>       if (GetHtSupported ())
>         {
>           m_stationManager->AddStationHtCapabilities (from, GetHtCapabilities ());
>         }
217c210
<           DeaggregateAmsduAndForward (mpdu);
---
>           DeaggregateAmsduAndForward (packet, hdr);
221c214
<           ForwardUp (mpdu->GetPacket ()->Copy (), from, to);
---
>           ForwardUp (packet, from, to);
229c222
<   RegularWifiMac::Receive (mpdu);
---
>   RegularWifiMac::Receive (packet, hdr);
diff ../../NS3-WiGig/src/wifi/model/adhoc-wifi-mac.h ../../ns-3-dev-git/src/wifi/model/adhoc-wifi-mac.h
33c33
<  * \brief Wifi MAC high model for an ad-hoc Wifi MAC
---
>  *
47c47,49
<   // Implementations of pure virtual methods, or overridden from base class.
---
>   /**
>    * \param address the current address of this MAC layer.
>    */
48a51,54
> 
>   /**
>    * \param linkUp the callback to invoke when the link becomes up.
>    */
50d55
<   void Enqueue (Ptr<Packet> packet, Mac48Address to);
52,53c57,66
< protected:
<   Ptr<MultiBandElement> GetMultiBandElement (void) const;
---
>   /**
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
>    *
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.
>    */
>   void Enqueue (Ptr<const Packet> packet, Mac48Address to);
> 
56c69
<   void Receive (Ptr<WifiMacQueueItem> mpdu);
---
>   void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
diff ../../NS3-WiGig/src/wifi/model/ampdu-subframe-header.cc ../../ns-3-dev-git/src/wifi/model/ampdu-subframe-header.cc
47,48c47
<     m_eof (0),
<     m_signature (0x4E) // Per 802.11 standard, the unique pattern is set to the value 0x4E.
---
>     m_eof (0)
67c66
<   i.WriteU8 (m_signature);
---
>   i.WriteU8 (0x4E); // Per 802.11 standard, the unique pattern is set to the value 0x4E.
78c77
<   m_signature = i.ReadU8 (); //SIG
---
>   i.ReadU8 (); //SIG
85,86c84
<   os << "EOF = " << m_eof << ", length = " << m_length
<      << ", signature = 0x" << std::hex << m_signature;
---
>   os << "EOF = " << m_eof << ", length = " << m_length;
111,116d108
< }
< 
< bool
< AmpduSubframeHeader::IsSignatureValid (void) const
< {
<   return m_signature == 0x4E;
diff ../../NS3-WiGig/src/wifi/model/ampdu-subframe-header.h ../../ns-3-dev-git/src/wifi/model/ampdu-subframe-header.h
1,91c1,81
< /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
< /*
<  * Copyright (c) 2013
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License version 2 as
<  * published by the Free Software Foundation;
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
<  *
<  * Author: Ghada Badawy <gbadawy@gmail.com>
<  */
< 
< #ifndef AMPDU_SUBFRAME_HEADER_H
< #define AMPDU_SUBFRAME_HEADER_H
< 
< #include "ns3/header.h"
< 
< namespace ns3 {
< 
< /**
<  * \ingroup wifi
<  * \brief Headers for A-MPDU subframes
<  */
< class AmpduSubframeHeader : public Header
< {
< public:
<   AmpduSubframeHeader ();
<   virtual ~AmpduSubframeHeader ();
< 
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
<   static TypeId GetTypeId (void);
< 
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the length field.
<    *
<    * \param length in bytes
<    */
<   void SetLength (uint16_t length);
<   /**
<   * Set the EOF field.
<   *
<   * \param eof set EOF field if true
<   */
<   void SetEof (bool eof);
<   /**
<    * Return the length field.
<    *
<    * \return the length field in bytes
<    */
<   uint16_t GetLength (void) const;
<   /**
<    * Return the EOF field.
<    *
<    * \return the EOF field
<    */
<   bool GetEof (void) const;
<   /**
<    * Return whether the pattern stored in the delimiter
<    * signature field is correct, i.e. corresponds to the
<    * unique pattern 0x4E.
<    *
<    * \return true if the signature is valid, false otherwise
<    */
<   bool IsSignatureValid (void) const;
< 
< private:
<   uint16_t m_length;   //!< length field in bytes
<   bool m_eof;          //!< EOF field
<   uint8_t m_signature; //!< delimiter signature (should correspond to pattern 0x4E in order to be assumed valid)
< };
< 
< } //namespace ns3
< 
< #endif /* AMPDU_SUBFRAME_HEADER_H */
---
> /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
> /*
>  * Copyright (c) 2013
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License version 2 as
>  * published by the Free Software Foundation;
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
>  *
>  * Author: Ghada Badawy <gbadawy@gmail.com>
>  */
> 
> #ifndef AMPDU_SUBFRAME_HEADER_H
> #define AMPDU_SUBFRAME_HEADER_H
> 
> #include "ns3/header.h"
> 
> namespace ns3 {
> 
> /**
>  * \ingroup wifi
>  */
> class AmpduSubframeHeader : public Header
> {
> public:
>   AmpduSubframeHeader ();
>   virtual ~AmpduSubframeHeader ();
> 
>   /**
>    * \brief Get the type ID.
>    * \return the object TypeId
>    */
>   static TypeId GetTypeId (void);
> 
>   TypeId GetInstanceTypeId (void) const;
>   void Print (std::ostream &os) const;
>   uint32_t GetSerializedSize (void) const;
>   void Serialize (Buffer::Iterator start) const;
>   uint32_t Deserialize (Buffer::Iterator start);
> 
>   /**
>    * Set the length field.
>    *
>    * \param length
>    */
>   void SetLength (uint16_t length);
>   /**
>   * Set the EOF field.
>   *
>   * \param eof
>   */
>   void SetEof (bool eof);
>   /**
>    * Return the length field.
>    *
>    * \return the length field
>    */
>   uint16_t GetLength (void) const;
>   /**
>    * Return the EOF field.
>    *
>    * \return the EOF field
>    */
>   bool GetEof (void) const;
> 
> private:
>   uint16_t m_length; //!< length field
>   bool m_eof;        //!< EOF field
> };
> 
> } //namespace ns3
> 
> #endif /* AMPDU_SUBFRAME_HEADER_H */
diff ../../NS3-WiGig/src/wifi/model/ampdu-tag.cc ../../ns-3-dev-git/src/wifi/model/ampdu-tag.cc
52c52
< AmpduTag::SetRemainingNbOfMpdus (uint8_t nbOfMpdus)
---
> AmpduTag::SetRemainingNbOfMpdus (uint8_t nbofmpdus)
54c54,55
<   m_nbOfMpdus = nbOfMpdus;
---
>   NS_ASSERT (nbofmpdus <= 64);
>   m_nbOfMpdus = nbofmpdus;
67c68
<   return (1 + sizeof (Time));
---
>   return (2 + sizeof (Time));
83c84
<   i.Read ((uint8_t *)&duration, sizeof(int64_t));
---
>   i.Read ((uint8_t *)&duration, 8);
diff ../../NS3-WiGig/src/wifi/model/ampdu-tag.h ../../ns-3-dev-git/src/wifi/model/ampdu-tag.h
1,89c1,89
< /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
< /*
<  * Copyright (c) 2013
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License version 2 as
<  * published by the Free Software Foundation;
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
<  *
<  * Authors: Ghada Badawy <gbadawy@gmail.com>
<  *          Sébastien Deronne <sebastien.deronne@gmail.com>
<  */
< 
< #ifndef AMPDU_TAG_H
< #define AMPDU_TAG_H
< 
< #include "ns3/nstime.h"
< #include "ns3/tag.h"
< 
< namespace ns3 {
< 
< /**
<  * \ingroup wifi
<  *
<  * The aim of the AmpduTag is to provide means for a MAC to specify that a packet includes A-MPDU
<  * since this is done in HT-SIG and there is no HT-SIG representation in ns-3
<  */
< class AmpduTag : public Tag
< {
< public:
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
<   static TypeId GetTypeId (void);
<   TypeId GetInstanceTypeId (void) const;
< 
<   /**
<    * Create a AmpduTag with the default =0 no A-MPDU
<    */
<   AmpduTag ();
<   /**
<    * \param nbOfMpdus the remaining number of MPDUs
<    *
<    * Set the remaining number of MPDUs in the A-MPDU.
<    */
<   void SetRemainingNbOfMpdus (uint8_t nbOfMpdus);
<   /**
<    * \param duration the remaining duration of the A-MPDU
<    *
<    * Set the remaining duration of the A-MPDU.
<    */
<   void SetRemainingAmpduDuration (Time duration);
< 
<   void Serialize (TagBuffer i) const;
<   void Deserialize (TagBuffer i);
<   uint32_t GetSerializedSize () const;
<   void Print (std::ostream &os) const;
< 
<   /**
<    * \return the remaining number of MPDUs in an A-MPDU
<    *
<    * Returns the remaining number of MPDUs in an A-MPDU
<    */
<   uint8_t GetRemainingNbOfMpdus (void) const;
<   /**
<    * \return the remaining duration of an A-MPDU
<    *
<    * Returns the remaining duration of an A-MPDU
<    */
<   Time GetRemainingAmpduDuration (void) const;
< 
< 
< private:
<   uint8_t m_nbOfMpdus; //!< Remaining number of MPDUs in the A-MPDU
<   Time m_duration;     //!< Remaining duration of the A-MPDU
< };
< 
< } //namespace ns3
< 
< #endif /* AMPDU_TAG_H */
---
> /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
> /*
>  * Copyright (c) 2013
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License version 2 as
>  * published by the Free Software Foundation;
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
>  *
>  * Authors: Ghada Badawy <gbadawy@gmail.com>
>  *          Sébastien Deronne <sebastien.deronne@gmail.com>
>  */
> 
> #ifndef AMPDU_TAG_H
> #define AMPDU_TAG_H
> 
> #include "ns3/nstime.h"
> #include "ns3/tag.h"
> 
> namespace ns3 {
> 
> /**
>  * \ingroup wifi
>  *
>  * The aim of the AmpduTag is to provide means for a MAC to specify that a packet includes A-MPDU
>  * since this is done in HT-SIG and there is no HT-SIG representation in ns-3
>  */
> class AmpduTag : public Tag
> {
> public:
>   /**
>    * \brief Get the type ID.
>    * \return the object TypeId
>    */
>   static TypeId GetTypeId (void);
>   TypeId GetInstanceTypeId (void) const;
> 
>   /**
>    * Create a AmpduTag with the default =0 no Ampdu
>    */
>   AmpduTag ();
>   /**
>    * \param nbofmpdus the remaining number of MPDUs
>    *
>    * Set the remaining number of MPDUs in the A-MPDU.
>    */
>   void SetRemainingNbOfMpdus (uint8_t nbofmpdus);
>   /**
>    * \param duration the remaining duration of the A-MPDU
>    *
>    * Set the remaining duration of the A-MPDU.
>    */
>   void SetRemainingAmpduDuration (Time duration);
> 
>   void Serialize (TagBuffer i) const;
>   void Deserialize (TagBuffer i);
>   uint32_t GetSerializedSize () const;
>   void Print (std::ostream &os) const;
> 
>   /**
>    * \return the remaining number of MPDUs in an A-MPDU
>    *
>    * Returns the remaining number of MPDUs in an A-MPDU
>    */
>   uint8_t GetRemainingNbOfMpdus (void) const;
>   /**
>    * \return the remaining duration of an A-MPDU
>    *
>    * Returns the remaining duration of an A-MPDU
>    */
>   Time GetRemainingAmpduDuration (void) const;
> 
> 
> private:
>   uint8_t m_nbOfMpdus; //!< Remaining number of MPDUs in the A-MPDU
>   Time m_duration;     //!< Remaining duration of the A-MPDU in nanoseconds
> };
> 
> } //namespace ns3
> 
> #endif /* AMPDU_TAG_H */
diff ../../NS3-WiGig/src/wifi/model/amrr-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/amrr-wifi-manager.cc
41,45c41,45
<   uint32_t m_tx_ok;      ///< transmit OK
<   uint32_t m_tx_err;     ///< transmit error
<   uint32_t m_tx_retr;    ///< transmit retry
<   uint32_t m_retry;      ///< retry
<   uint8_t m_txrate;      ///< transmit rate
---
>   uint32_t m_tx_ok; ///< transmit ok
>   uint32_t m_tx_err; ///< transmit error
>   uint32_t m_tx_retr; ///< transmit retry
>   uint32_t m_retry; ///< retry
>   uint8_t m_txrate; ///< transmit rate
47,48c47,48
<   uint32_t m_success;    ///< success
<   bool m_recovery;       ///< recovery
---
>   uint32_t m_success; ///< success
>   bool m_recovery; ///< recovery
106,123d105
< void
< AmrrWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
158c140
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
---
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
171,172c153,154
< AmrrWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> AmrrWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                  double ackSnr, WifiMode ackMode, double dataSnr)
174,175c156,157
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
190c172
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
---
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
325c307
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
---
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
368a351
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
377c360
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
384c367
<   AmrrWifiRemoteStation *station = static_cast<AmrrWifiRemoteStation*> (st);
---
>   AmrrWifiRemoteStation *station = (AmrrWifiRemoteStation *)st;
387a371
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
401c385
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
402a387,422
> }
> 
> bool
> AmrrWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
> void
> AmrrWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> AmrrWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> AmrrWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/amrr-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/amrr-wifi-manager.h
40c40
<  * This RAA does not support HT modes and will error
---
>  * This RAA does not support HT, VHT nor HE modes and will error
42c42
<  * that supports 802.11n or higher.
---
>  * that has VhtSupported, HtSupported or HeSupported set.
55a56,60
>   // Inherited from WifiRemoteStationManager
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
> 
58,59c63
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
67,68c71,72
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
72a77
>   bool IsLowLatency (void) const;
77c82
<    * \param station the remote station state
---
>    * \param station
83c88
<    * \param station the remote station state
---
>    * \param station
89c94
<    * \param station the remote station state
---
>    * \param station
95c100
<    * \param station the remote station state
---
>    * \param station
102c107
<    * \param station the remote station state
---
>    * \param station
112c117
<    * \param station the remote station state
---
>    * \param station
122c127
<    * \param station the remote station state
---
>    * \param station
133c138
<    * \param station the remote station state
---
>    * \param station
144c149
<    * \param station the remote station state
---
>    * \param station
151,153c156,158
<   Time m_updatePeriod;            ///< update period
<   double m_failureRatio;          ///< failure ratio
<   double m_successRatio;          ///< success ratio
---
>   Time m_updatePeriod; ///< update period
>   double m_failureRatio; ///< failure ratio
>   double m_successRatio; ///< success ratio
155c160
<   uint32_t m_minSuccessThreshold; ///< minimum success threshold
---
>   uint32_t m_minSuccessThreshold; ///< mnimum success threshold
diff ../../NS3-WiGig/src/wifi/model/amsdu-subframe-header.h ../../ns-3-dev-git/src/wifi/model/amsdu-subframe-header.h
31d30
<  * \brief Headers for A-MSDU subframes
62c61
<    * \param length the length in bytes
---
>    * \param length the length
77c76
<    * \returns the length in bytes
---
>    * \returns the length
84c83
<   uint16_t m_length; ///< length in bytes
---
>   uint16_t m_length; ///< length
diff ../../NS3-WiGig/src/wifi/model/aparf-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/aparf-wifi-manager.cc
137,154d136
< void
< AparfWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
204c186
<   AparfWifiRemoteStation *station = static_cast<AparfWifiRemoteStation*> (st);
---
>   AparfWifiRemoteStation *station = (AparfWifiRemoteStation *) st;
258,259c240,241
< AparfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                   double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> AparfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr,
>                                   WifiMode ackMode, double dataSnr)
261,262c243,244
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   AparfWifiRemoteStation *station = static_cast<AparfWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   AparfWifiRemoteStation *station = (AparfWifiRemoteStation *) st;
342c324
<   AparfWifiRemoteStation *station = static_cast<AparfWifiRemoteStation*> (st);
---
>   AparfWifiRemoteStation *station = (AparfWifiRemoteStation *) st;
345a328
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
364c347
<   return WifiTxVector (mode, station->m_powerLevel, GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, station->m_powerLevel, GetPreambleForTransmission (mode, GetAddress (st)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
371c354
<   /// \todo we could/should implement the ARF algorithm for
---
>   /// \todo we could/should implement the Arf algorithm for
373c356
<   AparfWifiRemoteStation *station = static_cast<AparfWifiRemoteStation*> (st);
---
>   AparfWifiRemoteStation *station = (AparfWifiRemoteStation *) st;
376a360
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
389c373
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (st)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
390a375,410
> }
> 
> bool
> AparfWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
> void
> AparfWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> AparfWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> AparfWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/aparf-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/aparf-wifi-manager.h
41c41
<  * This RAA does not support HT modes and will error
---
>  * This RAA does not support HT, VHT nor HE modes and will error
43c43
<  * that supports 802.11n or higher.
---
>  * that has VhtSupported, HtSupported or HeSupported set.
57a58,60
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
71,72c74
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
80,81c82,83
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
85a88
>   bool IsLowLatency (void) const;
99,100c102,103
<   uint8_t m_rateInc;     //!< Step size for increment the rate.
<   uint8_t m_rateDec;     //!< Step size for decrement the rate.
---
>   uint8_t m_rateInc;    //!< Step size for increment the rate.
>   uint8_t m_rateDec;    //!< Step size for decrement the rate.
diff ../../NS3-WiGig/src/wifi/model/ap-wifi-mac.cc ../../ns-3-dev-git/src/wifi/model/ap-wifi-mac.cc
37,39d36
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "he-configuration.h"
202,206c199
<       NS_FATAL_ERROR ("beacon interval should be multiple of 1024us (802.11 time unit), see IEEE Std. 802.11-2012");
<     }
<   if (interval.GetMicroSeconds () > (1024 * 65535))
<     {
<       NS_FATAL_ERROR ("beacon interval should be smaller then or equal to 65535 * 1024us (802.11 time unit)");
---
>       NS_LOG_WARN ("beacon interval should be multiple of 1024us (802.11 time unit), see IEEE Std. 802.11-2012");
237c230
<   if (GetErpSupported () && GetShortSlotTimeSupported ())
---
>   if (GetErpSupported () == true && GetShortSlotTimeSupported () == true)
241c234
<           if (!m_stationManager->GetShortSlotTimeSupported (i->second))
---
>           if (m_stationManager->GetShortSlotTimeSupported (i->second) == false)
254c247
<   if (GetErpSupported () && m_phy->GetShortPhyPreambleSupported ())
---
>   if (GetErpSupported () || m_phy->GetShortPlcpPreambleSupported ())
258c251
<           if (!m_stationManager->GetShortPreambleSupported (*i))
---
>           if (m_stationManager->GetShortPreambleSupported (*i) == false)
274c267
<       if (!m_stationManager->GetGreenfieldSupported (i->second))
---
>       if (m_stationManager->GetGreenfieldSupported (i->second) == false)
302c295
< ApWifiMac::ForwardDown (Ptr<Packet> packet, Mac48Address from,
---
> ApWifiMac::ForwardDown (Ptr<const Packet> packet, Mac48Address from,
328c321
< ApWifiMac::ForwardDown (Ptr<Packet> packet, Mac48Address from,
---
> ApWifiMac::ForwardDown (Ptr<const Packet> packet, Mac48Address from,
355c348
<   if (GetQosSupported ())
---
>   if (GetQosSupported () || GetHtSupported () || GetVhtSupported () || GetHeSupported ())
357c350
<       hdr.SetNoOrder (); // explicitly set to 0 for the time being since HT control field is not yet implemented (set it to 1 when implemented)
---
>       hdr.SetNoOrder (); // explicitly set to 0 for the time being since HT/VHT/HE control field is not yet implemented (set it to 1 when implemented)
378c371
< ApWifiMac::Enqueue (Ptr<Packet> packet, Mac48Address to, Mac48Address from)
---
> ApWifiMac::Enqueue (Ptr<const Packet> packet, Mac48Address to, Mac48Address from)
392c385
< ApWifiMac::Enqueue (Ptr<Packet> packet, Mac48Address to)
---
> ApWifiMac::Enqueue (Ptr<const Packet> packet, Mac48Address to)
438c431
<   //If it is a HT AP, then add the BSSMembershipSelectorSet
---
>   //If it is an HT-AP or VHT-AP or HE-AP, then add the BSSMembershipSelectorSet
442c435
<   if (GetHtSupported ())
---
>   if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
452c445
< Ptr<DsssParameterSet>
---
> DsssParameterSet
456c449
<   Ptr<DsssParameterSet> dsssParameters = Create<DsssParameterSet> ();
---
>   DsssParameterSet dsssParameters;
459,460c452,453
<       dsssParameters->SetDsssSupported (1);
<       dsssParameters->SetCurrentChannel (m_phy->GetChannelNumber ());
---
>       dsssParameters.SetDsssSupported (1);
>       dsssParameters.SetCurrentChannel (m_phy->GetChannelNumber ());
480c473
< Ptr<ErpInformation>
---
> ErpInformation
484,485c477,478
<   Ptr<ErpInformation> information = Create<ErpInformation> ();
<   information->SetErpSupported (1);
---
>   ErpInformation information;
>   information.SetErpSupported (1);
488,489c481,482
<       information->SetNonErpPresent (!m_nonErpStations.empty ());
<       information->SetUseProtection (GetUseNonErpProtection ());
---
>       information.SetNonErpPresent (!m_nonErpStations.empty ());
>       information.SetUseProtection (GetUseNonErpProtection ());
492c485
<           information->SetBarkerPreambleMode (0);
---
>           information.SetBarkerPreambleMode (0);
496c489
<           information->SetBarkerPreambleMode (1);
---
>           information.SetBarkerPreambleMode (1);
502c495
< Ptr<EdcaParameterSet>
---
> EdcaParameterSet
506c499
<   Ptr<EdcaParameterSet> edcaParameters = Create<EdcaParameterSet> ();
---
>   EdcaParameterSet edcaParameters;
509c502
<       edcaParameters->SetQosSupported (1);
---
>       edcaParameters.SetQosSupported (1);
515,519c508,512
<       edcaParameters->SetBeAci (0);
<       edcaParameters->SetBeCWmin (edca->GetMinCw ());
<       edcaParameters->SetBeCWmax (edca->GetMaxCw ());
<       edcaParameters->SetBeAifsn (edca->GetAifsn ());
<       edcaParameters->SetBeTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
---
>       edcaParameters.SetBeAci (0);
>       edcaParameters.SetBeCWmin (edca->GetMinCw ());
>       edcaParameters.SetBeCWmax (edca->GetMaxCw ());
>       edcaParameters.SetBeAifsn (edca->GetAifsn ());
>       edcaParameters.SetBeTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
523,527c516,520
<       edcaParameters->SetBkAci (1);
<       edcaParameters->SetBkCWmin (edca->GetMinCw ());
<       edcaParameters->SetBkCWmax (edca->GetMaxCw ());
<       edcaParameters->SetBkAifsn (edca->GetAifsn ());
<       edcaParameters->SetBkTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
---
>       edcaParameters.SetBkAci (1);
>       edcaParameters.SetBkCWmin (edca->GetMinCw ());
>       edcaParameters.SetBkCWmax (edca->GetMaxCw ());
>       edcaParameters.SetBkAifsn (edca->GetAifsn ());
>       edcaParameters.SetBkTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
531,535c524,528
<       edcaParameters->SetViAci (2);
<       edcaParameters->SetViCWmin (edca->GetMinCw ());
<       edcaParameters->SetViCWmax (edca->GetMaxCw ());
<       edcaParameters->SetViAifsn (edca->GetAifsn ());
<       edcaParameters->SetViTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
---
>       edcaParameters.SetViAci (2);
>       edcaParameters.SetViCWmin (edca->GetMinCw ());
>       edcaParameters.SetViCWmax (edca->GetMaxCw ());
>       edcaParameters.SetViAifsn (edca->GetAifsn ());
>       edcaParameters.SetViTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
539,543c532,536
<       edcaParameters->SetVoAci (3);
<       edcaParameters->SetVoCWmin (edca->GetMinCw ());
<       edcaParameters->SetVoCWmax (edca->GetMaxCw ());
<       edcaParameters->SetVoAifsn (edca->GetAifsn ());
<       edcaParameters->SetVoTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
---
>       edcaParameters.SetVoAci (3);
>       edcaParameters.SetVoCWmin (edca->GetMinCw ());
>       edcaParameters.SetVoCWmax (edca->GetMaxCw ());
>       edcaParameters.SetVoAifsn (edca->GetAifsn ());
>       edcaParameters.SetVoTxopLimit (static_cast<uint16_t> (txopLimit.GetMicroSeconds () / 32));
545c538
<       edcaParameters->SetQosInfo (0);
---
>       edcaParameters.SetQosInfo (0);
550c543
< Ptr<CfParameterSet>
---
> CfParameterSet
553c546
<   Ptr<CfParameterSet> cfParameterSet = Create<CfParameterSet> ();
---
>   CfParameterSet cfParameterSet;
556,560c549,553
<       cfParameterSet->SetPcfSupported (1);
<       cfParameterSet->SetCFPCount (0);
<       cfParameterSet->SetCFPPeriod (1);
<       cfParameterSet->SetCFPMaxDurationUs (GetCfpMaxDuration ().GetMicroSeconds ());
<       cfParameterSet->SetCFPDurRemainingUs (GetCfpMaxDuration ().GetMicroSeconds ());
---
>       cfParameterSet.SetPcfSupported (1);
>       cfParameterSet.SetCFPCount (0);
>       cfParameterSet.SetCFPPeriod (1);
>       cfParameterSet.SetCFPMaxDurationUs (GetCfpMaxDuration ().GetMicroSeconds ());
>       cfParameterSet.SetCFPDurRemainingUs (GetCfpMaxDuration ().GetMicroSeconds ());
565c558
< Ptr<HtOperation>
---
> HtOperation
569c562
<   Ptr<HtOperation> operation = Create<HtOperation> ();
---
>   HtOperation operation;
572,575c565,568
<       operation->SetHtSupported (1);
<       operation->SetPrimaryChannel (m_phy->GetChannelNumber ());
<       operation->SetRifsMode (GetRifsMode ());
<       operation->SetNonGfHtStasPresent (IsNonGfHtStasPresent ());
---
>       operation.SetHtSupported (1);
>       operation.SetPrimaryChannel (m_phy->GetChannelNumber ());
>       operation.SetRifsMode (GetRifsMode ());
>       operation.SetNonGfHtStasPresent (IsNonGfHtStasPresent ());
578,579c571,572
<           operation->SetSecondaryChannelOffset (1);
<           operation->SetStaChannelWidth (1);
---
>           operation.SetSecondaryChannelOffset (1);
>           operation.SetStaChannelWidth (1);
583c576
<           operation->SetHtProtection (NO_PROTECTION);
---
>           operation.SetHtProtection (NO_PROTECTION);
587c580
<           operation->SetHtProtection (MIXED_MODE_PROTECTION);
---
>           operation.SetHtProtection (MIXED_MODE_PROTECTION);
599c592
<           uint64_t dataRate = mcs.GetDataRate (m_phy->GetChannelWidth (), GetHtConfiguration ()->GetShortGuardIntervalSupported () ? 400 : 800, nss);
---
>           uint64_t dataRate = mcs.GetDataRate (m_phy->GetChannelWidth (), m_phy->GetShortGuardInterval () ? 400 : 800, nss);
622c615
<                   uint64_t dataRate = mcs.GetDataRate (m_stationManager->GetChannelWidthSupported (i->second), m_stationManager->GetShortGuardIntervalSupported (i->second) ? 400 : 800, nss);
---
>                   uint64_t dataRate = mcs.GetDataRate (m_stationManager->GetChannelWidthSupported (i->second), m_stationManager->GetShortGuardInterval (i->second) ? 400 : 800, nss);
642,644c635,637
<       operation->SetRxHighestSupportedDataRate (static_cast<uint16_t> (maxSupportedRate / 1e6)); //in Mbit/s
<       operation->SetTxMcsSetDefined (nMcs > 0);
<       operation->SetTxMaxNSpatialStreams (maxSpatialStream);
---
>       operation.SetRxHighestSupportedDataRate (static_cast<uint16_t> (maxSupportedRate / 1e6)); //in Mbit/s
>       operation.SetTxMcsSetDefined (nMcs > 0);
>       operation.SetTxMaxNSpatialStreams (maxSpatialStream);
646,655c639,648
<       operation->SetObssNonHtStasPresent (0);
<       operation->SetDualBeacon (0);
<       operation->SetDualCtsProtection (0);
<       operation->SetStbcBeacon (0);
<       operation->SetLSigTxopProtectionFullSupport (0);
<       operation->SetPcoActive (0);
<       operation->SetPhase (0);
<       operation->SetRxMcsBitmask (0);
<       operation->SetTxRxMcsSetUnequal (0);
<       operation->SetTxUnequalModulation (0);
---
>       operation.SetObssNonHtStasPresent (0);
>       operation.SetDualBeacon (0);
>       operation.SetDualCtsProtection (0);
>       operation.SetStbcBeacon (0);
>       operation.SetLSigTxopProtectionFullSupport (0);
>       operation.SetPcoActive (0);
>       operation.SetPhase (0);
>       operation.SetRxMcsBitmask (0);
>       operation.SetTxRxMcsSetUnequal (0);
>       operation.SetTxUnequalModulation (0);
660c653
< Ptr<VhtOperation>
---
> VhtOperation
664c657
<   Ptr<VhtOperation> operation = Create<VhtOperation> ();
---
>   VhtOperation operation;
667c660
<       operation->SetVhtSupported (1);
---
>       operation.SetVhtSupported (1);
671c664
<           operation->SetChannelWidth (2);
---
>           operation.SetChannelWidth (2);
675c668
<           operation->SetChannelWidth (1);
---
>           operation.SetChannelWidth (1);
679c672
<           operation->SetChannelWidth (0);
---
>           operation.SetChannelWidth (0);
681,682c674
<       uint8_t maxSpatialStream = m_phy->GetMaxSupportedRxSpatialStreams ();
<       for (std::map<uint16_t, Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); i++)
---
>       for (uint8_t nss = 1; nss <= 8; nss++)
684c676,677
<           if (m_stationManager->GetVhtSupported (i->second))
---
>           uint8_t maxMcs;
>           if (nss <= m_phy->GetMaxSupportedRxSpatialStreams ())
686,689c679
<               if (m_stationManager->GetNumberOfSupportedStreams (i->second) < maxSpatialStream)
<                 {
<                   maxSpatialStream = m_stationManager->GetNumberOfSupportedStreams (i->second);
<                 }
---
>               maxMcs = 9; //TBD: hardcode to 9 for now since we assume all MCS values are supported
691,695c681,685
<         }
<       for (uint8_t nss = 1; nss <= maxSpatialStream; nss++)
<         {
<           uint8_t maxMcs = 9; //TBD: hardcode to 9 for now since we assume all MCS values are supported
<           operation->SetMaxVhtMcsPerNss (nss, maxMcs);
---
>           else
>             {
>               maxMcs = 0;
>             }
>           operation.SetMaxVhtMcsPerNss (nss, maxMcs);
701c691
< Ptr<HeOperation>
---
> HeOperation
705c695
<   Ptr<HeOperation> operation = Create<HeOperation> ();
---
>   HeOperation operation;
708,710c698,699
<       operation->SetHeSupported (1);
<       uint8_t maxSpatialStream = m_phy->GetMaxSupportedRxSpatialStreams ();
<       for (std::map<uint16_t, Mac48Address>::const_iterator i = m_staList.begin (); i != m_staList.end (); i++)
---
>       operation.SetHeSupported (1);
>       for (uint8_t nss = 1; nss <= m_phy->GetMaxSupportedRxSpatialStreams (); nss++)
712,722c701
<           if (m_stationManager->GetHeSupported (i->second))
<             {
<               if (m_stationManager->GetNumberOfSupportedStreams (i->second) < maxSpatialStream)
<                 {
<                   maxSpatialStream = m_stationManager->GetNumberOfSupportedStreams (i->second);
<                 }
<             }
<         }
<       for (uint8_t nss = 1; nss <= maxSpatialStream; nss++)
<         {
<           operation->SetMaxHeMcsPerNss (nss, 11); //TBD: hardcode to 11 for now since we assume all MCS values are supported
---
>           operation.SetMaxHeMcsPerNss (nss, 11); //TBD: hardcode to 11 for now since we assume all MCS values are supported
724,726d702
<       UintegerValue bssColor;
<       GetHeConfiguration ()->GetAttribute ("BssColor", bssColor);
<       operation->SetBssColor (bssColor.Get ());
752c728
<       probe.AddWifiInformationElement (GetDsssParameterSet ());
---
>       probe.SetDsssParameterSet (GetDsssParameterSet ());
756c732
<       probe.AddWifiInformationElement (GetErpInformation ());
---
>       probe.SetErpInformation (GetErpInformation ());
760c736
<       probe.AddWifiInformationElement (GetEdcaParameterSet ());
---
>       probe.SetEdcaParameterSet (GetEdcaParameterSet ());
762c738
<   if (GetHtSupported ())
---
>   if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
764,766c740,742
<       probe.AddWifiInformationElement (GetExtendedCapabilities ());
<       probe.AddWifiInformationElement (GetHtCapabilities ());
<       probe.AddWifiInformationElement (GetHtOperation ());
---
>       probe.SetExtendedCapabilities (GetExtendedCapabilities ());
>       probe.SetHtCapabilities (GetHtCapabilities ());
>       probe.SetHtOperation (GetHtOperation ());
768c744
<   if (GetVhtSupported ())
---
>   if (GetVhtSupported () || GetHeSupported ())
770,771c746,747
<       probe.AddWifiInformationElement (GetVhtCapabilities ());
<       probe.AddWifiInformationElement (GetVhtOperation ());
---
>       probe.SetVhtCapabilities (GetVhtCapabilities ());
>       probe.SetVhtOperation (GetVhtOperation ());
775,776c751,752
<       probe.AddWifiInformationElement (GetHeCapabilities ());
<       probe.AddWifiInformationElement (GetHeOperation ());
---
>       probe.SetHeCapabilities (GetHeCapabilities ());
>       probe.SetHeOperation (GetHeOperation ());
834c810
<       assoc.AddWifiInformationElement (GetErpInformation ());
---
>       assoc.SetErpInformation (GetErpInformation ());
838c814
<       assoc.AddWifiInformationElement (GetEdcaParameterSet ());
---
>       assoc.SetEdcaParameterSet (GetEdcaParameterSet ());
840c816
<   if (GetHtSupported ())
---
>   if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
842,844c818,820
<       assoc.AddWifiInformationElement (GetExtendedCapabilities ());
<       assoc.AddWifiInformationElement (GetHtCapabilities ());
<       assoc.AddWifiInformationElement (GetHtOperation ());
---
>       assoc.SetExtendedCapabilities (GetExtendedCapabilities ());
>       assoc.SetHtCapabilities (GetHtCapabilities ());
>       assoc.SetHtOperation (GetHtOperation ());
846c822
<   if (GetVhtSupported ())
---
>   if (GetVhtSupported () || GetHeSupported ())
848,849c824,825
<       assoc.AddWifiInformationElement (GetVhtCapabilities ());
<       assoc.AddWifiInformationElement (GetVhtOperation ());
---
>       assoc.SetVhtCapabilities (GetVhtCapabilities ());
>       assoc.SetVhtOperation (GetVhtOperation ());
853,854c829,830
<       assoc.AddWifiInformationElement (GetHeCapabilities ());
<       assoc.AddWifiInformationElement (GetHeOperation ());
---
>       assoc.SetHeCapabilities (GetHeCapabilities ());
>       assoc.SetHeOperation (GetHeOperation ());
886c862
<       beacon.AddWifiInformationElement (GetCfParameterSet ());
---
>       beacon.SetCfParameterSet (GetCfParameterSet ());
890c866
<       beacon.AddWifiInformationElement (GetDsssParameterSet ());
---
>       beacon.SetDsssParameterSet (GetDsssParameterSet ());
894c870
<       beacon.AddWifiInformationElement (GetErpInformation ());
---
>       beacon.SetErpInformation (GetErpInformation ());
898c874
<       beacon.AddWifiInformationElement (GetEdcaParameterSet ());
---
>       beacon.SetEdcaParameterSet (GetEdcaParameterSet ());
900c876
<   if (GetHtSupported ())
---
>   if (GetHtSupported () || GetVhtSupported ())
902,904c878,880
<       beacon.AddWifiInformationElement (GetExtendedCapabilities ());
<       beacon.AddWifiInformationElement (GetHtCapabilities ());
<       beacon.AddWifiInformationElement (GetHtOperation ());
---
>       beacon.SetExtendedCapabilities (GetExtendedCapabilities ());
>       beacon.SetHtCapabilities (GetHtCapabilities ());
>       beacon.SetHtOperation (GetHtOperation ());
906c882
<   if (GetVhtSupported ())
---
>   if (GetVhtSupported () || GetHeSupported ())
908,909c884,885
<       beacon.AddWifiInformationElement (GetVhtCapabilities ());
<       beacon.AddWifiInformationElement (GetVhtOperation ());
---
>       beacon.SetVhtCapabilities (GetVhtCapabilities ());
>       beacon.SetVhtOperation (GetVhtOperation ());
913,918c889,890
<       beacon.AddWifiInformationElement (GetHeCapabilities ());
<       beacon.AddWifiInformationElement (GetHeOperation ());
<     }
<   if (m_supportMultiBand)
<     {
<       beacon.AddWifiInformationElement (GetMultiBandElement ());
---
>       beacon.SetHeCapabilities (GetHeCapabilities ());
>       beacon.SetHeOperation (GetHeOperation ());
978c950
< ApWifiMac::TxOk (Ptr<const Packet> packet, const WifiMacHeader &hdr)
---
> ApWifiMac::TxOk (const WifiMacHeader &hdr)
981c953
<   RegularWifiMac::TxOk (packet, hdr);
---
>   RegularWifiMac::TxOk (hdr);
1024,1039d995
< Ptr<MultiBandElement>
< ApWifiMac::GetMultiBandElement (void) const
< {
<   Ptr<MultiBandElement> multiband = Create<MultiBandElement> ();
<   multiband->SetStaRole (ROLE_AP);
<   multiband->SetStaMacAddressPresent (false); /* The same MAC address is used across all the bands */
<   multiband->SetBandID (Band_2_4GHz);
<   multiband->SetOperatingClass (18);          /* Europe */
<   multiband->SetChannelNumber (m_phy->GetChannelNumber ());
<   multiband->SetBssID (GetAddress ());
< //  multiband->SetBeaconInterval (m_beaconInterval.GetMicroSeconds ());
<   multiband->SetConnectionCapability (1);     /* AP */
<   multiband->SetFstSessionTimeout (m_fstTimeout);
<   return multiband;
< }
< 
1041,1045c997,999
< ApWifiMac::Receive (Ptr<WifiMacQueueItem> mpdu)
< {
<   NS_LOG_FUNCTION (this << *mpdu);
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
<   Ptr<const Packet> packet = mpdu->GetPacket ();
---
> ApWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
> {
>   NS_LOG_FUNCTION (this << packet << hdr);
1064c1018
<                       DeaggregateAmsduAndForward (mpdu);
---
>                       DeaggregateAmsduAndForward (packet, hdr);
1088c1042
<                   ForwardDown (copy, from, to, hdr->GetQosTid ());
---
>                   ForwardDown (packet, from, to, hdr->GetQosTid ());
1092c1046
<                   ForwardDown (copy, from, to);
---
>                   ForwardDown (packet, from, to);
1094c1048
<               ForwardUp (packet, from, to);
---
>               ForwardUp (copy, from, to);
1121,1128c1075,1076
<           MgtProbeRequestHeader probeRequestHeader;
<           packet->PeekHeader (probeRequestHeader);
<           Ssid ssid = probeRequestHeader.GetSsid ();
<           if (ssid == GetSsid () || ssid.IsBroadcast ())
<             {
<               NS_LOG_DEBUG ("Probe request received from " << from << ": send probe response");
<               SendProbeResp (from);
<             }
---
>           NS_LOG_DEBUG ("Probe request received from " << from << ": send probe response");
>           SendProbeResp (from);
1139c1087
<               packet->PeekHeader (assocReq);
---
>               packet->RemoveHeader (assocReq);
1141c1089
<               m_stationManager->AddSupportedPhyPreamble (from, capabilities.IsShortPreamble ());
---
>               m_stationManager->AddSupportedPlcpPreamble (from, capabilities.IsShortPreamble ());
1191,1193c1139,1140
<                   Ptr<HtCapabilities> htcapabilities =
<                       StaticCast<HtCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_HT_CAPABILITIES, 0)));
<                   if (htcapabilities->IsSupportedMcs (0))
---
>                   HtCapabilities htcapabilities = assocReq.GetHtCapabilities ();
>                   if (htcapabilities.IsSupportedMcs (0))
1199c1146
<                           if (!htcapabilities->IsSupportedMcs (mcs.GetMcsValue ()))
---
>                           if (!htcapabilities.IsSupportedMcs (mcs.GetMcsValue ()))
1210,1212c1157,1158
<                   Ptr<VhtCapabilities> vhtCapabilities =
<                       StaticCast<VhtCapabilities> (assocReq.GetInformationElement (std::make_pair(IE_VHT_CAPABILITIES,0)));
<                   if (vhtCapabilities->GetVhtCapabilitiesInfo () != 0)
---
>                   VhtCapabilities vhtcapabilities = assocReq.GetVhtCapabilities ();
>                   if (vhtcapabilities.GetVhtCapabilitiesInfo () != 0)
1217c1163
<                           if (!vhtCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
---
>                           if (!vhtcapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1228,1230c1174,1175
<                   Ptr<HeCapabilities> hecapabilities =
<                       StaticCast<HeCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<                   if (hecapabilities->GetSupportedMcsAndNss () != 0)
---
>                   HeCapabilities hecapabilities = assocReq.GetHeCapabilities ();
>                   if (hecapabilities.GetSupportedMcsAndNss () != 0)
1235c1180
<                           if (!hecapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
---
>                           if (!hecapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1270,1272c1215,1216
<                       Ptr<HtCapabilities> htCapabilities =
<                           StaticCast<HtCapabilities> (assocReq.GetInformationElement (std::make_pair(IE_HT_CAPABILITIES,0)));
<                       if (htCapabilities->IsSupportedMcs (0))
---
>                       HtCapabilities htCapabilities = assocReq.GetHtCapabilities ();
>                       if (htCapabilities.IsSupportedMcs (0))
1279,1280c1223
<                       Ptr<VhtCapabilities> vhtCapabilities =
<                           StaticCast<VhtCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_VHT_CAPABILITIES, 0)));
---
>                       VhtCapabilities vhtCapabilities = assocReq.GetVhtCapabilities ();
1282c1225
<                       if (vhtCapabilities->GetRxHighestSupportedLgiDataRate () > 0)
---
>                       if (vhtCapabilities.GetRxHighestSupportedLgiDataRate () > 0)
1288c1231
<                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
---
>                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1296c1239
<                   if (GetHtSupported ())
---
>                   if (GetHtSupported () || GetVhtSupported ())
1298,1299c1241
<                       Ptr<ExtendedCapabilities> extendedCapabilities =
<                           StaticCast<ExtendedCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_EXTENDED_CAPABILITIES, 0)));
---
>                       ExtendedCapabilities extendedCapabilities = assocReq.GetExtendedCapabilities ();
1304,1306c1246,1249
<                       Ptr<HeCapabilities> heCapabilities =
<                           StaticCast<HeCapabilities> (assocReq.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<                       if (heCapabilities->GetSupportedMcsAndNss () != 0)
---
>                       HeCapabilities heCapabilities = assocReq.GetHeCapabilities ();
>                       //todo: once we support non constant rate managers, we should add checks here whether HE is supported by the peer
>                       m_stationManager->AddStationHeCapabilities (from, heCapabilities);
>                       for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
1308,1309c1251,1252
<                           m_stationManager->AddStationHeCapabilities (from, heCapabilities);
<                           for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
---
>                           WifiMode mcs = m_phy->GetMcs (i);
>                           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1311,1316c1254,1255
<                               WifiMode mcs = m_phy->GetMcs (i);
<                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
<                                 {
<                                   m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
<                                   //here should add a control to add basic MCS when it is implemented
<                                 }
---
>                               m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
>                               //here should add a control to add basic MCS when it is implemented
1342c1281
<               packet->PeekHeader (reassocReq);
---
>               packet->RemoveHeader (reassocReq);
1344c1283
<               m_stationManager->AddSupportedPhyPreamble (from, capabilities.IsShortPreamble ());
---
>               m_stationManager->AddSupportedPlcpPreamble (from, capabilities.IsShortPreamble ());
1394,1396c1333,1334
<                   Ptr<HtCapabilities> htcapabilities
<                       = StaticCast<HtCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_HT_CAPABILITIES,0)));
<                   if (htcapabilities->IsSupportedMcs (0))
---
>                   HtCapabilities htcapabilities = reassocReq.GetHtCapabilities ();
>                   if (htcapabilities.IsSupportedMcs (0))
1402c1340
<                           if (!htcapabilities->IsSupportedMcs (mcs.GetMcsValue ()))
---
>                           if (!htcapabilities.IsSupportedMcs (mcs.GetMcsValue ()))
1413,1415c1351,1352
<                   Ptr<VhtCapabilities> vhtcapabilities
<                       = StaticCast<VhtCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_VHT_CAPABILITIES,0)));
<                   if (vhtcapabilities->GetVhtCapabilitiesInfo () != 0)
---
>                   VhtCapabilities vhtcapabilities = reassocReq.GetVhtCapabilities ();
>                   if (vhtcapabilities.GetVhtCapabilitiesInfo () != 0)
1420c1357
<                           if (!vhtcapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
---
>                           if (!vhtcapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1431,1433c1368,1369
<                   Ptr<HeCapabilities> hecapabilities
<                       = StaticCast<HeCapabilities> (reassocReq.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<                   if (hecapabilities->GetSupportedMcsAndNss () != 0)
---
>                   HeCapabilities hecapabilities = reassocReq.GetHeCapabilities ();
>                   if (hecapabilities.GetSupportedMcsAndNss () != 0)
1438c1374
<                           if (!hecapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
---
>                           if (!hecapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1465,1467c1401,1402
<                       Ptr<HtCapabilities> htCapabilities
<                           = StaticCast<HtCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_HT_CAPABILITIES,0)));
<                       if (htCapabilities->IsSupportedMcs (0))
---
>                       HtCapabilities htCapabilities = reassocReq.GetHtCapabilities ();
>                       if (htCapabilities.IsSupportedMcs (0))
1474,1475c1409
<                       Ptr<VhtCapabilities> vhtCapabilities
<                           = StaticCast<VhtCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_VHT_CAPABILITIES,0)));
---
>                       VhtCapabilities vhtCapabilities = reassocReq.GetVhtCapabilities ();
1477c1411
<                       if (vhtCapabilities->GetRxHighestSupportedLgiDataRate () > 0)
---
>                       if (vhtCapabilities.GetRxHighestSupportedLgiDataRate () > 0)
1483c1417
<                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
---
>                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1491c1425
<                   if (GetHtSupported ())
---
>                   if (GetHtSupported () || GetVhtSupported ())
1493,1494c1427
<                       Ptr<ExtendedCapabilities> extendedCapabilities
<                           = StaticCast<ExtendedCapabilities> (reassocReq.GetInformationElement (std::make_pair(IE_EXTENDED_CAPABILITIES,0)));
---
>                       ExtendedCapabilities extendedCapabilities = reassocReq.GetExtendedCapabilities ();
1499,1501c1432,1435
<                       Ptr<HeCapabilities> heCapabilities
<                           = StaticCast<HeCapabilities> (reassocReq.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<                       if (heCapabilities->GetSupportedMcsAndNss () != 0)
---
>                       HeCapabilities heCapabilities = reassocReq.GetHeCapabilities ();
>                       //todo: once we support non constant rate managers, we should add checks here whether HE is supported by the peer
>                       m_stationManager->AddStationHeCapabilities (from, heCapabilities);
>                       for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
1503,1504c1437,1438
<                           m_stationManager->AddStationHeCapabilities (from, heCapabilities);
<                           for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
---
>                           WifiMode mcs = m_phy->GetMcs (i);
>                           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities.IsSupportedTxMcs (mcs.GetMcsValue ()))
1506,1511c1440,1441
<                               WifiMode mcs = m_phy->GetMcs (i);
<                               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities->IsSupportedTxMcs (mcs.GetMcsValue ()))
<                                 {
<                                   m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
<                                   //here should add a control to add basic MCS when it is implemented
<                                 }
---
>                               m_stationManager->AddSupportedMcs (hdr->GetAddr2 (), mcs);
>                               //here should add a control to add basic MCS when it is implemented
1575c1505
<   RegularWifiMac::Receive (Create<WifiMacQueueItem> (packet, *hdr));
---
>   RegularWifiMac::Receive (packet, hdr);
1579c1509
< ApWifiMac::DeaggregateAmsduAndForward (Ptr<WifiMacQueueItem> mpdu)
---
> ApWifiMac::DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket, const WifiMacHeader *hdr)
1581,1582c1511,1514
<   NS_LOG_FUNCTION (this << *mpdu);
<   for (auto& i : *PeekPointer (mpdu))
---
>   NS_LOG_FUNCTION (this << aggregatedPacket << hdr);
>   MsduAggregator::DeaggregatedMsdus packets = MsduAggregator::Deaggregate (aggregatedPacket);
>   for (MsduAggregator::DeaggregatedMsdusCI i = packets.begin ();
>        i != packets.end (); ++i)
1584c1516
<       if (i.second.GetDestinationAddr () == GetAddress ())
---
>       if ((*i).second.GetDestinationAddr () == GetAddress ())
1586,1587c1518,1519
<           ForwardUp (i.first, i.second.GetSourceAddr (),
<                      i.second.GetDestinationAddr ());
---
>           ForwardUp ((*i).first, (*i).second.GetSourceAddr (),
>                      (*i).second.GetDestinationAddr ());
1591,1592c1523,1524
<           Mac48Address from = i.second.GetSourceAddr ();
<           Mac48Address to = i.second.GetDestinationAddr ();
---
>           Mac48Address from = (*i).second.GetSourceAddr ();
>           Mac48Address to = (*i).second.GetDestinationAddr ();
1594c1526
<           ForwardDown (i.first->Copy (), from, to, mpdu->GetHeader ().GetQosTid ());
---
>           ForwardDown ((*i).first, from, to, hdr->GetQosTid ());
1634c1566
<   if (GetHtSupported () && !GetVhtSupported ()) //RIFS mode is no longer allowed with 802.11ac or higher
---
>   if (GetHtSupported () && !GetVhtSupported ()) //RIFS mode is forbidden for VHT
1641c1573
<   if (GetHtSupported () && GetHtConfiguration ()->GetRifsSupported () && rifsMode)
---
>   if (GetRifsSupported () && rifsMode)
diff ../../NS3-WiGig/src/wifi/model/ap-wifi-mac.h ../../ns-3-dev-git/src/wifi/model/ap-wifi-mac.h
59c59,61
<   // Implementations of pure virtual methods, or overridden from base class.
---
>   /**
>    * \param stationManager the station manager attached to this MAC.
>    */
60a63,66
> 
>   /**
>    * \param linkUp the callback to invoke when the link becomes up.
>    */
62,63c68,91
<   void Enqueue (Ptr<Packet> packet, Mac48Address to);
<   void Enqueue (Ptr<Packet> packet, Mac48Address to, Mac48Address from);
---
> 
>   /**
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
>    *
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.
>    */
>   void Enqueue (Ptr<const Packet> packet, Mac48Address to);
> 
>   /**
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
>    * \param from the address from which the packet should be sent.
>    *
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.  The extra parameter "from" allows
>    * this device to operate in a bridged mode, forwarding received
>    * frames without altering the source address.
>    */
>   void Enqueue (Ptr<const Packet> packet, Mac48Address to, Mac48Address from);
> 
65d92
<   void SetAddress (Mac48Address address);
67a95,98
>    * \param address the current address of this MAC layer.
>    */
>   void SetAddress (Mac48Address address);
>   /**
85c116
<    * Typically, true is returned only when there is no non-ERP stations associated
---
>    * Typically, true is returned only when there is no non-erp stations associated
95c126
<    * stations support short PHY preamble.
---
>    * stations support short PLCP preamble.
124,125d154
< protected:
<   Ptr<MultiBandElement> GetMultiBandElement (void) const;
128c157
<   void Receive (Ptr<WifiMacQueueItem> mpdu);
---
>   void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
131c160
<    * (i.e. we received an Ack from the receiver).  If the packet
---
>    * (i.e. we received an ACK from the receiver).  If the packet
137c166
<   void TxOk (Ptr<const Packet> packet, const WifiMacHeader &hdr);
---
>   void TxOk (const WifiMacHeader &hdr);
140c169
<    * (i.e. we did not receive an Ack from the receiver).  If the packet
---
>    * (i.e. we did not receive an ACK from the receiver).  If the packet
154c183,184
<    * \param mpdu the MPDU containing the A-MSDU.
---
>    * \param aggregatedPacket the Packet containing the A-MSDU.
>    * \param hdr a pointer to the MAC header for \c aggregatedPacket.
156c186,187
<   void DeaggregateAmsduAndForward (Ptr<WifiMacQueueItem> mpdu);
---
>   void DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket,
>                                    const WifiMacHeader *hdr);
165c196
<   void ForwardDown (Ptr<Packet> packet, Mac48Address from, Mac48Address to);
---
>   void ForwardDown (Ptr<const Packet> packet, Mac48Address from, Mac48Address to);
174c205
<   void ForwardDown (Ptr<Packet> packet, Mac48Address from, Mac48Address to, uint8_t tid);
---
>   void ForwardDown (Ptr<const Packet> packet, Mac48Address from, Mac48Address to, uint8_t tid);
220c251
<   Ptr<ErpInformation> GetErpInformation (void) const;
---
>   ErpInformation GetErpInformation (void) const;
226c257
<   Ptr<EdcaParameterSet> GetEdcaParameterSet (void) const;
---
>   EdcaParameterSet GetEdcaParameterSet (void) const;
232c263
<   Ptr<CfParameterSet> GetCfParameterSet (void) const;
---
>   CfParameterSet GetCfParameterSet (void) const;
238c269
<   Ptr<HtOperation> GetHtOperation (void) const;
---
>   HtOperation GetHtOperation (void) const;
244c275
<   Ptr<VhtOperation> GetVhtOperation (void) const;
---
>   VhtOperation GetVhtOperation (void) const;
250c281
<   Ptr<HeOperation> GetHeOperation (void) const;
---
>   HeOperation GetHeOperation (void) const;
263c294
<   Ptr<DsssParameterSet> GetDsssParameterSet (void) const;
---
>   DsssParameterSet GetDsssParameterSet (void) const;
diff ../../NS3-WiGig/src/wifi/model/arf-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/arf-wifi-manager.cc
42a43
>   uint32_t m_retry; ///< retry count
86,103d86
< void
< ArfWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
115a99
>   station->m_retry = 0;
136c120
<  * \param st the station that we failed to send Data
---
>  * \param st the station that we failed to send DATA
142c126
<   ArfWifiRemoteStation *station = static_cast<ArfWifiRemoteStation*> (st);
---
>   ArfWifiRemoteStation *station = (ArfWifiRemoteStation *)st;
144a129
>   station->m_retry++;
149,150c134,135
<       NS_ASSERT (station->m_failed >= 1);
<       if (station->m_failed == 1)
---
>       NS_ASSERT (station->m_retry >= 1);
>       if (station->m_retry == 1)
162,163c147,148
<       NS_ASSERT (station->m_failed >= 1);
<       if (((station->m_failed - 1) % 2) == 1)
---
>       NS_ASSERT (station->m_retry >= 1);
>       if (((station->m_retry - 1) % 2) == 1)
171c156
<       if (station->m_failed >= 2)
---
>       if (station->m_retry >= 2)
192,193c177,178
< void ArfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                      double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> void ArfWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                      double ackSnr, WifiMode ackMode, double dataSnr)
195,196c180,181
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   ArfWifiRemoteStation *station = static_cast<ArfWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   ArfWifiRemoteStation *station = (ArfWifiRemoteStation *) st;
200a186
>   station->m_retry = 0;
230c216
<   ArfWifiRemoteStation *station = static_cast<ArfWifiRemoteStation*> (st);
---
>   ArfWifiRemoteStation *station = (ArfWifiRemoteStation *) st;
233a220
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
242c229
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
249c236
<   /// \todo we could/should implement the ARF algorithm for
---
>   /// \todo we could/should implement the Arf algorithm for
251c238
<   ArfWifiRemoteStation *station = static_cast<ArfWifiRemoteStation*> (st);
---
>   ArfWifiRemoteStation *station = (ArfWifiRemoteStation *) st;
254a242
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
267c255
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
268a257,292
> }
> 
> bool
> ArfWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
> void
> ArfWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> ArfWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> ArfWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/arf-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/arf-wifi-manager.h
44c44
<  * This RAA does not support HT modes and will error
---
>  * This RAA does not support HT, VHT nor HE modes and will error
46c46
<  * that supports 802.11n or higher.
---
>  * that has VhtSupported, HtSupported or HeSupported set.
58a59,63
>   // Inherited from WifiRemoteStationManager
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
> 
61,62c66
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
70,71c74,75
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
75a80
>   bool IsLowLatency (void) const;
77c82
<   uint32_t m_timerThreshold;   ///< timer threshold
---
>   uint32_t m_timerThreshold; ///< timer threshold
Only in ../../NS3-WiGig/src/wifi/model: association-state-machine.cc
Only in ../../NS3-WiGig/src/wifi/model: association-state-machine.h
Only in ../../NS3-WiGig/src/wifi/model: bft-id-tag.cc
Only in ../../NS3-WiGig/src/wifi/model: bft-id-tag.h
diff ../../NS3-WiGig/src/wifi/model/block-ack-agreement.cc ../../ns-3-dev-git/src/wifi/model/block-ack-agreement.cc
23d22
< #include "wifi-utils.h"
30,31c29
<   : m_peer (peer),
<     m_amsduSupported (0),
---
>   : m_amsduSupported (0),
33d30
<     m_tid (tid),
37a35,36
>   m_tid = tid;
>   m_peer = peer;
50d48
<   //// WIGIG ////
52d49
<   //// WIGIG ////
103a101
>   NS_LOG_FUNCTION (this);
116a115
>   NS_LOG_FUNCTION (this);
122a122
>   NS_LOG_FUNCTION (this);
128a129
>   NS_LOG_FUNCTION (this);
134a136
>   NS_LOG_FUNCTION (this);
141a144
>   NS_LOG_FUNCTION (this);
147a151
>   NS_LOG_FUNCTION (this);
154c158,164
<   return (GetStartingSequence () + GetBufferSize () - 1) % SEQNO_SPACE_SIZE;
---
>   return m_winEnd;
> }
> 
> void
> BlockAckAgreement::SetWinEnd (uint16_t seq)
> {
>   m_winEnd = seq;
166a177
>   NS_LOG_FUNCTION (this);
diff ../../NS3-WiGig/src/wifi/model/block-ack-agreement.h ../../ns-3-dev-git/src/wifi/model/block-ack-agreement.h
42,43c42,43
<    * \param peer the peer station
<    * \param tid the TID
---
>    * \param peer
>    * \param tid
50c50
<    * \param bufferSize the buffer size (in number of MPDUs)
---
>    * \param bufferSize
56c56
<    * \param timeout the timeout value
---
>    * \param timeout
72c72
<    * Set block ack policy to immediate Ack.
---
>    * Set Block ACK policy to immediate ACK.
76c76
<    * Set block ack policy to delayed Ack.
---
>    * Set Block ACK policy to delayed ACK.
85a86,91
>    * Set ending sequence number.
>    *
>    * \param seq the ending sequence number
>    */
>   void SetWinEnd (uint16_t seq);
>   /**
94c100
<    * \return the peer MAC address
---
>    * \return Mac48Address
100c106
<    * \return the buffer size (in number of MPDUs)
---
>    * \return buffer size
106c112
<    * \return the timeout
---
>    * \return timeout
110c116
<    * Return the starting sequence number.
---
>    * Return the starting squence number.
122c128
<    * Return the last sequence number covered by the ack window
---
>    * Return the ending sequence number
128c134
<    * Check whether the current ack policy is immediate BlockAck.
---
>    * Check whether the current ACK policy is immediate block ACK.
130c136
<    * \return true if the current ack policy is immediate BlockAck,
---
>    * \return true if the current ACK policy is immediate block ACK,
163c169
<   uint16_t m_startingSeq;    //!< Starting sequence control
---
>   uint16_t m_startingSeq;    //!< Starting squence control
diff ../../NS3-WiGig/src/wifi/model/block-ack-cache.cc ../../ns-3-dev-git/src/wifi/model/block-ack-cache.cc
39c39
<   m_winSize = winSize;
---
>   m_winSize = winSize <= 64 ? winSize : 64;
122,125c122
<   else if (blockAckHeader->IsCompressed () || blockAckHeader->IsExtendedCompressed ()
<            //// WIGIG ////
<            || blockAckHeader->IsEdmgCompressed ())
<            //// WIGIG ////
---
>   else if (blockAckHeader->IsCompressed ())
diff ../../NS3-WiGig/src/wifi/model/block-ack-cache.h ../../ns-3-dev-git/src/wifi/model/block-ack-cache.h
40c40
<    * Initialization function
---
>    * Init function
73c73
<    * Reset portion of bitmap function
---
>    * Reset portion of bitmap functiion
80,81c80,81
<   uint16_t m_winSize;  ///< window size
<   uint16_t m_winEnd;   ///< window end
---
>   uint16_t m_winSize; ///< window size
>   uint16_t m_winEnd; ///< window end
diff ../../NS3-WiGig/src/wifi/model/block-ack-manager.cc ../../ns-3-dev-git/src/wifi/model/block-ack-manager.cc
30d29
< #include "wifi-tx-vector.h"
35a35,42
> BlockAckManager::Item::Item (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp)
>   : packet (packet),
>     hdr (hdr),
>     timestamp (tStamp)
> {
>   NS_LOG_FUNCTION (this << packet << hdr << tStamp);
> }
> 
41c48
< Bar::Bar (Ptr<const WifiMacQueueItem> bar, uint8_t tid, bool skipIfNoDataQueued)
---
> Bar::Bar (Ptr<const Packet> bar, Mac48Address recipient, uint8_t tid, bool immediate)
42a50
>     recipient (recipient),
44c52
<     skipIfNoDataQueued (skipIfNoDataQueued)
---
>     immediate (immediate)
46c54
<   NS_LOG_FUNCTION (this << *bar << +tid << skipIfNoDataQueued);
---
>   NS_LOG_FUNCTION (this << bar << recipient << +tid << immediate);
58,61d65
<     .AddTraceSource ("AgreementState",
<                      "The state of the ADDBA handshake",
<                      MakeTraceSourceAccessor (&BlockAckManager::m_agreementState),
<                      "ns3::BlockAckManager::AgreementStateTracedCallback")
69,70d72
<   m_retryPackets = CreateObject<WifiMacQueue> ();
<   m_retryPackets->TraceConnectWithoutContext ("Expired", MakeCallback (&BlockAckManager::NotifyDiscardedMpdu, this));
78,116c80
<   m_retryPackets = 0;
< }
< 
< void
< BlockAckManager::CopyAgreements (Mac48Address recipient, Ptr<BlockAckManager> manager)
< {
<   NS_LOG_FUNCTION (this << recipient << manager);
< //  std::pair<Mac48Address, uint8_t> key;
< //  std::pair<OriginatorBlockAckAgreement, PacketQueue> value;
< //  OriginatorBlockAckAgreement agreement;  /* The existing agreement */
< //  for (AgreementsI iter = m_agreements.begin (); iter != m_agreements.end (); iter++)
< //    {
< //      key = iter->first;
< //      value = iter->second;
< //      /* Check if there is already an existing agreement */
< //      if (!ExistsAgreement (recipient, key.second))
< //        {
< //          agreement = value.first;
< //          OriginatorBlockAckAgreement clonedAgreement (recipient, key.second);
< //          clonedAgreement.SetStartingSequence (agreement.GetStartingSequence ());
< //          clonedAgreement.SetBufferSize (agreement.GetBufferSize ());
< //          clonedAgreement.SetWinEnd (agreement.GetWinEnd ());
< //          clonedAgreement.SetTimeout (agreement.GetTimeout ());
< //          clonedAgreement.SetAmsduSupport (agreement.IsAmsduSupported ());
< //          clonedAgreement.SetHtSupported (agreement.IsHtSupported ());
< //          if (agreement.IsImmediateBlockAck ())
< //            {
< //              clonedAgreement.SetImmediateBlockAck ();
< //            }
< //          else
< //            {
< //              clonedAgreement.SetDelayedBlockAck ();
< //            }
< //          clonedAgreement.SetState (agreement.GetState ());
< //          std::pair<OriginatorBlockAckAgreement, PacketQueue> clonedValue (clonedAgreement, value.second);
< //          manager->m_agreements.insert (std::make_pair (key, clonedValue));
< //          manager->m_blockPackets (recipient, key.second);
< //        }
< //    }
---
>   m_retryPackets.clear ();
129a94
>   NS_LOG_FUNCTION (this << recipient << +tid << state);
135a101,102
>         case OriginatorBlockAckAgreement::INACTIVE:
>           return it->second.first.IsInactive ();
140,145c107,108
<         case OriginatorBlockAckAgreement::REJECTED:
<           return it->second.first.IsRejected ();
<         case OriginatorBlockAckAgreement::NO_REPLY:
<           return it->second.first.IsNoReply ();
<         case OriginatorBlockAckAgreement::RESET:
<           return it->second.first.IsReset ();
---
>         case OriginatorBlockAckAgreement::UNSUCCESSFUL:
>           return it->second.first.IsUnsuccessful ();
162c125,126
<   agreement.SetBufferSize (reqHdr->GetBufferSize());
---
>   agreement.SetBufferSize (64);
>   agreement.SetWinEnd ((agreement.GetStartingSequence () + agreement.GetBufferSize () - 1) % 4096);
165,166c129
<   agreement.SetHtSupported (m_stationManager->GetHtSupported ()
<                             || m_stationManager->HasDmgSupported () || m_stationManager->HasEdmgSupported ());
---
>   agreement.SetHtSupported (m_stationManager->HasHtSupported ());
175,176d137
<   uint8_t tid = reqHdr->GetTid ();
<   m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::PENDING);
180,185d140
<   if (ExistsAgreement (recipient, tid))
<     {
<       // Delete agreement if it exists and in RESET state
<       NS_ASSERT (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::RESET));
<       m_agreements.erase (key);
<     }
197c152
<       for (WifiMacQueue::ConstIterator i = m_retryPackets->begin (); i != m_retryPackets->end (); )
---
>       for (std::list<PacketQueueI>::const_iterator i = m_retryPackets.begin (); i != m_retryPackets.end (); )
199c154
<           if ((*i)->GetHeader ().GetAddr1 () == recipient && (*i)->GetHeader ().GetQosTid () == tid)
---
>           if ((*i)->hdr.GetAddr1 () == recipient && (*i)->hdr.GetQosTid () == tid)
201c156
<               i = m_retryPackets->Remove (i);
---
>               i = m_retryPackets.erase (i);
209c164
<       //remove scheduled BAR
---
>       //remove scheduled bar
212c167
<           if (i->bar->GetHeader ().GetAddr1 () == recipient && i->tid == tid)
---
>           if (i->recipient == recipient && i->tid == tid)
236,252d190
<       // When the Add BA Response is received, there may be a packet transmitted
<       // under the normal ack policy that needs to be retransmitted. If so, such
<       // packet is placed in the retransmit queue. If this is the case, the starting
<       // sequence number is the sequence number of such packet. Otherwise, it is
<       // the sequence number that will be assigned to the next packet to be transmitted.
<       uint16_t startSeq;
<       WifiMacQueue::ConstIterator mpduIt = m_retryPackets->PeekByTidAndAddress (tid, recipient);
<       if (mpduIt != m_retryPackets->end ())
<         {
<           startSeq = (*mpduIt)->GetHeader ().GetSequenceNumber ();
<         }
<       else
<         {
<           startSeq = m_txMiddle->GetNextSeqNumberByTidAndAddress (tid, recipient);
<         }
<       agreement.SetStartingSequence (startSeq);
<       agreement.InitTxWindow ();
261,264d198
<       if (!it->second.first.IsEstablished ())
<       {
<         m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED);
<       }
278,283d211
< Ptr<WifiMacQueue>
< BlockAckManager::GetRetransmitQueue (void)
< {
<   return m_retryPackets;
< }
< 
285c213
< BlockAckManager::StorePacket (Ptr<WifiMacQueueItem> mpdu)
---
> BlockAckManager::StorePacket (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp)
287,294c215,216
<   NS_LOG_FUNCTION (this << *mpdu);
<   NS_ASSERT (mpdu->GetHeader ().IsQosData ());
< 
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
< 
<   AgreementsI agreementIt = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (agreementIt != m_agreements.end ());
---
>   NS_LOG_FUNCTION (this << packet << hdr << tStamp);
>   NS_ASSERT (hdr.IsQosData ());
296c218,219
<   uint16_t mpduDist = agreementIt->second.first.GetDistance (mpdu->GetHeader ().GetSequenceNumber ());
---
>   uint8_t tid = hdr.GetQosTid ();
>   Mac48Address recipient = hdr.GetAddr1 ();
298,307c221,225
<   if (mpduDist >= SEQNO_SPACE_HALF_SIZE)
<     {
<       NS_LOG_DEBUG ("Got an old packet. Do nothing");
<       return;
<     }
< 
<   // store the packet and keep the list sorted in increasing order of sequence number
<   // with respect to the starting sequence number
<   PacketQueueI it = agreementIt->second.second.begin ();
<   while (it != agreementIt->second.second.end ())
---
>   Item item (packet, hdr, tStamp);
>   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
>   NS_ASSERT (it != m_agreements.end ());
>   PacketQueueI queueIt = it->second.second.begin ();
>   for (; queueIt != it->second.second.end (); )
309c227
<       if (mpdu->GetHeader ().GetSequenceControl () == (*it)->GetHeader ().GetSequenceControl ())
---
>       if (((hdr.GetSequenceNumber () - queueIt->hdr.GetSequenceNumber () + 4096) % 4096) > 2047)
311,312c229,230
<           NS_LOG_DEBUG ("Packet already in the queue of the BA agreement");
<           return;
---
>           queueIt = it->second.second.insert (queueIt, item);
>           break;
314,318c232
< 
<       uint16_t dist = agreementIt->second.first.GetDistance ((*it)->GetHeader ().GetSequenceNumber ());
< 
<       if (mpduDist < dist ||
<           (mpduDist == dist && mpdu->GetHeader ().GetFragmentNumber () < (*it)->GetHeader ().GetFragmentNumber ()))
---
>       else
320c234
<           break;
---
>           queueIt++;
322,323d235
< 
<       it++;
325,326c237,240
<   agreementIt->second.second.insert (it, mpdu);
<   agreementIt->second.first.NotifyTransmittedMpdu (mpdu);
---
>   if (queueIt == it->second.second.end ())
>     {
>       it->second.second.push_back (item);
>     }
329,330c243,244
< Ptr<const WifiMacQueueItem>
< BlockAckManager::GetBar (bool remove)
---
> void
> BlockAckManager::CompleteAmpduExchange (Mac48Address recipient, uint8_t tid)
332,337c246,250
<   Ptr<const WifiMacQueueItem> bar;
<   // remove all expired MPDUs in the retransmission queue, so that Block Ack Requests
<   // (if needed) are scheduled
<   m_retryPackets->Remove (WifiMacQueue::EMPTY, true);
< 
<   auto nextBar = m_bars.begin ();
---
>   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
>   NS_ASSERT (it != m_agreements.end ());
>   OriginatorBlockAckAgreement &agreement = (*it).second.first;
>   agreement.CompleteExchange ();
> }
339c252,260
<   while (nextBar != m_bars.end ())
---
> Ptr<const Packet>
> BlockAckManager::GetNextPacket (WifiMacHeader &hdr, bool removePacket)
> {
>   NS_LOG_FUNCTION (this << &hdr);
>   Ptr<const Packet> packet = 0;
>   uint8_t tid;
>   Mac48Address recipient;
>   CleanupBuffers ();
>   if (!m_retryPackets.empty ())
341c262,264
<       if (nextBar->bar->GetHeader ().IsBlockAckReq ())
---
>       NS_LOG_DEBUG ("Retry buffer size is " << m_retryPackets.size ());
>       std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>       while (it != m_retryPackets.end ())
343,345c266
<           Mac48Address recipient = nextBar->bar->GetHeader ().GetAddr1 ();
<           AgreementsI it = m_agreements.find (std::make_pair (recipient, nextBar->tid));
<           if (it == m_agreements.end ())
---
>           if ((*it)->hdr.IsQosData ())
347,349c268
<               // BA agreement was torn down; remove this BAR and continue
<               nextBar = m_bars.erase (nextBar);
<               continue;
---
>               tid = (*it)->hdr.GetQosTid ();
351,353c270
<           if (nextBar->skipIfNoDataQueued
<               && m_retryPackets->PeekByTidAndAddress (nextBar->tid, recipient) == m_retryPackets->end ()
<               && m_queue->PeekByTidAndAddress (nextBar->tid, recipient) == m_queue->end ())
---
>           else
355,357c272
<               // skip this BAR as there is no data queued
<               nextBar++;
<               continue;
---
>               NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
359,360c274,277
<           // remove expired outstanding MPDUs and update the starting sequence number
<           for (auto mpduIt = it->second.second.begin (); mpduIt != it->second.second.end (); )
---
>           recipient = (*it)->hdr.GetAddr1 ();
>           AgreementsI agreement = m_agreements.find (std::make_pair (recipient, tid));
>           NS_ASSERT (agreement != m_agreements.end ());
>           if (removePacket)
362c279
<               if ((*mpduIt)->GetTimeStamp () + m_queue->GetMaxDelay () <= Simulator::Now ())
---
>               if (QosUtilsIsOldPacket (agreement->second.first.GetStartingSequence (),(*it)->hdr.GetSequenceNumber ()))
364,366c281,285
<                   // MPDU expired
<                   it->second.first.NotifyDiscardedMpdu (*mpduIt);
<                   mpduIt = it->second.second.erase (mpduIt);
---
>                   //Standard says the originator should not send a packet with seqnum < winstart
>                   NS_LOG_DEBUG ("The Retry packet have sequence number < WinStartO --> Discard " << (*it)->hdr.GetSequenceNumber () << " " << agreement->second.first.GetStartingSequence ());
>                   agreement->second.second.erase ((*it));
>                   it = m_retryPackets.erase (it);
>                   continue;
368c287,320
<               else
---
>               else if ((*it)->hdr.GetSequenceNumber () > (agreement->second.first.GetStartingSequence () + 63) % 4096)
>                 {
>                   agreement->second.first.SetStartingSequence ((*it)->hdr.GetSequenceNumber ());
>                 }
>             }
>           packet = (*it)->packet->Copy ();
>           hdr = (*it)->hdr;
>           hdr.SetRetry ();
>           if (hdr.IsQosData ())
>             {
>               tid = hdr.GetQosTid ();
>             }
>           else
>             {
>               NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>             }
>           recipient = hdr.GetAddr1 ();
>           if (!agreement->second.first.IsHtSupported ()
>               && (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED)
>                   || SwitchToBlockAckIfNeeded (recipient, tid, hdr.GetSequenceNumber ())))
>             {
>               hdr.SetQosAckPolicy (WifiMacHeader::BLOCK_ACK);
>             }
>           else
>             {
>               /* From section 9.10.3 in IEEE802.11e standard:
>                * In order to improve efficiency, originators using the Block Ack facility
>                * may send MPDU frames with the Ack Policy subfield in QoS control frames
>                * set to Normal Ack if only a few MPDUs are available for transmission.[...]
>                * When there are sufficient number of MPDUs, the originator may switch back to
>                * the use of Block Ack.
>                */
>               hdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
>               if (removePacket)
370c322,323
<                   mpduIt++;
---
>                   AgreementsI i = m_agreements.find (std::make_pair (recipient, tid));
>                   i->second.second.erase (*it);
373,376c326,376
<           // update BAR if the starting sequence number changed
<           CtrlBAckRequestHeader reqHdr;
<           nextBar->bar->GetPacket ()->PeekHeader (reqHdr);
<           if (reqHdr.GetStartingSequence () != it->second.first.GetStartingSequence ())
---
>           if (removePacket)
>             {
>               NS_LOG_INFO ("Retry packet seq = " << hdr.GetSequenceNumber ());
>               it = m_retryPackets.erase (it);
>               NS_LOG_DEBUG ("Removed one packet, retry buffer size = " << m_retryPackets.size ());
>             }
>           break;
>         }
>     }
>   return packet;
> }
> 
> Ptr<const Packet>
> BlockAckManager::PeekNextPacketByTidAndAddress (WifiMacHeader &hdr, uint8_t tid, Time *tstamp)
> {
>   NS_LOG_FUNCTION (this);
>   Ptr<const Packet> packet = 0;
>   CleanupBuffers ();
>   Mac48Address recipient = hdr.GetAddr1 ();
>   AgreementsI agreement = m_agreements.find (std::make_pair (recipient, tid));
>   NS_ASSERT (agreement != m_agreements.end ());
>   std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>   for (; it != m_retryPackets.end (); it++)
>     {
>       if (!(*it)->hdr.IsQosData ())
>         {
>           NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>         }
>       if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid)
>         {
>           if (QosUtilsIsOldPacket (agreement->second.first.GetStartingSequence (),(*it)->hdr.GetSequenceNumber ()))
>             {
>               //standard says the originator should not send a packet with seqnum < winstart
>               NS_LOG_DEBUG ("The Retry packet have sequence number < WinStartO --> Discard " << (*it)->hdr.GetSequenceNumber () << " " << agreement->second.first.GetStartingSequence ());
>               agreement->second.second.erase ((*it));
>               it = m_retryPackets.erase (it);
>               it--;
>               continue;
>             }
>           else if ((*it)->hdr.GetSequenceNumber () > (agreement->second.first.GetStartingSequence () + 63) % 4096)
>             {
>               agreement->second.first.SetStartingSequence ((*it)->hdr.GetSequenceNumber ());
>             }
>           packet = (*it)->packet->Copy ();
>           hdr = (*it)->hdr;
>           hdr.SetRetry ();
>           *tstamp = (*it)->timestamp;
>           NS_LOG_INFO ("Retry packet seq = " << hdr.GetSequenceNumber ());
>           if (!agreement->second.first.IsHtSupported ()
>               && (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED)
>                   || SwitchToBlockAckIfNeeded (recipient, tid, hdr.GetSequenceNumber ())))
378,381c378
<               reqHdr.SetStartingSequence (it->second.first.GetStartingSequence ());
<               Ptr<Packet> packet = Create<Packet> ();
<               packet->AddHeader (reqHdr);
<               nextBar->bar = Create<const WifiMacQueueItem> (packet, nextBar->bar->GetHeader ());
---
>               hdr.SetQosAckPolicy (WifiMacHeader::BLOCK_ACK);
382a380,392
>           else
>             {
>               /* From section 9.10.3 in IEEE802.11e standard:
>                * In order to improve efficiency, originators using the Block Ack facility
>                * may send MPDU frames with the Ack Policy subfield in QoS control frames
>                * set to Normal Ack if only a few MPDUs are available for transmission.[...]
>                * When there are sufficient number of MPDUs, the originator may switch back to
>                * the use of Block Ack.
>                */
>               hdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
>             }
>           NS_LOG_DEBUG ("Peeked one packet from retry buffer size = " << m_retryPackets.size () );
>           return packet;
383a394,396
>     }
>   return packet;
> }
385,386c398,409
<       bar = nextBar->bar;
<       if (remove)
---
> bool
> BlockAckManager::RemovePacket (uint8_t tid, Mac48Address recipient, uint16_t seqnumber)
> {
> 
>   std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>   for (; it != m_retryPackets.end (); it++)
>     {
>       if (!(*it)->hdr.IsQosData ())
>         {
>           NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>         }
>       if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid && (*it)->hdr.GetSequenceNumber () == seqnumber)
388c411,416
<           m_bars.erase (nextBar);
---
>           WifiMacHeader hdr = (*it)->hdr;
>           AgreementsI i = m_agreements.find (std::make_pair (recipient, tid));
>           i->second.second.erase ((*it));
>           m_retryPackets.erase (it);
>           NS_LOG_DEBUG ("Removed Packet from retry queue = " << hdr.GetSequenceNumber () << " " << +tid << " " << recipient << " Buffer Size = " << m_retryPackets.size ());
>           return true;
390d417
<       break;
392c419,432
<   return bar;
---
>   return false;
> }
> 
> bool
> BlockAckManager::HasBar (Bar &bar)
> {
>   NS_LOG_FUNCTION (this << &bar);
>   if (m_bars.size () > 0)
>     {
>       bar = m_bars.front ();
>       m_bars.pop_front ();
>       return true;
>     }
>   return false;
396c436
< BlockAckManager::HasPackets (void)
---
> BlockAckManager::HasPackets (void) const
399c439
<   return (!m_retryPackets->IsEmpty () || GetBar (false) != 0);
---
>   return (m_retryPackets.size () > 0 || m_bars.size () > 0);
415c455
<       uint16_t currentSeq = (*queueIt)->GetHeader ().GetSequenceNumber ();
---
>       uint16_t currentSeq = (*queueIt).hdr.GetSequenceNumber ();
418c458
<       while (queueIt != (*it).second.second.end () && (*queueIt)->GetHeader ().GetSequenceNumber () == currentSeq)
---
>       while (queueIt != (*it).second.second.end () && (*queueIt).hdr.GetSequenceNumber () == currentSeq)
425a466,500
> uint32_t
> BlockAckManager::GetNRetryNeededPackets (Mac48Address recipient, uint8_t tid) const
> {
>   NS_LOG_FUNCTION (this << recipient << +tid);
>   uint32_t nPackets = 0;
>   uint16_t currentSeq = 0;
>   if (ExistsAgreement (recipient, tid))
>     {
>       std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>       while (it != m_retryPackets.end ())
>         {
>           if (!(*it)->hdr.IsQosData ())
>             {
>               NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>             }
>           if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid)
>             {
>               currentSeq = (*it)->hdr.GetSequenceNumber ();
>               nPackets++;
>               /* a fragmented packet must be counted as one packet */
>               while (it != m_retryPackets.end () && (*it)->hdr.GetSequenceNumber () == currentSeq)
>                 {
>                   it++;
>                 }
>             }
>           //go to next packet
>           else
>             {
>               it++;
>             }
>         }
>     }
>   return nPackets;
> }
> 
440,441c515,516
< void
< BlockAckManager::NotifyGotAck (Ptr<const WifiMacQueueItem> mpdu)
---
> bool
> BlockAckManager::AlreadyExists (uint16_t currentSeq, Mac48Address recipient, uint8_t tid) const
443,455c518,519
<   NS_LOG_FUNCTION (this << *mpdu);
<   NS_ASSERT (mpdu->GetHeader ().IsQosData ());
< 
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   NS_ASSERT (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED));
< 
<   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (it != m_agreements.end ());
< 
<   // remove the acknowledged frame from the queue of outstanding packets
<   PacketQueueI queueIt = it->second.second.begin ();
<   while (queueIt != it->second.second.end ())
---
>   std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>   while (it != m_retryPackets.end ())
457c521,522
<       if ((*queueIt)->GetHeader ().GetSequenceNumber () == mpdu->GetHeader ().GetSequenceNumber ())
---
>       NS_LOG_FUNCTION (this << (*it)->hdr.GetType ());
>       if (!(*it)->hdr.IsQosData ())
459c524
<           queueIt = it->second.second.erase (queueIt);
---
>           NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
461,488c526
<       else
<       {
<         queueIt++;
<       }
<     }
< 
<   it->second.first.NotifyAckedMpdu (mpdu);
< }
< 
< void
< BlockAckManager::NotifyMissedAck (Ptr<WifiMacQueueItem> mpdu)
< {
<   NS_LOG_FUNCTION (this << *mpdu);
<   NS_ASSERT (mpdu->GetHeader ().IsQosData ());
< 
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   NS_ASSERT (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED));
< 
<   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (it != m_agreements.end ());
< 
<   // remove the frame from the queue of outstanding packets (it will be re-inserted
<   // if retransmitted)
<   PacketQueueI queueIt = it->second.second.begin ();
<   while (queueIt != it->second.second.end ())
<     {
<       if ((*queueIt)->GetHeader ().GetSequenceNumber () == mpdu->GetHeader ().GetSequenceNumber ())
---
>       if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid && currentSeq == (*it)->hdr.GetSequenceNumber ())
490c528
<           queueIt = it->second.second.erase (queueIt);
---
>           return true;
492,495c530
<       else
<       {
<         queueIt++;
<       }
---
>       it++;
497,499c532
< 
<   // insert in the retransmission queue
<   InsertInRetryQueue (mpdu);
---
>   return false;
503c536
< BlockAckManager::NotifyGotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, double dataSnr, WifiTxVector dataTxVector)
---
> BlockAckManager::NotifyGotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, WifiMode txMode, double dataSnr)
505c538,539
<   NS_LOG_FUNCTION (this << blockAck << recipient << rxSnr << dataSnr << dataTxVector);
---
>   NS_LOG_FUNCTION (this << blockAck << recipient << rxSnr << txMode.GetUniqueName () << dataSnr);
>   uint16_t sequenceFirstLost = 0;
519c553
<               /* Upon reception of a BlockAck frame, the inactivity timer at the
---
>               /* Upon reception of a block ack frame, the inactivity timer at the
529,532d562
< 
<           uint16_t currentStartingSeq = it->second.first.GetStartingSequence ();
<           uint16_t currentSeq = SEQNO_SPACE_SIZE;   // invalid value
< 
537,539c567,568
<                   currentSeq = (*queueIt)->GetHeader ().GetSequenceNumber ();
<                   if (blockAck->IsFragmentReceived (currentSeq,
<                                                     (*queueIt)->GetHeader ().GetFragmentNumber ()))
---
>                   if (blockAck->IsFragmentReceived ((*queueIt).hdr.GetSequenceNumber (),
>                                                     (*queueIt).hdr.GetFragmentNumber ()))
541a571,572
>                       RemoveFromRetryQueue (recipient, tid, (*queueIt).hdr.GetSequenceNumber ());
>                       queueIt = it->second.second.erase (queueIt);
543c574
<                   else if (!QosUtilsIsOldPacket (currentStartingSeq, currentSeq))
---
>                   else
548c579,580
<                           RemoveOldPackets (recipient, tid, currentSeq);
---
>                           sequenceFirstLost = (*queueIt).hdr.GetSequenceNumber ();
>                           (*it).second.first.SetStartingSequence (sequenceFirstLost);
551c583,587
<                       InsertInRetryQueue (*queueIt);
---
>                       if (!AlreadyExists ((*queueIt).hdr.GetSequenceNumber (),recipient,tid))
>                         {
>                           InsertInRetryQueue (queueIt);
>                         }
>                       queueIt++;
553,559d588
<                   // in any case, this packet is no longer outstanding
<                   queueIt = it->second.second.erase (queueIt);
<                 }
<               // If all frames were acknowledged, move the transmit window past the last one
<               if (!foundFirstLost && currentSeq != SEQNO_SPACE_SIZE)
<                 {
<                   RemoveOldPackets (recipient, tid, (currentSeq + 1) % SEQNO_SPACE_SIZE);
562,564c591
<           //// WIGIG ////
<           else if (blockAck->IsCompressed () || blockAck->IsExtendedCompressed () || blockAck->IsEdmgCompressed ())
<           //// WIGIG ////
---
>           else if (blockAck->IsCompressed ())
568c595
<                   currentSeq = (*queueIt)->GetHeader ().GetSequenceNumber ();
---
>                   uint16_t currentSeq = (*queueIt).hdr.GetSequenceNumber ();
571,573c598,599
<                       it->second.first.NotifyAckedMpdu (*queueIt);
<                       nSuccessfulMpdus++;
<                       if (!m_txOkCallback.IsNull ())
---
>                       while (queueIt != queueEnd
>                              && (*queueIt).hdr.GetSequenceNumber () == currentSeq)
575c601,607
<                           m_txOkCallback ((*queueIt)->GetHeader ());
---
>                           nSuccessfulMpdus++;
>                           if (!m_txOkCallback.IsNull ())
>                             {
>                               m_txOkCallback ((*queueIt).hdr);
>                             }
>                           RemoveFromRetryQueue (recipient, tid, currentSeq);
>                           queueIt = it->second.second.erase (queueIt);
578c610
<                   else if (!QosUtilsIsOldPacket (currentStartingSeq, currentSeq))
---
>                   else
579a612,617
>                       if (!foundFirstLost)
>                         {
>                           foundFirstLost = true;
>                           sequenceFirstLost = (*queueIt).hdr.GetSequenceNumber ();
>                           (*it).second.first.SetStartingSequence (sequenceFirstLost);
>                         }
583c621,625
<                           m_txFailedCallback ((*queueIt)->GetHeader ());
---
>                           m_txFailedCallback ((*queueIt).hdr);
>                         }
>                       if (!AlreadyExists ((*queueIt).hdr.GetSequenceNumber (),recipient,tid))
>                         {
>                           InsertInRetryQueue (queueIt);
585c627
<                       InsertInRetryQueue (*queueIt);
---
>                       queueIt++;
587,588d628
<                   // in any case, this packet is no longer outstanding
<                   queueIt = it->second.second.erase (queueIt);
591c631,637
<           m_stationManager->ReportAmpduTxStatus (recipient, nSuccessfulMpdus, nFailedMpdus, rxSnr, dataSnr, dataTxVector);
---
>           m_stationManager->ReportAmpduTxStatus (recipient, tid, nSuccessfulMpdus, nFailedMpdus, rxSnr, dataSnr);
>           uint16_t newSeq = m_txMiddle->GetNextSeqNumberByTidAndAddress (tid, recipient);
>           if ((foundFirstLost && !SwitchToBlockAckIfNeeded (recipient, tid, sequenceFirstLost))
>               || (!foundFirstLost && !SwitchToBlockAckIfNeeded (recipient, tid, newSeq)))
>             {
>               it->second.first.CompleteExchange ();
>             }
600,640d645
<   
< void
< BlockAckManager::NotifyMissedBlockAck (Mac48Address recipient, uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   if (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
<     {
<       AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<       for (auto& item : it->second.second)
<         {
<           // Queue previously transmitted packets that do not already exist in the retry queue.
<           InsertInRetryQueue (item);
<         }
<       // remove all packets from the queue of outstanding packets (they will be
<       // re-inserted if retransmitted)
<       it->second.second.clear ();
<     }
< }
< 
< void
< BlockAckManager::DiscardOutstandingMpdus (Mac48Address recipient, uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   if (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
<     {
<       AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<       while (!it->second.second.empty ())
<         {
<           Ptr<WifiMacQueueItem> mpdu = it->second.second.front ();
<           if (it->second.first.GetDistance (mpdu->GetHeader ().GetSequenceNumber ()) >= SEQNO_SPACE_HALF_SIZE)
<             {
<               // old packet
<               it->second.second.pop_front ();
<             }
<           else
<             {
<               NotifyDiscardedMpdu (mpdu);
<             }
<         }
<     }
< }
649,701c654,655
< void
< BlockAckManager::NotifyDiscardedMpdu (Ptr<const WifiMacQueueItem> mpdu)
< {
<   NS_LOG_FUNCTION (this << *mpdu);
< 
<   if (!mpdu->GetHeader ().IsQosData ())
<     {
<       NS_LOG_DEBUG ("Not a QoS Data frame");
<       return;
<     }
< 
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   if (!ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
<     {
<       NS_LOG_DEBUG ("No established Block Ack agreement");
<       return;
<     }
< 
<   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<   uint16_t currStartingSeq = it->second.first.GetStartingSequence ();
<   if (QosUtilsIsOldPacket (currStartingSeq, mpdu->GetHeader ().GetSequenceNumber ()))
<     {
<       NS_LOG_DEBUG ("Discarded an old frame");
<       return;
<     }
< 
<   // remove outstanding frames and frames in the retransmit queue with a sequence
<   // number less than or equal to the discarded MPDU
<   RemoveOldPackets (recipient, tid, (mpdu->GetHeader ().GetSequenceNumber () + 1) % SEQNO_SPACE_SIZE);
<   // actually advance the transmit window
<   it->second.first.NotifyDiscardedMpdu (mpdu);
< 
<   // schedule a BlockAckRequest
<   NS_LOG_DEBUG ("Schedule a Block Ack Request for agreement (" << recipient << ", " << +tid << ")");
<   Ptr<Packet> bar = Create<Packet> ();
<   bar->AddHeader (GetBlockAckReqHeader (recipient, tid));
< 
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_CTL_BACKREQ);
<   hdr.SetAddr1 (recipient);
<   hdr.SetAddr2 (mpdu->GetHeader ().GetAddr2 ());
<   hdr.SetAddr3 (mpdu->GetHeader ().GetAddr3 ());
<   hdr.SetDsNotTo ();
<   hdr.SetDsNotFrom ();
<   hdr.SetNoRetry ();
<   hdr.SetNoMoreFragments ();
< 
<   ScheduleBar (Create<const WifiMacQueueItem> (bar, hdr));
< }
< 
< CtrlBAckRequestHeader
< BlockAckManager::GetBlockAckReqHeader (Mac48Address recipient, uint8_t tid) const
---
> Ptr<Packet>
> BlockAckManager::ScheduleBlockAckReqIfNeeded (Mac48Address recipient, uint8_t tid)
702a657,661
>   /* This method checks if a BlockAckRequest frame should be send to the recipient station.
>      Number of packets under block ack is specified in OriginatorBlockAckAgreement object but sometimes
>      this number could be incorrect. In fact is possible that a block ack agreement exists for n
>      packets but some of these packets are dropped due to MSDU lifetime expiration.
>    */
704c663
<   AgreementsCI it = m_agreements.find (std::make_pair (recipient, tid));
---
>   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
707,726c666,668
<   CtrlBAckRequestHeader reqHdr;
<   reqHdr.SetType (m_blockAckType);
<   reqHdr.SetTidInfo (tid);
<   reqHdr.SetStartingSequence ((*it).second.first.GetStartingSequence ());
<   return reqHdr;
< }
< 
< void
< BlockAckManager::ScheduleBar (Ptr<const WifiMacQueueItem> bar, bool skipIfNoDataQueued)
< {
<   NS_LOG_FUNCTION (this << *bar);
<   NS_ASSERT (bar->GetHeader ().IsBlockAckReq ());
< 
<   CtrlBAckRequestHeader reqHdr;
<   bar->GetPacket ()->PeekHeader (reqHdr);
<   uint8_t tid = reqHdr.GetTidInfo ();
<   Bar request (bar, tid, skipIfNoDataQueued);
< 
<   // if a BAR for the given agreement is present, replace it with the new one
<   for (std::list<Bar>::const_iterator i = m_bars.begin (); i != m_bars.end (); i++)
---
>   if ((*it).second.first.IsBlockAckRequestNeeded ()
>       || (GetNRetryNeededPackets (recipient, tid) == 0
>           && m_queue->GetNPacketsByTidAndAddress (tid, recipient) == 0))
728c670,674
<       if (i->bar->GetHeader ().GetAddr1 () == bar->GetHeader ().GetAddr1 () && i->tid == tid)
---
>       OriginatorBlockAckAgreement &agreement = (*it).second.first;
>       agreement.CompleteExchange ();
> 
>       CtrlBAckRequestHeader reqHdr;
>       if (m_blockAckType == BASIC_BLOCK_ACK || m_blockAckType == COMPRESSED_BLOCK_ACK)
730,732c676,678
<           i = m_bars.erase (i);
<           m_bars.insert (i, request);
<           return;
---
>           reqHdr.SetType (m_blockAckType);
>           reqHdr.SetTidInfo (agreement.GetTid ());
>           reqHdr.SetStartingSequence (agreement.GetStartingSequence ());
733a680,690
>       else if (m_blockAckType == MULTI_TID_BLOCK_ACK)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Invalid block ack type.");
>         }
>       Ptr<Packet> bar = Create<Packet> ();
>       bar->AddHeader (reqHdr);
>       return bar;
735,743c692
< 
<   if (bar->GetHeader ().IsRetry ())
<     {
<       m_bars.push_front (request);
<     }
<   else
<     {
<       m_bars.push_back (request);
<     }
---
>   return 0;
759,762d707
<   if (!it->second.first.IsEstablished ())
<   {
<     m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED);
<   }
768c713
< BlockAckManager::NotifyAgreementRejected (Mac48Address recipient, uint8_t tid)
---
> BlockAckManager::NotifyAgreementUnsuccessful (Mac48Address recipient, uint8_t tid)
773c718
<   if (!it->second.first.IsRejected ())
---
>   if (it != m_agreements.end ())
775c720
<       m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::REJECTED);
---
>       it->second.first.SetState (OriginatorBlockAckAgreement::UNSUCCESSFUL);
777d721
<   it->second.first.SetState (OriginatorBlockAckAgreement::REJECTED);
781c725
< BlockAckManager::NotifyAgreementNoReply (Mac48Address recipient, uint8_t tid)
---
> BlockAckManager::NotifyMpduTransmission (Mac48Address recipient, uint8_t tid, uint16_t nextSeqNumber, WifiMacHeader::QosAckPolicy policy)
783c727,728
<   NS_LOG_FUNCTION (this << recipient << +tid);
---
>   NS_LOG_FUNCTION (this << recipient << +tid << nextSeqNumber);
>   Ptr<Packet> bar = 0;
786c731,732
<   if (!it->second.first.IsNoReply ())
---
>   uint16_t nextSeq;
>   if (GetNRetryNeededPackets (recipient, tid) > 0)
788c734
<       m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::NO_REPLY);
---
>       nextSeq = GetSeqNumOfNextRetryPacket (recipient, tid);
790,800c736
<   it->second.first.SetState (OriginatorBlockAckAgreement::NO_REPLY);
<   m_unblockPackets (recipient, tid);
< }
< 
< void
< BlockAckManager::NotifyAgreementReset (Mac48Address recipient, uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (it != m_agreements.end ());
<   if (!it->second.first.IsReset ())
---
>   else
802c738,748
<       m_agreementState (Simulator::Now (), recipient, tid, OriginatorBlockAckAgreement::RESET);
---
>       nextSeq = nextSeqNumber;
>     }
>   it->second.first.NotifyMpduTransmission (nextSeq);
>   if (policy == WifiMacHeader::BLOCK_ACK)
>     {
>       bar = ScheduleBlockAckReqIfNeeded (recipient, tid);
>       if (bar != 0)
>         {
>           Bar request (bar, recipient, tid, it->second.first.IsImmediateBlockAck ());
>           m_bars.push_back (request);
>         }
804d749
<   it->second.first.SetState (OriginatorBlockAckAgreement::RESET);
819c764
<   if (!ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::REJECTED) && ExistsAgreement (recipient, tid))
---
>   if (!ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::UNSUCCESSFUL) && ExistsAgreement (recipient, tid))
832c777
< bool BlockAckManager::NeedBarRetransmission (uint8_t tid, Mac48Address recipient)
---
> bool BlockAckManager::NeedBarRetransmission (uint8_t tid, uint16_t seqNumber, Mac48Address recipient)
834c779,783
<   if (ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
---
>   //The standard says the BAR gets discarded when all MSDUs lifetime expires
>   AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
>   NS_ASSERT (it != m_agreements.end ());
>   CleanupBuffers ();
>   if ((seqNumber + 63) < it->second.first.GetStartingSequence ())
836,846c785,803
<       AgreementsI it = m_agreements.find (std::make_pair (recipient, tid));
<       NS_ASSERT (it != m_agreements.end ());
< 
<       // A BAR needs to be retransmitted if there is at least a non-expired outstanding MPDU
<       for (auto& mpdu : it->second.second)
<         {
<           if (mpdu->GetTimeStamp () + m_queue->GetMaxDelay () > Simulator::Now ())
<             {
<               return true;
<             }
<         }
---
>       return false;
>     }
>   else if (it->second.first.GetTimeout () > 0 && it->second.first.m_inactivityEvent.IsExpired ())
>     {
>       /*
>        * According to "11.5.4 Error recovery upon a peer failure",
>        * DELBA should be issued after inactivity timeout,
>        * so block ack request should not be retransmitted anymore.
>        *
>        * Otherwise we risk retransmitting BAR forever if condition
>        * above is never met and the STA is not available.
>        *
>        * See https://www.nsnam.org/bugzilla/show_bug.cgi?id=2928 for details.
>        */
>       return false;
>     }
>   else
>     {
>       return true;
848,851d804
< 
<   // If the inactivity timer has expired, QosTxop::SendDelbaFrame has been called and
<   // has destroyed the agreement, hence we get here and correctly return false
<   return false;
857,876c810,816
<   RemoveFromRetryQueue (address, tid, seq, seq);
< }
< 
< void
< BlockAckManager::RemoveFromRetryQueue (Mac48Address address, uint8_t tid, uint16_t startSeq, uint16_t endSeq)
< {
<   NS_LOG_FUNCTION (this << address << +tid << startSeq << endSeq);
< 
<   AgreementsI agreementIt = m_agreements.find (std::make_pair (address, tid));
<   NS_ASSERT (agreementIt != m_agreements.end ());
< 
<   /* remove retry packet iterators if they are present in retry queue */
<   WifiMacQueue::ConstIterator it = m_retryPackets->PeekByTidAndAddress (tid, address);
< 
<   while (it != m_retryPackets->end ())
<     {
<       uint16_t itSeq = (*it)->GetHeader ().GetSequenceNumber ();
< 
<       if (agreementIt->second.first.GetDistance (itSeq) >= agreementIt->second.first.GetDistance (startSeq)
<           && agreementIt->second.first.GetDistance (itSeq) <= agreementIt->second.first.GetDistance (endSeq))
---
>   /* remove retry packet iterator if it's present in retry queue */
>   std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>   while (it != m_retryPackets.end ())
>     {
>       if ((*it)->hdr.GetAddr1 () == address
>           && (*it)->hdr.GetQosTid () == tid
>           && (*it)->hdr.GetSequenceNumber () == seq)
878,880c818
<           NS_LOG_DEBUG ("Removing frame with seqnum = " << itSeq);
<           it = m_retryPackets->Remove (it);
<           it = m_retryPackets->PeekByTidAndAddress (tid, address, it);
---
>           it = m_retryPackets.erase (it);
884c822
<           it = m_retryPackets->PeekByTidAndAddress (tid, address, ++it);
---
>           it++;
890c828
< BlockAckManager::RemoveOldPackets (Mac48Address recipient, uint8_t tid, uint16_t startingSeq)
---
> BlockAckManager::CleanupBuffers (void)
892,912c830,831
<   NS_LOG_FUNCTION (this << recipient << +tid << startingSeq);
< 
<   AgreementsI agreementIt = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (agreementIt != m_agreements.end ());
<   uint16_t currStartingSeq = agreementIt->second.first.GetStartingSequence ();
< 
<   NS_ABORT_MSG_IF (agreementIt->second.first.GetDistance (startingSeq) >= SEQNO_SPACE_HALF_SIZE,
<                    "The new starting sequence number is an old sequence number");
< 
<   if (startingSeq == currStartingSeq)
<     {
<       return;
<     }
< 
<   // remove packets that will become old from the retransmission queue
<   uint16_t lastRemovedSeq = (startingSeq - 1 + SEQNO_SPACE_SIZE) % SEQNO_SPACE_SIZE;
<   RemoveFromRetryQueue (recipient, tid, currStartingSeq, lastRemovedSeq);
< 
<   // remove packets that will become old from the queue of outstanding packets
<   PacketQueueI it = agreementIt->second.second.begin ();
<   while (it != agreementIt->second.second.end ())
---
>   NS_LOG_FUNCTION (this);
>   for (AgreementsI j = m_agreements.begin (); j != m_agreements.end (); j++)
914,916c833
<       uint16_t itSeq = (*it)->GetHeader ().GetSequenceNumber ();
< 
<       if (agreementIt->second.first.GetDistance (itSeq) <= agreementIt->second.first.GetDistance (lastRemovedSeq))
---
>       if (j->second.second.empty ())
918,919c835
<           NS_LOG_DEBUG ("Removing frame with seqnum = " << itSeq);
<           it = agreementIt->second.second.erase (it);
---
>           continue;
921c837,839
<       else
---
>       Time now = Simulator::Now ();
>       PacketQueueI end = j->second.second.begin ();
>       for (PacketQueueI i = j->second.second.begin (); i != j->second.second.end (); i++)
923c841,851
<           it++;
---
>           if (i->timestamp + m_maxDelay > now)
>             {
>               end = i;
>               break;
>             }
>           else
>             {
>               RemoveFromRetryQueue (j->second.first.GetPeer (),
>                                     j->second.first.GetTid (),
>                                     i->hdr.GetSequenceNumber ());
>             }
924a853,854
>       j->second.second.erase (j->second.second.begin (), end);
>       j->second.first.SetStartingSequence (end->hdr.GetSequenceNumber ());
928a859,865
> BlockAckManager::SetMaxPacketDelay (Time maxDelay)
> {
>   NS_LOG_FUNCTION (this << maxDelay);
>   m_maxDelay = maxDelay;
> }
> 
> void
955a893,912
> uint16_t
> BlockAckManager::GetSeqNumOfNextRetryPacket (Mac48Address recipient, uint8_t tid) const
> {
>   NS_LOG_FUNCTION (this << recipient << +tid);
>   std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin ();
>   while (it != m_retryPackets.end ())
>     {
>       if (!(*it)->hdr.IsQosData ())
>         {
>           NS_FATAL_ERROR ("Packet in blockAck manager retry queue is not Qos Data");
>         }
>       if ((*it)->hdr.GetAddr1 () == recipient && (*it)->hdr.GetQosTid () == tid)
>         {
>           return (*it)->hdr.GetSequenceNumber ();
>         }
>       it++;
>     }
>   return 4096;
> }
> 
969c926
< BlockAckManager::InsertInRetryQueue (Ptr<WifiMacQueueItem> mpdu)
---
> BlockAckManager::InsertInRetryQueue (PacketQueueI item)
971,982c928,929
<   NS_LOG_INFO ("Adding to retry queue " << *mpdu);
<   NS_ASSERT (mpdu->GetHeader ().IsQosData ());
< 
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
< 
<   AgreementsI agreementIt = m_agreements.find (std::make_pair (recipient, tid));
<   NS_ASSERT (agreementIt != m_agreements.end ());
< 
<   uint16_t mpduDist = agreementIt->second.first.GetDistance (mpdu->GetHeader ().GetSequenceNumber ());
< 
<   if (mpduDist >= SEQNO_SPACE_HALF_SIZE)
---
>   NS_LOG_INFO ("Adding to retry queue " << (*item).hdr.GetSequenceNumber ());
>   if (m_retryPackets.size () == 0)
984,985c931
<       NS_LOG_DEBUG ("Got an old packet. Do nothing");
<       return;
---
>       m_retryPackets.push_back (item);
987,990c933
< 
<   WifiMacQueue::ConstIterator it = m_retryPackets->PeekByTidAndAddress (tid, recipient);
< 
<   while (it != m_retryPackets->end ())
---
>   else
992c935
<       if (mpdu->GetHeader ().GetSequenceControl () == (*it)->GetHeader ().GetSequenceControl ())
---
>       for (std::list<PacketQueueI>::const_iterator it = m_retryPackets.begin (); it != m_retryPackets.end (); )
994,1003c937,949
<           NS_LOG_DEBUG ("Packet already in the retransmit queue");
<           return;
<         }
< 
<       uint16_t dist = agreementIt->second.first.GetDistance ((*it)->GetHeader ().GetSequenceNumber ());
< 
<       if (mpduDist < dist ||
<           (mpduDist == dist && mpdu->GetHeader ().GetFragmentNumber () < (*it)->GetHeader ().GetFragmentNumber ()))
<         {
<           break;
---
>           if (((item->hdr.GetSequenceNumber () - (*it)->hdr.GetSequenceNumber () + 4096) % 4096) > 2047)
>             {
>               it = m_retryPackets.insert (it, item);
>               break;
>             }
>           else
>             {
>               it++;
>               if (it == m_retryPackets.end ())
>                 {
>                   m_retryPackets.push_back (item);
>                 }
>             }
1005,1031d950
< 
<       it = m_retryPackets->PeekByTidAndAddress (tid, recipient, ++it);
<     }
<   mpdu->GetHeader ().SetRetry ();
<   m_retryPackets->Insert (it, mpdu);
< }
< 
< uint16_t
< BlockAckManager::GetRecipientBufferSize (Mac48Address recipient, uint8_t tid) const
< {
<   uint16_t size = 0;
<   AgreementsCI it = m_agreements.find (std::make_pair (recipient, tid));
<   if (it != m_agreements.end ())
<     {
<       size = it->second.first.GetBufferSize ();
<     }
<   return size;
< }
< 
< uint16_t
< BlockAckManager::GetOriginatorStartingSequence (Mac48Address recipient, uint8_t tid) const
< {
<   uint16_t seqNum = 0;
<   AgreementsCI it = m_agreements.find (std::make_pair (recipient, tid));
<   if (it != m_agreements.end ())
<     {
<       seqNum = it->second.first.GetStartingSequence ();
1033d951
<   return seqNum;
diff ../../NS3-WiGig/src/wifi/model/block-ack-manager.h ../../ns-3-dev-git/src/wifi/model/block-ack-manager.h
26d25
< #include "ns3/traced-callback.h"
29d27
< #include "wifi-remote-station-manager.h"
31d28
< #include "wifi-mac-queue-item.h"
39d35
< class CtrlBAckRequestHeader;
47c43
<  * \brief BlockAckRequest frame information
---
>  * \brief Block Ack Request
54c50,51
<    * Store a BlockAckRequest along with the corresponding TID.
---
>    * Construct Block ACK request for a given packet,
>    * receiver address, Traffic ID, and ACK policy.
56,63c53,65
<    * \param bar the BAR
<    * \param tid the Traffic ID
<    * \param skipIfNoDataQueued true to hold this BAR if there is no data queued
<    */
<   Bar (Ptr<const WifiMacQueueItem> bar, uint8_t tid, bool skipIfNoDataQueued = false);
<   Ptr<const WifiMacQueueItem> bar;  ///< BlockAckRequest
<   uint8_t tid;                      ///< TID
<   bool skipIfNoDataQueued;          ///< do not send if there is no data queued
---
>    * \param packet
>    * \param recipient
>    * \param tid
>    * \param immediate
>    */
>   Bar (Ptr<const Packet> packet,
>        Mac48Address recipient,
>        uint8_t tid,
>        bool immediate);
>   Ptr<const Packet> bar; ///< block ack request
>   Mac48Address recipient; ///< recipient
>   uint8_t tid; ///< TID
>   bool immediate; ///< immediate
102,108d103
<    *
<    * Copy all block ack agreement exists with station addressed by
<    * <i>recipient</i> for tid <i>tid</i>.
<    */
<   void CopyAgreements (Mac48Address recipient, Ptr<BlockAckManager> manager);
<   /**
<    * \param recipient Address of peer station involved in block ack mechanism.
114c109
<    * <i>recipient</i> for TID <i>tid</i>.
---
>    * <i>recipient</i> for tid <i>tid</i>.
125c120
<    * station addressed by <i>recipient</i> for TID <i>tid</i>.
---
>    * station addressed by <i>recipient</i> for tid <i>tid</i>.
139c134
<    * \param tid traffic ID of transmitted packet.
---
>    * \param tid Tid Traffic id of transmitted packet.
141c136
<    * Invoked when a recipient reject a block ack agreement or when a DELBA frame
---
>    * Invoked when a recipient reject a block ack agreement or when a Delba frame
153c148,150
<    * \param mpdu MPDU to store.
---
>    * \param packet Packet to store.
>    * \param hdr 802.11 header for packet.
>    * \param tStamp time stamp for packet
155,156c152,153
<    * Stores <i>mpdu</i> for a possible future retransmission. Retransmission occurs
<    * if the packet, in a BlockAck frame, is indicated by recipient as not received.
---
>    * Stores <i>packet</i> for a possible future retransmission. Retransmission occurs
>    * if the packet, in a block ack frame, is indicated by recipient as not received.
158c155
<   void StorePacket (Ptr<WifiMacQueueItem> mpdu);
---
>   void StorePacket (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp);
160c157,158
<    * Returns the next BlockAckRequest to send, if any.
---
>    * \param hdr 802.11 header of returned packet (if exists).
>    * \param removePacket flag to indicate whether the packet should be removed from the queue.
162c160
<    * \param remove true if the BAR has to be removed from the queue
---
>    * \return the packet
164c162,163
<    * \return the next BAR to be sent, if any
---
>    * This methods returns a packet (if exists) indicated as not received in
>    * corresponding block ack bitmap.
166c165
<   Ptr<const WifiMacQueueItem> GetBar (bool remove = true);
---
>   Ptr<const Packet> GetNextPacket (WifiMacHeader &hdr, bool removePacket);
168,169c167
<    * Returns true if there are packets that need of retransmission or at least a
<    * BAR is scheduled. Returns false otherwise.
---
>    * Returns true if the BAR is scheduled. Returns false otherwise.
171,179c169
<    * \return true if there are packets that need of retransmission or at least a BAR is scheduled,
<    *         false otherwise
<    */
<   bool HasPackets (void);
<   /**
<    * Invoked upon receipt of an Ack frame after the transmission of a QoS data frame
<    * sent under an established block ack agreement. Remove the acknowledged frame
<    * from the outstanding packets and update the starting sequence number of the
<    * transmit window, if needed.
---
>    * \param bar
181c171
<    * \param mpdu The acknowledged MPDU.
---
>    * \return true if a BAR is scheduled, false otherwise
183c173
<   void NotifyGotAck (Ptr<const WifiMacQueueItem> mpdu);
---
>   bool HasBar (Bar &bar);
185,188c175,176
<    * Invoked upon missed reception of an Ack frame after the transmission of a
<    * QoS data frame sent under an established block ack agreement. Remove the
<    * acknowledged frame from the outstanding packets and insert it in the
<    * retransmission queue.
---
>    * Returns true if there are packets that need of retransmission or at least a
>    * BAR is scheduled. Returns false otherwise.
190c178,179
<    * \param mpdu The unacknowledged MPDU.
---
>    * \return true if there are packets that need of retransmission or at least a BAR is scheduled,
>    *         false otherwise
192c181
<   void NotifyMissedAck (Ptr<WifiMacQueueItem> mpdu);
---
>   bool HasPackets (void) const;
194,196c183,186
<    * \param blockAck The received BlockAck frame.
<    * \param recipient Sender of BlockAck frame.
<    * \param rxSnr received SNR of the BlockAck frame itself
---
>    * \param blockAck The received block ack frame.
>    * \param recipient Sender of block ack frame.
>    * \param rxSnr received SNR of the block ack frame itself
>    * \param txMode mode of block ack frame.
198d187
<    * \param dataTxVector the TXVECTOR used to send the Data
200c189
<    * Invoked upon receipt of a BlockAck frame. Typically, this function, is called
---
>    * Invoked upon receipt of a block ack frame. Typically, this function, is called
202c191
<    * with Ack Policy set to Block Ack, were correctly received by the recipient.
---
>    * with ack policy set to Block Ack, were correctly received by the recipient.
205,206c194
<   void NotifyGotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient,
<                           double rxSnr, double dataSnr, WifiTxVector dataTxVector);
---
>   void NotifyGotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, WifiMode txMode, double dataSnr);
208c196
<    * \param recipient Sender of the expected BlockAck frame.
---
>    * \param recipient Address of peer station involved in block ack mechanism.
211,218c199
<    * Invoked upon missed reception of a block ack frame. Typically, this function, is called
<    * by ns3::QosTxop object. Performs a check on which MPDUs, previously sent
<    * with ack policy set to Block Ack, should be placed in the retransmission queue.
<    */
<   void NotifyMissedBlockAck (Mac48Address recipient, uint8_t tid);
<   /**
<    * \param recipient outstanding frames' receiver.
<    * \param tid Traffic ID.
---
>    * \return the number of packets buffered for a specified agreement
220,222c201,202
<    * Discard all the outstanding MPDUs destined to the given receiver and belonging
<    * to the given TID. Typically, this function is called by ns3::QosTxop object
<    * when it gives up retransmitting either a BlockAckRequest or the Data frames.
---
>    * Returns number of packets buffered for a specified agreement. This methods doesn't return
>    * number of buffered MPDUs but number of buffered MSDUs.
224c204
<   void DiscardOutstandingMpdus (Mac48Address recipient, uint8_t tid);
---
>   uint32_t GetNBufferedPackets (Mac48Address recipient, uint8_t tid) const;
229c209
<    * \return the number of packets buffered for a specified agreement
---
>    * \return the number of packets for a specific agreement that need retransmission
231,232c211,212
<    * Returns the number of packets buffered for a specified agreement. This methods doesn't return
<    * the number of buffered MPDUs but the number of buffered MSDUs.
---
>    * Returns number of packets for a specific agreement that need retransmission.
>    * This method doesn't return number of MPDUs that need retransmission but number of MSDUs.
234c214
<   uint32_t GetNBufferedPackets (Mac48Address recipient, uint8_t tid) const;
---
>   uint32_t GetNRetryNeededPackets (Mac48Address recipient, uint8_t tid) const;
248c228
<    * Marks an agreement as rejected. This happens if <i>recipient</i> station reject block ack setup
---
>    * Marks an agreement as unsuccessful. This happens if <i>recipient</i> station reject block ack setup
252c232
<   void NotifyAgreementRejected (Mac48Address recipient, uint8_t tid);
---
>   void NotifyAgreementUnsuccessful (Mac48Address recipient, uint8_t tid);
255a236,237
>    * \param nextSeqNumber Sequence number of the next packet that would be trasmitted by QosTxop.
>    * \param policy ack policy of the transmitted packet.
257,259c239,241
<    * Marks an agreement after not receiving response to ADDBA request. During this state
<    * any packets in queue will be transmitted using normal MPDU. This also unblock
<    * recipient address.
---
>    * This method is typically invoked by ns3::QosTxop object every time that a MPDU
>    * with ack policy subfield in Qos Control field set to Block Ack is transmitted.
>    * The <i>nextSeqNumber</i> parameter is used to block transmission of packets that are out of bitmap.
261c243
<   void NotifyAgreementNoReply (Mac48Address recipient, uint8_t tid);
---
>   void NotifyMpduTransmission (Mac48Address recipient, uint8_t tid, uint16_t nextSeqNumber, WifiMacHeader::QosAckPolicy policy);
266c248
<    * Set BA agreement to a transitory state to reset it after not receiving response to ADDBA request.
---
>    * This method to set the number of packets waiting for blockAck = 0 since the receiver will send the blockAck right away
268c250
<   void NotifyAgreementReset (Mac48Address recipient, uint8_t tid);
---
>   void CompleteAmpduExchange (Mac48Address recipient, uint8_t tid);
272c254
<    * Upon receipt of a BlockAck frame, if total number of packets (packets in WifiMacQueue
---
>    * Upon receipt of a block ack frame, if total number of packets (packets in WifiMacQueue
276,281d257
<   /**
<    * \return the retransmit queue.
<    *
<    * Return the retransmit queue.
<    */
<   Ptr<WifiMacQueue> GetRetransmitQueue (void);
294c270
<    * \param bAckType Type of BlockAck
---
>    * \param bAckType Type of block ack
298a275,281
>   /**
>    * \param maxDelay Max delay for a buffered packet.
>    *
>    * This method is always called by ns3::WifiMacQueue object and sets max delay equals
>    * to ns3:WifiMacQueue delay value.
>    */
>   void SetMaxPacketDelay (Time maxDelay);
301,302c284,285
<    * Set BlockAck inactivity callback
<    * \param callback the BlockAck inactivity callback function
---
>    * Set block ack inactivity callback
>    * \param callback the block ack inactivity callback function
319c302
<    * \param startingSeq the starting sequence number
---
>    * \param startingSeq
321c304
<    * \return true if there are packets in the queue that could be sent under block ack,
---
>    * \return true if there are packets in the queue that could be sent under block ACK,
331,333c314,315
<    * This function returns true if a block ack agreement is established with the
<    * given recipient for the given TID and there is at least an outstanding MPDU
<    * for such agreement whose lifetime is not expired.
---
>    * \param recipient the destination address
>    * \param tid the Traffic ID
335,336c317
<    * \param tid Traffic ID
<    * \param recipient MAC address of the recipient
---
>    * \return the sequence number of the next retry packet for a specific agreement
338c319,321
<    * \returns true if BAR retransmission needed
---
>    * Returns the sequence number of the next retry packet for a specific agreement.
>    * If there are no packets that need retransmission for the specified agreement or
>    * the agreement doesn't exist the function returns 4096;
340c323
<   bool NeedBarRetransmission (uint8_t tid, Mac48Address recipient);
---
>   uint16_t GetSeqNumOfNextRetryPacket (Mac48Address recipient, uint8_t tid) const;
342c325
<    * This function returns the buffer size negotiated with the recipient.
---
>    * Checks if the packet already exists in the retransmit queue or not if it does then it doesn't add it again
343a327,346
>    * \param currentSeq the current sequence
>    * \param recipient the destination address
>    * \param tid the Traffic ID
>    * \returns true if the packet already exists
>    */
>   bool AlreadyExists (uint16_t currentSeq, Mac48Address recipient, uint8_t tid) const;
>   /**
>    * Remove a packet after you peek in the queue and get it
>    * \param tid the Traffic ID
>    * \param recipient the destination address
>    * \param seqnumber sequence number
>    * \returns true if a packet was removed
>    */
>   bool RemovePacket (uint8_t tid, Mac48Address recipient, uint16_t seqnumber);
>   /**
>    * Peek in retransmit queue and get the next packet having address indicated
>    * by <i>type</i> equals to <i>addr</i>, and tid equals to <i>tid</i>.
>    * This method doesn't remove the packet from this queue.
>    *
>    * \param hdr wifi mac header
345c348
<    * \param recipient MAC address of the recipient
---
>    * \param timestamp timestamp
347c350
<    * \returns the buffer size negotiated with the recipient
---
>    * \returns Ptr<const Packet>
349c352
<   uint16_t GetRecipientBufferSize (Mac48Address recipient, uint8_t tid) const;
---
>   Ptr<const Packet> PeekNextPacketByTidAndAddress (WifiMacHeader &hdr, uint8_t tid, Time *timestamp);
351c354,355
<    * This function returns the starting sequence number of the transmit window.
---
>    * This function returns true if the lifetime of the packets a BAR refers to didn't expire yet else it returns false.
>    * If it return false then the BAR will be discarded (i.e. will not be re-transmitted)
354c358,359
<    * \param recipient MAC address of the recipient
---
>    * \param seqNumber sequence number
>    * \param recipient MAC address
356c361
<    * \returns the starting sequence number of the transmit window (WinStartO)
---
>    * \returns true if BAR retransmission needed
358c363
<   uint16_t GetOriginatorStartingSequence (Mac48Address recipient, uint8_t tid) const;
---
>   bool NeedBarRetransmission (uint8_t tid, uint16_t seqNumber, Mac48Address recipient);
381,389d385
<   /**
<    * TracedCallback signature for state changes.
<    *
<    * \param [in] now Time when the \pname{state} changed.
<    * \param [in] recipient MAC address of the recipient.
<    * \param [in] tid the TID.
<    * \param [in] state The state.
<    */
<   typedef void (* AgreementStateTracedCallback)(Time now, Mac48Address recipient, uint8_t tid, OriginatorBlockAckAgreement::State state);
390a387
> private:
392c389,390
<    * \param mpdu the discarded frame
---
>    * \param recipient
>    * \param tid
394,405c392
<    * Notify the block ack manager that an MPDU has been discarded, e.g., because
<    * the MSDU lifetime expired. If there is an established block ack agreement,
<    * make the transmit window advance beyond the discarded frame. This also
<    * involves (i) the removal of frames that consequently become old from the
<    * retransmit queue and from the queue of the block ack agreement, and (ii) the
<    * scheduling of a BlockAckRequest.
<    */
<   void NotifyDiscardedMpdu (Ptr<const WifiMacQueueItem> mpdu);
< 
<   /**
<    * \param recipient the recipient
<    * \param tid the TID
---
>    * \return a packet
407,408c394,397
<    * Get the BlockAckRequest header for the established BA agreement
<    * (<i>recipient</i>,<i>tid</i>).
---
>    * Checks if all packets, for which a block ack agreement was established or refreshed,
>    * have been transmitted. If yes, adds a pair in m_bAckReqs to indicate that
>    * at next channel access a block ack request (for established agreement
>    * <i>recipient</i>,<i>tid</i>) is needed.
410c399
<   CtrlBAckRequestHeader GetBlockAckReqHeader (Mac48Address recipient, uint8_t tid) const;
---
>   Ptr<Packet> ScheduleBlockAckReqIfNeeded (Mac48Address recipient, uint8_t tid);
413,419c402
<    * \param bar the BlockAckRequest to enqueue
<    * \param skipIfNoDataQueued do not send if there is no data queued
<    *
<    * Enqueue the given BlockAckRequest into the queue storing the next BAR
<    * frames to transmit. If a BAR for the same recipient and TID is already present
<    * in the queue, it is replaced by the new one. If the given BAR is retransmitted,
<    * it is placed at the head of the queue, otherwise at the tail.
---
>    * This method removes packets whose lifetime was exceeded.
421,423c404
<   void ScheduleBar (Ptr<const WifiMacQueueItem> bar, bool skipIfNoDataQueued = false);
< 
< private:
---
>   void CleanupBuffers (void);
430a412
>   struct Item;
432,439c414
<    * Remove packets from the retransmit queue and from the queue of outstanding
<    * packets that become old after setting the starting sequence number for the
<    * agreement with recipient equal to <i>recipient</i> and TID equal to <i>tid</i>
<    * to the given <i>startingSeq</i>.
<    *
<    * \param recipient the recipient MAC address
<    * \param tid Traffic ID
<    * \param startingSeq the new starting sequence number
---
>    * typedef for a list of Item struct.
441,446c416
<   void RemoveOldPackets (Mac48Address recipient, uint8_t tid, uint16_t startingSeq);
< 
<   /**
<    * typedef for a list of WifiMacQueueItem.
<    */
<   typedef std::list<Ptr<WifiMacQueueItem>> PacketQueue;
---
>   typedef std::list<Item> PacketQueue;
450c420
<   typedef std::list<Ptr<WifiMacQueueItem>>::iterator PacketQueueI;
---
>   typedef std::list<Item>::iterator PacketQueueI;
454c424
<   typedef std::list<Ptr<WifiMacQueueItem>>::const_iterator PacketQueueCI;
---
>   typedef std::list<Item>::const_iterator PacketQueueCI;
456c426
<    * typedef for a map between MAC address and block ack agreement.
---
>    * typedef for a map between MAC address and block ACK agreement.
472c442,462
<    * \param mpdu the packet to insert in the retransmission queue
---
>    * A struct for packet, Wifi header, and timestamp.
>    * Used in queue by block ACK manager.
>    */
>   struct Item
>   {
>     /**
>      * Constructor
>      *
>      * \param packet packet
>      * \param hdr packet header
>      * \param tStamp timestamp
>      */
>     Item (Ptr<const Packet> packet,
>           const WifiMacHeader &hdr,
>           Time tStamp);
>     Ptr<const Packet> packet; ///< packet
>     WifiMacHeader hdr; ///< header
>     Time timestamp; ///< timestamp
>   };
>   /**
>    * \param item
474c464
<    * Insert <i>mpdu</i> in retransmission queue.
---
>    * Insert item in retransmission queue.
477c467
<   void InsertInRetryQueue (Ptr<WifiMacQueueItem> mpdu);
---
>   void InsertInRetryQueue (PacketQueueI item);
480c470
<    * Remove an item from retransmission queue.
---
>    * Remove items from retransmission queue.
483c473
<    * \param address recipient MAC address of the packet to be removed
---
>    * \param address recipient mac address of the packet to be removed
490,501c480
<    * Remove a range of items from retransmission queue.
<    * This method should be called when packets are acknowledged.
<    *
<    * \param address recipient MAC address of the packet to be removed
<    * \param tid Traffic ID of the packet to be removed
<    * \param startSeq sequence number of the first packet to be removed
<    * \param endSeq sequence number of the last packet to be removed
<    */
<   void RemoveFromRetryQueue (Mac48Address address, uint8_t tid, uint16_t startSeq, uint16_t endSeq);
< 
<   /**
<    * This data structure contains, for each block ack agreement (recipient, TID), a set of packets
---
>    * This data structure contains, for each block ack agreement (recipient, tid), a set of packets
503c482
<    * Every packet or fragment indicated as correctly received in BlockAck frame is
---
>    * Every packet or fragment indicated as correctly received in block ack frame is
510c489
<    * A packet needs retransmission if it's indicated as not correctly received in a BlockAck
---
>    * A packet needs retransmission if it's indicated as not correctly received in a block ack
513c492
<   Ptr<WifiMacQueue> m_retryPackets;
---
>   std::list<PacketQueueI> m_retryPackets;
517c496,497
<   BlockAckType m_blockAckType; ///< BlockAck type
---
>   BlockAckType m_blockAckType; ///< block ack type
>   Time m_maxDelay; ///< maximum delay
519,522c499,502
<   Mac48Address m_address;      ///< address
<   Ptr<WifiMacQueue> m_queue;   ///< queue
<   Callback<void, Mac48Address, uint8_t, bool> m_blockAckInactivityTimeout; ///< BlockAck inactivity timeout callback
<   Callback<void, Mac48Address, uint8_t> m_blockPackets;   ///< block packets callback
---
>   Mac48Address m_address; ///< address
>   Ptr<WifiMacQueue> m_queue; ///< queue
>   Callback<void, Mac48Address, uint8_t, bool> m_blockAckInactivityTimeout; ///< block ack inactivity timeout callback
>   Callback<void, Mac48Address, uint8_t> m_blockPackets; ///< block packets callback
524,531c504,506
<   TxOk m_txOkCallback;                                    ///< transmit OK callback
<   TxFailed m_txFailedCallback;                            ///< transmit failed callback
<   Ptr<WifiRemoteStationManager> m_stationManager;         ///< the station manager
< 
<   /**
<    * The trace source fired when a state transition occurred.
<    */
<   TracedCallback<Time, Mac48Address, uint8_t, OriginatorBlockAckAgreement::State> m_agreementState;
---
>   TxOk m_txOkCallback; ///< transmit ok callback
>   TxFailed m_txFailedCallback; ///< transmit failed callback
>   Ptr<WifiRemoteStationManager> m_stationManager; ///< the station manager
diff ../../NS3-WiGig/src/wifi/model/block-ack-type.h ../../ns-3-dev-git/src/wifi/model/block-ack-type.h
28c28
<  * The different block ack policies.
---
>  * The different block ACK policies.
34,39c34
<   EXTENDED_COMPRESSED_BLOCK_ACK,
<   MULTI_TID_BLOCK_ACK,
<   //// WIGIG ////
<   EDMG_COMPRESSED_BLOCK_ACK,
<   EDMG_MULTI_TID_BLOCK_ACK,
<   //// WIGIG ////
---
>   MULTI_TID_BLOCK_ACK
Only in ../../NS3-WiGig/src/wifi/model: block-ack-window.cc
Only in ../../NS3-WiGig/src/wifi/model: block-ack-window.h
diff ../../NS3-WiGig/src/wifi/model/cara-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/cara-wifi-manager.cc
39c39
<   uint32_t m_timer;   ///< timer count
---
>   uint32_t m_timer; ///< timer count
41,42c41,42
<   uint32_t m_failed;  ///< failed count
<   uint8_t m_rate;     ///< rate in bps
---
>   uint32_t m_failed; ///< failed count
>   uint8_t m_rate; ///< rate
94,111d93
< void
< CaraWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
134c116
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
---
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
165,166c147,148
< CaraWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> CaraWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                  double ackSnr, WifiMode ackMode, double dataSnr)
168,169c150,151
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
203c185
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
---
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
206a189
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
215c198
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
222c205
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
---
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
227a211
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
240c224
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
246c230
<                             uint32_t size, bool normally)
---
>                             Ptr<const Packet> packet, bool normally)
248,249c232,233
<   NS_LOG_FUNCTION (this << st << size << normally);
<   CaraWifiRemoteStation *station = static_cast<CaraWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << normally);
>   CaraWifiRemoteStation *station = (CaraWifiRemoteStation *) st;
250a235,270
> }
> 
> bool
> CaraWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
> void
> CaraWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> CaraWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> CaraWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/cara-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/cara-wifi-manager.h
40c40
<  * This RAA does not support HT modes and will error
---
>  * This RAA does not support HT, VHT nor HE modes and will error
42c42
<  * that supports 802.11n or higher.
---
>  * that has VhtSupported, HtSupported or HeSupported set.
54a55,59
>   // Inherited from WifiRemoteStationManager
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
> 
57,58c62
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
66,67c70,71
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
73c77,78
<                   uint32_t size, bool normally);
---
>                   Ptr<const Packet> packet, bool normally);
>   bool IsLowLatency (void) const;
75c80
<   uint32_t m_timerTimeout;     ///< timer threshold
---
>   uint32_t m_timerTimeout; ///< timer threshold
78c83
<   uint32_t m_probeThreshold;   ///< probe threshold
---
>   uint32_t m_probeThreshold; ///< probe threshold
Only in ../../NS3-WiGig/src/wifi/model: cbtraa-dmg-wifi-manager.cc
Only in ../../NS3-WiGig/src/wifi/model: cbtraa-dmg-wifi-manager.h
diff ../../NS3-WiGig/src/wifi/model/cf-parameter-set.cc ../../ns-3-dev-git/src/wifi/model/cf-parameter-set.cc
49c49
<   //we should not be here if PCF is not supported
---
>   //we should not be here if pcf is not supported
148a149,156
> /**
>  * output operator
>  *
>  * \param os output stream
>  * \param cfParameterSet
>  *
>  * \return output stream
>  */
diff ../../NS3-WiGig/src/wifi/model/cf-parameter-set.h ../../ns-3-dev-git/src/wifi/model/cf-parameter-set.h
37a38,42
>   /**
>    * Set PCF supported function
>    * \param pcfSupported the PCF supported indicator
>    */
>   void SetPcfSupported (uint8_t pcfSupported);
39c44,47
<   // Implementations of pure virtual methods of WifiInformationElement
---
>   /**
>    * Element ID function
>    * \returns the wifi information element ID
>    */
40a49,52
>   /**
>    * Get information field size function
>    * \returns the information field size
>    */
41a54,57
>   /**
>    * Serialize information field function
>    * \param start the iterator
>    */
43,50d58
<   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is a QoS STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
52,53c60,63
<    * Set PCF supported function
<    * \param pcfSupported the PCF supported indicator
---
>    * Deserialize information field function
>    * \param start the iterator
>    * \param length the length
>    * \returns the size
55c65
<   void SetPcfSupported (uint8_t pcfSupported);
---
>   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
70c80
<    * Return the maximum CFP duration in microseconds.
---
>    * Return the CFP MaxDuration in microseconds.
72c82
<    * \return the maximum CFP duration in microseconds.
---
>    * \return the CFP MaxDuration in microseconds.
76c86
<    * Return the remaining CFP duration in microseconds.
---
>    * Return the CFP DurRemaining in microseconds.
78c88
<    * \return the remaining CFP duration in microseconds
---
>    * \return the CFP DurRemaining in microseconds
85c95
<    * \param count the CFP Count in DTIM frames unit
---
>    * \param cfpcount the CFP Count in DTIM frames unit
87c97
<   void SetCFPCount (uint8_t count);
---
>   void SetCFPCount (uint8_t cfpcount);
91c101,107
<    * \param period the CFP Period in DTIM frames unit
---
>    * \param cfpperiod the CFP Period in DTIM frames unit
>    */
>   void SetCFPPeriod (uint8_t cfpperiod);
>   /**
>    * Set the CFP MaxDuration in microseconds.
>    *
>    * \param cfpmaxduration the CFP MaxDuration in microseconds
93c109
<   void SetCFPPeriod (uint8_t period);
---
>   void SetCFPMaxDurationUs (uint64_t cfpmaxduration);
95c111
<    * Set the maximum CFP duration in microseconds.
---
>    * Set the CFP MaxDuration in microseconds.
97c113
<    * \param maxDuration the maximum CFP duration in microseconds
---
>    * \param cfpdurremaining the CFP DurRemaining in microseconds
99c115,116
<   void SetCFPMaxDurationUs (uint64_t maxDuration);
---
>   void SetCFPDurRemainingUs (uint64_t cfpdurremaining);
> 
101c118,123
<    * Set the remaining CFP duration in microseconds.
---
>    * This information element is a bit special in that it is only
>    * included if the STA is a QoS STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
103c125
<    * \param durRemaining the remaining CFP duration in microseconds
---
>    * \return an iterator
105c127,133
<   void SetCFPDurRemainingUs (uint64_t durRemaining);
---
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this EDCA Parameter Set.
>    *
>    * \return the serialized size of this EDCA Parameter Set
>    */
>   uint16_t GetSerializedSize () const;
111,112c139,140
<   uint64_t m_CFPMaxDuration;          ///< CFP maximum duration in microseconds
<   uint64_t m_CFPDurRemaining;         ///< CFP remaining duration in microseconds
---
>   uint64_t m_CFPMaxDuration;          ///< CFP MaxDuration
>   uint64_t m_CFPDurRemaining;         ///< CFP DurRemaining
118,125d145
< /**
<  * output operator
<  *
<  * \param os output stream
<  * \param cfParameterSet the CF Parameter Set
<  *
<  * \return output stream
<  */
diff ../../NS3-WiGig/src/wifi/model/channel-access-manager.cc ../../ns-3-dev-git/src/wifi/model/channel-access-manager.cc
42c42
<    * \param cam the ChannelAccessManager
---
>    * \param dcf
44,45c44,45
<   PhyListener (ns3::ChannelAccessManager *cam)
<     : m_cam (cam)
---
>   PhyListener (ns3::ChannelAccessManager *dcf)
>     : m_dcf (dcf)
53c53
<     m_cam->NotifyRxStartNow (duration);
---
>     m_dcf->NotifyRxStartNow (duration);
57c57
<     m_cam->NotifyRxEndOkNow ();
---
>     m_dcf->NotifyRxEndOkNow ();
61c61
<     m_cam->NotifyRxEndErrorNow ();
---
>     m_dcf->NotifyRxEndErrorNow ();
65c65
<     m_cam->NotifyTxStartNow (duration);
---
>     m_dcf->NotifyTxStartNow (duration);
69c69
<     m_cam->NotifyMaybeCcaBusyStartNow (duration);
---
>     m_dcf->NotifyMaybeCcaBusyStartNow (duration);
73c73
<     m_cam->NotifySwitchingStartNow (duration);
---
>     m_dcf->NotifySwitchingStartNow (duration);
77c77
<     m_cam->NotifySleepNow ();
---
>     m_dcf->NotifySleepNow ();
81c81
<     m_cam->NotifyOffNow ();
---
>     m_dcf->NotifyOffNow ();
85c85
<     m_cam->NotifyWakeupNow ();
---
>     m_dcf->NotifyWakeupNow ();
89c89
<     m_cam->NotifyOnNow ();
---
>     m_dcf->NotifyOnNow ();
93c93
<   ns3::ChannelAccessManager *m_cam;  //!< ChannelAccessManager to forward events to
---
>   ns3::ChannelAccessManager *m_dcf;  //!< ChannelAccessManager to forward events to
98c98
<  *      Implement the channel access manager of all Txop holders
---
>  *      Implement the DCF manager of all DCF state holders
108a109
>     m_lastRxEnd (MicroSeconds (0)),
114a116
>     m_rxing (false),
119,120c121
<     m_phyListener (0),
<     m_accessAllowed (true)
---
>     m_phyListener (0)
136c137
<   for (Ptr<Txop> i : m_txops)
---
>   for (Ptr<Txop> i : m_states)
141d141
<   m_phy = 0;
151d150
<   m_phy = phy;
163d161
<       m_phy = 0;
171c169
<   low->RegisterChannelAccessManager (this);
---
>   low->RegisterDcf (this);
203c201
< ChannelAccessManager::Add (Ptr<Txop> txop)
---
> ChannelAccessManager::Add (Ptr<Txop> dcf)
205,206c203,204
<   NS_LOG_FUNCTION (this << txop);
<   m_txops.push_back (txop);
---
>   NS_LOG_FUNCTION (this << dcf);
>   m_states.push_back (dcf);
210c208
< ChannelAccessManager::MostRecent (std::initializer_list<Time> list) const
---
> ChannelAccessManager::MostRecent (Time a, Time b) const
212,213c210,233
<   NS_ASSERT (list.size () > 0);
<   return *std::max_element (list.begin (), list.end ());
---
>   return Max (a, b);
> }
> 
> Time
> ChannelAccessManager::MostRecent (Time a, Time b, Time c, Time d, Time e, Time f) const
> {
>   Time g = MostRecent (a, b);
>   Time h = MostRecent (c, d);
>   Time i = MostRecent (e, f);
>   Time k = MostRecent (g, h);
>   Time retval = MostRecent (k, i);
>   return retval;
> }
> 
> Time
> ChannelAccessManager::MostRecent (Time a, Time b, Time c, Time d, Time e, Time f, Time g) const
> {
>   Time h = MostRecent (a, b);
>   Time i = MostRecent (c, d);
>   Time j = MostRecent (e, f);
>   Time k = MostRecent (h, i);
>   Time l = MostRecent (j, g);
>   Time retval = MostRecent (k, l);
>   return retval;
221,222c241
<   Time lastRxEnd = m_lastRxStart + m_lastRxDuration;
<   if (lastRxEnd > Simulator::Now ())
---
>   if (m_rxing)
246,305d264
< //// WIGIG ////
< void
< ChannelAccessManager::AllowChannelAccess ()
< {
<   m_accessAllowed = true;
< }
< 
< void
< ChannelAccessManager::DisableChannelAccess ()
< {
<   m_accessAllowed = false;
< 
<   Time now = Simulator::Now ();
< //  NS_ASSERT (m_lastTxStart + m_lastTxDuration <= now);
< //  if (m_rxing)
< //    {
< //      //Packet reception when the current allocation ends.
< //      m_lastRxEnd = Simulator::Now ();
< //      m_lastRxDuration = m_lastRxEnd - m_lastRxStart;
< //      m_lastRxReceivedOk = true;
< //      m_rxing = false;
< //    }
< //  if (m_lastNavStart + m_lastNavDuration > now)
< //    {
< //      m_lastNavDuration = now - m_lastNavStart;
< //    }
< //  if (m_lastBusyStart + m_lastBusyDuration > now)
< //    {
< //      m_lastBusyDuration = now - m_lastBusyStart;
< //    }
< //  if (m_lastAckTimeoutEnd > now)
< //    {
< //      m_lastAckTimeoutEnd = now;
< //    }
< //  if (m_lastCtsTimeoutEnd > now)
< //    {
< //      m_lastCtsTimeoutEnd = now;
< //    }
< 
<   //Cancel timeout
<   if (m_accessTimeout.IsRunning ())
<     {
<       m_accessTimeout.Cancel ();
<     }
< 
<   //Reset backoffs
<   for (auto txop : m_txops)
<     {
<       uint32_t remainingSlots = txop->GetBackoffSlots ();
<       if (remainingSlots > 0)
<         {
<           txop->UpdateBackoffSlotsNow (remainingSlots, now);
<           NS_ASSERT (txop->GetBackoffSlots () == 0);
<         }
<       txop->ResetCw ();
<       txop->m_accessRequested = false;
<     }
< }
< //// WIGIG ////
< 
307c266
< ChannelAccessManager::NeedBackoffUponAccess (Ptr<Txop> txop)
---
> ChannelAccessManager::IsWithinAifs (Ptr<Txop> state) const
309,334c268,270
<   NS_LOG_FUNCTION (this << txop);
< 
<   // the Txop might have a stale value of remaining backoff slots
<   UpdateBackoff ();
< 
<   /*
<    * From section 10.3.4.2 "Basic access" of IEEE 802.11-2016:
<    *
<    * A STA may transmit an MPDU when it is operating under the DCF access
<    * method, either in the absence of a PC, or in the CP of the PCF access
<    * method, when the STA determines that the medium is idle when a frame is
<    * queued for transmission, and remains idle for a period of a DIFS, or an
<    * EIFS (10.3.2.3.7) from the end of the immediately preceding medium-busy
<    * event, whichever is the greater, and the backoff timer is zero. Otherwise
<    * the random backoff procedure described in 10.3.4.3 shall be followed.
<    *
<    * From section 10.22.2.2 "EDCA backoff procedure" of IEEE 802.11-2016:
<    *
<    * The backoff procedure shall be invoked by an EDCAF when any of the following
<    * events occurs:
<    * a) An MA-UNITDATA.request primitive is received that causes a frame with that AC
<    *    to be queued for transmission such that one of the transmit queues associated
<    *    with that AC has now become non-empty and any other transmit queues
<    *    associated with that AC are empty; the medium is busy on the primary channel
<    */
<   if (!txop->HasFramesToTransmit () && !txop->GetLow ()->IsCfPeriod () && txop->GetBackoffSlots () == 0)
---
>   NS_LOG_FUNCTION (this << state);
>   Time ifsEnd = GetAccessGrantStart () + (state->GetAifsn () * m_slot);
>   if (ifsEnd > Simulator::Now ())
336,351c272,273
<       if (!IsBusy ())
<         {
<           // medium idle. If this is a DCF, use immediate access (we can transmit
<           // in a DIFS if the medium remains idle). If this is an EDCAF, update
<           // the backoff start time kept by the EDCAF to the current time in order
<           // to correctly align the backoff start time at the next slot boundary
<           // (performed by the next call to ChannelAccessManager::RequestAccess())
<           Time delay = (txop->IsQosTxop () ? Seconds (0)
<                                            : m_sifs + txop->GetAifsn () * m_slot);
<           txop->UpdateBackoffSlotsNow (0, Simulator::Now () + delay);
<         }
<       else
<         {
<           // medium busy, backoff is needed
<           return true;
<         }
---
>       NS_LOG_DEBUG ("IsWithinAifs () true; ifsEnd is at " << ifsEnd.GetSeconds ());
>       return true;
352a275
>   NS_LOG_DEBUG ("IsWithinAifs () false; ifsEnd was at " << ifsEnd.GetSeconds ());
356,389d278
< bool
< ChannelAccessManager::IsAccessAllowed () const
< {
<   return m_accessAllowed;
< }
< 
< bool
< ChannelAccessManager::CanAccess (void) const
< {
<   NS_LOG_FUNCTION (this);
<   //Deny access if in sleep mode
<   if (m_sleeping)
<     {
<       return false;
<     }
<   // PHY busy
<   Time lastRxEnd = m_lastRxStart + m_lastRxDuration;
<   if (lastRxEnd > Simulator::Now ())
<     {
<       return false;
<     }
<   Time lastTxEnd = m_lastTxStart + m_lastTxDuration;
<   if (lastTxEnd > Simulator::Now ())
<     {
<       return false;
<     }
<   // CCA busy
<   Time lastCCABusyEnd = m_lastBusyStart + m_lastBusyDuration;
<   if (lastCCABusyEnd > Simulator::Now ())
<     {
<       return false;
<     }
<   return true;
< }
392c281
< ChannelAccessManager::RequestAccess (Ptr<Txop> txop, bool isCfPeriod)
---
> ChannelAccessManager::RequestAccess (Ptr<Txop> state, bool isCfPeriod)
394,398c283
<   NS_LOG_FUNCTION (this << txop);
<   if (m_phy)
<     {
<       m_phy->NotifyChannelAccessRequested ();
<     }
---
>   NS_LOG_FUNCTION (this << state);
406,408c291,306
<       txop->NotifyAccessRequested ();
<       Time delay = (MostRecent ({GetAccessGrantStart (true), Simulator::Now ()}) - Simulator::Now ());
<       m_accessTimeout = Simulator::Schedule (delay, &ChannelAccessManager::DoGrantPcfAccess, this, txop);
---
>       state->NotifyAccessRequested ();
>       Time delay = (MostRecent (GetAccessGrantStart (true), Simulator::Now ()) - Simulator::Now ());
>       m_accessTimeout = Simulator::Schedule (delay, &ChannelAccessManager::GrantPcfAccess, this, state);
>       return;
>     }
>   UpdateBackoff ();
>   NS_ASSERT (!state->IsAccessRequested ());
>   state->NotifyAccessRequested ();
>   // If currently transmitting; end of transmission (ACK or no ACK) will cause
>   // a later access request if needed from EndTxNoAck, GotAck, or MissedAck
>   Time lastTxEnd = m_lastTxStart + m_lastTxDuration;
>   if (lastTxEnd > Simulator::Now ())
>     {
>       NS_LOG_DEBUG ("Internal collision (currently transmitting)");
>       state->NotifyInternalCollision ();
>       DoRestartAccessTimeoutIfNeeded ();
411,412c309,311
<   /*
<    * EDCAF operations shall be performed at slot boundaries (Sec. 10.22.2.4 of 802.11-2016)
---
>   /**
>    * If there is a collision, generate a backoff
>    * by notifying the collision to the user.
414,416c313
<   Time accessGrantStart = GetAccessGrantStart () + (txop->GetAifsn () * m_slot);
< 
<   if (txop->IsQosTxop () && txop->GetBackoffStart () > accessGrantStart)
---
>   if (state->GetBackoffSlots () == 0)
418,423c315,329
<       // The backoff start time reported by the EDCAF is more recent than the last
<       // time the medium was busy plus an AIFS, hence we need to align it to the
<       // next slot boundary.
<       Time diff = txop->GetBackoffStart () - accessGrantStart;
<       uint32_t nIntSlots = (diff / m_slot).GetHigh () + 1;
<       txop->UpdateBackoffSlotsNow (0, accessGrantStart + (nIntSlots * m_slot));
---
>       if (IsBusy ())
>         {
>           NS_LOG_DEBUG ("medium is busy: collision");
>           // someone else has accessed the medium; generate a backoff.
>           state->NotifyCollision ();
>           DoRestartAccessTimeoutIfNeeded ();
>           return;
>         }
>       else if (IsWithinAifs (state))
>         {
>           NS_LOG_DEBUG ("busy within AIFS");
>           state->NotifyCollision ();
>           DoRestartAccessTimeoutIfNeeded ();
>           return;
>         }
425,429c331
< 
<   UpdateBackoff ();
<   NS_ASSERT (!txop->IsAccessRequested ());
<   txop->NotifyAccessRequested ();
<   DoGrantDcfAccess ();
---
>   DoGrantAccess ();
434c336
< ChannelAccessManager::DoGrantPcfAccess (Ptr<Txop> txop)
---
> ChannelAccessManager::GrantPcfAccess (Ptr<Txop> state) //to be renamed
436c338
<   txop->NotifyAccessGranted ();
---
>   state->NotifyAccessGranted ();
440c342
< ChannelAccessManager::DoGrantDcfAccess (void)
---
> ChannelAccessManager::DoGrantAccess (void)
444c346
<   for (Txops::iterator i = m_txops.begin (); i != m_txops.end (); k++)
---
>   for (States::iterator i = m_states.begin (); i != m_states.end (); k++)
446,448c348,350
<       Ptr<Txop> txop = *i;
<       if (txop->IsAccessRequested ()
<           && GetBackoffEndFor (txop) <= Simulator::Now () )
---
>       Ptr<Txop> state = *i;
>       if (state->IsAccessRequested ()
>           && GetBackoffEndFor (state) <= Simulator::Now () )
451c353
<            * This is the first Txop we find with an expired backoff and which
---
>            * This is the first dcf we find with an expired backoff and which
454c356
<           NS_LOG_DEBUG ("dcf " << k << " needs access. backoff expired. access granted. slots=" << txop->GetBackoffSlots ());
---
>           NS_LOG_DEBUG ("dcf " << k << " needs access. backoff expired. access granted. slots=" << state->GetBackoffSlots ());
457,458c359,360
<           std::vector<Ptr<Txop> > internalCollisionTxops;
<           for (Txops::iterator j = i; j != m_txops.end (); j++, k++)
---
>           std::vector<Ptr<Txop> > internalCollisionStates;
>           for (States::iterator j = i; j != m_states.end (); j++, k++)
460,462c362,364
<               Ptr<Txop> otherTxop = *j;
<               if (otherTxop->IsAccessRequested ()
<                   && GetBackoffEndFor (otherTxop) <= Simulator::Now ())
---
>               Ptr<Txop> otherState = *j;
>               if (otherState->IsAccessRequested ()
>                   && GetBackoffEndFor (otherState) <= Simulator::Now ())
465c367
<                                 otherTxop->GetBackoffSlots ());
---
>                                 otherState->GetBackoffSlots ());
467c369
<                    * all other Txops with a lower priority whose backoff
---
>                    * all other dcfs with a lower priority whose backoff
471c373
<                   internalCollisionTxops.push_back (otherTxop);
---
>                   internalCollisionStates.push_back (otherState);
477c379
<            * perform first the calculations of which Txops are colliding and then
---
>            * perform first the calculations of which states are colliding and then
482,483c384,386
<           txop->NotifyAccessGranted ();
<           for (auto collidingTxop : internalCollisionTxops)
---
>           state->NotifyAccessGranted ();
>           for (std::vector<Ptr<Txop> >::iterator l = internalCollisionStates.begin ();
>                l != internalCollisionStates.end (); l++)
485c388
<               collidingTxop->NotifyInternalCollision ();
---
>               (*l)->NotifyInternalCollision ();
498c401
<   DoGrantDcfAccess ();
---
>   DoGrantAccess ();
506,508c409,418
<   Time lastRxEnd = m_lastRxStart + m_lastRxDuration;
<   Time rxAccessStart = lastRxEnd + m_sifs;
<   if ((lastRxEnd <= Simulator::Now ()) && !m_lastRxReceivedOk)
---
>   Time rxAccessStart;
>   if (!m_rxing)
>     {
>       rxAccessStart = m_lastRxEnd + m_sifs;
>       if (!m_lastRxReceivedOk)
>         {
>           rxAccessStart += m_eifsNoDifs;
>         }
>     }
>   else
510c420
<       rxAccessStart += m_eifsNoDifs;
---
>       rxAccessStart = m_lastRxStart + m_lastRxDuration + m_sifs;
521,526c431,436
<       accessGrantedStart = MostRecent ({rxAccessStart,
<                                         busyAccessStart,
<                                         txAccessStart,
<                                         ackTimeoutAccessStart,
<                                         ctsTimeoutAccessStart,
<                                         switchingAccessStart}
---
>       accessGrantedStart = MostRecent (rxAccessStart,
>                                        busyAccessStart,
>                                        txAccessStart,
>                                        ackTimeoutAccessStart,
>                                        ctsTimeoutAccessStart,
>                                        switchingAccessStart
531,537c441,447
<       accessGrantedStart = MostRecent ({rxAccessStart,
<                                         busyAccessStart,
<                                         txAccessStart,
<                                         navAccessStart,
<                                         ackTimeoutAccessStart,
<                                         ctsTimeoutAccessStart,
<                                         switchingAccessStart}
---
>       accessGrantedStart = MostRecent (rxAccessStart,
>                                        busyAccessStart,
>                                        txAccessStart,
>                                        navAccessStart,
>                                        ackTimeoutAccessStart,
>                                        ctsTimeoutAccessStart,
>                                        switchingAccessStart
549c459
< ChannelAccessManager::GetBackoffStartFor (Ptr<Txop> txop)
---
> ChannelAccessManager::GetBackoffStartFor (Ptr<Txop> state)
551,554c461,463
<   NS_LOG_FUNCTION (this << txop);
<   Time mostRecentEvent = MostRecent ({txop->GetBackoffStart (),
<                                      GetAccessGrantStart () + (txop->GetAifsn () * m_slot)});
<   NS_LOG_DEBUG ("Backoff start: " << mostRecentEvent.As (Time::US));
---
>   NS_LOG_FUNCTION (this << state);
>   Time mostRecentEvent = MostRecent (state->GetBackoffStart (),
>                                      GetAccessGrantStart () + (state->GetAifsn () * m_slot));
560c469
< ChannelAccessManager::GetBackoffEndFor (Ptr<Txop> txop)
---
> ChannelAccessManager::GetBackoffEndFor (Ptr<Txop> state)
562,566c471,474
<   NS_LOG_FUNCTION (this << txop);
<   Time backoffEnd = GetBackoffStartFor (txop) + (txop->GetBackoffSlots () * m_slot);
<   NS_LOG_DEBUG ("Backoff end: " << backoffEnd.As (Time::US));
< 
<   return backoffEnd;
---
>   NS_LOG_FUNCTION (this << state);
>   NS_LOG_DEBUG ("Backoff start: " << GetBackoffStartFor (state).As (Time::US) <<
>                 " end: " << (GetBackoffStartFor (state) + state->GetBackoffSlots () * m_slot).As (Time::US));
>   return GetBackoffStartFor (state) + (state->GetBackoffSlots () * m_slot);
574c482
<   for (auto txop : m_txops)
---
>   for (States::iterator i = m_states.begin (); i != m_states.end (); i++, k++)
576c484,486
<       Time backoffStart = GetBackoffStartFor (txop);
---
>       Ptr<Txop> state = *i;
> 
>       Time backoffStart = GetBackoffStartFor (state);
579c489
<           uint32_t nIntSlots = ((Simulator::Now () - backoffStart) / m_slot).GetHigh ();
---
>           uint32_t nIntSlots = (Simulator::Now () - backoffStart) / m_slot;
591c501
<           if (txop->IsQosTxop ())
---
>           if (state->IsQosTxop ())
595c505
<           uint32_t n = std::min (nIntSlots, txop->GetBackoffSlots ());
---
>           uint32_t n = std::min (nIntSlots, state->GetBackoffSlots ());
598c508
<           txop->UpdateBackoffSlotsNow (n, backoffUpdateBound);
---
>           state->UpdateBackoffSlotsNow (n, backoffUpdateBound);
600d509
<       ++k;
614c523
<   for (auto txop : m_txops)
---
>   for (States::iterator i = m_states.begin (); i != m_states.end (); i++)
616c525,526
<       if (txop->IsAccessRequested ())
---
>       Ptr<Txop> state = *i;
>       if (state->IsAccessRequested ())
618c528
<           Time tmp = GetBackoffEndFor (txop);
---
>           Time tmp = GetBackoffEndFor (state);
644,649d553
< bool
< ChannelAccessManager::IsReceiving (void) const
< {
<   return (m_lastRxStart + m_lastRxDuration > Simulator::Now ());
< }
< 
658c562
<   m_lastRxReceivedOk = true;
---
>   m_rxing = true;
666c570
<   m_lastRxDuration = Simulator::Now () - m_lastRxStart;
---
>   m_lastRxEnd = Simulator::Now ();
667a572
>   m_rxing = false;
675,682c580
<   Time now = Simulator::Now ();
<   Time lastRxEnd = m_lastRxStart + m_lastRxDuration;
<   if (lastRxEnd > now)
<     {
<       m_lastBusyStart = now;
<       m_lastBusyDuration = lastRxEnd - m_lastBusyStart;
<     }
<   m_lastRxDuration = now - m_lastRxStart;
---
>   m_lastRxEnd = Simulator::Now ();
683a582
>   m_rxing = false;
690,693c589
<   m_lastRxReceivedOk = true;
<   Time now = Simulator::Now ();
<   Time lastRxEnd = m_lastRxStart + m_lastRxDuration;
<   if (lastRxEnd > now)
---
>   if (m_rxing)
696,698c592,597
<       //inside MBIFS, so, we check that lastRxStart was maximum a MBIFS ago
<       NS_ASSERT_MSG (now - m_lastRxStart <= m_sifs * 3, "lastRxStart should be maximum a MBIFS ago");
<       m_lastRxDuration = now - m_lastRxStart;
---
>       //inside SIFS, so, we check that lastRxStart was maximum a SIFS ago
>       NS_ASSERT (Simulator::Now () - m_lastRxStart <= m_sifs);
>       m_lastRxEnd = Simulator::Now ();
>       m_lastRxDuration = m_lastRxEnd - m_lastRxStart;
>       m_lastRxReceivedOk = true;
>       m_rxing = false;
702c601
<   m_lastTxStart = now;
---
>   m_lastTxStart = Simulator::Now ();
724,726c623
<   m_lastRxReceivedOk = true;
< 
<   if (m_lastRxStart + m_lastRxDuration > now)
---
>   if (m_rxing)
729c626,629
<       m_lastRxDuration = now - m_lastRxStart;
---
>       m_lastRxEnd = Simulator::Now ();
>       m_lastRxDuration = m_lastRxEnd - m_lastRxStart;
>       m_lastRxReceivedOk = true;
>       m_rxing = false;
755c655
<   for (auto txop : m_txops)
---
>   for (States::iterator i = m_states.begin (); i != m_states.end (); i++)
757c657,658
<       uint32_t remainingSlots = txop->GetBackoffSlots ();
---
>       Ptr<Txop> state = *i;
>       uint32_t remainingSlots = state->GetBackoffSlots ();
760,761c661,662
<           txop->UpdateBackoffSlotsNow (remainingSlots, now);
<           NS_ASSERT (txop->GetBackoffSlots () == 0);
---
>           state->UpdateBackoffSlotsNow (remainingSlots, now);
>           NS_ASSERT (state->GetBackoffSlots () == 0);
763,765c664,666
<       txop->ResetCw ();
<       txop->m_accessRequested = false;
<       txop->NotifyChannelSwitching ();
---
>       state->ResetCw ();
>       state->m_accessRequested = false;
>       state->NotifyChannelSwitching ();
770a672
> 
785c687
<   for (auto txop : m_txops)
---
>   for (States::iterator i = m_states.begin (); i != m_states.end (); i++)
787c689,690
<       txop->NotifySleep ();
---
>       Ptr<Txop> state = *i;
>       state->NotifySleep ();
803c706
<   for (auto txop : m_txops)
---
>   for (States::iterator i = m_states.begin (); i != m_states.end (); i++)
805c708,709
<       txop->NotifyOff ();
---
>       Ptr<Txop> state = *i;
>       state->NotifyOff ();
814c718
<   for (auto txop : m_txops)
---
>   for (States::iterator i = m_states.begin (); i != m_states.end (); i++)
816c720,721
<       uint32_t remainingSlots = txop->GetBackoffSlots ();
---
>       Ptr<Txop> state = *i;
>       uint32_t remainingSlots = state->GetBackoffSlots ();
819,820c724,725
<           txop->UpdateBackoffSlotsNow (remainingSlots, Simulator::Now ());
<           NS_ASSERT (txop->GetBackoffSlots () == 0);
---
>           state->UpdateBackoffSlotsNow (remainingSlots, Simulator::Now ());
>           NS_ASSERT (state->GetBackoffSlots () == 0);
822,824c727,729
<       txop->ResetCw ();
<       txop->m_accessRequested = false;
<       txop->NotifyWakeUp ();
---
>       state->ResetCw ();
>       state->m_accessRequested = false;
>       state->NotifyWakeUp ();
833c738
<   for (auto txop : m_txops)
---
>   for (States::iterator i = m_states.begin (); i != m_states.end (); i++)
835c740,741
<       uint32_t remainingSlots = txop->GetBackoffSlots ();
---
>       Ptr<Txop> state = *i;
>       uint32_t remainingSlots = state->GetBackoffSlots ();
838,839c744,745
<           txop->UpdateBackoffSlotsNow (remainingSlots, Simulator::Now ());
<           NS_ASSERT (txop->GetBackoffSlots () == 0);
---
>           state->UpdateBackoffSlotsNow (remainingSlots, Simulator::Now ());
>           NS_ASSERT (state->GetBackoffSlots () == 0);
841,843c747,749
<       txop->ResetCw ();
<       txop->m_accessRequested = false;
<       txop->NotifyOn ();
---
>       state->ResetCw ();
>       state->m_accessRequested = false;
>       state->NotifyOn ();
856,857c762,763
<    * If the NAV reset indicates an end-of-NAV which is earlier
<    * than the previous end-of-NAV, the expected end of backoff
---
>    * If the nav reset indicates an end-of-nav which is earlier
>    * than the previous end-of-nav, the expected end of backoff
889c795
< ChannelAccessManager::NotifyAckTimeoutResetNow (void)
---
> ChannelAccessManager::NotifyAckTimeoutResetNow ()
904c810
< ChannelAccessManager::NotifyCtsTimeoutResetNow (void)
---
> ChannelAccessManager::NotifyCtsTimeoutResetNow ()
diff ../../NS3-WiGig/src/wifi/model/channel-access-manager.h ../../ns-3-dev-git/src/wifi/model/channel-access-manager.h
25d24
< #include <algorithm>
58c57
<    * Set up listener for PHY events.
---
>    * Set up listener for Phy events.
60c59
<    * \param phy the WifiPhy to listen to
---
>    * \param phy
64c63
<    * Remove current registered listener for PHY events.
---
>    * Remove current registered listener for Phy events.
66c65
<    * \param phy the WifiPhy to listen to
---
>    * \param phy
72c71
<    * \param low the MacLow to listen to
---
>    * \param low
101c100
<   Time GetEifsNoDifs (void) const;
---
>   Time GetEifsNoDifs () const;
104c103
<    * \param txop a new Txop.
---
>    * \param dcf a new Txop.
113c112
<   void Add (Ptr<Txop> txop);
---
>   void Add (Ptr<Txop> dcf);
116,125c115
<    * Determine if a new backoff needs to be generated when a packet is queued
<    * for transmission.
<    *
<    * \param txop the Txop requesting to generate a backoff
<    * \return true if backoff needs to be generated, false otherwise
<    */
<   bool NeedBackoffUponAccess (Ptr<Txop> txop);
< 
<   /**
<    * \param txop a Txop
---
>    * \param state a Txop
133c123
<   void RequestAccess (Ptr<Txop> txop, bool isCfPeriod = false);
---
>   void RequestAccess (Ptr<Txop> state, bool isCfPeriod = false);
136,140d125
<    * Check if we are receiving any packet.
<    * \return true if we receiving packet.
<    */
<   bool IsReceiving (void) const;
<   /**
143c128
<    * Notify the Txop that a packet reception started
---
>    * Notify the DCF that a packet reception started
148c133
<    * Notify the Txop that a packet reception was just
---
>    * Notify the DCF that a packet reception was just
153c138
<    * Notify the Txop that a packet reception was just
---
>    * Notify the DCF that a packet reception was just
160c145
<    * Notify the Txop that a packet transmission was
---
>    * Notify the DCF that a packet transmission was
166c151
<    * \param duration expected duration of CCA busy period
---
>    * \param duration expected duration of cca busy period
168c153
<    * Notify the Txop that a CCA busy period has just started.
---
>    * Notify the DCF that a CCA busy period has just started.
174c159
<    * Notify the Txop that a channel switching period has just started.
---
>    * Notify the DCF that a channel switching period has just started.
180c165
<    * Notify the Txop that the device has been put in sleep mode.
---
>    * Notify the DCF that the device has been put in sleep mode.
184c169
<    * Notify the Txop that the device has been put in off mode.
---
>    * Notify the DCF that the device has been put in off mode.
188c173
<    * Notify the Txop that the device has been resumed from sleep mode.
---
>    * Notify the DCF that the device has been resumed from sleep mode.
192c177
<    * Notify the Txop that the device has been resumed from off mode.
---
>    * Notify the DCF that the device has been resumed from off mode.
198c183
<    * Called at end of RX
---
>    * Called at end of rx
204c189
<    * Called at end of RX
---
>    * Called at end of rx
208c193
<    * Notify that ack timer has started for the given duration.
---
>    * Notify that ACK timer has started for the given duration.
210c195
<    * \param duration the duration of the timer
---
>    * \param duration
214c199
<    * Notify that ack timer has reset.
---
>    * Notify that ACK timer has reset.
216c201
<   void NotifyAckTimeoutResetNow (void);
---
>   void NotifyAckTimeoutResetNow ();
220c205
<    * \param duration the duration of the timer
---
>    * \param duration
226c211
<   void NotifyCtsTimeoutResetNow (void);
---
>   void NotifyCtsTimeoutResetNow ();
237,243d221
<   //// WIGIG ////
<   /* This is used only for EDCA contention */
<   void AllowChannelAccess ();
<   void DisableChannelAccess ();
<   bool IsAccessAllowed () const;
<   bool CanAccess (void) const;
<   //// WIGIG ////
258c236,237
<    * \param list the initializer list including the times to compare
---
>    * \param a
>    * \param b
262c241,268
<   Time MostRecent (std::initializer_list<Time> list) const;
---
>   Time MostRecent (Time a, Time b) const;
>   /**
>    * Return the most recent time.
>    *
>    * \param a
>    * \param b
>    * \param c
>    * \param d
>    * \param e
>    * \param f
>    *
>    * \return the most recent time
>    */
>   Time MostRecent (Time a, Time b, Time c, Time d, Time e, Time f) const;
>   /**
>    * Return the most recent time.
>    *
>    * \param a
>    * \param b
>    * \param c
>    * \param d
>    * \param e
>    * \param f
>    * \param g
>    *
>    * \return the most recent time
>    */
>   Time MostRecent (Time a, Time b, Time c, Time d, Time e, Time f, Time g) const;
276c282
<    * \param txop the Txop
---
>    * \param state
280c286
<   Time GetBackoffStartFor (Ptr<Txop> txop);
---
>   Time GetBackoffStartFor (Ptr<Txop> state);
285c291
<    * \param txop the Txop
---
>    * \param state
289c295
<   Time GetBackoffEndFor (Ptr<Txop> txop);
---
>   Time GetBackoffEndFor (Ptr<Txop> state);
299c305
<    * Grant access to Txop using DCF/EDCF contention rules
---
>    * Grant access to DCF
301c307
<   void DoGrantDcfAccess (void);
---
>   void DoGrantAccess (void);
303c309
<    * Grant access to Txop using PCF preemption
---
>    * Check if the device is between frames (in DIFS or AIFS interval)
305c311,317
<    * \param txop the Txop
---
>    * \param state the state to check
>    * \return true if the device is within AIFS,
>    *         false otherwise
>    */
>   bool IsWithinAifs (Ptr<Txop> state) const;
>   /**
>    * Grant access to PCF
307c319
<   void DoGrantPcfAccess (Ptr<Txop> txop);
---
>   void GrantPcfAccess (Ptr<Txop> state);
312c324
<   typedef std::vector<Ptr<Txop>> Txops;
---
>   typedef std::vector<Ptr<Txop> > States;
314,315c326,327
<   Txops m_txops;                //!< the vector of managed Txops
<   Time m_lastAckTimeoutEnd;     //!< the last Ack timeout end time
---
>   States m_states;              //!< the DCF states
>   Time m_lastAckTimeoutEnd;     //!< the last ACK timeout end time
336,338c348
<   PhyListener* m_phyListener;   //!< the PHY listener
<   Ptr<WifiPhy> m_phy;           //!< pointer to the PHY
<   bool m_accessAllowed;         //!< Access allowed by Txop instances
---
>   PhyListener* m_phyListener;   //!< the phy listener
Only in ../../NS3-WiGig/src/wifi/model: codebook-analytical.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook-analytical.h
Only in ../../NS3-WiGig/src/wifi/model: codebook.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook.h
Only in ../../NS3-WiGig/src/wifi/model: codebook-numerical.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook-numerical.h
Only in ../../NS3-WiGig/src/wifi/model: codebook-parametric-2d.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook-parametric-2d.h
Only in ../../NS3-WiGig/src/wifi/model: codebook-parametric.cc
Only in ../../NS3-WiGig/src/wifi/model: codebook-parametric.h
Only in ../../NS3-WiGig/src/wifi/model: common-header.cc
Only in ../../NS3-WiGig/src/wifi/model: common-header.h
Only in ../../NS3-WiGig/src/wifi/model: constant-obss-pd-algorithm.cc
Only in ../../NS3-WiGig/src/wifi/model: constant-obss-pd-algorithm.h
diff ../../NS3-WiGig/src/wifi/model/constant-rate-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/constant-rate-wifi-manager.cc
54,65d53
< void
< ConstantRateWifiManager::SetDataMode (WifiMode mode)
< {
<   m_dataMode = mode;
< }
< 
< void
< ConstantRateWifiManager::SetControlMode (WifiMode mode)
< {
<   m_ctlMode = mode;
< }
< 
111,112c99,100
< ConstantRateWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                          double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> ConstantRateWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                          double ackSnr, WifiMode ackMode, double dataSnr)
114c102
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
133,138c121
<   uint8_t nss = Min (GetMaxNumberOfTransmitStreams (), GetNumberOfSupportedStreams (st));
<   if (m_dataMode.GetModulationClass () == WIFI_MOD_CLASS_HT)
<     {
<       nss = 1 + (m_dataMode.GetMcsValue () / 8);
<     }
<   return WifiTxVector (m_dataMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (m_dataMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), ConvertGuardIntervalToNanoSeconds (m_dataMode, GetShortGuardIntervalSupported (st), NanoSeconds (GetGuardInterval (st))), GetNumberOfAntennas (), nss, 0, GetChannelWidthForTransmission (m_dataMode, GetChannelWidth (st)), GetAggregation (st), false);
---
>   return WifiTxVector (m_dataMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (m_dataMode, GetAddress (st)), ConvertGuardIntervalToNanoSeconds (m_dataMode, GetShortGuardInterval (st), NanoSeconds (GetGuardInterval (st))), GetNumberOfAntennas (), Min (GetMaxNumberOfTransmitStreams (), GetNumberOfSupportedStreams (st)), 0, GetChannelWidthForTransmission (m_dataMode, GetChannelWidth (st)), GetAggregation (st), false);
145c128,134
<   return WifiTxVector (m_ctlMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (m_ctlMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), ConvertGuardIntervalToNanoSeconds (m_ctlMode, GetShortGuardIntervalSupported (st), NanoSeconds (GetGuardInterval (st))), 1, 1, 0, GetChannelWidthForTransmission (m_ctlMode, GetChannelWidth (st)), GetAggregation (st), false);
---
>   return WifiTxVector (m_ctlMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (m_ctlMode, GetAddress (st)), ConvertGuardIntervalToNanoSeconds (m_ctlMode, GetShortGuardInterval (st), NanoSeconds (GetGuardInterval (st))), 1, 1, 0, GetChannelWidthForTransmission (m_ctlMode, GetChannelWidth (st)), GetAggregation (st), false);
> }
> 
> bool
> ConstantRateWifiManager::IsLowLatency (void) const
> {
>   return true;
diff ../../NS3-WiGig/src/wifi/model/constant-rate-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/constant-rate-wifi-manager.h
45,46c45
<   virtual void SetDataMode (WifiMode mode);
<   virtual void SetControlMode (WifiMode mode);
---
> 
57,58c56,57
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
62a62
>   bool IsLowLatency (void) const;
64c64
<   WifiMode m_dataMode; //!< Wifi mode for unicast Data frames
---
>   WifiMode m_dataMode; //!< Wifi mode for unicast DATA frames
Only in ../../NS3-WiGig/src/wifi/model: constant-wifi-ack-policy-selector.cc
Only in ../../NS3-WiGig/src/wifi/model: constant-wifi-ack-policy-selector.h
Only in ../../NS3-WiGig/src/wifi/model: control-trailer.cc
Only in ../../NS3-WiGig/src/wifi/model: control-trailer.h
diff ../../NS3-WiGig/src/wifi/model/ctrl-headers.cc ../../ns-3-dev-git/src/wifi/model/ctrl-headers.cc
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
19,20c18
<  * Authors: Mirko Banchi <mk.banchi@gmail.com>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mirko Banchi <mk.banchi@gmail.com>
22,23c20
< #include "ns3/address-utils.h"
< #include "ns3/log.h"
---
> 
28d24
< NS_LOG_COMPONENT_DEFINE ("CtrlHeaders");
38c34,35
<     m_baType (BASIC_BLOCK_ACK)
---
>     m_multiTid (false),
>     m_compressed (false)
74c71,75
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       size += 2; //Starting sequence control
>     }
>   else if (m_compressed)
76,86c77,81
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         size += 2;
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         size += (2 + 2) * (m_tidInfo + 1);
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       size += (2 + 2) * (m_tidInfo + 1);  //Multi-tid block ack
>     }
>   else
>     {
>       NS_FATAL_ERROR ("Reserved configuration.");
96c91,99
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       i.WriteHtolsbU16 (GetStartingSequenceControl ());
>     }
>   else if (m_compressed)
>     {
>       NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>     }
>   else
98,108c101
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         i.WriteHtolsbU16 (GetStartingSequenceControl ());
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       NS_FATAL_ERROR ("Reserved configuration.");
117c110,118
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       SetStartingSequenceControl (i.ReadLsbtohU16 ());
>     }
>   else if (m_compressed)
>     {
>       NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>     }
>   else
119,129c120
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         SetStartingSequenceControl (i.ReadLsbtohU16 ());
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       NS_FATAL_ERROR ("Reserved configuration.");
138c129,137
<   switch (m_baType)
---
>   if (m_barAckPolicy)
>     {
>       res |= 0x1;
>     }
>   if (m_multiTid)
>     {
>       res |= (0x1 << 1);
>     }
>   if (m_compressed)
140,153c139
<       case BASIC_BLOCK_ACK:
<         break;
<       case COMPRESSED_BLOCK_ACK:
<         res |= (0x02 << 1);
<         break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         res |= (0x01 << 1);
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         res |= (0x03 << 1);
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       res |= (0x1 << 2);
163,178c149,150
<   if (((bar >> 1) & 0x0f) == 0x03)
<     {
<       m_baType = MULTI_TID_BLOCK_ACK;
<     }
<   else if (((bar >> 1) & 0x0f) == 0x01)
<     {
<       m_baType = EXTENDED_COMPRESSED_BLOCK_ACK;
<     }
<   else if (((bar >> 1) & 0x0f) == 0x02)
<     {
<       m_baType = COMPRESSED_BLOCK_ACK;
<     }
<   else
<     {
<       m_baType = BASIC_BLOCK_ACK;
<     }
---
>   m_multiTid = (((bar >> 1) & 0x01) == 1) ? true : false;
>   m_compressed = (((bar >> 2) & 0x01) == 1) ? true : false;
203,209c175,192
<   m_baType = type;
< }
< 
< BlockAckType
< CtrlBAckRequestHeader::GetType (void) const
< {
<   return m_baType;
---
>   switch (type)
>     {
>     case BASIC_BLOCK_ACK:
>       m_multiTid = false;
>       m_compressed = false;
>       break;
>     case COMPRESSED_BLOCK_ACK:
>       m_multiTid = false;
>       m_compressed = true;
>       break;
>     case MULTI_TID_BLOCK_ACK:
>       m_multiTid = true;
>       m_compressed = true;
>       break;
>     default:
>       NS_FATAL_ERROR ("Invalid variant type");
>       break;
>     }
246c229
<   return (m_baType == BASIC_BLOCK_ACK) ? true : false;
---
>   return (!m_multiTid && !m_compressed) ? true : false;
252,258c235
<   return (m_baType == COMPRESSED_BLOCK_ACK) ? true : false;
< }
< 
< bool
< CtrlBAckRequestHeader::IsExtendedCompressed (void) const
< {
<   return (m_baType == EXTENDED_COMPRESSED_BLOCK_ACK) ? true : false;
---
>   return (!m_multiTid && m_compressed) ? true : false;
264c241
<   return (m_baType == MULTI_TID_BLOCK_ACK) ? true : false;
---
>   return (m_multiTid && m_compressed) ? true : false;
276,279c253,254
<     m_baType (BASIC_BLOCK_ACK),
<     //// WIGIG ////
<     m_edmgCompressedBlockAckSize (EDMG_COMPRESSED_BLOCK_ACK_BITMAP_1024)
<     //// WIGIG ////
---
>     m_multiTid (false),
>     m_compressed (false)
316c291,302
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       if (!m_compressed)
>         {
>           size += (2 + 128); //Basic block ack
>         }
>       else
>         {
>           size += (2 + 8); //Compressed block ack
>         }
>     }
>   else
318,337c304,311
<       case BASIC_BLOCK_ACK:
<         size += (2 + 128);
<         break;
<       case COMPRESSED_BLOCK_ACK:
<         size += (2 + 8);
<         break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         size += (2 + 32);
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         size += (2 + 2 + 8) * (m_tidInfo + 1); //Multi-TID block ack
<         break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         size += (2 + 128 + 1); // Consider that the compressed BlockAckBitmap is 1024 bits
<         break;
<       //// WIGIG ////
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       if (m_compressed)
>         {
>           size += (2 + 2 + 8) * (m_tidInfo + 1); //Multi-tid block ack
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
347c321,326
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       i.WriteHtolsbU16 (GetStartingSequenceControl ());
>       i = SerializeBitmap (i);
>     }
>   else if (m_compressed)
349,367c328,332
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         i.WriteHtolsbU16 (GetStartingSequenceControl ());
<         i = SerializeBitmap (i);
<         break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         i.WriteHtolsbU16 (GetStartingSequenceControl ());
<         i = SerializeBitmap (i);
<         i.WriteU8 (m_rbufcapValue);
<         break;
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>     }
>   else
>     {
>       NS_FATAL_ERROR ("Reserved configuration.");
376c341,350
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       SetStartingSequenceControl (i.ReadLsbtohU16 ());
>       i = DeserializeBitmap (i);
>     }
>   else if (m_compressed)
>     {
>       NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>     }
>   else
378,396c352
<       case BASIC_BLOCK_ACK:
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         SetStartingSequenceControl (i.ReadLsbtohU16 ());
<         i = DeserializeBitmap (i);
<         break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         SetStartingSequenceControl (i.ReadLsbtohU16 ());
<         i = DeserializeBitmap (i);
<         m_rbufcapValue = i.ReadU8 ();
<         break;
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       NS_FATAL_ERROR ("Reserved configuration.");
410,416c366,383
<   m_baType = type;
< }
< 
< BlockAckType
< CtrlBAckResponseHeader::GetType (void) const
< {
<   return m_baType;
---
>   switch (type)
>     {
>     case BASIC_BLOCK_ACK:
>       m_multiTid = false;
>       m_compressed = false;
>       break;
>     case COMPRESSED_BLOCK_ACK:
>       m_multiTid = false;
>       m_compressed = true;
>       break;
>     case MULTI_TID_BLOCK_ACK:
>       m_multiTid = true;
>       m_compressed = true;
>       break;
>     default:
>       NS_FATAL_ERROR ("Invalid variant type");
>       break;
>     }
453c420
<   return (m_baType == BASIC_BLOCK_ACK) ? true : false;
---
>   return (!m_multiTid && !m_compressed) ? true : false;
459,465c426
<   return (m_baType == COMPRESSED_BLOCK_ACK) ? true : false;
< }
< 
< bool
< CtrlBAckResponseHeader::IsExtendedCompressed (void) const
< {
<   return (m_baType == EXTENDED_COMPRESSED_BLOCK_ACK) ? true : false;
---
>   return (!m_multiTid && m_compressed) ? true : false;
471,477c432
<   return (m_baType == MULTI_TID_BLOCK_ACK) ? true : false;
< }
< //// WIGIG ////
< bool
< CtrlBAckResponseHeader::IsEdmgCompressed (void) const
< {
<   return (m_baType == EDMG_COMPRESSED_BLOCK_ACK) ? true : false;
---
>   return (m_multiTid && m_compressed) ? true : false;
479d433
< //// WIGIG ////
489c443,447
<   switch (m_baType)
---
>   if (m_multiTid)
>     {
>       res |= (0x1 << 1);
>     }
>   if (m_compressed)
491,509c449
<       case BASIC_BLOCK_ACK:
<         break;
<       case COMPRESSED_BLOCK_ACK:
<         res |= (0x02 << 1);
<         break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         res |= (0x01 << 1);
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         res |= (0x03 << 1);
<         break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         res |= (0x08 << 1);
<         break;
<       //// WIGIG ////
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       res |= (0x1 << 2);
519,540c459,460
<   if (((ba >> 1) & 0x0f) == 0x03)
<     {
<       m_baType = MULTI_TID_BLOCK_ACK;
<     }
<   else if (((ba >> 1) & 0x0f) == 0x01)
<     {
<       m_baType = EXTENDED_COMPRESSED_BLOCK_ACK;
<     }
<   else if (((ba >> 1) & 0x0f) == 0x02)
<     {
<       m_baType = COMPRESSED_BLOCK_ACK;
<     }
<   //// WIGIG ////
<   else if (((ba >> 1) & 0x0f) == 0x08)
<     {
<       m_baType = EDMG_COMPRESSED_BLOCK_ACK;
<     }
<   //// WIGIG ////
<   else
<     {
<       m_baType = BASIC_BLOCK_ACK;
<     }
---
>   m_multiTid = (((ba >> 1) & 0x01) == 1) ? true : false;
>   m_compressed = (((ba >> 2) & 0x01) == 1) ? true : false;
555,573d474
< //// WIGIG ////
< void
< CtrlBAckResponseHeader::SetCompresssedBlockAckSize (EDMG_COMPRESSED_BLOCK_ACK_BITMAP_SIZE size)
< {
<   m_edmgCompressedBlockAckSize = size;
< }
< 
< void
< CtrlBAckResponseHeader::SetReceiveBufferCapability (uint8_t capability)
< {
<   m_rbufcapValue = capability;
< }
< 
< uint8_t
< CtrlBAckResponseHeader::GetReceiveBufferCapability (void) const
< {
<   return m_rbufcapValue;
< }
< //// WIGIG ////
579c480
<   switch (m_baType)
---
>   if (!m_multiTid)
581c482,483
<       case BASIC_BLOCK_ACK:
---
>       if (!m_compressed)
>         {
586,587c488,490
<           break;
<       case COMPRESSED_BLOCK_ACK:
---
>         }
>       else
>         {
589,609c492,503
<           break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<           i.WriteHtolsbU64 (bitmap.m_extendedCompressedBitmap[0]);
<           i.WriteHtolsbU64 (bitmap.m_extendedCompressedBitmap[1]);
<           i.WriteHtolsbU64 (bitmap.m_extendedCompressedBitmap[2]);
<           i.WriteHtolsbU64 (bitmap.m_extendedCompressedBitmap[3]);
<           break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<           for (uint8_t j = 0; j < m_edmgCompressedBlockAckSize; j++)
<             {
<               i.WriteHtolsbU64 (bitmap.m_edmgCompressedBitmap[j]);
<             }
<           break;
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>         }
>     }
>   else
>     {
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
618c512
<   switch (m_baType)
---
>   if (!m_multiTid)
620c514,515
<       case BASIC_BLOCK_ACK:
---
>       if (!m_compressed)
>         {
625,626c520,522
<           break;
<       case COMPRESSED_BLOCK_ACK:
---
>         }
>       else
>         {
628,648c524,535
<           break;
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<           bitmap.m_extendedCompressedBitmap[0] = i.ReadLsbtohU64 ();
<           bitmap.m_extendedCompressedBitmap[1] = i.ReadLsbtohU64 ();
<           bitmap.m_extendedCompressedBitmap[2] = i.ReadLsbtohU64 ();
<           bitmap.m_extendedCompressedBitmap[3] = i.ReadLsbtohU64 ();
<           break;
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<           for (uint8_t j = 0; j < m_edmgCompressedBlockAckSize; j++)
<             {
<               bitmap.m_edmgCompressedBitmap[j] = i.ReadLsbtohU64 ();
<             }
<           break;
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>         }
>     }
>   else
>     {
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
660c547
<   switch (m_baType)
---
>   if (!m_multiTid)
662c549
<       case BASIC_BLOCK_ACK:
---
>       if (!m_compressed)
667d553
<           break;
669c555
<       case COMPRESSED_BLOCK_ACK:
---
>       else
672,678d557
<           break;
<         }
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         {
<           uint16_t index = IndexInBitmap (seq);
<           bitmap.m_extendedCompressedBitmap[index/64] |= (uint64_t (0x0000000000000001) << index);
<           break;
680,688c559,562
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         {
<           uint16_t index = IndexInBitmap (seq);
<           bitmap.m_edmgCompressedBitmap[index/64] |= (uint64_t (0x0000000000000001) << index);
<           break;
<         }
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
---
>     }
>   else
>     {
>       if (m_compressed)
691d564
<           break;
693c566
<       default:
---
>       else
695,696c568
<           NS_FATAL_ERROR ("Invalid BA type");
<           break;
---
>           NS_FATAL_ERROR ("Reserved configuration.");
709c581,593
<   switch (m_baType)
---
>   if (!m_multiTid)
>     {
>       if (!m_compressed)
>         {
>           bitmap.m_bitmap[IndexInBitmap (seq)] |= (0x0001 << frag);
>         }
>       else
>         {
>           /* We can ignore this...compressed block ack doesn't support
>              acknowledgement of single fragments */
>         }
>     }
>   else
711,727c595,602
<       case BASIC_BLOCK_ACK:
<         bitmap.m_bitmap[IndexInBitmap (seq)] |= (0x0001 << frag);
<         break;
<       case COMPRESSED_BLOCK_ACK:
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<       //// WIGIG //// /* WIGIG: To check */
<       case EDMG_COMPRESSED_BLOCK_ACK:
<       //// WIGIG ////
<         /* We can ignore this...compressed block ack doesn't support
<            acknowledgment of single fragments */
<         break;
<       case MULTI_TID_BLOCK_ACK:
<         NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
<         break;
<       default:
<         NS_FATAL_ERROR ("Invalid BA type");
<         break;
---
>       if (m_compressed)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
>       else
>         {
>           NS_FATAL_ERROR ("Reserved configuration.");
>         }
738c613
<   switch (m_baType)
---
>   if (!m_multiTid)
740c615
<       case BASIC_BLOCK_ACK:
---
>       if (!m_compressed)
745c620
<       case COMPRESSED_BLOCK_ACK:
---
>       else
747,749d621
<           /* Although this could make no sense, if packet with sequence number
<              equal to <i>seq</i> was correctly received, also all of its fragments
<              were correctly received. */
753,767c625,628
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         {
<           uint64_t mask = uint64_t (0x0000000000000001);
<           uint16_t index = IndexInBitmap (seq);
<           return (((bitmap.m_extendedCompressedBitmap[index/64] >> index) & mask) == 1) ? true : false;
<         }
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<         {
<           uint64_t mask = uint64_t (0x0000000000000001);
<           uint16_t index = IndexInBitmap (seq);
<           return (((bitmap.m_edmgCompressedBitmap[index/64] >> index) & mask) == 1) ? true : false;
<         }
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
---
>     }
>   else
>     {
>       if (m_compressed)
770d630
<           break;
772c632
<       default:
---
>       else
774,775c634
<           NS_FATAL_ERROR ("Invalid BA type");
<           break;
---
>           NS_FATAL_ERROR ("Reserved configuration.");
789c648
<   switch (m_baType)
---
>   if (!m_multiTid)
791c650
<       case BASIC_BLOCK_ACK:
---
>       if (!m_compressed)
795c654
<       case COMPRESSED_BLOCK_ACK:
---
>       else
803,812c662,665
<       case EXTENDED_COMPRESSED_BLOCK_ACK:
<         {
<           uint64_t mask = uint64_t (0x0000000000000001);
<           uint16_t index = IndexInBitmap (seq);
<           return (((bitmap.m_extendedCompressedBitmap[index/64] >> index) & mask) == 1) ? true : false;
<         }
<       //// WIGIG ////
<       case EDMG_COMPRESSED_BLOCK_ACK:
<       //// WIGIG ////
<       case MULTI_TID_BLOCK_ACK:
---
>     }
>   else
>     {
>       if (m_compressed)
815d667
<           break;
817c669
<       default:
---
>       else
819,820c671
<           NS_FATAL_ERROR ("Invalid BA type");
<           break;
---
>           NS_FATAL_ERROR ("Reserved configuration.");
838,851c689
<   //// WIGIG ////
<   if (m_baType == EDMG_COMPRESSED_BLOCK_ACK)
<     {
<       NS_ASSERT (index <= 1023);
<     }
<   //// WIGIG ////
<   else if (m_baType == EXTENDED_COMPRESSED_BLOCK_ACK)
<     {
<       NS_ASSERT (index <= 255);
<     }
<   else
<     {
<       NS_ASSERT (index <= 63);
<     }
---
>   NS_ASSERT (index <= 63);
858,871c696
<   //// WIGIG ////
<   if (m_baType == EDMG_COMPRESSED_BLOCK_ACK)
<     {
<       return (seq - m_startingSeq + 4096) % 4096 < 1024;
<     }
<   //// WIGIG ////
<   else if (m_baType == EXTENDED_COMPRESSED_BLOCK_ACK)
<     {
<       return (seq - m_startingSeq + 4096) % 4096 < 256;
<     }
<   else
<     {
<       return (seq - m_startingSeq + 4096) % 4096 < 64;
<     }
---
>   return (seq - m_startingSeq + 4096) % 4096 < 64;
886,897d710
< const uint64_t*
< CtrlBAckResponseHeader::GetExtendedCompressedBitmap (void) const
< {
<   return bitmap.m_extendedCompressedBitmap;
< }
< 
< const uint64_t*
< CtrlBAckResponseHeader::GetEdmgCompressedBitmap (void) const
< {
<   return bitmap.m_edmgCompressedBitmap;
< }
< 
904,2118c717
< /*************************
<  *  Poll Frame (8.3.1.11)
<  *************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDmgPoll);
< 
< CtrlDmgPoll::CtrlDmgPoll ()
<     : m_responseOffset (0)
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDmgPoll::~CtrlDmgPoll ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDmgPoll::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDmgPoll")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDmgPoll> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDmgPoll::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlDmgPoll::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   os << "Response Offset=" << m_responseOffset;
< }
< 
< uint32_t
< CtrlDmgPoll::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 2;  // Response Offset Field.
< }
< 
< void
< CtrlDmgPoll::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   i.WriteHtolsbU16 (m_responseOffset);
< }
< 
< uint32_t
< CtrlDmgPoll::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   m_responseOffset = i.ReadLsbtohU16 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< CtrlDmgPoll::SetResponseOffset (uint16_t value)
< {
<   NS_LOG_FUNCTION (this << value);
<   m_responseOffset = value;
< }
< 
< uint16_t
< CtrlDmgPoll::GetResponseOffset (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return m_responseOffset;
< }
< 
< /*************************************************
<  *  Service Period Request (SPR) Frame (8.3.1.12)
<  *************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_SPR);
< 
< CtrlDMG_SPR::CtrlDMG_SPR ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_SPR::~CtrlDMG_SPR ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_SPR::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_SPR")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDMG_SPR> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_SPR::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlDMG_SPR::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   m_dynamic.Print (os);
<   m_bfControl.Print (os);
< }
< 
< uint32_t
< CtrlDMG_SPR::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 7;  // Dynamic Allocation Info Field + BF Control.
< }
< 
< void
< CtrlDMG_SPR::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_dynamic.Serialize (i);
<   i = m_bfControl.Serialize (i);
< }
< 
< uint32_t
< CtrlDMG_SPR::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_dynamic.Deserialize (i);
<   i = m_bfControl.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< CtrlDMG_SPR::SetDynamicAllocationInfo (DynamicAllocationInfoField field)
< {
<   m_dynamic = field;
< }
< 
< void
< CtrlDMG_SPR::SetBFControl (BF_Control_Field value)
< {
<   m_bfControl = value;
< }
< 
< DynamicAllocationInfoField
< CtrlDMG_SPR::CtrlDMG_SPR::GetDynamicAllocationInfo (void) const
< {
<   return m_dynamic;
< }
< 
< BF_Control_Field
< CtrlDMG_SPR::GetBFControl (void) const
< {
<   return m_bfControl;
< }
< 
< /*************************
<  * Grant Frame (8.3.1.13)
<  *************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_Grant);
< 
< CtrlDMG_Grant::CtrlDMG_Grant ()
< {
<   NS_LOG_FUNCTION(this);
< }
< 
< CtrlDMG_Grant::~CtrlDMG_Grant ()
< {
<   NS_LOG_FUNCTION(this);
< }
< 
< TypeId
< CtrlDMG_Grant::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_Grant")
<       .SetParent<Header>()
<       .AddConstructor<CtrlDMG_Grant> ()
<       ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_Grant::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< /********************************************
<  * DMG Denial to Send (DTS) Frame (8.3.1.15)
<  ********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_DTS);
< 
< CtrlDMG_DTS::CtrlDMG_DTS ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_DTS::~CtrlDMG_DTS ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_DTS::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_DTS")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDMG_DTS> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_DTS::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlDMG_DTS::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< CtrlDMG_DTS::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 12;  // NAV-SA + NAV-DA
< }
< 
< void
< CtrlDMG_DTS::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   WriteTo (i, m_navSA);
<   WriteTo (i, m_navDA);
< }
< 
< uint32_t
< CtrlDMG_DTS::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   ReadFrom (i, m_navSA);
<   ReadFrom (i, m_navDA);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< /****************************************
<  *  Sector Sweep (SSW) Frame (8.3.1.16)
<  ****************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_SSW);
< 
< CtrlDMG_SSW::CtrlDMG_SSW ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_SSW::~CtrlDMG_SSW ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_SSW::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_SSW")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDMG_SSW> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_SSW::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void CtrlDMG_SSW::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   m_ssw.Print (os);
<   m_sswFeedback.Print (os);
< }
< 
< uint32_t
< CtrlDMG_SSW::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 6;  // SSW Field + SSW Feedback Field.
< }
< 
< void
< CtrlDMG_SSW::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_ssw.Serialize (i);
<   i = m_sswFeedback.Serialize (i);
< }
< 
< uint32_t
< CtrlDMG_SSW::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_ssw.Deserialize (i);
<   i = m_sswFeedback.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< CtrlDMG_SSW::SetSswField (DMG_SSW_Field &field)
< {
<   m_ssw = field;
< }
< 
< void
< CtrlDMG_SSW::SetSswFeedbackField (DMG_SSW_FBCK_Field &field)
< {
<   m_sswFeedback = field;
< }
< 
< DMG_SSW_Field
< CtrlDMG_SSW::GetSswField (void) const
< {
<   return m_ssw;
< }
< 
< DMG_SSW_FBCK_Field
< CtrlDMG_SSW::GetSswFeedbackField (void) const
< {
<   return m_sswFeedback;
< }
< 
< /*********************************************************
<  *  Sector Sweep Feedback (SSW-Feedback) Frame (8.3.1.17)
<  *********************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_SSW_FBCK);
< 
< CtrlDMG_SSW_FBCK::CtrlDMG_SSW_FBCK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_SSW_FBCK::~CtrlDMG_SSW_FBCK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_SSW_FBCK::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_SSW_FBCK")
<     .SetParent<Header>()
<     .AddConstructor<CtrlDMG_SSW_FBCK> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_SSW_FBCK::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlDMG_SSW_FBCK::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   m_sswFeedback.Print (os);
<   m_brpRequest.Print (os);
<   m_linkMaintenance.Print (os);
< }
< 
< uint32_t
< CtrlDMG_SSW_FBCK::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 8;  // SSW Feedback Field + BRP Request + Beamformed Link Maintenance.
< }
< 
< void
< CtrlDMG_SSW_FBCK::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_sswFeedback.Serialize (i);
<   i = m_brpRequest.Serialize (i);
<   i = m_linkMaintenance.Serialize (i);
< }
< 
< uint32_t
< CtrlDMG_SSW_FBCK::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION(this << &start);
<   Buffer::Iterator i = start;
< 
<   i = m_sswFeedback.Deserialize (i);
<   i = m_brpRequest.Deserialize (i);
<   i = m_linkMaintenance.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< CtrlDMG_SSW_FBCK::SetSswFeedbackField (DMG_SSW_FBCK_Field &field)
< {
<   m_sswFeedback = field;
< }
< 
< void
< CtrlDMG_SSW_FBCK::SetBrpRequestField (BRP_Request_Field &field)
< {
<   m_brpRequest = field;
< }
< 
< void
< CtrlDMG_SSW_FBCK::SetBfLinkMaintenanceField (BF_Link_Maintenance_Field &field)
< {
<   m_linkMaintenance = field;
< }
< 
< DMG_SSW_FBCK_Field
< CtrlDMG_SSW_FBCK::GetSswFeedbackField (void) const
< {
<   return m_sswFeedback;
< }
< 
< BRP_Request_Field
< CtrlDMG_SSW_FBCK::GetBrpRequestField (void) const
< {
<   return m_brpRequest;
< }
< 
< BF_Link_Maintenance_Field
< CtrlDMG_SSW_FBCK::GetBfLinkMaintenanceField (void) const
< {
<   return m_linkMaintenance;
< }
< 
< /**********************************************
<  * Sector Sweep ACK (SSW-ACK) Frame (8.3.1.18)
<  **********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlDMG_SSW_ACK);
< 
< CtrlDMG_SSW_ACK::CtrlDMG_SSW_ACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< CtrlDMG_SSW_ACK::~CtrlDMG_SSW_ACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlDMG_SSW_ACK::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlDMG_SSW_ACK")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlDMG_SSW_ACK> ()
<   ;
<   return tid;
< }
< 
< TypeId
< CtrlDMG_SSW_ACK::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< /*******************************
<  *  Grant ACK Frame (8.3.1.19)
<  *******************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (CtrlGrantAck);
< 
< CtrlGrantAck::CtrlGrantAck ()
< {
<   NS_LOG_FUNCTION (this);
<   memset (m_reserved, 0, sizeof (uint8_t) * 5);
< }
< 
< CtrlGrantAck::~CtrlGrantAck ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< CtrlGrantAck::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::CtrlGrantAck")
<     .SetParent<Header> ()
<     .AddConstructor<CtrlGrantAck> ()
<     ;
<   return tid;
< }
< 
< TypeId
< CtrlGrantAck::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void
< CtrlGrantAck::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
<   m_bfControl.Print (os);
< }
< 
< uint32_t
< CtrlGrantAck::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 7;  // Reserved + BF Control.
< }
< 
< void
< CtrlGrantAck::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i.Write (m_reserved, 5);
<   i = m_bfControl.Serialize (i);
< }
< 
< uint32_t
< CtrlGrantAck::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   i.Read (m_reserved, 5);
<   i = m_bfControl.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< /***********************************************
<  *   TDD Beamforming frame format (9.3.1.24.1)
<  ***********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (TDD_Beamforming);
< 
< TDD_Beamforming::TDD_Beamforming ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TDD_Beamforming::~TDD_Beamforming ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< TDD_Beamforming::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::TDD_Beamforming")
<     .SetParent<Header> ()
<     .AddConstructor<TDD_Beamforming> ()
<     ;
<   return tid;
< }
< 
< TypeId
< TDD_Beamforming::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void TDD_Beamforming::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< TDD_Beamforming::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 1;
< }
< 
< void
< TDD_Beamforming::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   uint8_t controlField = 0;
<   controlField |= m_groupBeamforming & 0x1;
<   controlField |= (m_beamMeasurement & 0x1) << 1;
<   controlField |= (m_beamformingFrameType & 0x3) << 2;
<   controlField |= (m_endOfTraining & 0x1) << 4;
<   i.WriteU8 (controlField);
< }
< 
< uint32_t
< TDD_Beamforming::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   uint8_t controlField = i.ReadU8 ();
<   m_groupBeamforming = controlField & 0x1;
<   m_beamMeasurement = (controlField >> 1) & 0x1;
<   m_beamformingFrameType = static_cast<TDD_Beamforming_Frame_Type> ((controlField << 2) & 0x3);
<   m_endOfTraining = (controlField >> 4) & 0x1;
<   return i.GetDistanceFrom (start);
< }
< 
< void
< TDD_Beamforming::SetGroup_Beamforming (bool value)
< {
<   m_groupBeamforming = value;
< }
< 
< void
< TDD_Beamforming::SetBeam_Measurement (bool value)
< {
<   m_beamMeasurement = value;
< }
< 
< void
< TDD_Beamforming::SetBeamformingFrameType (TDD_Beamforming_Frame_Type type)
< {
<   m_beamformingFrameType = type;
< }
< 
< void
< TDD_Beamforming::SetEndOfTraining (bool value)
< {
<   m_endOfTraining = value;
< }
< 
< bool
< TDD_Beamforming::GetGroup_Beamforming (void) const
< {
<   return m_groupBeamforming;
< }
< 
< bool
< TDD_Beamforming::GetBeam_Measurement (void) const
< {
<   return m_beamMeasurement;
< }
< 
< TDD_Beamforming_Frame_Type
< TDD_Beamforming::GetBeamformingFrameType (void) const
< {
<   return m_beamformingFrameType;
< }
< 
< bool
< TDD_Beamforming::GetEndOfTraining (void) const
< {
<   return m_endOfTraining;
< }
< 
< TDD_BEAMFORMING_PROCEDURE
< TDD_Beamforming::GetBeamformingProcedure (Mac48Address receiver) const
< {
<   return TDD_BEAMFORMING_INDIVIDUAL;
< }
< 
< /*********************************************
<  * TDD Sector Sweep (SSW) format (9.3.1.24.2)
<  *********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (TDD_Beamforming_SSW);
< 
< TDD_Beamforming_SSW::TDD_Beamforming_SSW ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TDD_Beamforming_SSW::~TDD_Beamforming_SSW ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< TDD_Beamforming_SSW::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::TDD_Beamforming_SSW")
<     .SetParent<TDD_Beamforming> ()
<     .AddConstructor<TDD_Beamforming_SSW> ()
<     ;
<   return tid;
< }
< 
< TypeId
< TDD_Beamforming_SSW::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void TDD_Beamforming_SSW::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< TDD_Beamforming_SSW::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 6;
< }
< 
< void
< TDD_Beamforming_SSW::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
< //  Buffer::Iterator i = start;
< }
< 
< uint32_t
< TDD_Beamforming_SSW::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   return i.GetDistanceFrom (start);
< }
< 
< void
< TDD_Beamforming_SSW::SetTxSectorID (uint16_t sectorID)
< {
<   m_sectorID = sectorID;
< }
< 
< void
< TDD_Beamforming_SSW::SetTxAntennaID (uint8_t antennaID)
< {
<   m_antennaID = antennaID;
< }
< 
< void
< TDD_Beamforming_SSW::SetCountIndex (uint8_t index)
< {
<   m_countIndex = index;
< }
< 
< void
< TDD_Beamforming_SSW::SetBeamformingTimeUnit (uint8_t unit)
< {
<   m_beamformingTimeUnit = unit;
< }
< 
< void
< TDD_Beamforming_SSW::SetTransmitPeriod (uint8_t period)
< {
<   m_transmitPeriod = period;
< }
< 
< void
< TDD_Beamforming_SSW::SetResponderFeedbackOffset (uint16_t offset)
< {
<   m_responderFeedbackOffset = offset;
< }
< 
< void
< TDD_Beamforming_SSW::SetInitiatorAckOffset (uint16_t offset)
< {
<   m_initiatorAckOffset = offset;
< }
< 
< void
< TDD_Beamforming_SSW::SetNumberOfRequestedFeedback (uint8_t feedback)
< {
<   m_numRequestedFeedback = feedback;
< }
< 
< 
< void
< TDD_Beamforming_SSW::SetTDDSlotCDOWN (uint16_t cdown)
< {
<   m_tddSlotCDOWN = cdown;
< }
< 
< void
< TDD_Beamforming_SSW::SetFeedbackRequested (bool feedback)
< {
<   m_feedbackRequested = feedback;
< }
< 
< uint16_t
< TDD_Beamforming_SSW::GetTxSectorID (void) const
< {
<   return m_sectorID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetTxAntennaID (void) const
< {
<   return m_antennaID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetCountIndex (void) const
< {
<   return m_countIndex;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetBeamformingTimeUnit (void) const
< {
<   return m_beamformingTimeUnit;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetTransmitPeriod (void) const
< {
<   return m_transmitPeriod;
< }
< 
< uint16_t
< TDD_Beamforming_SSW::GetResponderFeedbackOffset (void) const
< {
<   return m_responderFeedbackOffset;
< }
< 
< uint16_t
< TDD_Beamforming_SSW::GetInitiatorAckOffset (void) const
< {
<   return m_initiatorAckOffset;
< }
< 
< uint8_t
< TDD_Beamforming_SSW::GetNumberOfRequestedFeedback (void) const
< {
<   return m_numRequestedFeedback;
< }
< 
< uint16_t
< TDD_Beamforming_SSW::GetTDDSlotCDOWN (void) const
< {
<   return m_tddSlotCDOWN;
< }
< 
< bool
< TDD_Beamforming_SSW::GetFeedbackRequested (void) const
< {
<   return m_feedbackRequested;
< }
< 
< /*********************************************
<  *     TDD SSW Feedback format (9.3.1.24.3)
<  *********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (TDD_Beamforming_SSW_FEEDBACK);
< 
< TDD_Beamforming_SSW_FEEDBACK::TDD_Beamforming_SSW_FEEDBACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TDD_Beamforming_SSW_FEEDBACK::~TDD_Beamforming_SSW_FEEDBACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< TDD_Beamforming_SSW_FEEDBACK::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::TDD_Beamforming_SSW_FEEDBACK")
<     .SetParent<TDD_Beamforming> ()
<     .AddConstructor<TDD_Beamforming_SSW_FEEDBACK> ()
<     ;
<   return tid;
< }
< 
< TypeId
< TDD_Beamforming_SSW_FEEDBACK::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void TDD_Beamforming_SSW_FEEDBACK::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< TDD_Beamforming_SSW_FEEDBACK::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return TDD_Beamforming::GetSerializedSize () + 6;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
<   TDD_Beamforming::Serialize (i);
<   uint32_t value1 = 0;
<   uint16_t value2 = 0;
<   value1 |= (m_sectorID & 0x1FF);
<   value1 |= (m_antennaID & 0x7) << 9;
<   value1 |= (m_decodedSectorID & 0x1FF) << 12;
<   value1 |= (m_decodedAntennaID & 0x7) << 21;
<   value1 |= (m_snrReport & 0xFF) << 24;
<   value2 |= (m_feedbackCountIndex & 0x33);
<   i.WriteHtolsbU32 (value1);
<   i.WriteHtolsbU16 (value2);
< }
< 
< uint32_t
< TDD_Beamforming_SSW_FEEDBACK::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< //  i += TDD_Beamforming::Deserialize (i);
<   uint32_t value1 = i.ReadLsbtohU32 ();
<   uint16_t value2 = i.ReadLsbtohU16 ();
<   m_sectorID = (value1 & 0x1FF);
<   m_antennaID = (value1 >> 9) & 0x7;
<   m_decodedSectorID = (value1 >> 12) & 0x1FF;
<   m_decodedAntennaID = (value1 >> 21) & 0x7;
<   m_snrReport = (value1 >> 24) & 0xFF;
<   m_feedbackCountIndex = (value2 & 0x33);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetTxSectorID (uint16_t sectorID)
< {
<   m_sectorID = sectorID;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetTxAntennaID (uint8_t antennaID)
< {
<   m_antennaID = antennaID;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetDecodedTxSectorID (uint16_t sectorID)
< {
<   m_decodedSectorID = sectorID;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetDecodedTxAntennaID (uint8_t antennaID)
< {
<   m_decodedAntennaID = antennaID;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetSnrReport (uint8_t snr)
< {
<   m_snrReport = snr;
< }
< 
< void
< TDD_Beamforming_SSW_FEEDBACK::SetFeedbackCountIndex (uint8_t index)
< {
<   m_feedbackCountIndex = index;
< }
< 
< uint16_t
< TDD_Beamforming_SSW_FEEDBACK::GetTxSectorID (void) const
< {
<   return m_sectorID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_FEEDBACK::GetTxAntennaID (void) const
< {
<   return m_antennaID;
< }
< 
< uint16_t
< TDD_Beamforming_SSW_FEEDBACK::GetDecodedTxSectorID (void) const
< {
<   return m_decodedSectorID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_FEEDBACK::GetDecodedTxAntennaID (void) const
< {
<   return m_decodedAntennaID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_FEEDBACK::GetSnrReport (void) const
< {
<   return m_snrReport;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_FEEDBACK::GetFeedbackCountIndex (void) const
< {
<   return m_feedbackCountIndex;
< }
< 
< /*********************************************
<  *      TDD SSW ACK format (9.3.1.24.3)
<  *********************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (TDD_Beamforming_SSW_ACK);
< 
< TDD_Beamforming_SSW_ACK::TDD_Beamforming_SSW_ACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TDD_Beamforming_SSW_ACK::~TDD_Beamforming_SSW_ACK ()
< {
<   NS_LOG_FUNCTION (this);
< }
< 
< TypeId
< TDD_Beamforming_SSW_ACK::GetTypeId (void)
< {
<   NS_LOG_FUNCTION_NOARGS ();
<   static TypeId tid = TypeId ("ns3::TDD_Beamforming_SSW_ACK")
<     .SetParent<TDD_Beamforming> ()
<     .AddConstructor<TDD_Beamforming_SSW_ACK> ()
<   ;
<   return tid;
< }
< 
< TypeId
< TDD_Beamforming_SSW_ACK::GetInstanceTypeId (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return GetTypeId ();
< }
< 
< void TDD_Beamforming_SSW_ACK::Print (std::ostream &os) const
< {
<   NS_LOG_FUNCTION (this << &os);
< }
< 
< uint32_t
< TDD_Beamforming_SSW_ACK::GetSerializedSize () const
< {
<   NS_LOG_FUNCTION (this);
<   return 6;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::Serialize (Buffer::Iterator start) const
< {
<   NS_LOG_FUNCTION (this << &start);
< //  Buffer::Iterator i = start;
<   if (m_beamformingFrameType == TDD_SSW)
<     {
< 
<     }
<   else if (m_beamformingFrameType == TDD_SSW_Feedback)
<     {
< 
<     }
< }
< 
< uint32_t
< TDD_Beamforming_SSW_ACK::Deserialize (Buffer::Iterator start)
< {
<   NS_LOG_FUNCTION (this << &start);
<   Buffer::Iterator i = start;
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetDecodedTxSectorID (uint16_t sectorID)
< {
<   m_sectorID = sectorID;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetDecodedTxAntennaID (uint8_t antennaID)
< {
<   m_antennaID = antennaID;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetCountIndex (uint8_t index)
< {
<   m_countIndex = index;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetTransmitPeriod (uint8_t period)
< {
<   m_transmitPeriod = period;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetSnrReport (uint8_t snr)
< {
<   m_snrReport = snr;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetInitiatorTransmitOffset (uint16_t offset)
< {
<   m_InitiatorTransmitOffset = offset;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetResponderTransmitOffset (uint8_t offset)
< {
<   m_responderTransmitOffset = offset;
< }
< 
< void
< TDD_Beamforming_SSW_ACK::SetAckCountIndex (uint8_t count)
< {
<   m_ackCountIndex = count;
< }
< 
< uint16_t
< TDD_Beamforming_SSW_ACK::GetDecodedTxSectorID (void) const
< {
<   return m_sectorID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetDecodedTxAntennaID (void) const
< {
<   return m_antennaID;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetCountIndex (void) const
< {
<   return m_countIndex;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetTransmitPeriod (void) const
< {
<   return m_transmitPeriod;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetSnrReport (void) const
< {
<   return m_snrReport;
< }
< 
< uint16_t
< TDD_Beamforming_SSW_ACK::GetInitiatorTransmitOffGet (void) const
< {
<   return m_InitiatorTransmitOffset;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetResponderTransmitOffGet (void) const
< {
<   return m_responderTransmitOffset;
< }
< 
< uint8_t
< TDD_Beamforming_SSW_ACK::GetAckCountIndex (void) const
< {
<   return m_ackCountIndex;
< }
< 
< }  // namespace ns3
---
> }  //namespace ns3
diff ../../NS3-WiGig/src/wifi/model/ctrl-headers.h ../../ns-3-dev-git/src/wifi/model/ctrl-headers.h
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
19,20c18
<  * Authors: Mirko Banchi <mk.banchi@gmail.com>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mirko Banchi <mk.banchi@gmail.com>
28d25
< #include "fields-headers.h"
34c31
<  * \brief Headers for BlockAckRequest.
---
>  * \brief Headers for Block ack request.
36,40c33,37
<  *  802.11n standard includes three types of BlockAck:
<  *    - Basic BlockAck (unique type in 802.11e)
<  *    - Compressed BlockAck
<  *    - Multi-TID BlockAck
<  *  For now only basic BlockAck and compressed BlockAck
---
>  *  802.11n standard includes three types of block ack:
>  *    - Basic block ack (unique type in 802.11e)
>  *    - Compressed block ack
>  *    - Multi-TID block ack
>  *  For now only basic block ack and compressed block ack
42c39
<  *  Basic BlockAck is also default variant.
---
>  *  Basic block ack is also default variant.
61c58
<    * Enable or disable HT immediate Ack.
---
>    * Enable or disable HT immediate ACK.
63c60
<    * \param immediateAck enable or disable HT immediate Ack
---
>    * \param immediateAck enable or disable HT immediate ACK
67c64
<    * Set the block ack type.
---
>    * Set the block ACK type.
69c66
<    * \param type the BA type
---
>    * \param type
75c72
<    * \param tid the TID
---
>    * \param tid
87c84
<    * Check if the current Ack Policy is immediate.
---
>    * Check if the current ACK policy is immediate.
89c86
<    * \return true if the current Ack Policy is immediate,
---
>    * \return true if the current ACK policy is immediate,
94,99d90
<    * Return the Block Ack type ID.
<    *
<    * \return the BA type
<    */
<   BlockAckType GetType (void) const;
<   /**
112,113c103,104
<    * Check if the current Ack Policy is Basic Block Ack
<    * (i.e. not multi-TID nor compressed).
---
>    * Check if the current ACK policy is basic
>    * (i.e. not multiple TID and not compressed ACK).
115c106
<    * \return true if the current Ack Policy is Basic Block Ack,
---
>    * \return true if the current ACK policy is basic,
120,121c111,112
<    * Check if the current Ack Policy is Compressed Block Ack
<    * and not multi-TID.
---
>    * Check if the current ACK policy is compressed ACK
>    * and not multiple TID.
123c114
<    * \return true if the current Ack Policy is Compressed Block Ack,
---
>    * \return true if the current ACK policy is compressed ACK,
128,135c119
<    * Check if the current Ack Policy is Extended Compressed Block Ack.
<    *
<    * \return true if the current Ack Policy is Extended Compressed Block Ack,
<    *         false otherwise
<    */
<   bool IsExtendedCompressed (void) const;
<   /**
<    * Check if the current Ack Policy has Multi-TID Block Ack.
---
>    * Check if the current ACK policy has multiple TID.
137c121
<    * \return true if the current Ack Policy has Multi-TID Block Ack,
---
>    * \return true if the current ACK policy has multiple TID,
155c139
<    * \param seqControl the sequence control value
---
>    * \param seqControl
159c143
<    * Return the Block Ack control.
---
>    * Return the Block ACK control.
161c145
<    * \return the Block Ack control
---
>    * \return the Block ACK control
165c149
<    * Set the Block Ack control.
---
>    * Set the Block ACK control.
167c151
<    * \param bar the BAR control value
---
>    * \param bar
172c156
<    * The LSB bit of the BAR control field is used only for the
---
>    * The lsb bit of the BAR control field is used only for the
174c158
<    * For now only non HT immediate BlockAck is implemented so this field
---
>    * For now only non HT immediate block ack is implemented so this field
177,180c161,165
<   bool m_barAckPolicy;    ///< BAR Ack Policy
<   BlockAckType m_baType;  ///< BA type
<   uint16_t m_tidInfo;     ///< TID info
<   uint16_t m_startingSeq; ///< starting sequence number
---
>   bool m_barAckPolicy; ///< bar ack policy
>   bool m_multiTid; ///< multi TID
>   bool m_compressed; ///< compressed
>   uint16_t m_tidInfo; ///< TID info
>   uint16_t m_startingSeq; ///< starting seq
183,189d167
< enum EDMG_COMPRESSED_BLOCK_ACK_BITMAP_SIZE {
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_64   = 1,
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_128  = 2,
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_256  = 4,
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_512  = 8,
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_1024 = 16,
< };
193c171
<  * \brief Headers for BlockAck response.
---
>  * \brief Headers for Block ack response.
195,199c173,177
<  *  802.11n standard includes three types of BlockAck:
<  *    - Basic BlockAck (unique type in 802.11e)
<  *    - Compressed BlockAck
<  *    - Multi-TID BlockAck
<  *  For now only basic BlockAck and compressed BlockAck
---
>  *  802.11n standard includes three types of block ack:
>  *    - Basic block ack (unique type in 802.11e)
>  *    - Compressed block ack
>  *    - Multi-TID block ack
>  *  For now only basic block ack and compressed block ack
201c179
<  *  Basic BlockAck is also default variant.
---
>  *  Basic block ack is also default variant.
220c198
<    * Enable or disable HT immediate Ack.
---
>    * Enable or disable HT immediate ACK.
222c200
<    * \param immediateAck enable or disable HT immediate Ack
---
>    * \param immediateAck enable or disable HT immediate ACK
226c204
<    * Set the block ack type.
---
>    * Set the block ACK type.
228c206
<    * \param type the BA type
---
>    * \param type
234c212
<    * \param tid the TID
---
>    * \param tid
246c224
<    * Check if the current Ack Policy is immediate.
---
>    * Check if the current ACK policy is immediate.
248c226
<    * \return true if the current Ack Policy is immediate,
---
>    * \return true if the current ACK policy is immediate,
253,258d230
<    * Return the block ack type ID.
<    *
<    * \return type
<    */
<   BlockAckType GetType (void) const;
<   /**
271c243,244
<    * Check if the current BA policy is Basic Block Ack.
---
>    * Check if the current ACK policy is basic
>    * (i.e. not multiple TID and not compressed ACK).
273c246
<    * \return true if the current BA policy is Basic Block Ack,
---
>    * \return true if the current ACK policy is basic,
278c251,252
<    * Check if the current BA policy is Compressed Block Ack.
---
>    * Check if the current ACK policy is compressed ACK
>    * and not multiple TID.
280c254
<    * \return true if the current BA policy is Compressed Block Ack,
---
>    * \return true if the current ACK policy is compressed ACK,
285,292c259
<    * Check if the current BA policy is Extended Compressed Block Ack.
<    *
<    * \return true if the current BA policy is Extended Compressed Block Ack,
<    *         false otherwise
<    */
<   bool IsExtendedCompressed (void) const;
<   /**
<    * Check if the current BA policy is Multi-TID Block Ack.
---
>    * Check if the current ACK policy has multiple TID.
294c261
<    * \return true if the current BA policy is Multi-TID Block Ack,
---
>    * \return true if the current ACK policy has multiple TID,
298,304d264
<   /**
<    * Check if the current BA policy is EDMG compressed block ACK.
<    *
<    * \return true if the current BA policy is EDMG compressed block ACK,
<    *         false otherwise
<    */
<   bool IsEdmgCompressed (void) const;
310c270
<    * \param seq the sequence number
---
>    * \param seq
317,318c277,278
<    * \param seq the sequence number
<    * \param frag the fragment number
---
>    * \param seq
>    * \param frag
323c283
<    * was acknowledged in this BlockAck response.
---
>    * was ACKed in this Block ACK response.
325c285
<    * \param seq the sequence number
---
>    * \param seq
327c287
<    *         was ACKed in this BlockAck response, false otherwise
---
>    *         was ACKed in this Block ACK response, false otherwise
332c292
<    * and fragment number was acknowledged in this BlockAck response.
---
>    * and fragment number was ACKed in this Block ACK response.
334,335c294,295
<    * \param seq the sequence number
<    * \param frag the fragment number
---
>    * \param seq
>    * \param frag
337c297
<    *         and sequence number was acknowledged in this BlockAck response,
---
>    *         and sequence number was ACKed in this Block ACK response,
352c312
<    * \param seqControl the raw sequence control value
---
>    * \param seqControl
356,368c316
<    * Return the bitmap from the BlockAck response header.
<    *
<    * \param size
<    */
<   void SetCompresssedBlockAckSize (EDMG_COMPRESSED_BLOCK_ACK_BITMAP_SIZE size);
<   /**
<    * Set receive buffer capability.
<    *
<    * \param capability
<    */
<   void SetReceiveBufferCapability (uint8_t capability);
<   /**
<    * Get receive buffer capability.
---
>    * Return the bitmap from the block ACK response header.
370,376c318
<    * \return capability
<    */
<   uint8_t GetReceiveBufferCapability (void) const;
<   /**
<    * Return the bitmap from the BlockAck response header.
<    *
<    * \return the bitmap from the BlockAck response header
---
>    * \return the bitmap from the block ACK response header
380c322
<    * Return the compressed bitmap from the BlockAck response header.
---
>    * Return the compressed bitmap from the block ACK response header.
382c324
<    * \return the compressed bitmap from the BlockAck response header
---
>    * \return the compressed bitmap from the block ACK response header
385,396d326
<   /**
<    * Return the extended compressed bitmap from the BlockAck response header.
<    *
<    * \return the extended compressed bitmap from the BlockAck response header
<    */
<   const uint64_t* GetExtendedCompressedBitmap (void) const;
<   /**
<    * Return the EDMG compressed bitmap from the block ACK response header.
<    *
<    * \return the EDMG compressed bitmap from the block ACK response header
<    */
<   const uint64_t* GetEdmgCompressedBitmap (void) const;
406c336
<    * Return the Block Ack control.
---
>    * Return the block ACK control.
408c338
<    * \return the Block Ack control
---
>    * \return the block ACK control
412c342
<    * Set the Block Ack control.
---
>    * Set the block ACK control.
414c344
<    * \param ba the BA control to set
---
>    * \param bar
416c346
<   void SetBaControl (uint16_t ba);
---
>   void SetBaControl (uint16_t bar);
421c351
<    * \param start the iterator
---
>    * \param start
428c358
<    * \param start the iterator
---
>    * \param start
454c384
<    * \return true if the sequence number is concerned by the bitmap
---
>    * \return
459c389
<    * The LSB bit of the BA control field is used only for the
---
>    * The lsb bit of the BA control field is used only for the
464,467c394,398
<   bool m_baAckPolicy;     ///< BA Ack Policy
<   BlockAckType m_baType;  ///< BA type
<   uint16_t m_tidInfo;     ///< TID info
<   uint16_t m_startingSeq; ///< starting sequence number
---
>   bool m_baAckPolicy; ///< BA ack policy
>   bool m_multiTid; ///< multi TID
>   bool m_compressed; ///< compressed
>   uint16_t m_tidInfo; ///< TID info
>   uint16_t m_startingSeq; ///< starting seq
471,476c402,403
<     uint16_t m_bitmap[64]; ///< the basic BlockAck bitmap
<     uint64_t m_compressedBitmap; ///< the compressed BlockAck bitmap
<     uint64_t m_extendedCompressedBitmap[4]; ///< the extended compressed BlockAck bitmap
<     //// WIGIG ////
<     uint64_t m_edmgCompressedBitmap[16]; ///< the EDMG compressed block ack bitmap
<     //// WIGIG ////
---
>     uint16_t m_bitmap[64]; ///< the block ack bitmap
>     uint64_t m_compressedBitmap; ///< the compressed block ack bitmap
478,1067d404
< 
<   //// WIGIG ////
<   EDMG_COMPRESSED_BLOCK_ACK_BITMAP_SIZE m_edmgCompressedBlockAckSize;
<   uint8_t m_rbufcapValue; ///< Receive buffer capacity.
<   //// WIGIG ////
< };
< 
< 
< /*************************
<  *  Poll Frame (8.3.1.11)
<  *************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Poll Frame.
<  */
< class CtrlDmgPoll : public Header
< {
< public:
<   CtrlDmgPoll ();
<   ~CtrlDmgPoll ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the offset in units of 1 microseconds.
<    *
<    * \param value The offset in units of 1 microseconds.
<    */
<    void SetResponseOffset (uint16_t value);
< 
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   uint16_t GetResponseOffset (void) const;
< 
< private:
<   uint16_t m_responseOffset;
< 
< };
< 
< /***********************************************
<  * Service Period Request (SPR) Frame (8.3.1.12)
<  ***********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Service Period Request (SPR) Frame.
<  */
< class CtrlDMG_SPR : public Header
< {
< public:
<   CtrlDMG_SPR ();
<   ~CtrlDMG_SPR ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the Dynamic Allocation Information Field.
<    *
<    * \param value The Dynamic Allocation Information Field.
<    */
<   void SetDynamicAllocationInfo (DynamicAllocationInfoField field);
<   /**
<    * Set the offset in units of 1 microseconds.
<    *
<    * \param value The offset in units of 1 microseconds.
<    */
<   void SetBFControl (BF_Control_Field value);
< 
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   DynamicAllocationInfoField GetDynamicAllocationInfo (void) const;
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   BF_Control_Field GetBFControl (void) const;
< 
< private:
<   DynamicAllocationInfoField m_dynamic;
<   BF_Control_Field m_bfControl;
< 
< };
< 
< /*************************
<  * Grant Frame (8.3.1.13)
<  *************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Grant Frame.
<  */
< class CtrlDMG_Grant : public CtrlDMG_SPR
< {
< public:
<   CtrlDMG_Grant ();
<   ~CtrlDMG_Grant ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
< 
< };
< 
< /********************************************
<  * DMG Denial to Send (DTS) Frame (8.3.1.15)
<  ********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Denial to Send (DTS) Frame.
<  */
< class CtrlDMG_DTS: public Header
< {
< public:
<   CtrlDMG_DTS ();
<   ~CtrlDMG_DTS ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the Dynamic Allocation Information Field.
<    *
<    * \param value The Dynamic Allocation Information Field.
<    */
<   void SetNAV_SA (Mac48Address value);
<   /**
<    * Set the offset in units of 1 microseconds.
<    *
<    * \param value The offset in units of 1 microseconds.
<    */
<   void SetNAV_DA (Mac48Address value);
< 
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   Mac48Address GetNAV_SA (void) const;
<   /**
<    * Return the offset in units of 1 microseconds.
<    *
<    * \return the offset in units of 1 microseconds.
<    */
<   Mac48Address GetNAV_DA (void) const;
< 
< private:
<     Mac48Address m_navSA;
<     Mac48Address m_navDA;
< 
< };
< 
< /****************************************
<  *  Sector Sweep (SSW) Frame (8.3.1.16)
<  ****************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Sector Sweep (SSW) Frame.
<  */
< class CtrlDMG_SSW : public Header
< {
< public:
<   CtrlDMG_SSW ();
<   ~CtrlDMG_SSW ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetSswField (DMG_SSW_Field &field);
<   void SetSswFeedbackField (DMG_SSW_FBCK_Field &field);
<   DMG_SSW_Field GetSswField (void) const;
<   DMG_SSW_FBCK_Field GetSswFeedbackField (void) const;
< 
< private:
<   DMG_SSW_Field m_ssw;
<   DMG_SSW_FBCK_Field m_sswFeedback;
< 
< };
< 
< /*********************************************************
<  *  Sector Sweep Feedback (SSW-Feedback) Frame (8.3.1.17)
<  *********************************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Sector Sweep Feedback (SSW-Feedback) Frame.
<  */
< class CtrlDMG_SSW_FBCK : public Header
< {
< public:
<   CtrlDMG_SSW_FBCK ();
<   virtual ~CtrlDMG_SSW_FBCK ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetSswFeedbackField (DMG_SSW_FBCK_Field &field);
<   void SetBrpRequestField (BRP_Request_Field &field);
<   void SetBfLinkMaintenanceField (BF_Link_Maintenance_Field &field);
< 
<   DMG_SSW_FBCK_Field GetSswFeedbackField (void) const;
<   BRP_Request_Field GetBrpRequestField (void) const;
<   BF_Link_Maintenance_Field GetBfLinkMaintenanceField (void) const;
< 
< private:
<   DMG_SSW_FBCK_Field m_sswFeedback;
<   BRP_Request_Field m_brpRequest;
<   BF_Link_Maintenance_Field m_linkMaintenance;
< 
< };
< 
< /**********************************************
<  * Sector Sweep ACK (SSW-ACK) Frame (8.3.1.18)
<  **********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Sector Sweep ACK (SSW-ACK) Frame.
<  */
< class CtrlDMG_SSW_ACK : public CtrlDMG_SSW_FBCK
< {
< public:
<   CtrlDMG_SSW_ACK (void);
<   virtual ~CtrlDMG_SSW_ACK (void);
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
< 
< };
< 
< /******************************
<  *  Grant ACK Frame (8.3.1.19)
<  ******************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for Grant ACK Frame.
<  * The Grant ACK frame is sent only in CBAPs as a response to the reception of a Grant frame
<  * that has the Beamforming Training field equal to 1.
<  */
< class CtrlGrantAck : public Header
< {
< public:
<   CtrlGrantAck ();
<   ~CtrlGrantAck ();
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
< private:
<   uint8_t m_reserved[5];
<   BF_Control_Field m_bfControl;
< 
< };
< 
< /*********************************************
<  *  TDD Beamforming frame format (9.3.1.24.1)
<  *********************************************/
< 
< enum TDD_Beamforming_Frame_Type {
<   TDD_SSW = 0,
<   TDD_SSW_Feedback = 1,
<   TDD_SSW_ACK = 2,
< };
< 
< enum TDD_BEAMFORMING_PROCEDURE {
<   TDD_BEAMFORMING_INDIVIDUAL = 0,
<   TDD_BEAMFORMING_GROUP = 1,
<   TDD_BEAMFORMING_MEASUREMENT = 2,
< };
< 
< /**
<  * \ingroup wifi
<  * \brief Header for TDD Beamforming Frame.
<  */
< class TDD_Beamforming : public Header
< {
< public:
<   TDD_Beamforming ();
<   ~TDD_Beamforming ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /** TDD Beamforming Control field **/
<   void SetGroup_Beamforming (bool value);
<   void SetBeam_Measurement (bool value);
<   void SetBeamformingFrameType (TDD_Beamforming_Frame_Type type);
<   /**
<    * The End of Training subfield is set as follows:
<    *  A. The End of Training subfield is set to 1 in a TDD SSW frame to indicate that the initiator intends to
<    *  end the TDD individual beamforming training or the TDD beam measurement after the transmission
<    *  of the remaining TDD SSW frames with the current Sector ID; this subfield is set to 0 otherwise.
<    *  B. The End of Training subfield is set to 1 in a TDD SSW Feedback frame sent as part of a TDD
<    *  individual beamforming training if the TDD SSW Feedback frame is sent in response to a TDD SSW
<    *  frame in which its End of Training subfield was set to 1; this subfield is set to 0 otherwise.
<    *  C. The End of Training subfield is set to 1 in a TDD SSW Ack frame to indicate that the TDD individual
<    *  beamforming training has completed; otherwise, this subfield is set to 0.
<    * For TDD group BF, the End of Training subfield is reserved.
<    * \param value
<    */
<   void SetEndOfTraining (bool value);
< 
<   bool GetGroup_Beamforming (void) const;
<   bool GetBeam_Measurement (void) const;
<   TDD_Beamforming_Frame_Type GetBeamformingFrameType (void) const;
<   bool GetEndOfTraining (void) const;
< 
<   TDD_BEAMFORMING_PROCEDURE GetBeamformingProcedure (Mac48Address receiver) const;
< 
< protected:
<   bool m_groupBeamforming;
<   bool m_beamMeasurement;
<   TDD_Beamforming_Frame_Type m_beamformingFrameType;
<   bool m_endOfTraining;
< 
< };
< 
< /*********************************************
<  * TDD Sector Sweep (SSW) format (9.3.1.24.2)
<  *********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for TDD Beamforming Frame of a TDD SSW frame.
<  */
< class TDD_Beamforming_SSW : public TDD_Beamforming
< {
< public:
<   TDD_Beamforming_SSW ();
<   ~TDD_Beamforming_SSW ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /* TDD Beamforming Information field format (TDD individual BF) */
<   void SetTxSectorID (uint16_t sectorID);
<   void SetTxAntennaID (uint8_t antennaID);
<   void SetCountIndex (uint8_t index);
<   void SetBeamformingTimeUnit (uint8_t unit);
<   void SetTransmitPeriod (uint8_t period);
<   void SetResponderFeedbackOffset (uint16_t offset);
<   void SetInitiatorAckOffset (uint16_t offset);
<   void SetNumberOfRequestedFeedback (uint8_t feedback);
< 
<   uint16_t GetTxSectorID (void) const;
<   uint8_t GetTxAntennaID (void) const;
<   uint8_t GetCountIndex (void) const;
<   uint8_t GetBeamformingTimeUnit (void) const;
<   uint8_t GetTransmitPeriod (void) const;
<   uint16_t GetResponderFeedbackOffset (void) const;
<   uint16_t GetInitiatorAckOffset (void) const;
<   uint8_t GetNumberOfRequestedFeedback (void) const;
< 
<   /* TDD Beamforming Information field format (TDD beam measurement) */
<   void SetTDDSlotCDOWN (uint16_t cdown);
<   void SetFeedbackRequested (bool feedback);
< 
<   uint16_t GetTDDSlotCDOWN (void) const;
<   bool GetFeedbackRequested (void) const;
< 
< private:
<   /* TDD Beamforming Information field format (TDD individual BF) */
<   uint16_t m_sectorID;
<   uint8_t m_antennaID;
<   uint8_t m_countIndex;
<   uint8_t m_beamformingTimeUnit;
<   uint8_t m_transmitPeriod;
<   uint16_t m_responderFeedbackOffset;
<   uint16_t m_initiatorAckOffset;
<   uint8_t m_numRequestedFeedback;
< 
<   /* TDD Beamforming Information field format (TDD beam measurement) */
<   uint16_t m_tddSlotCDOWN;
<   bool m_feedbackRequested;
< 
< };
< 
< /*********************************************
<  *     TDD SSW Feedback format (9.3.1.24.3)
<  *********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for TDD Beamforming Frame.
<  */
< class TDD_Beamforming_SSW_FEEDBACK : public TDD_Beamforming
< {
< public:
<   TDD_Beamforming_SSW_FEEDBACK ();
<   ~TDD_Beamforming_SSW_FEEDBACK ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The TX Sector ID subfield is set to indicate the sector through which the TDD SSW Feedback frame is transmitted.
<    * \param sectorID
<    */
<   void SetTxSectorID (uint16_t sectorID);
<   /**
<    * The TX Antenna ID subfield indicates the DMG antenna ID through which the TDD SSW Feedback frame is transmitted.
<    * \param antennaID
<    */
<   void SetTxAntennaID (uint8_t antennaID);
<   /**
<    * The Decoded TX Sector ID subfield contains the value of the TX Sector ID subfield from the TDD SSW
<    * frame that the feedback frame is sent in response to and that the TDD SSW frame was received from the
<    * initiator with the best quality.
<    * \param sectorID
<    */
<   void SetDecodedTxSectorID (uint16_t sectorID);
<   /**
<    * The Decoded TX Antenna ID subfield contains the value of the TX Antenna ID subfield from the TDD SSW
<    * frame that the feedback frame is sent in response to and that was received with the best quality.
<    * \param antennaID
<    */
<   void SetDecodedTxAntennaID (uint8_t antennaID);
<   /**
<    * The SNR Report subfield is set to the value of the SNR achieved while decoding the TDD SSW frame
<    * received with the best quality and which is indicated in the Decoded TX Sector ID subfield. The value of the
<    * SNR Report subfield is an unsigned integer referenced to a level of –8 dB. Each step is 0.25 dB. SNR values
<    * less than or equal to –8 dB are represented as 0. SNR values greater than or equal to 55.75 dB are represented
<    * as 0xFF.
<    * \param snr
<    */
<   void SetSnrReport (uint8_t snr);
<   /**
<    * The Feedback Count Index subfield is counter indicating the index of the TDD SSW Feedback frame
<    * transmission during a TDD slot. Value 0 is used in the first transmitted TDD SSW Feedback frame and this
<    * subfield value is increased by 1 for each subsequent transmitted frame.
<    * \param index
<    */
<   void SetFeedbackCountIndex (uint8_t index);
< 
<   uint16_t GetTxSectorID (void) const;
<   uint8_t GetTxAntennaID (void) const;
<   uint16_t GetDecodedTxSectorID (void) const;
<   uint8_t GetDecodedTxAntennaID (void) const;
<   uint8_t GetSnrReport (void) const;
<   uint8_t GetFeedbackCountIndex (void) const;
< 
< private:
<   uint16_t m_sectorID;
<   uint8_t m_antennaID;
<   uint16_t m_decodedSectorID;
<   uint8_t m_decodedAntennaID;
<   uint8_t m_snrReport;
<   uint8_t m_feedbackCountIndex;
< 
< };
< 
< /*********************************************
<  *     TDD SSW ACK format (9.3.1.24.4)
<  *********************************************/
< 
< /**
<  * \ingroup wifi
<  * \brief Header for TDD Beamforming SSW ACK Frame.
<  */
< class TDD_Beamforming_SSW_ACK : public TDD_Beamforming
< {
< public:
<   TDD_Beamforming_SSW_ACK ();
<   ~TDD_Beamforming_SSW_ACK ();
< 
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Decoded TX Sector ID subfield contains the value of the TX Sector ID subfield from the TDD SSW
<    * Feedback frame that was received from the responder.
<    * \param sectorID
<    */
<   void SetDecodedTxSectorID (uint16_t sectorID);
<   /**
<    * The Decoded TX Antenna ID subfield contains the value of the TX Antenna ID subfield from the TDD SSW
<    * Feedback frame that was received from the responder.
<    * \param antennaID
<    */
<   void SetDecodedTxAntennaID (uint8_t antennaID);
<   /**
<    * The Count Index subfield indicates the index of the TDD Beamforming frame transmitted by the initiator
<    * within a TDD slot, with the subfield set to 0 for the first frame transmission and increased by one for each
<    * successive frame transmission within a TDD slot.
<    * \param index
<    */
<   void SetCountIndex (uint8_t index);
<   /**
<    * The Transmit Period subfield indicates the interval, in units of BTUs, between successive TDD SSW
<    * transmissions with the same Count Index subfield value in different TDD slots.
<    * \param period
<    */
<   void SetTransmitPeriod (uint8_t period);
<   /**
<    * The SNR Report subfield is set to the value of the SNR achieved while decoding the TDD SSW Feedback
<    * frame. The value of the SNR Report subfield is an unsigned integer referenced to a level of –8 dB. Each step
<    * is 0.25 dB. SNR values less than or equal to –8 dB are represented as 0. SNR values greater than or equal to
<    * 55.75 dB are represented as 0xFF.
<    * \param snr
<    */
<   void SetSnrReport (uint8_t snr);
<   /**
<    * The Initiator Transmit Offset subfield indicates the offset, in units of BTUs, beginning immediately after the
<    * end of the TDD SSW Ack frame, to the TDD slot in which the initiator is expected to transmit an additional
<    * frame (e.g., an Announce frame) to the responder. When the Initiator Transmit Offset subfield is set to 0, no
<    * time offset indication is specified by the initiator.
<    * \param offset
<    */
<   void SetInitiatorTransmitOffset (uint16_t offset);
<   /**
<    * The Responder Transmit Offset subfield indicates the offset, in units of BTUs, beginning immediately after
<    * the TDD SSW Ack frame, to the TDD slot in which the responder is expected to respond to frames sent by
<    * the initiator. When the Responder Transmit Offset subfield is set to 0, no time offset indication is specified
<    * by the initiator.
<    * \param offset
<    */
<   void SetResponderTransmitOffset (uint8_t offset);
<   /**
<    * The Ack Count Index subfield indicates the number of the TDD SSW Ack frames that have been sent before
<    * the current TDD SSW Ack frame within the same TDD slot. The Ack Count Index subfield is set to 0 if no
<    * TDD SSW Ack frame is transmitted before the current TDD SSW Ack frame in the same TDD slot, and
<    * increases by one for each transmission of a TDD SSW Ack frame within the same TDD slot.
<    * \param count
<    */
<   void SetAckCountIndex (uint8_t count);
< 
<   uint16_t GetDecodedTxSectorID (void) const;
<   uint8_t GetDecodedTxAntennaID (void) const;
<   uint8_t GetCountIndex (void) const;
<   uint8_t GetTransmitPeriod (void) const;
<   uint8_t GetSnrReport (void) const;
<   uint16_t GetInitiatorTransmitOffGet (void) const;
<   uint8_t GetResponderTransmitOffGet (void) const;
<   uint8_t GetAckCountIndex (void) const;
< 
< private:
<   uint16_t m_sectorID;
<   uint8_t m_antennaID;
<   uint8_t m_countIndex;
<   uint8_t m_transmitPeriod;
<   uint8_t m_snrReport;
<   uint16_t m_InitiatorTransmitOffset;
<   uint8_t m_responderTransmitOffset;
<   uint8_t m_ackCountIndex;
< 
1070c407
< } // namespace ns3
---
> } //namespace ns3
Only in ../../NS3-WiGig/src/wifi/model: dmg-adhoc-wifi-mac.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-adhoc-wifi-mac.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-ap-wifi-mac.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-ap-wifi-mac.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-ati-txop.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-ati-txop.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-beacon-txop.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-beacon-txop.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-capabilities.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-capabilities.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-error-model.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-error-model.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-information-elements.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-information-elements.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-sls-txop.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-sls-txop.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-sta-wifi-mac.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-sta-wifi-mac.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-channel.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-channel.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-mac.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-mac.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-phy.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-phy.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-phy-header.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-phy-header.h
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-spectrum-phy-interface.cc
Only in ../../NS3-WiGig/src/wifi/model: dmg-wifi-spectrum-phy-interface.h
diff ../../NS3-WiGig/src/wifi/model/dsss-error-rate-model.cc ../../ns-3-dev-git/src/wifi/model/dsss-error-rate-model.cc
71c71
<   //The Matlab model
---
>   //The matlab model
83c83
<       //fitprops.coeff from Matlab berfit
---
>       //fitprops.coeff from matlab berfit
106c106
<   //The Matlab model
---
>   //The matlab model
118c118
<       //fitprops.coeff from Matlab berfit
---
>       //fitprops.coeff from matlab berfit
diff ../../NS3-WiGig/src/wifi/model/dsss-error-rate-model.h ../../ns-3-dev-git/src/wifi/model/dsss-error-rate-model.h
34,36d33
< /**
<  * Structure for integral function parameters
<  */
39,40c36,37
<   double beta; ///< Beta parameter
<   double n;    ///< n parameter
---
>   double beta;
>   double n;
43,50d39
< /**
<  * Integral function using GSL library
<  *
<  * \param x the input x variable
<  * \param params a pointer to FunctionParameters struct
<  *
<  * \return the integral function
<  */
62c51
<  *      approximations for DQPSK transmission bit error rate", G. Ferrari and G.E. Corazza
---
>  *      approximations for dqpsk transmission bit error rate", G. Ferrari and G.E. Corazza
65c54
<  *      performance of the IEEE 802.11b complementarycode-key signal sets",
---
>  *      performance of the ieee 802.11b complementarycode-key signal sets",
69c58
<  *  This model is designed to run with highest accuracy using the GNU
---
>  *  This model is designed to run with highest accuracy using the Gnu
83c72
<    * \param x the input variable
---
>    * \param x x
diff ../../NS3-WiGig/src/wifi/model/dsss-parameter-set.h ../../ns-3-dev-git/src/wifi/model/dsss-parameter-set.h
37a38,42
>   /**
>    * Set DSSS supported
>    * \param DsssSupported the DSSS supported indicator
>    */
>   void SetDsssSupported (uint8_t DsssSupported);
39c44,54
<   // Implementations of pure virtual methods of WifiInformationElement
---
>   /**
>    * Set the Current Channel field in the DsssParameterSet information element.
>    *
>    * \param currentChannel the CurrentChannel field in the DsssParameterSet information element
>    */
>   void SetCurrentChannel (uint8_t currentChannel);
> 
>   /**
>    * Element ID function
>    * \returns the wifi information element ID
>    */
40a56,59
>   /**
>    * Get information field size function
>    * \returns the information field size
>    */
41a61,65
>   /**
>    * Serialize information field function
>    * \param start the iterator
>    * \returns the updated iterator
>    */
42a67,72
>   /**
>    * Deserialize infornamtion field function
>    * \param start the iterator
>    * \param length the length
>    * \returns the updated iterator
>    */
44,49d73
<   /* This information element is a bit special in that it is only
<      included if the STA does support DSSS. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
52,53c76,83
<    * Set DSSS supported
<    * \param dsssSupported the DSSS supported indicator
---
>    * This information element is a bit special in that it is only
>    * included if the STA does support DSSS. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
55,56c85
<   void SetDsssSupported (uint8_t dsssSupported);
< 
---
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
58c87
<    * Set the Current Channel field in the DsssParameterSet information element.
---
>    * Return the serialized size of this DSSS Parameter Set.
60c89
<    * \param currentChannel the CurrentChannel field in the DsssParameterSet information element
---
>    * \return the serialized size of this DSSS Parameter Set
62c91
<   void SetCurrentChannel (uint8_t currentChannel);
---
>   uint16_t GetSerializedSize () const;
diff ../../NS3-WiGig/src/wifi/model/edca-parameter-set.h ../../ns-3-dev-git/src/wifi/model/edca-parameter-set.h
38,50d37
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is a QoS STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
290a278,318
> 
>   /**
>    * Element ID function
>    * \returns the wifi information element ID
>    */
>   WifiInformationElementId ElementId () const;
>   /**
>    * Get information field size function
>    * \returns the information field size
>    */
>   uint8_t GetInformationFieldSize () const;
>   /**
>    * Serialize information field function
>    * \param start the iterator
>    */
>   void SerializeInformationField (Buffer::Iterator start) const;
>   /**
>    * Deserialize information field function
>    * \param start the iterator
>    * \param length the length
>    * \returns the size
>    */
>   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
> 
>   /**
>    * This information element is a bit special in that it is only
>    * included if the STA is a QoS STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this EDCA Parameter Set.
>    *
>    * \return the serialized size of this EDCA Parameter Set
>    */
>   uint16_t GetSerializedSize () const;
Only in ../../NS3-WiGig/src/wifi/model: edmg-capabilities.cc
Only in ../../NS3-WiGig/src/wifi/model: edmg-capabilities.h
Only in ../../NS3-WiGig/src/wifi/model: edmg-short-ssw.cc
Only in ../../NS3-WiGig/src/wifi/model: edmg-short-ssw.h
diff ../../NS3-WiGig/src/wifi/model/erp-information.cc ../../ns-3-dev-git/src/wifi/model/erp-information.cc
123a124,131
> /**
>  * output stream output operator
>  *
>  * \param os output stream
>  * \param erpinformation
>  *
>  * \returns output stream
>  */
125c133
< operator << (std::ostream &os, const ErpInformation &erpInformation)
---
> operator << (std::ostream &os, const ErpInformation &erpinformation)
127,129c135,137
<   os <<  bool (erpInformation.GetBarkerPreambleMode ())
<      << "|" << bool (erpInformation.GetUseProtection ())
<      << "|" << bool (erpInformation.GetNonErpPresent ());
---
>   os <<  bool (erpinformation.GetBarkerPreambleMode ())
>      << "|" << bool (erpinformation.GetUseProtection ())
>      << "|" << bool (erpinformation.GetNonErpPresent ());
diff ../../NS3-WiGig/src/wifi/model/erp-information.h ../../ns-3-dev-git/src/wifi/model/erp-information.h
38,52d37
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
< 
<   /* This information element is a bit special in that it is only
<      included if the STA is an ERP STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
97a83,128
>   /**
>    * Get the element ID field.
>    *
>    * \returns WifiInformationElementId
>    */
>   WifiInformationElementId ElementId () const;
>   /**
>    * Get the information field size.
>    *
>    * \returns the element field size
>    */
>   uint8_t GetInformationFieldSize () const;
>   /**
>    * Serialize the information field.
>    *
>    * \param start the information element iterator
>    */
>   void SerializeInformationField (Buffer::Iterator start) const;
>   /**
>    * Get the information field size.
>    *
>    * \param start the information element iterator
>    * \param length the information field length
>    *
>    * \returns the information field
>    */
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
> 
>   /**
>    * This information element is a bit special in that it is only
>    * included if the STA is an ERP STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this ErpInformation information element.
>    *
>    * \return the serialized size of this ErpInformation information element
>    */
>   uint16_t GetSerializedSize () const;
110c141
<  * \param erpInformation the ERP Information
---
>  * \param erpinformation
114c145
< std::ostream &operator << (std::ostream &os, const ErpInformation &erpInformation);
---
> std::ostream &operator << (std::ostream &os, const ErpInformation &erpinformation);
diff ../../NS3-WiGig/src/wifi/model/error-rate-model.h ../../ns-3-dev-git/src/wifi/model/error-rate-model.h
47c47
<    * \param ber a target BER
---
>    * \param ber a target ber
49c49
<    * \return the SNR which corresponds to the requested BER
---
>    * \return the snr which corresponds to the requested ber
64c64
<    * contains multiple modes (e.g. PHY header sent differently from PHY
---
>    * contains multiple modes (e.g. PLCP header sent differently from PLCP
diff ../../NS3-WiGig/src/wifi/model/extended-capabilities.cc ../../ns-3-dev-git/src/wifi/model/extended-capabilities.cc
395a396,403
> /**
>  * output stream output operator
>  *
>  * \param os output stream
>  * \param extendedcapabilities the extended capabilities
>  *
>  * \returns output stream
>  */
397c405
< operator << (std::ostream &os, const ExtendedCapabilities &extendedCapabilities)
---
> operator << (std::ostream &os, const ExtendedCapabilities &extendedcapabilities)
399c407
<   os << +extendedCapabilities.GetExtendedCapabilitiesByte1 ();
---
>   os << +extendedcapabilities.GetExtendedCapabilitiesByte1 ();
diff ../../NS3-WiGig/src/wifi/model/extended-capabilities.h ../../ns-3-dev-git/src/wifi/model/extended-capabilities.h
32a33,34
>  *
>  * \see attribute_ExtendedCapabilities
38,51d39
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is a HT STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
55c43
<    * \param htSupported flag whether HT is supported
---
>    * \param htsupported flag whether HT is supported
57c45
<   void SetHtSupported (uint8_t htSupported);
---
>   void SetHtSupported (uint8_t htsupported);
61c49
<    * \param vhtSupported flag whether VHT is supported
---
>    * \param vhtsupported flag whether VHT is supported
63c51
<   void SetVhtSupported (uint8_t vhtSupported);
---
>   void SetVhtSupported (uint8_t vhtsupported);
162a151,196
>   /**
>    * Return the element ID.
>    *
>    * \return the element ID
>    */
>   WifiInformationElementId ElementId () const;
>   /**
>    * Return the information field size.
>    *
>    * \return the information field size
>    */
>   uint8_t GetInformationFieldSize () const;
>   /**
>    * Serialize the information field.
>    *
>    * \param start the information field
>    */
>   void SerializeInformationField (Buffer::Iterator start) const;
>   /**
>    * Return the information field.
>    *
>    * \param start field
>    * \param length field length
>    *
>    * \return the information field
>    */
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
>   /**
>    * This information element is a bit special in that it is only
>    * included if the STA is an HT or a VHT STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this extended capabilities information element.
>    *
>    * \return the serialized size of this extended capabilities information element
>    */
>   uint16_t GetSerializedSize () const;
> 
165c199
<   //fields if HT supported
---
>   //fields supported by HT and VHT
167,177c201,211
<   uint8_t m_extendedChannelSwitching;              ///< Extended Channel Switching
<   uint8_t m_psmpCapability;                        ///< PSMP Capability
<   uint8_t m_spsmpSupport;                          ///< S-PSMP Support
< 
<   //fields if VHT supported
<   uint8_t m_event;                           ///< Event
<   uint8_t m_diagnostics;                     ///< Diagnostics
<   uint8_t m_multicastDiagnostics;            ///< Multicast Diagnostics
<   uint8_t m_locationTracking;                ///< Location Tracking
<   uint8_t m_fms;                             ///< FMS
<   uint8_t m_proxyArpService;                 ///< Proxy ARP Service
---
>   uint8_t m_extendedChannelSwitching; ///< Extended Channel Switching
>   uint8_t m_psmpCapability; ///< PSMP Capability
>   uint8_t m_spsmpSupport; ///< S-PSMP Support
> 
>   //fields supported by VHT
>   uint8_t m_event; ///< Event
>   uint8_t m_diagnostics; ///< Diagnostics
>   uint8_t m_multicastDiagnostics; ///< Multicast Diagnostics
>   uint8_t m_locationTracking; ///< Location Tracking
>   uint8_t m_fms; ///< FMS
>   uint8_t m_proxyArpService; ///< Proxy ARP Service
179,180c213,214
<   uint8_t m_civicLocation;                   ///< Civic Location
<   uint8_t m_geospatialLocation;              ///< Geospatial Location
---
>   uint8_t m_civicLocation; ///< Civic Location
>   uint8_t m_geospatialLocation; ///< Geospatial Location
182,185c216,219
<   uint8_t m_tfs;                  ///< TFS
<   uint8_t m_wnmSleepMode;         ///< WNM Sleep Mode
<   uint8_t m_timBroadcast;         ///< TIM Broadcast
<   uint8_t m_bssTransition;        ///< BSS Transition
---
>   uint8_t m_tfs; ///< TFS
>   uint8_t m_wnmSleepMode; ///< WNM Sleep Mode
>   uint8_t m_timBroadcast; ///< TIM Broadcast
>   uint8_t m_bssTransition; ///< BSS Transition
187,196c221,230
<   uint8_t m_acStationCount;       ///< AC Station Count
<   uint8_t m_multipleBssid;        ///< Multiple BSSID
<   uint8_t m_timingMeasurement;    ///< Timing Measurement
< 
<   uint8_t m_channelUsage;         ///< Channel Usage
<   uint8_t m_ssidList;             ///< SSID List
<   uint8_t m_dms;                  ///< DMS
<   uint8_t m_utcTsfOffset;         ///< UTC TSF Offset
<   uint8_t m_tpuBufferStaSupport;  ///< TPU Buffer STA Support
<   uint8_t m_tdlsPeerPsmSupport;   ///< TDLS Peer PSM Support
---
>   uint8_t m_acStationCount; ///< AC Station Count
>   uint8_t m_multipleBssid; ///< Multiple BSSID
>   uint8_t m_timingMeasurement; ///< Timing Measurement
> 
>   uint8_t m_channelUsage; ///< Channel Usage
>   uint8_t m_ssidList; ///< SSID List
>   uint8_t m_dms; ///< DMS
>   uint8_t m_utcTsfOffset; ///< UTC TSF Offset
>   uint8_t m_tpuBufferStaSupport; ///< TPU Buffer STA Support
>   uint8_t m_tdlsPeerPsmSupport; ///< TDLS Peer PSM Support
198c232
<   uint8_t m_interworking;         ///< Interworking
---
>   uint8_t m_interworking; ///< Interworking
200,205c234,239
<   uint8_t m_qosMap;                         ///< QoS Map
<   uint8_t m_ebr;                            ///< EBR
<   uint8_t m_sspnInterface;                  ///< SSPN Interface
<   uint8_t m_msgcfCapability;                ///< MSGCF Capability
<   uint8_t m_tdlsSupport;                    ///< TDLS Support
<   uint8_t m_tdlsProhibited;                 ///< TDLS Prohibited
---
>   uint8_t m_qosMap; ///< QoS Map
>   uint8_t m_ebr; ///< EBR
>   uint8_t m_sspnInterface; ///< SSPN Interface
>   uint8_t m_msgcfCapability; ///< MSGCF Capability
>   uint8_t m_tdlsSupport; ///< TDLS Support
>   uint8_t m_tdlsProhibited; ///< TDLS Prohibited
208c242
<   uint8_t m_rejectUnadmittedFrame;      ///< Reject Unadmitted Frame
---
>   uint8_t m_rejectUnadmittedFrame; ///< Reject Unadmitted Frame
210,213c244,247
<   uint8_t m_identifierLocation;         ///< Identifier Location
<   uint8_t m_uapsdCoexistence;           ///< U-APSD Coexistence
<   uint8_t m_wnmNotification;            ///< WNM Notification
<   uint8_t m_qabCapability;              ///< QAB Capability
---
>   uint8_t m_identifierLocation; ///< Identifier Location
>   uint8_t m_uapsdCoexistence; ///< U-APSD Coexistence
>   uint8_t m_wnmNotification; ///< WNM Notification
>   uint8_t m_qabCapability; ///< QAB Capability
215,216c249,250
<   uint8_t m_utf8Ssid;                    ///< UTF-8 SSID
<   uint8_t m_qmfActivated;                ///< QMFActivated
---
>   uint8_t m_utf8Ssid; ///< UTF-8 SSID
>   uint8_t m_qmfActivated; ///< QMFActivated
218,222c252,256
<   uint8_t m_robustAvStreaming;           ///< Robust AV Streaming
<   uint8_t m_advancedGcr;                 ///< Advanced GCR
<   uint8_t m_meshGcr;                     ///< Mesh GCR
<   uint8_t m_scs;                         ///< SCS
<   uint8_t m_qloadReport;                 ///< QLoad Report
---
>   uint8_t m_robustAvStreaming; ///< Robust AV Streaming
>   uint8_t m_advancedGcr; ///< Advanced GCR
>   uint8_t m_meshGcr; ///< Mesh GCR
>   uint8_t m_scs; ///< SCS
>   uint8_t m_qloadReport; ///< QLoad Report
224c258
<   uint8_t m_alternateEdca;              ///< Alternate EDCA
---
>   uint8_t m_alternateEdca; ///< Alternate EDCA
226,230c260,264
<   uint8_t m_protectedTxopNegotiation;   ///< Protected TXOP Negotiation
<   uint8_t m_protectedQloadReport;       ///< Protected QLoad Report
<   uint8_t m_tdlsWiderBandwidth;         ///< TDLS Wider Bandwidth
<   uint8_t m_operatingModeNotification;  ///< Operating Mode Notification
<   uint8_t m_maxNumberOfMsdusInAmsdu;    ///< Max Number Of MSDUs In A-MSDU
---
>   uint8_t m_protectedTxopNegotiation; ///< Protected TXOP Negotiation
>   uint8_t m_protectedQloadReport; ///< Protected QLoad Report
>   uint8_t m_tdlsWiderBandwidth; ///< TDLS Wider Bandwidth
>   uint8_t m_operatingModeNotification; ///< Operating Mode Notification
>   uint8_t m_maxNumberOfMsdusInAmsdu; ///< Max Number Of MSDUs In A-MSDU
236,244c270
< /**
<  * output stream output operator
<  *
<  * \param os output stream
<  * \param extendedCapabilities the extended capabilities
<  *
<  * \returns output stream
<  */
< std::ostream &operator << (std::ostream &os, const ExtendedCapabilities &extendedCapabilities);
---
> std::ostream &operator << (std::ostream &os, const ExtendedCapabilities &extendedcapabilities);
Only in ../../NS3-WiGig/src/wifi/model: ext-headers.cc
Only in ../../NS3-WiGig/src/wifi/model: ext-headers.h
Only in ../../NS3-WiGig/src/wifi/model: fields-headers.cc
Only in ../../NS3-WiGig/src/wifi/model: fields-headers.h
diff ../../NS3-WiGig/src/wifi/model/frame-capture-model.cc ../../ns-3-dev-git/src/wifi/model/frame-capture-model.cc
21,22d20
< #include "ns3/nstime.h"
< #include "ns3/simulator.h"
24d21
< #include "wifi-phy.h"
35,39d31
<     .AddAttribute ("CaptureWindow",
<                    "The duration of the capture window.",
<                    TimeValue (NanoSeconds (1891)),
<                    MakeTimeAccessor (&FrameCaptureModel::m_captureWindow),
<                    MakeTimeChecker ())
42,53d33
< }
< 
< void
< FrameCaptureModel::SetWifiPhy (Ptr<WifiPhy> wifiPhy)
< {
<   m_wifiPhy = wifiPhy;
< }
< 
< bool
< FrameCaptureModel::IsInCaptureWindow (Time timePreambleDetected) const
< {
<   return (timePreambleDetected + m_captureWindow >= Simulator::Now ());
diff ../../NS3-WiGig/src/wifi/model/frame-capture-model.h ../../ns-3-dev-git/src/wifi/model/frame-capture-model.h
29,30d28
< class WifiPhy;
< class Time;
45c43
<   void SetWifiPhy (Ptr<WifiPhy> wifiPhy);
---
> 
58,75d55
< 
<   /**
<    * This method returns true if the capture window duration has not elapsed yet,
<    *                     false otherwise.
<    *
<    * \param timePreambleDetected the time the preamble was detected
<    *
<    * \return true if the capture window duration has not elapsed yet,
<    *         false otherwise
<    */
<   virtual bool IsInCaptureWindow (Time timePreambleDetected) const;
< 
< protected:
<   Ptr<WifiPhy> m_wifiPhy;
< 
< 
< private:
<   Time m_captureWindow; //!< Capture window duration
80a61
> 
diff ../../NS3-WiGig/src/wifi/model/he-capabilities.cc ../../ns-3-dev-git/src/wifi/model/he-capabilities.cc
43c43
<     m_omControlSupport (0),
---
>     m_omiAcontrolSupport (0),
45c45
<     m_maxAmpduLengthExponent (0),
---
>     m_maximumAmpduLengthExponent (0),
96,102c96
<   return IE_EXTENSION;
< }
< 
< WifiInformationElementId
< HeCapabilities::ElementIdExt () const
< {
<   return IE_EXT_HE_CAPABILITIES;
---
>   return IE_HE_CAPABILITIES;
106c100
< HeCapabilities::SetHeSupported (uint8_t heSupported)
---
> HeCapabilities::SetHeSupported (uint8_t hesupported)
108c102
<   m_heSupported = heSupported;
---
>   m_heSupported = hesupported;
114c108
<   //we should not be here if HE is not supported
---
>   //we should not be here if ht is not supported
116c110
<   return 19; //todo: variable length!
---
>   return 16; //todo: variable length!
149,151c143,144
<       start.WriteHtolsbU32 (GetSupportedMcsAndNss ());
<       //todo: add another 32-bits field if 160 MHz channel is supported (variable length)
<       //todo: optional PPE Threshold field (variable length)
---
>       start.WriteU16 (GetSupportedMcsAndNss ()); //todo: variable length
>       //todo: optional PPE Threshold field
163c156
<   uint32_t mcsset = i.ReadU32 ();
---
>   uint16_t mcsset = i.ReadU16 (); //todo: variable length
167,168c160
<   //todo: add another 32-bits field if 160 MHz channel is supported (variable length)
<   //todo: optional PPE Threshold field (variable length)
---
>   //todo: optional PPE Threshold field
192c184
<   m_omControlSupport = (ctrl1 >> 25) & 0x03;
---
>   m_omiAcontrolSupport = (ctrl1 >> 25) & 0x03;
194c186
<   m_maxAmpduLengthExponent = (ctrl1 >> 27) & 0x03;
---
>   m_maximumAmpduLengthExponent = (ctrl1 >> 27) & 0x03;
224c216
<   val |= (m_omControlSupport & 0x03) << 25;
---
>   val |= (m_omiAcontrolSupport & 0x03) << 25;
226c218
<   val |= (m_maxAmpduLengthExponent & 0x03) << 27;
---
>   val |= (m_maximumAmpduLengthExponent & 0x03) << 27;
436c428
< HeCapabilities::SetMaxAmpduLength (uint32_t maxAmpduLength)
---
> HeCapabilities::SetMaxAmpduLengthExponent (uint8_t exponent)
438,446c430,431
<   for (uint8_t i = 0; i <= 3; i++)
<     {
<       if ((1ul << (20 + i)) - 1 == maxAmpduLength)
<         {
<           m_maxAmpduLengthExponent = i;
<           return;
<         }
<     }
<   NS_ABORT_MSG ("Invalid A-MPDU Max Length value");
---
>   NS_ASSERT (exponent <= 7);
>   m_maximumAmpduLengthExponent = exponent;
487,492c472,477
< uint32_t
< HeCapabilities::GetMaxAmpduLength (void) const
< {
<   return (1ul << (20 + m_maxAmpduLengthExponent)) - 1;
< }
< 
---
> /**
>  * output stream output operator
>  * \param os the output stream
>  * \param HeCapabilities the HE capabilities
>  * \returns the output stream
>  */
diff ../../NS3-WiGig/src/wifi/model/he-capabilities.h ../../ns-3-dev-git/src/wifi/model/he-capabilities.h
37,38c37,45
< 
<   // Implementations of pure virtual methods of WifiInformationElement
---
>   /**
>    * Set HE supported
>    * \param hesupported the HE supported indicator
>    */
>   void SetHeSupported (uint8_t hesupported);
>   /**
>    * Get the wifi information element ID
>    * \returns the wifi information element ID
>    */
40c47,50
<   WifiInformationElementId ElementIdExt () const;
---
>   /**
>    * Get information field size
>    * \returns the information field size
>    */
41a52,55
>   /**
>    * Serialize information field
>    * \param start the information field iterator
>    */
43,50d56
<   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is an HE STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
52,53c58,61
<    * Set HE supported
<    * \param heSupported the HE supported indicator
---
>    * Deserialize information field
>    * \param start the information field iterator
>    * \param length the length
>    * \returns the information field size
55c63
<   void SetHeSupported (uint8_t heSupported);
---
>   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
149c157
<    * Set the maximum AMPDU length.
---
>    * Set maximum AMPDU length exponent.
151c159
<    * \param maxAmpduLength 2^(20 + x) - 1, x in the range 0 to 3
---
>    * \param exponent the maximum AMPDU length exponent
153c161
<   void SetMaxAmpduLength (uint32_t maxAmpduLength);
---
>   void SetMaxAmpduLengthExponent (uint8_t exponent);
170c178
<    * Is RX MCS supported.
---
>    * Is transmit MCS supported.
177c185
<    * Is RX MCS supported.
---
>    * Is reeive MCS supported.
183a192,198
>   /*
>    * This information element is a bit special in that it is only
>    * included if the STA is an HE STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    */
> 
185c200
<    * Return the maximum A-MPDU length.
---
>    * Serialize function.
187c202,209
<    * \return the maximum A-MPDU length
---
>    * \param start the information element iterator
>    * \returns true if MCS transmit supported
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Set serialize size function.
>    *
>    * \returns the serialized size
189c211
<   uint32_t GetMaxAmpduLength (void) const;
---
>   uint16_t GetSerializedSize () const;
194,219c216,241
<   uint8_t m_plusHtcHeSupport;                            //!< HTC HE support
<   uint8_t m_twtRequesterSupport;                         //!< TWT requester support
<   uint8_t m_twtResponderSupport;                         //!< TWT responder support
<   uint8_t m_fragmentationSupport;                        //!< fragmentation support
<   uint8_t m_maximumNumberOfFragmentedMsdus;              //!< maximum number of fragmentation MSDUs
<   uint8_t m_minimumFragmentSize;                         //!< minimum fragment size
<   uint8_t m_triggerFrameMacPaddingDuration;              //!< trigger frame MAC padding duration
<   uint8_t m_multiTidAggregationSupport;                  //!< multi-TID aggregation support
<   uint8_t m_heLinkAdaptation;                            //!< HE link adaptation
<   uint8_t m_allAckSupport;                               //!< all Ack support
<   uint8_t m_ulMuResponseSchedulingSupport;               //!< UL MU response scheduling support
<   uint8_t m_aBsrSupport;                                 //!< BSR support
<   uint8_t m_broadcastTwtSupport;                         //!< broadcast TXT support
<   uint8_t m_32bitBaBitmapSupport;                        //!< 32-bit BA bitmap support
<   uint8_t m_muCascadeSupport;                            //!< MU cascade support
<   uint8_t m_ackEnabledMultiTidAggregationSupport;        //!< ack enabled multi-TID aggregation support
<   uint8_t m_groupAddressedMultiStaBlockAckInDlMuSupport; //!< group addressed multi-STA BlockAck in DL support
<   uint8_t m_omControlSupport;                            //!< operation mode control support
<   uint8_t m_ofdmaRaSupport;                              //!< OFDMA RA support
<   uint8_t m_maxAmpduLengthExponent;                      //!< maximum A-MPDU length exponent
<   uint8_t m_amsduFragmentationSupport;                   //!< A-MSDU fragmentation support
<   uint8_t m_flexibleTwtScheduleSupport;                  //!< flexible TWT schedule support
<   uint8_t m_rxControlFrameToMultiBss;                    //!< receive control frame to multi-BSS
<   uint8_t m_bsrpAmpduAggregation;                        //!< BSRP A-MPDU aggregation
<   uint8_t m_qtpSupport;                                  //!< QTP support
<   uint8_t m_aBqrSupport;                                 //!< ABQR support
---
>   uint8_t m_plusHtcHeSupport; //!< HTC HE support
>   uint8_t m_twtRequesterSupport; //!< TWT requester support
>   uint8_t m_twtResponderSupport; //!< TWT responder support
>   uint8_t m_fragmentationSupport; //!< fragmentation support
>   uint8_t m_maximumNumberOfFragmentedMsdus; //!< maximum number of fragmentation MSDUs
>   uint8_t m_minimumFragmentSize; //!< minimum fragment size
>   uint8_t m_triggerFrameMacPaddingDuration; //!< trigger frame MAC padding duration
>   uint8_t m_multiTidAggregationSupport; //!< multi TID aggregation support
>   uint8_t m_heLinkAdaptation; //!< HE link adaptation
>   uint8_t m_allAckSupport; //!< ack support
>   uint8_t m_ulMuResponseSchedulingSupport; //!< UL MU response scheduling support
>   uint8_t m_aBsrSupport; //!< BSR support
>   uint8_t m_broadcastTwtSupport; //!< broadcast TXT support
>   uint8_t m_32bitBaBitmapSupport; //!< 32bit BA bitmap support
>   uint8_t m_muCascadeSupport; //!< MU cascade support
>   uint8_t m_ackEnabledMultiTidAggregationSupport; //!< ack enabled multi TID aggregation support
>   uint8_t m_groupAddressedMultiStaBlockAckInDlMuSupport; //!< group addressed multi STA block ack in DL support
>   uint8_t m_omiAcontrolSupport; //!< OMI A control support
>   uint8_t m_ofdmaRaSupport; //!< OFDM RA support
>   uint8_t m_maximumAmpduLengthExponent; //!< maximum AMPDU length exponenet
>   uint8_t m_amsduFragmentationSupport; //!< AMSDU fragmentation support
>   uint8_t m_flexibleTwtScheduleSupport; //!< flexible TWT schedule support
>   uint8_t m_rxControlFrameToMultiBss; //!< receive control frame to multi bias
>   uint8_t m_bsrpAmpduAggregation; //!< BSRP AMPDU aggregation
>   uint8_t m_qtpSupport; //!< QTP support
>   uint8_t m_aBqrSupport; //!< ABQR support
222,237c244,259
<   uint8_t m_dualBandSupport;                         //!< dual band support
<   uint8_t m_channelWidthSet;                         //!< channel width set
<   uint8_t m_preamblePuncturingRx;                    //!< preamble puncturing receive
<   uint8_t m_deviceClass;                             //!< device class
<   uint8_t m_ldpcCodingInPayload;                     //!< LDPC coding in payload
<   uint8_t m_heLtfAndGiForHePpdus;                    //!< HE-LTF and GI for HE-PPDUs
<   uint8_t m_heLtfAndGiForNdp;                        //!< HE-LTF and GI for NDP
<   uint8_t m_stbcTxAndRx;                             //!< STBC transmit and receive
<   uint8_t m_doppler;                                 //!< Doppler
<   uint8_t m_ulMu;                                    //!< UL MU
<   uint8_t m_dcmEncodingTx;                           //!< DCM encoding transmit
<   uint8_t m_dcmEncodingRx;                           //!< DCM encoding receive
<   uint8_t m_ulHeMuPpduPayloadSupport;                //!< UL HE-MU-PDPU payload support
<   uint8_t m_suBeamformer;                            //!< SU beamformer
<   uint8_t m_suBeamformee;                            //!< SU beamformee
<   uint8_t m_muBeamformer;                            //!< MU beamformer
---
>   uint8_t m_dualBandSupport; //!< dual band support
>   uint8_t m_channelWidthSet; //!< channel width set
>   uint8_t m_preamblePuncturingRx; //!< preamble puncturing receive
>   uint8_t m_deviceClass; //!< device class
>   uint8_t m_ldpcCodingInPayload; //!< LDPC coding in payload
>   uint8_t m_heLtfAndGiForHePpdus; //!< HE LTF and GI for HE PDUs
>   uint8_t m_heLtfAndGiForNdp; //!< HE LTF and GI for NDP
>   uint8_t m_stbcTxAndRx; //!< STBC transmit and receive
>   uint8_t m_doppler; //!< doppler
>   uint8_t m_ulMu; //!< UL MU
>   uint8_t m_dcmEncodingTx; //!< DCM encoding transmit
>   uint8_t m_dcmEncodingRx; //!< DCM encoding receive
>   uint8_t m_ulHeMuPpduPayloadSupport; //!< UL HE MU PDPU payload support
>   uint8_t m_suBeamformer; //!< SU beam former
>   uint8_t m_suBeamformee; //!< SU beam formee
>   uint8_t m_muBeamformer; //!< MU beam former
239,254c261,276
<   uint8_t m_nstsTotalForSmallerOrEqualThan80Mhz;     //!< STS total for < 80 MHz
<   uint8_t m_beamformeeStsForLargerThan80Mhz;         //!< beamformee STS for > 80MHz
<   uint8_t m_nstsTotalForLargerThan80Mhz;             //!< STS total for > 80 MHz
<   uint8_t m_numberOfSoundingDimensionsForSmallerOrEqualThan80Mhz; //!< # of sounding dimensions for < 80 MHz
<   uint8_t m_numberOfSoundingDimensionsForLargerThan80Mhz;         //!< # of sounding dimensions for > 80 MHz
<   uint8_t m_ngEqual16ForSuFeedbackSupport;          //!< equal 16 for SU feedback
<   uint8_t m_ngEqual16ForMuFeedbackSupport;          //!< equal 16 for MU feedback
<   uint8_t m_codebookSize42ForSuSupport;             //!< codebook size 42 for SU
<   uint8_t m_codebookSize75ForSuSupport;             //!< codebook size 75 for SU
<   uint8_t m_beamformingFeedbackWithTriggerFrame;    //!< beamforming feedback with trigger frame
<   uint8_t m_heErSuPpduPayload;                      //!< HE-ER-SU-PPDU payload
<   uint8_t m_dlMuMimoOnPartialBandwidth;             //!< DL MU-MIMO on partial bandwidth
<   uint8_t m_ppeThresholdPresent;                    //!< PPE threshold present
<   uint8_t m_srpBasedSrSupport;                      //!< SRP based SR support
<   uint8_t m_powerBoostFactorAlphaSupport;           //!< power boost factor alpha support
<   uint8_t m_4TimesHeLtfAnd800NsGiSupportForHePpdus; //!< 4 times HE-LFT and 800ns GI support for HE-PPDUs
---
>   uint8_t m_nstsTotalForSmallerOrEqualThan80Mhz; //!< STS total for < 80 MHz
>   uint8_t m_beamformeeStsForLargerThan80Mhz; //!< beam formee STS for > 80MHz
>   uint8_t m_nstsTotalForLargerThan80Mhz; //!< STS total for > 80 MHz
>   uint8_t m_numberOfSoundingDimensionsForSmallerOrEqualThan80Mhz; //!< # of sounding diemnsions for < 80 MHz
>   uint8_t m_numberOfSoundingDimensionsForLargerThan80Mhz; //!< # of sounding dimensions for > 80 MHz
>   uint8_t m_ngEqual16ForSuFeedbackSupport; //!< equal 16 for SU feedback
>   uint8_t m_ngEqual16ForMuFeedbackSupport; //!< equal 16 for MU feedback
>   uint8_t m_codebookSize42ForSuSupport; //!< codebook size 42 for SU
>   uint8_t m_codebookSize75ForSuSupport; //!< codebook size 75 for SU
>   uint8_t m_beamformingFeedbackWithTriggerFrame; //!< beam forming feedback with trigger frame
>   uint8_t m_heErSuPpduPayload; //!< HE ER SU PPDU payload
>   uint8_t m_dlMuMimoOnPartialBandwidth; //!< DL MU MIMO on partial bandwidth
>   uint8_t m_ppeThresholdPresent; //!< PPE threshold present
>   uint8_t m_srpBasedSrSupport; //!< SRP based SR support
>   uint8_t m_powerBoostFactorAlphaSupport; //!< power boost factor alpha support
>   uint8_t m_4TimesHeLtfAnd800NsGiSupportForHePpdus; //!< 4 times HE LFT and 800 HS GI support for HE PPDUs
258,260c280,282
<   uint8_t m_highestMcsSupported;   //!< highest MCS support
<   std::vector<uint8_t> m_txBwMap;  //!< transmit BW map
<   std::vector<uint8_t> m_rxBwMap;  //!< receive BW map
---
>   uint8_t m_highestMcsSupported; //!< highest MCS support
>   std::vector<uint8_t> m_txBwMap; //!< transmit BW map
>   std::vector<uint8_t> m_rxBwMap; //!< receive BW map
266,271d287
< /**
<  * output stream output operator
<  * \param os the output stream
<  * \param HeCapabilities the HE capabilities
<  * \returns the output stream
<  */
Only in ../../NS3-WiGig/src/wifi/model: he-configuration.cc
Only in ../../NS3-WiGig/src/wifi/model: he-configuration.h
diff ../../NS3-WiGig/src/wifi/model/he-operation.cc ../../ns-3-dev-git/src/wifi/model/he-operation.cc
43,49c43
<   return IE_EXTENSION;
< }
< 
< WifiInformationElementId
< HeOperation::ElementIdExt () const
< {
<   return IE_EXT_HE_OPERATION;
---
>   return IE_HE_OPERATION;
53c47
< HeOperation::SetHeSupported (uint8_t heSupported)
---
> HeOperation::SetHeSupported (uint8_t hesupported)
55c49
<   m_heSupported = heSupported;
---
>   m_heSupported = hesupported;
63c57
<   return 7;
---
>   return 10;
100,113c94
<   uint8_t val = 3; //3 means not supported
<   if (maxHeMcs > 9) //MCS 0 - 11
<     {
<       val = 2;
<     }
<   else if (maxHeMcs > 7) //MCS 0 - 9
<     {
<       val = 1;
<     }
<   else if (maxHeMcs == 7) //MCS 0 - 7
<     {
<       val = 0;
<     }
<   m_basicHeMcsAndNssSet |= ((val & 0x03) << ((nss - 1) * 2));
---
>   m_basicHeMcsAndNssSet |= (((maxHeMcs - 7) & 0x07) << ((nss - 1) * 3));
116c97
< uint16_t
---
> uint32_t
122,135d102
< void
< HeOperation::SetBssColor (uint8_t bssColor)
< {
<   NS_ABORT_UNLESS (bssColor < 64); // 6 bits
<   m_bssColor = bssColor;
<   m_bssColorDisabled = 0;
< }
< 
< uint8_t
< HeOperation::GetBssColor (void) const
< {
<   return m_bssColor;
< }
< 
163,164c130,134
<       start.WriteU16 (GetBasicHeMcsAndNssSet ());
<       //todo: VHT Operation Information (variable)
---
>       uint32_t mcsset = GetBasicHeMcsAndNssSet ();
>       start.WriteU16 (mcsset & 0xffff);
>       start.WriteU8 ((mcsset >> 16) & 0xff);
>       start.WriteU16 (0); //todo: VHT Operation Information
>       start.WriteU8 (0); //todo: VHT Operation Information
173c143,146
<   m_basicHeMcsAndNssSet = i.ReadU16 ();
---
>   uint16_t mcsset_1 = i.ReadU16 ();
>   uint8_t mcsset_2 = i.ReadU8 ();
>   i.ReadU16 (); //todo: VHT Operation Information
>   i.ReadU8 (); //todo: VHT Operation Information
175c148,149
<   //todo: VHT Operation Information (variable)
---
>   m_basicHeMcsAndNssSet |= mcsset_1 & 0xffff;
>   m_basicHeMcsAndNssSet |= (mcsset_2 & 0xff) << 16;
178a153,160
> /**
>  * output stream output operator
>  *
>  * \param os output stream
>  * \param HeOperation the HE operation
>  *
>  * \returns output stream
>  */
diff ../../NS3-WiGig/src/wifi/model/he-operation.h ../../ns-3-dev-git/src/wifi/model/he-operation.h
33a34,35
>  *
>  * \see attribute_HeOperation
39,52d40
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   WifiInformationElementId ElementIdExt () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is a HE STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
56c44
<    * \param heSupported the HE supported information element
---
>    * \param hesupported the HE supported information element
58c46
<   void SetHeSupported (uint8_t heSupported);
---
>   void SetHeSupported (uint8_t hesupported);
68c56
<    * by specifying the tuple (<i>nss</i>, <i>maxMcs</i>).
---
>    * by specifying the tuple (nss, maxMcs).
86c74,87
<   uint16_t GetBasicHeMcsAndNssSet (void) const;
---
>   uint32_t GetBasicHeMcsAndNssSet (void) const;
> 
>   /**
>    * Return the element ID.
>    *
>    * \returns the element ID
>    */
>   WifiInformationElementId ElementId () const;
>   /**
>    * Return the information field size.
>    *
>    * \returns the information field size
>    */
>   uint8_t GetInformationFieldSize () const;
88,89c89,91
<    * Set the BSS color
<    * \param bssColor the BSS color value
---
>    * Serialize the information field.
>    *
>    * \param start the information field iterator
91c93
<   void SetBssColor (uint8_t bssColor);
---
>   void SerializeInformationField (Buffer::Iterator start) const;
93,94c95,110
<    * Get the BSS color
<    * \return the BSS color value
---
>    * Deserialize the information field.
>    *
>    * \param start the iterator
>    * \param length the length
>    * \returns the information field size
>    */
>   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
>   /**
>    * This information element is a bit special in that it is only
>    * included if the STA is a HE STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
96c112,118
<   uint8_t GetBssColor (void) const;
---
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this HE Operations IE.
>    *
>    * \return the serialized size of this HE Operations IE
>    */
>   uint16_t GetSerializedSize () const;
101,103c123,125
<   uint8_t m_bssColor;                     //!< BSS color
<   uint8_t m_defaultPEDuration;            //!< default PE duration
<   uint8_t m_twtRequired;                  //!< TWT required
---
>   uint8_t m_bssColor; //!< BSS color
>   uint8_t m_defaultPEDuration; //!< default PE duration
>   uint8_t m_twtRequired; //!< TWT required
105,109c127,131
<   uint8_t m_partialBssColor;              //!< partial BSS color
<   uint8_t m_maxBssidIndicator;            //!< max BSSID indicator
<   uint8_t m_txBssidIndicator;             //!< TX BSSID indicator
<   uint8_t m_bssColorDisabled;             //!< BSS color disabled
<   uint8_t m_dualBeacon;                   //!< Dual Beacon
---
>   uint8_t m_partialBssColor; //!< partial BSS color
>   uint8_t m_maxBssidIndicator; //!< max BSSID indicator
>   uint8_t m_txBssidIndicator; //!< TX BSSID indicator
>   uint8_t m_bssColorDisabled; //!< BSS color disabled
>   uint8_t m_dualBeacon; //!< Dual Beacon
112c134
<   uint16_t m_basicHeMcsAndNssSet; ///< basic HE MCS NSS set
---
>   uint32_t m_basicHeMcsAndNssSet; ///< basic HE MCS NSS set
120,127d141
< /**
<  * output stream output operator
<  *
<  * \param os output stream
<  * \param HeOperation the HE operation
<  *
<  * \returns output stream
<  */
diff ../../NS3-WiGig/src/wifi/model/ht-capabilities.cc ../../ns-3-dev-git/src/wifi/model/ht-capabilities.cc
41c41
<     m_maxAmpduLengthExponent (0),
---
>     m_maxAmpduLength (0),
57c57
<     m_reverseDirectionResponder (0),
---
>     m_reverzeDirectionResponder (0),
102c102
< HtCapabilities::SetHtSupported (uint8_t htSupported)
---
> HtCapabilities::SetHtSupported (uint8_t htsupported)
104c104
<   m_htSupported = htSupported;
---
>   m_htSupported = htsupported;
114c114
< HtCapabilities::SetSupportedChannelWidth (uint8_t supportedChannelWidth)
---
> HtCapabilities::SetSupportedChannelWidth (uint8_t supportedchannelwidth)
116c116
<   m_supportedChannelWidth = supportedChannelWidth;
---
>   m_supportedChannelWidth = supportedchannelwidth;
126c126
< HtCapabilities::SetShortGuardInterval20 (uint8_t shortGuardInterval)
---
> HtCapabilities::SetShortGuardInterval20 (uint8_t shortguardinterval)
128c128
<   m_shortGuardInterval20 = shortGuardInterval;
---
>   m_shortGuardInterval20 = shortguardinterval;
132c132
< HtCapabilities::SetShortGuardInterval40 (uint8_t shortGuardInterval)
---
> HtCapabilities::SetShortGuardInterval40 (uint8_t shortguardinterval)
134c134
<   m_shortGuardInterval40 = shortGuardInterval;
---
>   m_shortGuardInterval40 = shortguardinterval;
138c138
< HtCapabilities::SetMaxAmsduLength (uint16_t maxAmsduLength)
---
> HtCapabilities::SetMaxAmsduLength (uint8_t maxamsdulength)
140,142c140
<   NS_ABORT_MSG_IF (maxAmsduLength != 3839 && maxAmsduLength != 7935,
<                    "Invalid A-MSDU Max Length value");
<   m_maxAmsduLength = (maxAmsduLength == 3839 ? 0 : 1);
---
>   m_maxAmsduLength = maxamsdulength;
146c144
< HtCapabilities::SetLSigProtectionSupport (uint8_t lSigProtection)
---
> HtCapabilities::SetLSigProtectionSupport (uint8_t lsigprotection)
148c146
<   m_lsigProtectionSupport = lSigProtection;
---
>   m_lsigProtectionSupport = lsigprotection;
152c150
< HtCapabilities::SetMaxAmpduLength (uint32_t maxAmpduLength)
---
> HtCapabilities::SetMaxAmpduLength (uint8_t maxampdulength)
154,162c152
<   for (uint8_t i = 0; i <= 3; i++)
<     {
<       if ((1ul << (13 + i)) - 1 == maxAmpduLength)
<         {
<           m_maxAmpduLengthExponent = i;
<           return;
<         }
<     }
<   NS_ABORT_MSG ("Invalid A-MPDU Max Length value");
---
>   m_maxAmpduLength = maxampdulength;
172c162
< HtCapabilities::SetRxHighestSupportedDataRate (uint16_t maxSupportedRate)
---
> HtCapabilities::SetRxHighestSupportedDataRate (uint16_t maxsupportedrate)
174c164
<   m_rxHighestSupportedDataRate = maxSupportedRate;
---
>   m_rxHighestSupportedDataRate = maxsupportedrate;
178c168
< HtCapabilities::SetTxMcsSetDefined (uint8_t txMcsSetDefined)
---
> HtCapabilities::SetTxMcsSetDefined (uint8_t txmcssetdefined)
180c170
<   m_txMcsSetDefined = txMcsSetDefined;
---
>   m_txMcsSetDefined = txmcssetdefined;
184c174
< HtCapabilities::SetTxRxMcsSetUnequal (uint8_t txRxMcsSetUnequal)
---
> HtCapabilities::SetTxRxMcsSetUnequal (uint8_t txrxmcssetunequal)
186c176
<   m_txRxMcsSetUnequal = txRxMcsSetUnequal;
---
>   m_txRxMcsSetUnequal = txrxmcssetunequal;
190c180
< HtCapabilities::SetTxMaxNSpatialStreams (uint8_t maxTxSpatialStreams)
---
> HtCapabilities::SetTxMaxNSpatialStreams (uint8_t maxtxspatialstreams)
192c182
<   m_txMaxNSpatialStreams = maxTxSpatialStreams - 1; //0 for 1 SS, 1 for 2 SSs, etc
---
>   m_txMaxNSpatialStreams = maxtxspatialstreams - 1; //0 for 1 SS, 1 for 2 SSs, etc
196c186
< HtCapabilities::SetTxUnequalModulation (uint8_t txUnequalModulation)
---
> HtCapabilities::SetTxUnequalModulation (uint8_t txunequalmodulation)
198c188
<   m_txUnequalModulation = txUnequalModulation;
---
>   m_txUnequalModulation = txunequalmodulation;
225,240d214
< uint16_t
< HtCapabilities::GetMaxAmsduLength (void) const
< {
<   if (m_maxAmsduLength == 0)
<     {
<       return 3839;
<     }
<   return 7935;
< }
< 
< uint32_t
< HtCapabilities::GetMaxAmpduLength (void) const
< {
<   return (1ul << (13 + m_maxAmpduLengthExponent)) - 1;
< }
< 
270c244
<   //we should not be here if HT is not supported
---
>   //we should not be here if ht is not supported
338c312
<   m_maxAmpduLengthExponent = ctrl & 0x03;
---
>   m_maxAmpduLength = ctrl & 0x03;
347c321
<   val |=  m_maxAmpduLengthExponent & 0x03;
---
>   val |=  m_maxAmpduLength & 0x03;
418c392
<   val |= (m_reverseDirectionResponder & 0x01) << 11;
---
>   val |= (m_reverzeDirectionResponder & 0x01) << 11;
431c405
<   m_reverseDirectionResponder = (ctrl >> 11) & 0x01;
---
>   m_reverzeDirectionResponder = (ctrl >> 11) & 0x01;
551a526,533
> /**
>  * output stream output operator
>  *
>  * \param os output stream
>  * \param htcapabilities the HT capabilities
>  *
>  * \returns output stream
>  */
diff ../../NS3-WiGig/src/wifi/model/ht-capabilities.h ../../ns-3-dev-git/src/wifi/model/ht-capabilities.h
39a40,41
>  *
>  * \see attribute_HtCapabilities
45,58d46
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is an HT STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
62c50
<    * \param htSupported the HT supported field
---
>    * \param htsupported the HT supported field
64c52
<   void SetHtSupported (uint8_t htSupported);
---
>   void SetHtSupported (uint8_t htsupported);
107c95
<    * \param ldpc the LDPC field
---
>    * \param ldpc
113c101
<    * \param supportedChannelWidth the supported channel width field
---
>    * \param supportedchannelwidth
115c103
<   void SetSupportedChannelWidth (uint8_t supportedChannelWidth);
---
>   void SetSupportedChannelWidth (uint8_t supportedchannelwidth);
117c105
<    * Set the Greenfield field.
---
>    * Set the green field.
119c107
<    * \param greenfield the Greenfield field
---
>    * \param greenfield
125c113
<    * \param shortGuardInterval the short guard interval
---
>    * \param shortguardinterval
127c115
<   void SetShortGuardInterval20 (uint8_t shortGuardInterval);
---
>   void SetShortGuardInterval20 (uint8_t shortguardinterval);
131c119
<    * \param shortGuardInterval the short guard interval
---
>    * \param shortguardinterval
133c121
<   void SetShortGuardInterval40 (uint8_t shortGuardInterval);
---
>   void SetShortGuardInterval40 (uint8_t shortguardinterval);
137c125
<    * \param maxAmsduLength Either 3839 or 7935
---
>    * \param maxamsdulength
139c127
<   void SetMaxAmsduLength (uint16_t maxAmsduLength);
---
>   void SetMaxAmsduLength (uint8_t maxamsdulength);
143c131
<    * \param lSigProtection the LSIG protection support field
---
>    * \param lsigprotection
145c133
<   void SetLSigProtectionSupport (uint8_t lSigProtection);
---
>   void SetLSigProtectionSupport (uint8_t lsigprotection);
150c138
<    * \param maxAmpduLength 2^(13 + x) - 1, x in the range 0 to 3
---
>    * \param maxampdulength
152c140
<   void SetMaxAmpduLength (uint32_t maxAmpduLength);
---
>   void SetMaxAmpduLength (uint8_t maxampdulength);
157c145
<    * \param index the index of the receive MCS
---
>    * \param index
163c151
<    * \param maxSupportedRate the maximum supported data rate
---
>    * \param maxsupportedrate
165c153
<   void SetRxHighestSupportedDataRate (uint16_t maxSupportedRate);
---
>   void SetRxHighestSupportedDataRate (uint16_t maxsupportedrate);
169c157
<    * \param txMcsSetDefined the TX MCS set defined
---
>    * \param txmcssetdefined
171c159
<   void SetTxMcsSetDefined (uint8_t txMcsSetDefined);
---
>   void SetTxMcsSetDefined (uint8_t txmcssetdefined);
175c163
<    * \param txRxMcsSetUnequal the TX/RX MCS set unequal field
---
>    * \param txrxmcssetunequal
177c165
<   void SetTxRxMcsSetUnequal (uint8_t txRxMcsSetUnequal);
---
>   void SetTxRxMcsSetUnequal (uint8_t txrxmcssetunequal);
181c169
<    * \param maxTxSpatialStreams the maximum number of TX SSs
---
>    * \param maxtxspatialstreams
183c171
<   void SetTxMaxNSpatialStreams (uint8_t maxTxSpatialStreams);
---
>   void SetTxMaxNSpatialStreams (uint8_t maxtxspatialstreams);
187c175
<    * \param txUnequalModulation the TX unequal modulation field
---
>    * \param txunequalmodulation
189c177
<   void SetTxUnequalModulation (uint8_t txUnequalModulation);
---
>   void SetTxUnequalModulation (uint8_t txunequalmodulation);
247c235
<    * Return the Greenfield field.
---
>    * Return the green field.
249c237
<    * \return the Greenfield field
---
>    * \return the green field
259,270d246
<    * Return the maximum A-MSDU length.
<    *
<    * \return the maximum A-MSDU length
<    */
<   uint16_t GetMaxAmsduLength (void) const;
<   /**
<    * Return the maximum A-MPDU length.
<    *
<    * \return the maximum A-MPDU length
<    */
<   uint32_t GetMaxAmpduLength (void) const;
<   /**
284a261,307
>   /**
>    * Return the element ID.
>    *
>    * \return the element ID
>    */
>   WifiInformationElementId ElementId () const;
>   /**
>    * Return the information field size.
>    *
>    * \return the information field size
>    */
>   uint8_t GetInformationFieldSize () const;
>   /**
>    * Serialize the information field.
>    *
>    * \param start the information field
>    */
>   void SerializeInformationField (Buffer::Iterator start) const;
>   /**
>    * Return the information field.
>    *
>    * \param start field
>    * \param length field length
>    *
>    * \return the information field
>    */
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
>   /**
>    * This information element is a bit special in that it is only
>    * included if the STA is an HT STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this HT capability
>    * information element.
>    *
>    * \return the serialized size of this HT capability information element
>    */
>   uint16_t GetSerializedSize () const;
> 
288c311
<   uint8_t m_ldpc;                  ///< LDPC
---
>   uint8_t m_ldpc; ///< LDPC
290,301c313,324
<   uint8_t m_smPowerSave;           ///< SM power save
<   uint8_t m_greenField;            ///< Greenfield
<   uint8_t m_shortGuardInterval20;  ///< short guard interval 20 MHz
<   uint8_t m_shortGuardInterval40;  ///< short guard interval 40 MHz
<   uint8_t m_txStbc;                ///< transmit STBC
<   uint8_t m_rxStbc;                ///< receive STBC
<   uint8_t m_htDelayedBlockAck;     ///< HT delayed block ack
<   uint8_t m_maxAmsduLength;        ///< maximum A-MSDU length
<   uint8_t m_dssMode40;             ///< DSS mode 40
<   uint8_t m_psmpSupport;           ///< PSMP support
<   uint8_t m_fortyMhzIntolerant;    ///< 40 MHz intolerant
<   uint8_t m_lsigProtectionSupport; ///< L-SIG protection support
---
>   uint8_t m_smPowerSave; ///< SM power save
>   uint8_t m_greenField; ///< green field
>   uint8_t m_shortGuardInterval20; ///< short guard interval 20
>   uint8_t m_shortGuardInterval40; ///< short guard interval 40
>   uint8_t m_txStbc; ///< transmit STBC
>   uint8_t m_rxStbc; ///< receive STBC
>   uint8_t m_htDelayedBlockAck; ///< HT delayed block ack
>   uint8_t m_maxAmsduLength; ///< maximum AMSDU length
>   uint8_t m_dssMode40; ///< DSS mode 40
>   uint8_t m_psmpSupport; ///< PSMP support
>   uint8_t m_fortyMhzIntolerant; ///< 40 Mhz intolerant
>   uint8_t m_lsigProtectionSupport; ///< LSIG protection support
304,306c327,329
<   uint8_t m_maxAmpduLengthExponent; ///< maximum A-MPDU length
<   uint8_t m_minMpduStartSpace;      ///< minimum MPDU start space
<   uint8_t m_ampduReserved;          ///< A-MPDU reserved
---
>   uint8_t m_maxAmpduLength; ///< maximum AMPDU length
>   uint8_t m_minMpduStartSpace; ///< minimum MPDU start space
>   uint8_t m_ampduReserved; ///< AMPDU reserved
309,316c332,339
<   uint8_t m_reservedMcsSet1;                 ///< reserved MCS set 1
<   uint16_t m_rxHighestSupportedDataRate;     ///< receive highest supported data rate
<   uint8_t m_reservedMcsSet2;                 ///< reserved MCS set 2
<   uint8_t m_txMcsSetDefined;                 ///< transmit MCS set defined
<   uint8_t m_txRxMcsSetUnequal;               ///< transmit / receive MCS set unequal
<   uint8_t m_txMaxNSpatialStreams;            ///< transmit maximum number spatial streams
<   uint8_t m_txUnequalModulation;             ///< transmit unequal modulation
<   uint32_t m_reservedMcsSet3;                ///< reserved MCS set 3
---
>   uint8_t m_reservedMcsSet1; ///< reserved MCS set 1
>   uint16_t m_rxHighestSupportedDataRate; ///< receive highest supported data rate
>   uint8_t m_reservedMcsSet2; ///< reserved MCS set 2
>   uint8_t m_txMcsSetDefined; ///< transmit MCS set defined
>   uint8_t m_txRxMcsSetUnequal; ///< transmit / receive MCS set unequal
>   uint8_t m_txMaxNSpatialStreams; ///< transmit maximum number spatial streams
>   uint8_t m_txUnequalModulation; ///< transmit unequal modulation
>   uint32_t m_reservedMcsSet3; ///< reserved MCS set 3
320,325c343,348
<   uint8_t m_pco;                           ///< PCO
<   uint8_t m_pcoTransitionTime;             ///< PCO transition time
<   uint8_t m_reservedExtendedCapabilities;  ///< reserved extended capabilities
<   uint8_t m_mcsFeedback;                   ///< MCS feedback
<   uint8_t m_htcSupport;                    ///< HTC support
<   uint8_t m_reverseDirectionResponder;     ///< reverse direction responder
---
>   uint8_t m_pco; ///< PCO
>   uint8_t m_pcoTransitionTime; ///< PCO trnsition time
>   uint8_t m_reservedExtendedCapabilities; ///< reserved extended capabilities
>   uint8_t m_mcsFeedback; ///< MCS feedback
>   uint8_t m_htcSupport; ///< HTS support
>   uint8_t m_reverzeDirectionResponder; ///< reverse direction responder
329,343c352,366
<   uint8_t m_implicitRxBfCapable;                       ///< implicit receive BF capable
<   uint8_t m_rxStaggeredSoundingCapable;                ///< receive staggered sounding capable
<   uint8_t m_txStaggeredSoundingCapable;                ///< transmit staggered sounding capable
<   uint8_t m_rxNdpCapable;                              ///< receive NDP capable
<   uint8_t m_txNdpCapable;                              ///< transmit NDP capable
<   uint8_t m_implicitTxBfCapable;                       ///< implicit transmit BF capable
<   uint8_t m_calibration;                               ///< calibration
<   uint8_t m_explicitCsiTxBfCapable;                    ///< explicit CSI transmit BF capable
<   uint8_t m_explicitNoncompressedSteeringCapable;      ///< explicit non compressed steeering capable
<   uint8_t m_explicitCompressedSteeringCapable;         ///< explicit compressed steeering capable
<   uint8_t m_explicitTxBfCsiFeedback;                   ///< explicit transmit BF CSI feedback
<   uint8_t m_explicitNoncompressedBfFeedbackCapable;    ///< explicit non compressed BF feedback capable
<   uint8_t m_explicitCompressedBfFeedbackCapable;       ///< explicit compressed BF feedback capable
<   uint8_t m_minimalGrouping;                           ///< minimal grouping
<   uint8_t m_csiNBfAntennasSupported;                   ///< CSI NBF antenna supported
---
>   uint8_t m_implicitRxBfCapable; ///< implicit receive BF capable
>   uint8_t m_rxStaggeredSoundingCapable; ///< receive staggered sounding capable
>   uint8_t m_txStaggeredSoundingCapable; ///< transmit staggered soundign capable
>   uint8_t m_rxNdpCapable; ///< receive NDP capable
>   uint8_t m_txNdpCapable; ///< transmit NDP capable
>   uint8_t m_implicitTxBfCapable; ///< implicit transmit BF capable
>   uint8_t m_calibration; ///< calibration
>   uint8_t m_explicitCsiTxBfCapable; ///< explicit CSI transmit BF capable
>   uint8_t m_explicitNoncompressedSteeringCapable; ///< explicit non compressed steeering capable
>   uint8_t m_explicitCompressedSteeringCapable; ///< explicit compressed steeering capable
>   uint8_t m_explicitTxBfCsiFeedback; ///< explicit transmit BF CSI feedback
>   uint8_t m_explicitNoncompressedBfFeedbackCapable; ///< eplicit non complressed BF feedback capable
>   uint8_t m_explicitCompressedBfFeedbackCapable; ///< explicit compressed BF feedback capable
>   uint8_t m_minimalGrouping; ///< minimal grouping
>   uint8_t m_csiNBfAntennasSupported; ///< CSI NBF antenna supported
345,348c368,371
<   uint8_t m_compressedSteeringNBfAntennasSupported;    ///< compressed steering NBF antenna supported
<   uint8_t m_csiMaxNRowsBfSupported;                    ///< CSI maximum number rows BF supported
<   uint8_t m_channelEstimationCapability;               ///< channel estimation capability
<   uint8_t m_reservedTxBf;                              ///< reserved  transmit BF
---
>   uint8_t m_compressedSteeringNBfAntennasSupported; ///< compressed steering NBF antenna supported
>   uint8_t m_csiMaxNRowsBfSupported; ///< CSI maximum number rows BF supported
>   uint8_t m_channelEstimationCapability; ///< channel estimation capability
>   uint8_t m_reservedTxBf; ///< reserved  transmit BF
351,358c374,381
<   uint8_t m_antennaSelectionCapability;               ///< antenna selection capability
<   uint8_t m_explicitCsiFeedbackBasedTxASelCapable;    ///< explicit CSI feedback based transmit antenna selection capable
<   uint8_t m_antennaIndicesFeedbackBasedTxASelCapable; ///< antenna indices feedback based transmit antenna selection capable
<   uint8_t m_explicitCsiFeedbackCapable;               ///< explicit CSI feedback capable
<   uint8_t m_antennaIndicesFeedbackCapable;            ///< antenna indices feedback capable
<   uint8_t m_rxASelCapable;                            ///< receive antenna selection capable
<   uint8_t m_txSoundingPpdusCapable;                   ///< sounding PPDUS capable
<   uint8_t m_reservedASel;                             ///< reserved ASEL
---
>   uint8_t m_antennaSelectionCapability; ///< antenna selection capability
>   uint8_t m_explicitCsiFeedbackBasedTxASelCapable; ///< explicit CSI feedback based transmit a sel capable
>   uint8_t m_antennaIndicesFeedbackBasedTxASelCapable; ///< antenna indices feedback absed transmit a sel capable
>   uint8_t m_explicitCsiFeedbackCapable; ///< explicit CSI feedback capable
>   uint8_t m_antennaIndicesFeedbackCapable; ///< antenna indices feedback capable
>   uint8_t m_rxASelCapable; ///< receive a sel capable
>   uint8_t m_txSoundingPpdusCapable; ///< sounding PPDUS capable
>   uint8_t m_reservedASel; ///< reserved a sel
364,371d386
< /**
<  * output stream output operator
<  *
<  * \param os output stream
<  * \param htcapabilities the HT capabilities
<  *
<  * \returns output stream
<  */
Only in ../../NS3-WiGig/src/wifi/model: ht-configuration.cc
Only in ../../NS3-WiGig/src/wifi/model: ht-configuration.h
diff ../../NS3-WiGig/src/wifi/model/ht-operation.cc ../../ns-3-dev-git/src/wifi/model/ht-operation.cc
67c67
< HtOperation::SetHtSupported (uint8_t htSupported)
---
> HtOperation::SetHtSupported (uint8_t htsupported)
69c69
<   m_htSupported = htSupported;
---
>   m_htSupported = htsupported;
75c75
<   //we should not be here if HT is not supported
---
>   //we should not be here if ht is not supported
87c87
< HtOperation::SetSecondaryChannelOffset (uint8_t secondaryChannelOffset)
---
> HtOperation::SetSecondaryChannelOffset (uint8_t secondarychanneloffset)
89c89
<   m_secondaryChannelOffset = secondaryChannelOffset;
---
>   m_secondaryChannelOffset = secondarychanneloffset;
93c93
< HtOperation::SetStaChannelWidth (uint8_t staChannelWidth)
---
> HtOperation::SetStaChannelWidth (uint8_t stachannelwidth)
95c95
<   m_staChannelWidth = staChannelWidth;
---
>   m_staChannelWidth = stachannelwidth;
99c99
< HtOperation::SetRifsMode (uint8_t rifsMode)
---
> HtOperation::SetRifsMode (uint8_t rifsmode)
101c101
<   m_rifsMode = rifsMode;
---
>   m_rifsMode = rifsmode;
105c105
< HtOperation::SetHtProtection (uint8_t htProtection)
---
> HtOperation::SetHtProtection (uint8_t htprotection)
107c107
<   m_htProtection = htProtection;
---
>   m_htProtection = htprotection;
111c111
< HtOperation::SetNonGfHtStasPresent (uint8_t nonGfHtStasPresent)
---
> HtOperation::SetNonGfHtStasPresent (uint8_t nongfhtstaspresent)
113c113
<   m_nonGfHtStasPresent = nonGfHtStasPresent;
---
>   m_nonGfHtStasPresent = nongfhtstaspresent;
117c117
< HtOperation::SetObssNonHtStasPresent (uint8_t obssNonHtStasPresent)
---
> HtOperation::SetObssNonHtStasPresent (uint8_t obssnonhtstaspresent)
119c119
<   m_obssNonHtStasPresent = obssNonHtStasPresent;
---
>   m_obssNonHtStasPresent = obssnonhtstaspresent;
123c123
< HtOperation::SetDualBeacon (uint8_t dualBeacon)
---
> HtOperation::SetDualBeacon (uint8_t dualbeacon)
125c125
<   m_dualBeacon = dualBeacon;
---
>   m_dualBeacon = dualbeacon;
129c129
< HtOperation::SetDualCtsProtection (uint8_t dualCtsProtection)
---
> HtOperation::SetDualCtsProtection (uint8_t dualctsprotection)
131c131
<   m_dualCtsProtection = dualCtsProtection;
---
>   m_dualCtsProtection = dualctsprotection;
135c135
< HtOperation::SetStbcBeacon (uint8_t stbcBeacon)
---
> HtOperation::SetStbcBeacon (uint8_t stbcbeacon)
137c137
<   m_stbcBeacon = stbcBeacon;
---
>   m_stbcBeacon = stbcbeacon;
141c141
< HtOperation::SetLSigTxopProtectionFullSupport (uint8_t lSigTxopProtectionFullSupport)
---
> HtOperation::SetLSigTxopProtectionFullSupport (uint8_t lsigtxopprotectionfullsupport)
143c143
<   m_lSigTxopProtectionFullSupport = lSigTxopProtectionFullSupport;
---
>   m_lSigTxopProtectionFullSupport = lsigtxopprotectionfullsupport;
147c147
< HtOperation::SetPcoActive (uint8_t pcoActive)
---
> HtOperation::SetPcoActive (uint8_t pcoactive)
149c149
<   m_pcoActive = pcoActive;
---
>   m_pcoActive = pcoactive;
153c153
< HtOperation::SetPhase (uint8_t pcoPhase)
---
> HtOperation::SetPhase (uint8_t pcophase)
155c155
<   m_pcoPhase = pcoPhase;
---
>   m_pcoPhase = pcophase;
165c165
< HtOperation::SetRxHighestSupportedDataRate (uint16_t maxSupportedRate)
---
> HtOperation::SetRxHighestSupportedDataRate (uint16_t maxsupportedrate)
167c167
<   m_rxHighestSupportedDataRate = maxSupportedRate;
---
>   m_rxHighestSupportedDataRate = maxsupportedrate;
171c171
< HtOperation::SetTxMcsSetDefined (uint8_t txMcsSetDefined)
---
> HtOperation::SetTxMcsSetDefined (uint8_t txmcssetdefined)
173c173
<   m_txMcsSetDefined = txMcsSetDefined;
---
>   m_txMcsSetDefined = txmcssetdefined;
177c177
< HtOperation::SetTxRxMcsSetUnequal (uint8_t txRxMcsSetUnequal)
---
> HtOperation::SetTxRxMcsSetUnequal (uint8_t txrxmcssetunequal)
179c179
<   m_txRxMcsSetUnequal = txRxMcsSetUnequal;
---
>   m_txRxMcsSetUnequal = txrxmcssetunequal;
183c183
< HtOperation::SetTxMaxNSpatialStreams (uint8_t maxTxSpatialStreams)
---
> HtOperation::SetTxMaxNSpatialStreams (uint8_t maxtxspatialstreams)
185c185
<   m_txMaxNSpatialStreams = maxTxSpatialStreams - 1; //0 for 1 SS, 1 for 2 SSs, etc
---
>   m_txMaxNSpatialStreams = maxtxspatialstreams - 1; //0 for 1 SS, 1 for 2 SSs, etc
189c189
< HtOperation::SetTxUnequalModulation (uint8_t txUnequalModulation)
---
> HtOperation::SetTxUnequalModulation (uint8_t txunequalmodulation)
191c191
<   m_txUnequalModulation = txUnequalModulation;
---
>   m_txUnequalModulation = txunequalmodulation;
491a492,499
> /**
>  * output stream output operator
>  *
>  * \param os output stream
>  * \param htOperation the HT operation
>  *
>  * \returns output stream
>  */
diff ../../NS3-WiGig/src/wifi/model/ht-operation.h ../../ns-3-dev-git/src/wifi/model/ht-operation.h
48a49,50
>  *
>  * \see attribute_HtOperation
54,67d55
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is an HT STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
71c59
<    * \param htSupported the HT Supported flag
---
>    * \param htsupported the HT Supported flag
73c61
<   void SetHtSupported (uint8_t htSupported);
---
>   void SetHtSupported (uint8_t htsupported);
110c98
<    * \param secondaryChannelOffset the secondary channel offset
---
>    * \param secondarychanneloffset the secondary channel offset
112c100
<   void SetSecondaryChannelOffset (uint8_t secondaryChannelOffset);
---
>   void SetSecondaryChannelOffset (uint8_t secondarychanneloffset);
116c104
<    * \param staChannelWidth the STA channel width
---
>    * \param stachannelwidth the STA channel width
118c106
<   void SetStaChannelWidth (uint8_t staChannelWidth);
---
>   void SetStaChannelWidth (uint8_t stachannelwidth);
122c110
<    * \param rifsMode the RIFS mode
---
>    * \param rifsmode the RIFS mode
124c112
<   void SetRifsMode (uint8_t rifsMode);
---
>   void SetRifsMode (uint8_t rifsmode);
129c117
<    * \param htProtection the HT protection
---
>    * \param htprotection the HT protection
131c119
<   void SetHtProtection (uint8_t htProtection);
---
>   void SetHtProtection (uint8_t htprotection);
135c123
<    * \param nonGfHtStasPresent the non GF HT STAs present
---
>    * \param nongfhtstaspresent the non GF HT STAs present
137c125
<   void SetNonGfHtStasPresent (uint8_t nonGfHtStasPresent);
---
>   void SetNonGfHtStasPresent (uint8_t nongfhtstaspresent);
141c129
<    * \param obssNonHtStasPresent the OBSS non HTA STAs present
---
>    * \param obssnonhtstaspresent the OBSS non HTA STAs present
143c131
<   void SetObssNonHtStasPresent (uint8_t obssNonHtStasPresent);
---
>   void SetObssNonHtStasPresent (uint8_t obssnonhtstaspresent);
148c136
<    * \param dualBeacon the dual beacon
---
>    * \param dualbeacon the dual beacon
150c138
<   void SetDualBeacon (uint8_t dualBeacon);
---
>   void SetDualBeacon (uint8_t dualbeacon);
154c142
<    * \param dualCtsProtection the dual CTS protection
---
>    * \param dualctsprotection the dual CTS protection
156c144
<   void SetDualCtsProtection (uint8_t dualCtsProtection);
---
>   void SetDualCtsProtection (uint8_t dualctsprotection);
160c148
<    * \param stbcBeacon the STBC beacon
---
>    * \param stbcbeacon the STBC beacon
162c150
<   void SetStbcBeacon (uint8_t stbcBeacon);
---
>   void SetStbcBeacon (uint8_t stbcbeacon);
166c154
<    * \param lSigTxopProtectionFullSupport the LSIG TXOP protection full support
---
>    * \param lsigtxopprotectionfullsupport the LSIG TXOP protection full support
168c156
<   void SetLSigTxopProtectionFullSupport (uint8_t lSigTxopProtectionFullSupport);
---
>   void SetLSigTxopProtectionFullSupport (uint8_t lsigtxopprotectionfullsupport);
172c160
<    * \param pcoActive the PCO active
---
>    * \param pcoactive the PCO active
174c162
<   void SetPcoActive (uint8_t pcoActive);
---
>   void SetPcoActive (uint8_t pcoactive);
178c166
<    * \param pcoPhase the PCO phase
---
>    * \param pcophase the PCO phase
180c168
<   void SetPhase (uint8_t pcoPhase);
---
>   void SetPhase (uint8_t pcophase);
191c179
<    * \param maxSupportedRate the maximum supported data rate
---
>    * \param maxsupportedrate the maximum supported data rate
193c181
<   void SetRxHighestSupportedDataRate (uint16_t maxSupportedRate);
---
>   void SetRxHighestSupportedDataRate (uint16_t maxsupportedrate);
197c185
<    * \param txMcsSetDefined the transmit MCS set defined
---
>    * \param txmcssetdefined the transmit MCS set defined
199c187
<   void SetTxMcsSetDefined (uint8_t txMcsSetDefined);
---
>   void SetTxMcsSetDefined (uint8_t txmcssetdefined);
203c191
<    * \param txRxMcsSetUnequal the transmit / receive MCS set unequal
---
>    * \param txrxmcssetunequal the transmit / reeive MCS set unequal
205c193
<   void SetTxRxMcsSetUnequal (uint8_t txRxMcsSetUnequal);
---
>   void SetTxRxMcsSetUnequal (uint8_t txrxmcssetunequal);
209c197
<    * \param maxTxSpatialStreams the maximum transmit spatial streams
---
>    * \param maxtxspatialstreams the maximum transmit spatial streams
211c199
<   void SetTxMaxNSpatialStreams (uint8_t maxTxSpatialStreams);
---
>   void SetTxMaxNSpatialStreams (uint8_t maxtxspatialstreams);
215c203
<    * \param txUnequalModulation the transmit unequal modulation
---
>    * \param txunequalmodulation the transmit unequal modulation
217c205
<   void SetTxUnequalModulation (uint8_t txUnequalModulation);
---
>   void SetTxUnequalModulation (uint8_t txunequalmodulation);
369a358,402
>   /**
>    * Return element ID.
>    *
>    * \return element ID
>    */
>   WifiInformationElementId ElementId () const;
>   /**
>    * Return information field size.
>    *
>    * \return information field size
>    */
>   uint8_t GetInformationFieldSize () const;
>   /**
>    * Serialize information field.
>    *
>    * \param start iterator
>    */
>   void SerializeInformationField (Buffer::Iterator start) const;
>   /**
>    * DeSerialize information field.
>    *
>    * \param start iterator
>    * \param length length
>    * \returns information field
>    */
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
>   /**
>    * This information element is a bit special in that it is only
>    * included if the STA is an HT STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this HT Operation IE.
>    *
>    * \return the serialized size of this HT Operation IE
>    */
>   uint16_t GetSerializedSize () const;
> 
375,377c408,410
<   uint8_t m_secondaryChannelOffset;     ///< secondary channel offset
<   uint8_t m_staChannelWidth;            ///< STA channel width
<   uint8_t m_rifsMode;                   ///< RIFS mode
---
>   uint8_t m_secondaryChannelOffset; ///< secondary channel offset
>   uint8_t m_staChannelWidth; ///< STA channel width
>   uint8_t m_rifsMode; ///< RIFS mode
381,382c414,415
<   uint8_t m_htProtection;                 ///< HT protection
<   uint8_t m_nonGfHtStasPresent;           ///< non GF HT STAs present
---
>   uint8_t m_htProtection; ///< HT protection
>   uint8_t m_nonGfHtStasPresent; ///< non GF HT STAs present
384c417
<   uint8_t m_obssNonHtStasPresent;         ///< OBSS NON HT STAs present
---
>   uint8_t m_obssNonHtStasPresent; ///< OBSS NON HT STAs present
388,395c421,428
<   uint8_t m_reservedInformationSubset3_1;  ///< reserved information subset 3-1
<   uint8_t m_dualBeacon;                    ///< dual beacon
<   uint8_t m_dualCtsProtection;             ///< dual CTS protection
<   uint8_t m_stbcBeacon;                    ///< STBC beacon
<   uint8_t m_lSigTxopProtectionFullSupport; ///< L-SIG TXOP protection full support
<   uint8_t m_pcoActive;                     ///< PCO active
<   uint8_t m_pcoPhase;                      ///< PCO phase
<   uint8_t m_reservedInformationSubset3_2;  ///< reserved information subset 3-2
---
>   uint8_t m_reservedInformationSubset3_1; ///< reserved information subset 3-1
>   uint8_t m_dualBeacon; ///< dual beacon
>   uint8_t m_dualCtsProtection; ///< dual CTS protection
>   uint8_t m_stbcBeacon; ///< STBC beacon
>   uint8_t m_lSigTxopProtectionFullSupport; ///< LSIG TXOP protection full support
>   uint8_t m_pcoActive; ///< PCO active
>   uint8_t m_pcoPhase; ///< PCO phase
>   uint8_t m_reservedInformationSubset3_2; ///< reserved information subset 3-2
398,405c431,438
<   uint8_t m_reservedMcsSet1;                 ///< reserved MCS set 1
<   uint16_t m_rxHighestSupportedDataRate;     ///< receive highest supported data rate
<   uint8_t m_reservedMcsSet2;                 ///< reserved MCS set2
<   uint8_t m_txMcsSetDefined;                 ///< transmit MCS set defined
<   uint8_t m_txRxMcsSetUnequal;               ///< transmit / receive MCS set unequal
<   uint8_t m_txMaxNSpatialStreams;            ///< transmit maximum number spatial streams
<   uint8_t m_txUnequalModulation;             ///< transmit unequal modulation
<   uint32_t m_reservedMcsSet3;                ///< reserved MCS set 3
---
>   uint8_t m_reservedMcsSet1; ///< reserved MCS set 1
>   uint16_t m_rxHighestSupportedDataRate; ///< receive highest supported data rate
>   uint8_t m_reservedMcsSet2; ///< reserved MCS set2
>   uint8_t m_txMcsSetDefined; ///< transmit MCS set defined
>   uint8_t m_txRxMcsSetUnequal; ///< transmit / receive MCS set unequal
>   uint8_t m_txMaxNSpatialStreams; ///< transmit maximum number spatial streams
>   uint8_t m_txUnequalModulation; ///< transmit unequal modulation
>   uint32_t m_reservedMcsSet3; ///< reserved MCS set 3
412,419d444
< /**
<  * output stream output operator
<  *
<  * \param os output stream
<  * \param htOperation the HT operation
<  *
<  * \returns output stream
<  */
Only in ../../NS3-WiGig/src/wifi/model: ideal-dmg-wifi-manager.cc
Only in ../../NS3-WiGig/src/wifi/model: ideal-dmg-wifi-manager.h
diff ../../NS3-WiGig/src/wifi/model/ideal-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/ideal-wifi-manager.cc
21d20
< #include <algorithm>
25d23
< #include <algorithm>
37,43c35,38
<   double m_lastSnrObserved;            //!< SNR of most recently reported packet sent to the remote station
<   uint16_t m_lastChannelWidthObserved; //!< Channel width (in MHz) of most recently reported packet sent to the remote station
<   uint16_t m_lastNssObserved;          //!<  Number of spatial streams of most recently reported packet sent to the remote station
<   double m_lastSnrCached;              //!< SNR most recently used to select a rate
<   uint8_t m_lastNss;                   //!< Number of spatial streams most recently used to the remote station
<   WifiMode m_lastMode;                 //!< Mode most recently used to the remote station
<   uint16_t m_lastChannelWidth;         //!< Channel width (in MHz) most recently used to the remote station
---
>   double m_lastSnrObserved;  //!< SNR of most recently reported packet sent to the remote station
>   double m_lastSnrCached;    //!< SNR most recently used to select a rate
>   uint8_t m_nss;             //!< Number of spacial streams
>   WifiMode m_lastMode;       //!< Mode most recently used to the remote station
92c87
< IdealWifiManager::GetChannelWidthForNonHtMode (WifiMode mode) const
---
> IdealWifiManager::GetChannelWidthForMode (WifiMode mode) const
112,118d106
<   BuildSnrThresholds ();
< }
< 
< void
< IdealWifiManager::BuildSnrThresholds (void)
< {
<   m_thresholds.clear ();
126c114
<       txVector.SetChannelWidth (GetChannelWidthForNonHtMode (mode));
---
>       txVector.SetChannelWidth (GetChannelWidthForMode (mode));
129c117
<       NS_LOG_DEBUG ("Adding mode = " << mode.GetUniqueName ());
---
>       NS_LOG_DEBUG ("Initialize, adding mode = " << mode.GetUniqueName ());
132,133c120,121
<   // Add all MCSes
<   if (GetHtSupported ())
---
>   // Add all Ht and Vht MCSes
>   if (HasVhtSupported () == true || HasHtSupported () == true || HasHeSupported () == true)
144c132
<                   uint16_t guardInterval = GetShortGuardIntervalSupported () ? 400 : 800;
---
>                   uint16_t guardInterval = GetPhy ()->GetShortGuardInterval () ? 400 : 800;
148c136
<                   NS_LOG_DEBUG ("Adding mode = " << mode.GetUniqueName () <<
---
>                   NS_LOG_DEBUG ("Initialize, adding mode = " << mode.GetUniqueName () <<
151a140
>                   NS_LOG_DEBUG ("In SetupPhy, adding mode = " << mode.GetUniqueName ());
161c150
<                       guardInterval = GetShortGuardIntervalSupported () ? 400 : 800;
---
>                       guardInterval = GetPhy ()->GetShortGuardInterval () ? 400 : 800;
165c154
<                       guardInterval = GetGuardInterval ();
---
>                       guardInterval = static_cast<uint16_t> (GetPhy ()->GetGuardInterval ().GetNanoSeconds ());
170,183c159,166
<                       if (mode.IsAllowed (j, k))
<                         {
<                           NS_LOG_DEBUG ("Adding mode = " << mode.GetUniqueName () <<
<                                         " channel width " << j <<
<                                         " nss " << +k <<
<                                         " GI " << guardInterval);
<                           txVector.SetNss (k);
<                           txVector.SetMode (mode);
<                           AddSnrThreshold (txVector, GetPhy ()->CalculateSnr (txVector, m_ber));
<                         }
<                       else
<                         {
<                           NS_LOG_DEBUG ("Mode = " << mode.GetUniqueName () << " disallowed");
<                         }
---
>                       NS_LOG_DEBUG ("Initialize, adding mode = " << mode.GetUniqueName () <<
>                                     " channel width " << j <<
>                                     " nss " << +k <<
>                                     " GI " << guardInterval);
>                       NS_LOG_DEBUG ("In SetupPhy, adding mode = " << mode.GetUniqueName ());
>                       txVector.SetNss (k);
>                       txVector.SetMode (mode);
>                       AddSnrThreshold (txVector, GetPhy ()->CalculateSnr (txVector, m_ber));
192c175
< IdealWifiManager::GetSnrThreshold (WifiTxVector txVector)
---
> IdealWifiManager::GetSnrThreshold (WifiTxVector txVector) const
194,211c177,196
<   NS_LOG_FUNCTION (this << txVector);
<   auto it = std::find_if (m_thresholds.begin (), m_thresholds.end (),
<       [&txVector] (const std::pair<double, WifiTxVector>& p) -> bool {
<           return ((txVector.GetMode () == p.second.GetMode ()) && (txVector.GetNss () == p.second.GetNss ()) && (txVector.GetChannelWidth () == p.second.GetChannelWidth ()));
<       }
<   );
<   if (it == m_thresholds.end ())
<     {
<       //This means capabilities have changed in runtime, hence rebuild SNR thresholds
<       BuildSnrThresholds ();
<       it = std::find_if (m_thresholds.begin (), m_thresholds.end (),
<           [&txVector] (const std::pair<double, WifiTxVector>& p) -> bool {
<               return ((txVector.GetMode () == p.second.GetMode ()) && (txVector.GetNss () == p.second.GetNss ()) && (txVector.GetChannelWidth () == p.second.GetChannelWidth ()));
<           }
<       );
<       NS_ASSERT_MSG (it != m_thresholds.end (), "SNR threshold not found");
<   }
<   return it->first;
---
>   NS_LOG_FUNCTION (this << txVector.GetMode ().GetUniqueName ());
>   for (Thresholds::const_iterator i = m_thresholds.begin (); i != m_thresholds.end (); i++)
>     {
>       NS_LOG_DEBUG ("Checking " << i->second.GetMode ().GetUniqueName () <<
>                     " nss " << +i->second.GetNss () <<
>                     " GI " << i->second.GetGuardInterval () <<
>                     " width " << i->second.GetChannelWidth ());
>       NS_LOG_DEBUG ("against TxVector " << txVector.GetMode ().GetUniqueName () <<
>                     " nss " << +txVector.GetNss () <<
>                     " GI " << txVector.GetGuardInterval () <<
>                     " width " << txVector.GetChannelWidth ());
>       if (txVector.GetMode () == i->second.GetMode ()
>           && txVector.GetNss () == i->second.GetNss ()
>           && txVector.GetChannelWidth () == i->second.GetChannelWidth ())
>         {
>           return i->first;
>         }
>     }
>   NS_ASSERT (false);
>   return 0.0;
217c202
<   NS_LOG_FUNCTION (this << txVector.GetMode ().GetUniqueName () << txVector.GetChannelWidth () << snr);
---
>   NS_LOG_FUNCTION (this << txVector.GetMode ().GetUniqueName () << snr);
226c211,214
<   Reset (station);
---
>   station->m_lastSnrObserved = 0.0;
>   station->m_lastSnrCached = CACHE_INITIAL_VALUE;
>   station->m_lastMode = GetDefaultMode ();
>   station->m_nss = 1;
230,242d217
< void
< IdealWifiManager::Reset (WifiRemoteStation *station) const
< {
<   NS_LOG_FUNCTION (this << station);
<   IdealWifiRemoteStation *st = static_cast<IdealWifiRemoteStation*> (station);
<   st->m_lastSnrObserved = 0.0;
<   st->m_lastChannelWidthObserved = 0;
<   st->m_lastNssObserved = 1;
<   st->m_lastSnrCached = CACHE_INITIAL_VALUE;
<   st->m_lastMode = GetDefaultMode ();
<   st->m_lastChannelWidth = 0;
<   st->m_lastNss = 1;
< }
267c242
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
269,270d243
<   station->m_lastChannelWidthObserved = GetPhy ()->GetChannelWidth () >= 40 ? 20 : GetPhy ()->GetChannelWidth ();
<   station->m_lastNssObserved = 1;
274,275c247,248
< IdealWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                   double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> IdealWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                   double ackSnr, WifiMode ackMode, double dataSnr)
277,278c250,251
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode.GetUniqueName () << dataSnr << dataChannelWidth << +dataNss);
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode.GetUniqueName () << dataSnr);
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
285,286d257
<   station->m_lastChannelWidthObserved = dataChannelWidth;
<   station->m_lastNssObserved = dataNss;
290,291c261
< IdealWifiManager::DoReportAmpduTxStatus (WifiRemoteStation *st, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                                          double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> IdealWifiManager::DoReportAmpduTxStatus (WifiRemoteStation *st, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus, double rxSnr, double dataSnr)
293,294c263,264
<   NS_LOG_FUNCTION (this << st << +nSuccessfulMpdus << +nFailedMpdus << rxSnr << dataSnr << dataChannelWidth << +dataNss);
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << +nSuccessfulMpdus << +nFailedMpdus << rxSnr << dataSnr);
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
301,302d270
<   station->m_lastChannelWidthObserved = dataChannelWidth;
<   station->m_lastNssObserved = dataNss;
304a273
> 
309c278,279
<   Reset (station);
---
>   IdealWifiRemoteStation *st = (IdealWifiRemoteStation *)station;
>   st->m_lastSnrObserved = 0.0;
316c286,287
<   Reset (station);
---
>   IdealWifiRemoteStation *st = (IdealWifiRemoteStation *)station;
>   st->m_lastSnrObserved = 0.0;
323c294
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
325c296
<   //highest data rate for which the SNR threshold is smaller than m_lastSnr
---
>   //highest data rate for which the snr threshold is smaller than m_lastSnr
335c306
<   if ((station->m_lastSnrCached != CACHE_INITIAL_VALUE) && (station->m_lastSnrObserved == station->m_lastSnrCached) && (channelWidth == station->m_lastChannelWidth))
---
>   if (station->m_lastSnrCached != CACHE_INITIAL_VALUE && station->m_lastSnrObserved == station->m_lastSnrCached)
337c308,309
<       // SNR has not changed, so skip the search and use the last mode selected
---
>       // SNR has not changed, so skip the search and use the last
>       // mode selected
339c311
<       selectedNss = station->m_lastNss;
---
>       selectedNss = station->m_nss;
343d314
<                     " channel width " << station->m_lastChannelWidth <<
348c319,320
<       if (GetHtSupported () && GetHtSupported (st))
---
>       if ((HasVhtSupported () == true || HasHtSupported () == true || HasHeSupported () == true)
>           && (GetHtSupported (st) == true || GetVhtSupported (st) == true || GetHeSupported (st) == true))
356c328
<                   guardInterval = static_cast<uint16_t> (std::max (GetShortGuardIntervalSupported (station) ? 400 : 800, GetShortGuardIntervalSupported () ? 400 : 800));
---
>                   guardInterval = static_cast<uint16_t> (std::max (GetShortGuardInterval (station) ? 400 : 800, GetPhy ()->GetShortGuardInterval () ? 400 : 800));
359c331
<                   if (GetVhtSupported () && GetVhtSupported (station))
---
>                   if (HasVhtSupported () && GetVhtSupported (station))
364c336
<                   if (GetHeSupported () && GetHeSupported (station))
---
>                   if (HasHeSupported () && GetHeSupported (station))
386,387c358
<                   double snr = GetLastObservedSnr (station, channelWidth, nss);
<                   if (dataRate > bestRate && threshold < snr)
---
>                   if (dataRate > bestRate && threshold < station->m_lastSnrObserved)
392,393c363,364
<                                     " channel width " << channelWidth <<
<                                     " snr " << snr);
---
>                                     " last snr observed " <<
>                                     station->m_lastSnrObserved);
401c372
<                   guardInterval = static_cast<uint16_t> (std::max (GetShortGuardIntervalSupported (station) ? 400 : 800, GetShortGuardIntervalSupported () ? 400 : 800));
---
>                   guardInterval = static_cast<uint16_t> (std::max (GetShortGuardInterval (station) ? 400 : 800, GetPhy ()->GetShortGuardInterval () ? 400 : 800));
404c375
<                   if (GetHeSupported () && GetHeSupported (station))
---
>                   if (HasHeSupported () && GetHeSupported (station))
409c380
<                   if (!GetVhtSupported () || !GetVhtSupported (station))
---
>                   if (!HasVhtSupported () || !GetVhtSupported (station))
430,431c401
<                       double snr = GetLastObservedSnr (station, channelWidth, nss);
<                       if (dataRate > bestRate && threshold < snr)
---
>                       if (dataRate > bestRate && threshold < station->m_lastSnrObserved)
435,436c405,407
<                                         " channel width " << channelWidth <<
<                                         " snr " << snr);
---
>                                         " threshold " << threshold  <<
>                                         " last snr observed " <<
>                                         station->m_lastSnrObserved);
445c416
<                   guardInterval = std::max (GetGuardInterval (station), GetGuardInterval ());
---
>                   guardInterval = std::max (GetGuardInterval (station), static_cast<uint16_t> (GetPhy ()->GetGuardInterval ().GetNanoSeconds ()));
448c419
<                   if (!GetHeSupported () || !GetHeSupported (station))
---
>                   if (!HasHeSupported () || !GetHeSupported (station))
452c423
<                   for (uint8_t nss = 1; nss <= std::min (GetMaxNumberOfTransmitStreams (), GetNumberOfSupportedStreams (station)); nss++)
---
>                   for (uint8_t nss = 1; nss <= GetNumberOfSupportedStreams (station); nss++)
469,470c440
<                       double snr = GetLastObservedSnr (station, channelWidth, nss);
<                       if (dataRate > bestRate && threshold < snr)
---
>                       if (dataRate > bestRate && threshold < station->m_lastSnrObserved)
475,476c445,446
<                                         " channel width " << channelWidth <<
<                                         " snr " << snr);
---
>                                         " last snr observed " <<
>                                         station->m_lastSnrObserved);
494,495c464
<               uint16_t channelWidth = GetChannelWidthForNonHtMode (mode);
<               txVector.SetChannelWidth (channelWidth);
---
>               txVector.SetChannelWidth (GetChannelWidthForMode (mode));
502,503c471
<               double snr = GetLastObservedSnr (station, channelWidth, 1);
<               if (dataRate > bestRate && threshold < snr)
---
>               if (dataRate > bestRate && threshold < station->m_lastSnrObserved)
508c476,477
<                                 " snr " << snr);
---
>                                 " last snr observed " <<
>                                 station->m_lastSnrObserved);
517c486
<       station->m_lastNss = selectedNss;
---
>       station->m_nss = selectedNss;
519,520c488
<   NS_LOG_DEBUG ("Found maxMode: " << maxMode << " channelWidth: " << channelWidth << " nss: " << +selectedNss);
<   station->m_lastChannelWidth = channelWidth;
---
>   NS_LOG_DEBUG ("Found maxMode: " << maxMode << " channelWidth: " << channelWidth);
523,527c491
<       guardInterval = std::max (GetGuardInterval (station), GetGuardInterval ());
<     }
<   else if ((maxMode.GetModulationClass () == WIFI_MOD_CLASS_HT) || (maxMode.GetModulationClass () == WIFI_MOD_CLASS_VHT))
<     {
<       guardInterval = static_cast<uint16_t> (std::max (GetShortGuardIntervalSupported (station) ? 400 : 800, GetShortGuardIntervalSupported () ? 400 : 800));
---
>       guardInterval = std::max (GetGuardInterval (station), static_cast<uint16_t> (GetPhy ()->GetGuardInterval ().GetNanoSeconds ()));
531c495
<       guardInterval = 800;
---
>       guardInterval = static_cast<uint16_t> (std::max (GetShortGuardInterval (station) ? 400 : 800, GetPhy ()->GetShortGuardInterval () ? 400 : 800));
538c502
<   return WifiTxVector (maxMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (maxMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), guardInterval, GetNumberOfAntennas (), selectedNss, 0, GetChannelWidthForTransmission (maxMode, channelWidth), GetAggregation (station), false);
---
>   return WifiTxVector (maxMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (maxMode, GetAddress (station)), guardInterval, GetNumberOfAntennas (), selectedNss, 0, GetChannelWidthForTransmission (maxMode, channelWidth), GetAggregation (station), false);
545c509
<   IdealWifiRemoteStation *station = static_cast<IdealWifiRemoteStation*> (st);
---
>   IdealWifiRemoteStation *station = (IdealWifiRemoteStation *)st;
547c511
<   //SNR threshold possible which is smaller than m_lastSnr to
---
>   //snr threshold possible which is smaller than m_lastSnr to
554c518,519
<   //RTS is sent in a non-HT frame
---
>   //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac/ax
>   //RTS is sent in a legacy frame; RTS with HT/VHT/HE is not yet supported
560c525
<       txVector.SetChannelWidth (GetChannelWidthForNonHtMode (mode));
---
>       txVector.SetChannelWidth (GetChannelWidthForMode (mode));
568c533
<   return WifiTxVector (maxMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (maxMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, GetNumberOfAntennas (), nss, 0, GetChannelWidthForNonHtMode (maxMode), GetAggregation (station), false);
---
>   return WifiTxVector (maxMode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (maxMode, GetAddress (station)), 800, GetNumberOfAntennas (), nss, 0, GetChannelWidthForMode (maxMode), GetAggregation (station), false);
571,572c536,537
< double
< IdealWifiManager::GetLastObservedSnr (IdealWifiRemoteStation *station, uint16_t channelWidth, uint8_t nss) const
---
> bool
> IdealWifiManager::IsLowLatency (void) const
574,589c539
<   double snr = station->m_lastSnrObserved;
<   if (channelWidth != station->m_lastChannelWidthObserved)
<     {
<       snr /= (static_cast<double> (channelWidth) / station->m_lastChannelWidthObserved);
<     }
<   if (nss != station->m_lastNssObserved)
<     {
<       snr /= (static_cast<double> (nss) / station->m_lastNssObserved);
<     }
<   NS_LOG_DEBUG ("Last observed SNR is " << station->m_lastSnrObserved <<
<                 " for channel width " << station->m_lastChannelWidthObserved <<
<                 " and nss " << +station->m_lastNssObserved <<
<                 "; computed SNR is " << snr <<
<                 " for channel width " << channelWidth <<
<                 " and nss " << +nss);
<   return snr;
---
>   return true;
diff ../../NS3-WiGig/src/wifi/model/ideal-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/ideal-wifi-manager.h
29,30d28
< struct IdealWifiRemoteStation;
< 
39c37
<  * SNR of every packet received and sends back this SNR to the
---
>  * snr of every packet received and sends back this snr to the
41c39
<  * transmitter keeps track of the last SNR sent back by a receiver
---
>  * transmitter keeps track of the last snr sent back by a receiver
43,44c41,42
<  * of SNR thresholds built from a target BER and transmission
<  * mode-specific SNR/BER curves.
---
>  * of snr thresholds built from a target ber and transmission
>  * mode-specific snr/ber curves.
70,73c68,72
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
<   void DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                               double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
>   void DoReportAmpduTxStatus (WifiRemoteStation *station,
>                               uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
>                               double rxSnr, double dataSnr);
78,89c77
< 
<   /**
<    * Reset the station, invoked if the maximum amount of retries has failed.
<    */
<   void Reset (WifiRemoteStation *station) const;
< 
<   /**
<    * Construct the vector of minimum SNRs needed to successfully transmit for
<    * all possible combinations (rate, channel width, nss) based on PHY capabilities.
<    * This is called at initialization and if PHY capabilities changed.
<    */
<   void BuildSnrThresholds (void);
---
>   bool IsLowLatency (void) const;
95c83
<    * \param txVector WifiTxVector (containing valid mode, width, and Nss)
---
>    * \param txVector WifiTxVector (containing valid mode, width, and nss)
97c85
<    * \return the minimum SNR for the given WifiTxVector in linear scale
---
>    * \return the minimum SNR for the given WifiTxVector
99c87
<   double GetSnrThreshold (WifiTxVector txVector);
---
>   double GetSnrThreshold (WifiTxVector txVector) const;
104,105c92,93
<    * \param txVector the WifiTxVector storing mode, channel width, and Nss
<    * \param snr the minimum SNR for the given txVector in linear scale
---
>    * \param txVector the WifiTxVector storing mode, channel width, and nss
>    * \param snr the minimum SNR for the given txVector
110,111c98,99
<    * Convenience function for selecting a channel width for non-HT mode
<    * \param mode non-HT WifiMode
---
>    * Convenience function for selecting a channel width for legacy mode
>    * \param mode legacy WifiMode
114,126c102
<   uint16_t GetChannelWidthForNonHtMode (WifiMode mode) const;
< 
<   /**
<    * Convenience function to get the last observed SNR from a given station for a given channel width and a given NSS.
<    * Since the previously received SNR information might be related to a different channel width than the requested one,
<    * and/or a different NSS,  the function does some computations to get the corresponding SNR.
<    *
<    * \param station the station being queried
<    * \param channelWidth the channel width (in MHz)
<    * \param nss the number of spatial streams
<    * \return the SNR in linear scale
<    */
<   double GetLastObservedSnr (IdealWifiRemoteStation *station, uint16_t channelWidth, uint8_t nss) const;
---
>   uint16_t GetChannelWidthForMode (WifiMode mode) const;
diff ../../NS3-WiGig/src/wifi/model/infrastructure-wifi-mac.h ../../ns-3-dev-git/src/wifi/model/infrastructure-wifi-mac.h
49c49
<    * The packet should be enqueued in a TX queue, and should be
---
>    * The packet should be enqueued in a tx queue, and should be
53c53
<   virtual void Enqueue (Ptr<Packet> packet, Mac48Address to) = 0;
---
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to) = 0;
diff ../../NS3-WiGig/src/wifi/model/interference-helper.cc ../../ns-3-dev-git/src/wifi/model/interference-helper.cc
21a22
> #include "ns3/packet.h"
24d24
< #include "ns3/packet.h"
28,32d27
< #include "wifi-utils.h"
< #include "wifi-ppdu.h"
< #include "wifi-psdu.h"
< #include <algorithm>
< 
39c34
<  *       PHY event class
---
>  *       Phy event class
42,51c37,38
< Event::Event (WifiTxVector txVector, Time duration, double rxPower)
<   : m_txVector (txVector),
<     m_startTime (Simulator::Now ()),
<     m_endTime (m_startTime + duration),
<     m_rxPowerW (rxPower)
< {
< }
< 
< Event::Event (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower)
<   : m_ppdu (ppdu),
---
> Event::Event (Ptr<const Packet> packet, WifiTxVector txVector, Time duration, double rxPower)
>   : m_packet (packet),
59,68d45
< Event::Event (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower, std::vector<double> mimoRxPower)
<   : m_ppdu (ppdu),
<     m_txVector (txVector),
<     m_startTime (Simulator::Now ()),
<     m_endTime (m_startTime + duration),
<     m_rxPowerW (rxPower),
<     m_mimoRxPowerW (mimoRxPower)
< {
< }
< 
73,74c50,51
< Ptr<const WifiPsdu>
< Event::GetPsdu (void) const
---
> Ptr<const Packet>
> Event::GetPacket (void) const
76,82c53
<   return m_ppdu->GetPsdu ();
< }
< 
< Ptr<const WifiPpdu>
< Event::GetPpdu (void) const
< {
<   return m_ppdu;
---
>   return m_packet;
97,102d67
< Time
< Event::GetDuration (void) const
< {
<   return m_endTime - m_startTime;
< }
< 
121,193d85
< std::vector<double>
< Event::GetMimoRxPowerW (void) const
< {
<   return m_mimoRxPowerW;
< }
< 
< std::vector<double>
< Event::GetMimoInterStreamInterference (void) const
< {
<   uint8_t numTxAntennas = m_txVector.GetNumberOfTxChains ();
<   uint8_t numRxAntennas = m_mimoRxPowerW.size ()/numTxAntennas;
<   double interference;
<   std::vector<double> interferenceList;
<   uint8_t index = 0;
<   for (uint8_t tx = 0; tx < numTxAntennas; tx++)
<     {
<       for (uint8_t rx = 0; rx < numRxAntennas; rx++)
<         {
<           interference = 0;
<           for (uint8_t txInterferer = 0; txInterferer < numTxAntennas; txInterferer++)
<             {
<               if (txInterferer != tx)
<                 {
<                   interference += m_mimoRxPowerW.at (rx + txInterferer * numRxAntennas);
<                 }
<             }
<           index++;
<           interferenceList.push_back (interference);
<         }
<     }
<   return interferenceList;
< }
< 
< std::vector<uint8_t>
< Event::GetMimoRxSignalLocation (void) const
< {
<   uint8_t numTxAntennas = m_txVector.GetNumberOfTxChains ();
<   uint8_t numRxAntennas = m_mimoRxPowerW.size ()/numTxAntennas;
<   std::vector<uint8_t> rxLocationList;
<   for (uint8_t rx = 0; rx < numRxAntennas; rx++)
<     {
<       double maxRxPower = m_mimoRxPowerW.at (rx);
<       uint8_t maxTxIdx = 0;
<       for (uint8_t tx = 0; tx < numTxAntennas; tx++)
<         {
<           /* Find the Tx signal at each Rx antenna that is received with the maximum Rx power under the constraint
<            * that it has already not been received by a previous antenna */
<           if ((std::find (rxLocationList.begin (), rxLocationList.end (), tx) == rxLocationList.end ())
<               && (m_mimoRxPowerW.at (rx + tx * numRxAntennas) > maxRxPower))
<             {
<               maxRxPower = m_mimoRxPowerW.at (rx + tx * numRxAntennas);
<               maxTxIdx = tx;
<             }
<         }
<       rxLocationList.push_back (maxTxIdx);
<     }
<   /* Find the location of the Rx power in m_mimoRxPowerW that is associated with the signal we try to decode at each antenna */
<   for (uint8_t rx = 0; rx < numRxAntennas; rx++)
<     {
<       uint8_t txIdx = rxLocationList.at (rx);
<       rxLocationList[rx] = rx + txIdx * numRxAntennas;
<     }
<   return rxLocationList;
< }
< 
< std::ostream & operator << (std::ostream &os, const Event &event)
< {
<   os << "start=" << event.GetStartTime () << ", end=" << event.GetEndTime ()
<      << ", TXVECTOR=" << event.GetTxVector ()
<      << ", power=" << event.GetRxPowerW () << "W"
<      << ", PPDU=" << event.GetPpdu ();
<   return os;
< }
245,250d136
< void
< InterferenceHelper::SetWifiPhy (Ptr<WifiPhy> wifiPhy)
< {
<   m_wifiPhy = wifiPhy;
< }
< 
252c138
< InterferenceHelper::Add (WifiTxVector txVector, Time duration, double rxPowerW)
---
> InterferenceHelper::Add (Ptr<const Packet> packet, WifiTxVector txVector, Time duration, double rxPowerW)
254,270c140
<   Ptr<Event> event = Create<Event> (txVector, duration, rxPowerW);
<   AppendEvent (event);
<   return event;
< }
< 
< Ptr<Event>
< InterferenceHelper::Add (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPowerW)
< {
<   Ptr<Event> event = Create<Event> (ppdu, txVector, duration, rxPowerW);
<   AppendEvent (event);
<   return event;
< }
< 
< Ptr<Event>
< InterferenceHelper::Add (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPowerW, std::vector<double> mimoRxPower)
< {
<   Ptr<Event> event = Create<Event> (ppdu, txVector, duration, rxPowerW, mimoRxPower);
---
>   Ptr<Event> event = Create<Event> (packet, txVector, duration, rxPowerW);
280,284c150,152
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_QOSDATA);
<   Ptr<WifiPpdu> fakePpdu = Create<WifiPpdu> (Create<WifiPsdu> (Create<Packet> (0), hdr),
<                                              WifiTxVector (), duration, 0);
<   Add (fakePpdu, WifiTxVector (), duration, rxPowerW);
---
>   WifiTxVector fakeTxVector;
>   Ptr<const Packet> packet (0);
>   Add (packet, fakeTxVector, duration, rxPowerW);
299,304d166
< double
< InterferenceHelper::GetNoiseFigure (void) const
< {
<   return m_noiseFigure;
< }
< 
360c222
< InterferenceHelper::CalculateSnr (double signal, double noiseInterference, WifiTxVector txVector) const
---
> InterferenceHelper::CalculateSnr (double signal, double noiseInterference, uint16_t channelWidth) const
364d225
<   uint16_t channelWidth = txVector.GetChannelWidth ();
371,378c232
<   NS_LOG_DEBUG ("bandwidth(MHz)=" << channelWidth << ", signal(W)= " << signal << ", noise(W)=" << noiseFloor << ", interference(W)=" << noiseInterference << ", snr=" << RatioToDb(snr) << "dB");
<   double gain = 1;
<   if (m_numRxAntennas > txVector.GetNss ())
<     {
<       gain = static_cast<double>(m_numRxAntennas) / txVector.GetNss (); //compute gain offered by diversity for AWGN
<     }
<   NS_LOG_DEBUG ("SNR improvement thanks to diversity: " << 10 * std::log10 (gain) << "dB");
<   snr *= gain;
---
>   NS_LOG_DEBUG ("bandwidth(MHz)=" << channelWidth << ", signal(W)= " << signal << ", noise(W)=" << noiseFloor << ", interference(W)=" << noiseInterference << ", snr(linear)=" << snr);
382,400d235
< std::vector<double>
< InterferenceHelper::CalculateSnr (std::vector<double> signalList, double noiseInterference, WifiTxVector txVector) const
< {
<   //thermal noise at 290K in J/s = W
<   static const double BOLTZMANN = 1.3803e-23;
<   uint16_t channelWidth = txVector.GetChannelWidth ();
<   //Nt is the power of thermal noise in W
<   double Nt = BOLTZMANN * 290 * channelWidth * 1e6;
<   //receiver noise Floor (W) which accounts for thermal noise and non-idealities of the receiver
<   double noiseFloor = m_noiseFigure * Nt;
<   double noise = noiseFloor + noiseInterference;
<   std::vector<double> snrValues;
<   for (const auto& signal: signalList)
<     {
<       snrValues.push_back (signal / noise); //linear scale
<     }
<   return snrValues;
< }
< 
404c239
<   double noiseInterferenceW = m_firstPower;
---
>   double noiseInterference = m_firstPower;
406c241
<   for (; it != m_niChanges.end () && it->first < Simulator::Now (); ++it)
---
>   for (; it != m_niChanges.end () && it->second.GetEvent () != event; ++it)
408,415c243
<       //// WIGIG ////
<       if (it->second.GetEvent ()->GetEndTime () == event->GetStartTime ())
<         {
<           /* This is to handle IEEE 802.11ad AGC and TRN Subfields */
<           continue;
<         }
<       //// WIGIG ////
<       noiseInterferenceW = it->second.GetPower () - event->GetRxPowerW ();
---
>       noiseInterference = it->second.GetPower ();
417,418d244
<   it = m_niChanges.find (event->GetStartTime ());
<   for (; it != m_niChanges.end () && it->second.GetEvent () != event; ++it);
425,426c251
<   NS_ASSERT_MSG (noiseInterferenceW >= 0, "CalculateNoiseInterferenceW returns negative value " << noiseInterferenceW);
<   return noiseInterferenceW;
---
>   return noiseInterference;
436c261
<   uint64_t rate = mode.GetDataRate (txVector.GetChannelWidth ());
---
>   uint64_t rate = mode.GetPhyRate (txVector);
438,445c263
<   double csr = m_errorRateModel->GetChunkSuccessRate (mode, txVector, snir, nbits);
<   return csr;
< }
< 
< double
< InterferenceHelper::CalculatePayloadChunkSuccessRate (double snir, Time duration, WifiTxVector txVector) const
< {
<   if (duration.IsZero ())
---
>   if (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT || txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT || txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
447c265,270
<       return 1.0;
---
>       nbits /= txVector.GetNss (); //divide effective number of bits by NSS to achieve same chunk error rate as SISO for AWGN
>       double gain = (txVector.GetNTx () * m_numRxAntennas); //compute gain offered by MIMO, SIMO or MISO compared to SISO for AWGN
>       NS_LOG_DEBUG ("TX=" << +txVector.GetNTx () <<
>                     ", RX=" << +m_numRxAntennas <<
>                     ", SNIR improvement=+" << 10 * std::log10 (gain) << "dB");
>       snir *= gain;
449,452d271
<   WifiMode mode = txVector.GetMode ();
<   uint64_t rate = mode.GetDataRate (txVector);
<   uint64_t nbits = static_cast<uint64_t> (rate * duration.GetSeconds ());
<   nbits /= txVector.GetNss (); //divide effective number of bits by NSS to achieve same chunk error rate as SISO for AWGN
458,509c277
< InterferenceHelper::CalculatePayloadPer (Ptr<const Event> event, NiChanges *ni, std::pair<Time, Time> window) const
< {
<   NS_LOG_FUNCTION (this << window.first << window.second);
<   const WifiTxVector txVector = event->GetTxVector ();
<   double psr = 1.0; /* Packet Success Rate */
<   auto j = ni->begin ();
<   Time previous = j->first;
<   WifiMode payloadMode = event->GetTxVector ().GetMode ();
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   Time phyHeaderStart = j->first + WifiPhy::GetPhyPreambleDuration (txVector); //PPDU start time + preamble
<   Time phyLSigHeaderEnd = phyHeaderStart + WifiPhy::GetPhyHeaderDuration (txVector); //PPDU start time + preamble + L-SIG
<   Time phyTrainingSymbolsStart = phyLSigHeaderEnd + WifiPhy::GetPhyHtSigHeaderDuration (preamble) + WifiPhy::GetPhySigA1Duration (preamble) + WifiPhy::GetPhySigA2Duration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A
<   Time phyPayloadStart = phyTrainingSymbolsStart + WifiPhy::GetPhyTrainingSymbolDuration (txVector) + WifiPhy::GetPhySigBDuration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A + Training + SIG-B
<   Time windowStart = phyPayloadStart + window.first;
<   Time windowEnd = phyPayloadStart + window.second;
<   double noiseInterferenceW = m_firstPower;
<   double powerW = event->GetRxPowerW ();
<   while (++j != ni->end ())
<     {
<       Time current = j->first;
<       NS_LOG_DEBUG ("previous= " << previous << ", current=" << current);
<       NS_ASSERT (current >= previous);
<       /* Get a vector of per stream SNRs (in the case of SISO there is only value in it) and calculate the chunk success rate per stream */
<       std::vector<double> snrPerStream = CalculatePerStreamSnr (event, noiseInterferenceW);
<       //Case 1: Both previous and current point to the windowed payload
<       if (previous >= windowStart)
<         {
<           for (auto snr:snrPerStream)
<             psr *= CalculatePayloadChunkSuccessRate (snr, Min (windowEnd, current) - previous, txVector);
<           NS_LOG_DEBUG ("Both previous and current point to the windowed payload: mode=" << payloadMode << ", psr=" << psr);
<         }
<       //Case 2: previous is before windowed payload and current is in the windowed payload
<       else if (current >= windowStart)
<         {
<           for (auto snr:snrPerStream)
<             psr *= CalculatePayloadChunkSuccessRate (snr, Min (windowEnd, current) - windowStart, txVector);
<           NS_LOG_DEBUG ("previous is before windowed payload and current is in the windowed payload: mode=" << payloadMode << ", psr=" << psr);
<         }
<       noiseInterferenceW = j->second.GetPower () - powerW;
<       previous = j->first;
<       if (previous > windowEnd)
<         {
<           NS_LOG_DEBUG ("Stop: new previous=" << previous << " after time window end=" << windowEnd);
<           break;
<         }
<     }
<   double per = 1 - psr;
<   return per;
< }
< 
< double
< InterferenceHelper::CalculateNonHtPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const
---
> InterferenceHelper::CalculatePlcpPayloadPer (Ptr<const Event> event, NiChanges *ni) const
515a284
>   WifiMode payloadMode = event->GetPayloadMode ();
517,521c286,289
<   WifiMode headerMode = WifiPhy::GetPhyHeaderMode (txVector);
<   Time phyHeaderStart = j->first + WifiPhy::GetPhyPreambleDuration (txVector); //PPDU start time + preamble
<   Time phyLSigHeaderEnd = phyHeaderStart + WifiPhy::GetPhyHeaderDuration (txVector); //PPDU start time + preamble + L-SIG
<   Time phyTrainingSymbolsStart = phyLSigHeaderEnd + WifiPhy::GetPhyHtSigHeaderDuration (preamble) + WifiPhy::GetPhySigA1Duration (preamble) + WifiPhy::GetPhySigA2Duration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A
<   Time phyPayloadStart = phyTrainingSymbolsStart + WifiPhy::GetPhyTrainingSymbolDuration (txVector) + WifiPhy::GetPhySigBDuration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A + Training + SIG-B
---
>   Time plcpHeaderStart = j->first + WifiPhy::GetPlcpPreambleDuration (txVector); //packet start time + preamble
>   Time plcpHsigHeaderStart = plcpHeaderStart + WifiPhy::GetPlcpHeaderDuration (txVector); //packet start time + preamble + L-SIG
>   Time plcpTrainingSymbolsStart = plcpHsigHeaderStart + WifiPhy::GetPlcpHtSigHeaderDuration (preamble) + WifiPhy::GetPlcpSigA1Duration (preamble) + WifiPhy::GetPlcpSigA2Duration (preamble); //packet start time + preamble + L-SIG + HT-SIG or SIG-A
>   Time plcpPayloadStart = plcpTrainingSymbolsStart + WifiPhy::GetPlcpTrainingSymbolDuration (txVector) + WifiPhy::GetPlcpSigBDuration (preamble); //packet start time + preamble + L-SIG + HT-SIG or SIG-A + Training + SIG-B
529,582c297,298
<       double snr = CalculateSnr (powerW, noiseInterferenceW, txVector);
<       //Case 1: previous and current after payload start
<       if (previous >= phyPayloadStart)
<         {
<           psr *= 1;
<           NS_LOG_DEBUG ("Case 1 - previous and current after payload start: nothing to do");
<         }
<       //Case 2: previous is in training or in SIG-B: non-HT will not enter here since it didn't enter in the last two and they are all the same for non-HT
<       else if (previous >= phyTrainingSymbolsStart)
<         {
<           NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<           psr *= 1;
<           NS_LOG_DEBUG ("Case 2 - previous is in training or in SIG-B: nothing to do");
<         }
<       //Case 3: previous is in HT-SIG or SIG-A: non-HT will not enter here since it didn't enter in the last two and they are all the same for non-HT
<       else if (previous >= phyLSigHeaderEnd)
<         {
<           NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<           psr *= 1;
<           NS_LOG_DEBUG ("Case 3cii - previous is in HT-SIG or SIG-A: nothing to do");
<         }
<       //Case 4: previous in L-SIG: HT GF will not reach here because it will execute the previous if and exit
<       else if (previous >= phyHeaderStart)
<         {
<           NS_ASSERT (preamble != WIFI_PREAMBLE_HT_GF);
<           //Case 4a: current after payload start
<           if (current >= phyPayloadStart)
<             {
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 4a - previous in L-SIG and current after payload start: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 4b: current is in training or in SIG-B. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyTrainingSymbolsStart)
<             {
<               NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 4a - previous in L-SIG and current is in training or in SIG-B: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 4c: current in HT-SIG or in SIG-A. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyLSigHeaderEnd)
<             {
<               NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 4ci - previous is in L-SIG and current in HT-SIG or in SIG-A: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 4d: current with previous in L-SIG
<           else
<             {
<               psr *= CalculateChunkSuccessRate (snr, current - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 4d - current with previous in L-SIG: mode=" << headerMode << ", psr=" << psr);
<             }
<         }
<       //Case 5: previous is in the preamble works for all cases
<       else
---
>       //Case 1: Both previous and current point to the payload
>       if (previous >= plcpPayloadStart)
584,610c300,315
<           //Case 5a: current after payload start
<           if (current >= phyPayloadStart)
<             {
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 5aii - previous is in the preamble and current is after payload start: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 5b: current is in training or in SIG-B. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyTrainingSymbolsStart)
<             {
<               NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 5b - previous is in the preamble and current is in training or in SIG-B: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 5c: current in HT-SIG or in SIG-A. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyLSigHeaderEnd)
<             {
<               NS_ASSERT ((preamble != WIFI_PREAMBLE_LONG) && (preamble != WIFI_PREAMBLE_SHORT));
<               psr *= CalculateChunkSuccessRate (snr, phyLSigHeaderEnd - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 5b - previous is in the preamble and current in HT-SIG or in SIG-A: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 5d: current is in L-SIG.
<           else if (current >= phyHeaderStart)
<             {
<               NS_ASSERT (preamble != WIFI_PREAMBLE_HT_GF);
<               psr *= CalculateChunkSuccessRate (snr, current - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 5d - previous is in the preamble and current is in L-SIG: mode=" << headerMode << ", psr=" << psr);
<             }
---
>           psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                           noiseInterferenceW,
>                                                           txVector.GetChannelWidth ()),
>                                             current - previous,
>                                             payloadMode, txVector);
>           NS_LOG_DEBUG ("Both previous and current point to the payload: mode=" << payloadMode << ", psr=" << psr);
>         }
>       //Case 2: previous is before payload and current is in the payload
>       else if (current >= plcpPayloadStart)
>         {
>           psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                           noiseInterferenceW,
>                                                           txVector.GetChannelWidth ()),
>                                             current - plcpPayloadStart,
>                                             payloadMode, txVector);
>           NS_LOG_DEBUG ("previous is before payload and current is in the payload: mode=" << payloadMode << ", psr=" << psr);
612d316
< 
616d319
< 
622c325
< InterferenceHelper::CalculateHtPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const
---
> InterferenceHelper::CalculatePlcpHeaderPer (Ptr<const Event> event, NiChanges *ni) const
633,634c336,337
<       //mode for PHY header fields sent with HT modulation
<       mcsHeaderMode = WifiPhy::GetHtPhyHeaderMode ();
---
>       //mode for PLCP header fields sent with HT modulation
>       mcsHeaderMode = WifiPhy::GetHtPlcpHeaderMode ();
636c339
<   else if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_VHT_MU)
---
>   else if (preamble == WIFI_PREAMBLE_VHT)
638,639c341,342
<       //mode for PHY header fields sent with VHT modulation
<       mcsHeaderMode = WifiPhy::GetVhtPhyHeaderMode ();
---
>       //mode for PLCP header fields sent with VHT modulation
>       mcsHeaderMode = WifiPhy::GetVhtPlcpHeaderMode ();
641c344
<   else if (preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_HE_MU)
---
>   else if (preamble == WIFI_PREAMBLE_HE_SU)
643,644c346,347
<       //mode for PHY header fields sent with HE modulation
<       mcsHeaderMode = WifiPhy::GetHePhyHeaderMode ();
---
>       //mode for PLCP header fields sent with HE modulation
>       mcsHeaderMode = WifiPhy::GetHePlcpHeaderMode ();
646,650c349,353
<   WifiMode headerMode = WifiPhy::GetPhyHeaderMode (txVector);
<   Time phyHeaderStart = j->first + WifiPhy::GetPhyPreambleDuration (txVector); //PPDU start time + preamble
<   Time phyLSigHeaderEnd = phyHeaderStart + WifiPhy::GetPhyHeaderDuration (txVector); //PPDU start time + preamble + L-SIG
<   Time phyTrainingSymbolsStart = phyLSigHeaderEnd + WifiPhy::GetPhyHtSigHeaderDuration (preamble) + WifiPhy::GetPhySigA1Duration (preamble) + WifiPhy::GetPhySigA2Duration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A
<   Time phyPayloadStart = phyTrainingSymbolsStart + WifiPhy::GetPhyTrainingSymbolDuration (txVector) + WifiPhy::GetPhySigBDuration (preamble); //PPDU start time + preamble + L-SIG + HT-SIG or SIG-A + Training + SIG-B
---
>   WifiMode headerMode = WifiPhy::GetPlcpHeaderMode (txVector);
>   Time plcpHeaderStart = j->first + WifiPhy::GetPlcpPreambleDuration (txVector); //packet start time + preamble
>   Time plcpHsigHeaderStart = plcpHeaderStart + WifiPhy::GetPlcpHeaderDuration (txVector); //packet start time + preamble + L-SIG
>   Time plcpTrainingSymbolsStart = plcpHsigHeaderStart + WifiPhy::GetPlcpHtSigHeaderDuration (preamble) + WifiPhy::GetPlcpSigA1Duration (preamble) + WifiPhy::GetPlcpSigA2Duration (preamble); //packet start time + preamble + L-SIG + HT-SIG or SIG-A
>   Time plcpPayloadStart = plcpTrainingSymbolsStart + WifiPhy::GetPlcpTrainingSymbolDuration (txVector) + WifiPhy::GetPlcpSigBDuration (preamble); //packet start time + preamble + L-SIG + HT-SIG or SIG-A + Training + SIG-B
658,660c361,362
<       double snr = CalculateSnr (powerW, noiseInterferenceW, txVector);
<       //Case 1: previous and current after payload start: nothing to do
<       if (previous >= phyPayloadStart)
---
>       //Case 1: previous and current after playload start: nothing to do
>       if (previous >= plcpPayloadStart)
663c365
<           NS_LOG_DEBUG ("Case 1 - previous and current after payload start: nothing to do");
---
>           NS_LOG_DEBUG ("Case 1 - previous and current after playload start: nothing to do");
665,666c367,368
<       //Case 2: previous is in training or in SIG-B: non-HT will not enter here since it didn't enter in the last two and they are all the same for non-HT
<       else if (previous >= phyTrainingSymbolsStart)
---
>       //Case 2: previous is in training or in SIG-B: legacy will not enter here since it didn't enter in the last two and they are all the same for legacy
>       else if (previous >= plcpTrainingSymbolsStart)
670c372
<           if (current >= phyPayloadStart)
---
>           if (current >= plcpPayloadStart)
672c374,378
<               psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - previous, mcsHeaderMode, txVector);
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               txVector.GetChannelWidth ()),
>                                                 plcpPayloadStart - previous,
>                                                 mcsHeaderMode, txVector);
678c384,388
<               psr *= CalculateChunkSuccessRate (snr, current - previous, mcsHeaderMode, txVector);
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               txVector.GetChannelWidth ()),
>                                                 current - previous,
>                                                 mcsHeaderMode, txVector);
682,683c392,393
<       //Case 3: previous is in HT-SIG or SIG-A: non-HT will not enter here since it didn't enter in the last two and they are all the same for non-HT
<       else if (previous >= phyLSigHeaderEnd)
---
>       //Case 3: previous is in HT-SIG or SIG-A: legacy will not enter here since it didn't enter in the last two and they are all the same for legacy
>       else if (previous >= plcpHsigHeaderStart)
687c397
<           if (current >= phyPayloadStart)
---
>           if (current >= plcpPayloadStart)
689c399,403
<               psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               txVector.GetChannelWidth ()),
>                                                 plcpPayloadStart - plcpTrainingSymbolsStart,
>                                                 mcsHeaderMode, txVector);
691c405
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               if (preamble == WIFI_PREAMBLE_VHT || preamble == WIFI_PREAMBLE_HE_SU)
693,695c407,413
<                   //SIG-A is sent using non-HT OFDM modulation
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - previous, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 3ai - previous is in SIG-A and current after payload start: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   //SIG-A is sent using legacy OFDM modulation
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpTrainingSymbolsStart - previous,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 3ai - previous is in SIG-A and current after payload start: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
700c418,422
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - previous, mcsHeaderMode, txVector);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpTrainingSymbolsStart - previous,
>                                                     mcsHeaderMode, txVector);
705c427
<           else if (current >= phyTrainingSymbolsStart)
---
>           else if (current >= plcpTrainingSymbolsStart)
707c429,433
<               psr *= CalculateChunkSuccessRate (snr, current - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               txVector.GetChannelWidth ()),
>                                                 current - plcpTrainingSymbolsStart,
>                                                 mcsHeaderMode, txVector);
709c435
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               if (preamble == WIFI_PREAMBLE_VHT || preamble == WIFI_PREAMBLE_HE_SU)
711,712c437,442
<                   //SIG-A is sent using non-HT OFDM modulation
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - previous, headerMode, txVector);
---
>                   //SIG-A is sent using legacy OFDM modulation
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpTrainingSymbolsStart - previous,
>                                                     headerMode, txVector);
718c448,452
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - previous, mcsHeaderMode, txVector);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpTrainingSymbolsStart - previous,
>                                                     mcsHeaderMode, txVector);
726c460
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               if (preamble == WIFI_PREAMBLE_VHT || preamble == WIFI_PREAMBLE_HE_SU)
728,729c462,467
<                   //SIG-A is sent using non-HT OFDM modulation
<                   psr *= CalculateChunkSuccessRate (snr, current - previous, headerMode, txVector);
---
>                   //SIG-A is sent using legacy OFDM modulation
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - previous,
>                                                     headerMode, txVector);
735c473,477
<                   psr *= CalculateChunkSuccessRate (snr, current - previous, mcsHeaderMode, txVector);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - previous,
>                                                     mcsHeaderMode, txVector);
741c483
<       else if (previous >= phyHeaderStart)
---
>       else if (previous >= plcpHeaderStart)
745c487
<           if (current >= phyPayloadStart)
---
>           if (current >= plcpPayloadStart)
747c489
<               //Case 4ai: non-HT format
---
>               //Case 4ai: legacy format
750,751c492,497
<                   psr *= 1;
<                   NS_LOG_DEBUG ("Case 4ai - previous in L-SIG and current after payload start: nothing to do");
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpPayloadStart - previous,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 4ai - previous in L-SIG and current after payload start: mode=" << headerMode << ", psr=" << psr);
754c500
<               else if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               else if (preamble == WIFI_PREAMBLE_VHT || preamble == WIFI_PREAMBLE_HE_SU)
756,758c502,512
<                   psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 4aii - previous is in L-SIG and current after payload start: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpTrainingSymbolsStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpTrainingSymbolsStart - previous,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 4aii - previous is in L-SIG and current after payload start: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
763,764c517,527
<                   psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 4aiii - previous in L-SIG and current after payload start: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpHsigHeaderStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - previous,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 4aiii - previous in L-SIG and current after payload start: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
767,768c530,531
<           //Case 4b: current is in training or in SIG-B. non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyTrainingSymbolsStart)
---
>           //Case 4b: current is in training or in SIG-B. legacy will not come here since it went in previous if or if the previous if is not true this will be not true
>           else if (current >= plcpTrainingSymbolsStart)
772c535
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               if (preamble == WIFI_PREAMBLE_VHT || preamble == WIFI_PREAMBLE_HE_SU)
774,776c537,547
<                   psr *= CalculateChunkSuccessRate (snr, current - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 4bi - previous is in L-SIG and current in training or in SIG-B: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - plcpTrainingSymbolsStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpTrainingSymbolsStart - previous,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 4bi - previous is in L-SIG and current in training or in SIG-B: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
781,782c552,562
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 4bii - previous in L-SIG and current in HT training: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - plcpHsigHeaderStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - previous,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 4bii - previous in L-SIG and current in HT training: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
785,786c565,566
<           //Case 4c: current in HT-SIG or in SIG-A. Non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyLSigHeaderEnd)
---
>           //Case 4c: current in HT-SIG or in SIG-A. Legacy will not come here since it went in previous if or if the previous if is not true this will be not true
>           else if (current >= plcpHsigHeaderStart)
790c570
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               if (preamble == WIFI_PREAMBLE_VHT || preamble == WIFI_PREAMBLE_HE_SU)
792c572,576
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, headerMode, txVector);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - previous,
>                                                     headerMode, txVector);
798,799c582,592
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 4cii - previous in L-SIG and current in HT-SIG: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - plcpHsigHeaderStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - previous,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 4cii - previous in L-SIG and current in HT-SIG: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
805,806c598,603
<               psr *= 1;
<               NS_LOG_DEBUG ("Case 4d - current with previous in L-SIG: nothing to do");
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               txVector.GetChannelWidth ()),
>                                                 current - previous,
>                                                 headerMode, txVector);
>               NS_LOG_DEBUG ("Case 4d - current with previous in L-SIG: mode=" << headerMode << ", psr=" << psr);
813c610
<           if (current >= phyPayloadStart)
---
>           if (current >= plcpPayloadStart)
815c612
<               //Case 5ai: non-HT format (No HT-SIG or Training Symbols)
---
>               //Case 5ai: legacy format (No HT-SIG or Training Symbols)
818,819c615,620
<                   psr *= 1;
<                   NS_LOG_DEBUG ("Case 5ai - previous is in the preamble and current is after payload start: nothing to do");
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpHeaderStart,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 5a - previous is in the preamble and current is after payload start: mode=" << headerMode << ", psr=" << psr);
822c623
<               else if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               else if (preamble == WIFI_PREAMBLE_VHT || preamble == WIFI_PREAMBLE_HE_SU)
824,826c625,635
<                   psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 5aii - previous is in the preamble and current is after payload start: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpTrainingSymbolsStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpTrainingSymbolsStart - plcpHeaderStart,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 5aii - previous is in the preamble and current is after payload start: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
831,832c640,650
<                   psr *= CalculateChunkSuccessRate (snr, phyPayloadStart - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 5aiii - previous is in the preamble and current is after payload start: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpPayloadStart - plcpHsigHeaderStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - plcpHeaderStart, //HT GF: plcpHsigHeaderStart - plcpHeaderStart = 0
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 5aiii - previous is in the preamble and current is after payload start: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
835,836c653,654
<           //Case 5b: current is in training or in SIG-B. Non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyTrainingSymbolsStart)
---
>           //Case 5b: current is in training or in SIG-B. Legacy will not come here since it went in previous if or if the previous if is not true this will be not true
>           else if (current >= plcpTrainingSymbolsStart)
840c658
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               if (preamble == WIFI_PREAMBLE_VHT || preamble == WIFI_PREAMBLE_HE_SU)
842,844c660,670
<                   psr *= CalculateChunkSuccessRate (snr, current - phyTrainingSymbolsStart, mcsHeaderMode, txVector);
<                   psr *= CalculateChunkSuccessRate (snr, phyTrainingSymbolsStart - phyLSigHeaderEnd, headerMode, txVector);
<                   NS_LOG_DEBUG ("Case 5bi - previous is in the preamble and current in training or in SIG-B: mcs mode=" << mcsHeaderMode << ", non-HT mode=" << headerMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - plcpTrainingSymbolsStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpTrainingSymbolsStart - plcpHeaderStart,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 5bi - previous is in the preamble and current in training or in SIG-B: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
849,850c675,685
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 5bii - previous is in the preamble and current in HT training: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - plcpHsigHeaderStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - plcpHeaderStart,
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 5bii - previous is in the preamble and current in HT training: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
853,854c688,689
<           //Case 5c: current in HT-SIG or in SIG-A. Non-HT will not come here since it went in previous if or if the previous if is not true this will be not true
<           else if (current >= phyLSigHeaderEnd)
---
>           //Case 5c: current in HT-SIG or in SIG-A. Legacy will not come here since it went in previous if or if the previous if is not true this will be not true
>           else if (current >= plcpHsigHeaderStart)
858c693
<               if (preamble == WIFI_PREAMBLE_VHT_SU || preamble == WIFI_PREAMBLE_HE_SU || preamble == WIFI_PREAMBLE_VHT_MU || preamble == WIFI_PREAMBLE_HE_MU)
---
>               if (preamble == WIFI_PREAMBLE_VHT || preamble == WIFI_PREAMBLE_HE_SU)
860c695,699
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, headerMode, txVector);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - plcpHeaderStart,
>                                                     headerMode, txVector);
866,867c705,715
<                   psr *= CalculateChunkSuccessRate (snr, current - phyLSigHeaderEnd, mcsHeaderMode, txVector);
<                   NS_LOG_DEBUG ("Case 5cii - previous in preamble and current in HT-SIG: mcs mode=" << mcsHeaderMode << ", psr=" << psr);
---
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     current - plcpHsigHeaderStart,
>                                                     mcsHeaderMode, txVector);
>                   psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                                   noiseInterferenceW,
>                                                                   txVector.GetChannelWidth ()),
>                                                     plcpHsigHeaderStart - plcpHeaderStart, //HT-GF: plcpHsigHeaderStart - plcpHeaderStart = 0
>                                                     headerMode, txVector);
>                   NS_LOG_DEBUG ("Case 5cii - previous in preamble and current in HT-SIG: mcs mode=" << mcsHeaderMode << ", legacy mode=" << headerMode << ", psr=" << psr);
871c719
<           else if (current >= phyHeaderStart)
---
>           else if (current >= plcpHeaderStart)
874,941c722,727
<               psr *= 1;
<               NS_LOG_DEBUG ("Case 5d - previous is in the preamble and current is in L-SIG: nothing to do");
<             }
<         }
< 
<       noiseInterferenceW = j->second.GetPower () - powerW;
<       previous = j->first;
<     }
< 
<   double per = 1 - psr;
<   return per;
< }
< 
< double
< InterferenceHelper::CalculateDmgPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const
< {
<   NS_LOG_FUNCTION (this);
<   const WifiTxVector txVector = event->GetTxVector ();
<   double psr = 1.0; /* Packet Success Rate */
<   auto j = ni->begin ();
<   Time previous = j->first;
<   WifiMode headerMode = WifiPhy::GetPhyHeaderMode (txVector);
<   Time phyHeaderStart = j->first + WifiPhy::GetPhyPreambleDuration (txVector);  //PPDU start time + preamble
<   Time phyHeaderEnd = phyHeaderStart + WifiPhy::GetPhyHeaderDuration (txVector); //PPDU start time + preamble + header
<   double noiseInterferenceW = m_firstPower;
<   double powerW = event->GetRxPowerW ();
<   while (++j != ni->end ())
<     {
<       Time current = j->first;
<       NS_LOG_DEBUG ("previous= " << previous << ", current=" << current);
<       NS_ASSERT (current >= previous);
<       double snr = CalculateSnr (powerW, noiseInterferenceW, txVector);
<       //Case 1: previous and current after payload start
<       if (previous >= phyHeaderEnd)
<         {
<           psr *= 1;
<           NS_LOG_DEBUG ("Case 1 - previous and current after payload start: nothing to do");
<         }
<       //Case 2: previous in DMG PHY Header
<       else if (previous >= phyHeaderStart)
<         {
<           //Case 2a: current after payload start
<           if (current >= phyHeaderEnd)
<             {
<               psr *= CalculateChunkSuccessRate (snr, phyHeaderEnd - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 2a - previous in DMG PHY Header and current after payload start: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 2b: current with previous in DMG PHY Header
<           else
<             {
<               psr *= CalculateChunkSuccessRate (snr, current - previous, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 2b - current with previous in DMG PHY Header: mode=" << headerMode << ", psr=" << psr);
<             }
<         }
<       //Case 3: previous is in the preamble works for all cases
<       else
<         {
<           //Case 3a: current after payload start/PHY header end
<           if (current >= phyHeaderEnd)
<             {
<               psr *= CalculateChunkSuccessRate (snr, phyHeaderEnd - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 3a - previous is in the preamble and current is after payload start: mode=" << headerMode << ", psr=" << psr);
<             }
<           //Case 3b: current is in DMG PHY Header.
<           else if (current >= phyHeaderStart)
<             {
<               psr *= CalculateChunkSuccessRate (snr, current - phyHeaderStart, headerMode, txVector);
<               NS_LOG_DEBUG ("Case 3b - previous is in the preamble and current is in DMG PHY Header: mode=" << headerMode << ", psr=" << psr);
---
>               psr *= CalculateChunkSuccessRate (CalculateSnr (powerW,
>                                                               noiseInterferenceW,
>                                                               txVector.GetChannelWidth ()),
>                                                 current - plcpHeaderStart,
>                                                 headerMode, txVector);
>               NS_LOG_DEBUG ("Case 5d - previous is in the preamble and current is in L-SIG: mode=" << headerMode << ", psr=" << psr);
954c740
< InterferenceHelper::CalculatePayloadSnrPer (Ptr<Event> event, std::pair<Time, Time> relativeMpduStartStop) const
---
> InterferenceHelper::CalculatePlcpPayloadSnrPer (Ptr<Event> event) const
960c746
<                              event->GetTxVector ());
---
>                              event->GetTxVector ().GetChannelWidth ());
962,963c748,749
<   /* calculate the SNIR at the start of the MPDU (located through windowing) and accumulate
<    * all SNIR changes in the SNIR vector.
---
>   /* calculate the SNIR at the start of the packet and accumulate
>    * all SNIR changes in the snir vector.
965c751
<   double per = CalculatePayloadPer (event, &ni, relativeMpduStartStop);
---
>   double per = CalculatePlcpPayloadPer (event, &ni);
973,1127d758
< double
< InterferenceHelper::CalculatePlcpTrnSnr (Ptr<Event> event)
< {
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   double snr = CalculateSnr (event->GetRxPowerW (),
<                              noiseInterferenceW,
<                              event->GetTxVector ());
<   return snr;
< }
< 
< std::vector<double>
< InterferenceHelper::CalculateMimoTrnSnr (Ptr<Event> event, std::vector<double> rxPowerWList,
<                                          bool interferenceFree, uint8_t numRxAntennas)
< {
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   std::vector<double> snrValues;
<   if (interferenceFree)
<     {
<       snrValues = CalculateSnr (rxPowerWList,
<                                 noiseInterferenceW,
<                                 event->GetTxVector ());
<     }
<   else
<     {
<       uint8_t numTxAntennas = rxPowerWList.size ()/numRxAntennas;
<       double rxPowerW, interference, snrValue;
<       uint8_t index = 0;
<       for (uint8_t tx = 0; tx < numTxAntennas; tx++)
<         {
<           for (uint8_t rx = 0; rx < numRxAntennas; rx++)
<             {
<               rxPowerW = rxPowerWList.at (index);
<               interference = 0;
<               for (uint8_t txInterferer = 0; txInterferer < numTxAntennas; txInterferer++)
<                 {
<                   if (txInterferer != tx)
<                     {
<                       interference += rxPowerWList.at (rx + txInterferer * numRxAntennas);
<                     }
<                 }
<               index++;
<               interference += noiseInterferenceW;
<               snrValue = CalculateSnr (rxPowerW, interference, event->GetTxVector ());
<               snrValues.push_back (snrValue);
<             }
<         }
<     }
<   return snrValues;
< }
< 
< double
< InterferenceHelper::CalculatePayloadSnr (Ptr<Event> event) const
< {
<   NS_LOG_FUNCTION (this);
<   /* Calculate the SINR per stream */
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   std::vector<double> snrPerStream = CalculatePerStreamSnr (event, noiseInterferenceW);
<   double snr;
<   /* In the case of SISO simply return the SNR, in the case of MIMO return the minumum SNR per stream */
<   if (snrPerStream.size () == 1)
<     snr = snrPerStream.at (0);
<   else
<     snr = *(std::min_element (snrPerStream.begin (), snrPerStream.end ()));
<   return snr;
< }
< 
< std::vector<double>
< InterferenceHelper::CalculatePerStreamSnr (Ptr<Event const> event, double noiseInterferenceW) const
< {
<   NS_LOG_FUNCTION (this);
<   std::vector<double> perStreamSnr;
<   if (event->GetMimoRxPowerW ().empty ())
<     {
<       /* In case of SISO simply calculate the SINR */
<       double snr = CalculateSnr (event->GetRxPowerW (),
<                                  noiseInterferenceW,
<                                  event->GetTxVector ());
<       perStreamSnr.push_back (snr);
<     }
<   else
<     {
<       /* In case of MIMO calculate the SINR per stream taking into account inter-stream interference and
<        * assuming that we try to decode the maximum received tx signal at each antenna as long as no two rx antennas
<        * try to decode the same signal */
<       std::vector<double> mimoRxPowerW = event->GetMimoRxPowerW ();
<       std::vector<double> interStreamInterference = event->GetMimoInterStreamInterference ();
<       std::vector<uint8_t> rxPowerLocations = event->GetMimoRxSignalLocation ();
<       for (auto rxStream : rxPowerLocations)
<         {
<           double snr = CalculateSnr (mimoRxPowerW.at (rxStream),
<                                      noiseInterferenceW + interStreamInterference.at (rxStream),
<                                      event->GetTxVector ());
<           perStreamSnr.push_back (snr);
<         }
<     }
<   return perStreamSnr;
< }
< 
< double
< InterferenceHelper::CalculateSnr (Ptr<Event> event) const
< {
<   NS_LOG_FUNCTION (this);
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   double snr = CalculateSnr (event->GetRxPowerW (),
<                              noiseInterferenceW,
<                              event->GetTxVector ());
<  return snr;
< }
< 
< struct InterferenceHelper::SnrPer
< InterferenceHelper::CalculateNonHtPhyHeaderSnrPer (Ptr<Event> event) const
< {
<   NS_LOG_FUNCTION (this);
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   double snr = CalculateSnr (event->GetRxPowerW (),
<                              noiseInterferenceW,
<                              event->GetTxVector ());
< 
<   /* calculate the SNIR at the start of the PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
<    */
<   double per = CalculateNonHtPhyHeaderPer (event, &ni);
< 
<   struct SnrPer snrPer;
<   snrPer.snr = snr;
<   snrPer.per = per;
<   return snrPer;
< }
< 
< struct InterferenceHelper::SnrPer
< InterferenceHelper::CalculateHtPhyHeaderSnrPer (Ptr<Event> event) const
< {
<   NS_LOG_FUNCTION (this);
<   NiChanges ni;
<   double noiseInterferenceW = CalculateNoiseInterferenceW (event, &ni);
<   double snr = CalculateSnr (event->GetRxPowerW (),
<                              noiseInterferenceW,
<                              event->GetTxVector ());
<   
<   /* calculate the SNIR at the start of the PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
<    */
<   double per = CalculateHtPhyHeaderPer (event, &ni);
<   
<   struct SnrPer snrPer;
<   snrPer.snr = snr;
<   snrPer.per = per;
<   return snrPer;
< }
< 
1129c760
< InterferenceHelper::CalculateDmgPhyHeaderSnrPer (Ptr<Event> event) const
---
> InterferenceHelper::CalculatePlcpHeaderSnrPer (Ptr<Event> event) const
1131d761
<   NS_LOG_FUNCTION (this);
1136c766
<                              event->GetTxVector ());
---
>                              event->GetTxVector ().GetChannelWidth ());
1138,1139c768,769
<   /* calculate the SNIR at the start of the PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
---
>   /* calculate the SNIR at the start of the plcp header and accumulate
>    * all SNIR changes in the snir vector.
1141c771
<   double per = CalculateDmgPhyHeaderPer (event, &ni);
---
>   double per = CalculatePlcpHeaderPer (event, &ni);
1194c824
<   auto it = GetPreviousPosition (Simulator::Now ());
---
>   auto it = m_niChanges.find (Simulator::Now ());
diff ../../NS3-WiGig/src/wifi/model/interference-helper.h ../../ns-3-dev-git/src/wifi/model/interference-helper.h
30,31c30
< class WifiPpdu;
< class WifiPsdu;
---
> class Packet;
33d31
< class WifiPhy;
38c36
<  * \brief signal event for a PPDU.
---
>  * \brief signal event for a packet.
45a44
>    * \param packet the packet
48,67c47
<    * \param rxPower the received power (w)
<    */
<   Event (WifiTxVector txVector, Time duration, double rxPower);
<   /**
<    * Create an Event with the given parameters.
<    *
<    * \param ppdu the PPDU
<    * \param txVector the TXVECTOR
<    * \param duration duration of the PPDU
<    * \param rxPower the received power (w)
<    */
<   Event (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower);
<   /**
<    * Create an Event with the given parameters.
<    *
<    * \param ppdu the PPDU
<    * \param txVector the TXVECTOR
<    * \param duration duration of the PPDU
<    * \param rxPower the received power (w)
<    * \param mimoRxPower the received power (w) for MIMO
---
>    * \param rxPower the receive power (w)
69c49
<   Event (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower, std::vector<double> mimoRxPower);
---
>   Event (Ptr<const Packet> packet, WifiTxVector txVector, Time duration, double rxPower);
72,73c52
<   /**
<    * Return the PSDU in the PPDU.
---
>   /** Return the packet.
75c54
<    * \return the PSDU in the PPDU
---
>    * \return the packet
77,83c56
<   Ptr<const WifiPsdu> GetPsdu (void) const;
<   /**
<    * Return the PPDU.
<    *
<    * \return the PPDU
<    */
<   Ptr<const WifiPpdu> GetPpdu (void) const;
---
>   Ptr<const Packet> GetPacket (void) const;
97,103c70
<    * Return the duration of the signal.
<    *
<    * \return the duration of the signal
<    */
<   Time GetDuration (void) const;
<   /**
<    * Return the received power (w).
---
>    * Return the receive power (w).
105c72
<    * \return the received power (w)
---
>    * \return the receive power (w)
109c76
<    * Return the TXVECTOR of the PPDU.
---
>    * Return the TXVECTOR of the packet.
111c78
<    * \return the TXVECTOR of the PPDU
---
>    * \return the TXVECTOR of the packet
120,140d86
<   /**
<    * Return the list of received powers (W) in the case of MIMO.
<    *
<    * \return the list of received powers in the case of MIMO
<    */
<   std::vector<double> GetMimoRxPowerW (void) const;
<   /**
<    * Return the list of inter-stream interference for each received MIMO power.
<    *
<    * \return the list of inter-stream interference values in the case of MIMO
<    */
<   std::vector<double> GetMimoInterStreamInterference (void) const;
<   /**
<    * Return the location of the Rx signals that we lock into for each Rx antenna
<    * from the list of Rx powers in the case of MIMO.
<    * For now we choose to lock into the strongest Rx signal at each antenna, making sure that no two antennas
<    * try to decode the same stream.
<    *
<    * \return the list of indices from the mimoRxPowerW list that specify the rx signals that we decode
<    */
<   std::vector<uint8_t> GetMimoRxSignalLocation (void) const;
144c90
<   Ptr<const WifiPpdu> m_ppdu; ///< PPDU
---
>   Ptr<const Packet> m_packet; ///< packet
148,149c94
<   double m_rxPowerW; ///< received power in watts
<   std::vector<double> m_mimoRxPowerW; //!< received power in watts for MIMO
---
>   double m_rxPowerW; ///< receive power in watts
153,162d97
<  * \brief Stream insertion operator.
<  *
<  * \param os the stream
<  * \param event the event
<  * \returns a reference to the stream
<  */
< std::ostream& operator<< (std::ostream& os, const Event &event);
< 
< 
< /**
170c105
<    * Signal event for a PPDU.
---
>    * Signal event for a packet.
178c113
<     double snr; ///< SNR in linear scale
---
>     double snr; ///< SNR
185d119
<   void SetWifiPhy (Ptr<WifiPhy> wifiPhy);
189c123
<    * \param value noise figure in linear scale
---
>    * \param value noise figure
200,205d133
<    * Return the noise figure.
<    *
<    * \return the noise figure
<    */
<   double GetNoiseFigure (void) const;
<   /**
229,236d156
<    * Add the PPDU-related signal to interference helper.
<    *
<    * \param txvector TXVECTOR of the packet
<    * \param duration duration of the signal
<    * \param rxPower the received power (w)
<    */
<   Ptr<Event> Add (WifiTxVector txVector, Time duration, double rxPower = 0);
<   /**
240,254c160,162
<    * \param ppdu the PPDU
<    * \param txVector the TXVECTOR
<    * \param rxPower received power (W)
<    *
<    * \return Event
<    */
<   Ptr<Event> Add (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower);
<   /**
<    * Add the packet-related signal to interference helper.
<    *
<    * \param packet the packet
<    * \param ppdu the PPDU
<    * \param txVector the TXVECTOR
<    * \param rxPower received power (W)
<    * \param mimoRxPower received power (W) for MIMO
---
>    * \param txVector TXVECTOR of the packet
>    * \param duration the duration of the signal
>    * \param rxPower receive power (W)
258c166
<   Ptr<Event> Add (Ptr<const WifiPpdu> ppdu, WifiTxVector txVector, Time duration, double rxPower, std::vector<double> mimoRxPower);
---
>   Ptr<Event> Add (Ptr<const Packet> packet, WifiTxVector txVector, Time duration, double rxPower);
263c171
<    * \param rxPower received power (W)
---
>    * \param rxPower receive power (W)
266,296d173
<   //// WIGIG ////
<   /**
<    * Calculate the SNIR for the event (starting from now until the event end).
<    *
<    * \param event the event corresponding to the first time the corresponding TRN subfield arrives
<    *
<    * \return the SNR for the TRN subfield in linear scale
<    */
<   double CalculatePlcpTrnSnr (Ptr<Event> event);
<   /**
<    * Calculate the SNIR for the event (starting from now until the event end).
<    *
<    * \param event the event corresponding to the first time the corresponding TRN subfield arrives
<    * \param rxPowerW List of rx power values in Watt for each Tx and Rx combination.
<    * \param interferenceFree This flag is to idnicate whether we consider inter-stream interference
<    * in our SINR calculations which is for the SISO case or we include inter-stream interference
<    * which is in the MIMO case
<    * \param numRxAntennas The numbers of receive antennas when we the interferenceFree flag is set to false.
<    * \return List of SNR values in linear scale.
<    */
<   std::vector<double> CalculateMimoTrnSnr (Ptr<Event> event, std::vector<double> rxPowerW,
<                                            bool interferenceFree = true, uint8_t numRxAntennas = 1);
<   /**
<    * Calculate the SNIR for the event (starting from now until the event end). In the MIMO case
<    * returns the minimum SINR from the streams taking into account inter-stream interference.
<    * Used in the EndReceive function
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
<    *
<    * \return the SNR for the PPDU in linear scale
<    */
<   double CalculatePayloadSnr (Ptr<Event> event) const;
298,300c175,176
<    * Calculate the SNR per stream (taking into account inter-stream interference) and return
<    * a vector of SNR values (in the case of SISO transmission the vector has a single value, in the case of MIMO multiple)
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
---
>    * Calculate the SNIR at the start of the plcp payload and accumulate
>    * all SNIR changes in the snir vector.
302,342c178
<    * \return a vector of SNR for the PPDU in liner scale corresponding to the SNR per stream
<    */
<   std::vector<double> CalculatePerStreamSnr (Ptr<const Event> event, double noiseInterferenceW) const;
< 
<   //// WIGIG ////
< 
<   /**
<    * Calculate the SNIR at the start of the payload and accumulate
<    * all SNIR changes in the SNIR vector for each MPDU of an A-MPDU.
<    * This workaround is required in order to provide one PER per MPDU, for
<    * reception success/failure evaluation, while hiding aggregation details from
<    * this class.
<    *
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
<    * \param relativeMpduStartStop the time window (pair of start and end times) of PHY payload to focus on
<    *
<    * \return struct of SNR and PER (with PER being evaluated over the provided time window)
<    */
<   struct InterferenceHelper::SnrPer CalculatePayloadSnrPer (Ptr<Event> event, std::pair<Time, Time> relativeMpduStartStop) const;
<   /**
<    * Calculate the SNIR for the event (starting from now until the event end).
<    *
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
<    *
<    * \return the SNR for the PPDU in linear scale
<    */
<   double CalculateSnr (Ptr<Event> event) const;
<   /**
<    * Calculate the SNIR at the start of the non-HT PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
<    *
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
<    *
<    * \return struct of SNR and PER
<    */
<   struct InterferenceHelper::SnrPer CalculateNonHtPhyHeaderSnrPer (Ptr<Event> event) const;
<   /**
<    * Calculate the SNIR at the start of the HT PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
<    *
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
---
>    * \param event the event corresponding to the first time the corresponding packet arrives
346c182
<   struct InterferenceHelper::SnrPer CalculateHtPhyHeaderSnrPer (Ptr<Event> event) const;
---
>   struct InterferenceHelper::SnrPer CalculatePlcpPayloadSnrPer (Ptr<Event> event) const;
348,349c184,185
<    * Calculate the SNIR at the start of the DMG PHY header and accumulate
<    * all SNIR changes in the SNIR vector.
---
>    * Calculate the SNIR at the start of the plcp header and accumulate
>    * all SNIR changes in the snir vector.
351c187
<    * \param event the event corresponding to the first time the corresponding PPDU arrives
---
>    * \param event the event corresponding to the first time the corresponding packet arrives
355c191
<   struct InterferenceHelper::SnrPer CalculateDmgPhyHeaderSnrPer (Ptr<Event> event) const;
---
>   struct InterferenceHelper::SnrPer CalculatePlcpHeaderSnrPer (Ptr<Event> event) const;
371,408d206
< protected:
<   /**
<    * Calculate SNR (linear ratio) from the given signal power and noise+interference power.
<    *
<    * \param signal signal power, W
<    * \param noiseInterference noise and interference power, W
<    * \param txVector the TXVECTOR
<    *
<    * \return SNR in linear scale
<    */
<   double CalculateSnr (double signal, double noiseInterference, WifiTxVector txVector) const;
<   //// WIGIG ////
<   /**
<    * Calculate SNR (linear ratio) from the given list of signal power and noise+interference power.
<    * This is a special function and used for orthogonal EDMG TRN subfields.
<    *
<    * \param signal List of signals powers in Watts.
<    * \param noiseInterference noise and interference power, W
<    * \param txVector the TXVECTOR
<    *
<    * \return List of SNR values in linear scale
<    */
<   std::vector<double> CalculateSnr (std::vector<double> signalList, double noiseInterference, WifiTxVector txVector) const;
<   //// WIGIG ////
<   /**
<    * Calculate the success rate of the chunk given the SINR, duration, and Wi-Fi mode.
<    * The duration and mode are used to calculate how many bits are present in the chunk.
<    *
<    * \param snir the SINR
<    * \param duration the duration of the chunk
<    * \param mode the WifiMode
<    * \param txVector the TXVECTOR
<    *
<    * \return the success rate
<    */
<   double CalculateChunkSuccessRate (double snir, Time duration, WifiMode mode, WifiTxVector txVector) const;
< 
< 
419c217
<      * \param power the power in watts
---
>      * \param power the power
426c224
<      * \return the power in watts
---
>      * \return the power
432c230
<      * \param power the power to be added to the existing value in watts
---
>      * \param power the power to be added to the existing value
444c242
<     double m_power; ///< power in watts
---
>     double m_power; ///< power
462,463c260,261
<    * \param event the event
<    * \param ni the NiChanges
---
>    * \param event
>    * \param ni
469,482c267,268
<    * Calculate the success rate of the payload chunk given the SINR, duration, and Wi-Fi mode.
<    * The duration and mode are used to calculate how many bits are present in the chunk.
<    *
<    * \param snir the SINR
<    * \param duration the duration of the chunk
<    * \param txVector the TXVECTOR
<    *
<    * \return the success rate
<    */
<   double CalculatePayloadChunkSuccessRate (double snir, Time duration, WifiTxVector txVector) const;
<   /**
<    * Calculate the error rate of the given PHY payload only in the provided time
<    * window (thus enabling per MPDU PER information). The PHY payload can be divided into
<    * multiple chunks (e.g. due to interference from other transmissions).
---
>    * Calculate SNR (linear ratio) from the given signal power and noise+interference power.
>    * (Mode is not currently used)
484,486c270,272
<    * \param event the event
<    * \param ni the NiChanges
<    * \param window time window (pair of start and end times) of PHY payload to focus on
---
>    * \param signal
>    * \param noiseInterference
>    * \param channelWidth
488c274
<    * \return the error rate of the payload
---
>    * \return SNR in liear ratio
490c276
<   double CalculatePayloadPer (Ptr<const Event> event, NiChanges *ni, std::pair<Time, Time> window) const;
---
>   double CalculateSnr (double signal, double noiseInterference, uint16_t channelWidth) const;
492,493c278,279
<    * Calculate the error rate of the non-HT PHY header. The non-HT PHY header
<    * can be divided into multiple chunks (e.g. due to interference from other transmissions).
---
>    * Calculate the success rate of the chunk given the SINR, duration, and Wi-Fi mode.
>    * The duration and mode are used to calculate how many bits are present in the chunk.
495,496c281,284
<    * \param event the event
<    * \param ni the NiChanges
---
>    * \param snir SINR
>    * \param duration
>    * \param mode
>    * \param txVector
498c286
<    * \return the error rate of the non-HT PHY header
---
>    * \return the success rate
500c288
<   double CalculateNonHtPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const;
---
>   double CalculateChunkSuccessRate (double snir, Time duration, WifiMode mode, WifiTxVector txVector) const;
502,503c290,291
<    * Calculate the error rate of the HT PHY header. TheHT PHY header
<    * can be divided into multiple chunks (e.g. due to interference from other transmissions).
---
>    * Calculate the error rate of the given plcp payload. The plcp payload can be divided into
>    * multiple chunks (e.g. due to interference from other transmissions).
505,506c293,294
<    * \param event the event
<    * \param ni the NiChanges
---
>    * \param event
>    * \param ni
508c296
<    * \return the error rate of the HT PHY header
---
>    * \return the error rate of the packet
510c298
<   double CalculateHtPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const;
---
>   double CalculatePlcpPayloadPer (Ptr<const Event> event, NiChanges *ni) const;
512,513c300,301
<    * Calculate the error rate of the DMG PHY header. The DMG PHY header
<    * can be divided into multiple chunks (e.g. due to interference from other transmissions).
---
>    * Calculate the error rate of the plcp header. The plcp header can be divided into
>    * multiple chunks (e.g. due to interference from other transmissions).
515,516c303,304
<    * \param event the event
<    * \param ni the NiChanges
---
>    * \param event
>    * \param ni
518c306
<    * \return the error rate of the DMG PHY header
---
>    * \return the error rate of the packet
520c308
<   double CalculateDmgPhyHeaderPer (Ptr<const Event> event, NiChanges *ni) const;
---
>   double CalculatePlcpHeaderPer (Ptr<const Event> event, NiChanges *ni) const;
522d309
<   Ptr<WifiPhy> m_wifiPhy;
528c315
<   double m_firstPower; ///< first power in watts
---
>   double m_firstPower; ///< first power
532c319
<    * Returns an iterator to the first NiChange that is later than moment
---
>    * Returns an iterator to the first nichange that is later than moment
539c326
<    * Returns an iterator to the first NiChange that is later than moment
---
>    * Returns an iterator to the first nichange that is later than moment
546c333
<    * Returns an iterator to the last NiChange that is before than moment
---
>    * Returns an iterator to the last nichange that is before than moment
557,558c344,345
<    * \param moment time to check from
<    * \param change the NiChange to add
---
>    * \param moment
>    * \param change
diff ../../NS3-WiGig/src/wifi/model/mac-low.cc ../../ns-3-dev-git/src/wifi/model/mac-low.cc
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
22,23d20
<  *          Stefano Avallone <stavallo@unina.it>
<  *          Hany Assasa <hany.assasa@gmail.com>
27a25
> #include "ns3/socket.h"
33d30
< #include "wifi-psdu.h"
41,43d37
< #include "dmg-wifi-mac.h"
< #include "dmg-wifi-phy.h"
< #include "dmg-sta-wifi-mac.h"
48,51d41
< #include "wifi-mac.h"
< #include <algorithm>
< #include "wifi-ack-policy-selector.h"
< #include "control-trailer.h"
56,60d45
< // Time (in nanoseconds) to be added to the PSDU duration to yield the duration
< // of the timer that is started when the PHY indicates the start of the reception
< // of a frame and we are waiting for a response.
< #define PSDU_DURATION_SAFEGUARD 400
< 
123,125c108
<   : m_msduAggregator (0),
<     m_mpduAggregator (0),
<     m_normalAckTimeoutEvent (),
---
>   : m_normalAckTimeoutEvent (),
140a124
>     m_ampdu (false),
143,147c127
<     m_cfAckInfo (),
<     m_transmissionSuspended (false),
<     m_restoredSuspendedTransmission (false),
<     m_servingSLS (false),
<     m_servingMimoBFT (false)
---
>     m_cfAckInfo ()
149a130,133
>   for (uint8_t i = 0; i < 8; i++)
>     {
>       m_aggregateQueue[i] = CreateObject<WifiMacQueue> ();
>     }
199,200d182
<   m_msduAggregator = 0;
<   m_mpduAggregator = 0;
207a190,194
>   for (uint8_t i = 0; i < 8; i++)
>     {
>       m_aggregateQueue[i] = 0;
>     }
>   m_ampdu = false;
266d252
<   m_phy->TraceConnectWithoutContext ("PhyRxPayloadBegin", MakeCallback (&MacLow::RxStartIndication, this));
281,283c267,268
<   m_phy->TraceDisconnectWithoutContext ("PhyRxPayloadBegin", MakeCallback (&MacLow::RxStartIndication, this));
<   m_phy->SetReceiveOkCallback (MakeNullCallback<void, Ptr<WifiPsdu>, double, WifiTxVector, std::vector<bool>> ());
<   m_phy->SetReceiveErrorCallback (MakeNullCallback<void, Ptr<WifiPsdu>> ());
---
>   m_phy->SetReceiveOkCallback (MakeNullCallback<void, Ptr<Packet>, double, WifiTxVector> ());
>   m_phy->SetReceiveErrorCallback (MakeNullCallback<void, Ptr<Packet>, double> ());
288,301d272
< Ptr<QosTxop>
< MacLow::GetEdca (uint8_t tid) const
< {
<   auto it = m_edca.find (QosUtilsMapTidToAc (tid));
<   NS_ASSERT (it != m_edca.end ());
<   return it->second;
< }
< 
< void
< MacLow::SetMac (const Ptr<WifiMac> mac)
< {
<   m_mac = mac;
< }
< 
308,333d278
< Ptr<MsduAggregator>
< MacLow::GetMsduAggregator (void) const
< {
<   return m_msduAggregator;
< }
< 
< Ptr<MpduAggregator>
< MacLow::GetMpduAggregator (void) const
< {
<   return m_mpduAggregator;
< }
< 
< void
< MacLow::SetMsduAggregator (const Ptr<MsduAggregator> aggr)
< {
<   NS_LOG_FUNCTION (this << aggr);
<   m_msduAggregator = aggr;
< }
< 
< void
< MacLow::SetMpduAggregator (const Ptr<MpduAggregator> aggr)
< {
<   NS_LOG_FUNCTION (this << aggr);
<   m_mpduAggregator = aggr;
< }
< 
365c310
< MacLow::GetCtsToSelfSupported (void) const
---
> MacLow::GetCtsToSelfSupported () const
371c316
< MacLow::SetSifs (Time sifs)
---
> MacLow::SetCtsTimeout (Time ctsTimeout)
373c318
<   m_sifs = sifs;
---
>   m_ctsTimeout = ctsTimeout;
376d320
< //// WIGIG ////
378,396c322
< MacLow::SetSbifs (Time sbifs)
< {
<   m_sbifs = sbifs;
< }
< 
< void
< MacLow::SetMbifs (Time mbifs)
< {
<   m_mbifs = mbifs;
< }
< 
< void
< MacLow::SetLbifs (Time lbifs)
< {
<   m_lbifs = lbifs;
< }
< 
< void
< MacLow::SetBrifs (Time brifs)
---
> MacLow::SetSifs (Time sifs)
398c324
<   m_brifs = brifs;
---
>   m_sifs = sifs;
400d325
< //// WIGIG ////
457c382
< MacLow::GetBasicBlockAckTimeout (void) const
---
> MacLow::GetBasicBlockAckTimeout () const
463c388
< MacLow::GetCompressedBlockAckTimeout (void) const
---
> MacLow::GetCompressedBlockAckTimeout () const
468a394,399
> MacLow::GetCtsTimeout (void) const
> {
>   return m_ctsTimeout;
> }
> 
> Time
470a402
>   NS_LOG_FUNCTION (this);
476a409
>   NS_LOG_FUNCTION (this);
492,517d424
< //// WIGIG ////
< Time
< MacLow::GetSbifs (void) const
< {
<   return m_sbifs;
< }
< 
< Time
< MacLow::GetMbifs (void) const
< {
<   return m_mbifs;
< }
< 
< Time
< MacLow::GetLbifs (void) const
< {
<   return m_lbifs;
< }
< 
< Time
< MacLow::GetBrifs (void) const
< {
<   return m_brifs;
< }
< //// WIGIG ////
< 
543c450
< MacLow::SetRxCallback (Callback<void, Ptr<WifiMacQueueItem>> callback)
---
> MacLow::SetRxCallback (Callback<void, Ptr<Packet>, const WifiMacHeader *> callback)
549,682c456
< MacLow::RegisterChannelAccessManager (Ptr<ChannelAccessManager> channelAccessManager)
< {
<   m_channelAccessManagers.push_back (channelAccessManager);
< }
< 
< //// WIGIG ////
< 
< bool
< MacLow::IsCurrentAllocationEmpty (void) const
< {
<   return m_currentAllocation == 0;
< }
< 
< void
< MacLow::ResumeTransmission (Time duration, Ptr<Txop> txop)
< {
<   NS_LOG_FUNCTION (this << duration << txop);
< 
<   NS_ASSERT_MSG (!IsCurrentAllocationEmpty (), "Restored allocation should not be empty");
< 
<   NS_LOG_DEBUG ("IsAmpdu=" << m_currentAllocation->psdu->IsAggregate ()
<                 << ", PacketSize=" << m_currentAllocation->psdu->GetSize ()
<                 << ", seq=0x" << std::hex << m_currentAllocation->psdu->GetHeader (0).GetSequenceControl () << std::dec);
< 
<   /* Restore the vaiables associated to the current allocation */
<   m_restoredSuspendedTransmission = false;
<   m_currentPacket = m_currentAllocation->psdu;
<   m_txParams = m_currentAllocation->txParams;
<   m_currentTxVector = m_currentAllocation->txVector;
< 
<   /* Check if the remaining time is enough to resume previously suspended transmission */
<   Time transactionTime = CalculateWiGigTransactionTime (m_currentPacket);
<   NS_LOG_DEBUG ("TransactionTime=" << transactionTime <<
<                 ", RemainingTime=" << txop->GetAllocationRemaining ());
<   if (transactionTime <= duration)
<     {
<       /* This only applies for service period */
<       CancelAllEvents ();
<       m_currentTxop = txop;
< 
<       if (m_txParams.MustSendRts ())
<         {
<           SendRtsForPacket ();
<         }
<       else
<         {
<           SendDataPacket ();
<         }
< 
<       /* When this method completes, either we have taken ownership of the medium or the device switched off in the meantime. */
<       NS_ASSERT (m_phy->IsStateTx () || m_phy->IsStateOff ());
<     }
<   else
<     {
<       m_transmissionSuspended = true;
<     }
< 
<   /* Remove suspended allocaion related parameters as we've restored it */
<   m_allocationPeriodsTable.erase (m_currentAllocationID);
< }
< 
< void
< MacLow::AbortSuspendedTransmission (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_restoredSuspendedTransmission = false;
<   m_currentAllocation = 0;
<   m_allocationPeriodsTable.erase (m_currentAllocationID);
< }
< 
< void
< MacLow::ChangeAllocationPacketsAddress (AllocationID allocationId, Mac48Address destAdd)
< {
<   NS_LOG_FUNCTION (this << uint16_t (allocationId) << destAdd);
<   /* Find the stored parameters and packets for the provided allocation */
<   AllocationPeriodsTableI it = m_allocationPeriodsTable.find (m_currentAllocationID);
<   if (it != m_allocationPeriodsTable.end ())
<     {
<       NS_LOG_DEBUG ("Changing Receiver Address for Packets stored for AllocationID=" << uint16_t (allocationId));
< //      it->second.psdu.SetAddr1 (destAdd);
<     }
<   else
<     {
<       NS_LOG_DEBUG ("No allocation parameters stored for AllocationID=" << uint16_t (allocationId));
<     }
< }
< 
< void
< MacLow::RestoreAllocationParameters (AllocationID allocationId)
< {
<   NS_LOG_FUNCTION (this << static_cast<uint16_t> (allocationId));
<   m_transmissionSuspended = false;  /* Transmission is not suspended anymore */
<   m_currentAllocationID = allocationId;
<   /* Find the stored parameters and packets for the provided allocation */
<   AllocationPeriodsTableCI it = m_allocationPeriodsTable.find (m_currentAllocationID);
<   if (it != m_allocationPeriodsTable.end ())
<     {
<       NS_LOG_DEBUG ("Restored allocation parameters for AllocationID=" << uint16_t (allocationId));
<       m_currentAllocation = it->second;
<       m_restoredSuspendedTransmission = true;
<     }
<   else
<     {
<       NS_LOG_DEBUG ("No allocation parameters stored for AllocationID=" << uint16_t (allocationId));
<       m_restoredSuspendedTransmission = false;
<       m_currentAllocation = 0;
<     }
< }
< 
< void
< MacLow::StoreAllocationParameters (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_LOG_DEBUG ("CurrentPacket=" << m_currentPacket);
<   if (m_currentPacket != 0
<       && m_currentPacket->GetHeader (0).IsQosData ())
<     {
<       /* Since CurrentPacket is not empty it means we've suspended an ongoing transmission */
<       Ptr<AllocationParameters> allocationParams = Create<AllocationParameters> ();
<       allocationParams->psdu = m_currentPacket;
<       allocationParams->txParams = m_txParams;
<       allocationParams->txVector = m_currentTxVector;
<       allocationParams->txop = m_currentTxop;
<       m_allocationPeriodsTable[m_currentAllocationID] = allocationParams;
<       NS_LOG_DEBUG ("PSDU Size=" << m_currentPacket->GetSize ()
<                     << ", seq=0x" << std::hex << m_currentPacket->GetHeader (0).GetSequenceControl () << std::dec
<                     << ", Txop=" << m_currentTxop);
<     }
<   m_currentPacket = 0;
<   m_currentAllocation = 0;
< }
< 
< void
< MacLow::EndAllocationPeriod (void)
---
> MacLow::RegisterDcf (Ptr<ChannelAccessManager> dcf)
684,694c458
<   NS_LOG_FUNCTION (this);
<   CancelAllEvents ();
<   StoreAllocationParameters ();
<   if (m_navCounterResetCtsMissed.IsRunning ())
<     {
<       m_navCounterResetCtsMissed.Cancel ();
<     }
<   m_lastNavStart = Simulator::Now ();
<   m_lastNavDuration = Seconds (0);
<   m_currentTxop = 0;
< //  m_phy->EndAllocationPeriod ();
---
>   m_channelAccessManagers.push_back (dcf);
698c462
< MacLow::IsTransmissionSuspended (void) const
---
> MacLow::IsAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
700,714c464,469
<   return m_transmissionSuspended;
< }
< 
< bool
< MacLow::CompletedSuspendedPsduTransmission (Ptr<Txop> txop) const
< {
<   NS_LOG_FUNCTION (this << txop);
<   NS_LOG_DEBUG ("Restored Suspended Transmission=" << m_restoredSuspendedTransmission);
<   if (m_restoredSuspendedTransmission
<       && !IsCurrentAllocationEmpty ()
<       && m_currentAllocation->txop == txop)
<     {
<       return false;
<     }
<   else
---
>   uint32_t size, actualSize;
>   WifiMacTrailer fcs;
>   size = packet->GetSize () + hdr.GetSize () + fcs.GetSerializedSize ();
>   Ptr<Packet> p = AggregateToAmpdu (packet, hdr);
>   actualSize = p->GetSize ();
>   if (actualSize > size)
715a471
>       m_currentPacket = p;
717a474
>   return false;
720,738d476
< bool
< MacLow::SwitchInTransmissionMode (void) const
< {
<   Mac48Address address = m_currentAllocation->psdu->GetAddr1 ();
<   if (m_currentAllocation->txVector.Get_NUM_STS () != StaticCast<DmgWifiMac> (m_mac)->GetStationNStreams (address))
<     {
<       NS_LOG_INFO ("The number of space-time streams in the saved allocation and the one currently calculate do not match. There has been a switch in"
<                    "the transmission mode");
<       return true;
<     }
<   else
<     {
<       NS_LOG_INFO ("The number of space-time streams in the saved allocation and the one currently calculate match. There has not been a switch in"
<                    "the transmission mode");
<       return false;
<     }
< }
< //// WIGIG ////
< 
740c478,479
< MacLow::StartTransmission (Ptr<WifiMacQueueItem> mpdu,
---
> MacLow::StartTransmission (Ptr<const Packet> packet,
>                            const WifiMacHeader* hdr,
744c483
<   NS_LOG_FUNCTION (this << *mpdu << params << txop);
---
>   NS_LOG_FUNCTION (this << packet << hdr << params << txop);
763c502
<    * one of the EDCA of the QAP.
---
>    * one of the Edca of the QAP.
765,766c504,508
<   m_currentPacket = Create<WifiPsdu> (mpdu, false);
<   const WifiMacHeader& hdr = mpdu->GetHeader ();
---
>   m_currentPacket = packet->Copy ();
>   // remove the priority tag attached, if any
>   SocketPriorityTag priorityTag;
>   m_currentPacket->RemovePacketTag (priorityTag);
>   m_currentHdr = *hdr;
770c512,514
<   if (hdr.IsCtl ())
---
>   m_currentTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
> 
>   if (NeedRts () && !IsCfPeriod ())
772c516
<       m_currentTxVector = GetRtsTxVector (mpdu);
---
>       m_txParams.EnableRts ();
776c520
<       m_currentTxVector = GetDataTxVector (mpdu);
---
>       m_txParams.DisableRts ();
779,788c523,526
<   /* The packet received by this function can be any of the following:
<    * (a) a management frame dequeued from the Txop
<    * (b) a non-QoS data frame dequeued from the Txop
<    * (c) a non-broadcast QoS Data frame peeked or dequeued from a QosTxop
<    * (d) a broadcast QoS data or DELBA Request frame dequeued from a QosTxop
<    * (e) a BlockAckReq or ADDBA Request frame
<    * (f) a fragment of non-QoS/QoS Data frame dequeued from the Txop/QosTxop
<    */
<   if (hdr.IsQosData () && !hdr.GetAddr1 ().IsBroadcast ()
<       && !hdr.IsMoreFragments () && hdr.GetFragmentNumber () == 0)
---
>   if (m_currentHdr.IsMgt ()
>       || (!m_currentHdr.IsQosData ()
>           && !m_currentHdr.IsBlockAck ()
>           && !m_currentHdr.IsBlockAckReq ()))
790,852c528,539
<       // We get here if the received packet is a non-broadcast QoS data frame
<       uint8_t tid = hdr.GetQosTid ();
<       Ptr<QosTxop> qosTxop = m_edca.find (QosUtilsMapTidToAc (tid))->second;
< 
<       // if a TXOP limit exists, compute the remaining TXOP duration
<       Time txopLimit = Time::Min ();
<       //// WIGIG ////
<       if (m_currentTxop->GetTxopLimit ().IsStrictlyPositive () || m_currentTxop->GetAllocationRemaining ().IsStrictlyPositive ())
<         {
<           txopLimit = m_currentTxop->GetPpduDurationLimit (mpdu, params);
<           //NS_ASSERT (txopLimit.IsPositive ());
<         }   
<       // QosTxop may send us a peeked frame
<       Ptr<const WifiMacQueueItem> tmp = qosTxop->PeekFrameForTransmission ();
<       //// WIGIG ////
<       bool isPeeked = (tmp != 0 && tmp->GetPacket () == mpdu->GetPacket ());
< 
<       Ptr<WifiMacQueueItem> newMpdu;
<       // If the frame has been peeked, dequeue it if it meets the size and duration constraints
<       if (isPeeked)
<         {
<           newMpdu = qosTxop->DequeuePeekedFrame (mpdu, m_currentTxVector, true, 0, txopLimit);
<         }
<       else if (IsWithinSizeAndTimeLimits (mpdu, m_currentTxVector, 0, txopLimit))
<         {
<           newMpdu = mpdu;
<         }
< 
<       if (newMpdu == 0)
<         {
<           // if the frame has been dequeued, then there is no BA agreement with the
<           // receiver (otherwise the frame would have been peeked). Hence, the frame
<           // has been sent under Normal Ack policy, not acknowledged and now retransmitted.
<           // If we cannot send it now, let the QosTxop retransmit it again.
<           // If the frame has been just peeked, reset the current packet at QosTxop.
<           if (isPeeked)
<             {
<               //// WIGIG ////
<               m_currentPacket = 0;
<               //// WIGIG ////
<               qosTxop->UpdateCurrentPacket (Create<WifiMacQueueItem> (nullptr, WifiMacHeader ()));
<             }
<           return;
<         }
<       // Update the current packet at QosTxop, given that A-MSDU aggregation may have
<       // been performed on the peeked frame
<       qosTxop->UpdateCurrentPacket (newMpdu);
< 
<       //// WIGIG ////
<       /* Since we might perform A-MPDU aggregation, update txopLimit to take into account the correct
<        * size of A-MPDU aggregation */
<       if (m_currentTxop->GetTxopLimit ().IsStrictlyPositive () || m_currentTxop->GetAllocationRemaining ().IsStrictlyPositive ())
<         {
<           /* Get temporary TransmissionLow Parameters for A-MPDU */
<           MacLowTransmissionParameters tempParams = qosTxop->GetAckPolicySelector ()->GetTemporaryParams (m_currentPacket, params);
<           txopLimit = m_currentTxop->GetPpduDurationLimit (mpdu, tempParams);
< //          NS_ASSERT (txopLimit.IsPositive ());
<         }
<       //// WIGIG ////
< 
<       //Perform MPDU aggregation if possible
<       std::vector<Ptr<WifiMacQueueItem>> mpduList;
<       if (m_mpduAggregator != 0)
---
>       //This is mainly encountered when a higher priority control or management frame is
>       //sent between A-MPDU transmissions. It avoids to unexpectedly flush the aggregate
>       //queue when previous RTS request has failed.
>       m_ampdu = false;
>     }
>   else if (m_currentHdr.IsQosData () && !m_aggregateQueue[GetTid (packet, *hdr)]->IsEmpty ())
>     {
>       //m_aggregateQueue > 0 occurs when a RTS/CTS exchange failed before an A-MPDU transmission.
>       //In that case, we transmit the same A-MPDU as previously.
>       uint32_t sentMpdus = m_aggregateQueue[GetTid (packet, *hdr)]->GetNPackets ();
>       m_ampdu = true;
>       if (sentMpdus > 1)
854c541
<           mpduList = m_mpduAggregator->GetNextAmpdu (newMpdu, m_currentTxVector, txopLimit);
---
>           m_txParams.EnableCompressedBlockAck ();
856,857c543
< 
<       if (mpduList.size () > 1)
---
>       else if (m_currentHdr.IsQosData ())
859,862c545,546
<           m_currentPacket = Create<WifiPsdu> (mpduList);
< 
<           NS_LOG_DEBUG ("tx unicast A-MPDU containing " << mpduList.size () << " MPDUs");
<           qosTxop->SetAmpduExist (hdr.GetAddr1 (), true);
---
>           //VHT/HE single MPDUs are followed by normal ACKs
>           m_txParams.EnableAck ();
864,865c548,551
<       else if (m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT
<                || m_currentTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE)
---
>       AcIndex ac = QosUtilsMapTidToAc (GetTid (packet, *hdr));
>       std::map<AcIndex, Ptr<QosTxop> >::const_iterator edcaIt = m_edca.find (ac);
>       Ptr<Packet> aggregatedPacket = Create<Packet> ();
>       for (uint32_t i = 0; i < sentMpdus; i++)
867,871c553,556
<           // VHT/HE single MPDU
<           m_currentPacket = Create<WifiPsdu> (newMpdu, true);
< 
<           NS_LOG_DEBUG ("tx unicast S-MPDU with sequence number " << hdr.GetSequenceNumber ());
<           qosTxop->SetAmpduExist (hdr.GetAddr1 (), true);
---
>           Ptr<Packet> newPacket = (m_txPackets[GetTid (packet, *hdr)].at (i).packet)->Copy ();
>           newPacket->AddHeader (m_txPackets[GetTid (packet, *hdr)].at (i).hdr);
>           AddWifiMacTrailer (newPacket);
>           edcaIt->second->GetMpduAggregator ()->Aggregate (newPacket, aggregatedPacket);
873c558,566
<       else  // HT
---
>       m_currentPacket = aggregatedPacket;
>       m_currentHdr = (m_txPackets[GetTid (packet, *hdr)].at (0).hdr);
>       m_currentTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
>     }
>   else
>     {
>       //Perform MPDU aggregation if possible
>       m_ampdu = IsAmpdu (m_currentPacket, m_currentHdr);
>       if (m_ampdu)
875c568,578
<           m_currentPacket = Create<WifiPsdu> (newMpdu, false);
---
>           AmpduTag ampdu;
>           m_currentPacket->PeekPacketTag (ampdu);
>           if (ampdu.GetRemainingNbOfMpdus () > 0)
>             {
>               m_txParams.EnableCompressedBlockAck ();
>             }
>           else if (m_currentHdr.IsQosData ())
>             {
>               //VHT/HE single MPDUs are followed by normal ACKs
>               m_txParams.EnableAck ();
>             }
877,881d579
< 
<       // A QoS Txop must have an installed ack policy selector
<       NS_ASSERT (qosTxop->GetAckPolicySelector () != 0);
<       qosTxop->GetAckPolicySelector ()->UpdateTxParams (m_currentPacket, m_txParams);
<       qosTxop->GetAckPolicySelector ()->SetAckPolicy (m_currentPacket, m_txParams);
884,885c582,583
<   NS_LOG_DEBUG ("startTx size=" << m_currentPacket->GetSize () <<
<                 ", to=" << m_currentPacket->GetAddr1 () << ", txop=" << m_currentTxop);
---
>   NS_LOG_DEBUG ("startTx size=" << GetSize (m_currentPacket, &m_currentHdr, m_ampdu) <<
>                 ", to=" << m_currentHdr.GetAddr1 () << ", txop=" << m_currentTxop);
907,1011d604
< //// WIGIG ////
< void
< MacLow::TransmitSingleFrame (Ptr<WifiMacQueueItem> mpdu,
<                              MacLowTransmissionParameters params,
<                              Ptr<Txop> txop)
< {
<   NS_LOG_FUNCTION (this << *mpdu << params << txop);
<   if (m_phy->IsStateOff ())
<     {
<       NS_LOG_DEBUG ("Cannot start TX because device is OFF");
<       return;
<     }
<   m_currentPacket = Create<WifiPsdu> (mpdu, false);
<   CancelAllEvents ();
<   m_currentTxop = txop;
<   m_txParams = params;
<   m_currentTxVector = GetDmgTxVector (mpdu);
<   SendDataPacket ();
< 
<   /* When this method completes, either we have taken ownership of the medium or the device switched off in the meantime. */
<   NS_ASSERT (m_phy->IsStateTx () || m_phy->IsStateOff ());
< }
< 
< void
< MacLow::StartTransmission (Ptr<WifiMacQueueItem> mpdu,
<                            MacLowTransmissionParameters params,
<                            TransmissionOkCallback callback)
< {
<   NS_LOG_FUNCTION (this << *mpdu << params);
<   if (m_phy->IsStateOff ())
<     {
<       NS_LOG_DEBUG ("Cannot start TX because device is OFF");
<       return;
<     }
<   m_currentPacket = Create<WifiPsdu> (mpdu, false);
<   CancelAllEvents ();
<   m_currentTxop = 0;
<   m_transmissionCallback = callback;
<   m_txParams = params;
<   m_currentTxVector = GetDmgTxVector (mpdu);
<   SendDataPacket ();
< 
<   /* When this method completes, either we have taken ownership of the medium or the device switched off in the meantime. */
<   NS_ASSERT (m_phy->IsStateTx () || m_phy->IsStateOff ());
< }
< 
< void
< MacLow::StartShortSswTransmission (Ptr<WifiMacQueueItem> mpdu,
<                            MacLowTransmissionParameters params,
<                            TransmissionShortSswOkCallback callback)
< {
<   NS_LOG_FUNCTION (this << *mpdu << params);
<   if (m_phy->IsStateOff ())
<     {
<       NS_LOG_DEBUG ("Cannot start TX because device is OFF");
<       return;
<     }
<   m_currentPacket = Create<WifiPsdu> (mpdu, false);
<   CancelAllEvents ();
<   m_currentTxop = 0;
<   m_transmissionShortSswCallback = callback;
<   m_txParams = params;
<   m_currentTxVector = GetDmgControlTxVector ();
<   StartDataTxTimers (m_currentTxVector);
< 
<   NS_ASSERT (m_currentPacket->GetNMpdus ());
< 
<   NS_LOG_DEBUG ("send Short SSW, size=" << m_currentPacket->GetSize () <<
<                 ", mode=" << m_currentTxVector.GetMode  () <<
<                 ", preamble=" << m_currentTxVector.GetPreambleType ());
< 
<   NS_LOG_DEBUG ("Sending non aggregate MPDU");
<   m_phy->Send (m_currentPacket, m_currentTxVector);
< 
<   /* When this method completes, either we have taken ownership of the medium or the device switched off in the meantime. */
<   NS_ASSERT (m_phy->IsStateTx () || m_phy->IsStateOff ());
< }
< 
< void
< MacLow::SLS_Phase_Started (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_servingSLS = true;
<   /* We always prioritize SLS over any data transmission, so we cancel any events. */
<   if (m_normalAckTimeoutEvent.IsRunning ())
<     {
<       m_normalAckTimeoutEvent.Cancel ();
<     }
<   if (m_blockAckTimeoutEvent.IsRunning ())
<     {
<       m_blockAckTimeoutEvent.Cancel ();
<     }
<   if (m_sendAckEvent.IsRunning ())
<     {
<       m_sendAckEvent.Cancel ();
<     }
< }
< 
< void
< MacLow::SLS_Phase_Ended (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_servingSLS = false;
< }
< 
1013c606
< MacLow::Is_Performing_SLS (void) const
---
> MacLow::NeedRts (void) const
1015,1042c608,610
<   return m_servingSLS;
< }
< 
< void
< MacLow::MIMO_BFT_Phase_Started (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_servingMimoBFT = true;
<   /* We always prioritize MIMO BFT over any data transmission, so we cancel any events. */
<   if (m_normalAckTimeoutEvent.IsRunning ())
<     {
<       m_normalAckTimeoutEvent.Cancel ();
<     }
<   if (m_blockAckTimeoutEvent.IsRunning ())
<     {
<       m_blockAckTimeoutEvent.Cancel ();
<     }
<   if (m_sendAckEvent.IsRunning ())
<     {
<       m_sendAckEvent.Cancel ();
<     }
< }
< 
< void
< MacLow::MIMO_BFT_Phase_Ended (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_servingMimoBFT = false;
---
>   WifiTxVector dataTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
>   return m_stationManager->NeedRts (m_currentHdr.GetAddr1 (), &m_currentHdr,
>                                     m_currentPacket, dataTxVector);
1046,1052d613
< MacLow::Is_Performing_MIMO_BFT (void) const
< {
<   return m_servingMimoBFT;
< }
< //// WIGIG ////
< 
< bool
1055c616
<   WifiTxVector dataTxVector = GetDataTxVector (*m_currentPacket->begin ());
---
>   WifiTxVector dataTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
1059,1162d619
< bool
< MacLow::IsWithinSizeAndTimeLimits (Ptr<const WifiMacQueueItem> mpdu, WifiTxVector txVector,
<                                     uint32_t ampduSize, Time ppduDurationLimit)
< {
<   NS_ASSERT (mpdu != 0 && mpdu->GetHeader ().IsQosData ());
< 
<   return IsWithinSizeAndTimeLimits (mpdu->GetSize (), mpdu->GetHeader ().GetAddr1 (),
<                                     mpdu->GetHeader ().GetQosTid (), txVector,
<                                     ampduSize, ppduDurationLimit);
< }
< 
< bool
< MacLow::IsWithinSizeAndTimeLimits (uint32_t mpduSize, Mac48Address receiver, uint8_t tid,
<                                     WifiTxVector txVector, uint32_t ampduSize, Time ppduDurationLimit)
< {
<   NS_LOG_FUNCTION (this << mpduSize << receiver << +tid << txVector << ampduSize << ppduDurationLimit);
< 
<   if (ppduDurationLimit != Time::Min () && ppduDurationLimit.IsNegative ())
<     {
<       return false;
<     }
< 
<   WifiModulationClass modulation = txVector.GetMode ().GetModulationClass ();
< 
<   uint32_t maxAmpduSize = 0;
<   if (GetMpduAggregator ())
<     {
<       maxAmpduSize = GetMpduAggregator ()->GetMaxAmpduSize (receiver, tid, modulation);
<     }
< 
<   // If maxAmpduSize is null, then ampduSize must be null as well
<   NS_ASSERT (maxAmpduSize || ampduSize == 0);
< 
<   uint32_t ppduPayloadSize = mpduSize;
< 
<   // compute the correct size for A-MPDUs and S-MPDUs
<   if (ampduSize > 0 || modulation >= WIFI_MOD_CLASS_VHT)
<     {
<       ppduPayloadSize = GetMpduAggregator ()->GetSizeIfAggregated (mpduSize, ampduSize);
<     }
< 
<   if (maxAmpduSize > 0 && ppduPayloadSize > maxAmpduSize)
<     {
<       NS_LOG_DEBUG ("the frame does not meet the constraint on max A-MPDU size");
<       return false;
<     }
< 
<   // Get the maximum PPDU Duration based on the preamble type
<   Time maxPpduDuration = GetPpduMaxTime (txVector.GetPreambleType ());
< 
<   Time txTime = m_phy->CalculateTxDuration (ppduPayloadSize, txVector, m_phy->GetFrequency ());
< 
<   if ((ppduDurationLimit.IsStrictlyPositive () && txTime > ppduDurationLimit)
<       || (maxPpduDuration.IsStrictlyPositive () && txTime > maxPpduDuration))
<     {
<       NS_LOG_DEBUG ("the frame does not meet the constraint on max PPDU duration");
<       return false;
<     }
< 
<   return true;
< }
< 
< void
< MacLow::RxStartIndication (WifiTxVector txVector, Time psduDuration)
< {
<   NS_LOG_FUNCTION (this);
<   NS_LOG_DEBUG ("PSDU reception started for " << psduDuration.ToDouble (Time::US)
<                 << " us (txVector: " << txVector << ")");
<   NS_ASSERT (psduDuration.IsStrictlyPositive ());
< 
<   if (m_normalAckTimeoutEvent.IsRunning ())
<     {
<       // we are waiting for a Normal Ack and something arrived
<       NS_LOG_DEBUG ("Rescheduling Normal Ack timeout");
<       m_normalAckTimeoutEvent.Cancel ();
<       NotifyAckTimeoutResetNow ();
<       m_normalAckTimeoutEvent = Simulator::Schedule (psduDuration + NanoSeconds (PSDU_DURATION_SAFEGUARD),
<                                                      &MacLow::NormalAckTimeout, this);
<     }
<   else if (m_blockAckTimeoutEvent.IsRunning ())
<     {
<       // we are waiting for a BlockAck and something arrived
<       NS_LOG_DEBUG ("Rescheduling Block Ack timeout");
<       m_blockAckTimeoutEvent.Cancel ();
<       NotifyAckTimeoutResetNow ();
<       m_blockAckTimeoutEvent = Simulator::Schedule (psduDuration + NanoSeconds (PSDU_DURATION_SAFEGUARD),
<                                                     &MacLow::BlockAckTimeout, this);
<     }
<   else if (m_ctsTimeoutEvent.IsRunning ())
<     {
<       // we are waiting for a CTS and something arrived
<       NS_LOG_DEBUG ("Rescheduling CTS timeout");
<       m_ctsTimeoutEvent.Cancel ();
<       NotifyCtsTimeoutResetNow ();
<       m_ctsTimeoutEvent = Simulator::Schedule (psduDuration + NanoSeconds (PSDU_DURATION_SAFEGUARD),
<                                                &MacLow::CtsTimeout, this);
<     }
<   else if (m_navCounterResetCtsMissed.IsRunning ())
<     {
<       NS_LOG_DEBUG ("Cannot reset NAV");
<       m_navCounterResetCtsMissed.Cancel ();
<     }
< }
< 
1164c621
< MacLow::ReceiveError (Ptr<WifiPsdu> psdu)
---
> MacLow::ReceiveError (Ptr<Packet> packet, double rxSnr)
1166c623
<   NS_LOG_FUNCTION (this << *psdu);
---
>   NS_LOG_FUNCTION (this << packet << rxSnr);
1168c625
<   if (IsCfPeriod () && m_currentPacket->GetHeader (0).IsCfPoll ())
---
>   if (IsCfPeriod () && m_currentHdr.IsCfPoll ())
1231,1249c688
< MacLow::ReceiveShortSswOk (Ptr<WifiMacQueueItem> mpdu, double rxSnr, WifiTxVector txVector, bool ampduSubframe)
< {
<   NS_LOG_FUNCTION (this << *mpdu << rxSnr << txVector);
<   /* An MPDU containing a Short SSW packet is received from the PHY.
<    */  
<   Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
< 
<   /* To do: Set the NAV to account for the duration of the whole SISO period in MU-MIMO BFT */
< //  bool isPrevNavZero = IsNavZero ();
< //  NS_LOG_DEBUG ("duration/id=" << hdr.GetDuration ());
< //  NotifyNav (packet, hdr);
< 
<   Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<   wifiMac->ReceiveShortSswFrame (packet, rxSnr);
<   return;
< }
< 
< void
< MacLow::ReceiveOk (Ptr<WifiMacQueueItem> mpdu, double rxSnr, WifiTxVector txVector, bool ampduSubframe)
---
> MacLow::ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, bool ampduSubframe)
1251,1253c690,692
<   NS_LOG_FUNCTION (this << *mpdu << rxSnr << txVector);
<   /* An MPDU is received from the PHY.
<    * When we have handled this MPDU,
---
>   NS_LOG_FUNCTION (this << packet << rxSnr << txVector.GetMode () << txVector.GetPreambleType ());
>   /* A packet is received from the PHY.
>    * When we have handled this packet,
1257,1258c696,697
<   const WifiMacHeader& hdr = mpdu->GetHeader ();
<   Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
---
>   WifiMacHeader hdr;
>   packet->RemoveHeader (hdr);
1284,1312c723,728
<               if ((m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ad) || (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay))
<                 {
<                   m_sendCtsEvent = Simulator::Schedule (GetSifs (),
<                                                         &MacLow::SendDmgCtsAfterRts, this,
<                                                         hdr.GetAddr2 (),
<                                                         hdr.GetDuration (),
<                                                         txVector,
<                                                         rxSnr);
<                   if (txVector.IsControlTrailerPresent ())
<                     {
<                       ControlTrailer ct;
<                       Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
<                       packet->RemoveHeader (ct);
<                       if (ct.IsMimoTransmission () && (!ct.IsMuMimoTransmission ()))
<                         {
<                           Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<                           wifiMac->UpdateBestMimoRxAntennaConfigurationIndex (hdr.GetAddr2 (), ct.GetTxSectorCombinationIdx ());
<                         }
<                     }
<                 }
<               else
<                 {
<                   m_sendCtsEvent = Simulator::Schedule (GetSifs (),
<                                                         &MacLow::SendCtsAfterRts, this,
<                                                         hdr.GetAddr2 (),
<                                                         hdr.GetDuration (),
<                                                         txVector,
<                                                         rxSnr);
<                 }
---
>               m_sendCtsEvent = Simulator::Schedule (GetSifs (),
>                                                     &MacLow::SendCtsAfterRts, this,
>                                                     hdr.GetAddr2 (),
>                                                     hdr.GetDuration (),
>                                                     txVector,
>                                                     rxSnr);
1320c736
<   else if ((hdr.IsCts () || hdr.IsDmgCts ())
---
>   else if (hdr.IsCts ()
1330c746
<       NS_LOG_DEBUG ("received cts from=" << m_currentPacket->GetAddr1 ());
---
>       NS_LOG_DEBUG ("received cts from=" << m_currentHdr.GetAddr1 ());
1334c750
<       m_stationManager->ReportRxOk (m_currentPacket->GetAddr1 (), &hdr,
---
>       m_stationManager->ReportRxOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
1336c752
<       m_stationManager->ReportRtsOk (m_currentPacket->GetAddr1 (), &m_currentPacket->GetHeader (0),
---
>       m_stationManager->ReportRtsOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
1345,1359d760
<       if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<         {
<           if (txVector.IsControlTrailerPresent ())
<             {
<               ControlTrailer ct;
<               Ptr<Packet> packet = mpdu->GetPacket ()-> Copy ();
<               packet->RemoveHeader (ct);
<               if (ct.IsMimoTransmission () && (!ct.IsMuMimoTransmission ()))
<                 {
<                   Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<                   wifiMac->UpdateBestMimoRxAntennaConfigurationIndex (hdr.GetAddr2 (), ct.GetTxSectorCombinationIdx ());
<                   wifiMac->SteerMimoRxAntennaToward (hdr.GetAddr2 ());
<                 }
<             }
<         }
1366c767
<       NS_LOG_DEBUG ("receive ack from=" << m_currentPacket->GetAddr1 ());
---
>       NS_LOG_DEBUG ("receive ack from=" << m_currentHdr.GetAddr1 ());
1372c773
<           m_stationManager->ReportRxOk (m_currentPacket->GetAddr1 (), &hdr,
---
>           m_stationManager->ReportRxOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
1374c775
<           m_stationManager->ReportDataOk (m_currentPacket->GetAddr1 (), &m_currentPacket->GetHeader (0),
---
>           m_stationManager->ReportDataOk (m_currentHdr.GetAddr1 (), &m_currentHdr,
1376c777
<                                           m_currentTxVector, m_currentPacket->GetSize ());
---
>                                           m_currentPacket->GetSize ());
1378,1383c779,791
<       // cancel the Normal Ack timer
<       m_normalAckTimeoutEvent.Cancel ();
<       NotifyAckTimeoutResetNow ();
<       m_currentTxop->GotAck ();
< 
<       if (m_txParams.HasNextPacket ())
---
>       bool gotAck = false;
>       if (m_txParams.MustWaitNormalAck ()
>           && m_normalAckTimeoutEvent.IsRunning ())
>         {
>           m_normalAckTimeoutEvent.Cancel ();
>           NotifyAckTimeoutResetNow ();
>           gotAck = true;
>         }
>       if (gotAck)
>         {
>           m_currentTxop->GotAck ();
>         }
>       if (m_txParams.HasNextPacket () && (!m_currentHdr.IsQosData () || m_currentTxop->GetTxopLimit ().IsZero () || m_currentTxop->HasTxop ()))
1394,1399c802
<       else if (m_currentPacket->GetHeader (0).IsQosData () && m_currentTxop->IsQosTxop () &&
<                m_currentTxop->GetTxopLimit ().IsStrictlyPositive ()
<                //// WIGIG ////
<                //&& m_currentTxop->GetTxopRemaining () > GetSifs ()
<                && m_currentTxop->GetRemainingTimeForTransmission () > GetSifs ())
<                //// WIGIG ////
---
>       else if (m_currentHdr.IsQosData () && m_currentTxop->HasTxop ())
1410c813,814
<       else if (m_currentTxop->IsQosTxop ())
---
>       m_ampdu = false;
>       if (m_currentHdr.IsQosData ())
1412c816
<           m_currentTxop->TerminateTxop ();
---
>           FlushAggregateQueue (m_currentHdr.GetQosTid ());
1414,1415d817
<       /* WIGIG: Set the current packet to zero to avoid storing it for the next access period */
<       m_currentPacket = 0; //// WIGIG ////
1418c820
<            && m_txParams.MustWaitBlockAck ()
---
>            && (m_txParams.MustWaitBasicBlockAck () || m_txParams.MustWaitCompressedBlockAck ())
1423a826
>       FlushAggregateQueue (GetTid (packet, hdr));
1428,1434c831,833
<       m_currentTxop->GotBlockAck (&blockAck, hdr.GetAddr2 (), rxSnr, tag.Get (), m_currentTxVector);
<       // start next packet if TXOP remains, otherwise contend for accessing the channel again
<       if (m_currentTxop->IsQosTxop () && m_currentTxop->GetTxopLimit ().IsStrictlyPositive ()
<           //// WIGIG ////
<           //&& m_currentTxop->GetTxopRemaining () > GetSifs ()
<           && m_currentTxop->GetRemainingTimeForTransmission () > GetSifs ())
<           //// WIGIG ////
---
>       m_currentTxop->GotBlockAck (&blockAck, hdr.GetAddr2 (), rxSnr, txVector.GetMode (), tag.Get ());
>       m_ampdu = false;
>       if (m_currentHdr.IsQosData () && m_currentTxop->HasTxop ())
1445,1450d843
<       else if (m_currentTxop->IsQosTxop ())
<         {
<           m_currentTxop->TerminateTxop ();
<         }
<       /* WIGIG: Set the current packet to zero to avoid storing it for the next access period */
<       m_currentPacket = 0; //// WIGIG ////
1454,1463d846
<       if (m_servingSLS)
<         {
<           NS_LOG_DEBUG ("We are serving SLS, so ignore BlockAckRequest frame");
<           return;
<         }
<       if (m_servingMimoBFT)
<         {
<           NS_LOG_DEBUG ("We are serving MIMO BFT, so ignore BlockAckRequest frame");
<           return;
<         }
1477c860
<               NS_ASSERT (m_sendAckEvent.IsExpired ());
---
>               //NS_ASSERT (m_sendAckEvent.IsExpired ());
1507,1520d889
<   //// WIGIG ////
<   else if (hdr.IsDMGBeacon ())
<     {
<       NS_LOG_DEBUG ("Received DMG Beacon with BSSID=" << hdr.GetAddr1 ());
<       m_stationManager->ReportRxOk (hdr.GetAddr1 (), &hdr, rxSnr, txVector.GetMode ());
<       goto rxPacket;
<     }
<   else if ((hdr.GetAddr1 () == m_self) && (hdr.IsSSW () || hdr.IsSSW_FBCK () || hdr.IsSSW_ACK ()))
<     {
<       NS_LOG_DEBUG ("Received " << hdr.GetTypeString ());
<       m_stationManager->ReportRxOk (hdr.GetAddr2 (), &hdr, rxSnr, txVector.GetMode ());
<       goto rxPacket;
<     }
<   //// WIGIG ////
1564,1581d932
<       if (m_servingSLS)
<         {
<           NS_LOG_DEBUG ("We are serving SLS, so ignore any data or management frame");
<           if (m_sendAckEvent.IsRunning ())
<             {
<               m_sendAckEvent.Cancel ();
<             }
<           return;
<         }
<       if (m_servingMimoBFT && (hdr.IsData () || hdr.IsBlockAck ()))
<         {
<           NS_LOG_DEBUG ("We are serving MIMO BFT, so ignore any data or management frame that's not part of it");
<           if (m_sendAckEvent.IsRunning ())
<             {
<               m_sendAckEvent.Cancel ();
<             }
<           return;
<         }
1584,1589c935
<       if (hdr.IsActionNoAck ())
<         {
<           NS_LOG_DEBUG ("Received Action No ACK Frame");
<           goto rxPacket;
<         }
<       else if (hdr.IsQosData () && ReceiveMpdu (mpdu))
---
>       if (hdr.IsQosData () && ReceiveMpdu (packet, hdr))
1593c939
<              the block ack agreement exists, the recipient shall buffer the MSDU
---
>              the Block Ack agreement exists, the recipient shall buffer the MSDU
1604,1610c950
<               NS_ASSERT (m_sendAckEvent.IsExpired ()); //// WIGIG ////
< //// WIGIG ////
<              // if (m_sendAckEvent.IsRunning ())
<              //   {
<              //    m_sendAckEvent.Cancel ();
<              //  }
< //// WIGIG ////
---
>               NS_ASSERT (m_sendAckEvent.IsExpired ());
1632c972
<              When a recipient does not have an active block ack for a TID, but receives
---
>              When a recipient does not have an active Block ack for a TID, but receives
1659d998
<               mpdu = Create<WifiMacQueueItem> (packet, hdr);
1686,1689d1024
<               //else  //// WIGIG ////
<               //  {
<               //    return;
<               //  }
1711d1045
<                   mpdu = Create<WifiMacQueueItem> (packet, hdr);
1733,1737d1066
<       else if (m_servingMimoBFT && hdr.GetAddr1 () == hdr.GetAddr2 ())
<         {
<           NS_LOG_INFO ("During MIMO BF Training phase of MU-MIMO BFT the Initiator sets the TA and RA fields to his own address");
<           goto rxPacket;
<         }
1748c1077,1079
<   m_rxCallback (mpdu);
---
>   WifiMacTrailer fcs;
>   packet->RemoveTrailer (fcs);
>   m_rxCallback (packet, &hdr);
1777c1108
<   NS_ASSERT (ackTxVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HT); //Ack should always use non-HT PPDU (HT PPDU cases not supported yet)
---
>   NS_ASSERT (ackTxVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HT); //ACK should always use non-HT PPDU (HT PPDU cases not supported yet)
1792,1798c1123
< MacLow::GetBlockAckRequestDuration (WifiTxVector blockAckReqTxVector, BlockAckType type) const
< {
<   return m_phy->CalculateTxDuration (GetBlockAckRequestSize (type), blockAckReqTxVector, m_phy->GetFrequency ());
< }
< 
< Time
< MacLow::GetCtsDuration (Mac48Address to, WifiTxVector rtsTxVector, bool addControlTrailer) const
---
> MacLow::GetCtsDuration (Mac48Address to, WifiTxVector rtsTxVector) const
1800,1810c1125,1126
<   //// WIGIG ////
<   if ((rtsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_CTRL || rtsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL))
<     {
<       return GetDmgCtsDuration (addControlTrailer);
<     }
<   else
<     //// WIGIG ////
<     {
<       WifiTxVector ctsTxVector = GetCtsTxVectorForRts (to, rtsTxVector.GetMode ());
<       return GetCtsDuration (ctsTxVector);
<     }
---
>   WifiTxVector ctsTxVector = GetCtsTxVectorForRts (to, rtsTxVector.GetMode ());
>   return GetCtsDuration (ctsTxVector);
1820,1854d1135
< //// WIGIG ////
< Time
< MacLow::GetDmgControlDuration (WifiTxVector txVector, uint32_t payloadSize) const
< {
<   NS_ASSERT (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_CTRL || txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL);
<   return m_phy->CalculateTxDuration (payloadSize, txVector, m_phy->GetFrequency ());
< }
< 
< Time
< MacLow::GetDmgCtsDuration (bool addControlTrailer) const
< {
<   WifiTxVector ctsTxVector = GetDmgControlTxVector ();
<   NS_ASSERT (ctsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_CTRL || ctsTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL);
<   return m_phy->CalculateTxDuration (GetDmgCtsSize (addControlTrailer), ctsTxVector, m_phy->GetFrequency ());
< }
< 
< uint32_t
< MacLow::GetDmgCtsSize (bool addControlTrailer)
< {
<   WifiMacHeader cts;
<   cts.SetType (WIFI_MAC_CTL_DMG_CTS);
<   uint32_t dmgCtsSize = cts.GetSize () + 4;
<   if (addControlTrailer)
<     dmgCtsSize+= 18;
<   return dmgCtsSize;
< }
< 
< WifiTxVector
< MacLow::GetDmgTxVector (Ptr<const WifiMacQueueItem> item) const
< {
<   Mac48Address to = item->GetHeader ().GetAddr1 ();
<   return m_stationManager->GetDmgTxVector (to, &item->GetHeader (), item->GetPacket ());
< }
< //// WIGIG ////
< 
1856c1137
< MacLow::GetRtsTxVector (Ptr<const WifiMacQueueItem> item) const
---
> MacLow::GetRtsTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
1858c1139,1140
<   return m_stationManager->GetRtsTxVector (item->GetHeader ().GetAddr1 ());
---
>   Mac48Address to = hdr->GetAddr1 ();
>   return m_stationManager->GetRtsTxVector (to, hdr, packet);
1862,1896c1144
< MacLow::GetDataTxVector (Ptr<const WifiMacQueueItem> item) const
< {
<   return m_stationManager->GetDataTxVector (item->GetHeader ());
< }
< 
< Time
< MacLow::GetResponseDuration (const MacLowTransmissionParameters& params, WifiTxVector dataTxVector,
<                              Mac48Address receiver) const
< {
<   NS_LOG_FUNCTION (this << receiver << dataTxVector << params);
< 
<   Time duration = Seconds (0);
<   if (params.MustWaitNormalAck ())
<     {
<       duration += GetSifs ();
<       duration += GetAckDuration (receiver, dataTxVector);
<     }
<   else if (params.MustWaitBlockAck ())
<     {
<       duration += GetSifs ();
<       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_self, dataTxVector.GetMode ());
<       duration += GetBlockAckDuration (blockAckReqTxVector, params.GetBlockAckType ());
<     }
<   else if (params.MustSendBlockAckRequest ())
<     {
<       duration += 2 * GetSifs ();
<       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_self, dataTxVector.GetMode ());
<       duration += GetBlockAckRequestDuration (blockAckReqTxVector, params.GetBlockAckRequestType ());
<       duration += GetBlockAckDuration (blockAckReqTxVector, params.GetBlockAckRequestType ());
<     }
<   return duration;
< }
< 
< WifiMode
< MacLow::GetControlAnswerMode (WifiMode reqMode) const
---
> MacLow::GetDataTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const
1898,2059c1146,1147
<   NS_LOG_FUNCTION (this << reqMode);
<   WifiMode mode = m_stationManager->GetDefaultMode ();
<   bool found = false;
<   if (m_stationManager->HasDmgSupported () || m_stationManager->HasEdmgSupported ())   //// WIGIG ////
<     {
<       /**
<        * Rules for selecting a control response rate from IEEE 802.11ad-2012,
<        * Section 9.7.5a Multirate support for DMG STAs:
<        */
<       WifiMode thismode;
<       /* We start from SC PHY Rates, This is for transmitting an ACK frame or a BA frame */
<       for (uint32_t idx = 0; idx < m_phy->GetNModes (); idx++)
<         {
<           thismode = m_phy->GetMode (idx);
<           if (thismode.IsMandatory () && (thismode.GetDataRate () <= reqMode.GetDataRate ()))
<             {
<               mode = thismode;
<               found = true;
<             }
<           else
<             {
<               break;
<             }
<         }
<     }
<   else
<     {
<       /**
<        * The standard has relatively unambiguous rules for selecting a
<        * control response rate (the below is quoted from IEEE 802.11-2012,
<        * Section 9.7):
<        *
<        * To allow the transmitting STA to calculate the contents of the
<        * Duration/ID field, a STA responding to a received frame shall
<        * transmit its Control Response frame (either CTS or Ack), other
<        * than the BlockAck control frame, at the highest rate in the
<        * BSSBasicRateSet parameter that is less than or equal to the
<        * rate of the immediately previous frame in the frame exchange
<        * sequence (as defined in Annex G) and that is of the same
<        * modulation class (see Section 9.7.8) as the received frame...
<        */
<       //First, search the BSS Basic Rate set
<       for (uint8_t i = 0; i < m_stationManager->GetNBasicModes (); i++)
<         {
<           WifiMode testMode = m_stationManager->GetBasicMode (i);
<           if ((!found || testMode.IsHigherDataRate (mode))
<               && (!testMode.IsHigherDataRate (reqMode))
<               && (IsAllowedControlAnswerModulationClass (reqMode.GetModulationClass (), testMode.GetModulationClass ())))
<             {
<               mode = testMode;
<               //We've found a potentially-suitable transmit rate, but we
<               //need to continue and consider all the basic rates before
<               //we can be sure we've got the right one.
<               found = true;
<             }
<         }
<       if (m_stationManager->GetHtSupported ())
<         {
<           if (!found)
<             {
<               mode = m_stationManager->GetDefaultMcs ();
<               for (uint8_t i = 0; i != m_stationManager->GetNBasicMcs (); i++)
<                 {
<                   WifiMode testMode = m_stationManager->GetBasicMcs (i);
<                   if ((!found || testMode.IsHigherDataRate (mode))
<                       && (!testMode.IsHigherDataRate (reqMode))
<                       && (testMode.GetModulationClass () == reqMode.GetModulationClass ()))
<                     {
<                       mode = testMode;
<                       //We've found a potentially-suitable transmit rate, but we
<                       //need to continue and consider all the basic rates before
<                       //we can be sure we've got the right one.
<                       found = true;
<                     }
<                 }
<             }
<         }
<       //If we found a suitable rate in the BSSBasicRateSet, then we are
<       //done and can return that mode.
<       if (found)
<         {
<           NS_LOG_DEBUG ("MacLow::GetControlAnswerMode returning " << mode);
<           return mode;
<         }
< 
<       /**
<        * If no suitable basic rate was found, we search the mandatory
<        * rates. The standard (IEEE 802.11-2007, Section 9.6) says:
<        *
<        *   ...If no rate contained in the BSSBasicRateSet parameter meets
<        *   these conditions, then the control frame sent in response to a
<        *   received frame shall be transmitted at the highest mandatory
<        *   rate of the PHY that is less than or equal to the rate of the
<        *   received frame, and that is of the same modulation class as the
<        *   received frame. In addition, the Control Response frame shall
<        *   be sent using the same PHY options as the received frame,
<        *   unless they conflict with the requirement to use the
<        *   BSSBasicRateSet parameter.
<        *
<        * \todo Note that we're ignoring the last sentence for now, because
<        * there is not yet any manipulation here of PHY options.
<        */
<       for (uint8_t idx = 0; idx < m_phy->GetNModes (); idx++)
<         {
<           WifiMode thismode = m_phy->GetMode (idx);
<           /* If the rate:
<            *
<            *  - is a mandatory rate for the PHY, and
<            *  - is equal to or faster than our current best choice, and
<            *  - is less than or equal to the rate of the received frame, and
<            *  - is of the same modulation class as the received frame
<            *
<            * ...then it's our best choice so far.
<            */
<           if (thismode.IsMandatory ()
<               && (!found || thismode.IsHigherDataRate (mode))
<               && (!thismode.IsHigherDataRate (reqMode))
<               && (IsAllowedControlAnswerModulationClass (reqMode.GetModulationClass (), thismode.GetModulationClass ())))
<             {
<               mode = thismode;
<               //As above; we've found a potentially-suitable transmit
<               //rate, but we need to continue and consider all the
<               //mandatory rates before we can be sure we've got the right one.
<               found = true;
<             }
<         }
<       if (m_stationManager->GetHtSupported () )
<         {
<           for (uint8_t idx = 0; idx < m_phy->GetNMcs (); idx++)
<             {
<               WifiMode thismode = m_phy->GetMcs (idx);
<               if (thismode.IsMandatory ()
<                   && (!found || thismode.IsHigherDataRate (mode))
<                   && (!thismode.IsHigherCodeRate (reqMode))
<                   && (thismode.GetModulationClass () == reqMode.GetModulationClass ()))
<                 {
<                   mode = thismode;
<                   //As above; we've found a potentially-suitable transmit
<                   //rate, but we need to continue and consider all the
<                   //mandatory rates before we can be sure we've got the right one.
<                   found = true;
<                 }
<             }
<         }
<     }
< 
<   /**
<    * If we still haven't found a suitable rate for the response then
<    * someone has messed up the simulation configuration. This probably means
<    * that the WifiPhyStandard is not set correctly, or that a rate that
<    * is not supported by the PHY has been explicitly requested.
<    *
<    * Either way, it is serious - we can either disobey the standard or
<    * fail, and I have chosen to do the latter...
<    */
<   if (!found)
<     {
<       NS_FATAL_ERROR ("Can't find response rate for " << reqMode);
<     }
< 
<   NS_LOG_DEBUG ("MacLow::GetControlAnswerMode returning " << mode);
<   return mode;
---
>   Mac48Address to = hdr->GetAddr1 ();
>   return m_stationManager->GetDataTxVector (to, hdr, packet);
2065,2079c1153
<   NS_ASSERT (!to.IsGroup ());
<   WifiMode ctsMode = GetControlAnswerMode (rtsTxMode);
<   WifiTxVector v;
<   v.SetMode (ctsMode);
<   v.SetPreambleType (GetPreambleForTransmission (ctsMode.GetModulationClass (), m_stationManager->GetShortPreambleEnabled (), m_stationManager->UseGreenfieldForDestination (to)));
<   v.SetTxPowerLevel (m_stationManager->GetDefaultTxPowerLevel ());
<   v.SetChannelWidth (GetChannelWidthForTransmission (ctsMode, m_phy->GetChannelWidth ()));
<    uint16_t ctsTxGuardInterval = ConvertGuardIntervalToNanoSeconds (ctsMode, m_phy->GetShortGuardInterval (), m_phy->GetGuardInterval ());
<   v.SetGuardInterval (ctsTxGuardInterval);
<   v.SetNss (1);
<   if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<     {
<       v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_phy)->GetChannelConfiguration ());
<     }
<   return v;
---
>   return m_stationManager->GetCtsTxVector (to, rtsTxMode);
2085,2108c1159
<   NS_ASSERT (!to.IsGroup ());
<   WifiMode ackMode = GetControlAnswerMode (dataTxMode);
<   WifiTxVector v;
<   v.SetMode (ackMode);
<   v.SetPreambleType (GetPreambleForTransmission (ackMode.GetModulationClass (), m_stationManager->GetShortPreambleEnabled (), m_stationManager->UseGreenfieldForDestination (to)));
<   v.SetTxPowerLevel (m_stationManager->GetDefaultTxPowerLevel ());
<   v.SetChannelWidth (GetChannelWidthForTransmission (ackMode, m_phy->GetChannelWidth ()));
<    uint16_t ackTxGuardInterval = ConvertGuardIntervalToNanoSeconds (ackMode, m_phy->GetShortGuardInterval (), m_phy->GetGuardInterval ());
<   v.SetGuardInterval (ackTxGuardInterval);
<   v.SetNss (1);
<   //// WIGIG ////
<   if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<     {
<       v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_phy)->GetChannelConfiguration ());
<     }
<   //// WIGIG ////
<   return v;
< }
< 
< //// WIGIG ////
< WifiTxVector
< MacLow::GetDmgControlTxVector (void) const
< {
<   return m_stationManager->GetDmgControlTxVector ();
---
>   return m_stationManager->GetAckTxVector (to, dataTxMode);
2110d1160
< //// WIGIG ////
2115,2131c1165
<   NS_ASSERT (!to.IsGroup ());
<   WifiMode blockAckMode = GetControlAnswerMode (dataTxMode);
<   WifiTxVector v;
<   v.SetMode (blockAckMode);
<   v.SetPreambleType (GetPreambleForTransmission (blockAckMode.GetModulationClass (), m_stationManager->GetShortPreambleEnabled (), m_stationManager->UseGreenfieldForDestination (to)));
<   v.SetTxPowerLevel (m_stationManager->GetDefaultTxPowerLevel ());
<   v.SetChannelWidth (GetChannelWidthForTransmission (blockAckMode, m_phy->GetChannelWidth ()));
<   uint16_t blockAckTxGuardInterval = ConvertGuardIntervalToNanoSeconds (blockAckMode, m_phy->GetShortGuardInterval (), m_phy->GetGuardInterval ());
<   v.SetGuardInterval (blockAckTxGuardInterval);
<   v.SetNss (1);
<   //// WIGIG ////
<   if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<     {
<       v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_phy)->GetChannelConfiguration ());
<     }
<   //// WIGIG ////
<   return v;
---
>   return m_stationManager->GetBlockAckTxVector (to, dataTxMode);
2152,2153c1186,1194
<   Ptr<const WifiMacQueueItem> item = Create<const WifiMacQueueItem> (packet, *hdr);
<   Time txTime = CalculateOverheadTxTime (item, params);
---
>   Time txTime = Seconds (0);
>   if (params.MustSendRts ())
>     {
>       WifiTxVector rtsTxVector = GetRtsTxVector (packet, hdr);
>       txTime += m_phy->CalculateTxDuration (GetRtsSize (), rtsTxVector, m_phy->GetFrequency ());
>       txTime += GetCtsDuration (hdr->GetAddr1 (), rtsTxVector);
>       txTime += Time (GetSifs () * 2);
>     }
>   WifiTxVector dataTxVector = GetDataTxVector (packet, hdr);
2158c1199
<       dataSize = GetSize (fragment, hdr, m_currentPacket && m_currentPacket->IsAggregate ());
---
>       dataSize = GetSize (fragment, hdr, m_ampdu);
2162c1203
<       dataSize = GetSize (packet, hdr, m_currentPacket && m_currentPacket->IsAggregate ());
---
>       dataSize = GetSize (packet, hdr, m_ampdu);
2164,2173c1205,1207
<   txTime += m_phy->CalculateTxDuration (dataSize, GetDataTxVector (item), m_phy->GetFrequency ());
<   return txTime;
< }
< 
< Time
< MacLow::CalculateOverheadTxTime (Ptr<const WifiMacQueueItem> item,
<                                  const MacLowTransmissionParameters& params) const
< {
<   Time txTime = Seconds (0);
<   if (params.MustSendRts ())
---
>   txTime += m_phy->CalculateTxDuration (dataSize, dataTxVector, m_phy->GetFrequency ());
>   txTime += GetSifs ();
>   if (params.MustWaitNormalAck ())
2175,2178c1209
<       WifiTxVector rtsTxVector = GetRtsTxVector (item);
<       txTime += m_phy->CalculateTxDuration (GetRtsSize (), rtsTxVector, m_phy->GetFrequency ());
<       txTime += GetCtsDuration (item->GetHeader ().GetAddr1 (), rtsTxVector);
<       txTime += Time (GetSifs () * 2);
---
>       txTime += GetAckDuration (hdr->GetAddr1 (), dataTxVector);
2180,2181d1210
<   txTime += GetResponseDuration (params, GetDataTxVector (item), item->GetHeader ().GetAddr1 ());
< 
2193c1222
<       WifiTxVector dataTxVector = GetDataTxVector (Create<const WifiMacQueueItem> (packet, *hdr));
---
>       WifiTxVector dataTxVector = GetDataTxVector (packet, hdr);
2200,2220d1228
< //// WIGIG ////
< Time
< MacLow::CalculateWiGigTransactionTime (Ptr<WifiPsdu> psdu)
< {
<   NS_LOG_FUNCTION (this << psdu);
<   Time txTime = m_phy->CalculateTxDuration (psdu->GetSize (), m_currentTxVector, m_phy->GetFrequency ());
<   /* Calculate overhead duration */
<   if (m_txParams.MustSendRts ())
<     {
<       WifiTxVector rtsTxVector = GetDmgControlTxVector ();
<       txTime += m_phy->CalculateTxDuration (GetRtsSize (), rtsTxVector, m_phy->GetFrequency ());
<       txTime += GetCtsDuration (psdu->GetAddr1 (), rtsTxVector);
<       txTime += Time (GetSifs () * 2);
<     }
<   txTime += GetResponseDuration (m_txParams, m_currentTxVector, psdu->GetAddr1 ());
<   /* Convert to MicroSeconds since the duration in the headers are in MicroSeconds */
<   return MicroSeconds (ceil ((double) txTime.GetNanoSeconds () / 1000));
<   return Seconds (0);
< }
< //// WIGIG ////
< 
2231,2238c1239
<   Time duration = hdr.GetDuration ();
<   if (hdr.IsCfPoll () && hdr.GetAddr2 () == m_bssid)
<     {
<       //see section 9.3.2.2 802.11-1999
<       DoNavResetNow (duration);
<       return;
<     }
<   else if (hdr.IsCfEnd () && hdr.GetAddr2 () == m_bssid)
---
>   if (hdr.IsCfEnd () && hdr.GetAddr2 () == m_bssid)
2246,2258d1246
<       if (hdr.IsGrantFrame ())
<         {
<           // see section 9.33.7.3 802.11ad-2012
<           Ptr<Packet> newPacket = packet->Copy ();
<           CtrlDMG_Grant grant;
<           newPacket->RemoveHeader (grant);
<           Ptr<DmgStaWifiMac> highMac = DynamicCast<DmgStaWifiMac> (m_mac);
<           if (grant.GetDynamicAllocationInfo ().GetSourceAID () == highMac->GetAssociationID () ||
<               grant.GetDynamicAllocationInfo ().GetDestinationAID () == highMac->GetAssociationID ())
<             {
<               return;
<             }
<         }
2259a1248
>       Time duration = hdr.GetDuration ();
2266,2269c1255,1258
<            * period with a duration of (2 * aSIFSTime) + (CTS_Time) + aRxPHYStartDelay + (2 * aSlotTime)
<            * starting at the PHY-RXEND.indication corresponding to the detection of the RTS frame. The
<            * “CTS_Time” shall be calculated using the length of the CTS frame and the data rate at which
<            * the RTS frame used for the most recent NAV update was received.
---
>            * period with a duration of (2 * aSIFSTime) + (CTS_Time) + (2 * aSlotTime) starting at the
>            * PHY-RXEND.indication corresponding to the detection of the RTS frame. The “CTS_Time” shall
>            * be calculated using the length of the CTS frame and the data rate at which the RTS frame
>            * used for the most recent NAV update was received.
2273c1262
<           WifiTxVector txVector = GetRtsTxVector (Create<const WifiMacQueueItem> (packet, hdr));
---
>           WifiTxVector txVector = GetRtsTxVector (packet, &hdr);
2276,2277c1265
<             Time (2 * GetSifs ()) + Time (2 * GetSlotTime ()) +
<             m_phy->CalculatePhyPreambleAndHeaderDuration (txVector);
---
>             Time (2 * GetSifs ()) + Time (2 * GetSlotTime ());
2279,2280c1267,1268
<                                                             &MacLow::DoNavResetNow, this,
<                                                             Seconds (0));
---
>                                                             &MacLow::NavCounterResetCtsMissed, this,
>                                                             Simulator::Now ());
2285a1274,1282
> MacLow::NavCounterResetCtsMissed (Time rtsEndRxTime)
> {
>   if (m_phy->GetLastRxStartTime () < rtsEndRxTime)
>     {
>       DoNavResetNow (Seconds (0));
>     }
> }
> 
> void
2325c1322
< MacLow::NotifyAckTimeoutResetNow (void)
---
> MacLow::NotifyAckTimeoutResetNow ()
2343c1340
< MacLow::NotifyCtsTimeoutResetNow (void)
---
> MacLow::NotifyCtsTimeoutResetNow ()
2352c1349
< MacLow::ForwardDown (Ptr<const WifiPsdu> psdu, WifiTxVector txVector)
---
> MacLow::ForwardDown (Ptr<const Packet> packet, const WifiMacHeader* hdr, WifiTxVector txVector)
2354,2361c1351,1354
<   NS_LOG_FUNCTION (this << psdu << txVector);
< 
<   NS_ASSERT (psdu->GetNMpdus ());
<   const WifiMacHeader& hdr = (*psdu->begin ())->GetHeader ();
< 
<   NS_LOG_DEBUG ("send " << hdr.GetTypeString () <<
<                 ", to=" << hdr.GetAddr1 () <<
<                 ", size=" << psdu->GetSize () <<
---
>   NS_LOG_FUNCTION (this << packet << hdr << txVector);
>   NS_LOG_DEBUG ("send " << hdr->GetTypeString () <<
>                 ", to=" << hdr->GetAddr1 () <<
>                 ", size=" << packet->GetSize () <<
2364,2369c1357,1359
<                 ", duration=" << hdr.GetDuration () <<
<                 ", seq=0x" << std::hex << hdr.GetSequenceControl () << std::dec);
< 
<   //// WIGIG ////
<   /* Antenna steering */
<   if ((m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ad) || (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay))
---
>                 ", duration=" << hdr->GetDuration () <<
>                 ", seq=0x" << std::hex << m_currentHdr.GetSequenceControl () << std::dec);
>   if (!m_ampdu || hdr->IsAck () || hdr->IsRts () || hdr->IsCts () || hdr->IsBlockAck () || hdr->IsMgt ())
2371,2374c1361
<       Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<       /* Change antenna configuration */
<       if (((wifiMac->GetCurrentAccessPeriod () == CHANNEL_ACCESS_DTI) && (wifiMac->GetCurrentAllocation () == CBAP_ALLOCATION))
<           || (wifiMac->GetCurrentAccessPeriod () == CHANNEL_ACCESS_ATI))
---
>       if (hdr->IsCfPoll () && m_stationManager->HasPcfSupported ())
2376,2383c1363
<           if ((wifiMac->GetTypeOfStation () == DMG_AP) && (hdr.IsAck () || hdr.IsBlockAck ()))
<             {
<               wifiMac->SteerTxAntennaToward (hdr.GetAddr1 (), (false));
<             }
<           else if (!(hdr.IsSSW () || hdr.IsSSW_ACK () || hdr.IsSSW_FBCK () || m_servingMimoBFT)) /* Special case to handle TXSS CBAP*/
<             {
<               wifiMac->SteerAntennaToward (hdr.GetAddr1 (), hdr.IsData ());
<             }
---
>           Simulator::Schedule (GetPifs () + m_phy->CalculateTxDuration (packet->GetSize (), txVector, m_phy->GetFrequency ()), &MacLow::CfPollTimeout, this);
2385c1365
<       else if (wifiMac->GetTypeOfStation () == DMG_ADHOC)
---
>       if (hdr->IsBeacon () && m_stationManager->HasPcfSupported ())
2387c1367
<           if ((hdr.IsAck () || hdr.IsBlockAck ()))
---
>           if (Simulator::Now () > m_lastBeacon + m_beaconInterval)
2389,2393c1369
<               wifiMac->SteerTxAntennaToward (hdr.GetAddr1 (), true);
<             }
<           else
<             {
<               wifiMac->SteerAntennaToward (hdr.GetAddr1 (), (hdr.IsData () || hdr.IsAck () || hdr.IsBlockAck ()));
---
>               m_cfpForeshortening = (Simulator::Now () - m_lastBeacon - m_beaconInterval);
2394a1371
>           m_lastBeacon = Simulator::Now ();
2396,2405c1373
<     }
<   //// WIGIG ////
< 
<   if (hdr.IsCfPoll () && m_stationManager->GetPcfSupported ())
<     {
<       Simulator::Schedule (GetPifs () + m_phy->CalculateTxDuration (psdu->GetSize (), txVector, m_phy->GetFrequency ()), &MacLow::CfPollTimeout, this);
<     }
<   if (hdr.IsBeacon () && m_stationManager->GetPcfSupported ())
<     {
<       if (Simulator::Now () > m_lastBeacon + m_beaconInterval)
---
>       else if (hdr->IsCfEnd () && m_stationManager->HasPcfSupported ())
2407c1375,1378
<           m_cfpForeshortening = (Simulator::Now () - m_lastBeacon - m_beaconInterval);
---
>           m_cfpStart = NanoSeconds (0);
>           m_cfpForeshortening = NanoSeconds (0);
>           m_cfAckInfo.appendCfAck = false;
>           m_cfAckInfo.expectCfAck = false;
2409,2431c1380,1384
<       m_lastBeacon = Simulator::Now ();
<     }
<   else if (hdr.IsCfEnd () && m_stationManager->GetPcfSupported ())
<     {
<       m_cfpStart = NanoSeconds (0);
<       m_cfpForeshortening = NanoSeconds (0);
<       m_cfAckInfo.appendCfAck = false;
<       m_cfAckInfo.expectCfAck = false;
<     }
<   else if (IsCfPeriod () && hdr.HasData ())
<     {
<       m_cfAckInfo.expectCfAck = true;
<     }
< 
<   if (psdu->IsSingle ())
<     {
<       txVector.SetAggregation (true);
<       NS_LOG_DEBUG ("Sending S-MPDU");
<     }
<   else if (psdu->IsAggregate ())
<     {
<       txVector.SetAggregation (true);
<       NS_LOG_DEBUG ("Sending A-MPDU");
---
>       else if (IsCfPeriod () && hdr->HasData ())
>         {
>           m_cfAckInfo.expectCfAck = true;
>         }
>       m_phy->SendPacket (packet, txVector);
2435,2436c1388,1394
<       NS_LOG_DEBUG ("Sending non aggregate MPDU");
<     }
---
>       Ptr<Packet> newPacket;
>       Ptr <WifiMacQueueItem> dequeuedItem;
>       WifiMacHeader newHdr;
>       uint32_t queueSize = m_aggregateQueue[GetTid (packet, *hdr)]->GetNPackets ();
>       bool singleMpdu = false;
>       bool last = false;
>       MpduType mpdutype = NORMAL_MPDU;
2438,2440c1396,1400
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       if (mpdu->GetHeader ().IsQosData ())
---
>       uint8_t tid = GetTid (packet, *hdr);
>       AcIndex ac = QosUtilsMapTidToAc (tid);
>       std::map<AcIndex, Ptr<QosTxop> >::const_iterator edcaIt = m_edca.find (ac);
> 
>       if (queueSize == 1)
2442,2443c1402,1471
<           auto edcaIt = m_edca.find (QosUtilsMapTidToAc (mpdu->GetHeader ().GetQosTid ()));
<           edcaIt->second->CompleteMpduTx (mpdu);
---
>           singleMpdu = true;
>         }
> 
>       //Add packet tag
>       AmpduTag ampdutag;
>       Time delay = Seconds (0);
>       Time remainingAmpduDuration = m_phy->CalculateTxDuration (packet->GetSize (), txVector, m_phy->GetFrequency ());
>       if (queueSize > 1 || singleMpdu)
>         {
>           txVector.SetAggregation (true);
>         }
>       for (; queueSize > 0; queueSize--)
>         {
>           dequeuedItem = m_aggregateQueue[GetTid (packet, *hdr)]->Dequeue ();
>           newHdr = dequeuedItem->GetHeader ();
>           newPacket = dequeuedItem->GetPacket ()->Copy ();
>           newHdr.SetDuration (hdr->GetDuration ());
>           newPacket->AddHeader (newHdr);
>           AddWifiMacTrailer (newPacket);
>           if (queueSize == 1)
>             {
>               last = true;
>               mpdutype = LAST_MPDU_IN_AGGREGATE;
>             }
> 
>           edcaIt->second->GetMpduAggregator ()->AddHeaderAndPad (newPacket, last, singleMpdu);
> 
>           if (delay.IsZero ())
>             {
>               if (!singleMpdu)
>                 {
>                   NS_LOG_DEBUG ("Sending MPDU as part of A-MPDU");
>                   mpdutype = MPDU_IN_AGGREGATE;
>                 }
>               else
>                 {
>                   NS_LOG_DEBUG ("Sending S-MPDU");
>                   mpdutype = NORMAL_MPDU;
>                 }
>             }
> 
>           Time mpduDuration = m_phy->CalculateTxDuration (newPacket->GetSize (), txVector, m_phy->GetFrequency (), mpdutype, 0);
>           remainingAmpduDuration -= mpduDuration;
> 
>           ampdutag.SetRemainingNbOfMpdus (static_cast<uint8_t> (queueSize - 1));
>           if (queueSize > 1)
>             {
>               ampdutag.SetRemainingAmpduDuration (remainingAmpduDuration);
>             }
>           else
>             {
>               ampdutag.SetRemainingAmpduDuration (NanoSeconds (0));
>             }
>           newPacket->AddPacketTag (ampdutag);
> 
>           if (delay.IsZero ())
>             {
>               m_phy->SendPacket (newPacket, txVector, mpdutype);
>             }
>           else
>             {
>               Simulator::Schedule (delay, &MacLow::SendMpdu, this, newPacket, txVector, mpdutype);
>             }
>           if (queueSize > 1)
>             {
>               NS_ASSERT (remainingAmpduDuration > 0);
>               delay = delay + mpduDuration;
>             }
> 
>           txVector.SetPreambleType (WIFI_PREAMBLE_NONE);
2446c1474,1480
<   m_phy->Send (psdu, txVector);
---
> }
> 
> void
> MacLow::SendMpdu (Ptr<const Packet> packet, WifiTxVector txVector, MpduType mpdutype)
> {
>   NS_LOG_DEBUG ("Sending MPDU as part of A-MPDU");
>   m_phy->SendPacket (packet, txVector, mpdutype);
2472,2485c1506,1510
<   /// \todo should check that there was no RX start before now.
<   /// we should restart a new CTS timeout now until the expected
<   /// end of RX if there was a RX start before now.
<   m_stationManager->ReportRtsFailed (m_currentPacket->GetAddr1 (), &m_currentPacket->GetHeader (0));
< 
<   Ptr<QosTxop> qosTxop = DynamicCast<QosTxop> (m_currentTxop);
<   if (qosTxop != 0)
<     {
<       qosTxop->NotifyMissedCts (std::list<Ptr<WifiMacQueueItem>> (m_currentPacket->begin (), m_currentPacket->end ()));
<     }
<   else
<     {
<       m_currentTxop->MissedCts ();
<     }
---
>   /// \todo should check that there was no rx start before now.
>   /// we should restart a new cts timeout now until the expected
>   /// end of rx if there was a rx start before now.
>   m_stationManager->ReportRtsFailed (m_currentHdr.GetAddr1 (), &m_currentHdr);
>   Ptr<Txop> txop = m_currentTxop;
2487,2488c1512,1513
<   //// WIGIG ////
<   m_currentPacket = 0;
---
>   m_ampdu = false;
>   txop->MissedCts ();
2496c1521
<   /// \todo should check that there was no RX start before now.
---
>   /// \todo should check that there was no rx start before now.
2498c1523,1525
<   /// end of RX if there was a RX start before now.
---
>   /// end of rx if there was a rx start before now.
>   m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr,
>                                       m_currentPacket->GetSize ());
2500a1528,1532
>   m_ampdu = false;
>   if (m_currentHdr.IsQosData ())
>     {
>       FlushAggregateQueue (GetTid (m_currentPacket, m_currentHdr));
>     }
2502,2503d1533
<   //// WIGIG ////
<   m_currentPacket = 0;
2513,2515c1543,1548
<   txop->MissedBlockAck (m_currentPacket->GetNMpdus ());
<   //// WIGIG ////
<   m_currentPacket = 0;
---
>   m_ampdu = false;
>   uint8_t tid = GetTid (m_currentPacket, m_currentHdr);
>   AmpduTag ampdu;
>   m_currentPacket->RemovePacketTag (ampdu);
>   txop->MissedBlockAck (ampdu.GetRemainingNbOfMpdus () + 1);
>   FlushAggregateQueue (tid);
2529c1562
<   rts.SetAddr1 (m_currentPacket->GetAddr1 ());
---
>   rts.SetAddr1 (m_currentHdr.GetAddr1 ());
2531,2543c1564
<   WifiTxVector rtsTxVector = GetRtsTxVector (*m_currentPacket->begin ());
< 
<   /* Check if a control trailer needs to be added to the RTS packet - for RTS packets before MIMO transmissions */
<   bool addControlTrailer = false;
<   DATA_COMMUNICATION_MODE dataMode = DATA_MODE_SISO;
<   Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<   if (m_phy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<     {
<       dataMode = wifiMac->GetStationDataCommunicationMode (rts.GetAddr1 ());
<       addControlTrailer = (dataMode != DATA_MODE_SISO);
<       rtsTxVector.SetControlTrailerPresent (addControlTrailer);
<     }
< 
---
>   WifiTxVector rtsTxVector = GetRtsTxVector (m_currentPacket, &m_currentHdr);
2547c1568
<   duration += GetCtsDuration (m_currentPacket->GetAddr1 (), rtsTxVector, addControlTrailer);
---
>   duration += GetCtsDuration (m_currentHdr.GetAddr1 (), rtsTxVector);
2549c1570
<   duration += m_phy->CalculateTxDuration (m_currentPacket->GetSize (),
---
>   duration += m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr, m_ampdu),
2551c1572,1586
<   duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>   duration += GetSifs ();
>   if (m_txParams.MustWaitBasicBlockAck ())
>     {
>       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>       duration += GetBlockAckDuration (blockAckReqTxVector, BASIC_BLOCK_ACK);
>     }
>   else if (m_txParams.MustWaitCompressedBlockAck ())
>     {
>       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>       duration += GetBlockAckDuration (blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>     }
>   else if (m_txParams.MustWaitNormalAck ())
>     {
>       duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>     }
2556c1591,1595
<       duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>       if (m_txParams.MustWaitNormalAck ())
>         {
>           duration += GetSifs ();
>           duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>         }
2559a1599,1600
>   Time txDuration = m_phy->CalculateTxDuration (GetRtsSize (), rtsTxVector, m_phy->GetFrequency ());
>   Time timerDelay = txDuration + GetCtsTimeout ();
2561,2566d1601
<   Time txDuration = m_phy->CalculateTxDuration (GetRtsSize (addControlTrailer), rtsTxVector, m_phy->GetFrequency ());
<   // After transmitting an RTS frame, the STA shall wait for a CTSTimeout interval with
<   // a value of aSIFSTime + aSlotTime + aRxPHYStartDelay (IEEE 802.11-2016 sec. 10.3.2.7).
<   // aRxPHYStartDelay equals the time to transmit the PHY header.
<   Time timerDelay = txDuration + GetSifs () + GetSlotTime ()
<                     + m_phy->CalculatePhyPreambleAndHeaderDuration (rtsTxVector);
2572,2590c1607,1610
<   if (addControlTrailer)
<     {
<       ControlTrailer ct;
<       ct.SetControlTrailerFormatType (CT_TYPE_GRANT_RTS_CTS2SELF);
<       ct.SetAsMimoTransmission (true);
<       if (dataMode == DATA_MODE_SU_MIMO)
<         {
<           // For now we use the top combination as reported by the SU_MIMO BFT protocol for MIMO communication.
<           ct.SetTxSectorCombinationIdx (0);
<           wifiMac->UpdateBestMimoTxAntennaConfigurationIndex (rts.GetAddr1 (), 0);
<         }
<       else
<         {
<           ct.SetAsMuMimoTransmission (true);
<           // To do: Set the other parameters regarding MU-MIMO RTS
<         }
<       packet->AddHeader (ct);
<     }
<   ForwardDown (Create<const WifiPsdu> (packet, rts), rtsTxVector);
---
>   packet->AddHeader (rts);
>   AddWifiMacTrailer (packet);
> 
>   ForwardDown (packet, &rts, rtsTxVector);
2596,2597c1616
<   NS_LOG_FUNCTION (this);
<   Time txDuration = m_phy->CalculateTxDuration (m_currentPacket->GetSize (), dataTxVector, m_phy->GetFrequency ());
---
>   Time txDuration = m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr, m_ampdu), dataTxVector, m_phy->GetFrequency ());
2600,2606c1619
<       // the timeout duration is "aSIFSTime + aSlotTime + aRxPHYStartDelay, starting
<       // at the PHY-TXEND.confirm primitive" (section 10.3.2.9 or 10.22.2.2 of 802.11-2016).
<       // aRxPHYStartDelay equals the time to transmit the PHY header.
<       WifiTxVector ackTxVector = GetAckTxVector (m_currentPacket->GetAddr1 (),
<                                                  dataTxVector.GetMode ());
<       Time timerDelay = txDuration + GetSifs () + GetSlotTime ()
<                         + m_phy->CalculatePhyPreambleAndHeaderDuration (ackTxVector);
---
>       Time timerDelay = txDuration + GetAckTimeout ();
2611c1624
<   else if (m_txParams.MustWaitBlockAck ())
---
>   else if (m_txParams.MustWaitBasicBlockAck ())
2613,2619c1626,1633
<       // the timeout duration is "aSIFSTime + aSlotTime + aRxPHYStartDelay, starting
<       // at the PHY-TXEND.confirm primitive" (section 10.3.2.9 or 10.22.2.2 of 802.11-2016).
<       // aRxPHYStartDelay equals the time to transmit the PHY header.
<       WifiTxVector blockAckTxVector = GetBlockAckTxVector (m_currentPacket->GetAddr1 (),
<                                                            dataTxVector.GetMode ());
<       Time timerDelay = txDuration + GetSifs () + GetSlotTime ()
<                         + m_phy->CalculatePhyPreambleAndHeaderDuration (blockAckTxVector);
---
>       Time timerDelay = txDuration + GetBasicBlockAckTimeout ();
>       NS_ASSERT (m_blockAckTimeoutEvent.IsExpired ());
>       NotifyAckTimeoutStartNow (timerDelay);
>       m_blockAckTimeoutEvent = Simulator::Schedule (timerDelay, &MacLow::BlockAckTimeout, this);
>     }
>   else if (m_txParams.MustWaitCompressedBlockAck ())
>     {
>       Time timerDelay = txDuration + GetCompressedBlockAckTimeout ();
2638,2643c1652
<   else if (m_currentPacket->GetHeader (0).IsQosData () && m_currentTxop->IsQosTxop () &&
<            m_currentTxop->GetTxopLimit ().IsStrictlyPositive ()
<            //// WIGIG ////
<            //&& m_currentTxop->GetTxopRemaining () > GetSifs ()
<            && m_currentTxop->GetRemainingTimeForTransmission () > GetSifs ())
<            //// WIGIG ////
---
>   else if (m_currentHdr.IsQosData () && m_currentHdr.IsQosBlockAck () && m_currentTxop->HasTxop ())
2669,2675c1678,1679
<   //// WIGIG ////
<   if (m_txParams.HasDurationId ()) //// (Modification)
<     {
<       m_currentPacket->SetDuration (m_txParams.GetDurationId ());
<     }
<   //// WIGIG ////
<   else if (!IsCfPeriod ())
---
> 
>   if (!IsCfPeriod ())
2677c1681,1698
<       Time duration = GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>       Time duration = Seconds (0);
>       if (m_txParams.MustWaitBasicBlockAck ())
>         {
>           duration += GetSifs ();
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           duration += GetBlockAckDuration (blockAckReqTxVector, BASIC_BLOCK_ACK);
>         }
>       else if (m_txParams.MustWaitCompressedBlockAck ())
>         {
>           duration += GetSifs ();
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           duration += GetBlockAckDuration (blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>         }
>       else if (m_txParams.MustWaitNormalAck ())
>         {
>           duration += GetSifs ();
>           duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>         }
2690c1711,1715
<           duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>           if (m_txParams.MustWaitNormalAck ())
>             {
>               duration += GetSifs ();
>               duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>             }
2692c1717
<       m_currentPacket->SetDuration (duration);
---
>       m_currentHdr.SetDuration (duration);
2696c1721
<       if (m_currentPacket->GetHeader (0).IsCfEnd ())
---
>       if (m_currentHdr.IsCfEnd ())
2698c1723
<           m_currentPacket->GetHeader (0).SetRawDuration (0);
---
>           m_currentHdr.SetRawDuration (0);
2702c1727
<           m_currentPacket->GetHeader (0).SetRawDuration (32768);
---
>           m_currentHdr.SetRawDuration (32768);
2706c1731,1736
<   if (!m_currentPacket->IsAggregate ())
---
>   Ptr <Packet> packet = m_currentPacket->Copy ();
>   if (m_ampdu)
>     {
>       NS_ASSERT (m_currentHdr.IsQosData ());
>     }
>   else
2710c1740
<           switch (m_currentPacket->GetHeader (0).GetType ())
---
>           switch (m_currentHdr.GetType ())
2713c1743
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_DATA_CFACK, false);
---
>               m_currentHdr.SetType (WIFI_MAC_DATA_CFACK, false);
2716c1746
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_DATA_CFACK_CFPOLL, false);
---
>               m_currentHdr.SetType (WIFI_MAC_DATA_CFACK_CFPOLL, false);
2719c1749
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_DATA_NULL_CFACK, false);
---
>               m_currentHdr.SetType (WIFI_MAC_DATA_NULL_CFACK, false);
2722c1752
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_DATA_NULL_CFACK_CFPOLL, false);
---
>               m_currentHdr.SetType (WIFI_MAC_DATA_NULL_CFACK_CFPOLL, false);
2725c1755
<               m_currentPacket->GetHeader (0).SetType (WIFI_MAC_CTL_END_ACK, false);
---
>               m_currentHdr.SetType (WIFI_MAC_CTL_END_ACK, false);
2732,2733c1762,1763
<           //Standard says that, for frames of type Data+CF-Ack, Data+CF-Poll+CF-Ack, and CF-Poll+CF-Ack,
<           //the rate chosen to transmit the frame must be supported by both the addressed recipient STA and the STA to which the Ack is intended.
---
>           //Standard says that, for frames of type Data+CF-ACK, Data+CF-Poll+CF-ACK, and CF-Poll+CF-ACK,
>           //the rate chosen to transmit the frame must be supported by both the addressed recipient STA and the STA to which the ACK is intended.
2735,2737c1765,1767
<           //Instead, we simply fetch two TxVector and we select the one with the lowest data rate.
<           //This should be later changed, at the latest once HCCA is implemented for HT/VHT/HE stations.
<           WifiMacHeader tmpHdr = m_currentPacket->GetHeader (0);
---
>           //Instead, we simply fetch two TxVector and we select the one with the lowest datarate.
>           //This should be later changed, at the latest once HCCA is implemented for HT/VHT stations.
>           WifiMacHeader tmpHdr = m_currentHdr;
2739c1769
<           WifiTxVector tmpTxVector = GetDataTxVector (Create<const WifiMacQueueItem> (m_currentPacket->GetPayload (0), tmpHdr));
---
>           WifiTxVector tmpTxVector = GetDataTxVector (packet, &tmpHdr);
2746a1777,1778
>       packet->AddHeader (m_currentHdr);
>       AddWifiMacTrailer (packet);
2748,2755c1780
<   if (m_txParams.MustSendBlockAckRequest ())
<     {
<       Ptr<QosTxop> qosTxop = DynamicCast<QosTxop> (m_currentTxop);
<       NS_ASSERT (qosTxop != 0);
<       auto bar = qosTxop->PrepareBlockAckRequest (m_currentPacket->GetAddr1 (), *m_currentPacket->GetTids ().begin ());
<       qosTxop->ScheduleBar (bar);
<     }
<   ForwardDown (m_currentPacket, m_currentTxVector);
---
>   ForwardDown (packet, &m_currentHdr, m_currentTxVector);
2775c1800
<   WifiTxVector ctsTxVector = GetRtsTxVector (*m_currentPacket->begin ());
---
>   WifiTxVector ctsTxVector = GetRtsTxVector (m_currentPacket, &m_currentHdr);
2779c1804
<   duration += m_phy->CalculateTxDuration (m_currentPacket->GetSize (),
---
>   duration += m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr, m_ampdu),
2781c1806,1822
<   duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>   if (m_txParams.MustWaitBasicBlockAck ())
>     {
>       duration += GetSifs ();
>       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>       duration += GetBlockAckDuration (blockAckReqTxVector, BASIC_BLOCK_ACK);
>     }
>   else if (m_txParams.MustWaitCompressedBlockAck ())
>     {
>       duration += GetSifs ();
>       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>       duration += GetBlockAckDuration (blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>     }
>   else if (m_txParams.MustWaitNormalAck ())
>     {
>       duration += GetSifs ();
>       duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>     }
2787c1828,1838
<       duration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>       if (m_txParams.MustWaitCompressedBlockAck ())
>         {
>           duration += GetSifs ();
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           duration += GetBlockAckDuration (blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>         }
>       else if (m_txParams.MustWaitNormalAck ())
>         {
>           duration += GetSifs ();
>           duration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>         }
2792c1843,1847
<   ForwardDown (Create<const WifiPsdu> (Create<Packet> (), cts), ctsTxVector);
---
>   Ptr<Packet> packet = Create<Packet> ();
>   packet->AddHeader (cts);
>   AddWifiMacTrailer (packet);
> 
>   ForwardDown (packet, &cts, ctsTxVector);
2823a1879,1880
>   packet->AddHeader (cts);
>   AddWifiMacTrailer (packet);
2830,2890c1887
<   ForwardDown (Create<const WifiPsdu> (packet, cts), ctsTxVector);
< }
< 
< //// WIGIG ////
< void
< MacLow::SendDmgCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr)
< {
<   NS_LOG_FUNCTION (this << source << duration << rtsTxVector.GetMode () << rtsSnr);
<   /* Send a DMG CTS when we receive a RTS right after SIFS. */
<   WifiTxVector ctsTxVector = GetDmgControlTxVector ();
<   WifiMacHeader cts;
<   cts.SetType (WIFI_MAC_CTL_DMG_CTS);
<   cts.SetDsNotFrom ();
<   cts.SetDsNotTo ();
<   cts.SetNoMoreFragments ();
<   cts.SetNoRetry ();
<   cts.SetAddr1 (source);
<   cts.SetAddr2 (GetAddress ());
< 
<   /* Check if a control trailer needs to be added to the DMG CTS - for CTS before a MIMO transmission */
<   Ptr<DmgWifiMac> wifiMac = DynamicCast<DmgWifiMac> (m_mac);
<   DATA_COMMUNICATION_MODE dataMode = wifiMac->GetStationDataCommunicationMode (source);
<   bool addControlTrailer = (dataMode != DATA_MODE_SISO);
<   ctsTxVector.SetControlTrailerPresent (addControlTrailer);
< 
<   /* Set duration field */
<   duration -= GetDmgCtsDuration (addControlTrailer);
<   duration -= GetSifs ();
<   NS_ASSERT (duration.IsPositive ());
<   cts.SetDuration (duration);
< 
<   Ptr<Packet> packet = Create<Packet> ();
< 
<   SnrTag tag;
<   tag.Set (rtsSnr);
<   packet->AddPacketTag (tag);
< 
<   /* When using RTS/CTS for channel access for MIMO communication a control trailer needs to be added to the packet */
<   if (addControlTrailer)
<     {
<       ControlTrailer ct;
<       ct.SetControlTrailerFormatType (CT_TYPE_CTS_DTS);
<       ct.SetAsMimoTransmission (false);
<       /* For now only the station transmitting the data transmits in MIMO while the receiver responds in SISO mode */
< //      if (dataMode == DATA_MODE_SU_MIMO)
< //        {
< //          // For now we use the top combination as reported by the SU_MIMO BFT protocol for MIMO communication.
< //          ct.SetTxSectorCombinationIdx (0);
< //          wifiMac->UpdateBestMimoTxAntennaConfigurationIndex (source, 0);
< //        }
< //      else
< //        {
< //          ct.SetAsMuMimoTransmission (true);
< //          // To do: Set the other parameters regarding MU-MIMO RTS
< //        }
<       packet->AddHeader (ct);
<       /* After sending the CTS set up the receive antennas in the comfiguration needed for MIMO reception */
<       Simulator::Schedule (GetDmgCtsDuration (addControlTrailer), &DmgWifiMac::SteerMimoRxAntennaToward, wifiMac, source);
<     }
< 
<   ForwardDown (Create<const WifiPsdu> (packet, cts), ctsTxVector);
---
>   ForwardDown (packet, &cts, ctsTxVector);
2892d1888
< //// WIGIG ////
2899c1895
<    * RTS/CTS/Data/Ack handshake
---
>    * RTS/CTS/DATA/ACK handshake
2902a1899,1912
>   if (m_currentHdr.IsQosData ())
>     {
>       uint8_t tid = GetTid (m_currentPacket, m_currentHdr);
>       if (!m_aggregateQueue[GetTid (m_currentPacket, m_currentHdr)]->IsEmpty ())
>         {
>           for (std::vector<Item>::size_type i = 0; i != m_txPackets[tid].size (); i++)
>             {
>               AcIndex ac = QosUtilsMapTidToAc (tid);
>               std::map<AcIndex, Ptr<QosTxop> >::const_iterator edcaIt = m_edca.find (ac);
>               edcaIt->second->CompleteMpduTx (m_txPackets[tid].at (i).packet, m_txPackets[tid].at (i).hdr, m_txPackets[tid].at (i).timestamp);
>             }
>         }
>     }
> 
2904c1914,1931
<   Time newDuration = GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>   Time newDuration = Seconds (0);
>   if (m_txParams.MustWaitBasicBlockAck ())
>     {
>       newDuration += GetSifs ();
>       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>       newDuration += GetBlockAckDuration (blockAckReqTxVector, BASIC_BLOCK_ACK);
>     }
>   else if (m_txParams.MustWaitCompressedBlockAck ())
>     {
>       newDuration += GetSifs ();
>       WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>       newDuration += GetBlockAckDuration (blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>     }
>   else if (m_txParams.MustWaitNormalAck ())
>     {
>       newDuration += GetSifs ();
>       newDuration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>     }
2916c1943,1953
<       newDuration += GetResponseDuration (m_txParams, m_currentTxVector, m_currentPacket->GetAddr1 ());
---
>       if (m_txParams.MustWaitCompressedBlockAck ())
>         {
>           newDuration += GetSifs ();
>           WifiTxVector blockAckReqTxVector = GetBlockAckTxVector (m_currentHdr.GetAddr2 (), m_currentTxVector.GetMode ());
>           newDuration += GetBlockAckDuration (blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>         }
>       else if (m_txParams.MustWaitNormalAck ())
>         {
>           newDuration += GetSifs ();
>           newDuration += GetAckDuration (m_currentHdr.GetAddr1 (), m_currentTxVector);
>         }
2919c1956
<   Time txDuration = m_phy->CalculateTxDuration (m_currentPacket->GetSize (), m_currentTxVector, m_phy->GetFrequency ());
---
>   Time txDuration = m_phy->CalculateTxDuration (GetSize (m_currentPacket, &m_currentHdr, m_ampdu), m_currentTxVector, m_phy->GetFrequency ());
2925,2926c1962,1968
<   m_currentPacket->SetDuration (duration);
<   if (m_txParams.MustSendBlockAckRequest ())
---
>   m_currentHdr.SetDuration (duration);
>   Ptr <Packet> packet = m_currentPacket->Copy ();
>   if (m_ampdu)
>     {
>       NS_ASSERT (m_currentHdr.IsQosData ());
>     }
>   else
2928,2931c1970,1971
<       Ptr<QosTxop> qosTxop = DynamicCast<QosTxop> (m_currentTxop);
<       NS_ASSERT (qosTxop != 0);
<       auto bar = qosTxop->PrepareBlockAckRequest (m_currentPacket->GetAddr1 (), *m_currentPacket->GetTids ().begin ());
<       qosTxop->ScheduleBar (bar);
---
>       packet->AddHeader (m_currentHdr);
>       AddWifiMacTrailer (packet);
2933c1973
<   ForwardDown (m_currentPacket, m_currentTxVector);
---
>   ForwardDown (packet, &m_currentHdr, m_currentTxVector);
2954c1994
<   if (m_currentTxop != 0)
---
>   if (m_currentHdr.IsBeacon () && m_stationManager->HasPcfSupported ())
2956,2968c1996
<       if (m_currentPacket->GetHeader (0).IsBeacon () && m_stationManager->GetPcfSupported ())
<         {
<           m_cfpStart = Simulator::Now ();
<         }
<       if (!m_cfAckInfo.expectCfAck)
<         {
<           Ptr<Txop> txop = m_currentTxop;
<           txop->EndTxNoAck ();
<         }
<       if (!IsCfPeriod ())
<         {
<           m_currentTxop = 0;
<         }
---
>       m_cfpStart = Simulator::Now ();
2970c1998
<   else
---
>   if (!m_cfAckInfo.expectCfAck)
2972,2975c2000,2005
<       if (m_currentPacket->IsShortSSW ())
<         m_transmissionShortSswCallback ();
<       else
<         m_transmissionCallback (m_currentPacket->GetHeader (0));
---
>       Ptr<Txop> txop = m_currentTxop;
>       txop->EndTxNoAck ();
>     }
>   if (!IsCfPeriod ())
>     {
>       m_currentTxop = 0;
2977,2979d2006
<   //// WIGIG ////
<   m_currentPacket = 0;
<   //// WIGIG ////
2986,3002c2013,2027
<   if (!m_phy->IsStateTx () && !m_phy->IsStateSwitching ()) //// WIGIG //// (Modification)
<     {
<       // send an Ack, after SIFS, when you receive a packet
<       WifiTxVector ackTxVector = GetAckTxVector (source, dataTxMode);
<       WifiMacHeader ack;
<       ack.SetType (WIFI_MAC_CTL_ACK);
<       ack.SetDsNotFrom ();
<       ack.SetDsNotTo ();
<       ack.SetNoRetry ();
<       ack.SetNoMoreFragments ();
<       ack.SetAddr1 (source);
<       // 802.11-2012, Section 8.3.1.4:  Duration/ID is received duration value
<       // minus the time to transmit the Ack frame and its SIFS interval
<       duration -= GetAckDuration (ackTxVector);
<       duration -= GetSifs ();
<       NS_ASSERT_MSG (duration.IsPositive (), "Please provide test case to maintainers if this assert is hit.");
<       ack.SetDuration (duration);
---
>   // send an ACK, after SIFS, when you receive a packet
>   WifiTxVector ackTxVector = GetAckTxVector (source, dataTxMode);
>   WifiMacHeader ack;
>   ack.SetType (WIFI_MAC_CTL_ACK);
>   ack.SetDsNotFrom ();
>   ack.SetDsNotTo ();
>   ack.SetNoRetry ();
>   ack.SetNoMoreFragments ();
>   ack.SetAddr1 (source);
>   // 802.11-2012, Section 8.3.1.4:  Duration/ID is received duration value
>   // minus the time to transmit the ACK frame and its SIFS interval
>   duration -= GetAckDuration (ackTxVector);
>   duration -= GetSifs ();
>   NS_ASSERT_MSG (duration.IsPositive (), "Please provide test case to maintainers if this assert is hit.");
>   ack.SetDuration (duration);
3004c2029,2031
<       Ptr<Packet> packet = Create<Packet> ();
---
>   Ptr<Packet> packet = Create<Packet> ();
>   packet->AddHeader (ack);
>   AddWifiMacTrailer (packet);
3006,3008c2033,2035
<       SnrTag tag;
<       tag.Set (dataSnr);
<       packet->AddPacketTag (tag);
---
>   SnrTag tag;
>   tag.Set (dataSnr);
>   packet->AddPacketTag (tag);
3010,3016c2037,2038
<       //Ack should always use non-HT PPDU (HT PPDU cases not supported yet)
<       ForwardDown (Create<const WifiPsdu> (packet, ack), ackTxVector);
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Skip ack after data");
<     }
---
>   //ACK should always use non-HT PPDU (HT PPDU cases not supported yet)
>   ForwardDown (packet, &ack, ackTxVector);
3020c2042
< MacLow::ReceiveMpdu (Ptr<WifiMacQueueItem> mpdu)
---
> MacLow::ReceiveMpdu (Ptr<Packet> packet, WifiMacHeader hdr)
3022,3030c2044,2046
<   const WifiMacHeader& hdr = mpdu->GetHeader ();
< 
<   if (m_stationManager->GetHtSupported ()
<       || m_stationManager->GetVhtSupported ()
<       || m_stationManager->GetHeSupported ()
<       //// WIGIG ////
<       || m_stationManager->HasDmgSupported ()
<       || m_stationManager->HasEdmgSupported ())
<       //// WIGIG ////
---
>   if (m_stationManager->HasHtSupported ()
>       || m_stationManager->HasVhtSupported ()
>       || m_stationManager->HasHeSupported ())
3042c2058
<           //Implement HT immediate BlockAck support for HT Delayed BlockAck is not added yet
---
>           //Implement HT immediate Block Ack support for HT Delayed Block Ack is not added yet
3045c2061
<               StoreMpduIfNeeded (mpdu);
---
>               StoreMpduIfNeeded (packet, hdr);
3049,3053c2065,2073
<                   NS_ASSERT (delta > 0);
<                   uint16_t bufferSize = (*it).second.first.GetBufferSize ();
<                   uint16_t startingSeq = (seqNumber - bufferSize + 1 + 4096) % 4096;
<                   (*it).second.first.SetStartingSequence (startingSeq);
<                   RxCompleteBufferedPacketsWithSmallerSequence ((*it).second.first.GetStartingSequenceControl (), originator, tid);
---
>                   if (delta > 1)
>                     {
>                       (*it).second.first.SetWinEnd (seqNumber);
>                       int16_t winEnd = (*it).second.first.GetWinEnd ();
>                       int16_t bufferSize = (*it).second.first.GetBufferSize ();
>                       uint16_t sum = (static_cast<uint16_t> (std::abs (winEnd - bufferSize + 1))) % 4096;
>                       (*it).second.first.SetStartingSequence (sum);
>                       RxCompleteBufferedPacketsWithSmallerSequence ((*it).second.first.GetStartingSequenceControl (), originator, tid);
>                     }
3055a2076
>               (*it).second.first.SetWinEnd (((*it).second.first.GetStartingSequence () + (*it).second.first.GetBufferSize () - 1) % 4096);
3061c2082
<   return StoreMpduIfNeeded (mpdu);
---
>   return StoreMpduIfNeeded (packet, hdr);
3065c2086
< MacLow::StoreMpduIfNeeded (Ptr<WifiMacQueueItem> mpdu)
---
> MacLow::StoreMpduIfNeeded (Ptr<Packet> packet, WifiMacHeader hdr)
3067,3068d2087
<   const WifiMacHeader& hdr = mpdu->GetHeader ();
< 
3071a2091,2094
>       WifiMacTrailer fcs;
>       packet->RemoveTrailer (fcs);
>       BufferedPacket bufferedPacket (packet, hdr);
> 
3077c2100
<            && QosUtilsMapSeqControlToUniqueInteger ((*i)->GetHeader ().GetSequenceControl (), endSequence) < mappedSeqControl; i++)
---
>            && QosUtilsMapSeqControlToUniqueInteger ((*i).second.GetSequenceControl (), endSequence) < mappedSeqControl; i++)
3080c2103
<       (*it).second.second.insert (i, mpdu);
---
>       (*it).second.second.insert (i, bufferedPacket);
3111c2134
<   std::list<Ptr<WifiMacQueueItem>> buffer (0);
---
>   std::list<BufferedPacket> buffer (0);
3161c2184
<           guard = (*(*it).second.second.begin ())->GetHeader ().GetSequenceControl ();
---
>           guard = (*it).second.second.begin ()->second.GetSequenceControl ();
3165c2188
<            && QosUtilsMapSeqControlToUniqueInteger ((*i)->GetHeader ().GetSequenceControl (), endSequence) < mappedStart; )
---
>            && QosUtilsMapSeqControlToUniqueInteger ((*i).second.GetSequenceControl (), endSequence) < mappedStart; )
3167c2190
<           if (guard == (*i)->GetHeader ().GetSequenceControl ())
---
>           if (guard == (*i).second.GetSequenceControl ())
3169c2192
<               if (!(*i)->GetHeader ().IsMoreFragments ())
---
>               if (!(*i).second.IsMoreFragments ())
3173c2196
<                       m_rxCallback (*last);
---
>                       m_rxCallback ((*last).first, &(*last).second);
3176c2199
<                   m_rxCallback (*last);
---
>                   m_rxCallback ((*last).first, &(*last).second);
3179c2202
<                   while (i != (*it).second.second.end () && guard == (*i)->GetHeader ().GetSequenceControl ())
---
>                   while (i != (*it).second.second.end () && guard == (*i).second.GetSequenceControl ())
3185c2208
<                       guard = (*i)->GetHeader ().GetSequenceControl ();
---
>                       guard = (*i).second.GetSequenceControl ();
3197c2220
<               while (i != (*it).second.second.end () && guard == (*i)->GetHeader ().GetSequenceControl ())
---
>               while (i != (*it).second.second.end () && guard == (*i).second.GetSequenceControl ())
3203c2226
<                   guard = (*i)->GetHeader ().GetSequenceControl ();
---
>                   guard = (*i).second.GetSequenceControl ();
3221c2244
<       for (; i != (*it).second.second.end () && guard == (*i)->GetHeader ().GetSequenceControl (); i++)
---
>       for (; i != (*it).second.second.end () && guard == (*i).second.GetSequenceControl (); i++)
3223c2246
<           if (!(*i)->GetHeader ().IsMoreFragments ())
---
>           if (!(*i).second.IsMoreFragments ())
3227c2250
<                   m_rxCallback (*lastComplete);
---
>                   m_rxCallback ((*lastComplete).first, &(*lastComplete).second);
3230c2253
<               m_rxCallback (*lastComplete);
---
>               m_rxCallback ((*lastComplete).first, &(*lastComplete).second);
3233c2256
<           guard = (*i)->GetHeader ().IsMoreFragments () ? (guard + 1) : ((guard + 16) & 0xfff0);
---
>           guard = (*i).second.IsMoreFragments () ? (guard + 1) : ((guard + 16) & 0xfff0);
3241d2263
< 
3265c2287,2298
<       duration -= GetBlockAckDuration (blockAckReqTxVector, blockAck->GetType ());
---
>       if (blockAck->IsBasic ())
>         {
>           duration -= GetBlockAckDuration (blockAckReqTxVector, BASIC_BLOCK_ACK);
>         }
>       else if (blockAck->IsCompressed ())
>         {
>           duration -= GetBlockAckDuration (blockAckReqTxVector, COMPRESSED_BLOCK_ACK);
>         }
>       else if (blockAck->IsMultiTid ())
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
>         }
3282c2315
<   //here should be present a control about immediate or delayed BlockAck
---
>   //here should be present a control about immediate or delayed block ack
3283a2317,2318
>   packet->AddHeader (hdr);
>   AddWifiMacTrailer (packet);
3287c2322
<   ForwardDown (Create<const WifiPsdu> (packet, hdr), blockAckReqTxVector);
---
>   ForwardDown (packet, &hdr, blockAckReqTxVector);
3294c2329
<   if (!m_phy->IsStateTx () && !m_phy->IsStateSwitching ()) //// WIGIG //// (Modification)
---
>   if (!m_phy->IsStateTx () && !m_phy->IsStateRx ())
3308,3324c2343
<       //// WIGIG ////
<       if (m_stationManager->HasEdmgSupported ())
<         {
<           blockAck.SetType (BlockAckType::EDMG_COMPRESSED_BLOCK_ACK);
<         }
<       else
<       //// WIGIG ////
<         {
<           if ((*it).second.first.GetBufferSize () > 64)
<             {
<               blockAck.SetType (EXTENDED_COMPRESSED_BLOCK_ACK);
<             }
<           else
<             {
<               blockAck.SetType (COMPRESSED_BLOCK_ACK);
<             }
<         }
---
>       blockAck.SetType (COMPRESSED_BLOCK_ACK);
3328,3330c2347
<       WifiTxVector blockAckTxVector = GetBlockAckTxVector (originator, blockAckReqTxVector.GetMode ());
< 
<       SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckTxVector.GetMode (), rxSnr);
---
>       SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxVector.GetMode (), rxSnr);
3343c2360,2363
<   if (!m_phy->IsStateTx () && !m_phy->IsStateSwitching ()) //// WIGIG //// (Modification)
---
>   CtrlBAckResponseHeader blockAck;
>   uint8_t tid = 0;
>   bool immediate = false;
>   if (!reqHdr.IsMultiTid ())
3345,3348c2365,2367
<       CtrlBAckResponseHeader blockAck;
<       uint8_t tid = 0;
<       bool immediate = false;
<       if (!reqHdr.IsMultiTid ())
---
>       tid = reqHdr.GetTidInfo ();
>       AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
>       if (it != m_bAckAgreements.end ())
3350,3352c2369,2372
<           tid = reqHdr.GetTidInfo ();
<           AgreementsI it = m_bAckAgreements.find (std::make_pair (originator, tid));
<           if (it != m_bAckAgreements.end ())
---
>           blockAck.SetStartingSequence (reqHdr.GetStartingSequence ());
>           blockAck.SetTidInfo (tid);
>           immediate = (*it).second.first.IsImmediateBlockAck ();
>           if (reqHdr.IsBasic ())
3354,3363c2374,2397
<               blockAck.SetStartingSequence (reqHdr.GetStartingSequence ());
<               blockAck.SetTidInfo (tid);
<               immediate = (*it).second.first.IsImmediateBlockAck ();
<               //// WIGIG ////
<               if (m_stationManager->HasEdmgSupported ())
<                 {
<                   blockAck.SetType (EDMG_COMPRESSED_BLOCK_ACK);
<                 }
<               else
<               //// WIGIG ////
---
>               blockAck.SetType (BASIC_BLOCK_ACK);
>             }
>           else if (reqHdr.IsCompressed ())
>             {
>               blockAck.SetType (COMPRESSED_BLOCK_ACK);
>             }
>           BlockAckCachesI i = m_bAckCaches.find (std::make_pair (originator, tid));
>           NS_ASSERT (i != m_bAckCaches.end ());
>           (*i).second.FillBlockAckBitmap (&blockAck);
>           NS_LOG_DEBUG ("Got block Ack Req with seq " << reqHdr.GetStartingSequence ());
> 
>           if (!m_stationManager->HasHtSupported ()
>               && !m_stationManager->HasVhtSupported ()
>               && !m_stationManager->HasHeSupported ())
>             {
>               /* All packets with smaller sequence than starting sequence control must be passed up to Wifimac
>                * See 9.10.3 in IEEE 802.11e standard.
>                */
>               RxCompleteBufferedPacketsWithSmallerSequence (reqHdr.GetStartingSequenceControl (), originator, tid);
>               RxCompleteBufferedPacketsUntilFirstLost (originator, tid);
>             }
>           else
>             {
>               if (!QosUtilsIsOldPacket ((*it).second.first.GetStartingSequence (), reqHdr.GetStartingSequence ()))
3365,3393c2399,2400
<                   if (reqHdr.IsBasic ())
<                     {
<                       blockAck.SetType (BASIC_BLOCK_ACK);
<                     }
<                   else if (reqHdr.IsCompressed ())
<                     {
<                       blockAck.SetType (COMPRESSED_BLOCK_ACK);
<                     }
<                   else if (reqHdr.IsExtendedCompressed ())
<                     {
<                       blockAck.SetType (EXTENDED_COMPRESSED_BLOCK_ACK);
<                     }
<                 }
<               BlockAckCachesI i = m_bAckCaches.find (std::make_pair (originator, tid));
<               NS_ASSERT (i != m_bAckCaches.end ());
<               (*i).second.FillBlockAckBitmap (&blockAck);
<               NS_LOG_DEBUG ("Got block Ack Req with seq " << reqHdr.GetStartingSequence ());
< 
<               if (!m_stationManager->GetHtSupported ()
<                   && !m_stationManager->GetVhtSupported ()
<                   && !m_stationManager->GetHeSupported ()
<                   //// WIGIG ////
<                   && !m_stationManager->HasDmgSupported ()
<                   && !m_stationManager->HasEdmgSupported ())
<                 //// WIGIG ////
<                 {
<                   /* All packets with smaller sequence than starting sequence control must be passed up to WifiMac
<                            * See 9.10.3 in IEEE 802.11e standard.
<                            */
---
>                   (*it).second.first.SetStartingSequence (reqHdr.GetStartingSequence ());
>                   (*it).second.first.SetWinEnd (((*it).second.first.GetStartingSequence () + (*it).second.first.GetBufferSize () - 1) % 4096);
3396,3404c2403
<                 }
<               else
<                 {
<                   if (!QosUtilsIsOldPacket ((*it).second.first.GetStartingSequence (), reqHdr.GetStartingSequence ()))
<                     {
<                       (*it).second.first.SetStartingSequence (reqHdr.GetStartingSequence ());
<                       RxCompleteBufferedPacketsWithSmallerSequence (reqHdr.GetStartingSequenceControl (), originator, tid);
<                       RxCompleteBufferedPacketsUntilFirstLost (originator, tid);
<                     }
---
>                   (*it).second.first.SetWinEnd (((*it).second.first.GetStartingSequence () + (*it).second.first.GetBufferSize () - 1) % 4096);
3407,3410d2405
<           else
<             {
<               NS_LOG_DEBUG ("there's not a valid block ack agreement with " << originator);
<             }
3414c2409
<           NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
---
>           NS_LOG_DEBUG ("there's not a valid block ack agreement with " << originator);
3416d2410
<       SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxMode, rxSnr);
3420c2414
<       NS_LOG_DEBUG ("Skip block ack response!");
---
>       NS_FATAL_ERROR ("Multi-tid block ack is not supported.");
3421a2416
>   SendBlockAckResponse (&blockAck, originator, immediate, duration, blockAckReqTxMode, rxSnr);
3447c2442
< MacLow::DeaggregateAmpduAndReceive (Ptr<WifiPsdu> psdu, double rxSnr, WifiTxVector txVector, std::vector<bool> statusPerMpdu)
---
> MacLow::DeaggregateAmpduAndReceive (Ptr<Packet> aggregatedPacket, double rxSnr, WifiTxVector txVector)
3449a2445
>   AmpduTag ampdu;
3452c2448
<   if (txVector.IsAggregation ())
---
>   if (aggregatedPacket->RemovePacketTag (ampdu))
3454,3455d2449
<       NS_ASSERT (psdu->IsAggregate ());
< 
3457,3477c2451,2452
<       auto n = psdu->begin ();
<       auto status = statusPerMpdu.begin ();
<       NS_ABORT_MSG_IF (psdu->GetNMpdus () != statusPerMpdu.size (), "Should have one receive status per MPDU");
< 
<       WifiMacHeader firsthdr = (*n)->GetHeader ();
< 
<       //// WIGIG ////
<       /* No need to continue processing the received A-MPDU, if we are performing SLS. */
<       if (m_servingSLS)
<         {
<           NS_LOG_DEBUG ("Perfomring SLS BFT, so ignoe the received A-MPDU from " << firsthdr.GetAddr2 () <<
<                         " with sequence=" << firsthdr.GetSequenceNumber ());
<           return;
<         }
<       if (m_servingMimoBFT)
<         {
<           NS_LOG_DEBUG ("Perfomring MIMO BFT, so ignoe the received A-MPDU from " << firsthdr.GetAddr2 () <<
<                         " with sequence=" << firsthdr.GetSequenceNumber ());
<           return;
<         }
<       //// WIGIG ////
---
>       MpduAggregator::DeaggregatedMpdus packets = MpduAggregator::Deaggregate (aggregatedPacket);
>       MpduAggregator::DeaggregatedMpdusCI n = packets.begin ();
3478a2454,2455
>       WifiMacHeader firsthdr;
>       (*n).first->PeekHeader (firsthdr);
3480c2457
<       NotifyNav ((*n)->GetPacket (), firsthdr);
---
>       NotifyNav ((*n).first, firsthdr);
3484,3485c2461,2493
<           //Iterate over all MPDUs and notify reception only if status OK
<           for (; n != psdu->end (); ++n, ++status)
---
>           bool singleMpdu = (*n).second.GetEof ();
>           if (singleMpdu)
>             {
>               //If the MPDU is sent as a VHT/HE single MPDU (EOF=1 in A-MPDU subframe header), then the responder sends an ACK.
>               NS_LOG_DEBUG ("Receive S-MPDU");
>               ampduSubframe = false;
>             }
>           else if (txVector.GetPreambleType () != WIFI_PREAMBLE_NONE || !m_sendAckEvent.IsRunning ())
>             {
>               m_sendAckEvent = Simulator::Schedule (ampdu.GetRemainingAmpduDuration () + GetSifs (),
>                                                     &MacLow::SendBlockAckAfterAmpdu, this,
>                                                     firsthdr.GetQosTid (),
>                                                     firsthdr.GetAddr2 (),
>                                                     firsthdr.GetDuration (),
>                                                     txVector,
>                                                     rxSnr);
>             }
> 
>           if (firsthdr.IsAck () || firsthdr.IsBlockAck () || firsthdr.IsBlockAckReq ())
>             {
>               ReceiveOk ((*n).first, rxSnr, txVector, ampduSubframe);
>             }
>           else if (firsthdr.IsData () || firsthdr.IsQosData ())
>             {
>               NS_LOG_DEBUG ("Deaggregate packet from " << firsthdr.GetAddr2 () << " with sequence=" << firsthdr.GetSequenceNumber ());
>               ReceiveOk ((*n).first, rxSnr, txVector, ampduSubframe);
>               if (firsthdr.IsQosAck ())
>                 {
>                   NS_LOG_DEBUG ("Normal Ack");
>                   normalAck = true;
>                 }
>             }
>           else
3487,3489c2495,2500
<               firsthdr = (*n)->GetHeader ();
<               NS_ABORT_MSG_IF (firsthdr.GetAddr1 () != m_self, "All MPDUs of A-MPDU should have the same destination address");
<               if (*status) //PER and thus CRC check succeeded
---
>               NS_FATAL_ERROR ("Received A-MPDU with invalid first MPDU type");
>             }
> 
>           if (ampdu.GetRemainingNbOfMpdus () == 0 && !singleMpdu)
>             {
>               if (normalAck)
3491c2502,2503
<                   if (psdu->IsSingle ())
---
>                   //send block Ack
>                   if (firsthdr.IsBlockAckReq ())
3493,3495c2505
<                       //If the MPDU is sent as a VHT/HE single MPDU (EOF=1 in A-MPDU subframe header), then the responder sends an Ack.
<                       NS_LOG_DEBUG ("Receive S-MPDU");
<                       ampduSubframe = false;
---
>                       NS_FATAL_ERROR ("Sending a BlockAckReq with QosPolicy equal to Normal Ack");
3497c2507,2509
<                   else if (!m_sendAckEvent.IsRunning () && firsthdr.IsQosAck ()) // Implicit BAR Ack Policy
---
>                   uint8_t tid = firsthdr.GetQosTid ();
>                   AgreementsI it = m_bAckAgreements.find (std::make_pair (firsthdr.GetAddr2 (), tid));
>                   if (it != m_bAckAgreements.end ())
3499,3504c2511,2514
<                       m_sendAckEvent = Simulator::Schedule (GetSifs (),
<                                                             &MacLow::SendBlockAckAfterAmpdu, this,
<                                                             firsthdr.GetQosTid (),
<                                                             firsthdr.GetAddr2 (),
<                                                             firsthdr.GetDuration (),
<                                                             txVector, rxSnr);
---
>                       /* See section 11.5.3 in IEEE 802.11 for mean of this timer */
>                       ResetBlockAckInactivityTimerIfNeeded (it->second.first);
>                       NS_LOG_DEBUG ("rx A-MPDU/sendImmediateBlockAck from=" << firsthdr.GetAddr2 ());
>                       NS_ASSERT (m_sendAckEvent.IsRunning ());
3505a2516,2528
>                   else
>                     {
>                       NS_LOG_DEBUG ("There's not a valid agreement for this block ack request.");
>                     }
>                 }
>             }
>         }
>     }
>   else
>     {
>       ReceiveOk (aggregatedPacket, rxSnr, txVector, ampduSubframe);
>     }
> }
3507c2530,2649
<                   if (firsthdr.IsAck () || firsthdr.IsBlockAck () || firsthdr.IsBlockAckReq ())
---
> bool
> MacLow::StopMpduAggregation (Ptr<const Packet> peekedPacket, WifiMacHeader peekedHdr, Ptr<Packet> aggregatedPacket, uint8_t blockAckSize) const
> {
>   if (peekedPacket == 0)
>     {
>       NS_LOG_DEBUG ("no more packets in queue");
>       return true;
>     }
> 
>   Time aPPDUMaxTime = MicroSeconds (5484);
>   uint8_t tid = GetTid (peekedPacket, peekedHdr);
>   AcIndex ac = QosUtilsMapTidToAc (tid);
>   std::map<AcIndex, Ptr<QosTxop> >::const_iterator edcaIt = m_edca.find (ac);
> 
>   if (m_phy->GetGreenfield ())
>     {
>       aPPDUMaxTime = MicroSeconds (10000);
>     }
> 
>   //A STA shall not transmit a PPDU that has a duration that is greater than aPPDUMaxTime
>   if (m_phy->CalculateTxDuration (aggregatedPacket->GetSize () + peekedPacket->GetSize () + peekedHdr.GetSize () + WIFI_MAC_FCS_LENGTH, m_currentTxVector, m_phy->GetFrequency ()) > aPPDUMaxTime)
>     {
>       NS_LOG_DEBUG ("no more packets can be aggregated to satisfy PPDU <= aPPDUMaxTime");
>       return true;
>     }
> 
>   if (!edcaIt->second->GetMpduAggregator ()->CanBeAggregated (peekedPacket->GetSize () + peekedHdr.GetSize () + WIFI_MAC_FCS_LENGTH, aggregatedPacket, blockAckSize))
>     {
>       NS_LOG_DEBUG ("no more packets can be aggregated because the maximum A-MPDU size has been reached");
>       return true;
>     }
> 
>   return false;
> }
> 
> Ptr<Packet>
> MacLow::AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr)
> {
>   bool isAmpdu = false;
>   Ptr<Packet> newPacket, tempPacket;
>   WifiMacHeader peekedHdr;
>   newPacket = packet->Copy ();
>   Ptr<Packet> currentAggregatedPacket;
>   CtrlBAckRequestHeader blockAckReq;
> 
>   if (hdr.IsBlockAckReq ())
>     {
>       //Workaround to avoid BlockAckReq to be part of an A-MPDU. The standard says that
>       //BlockAckReq is not present in A-MPDU if any QoS data frames for that TID are present.
>       //Since an A-MPDU in non-PSMP frame exchanges aggregates MPDUs from one TID, this means
>       //we should stop aggregation here for single-TID A-MPDUs. Once PSMP and multi-TID A-MPDUs
>       //are supported, the condition of entering here should be changed.
>       return newPacket;
>     }
> 
>   //missing hdr.IsAck() since we have no means of knowing the Tid of the Ack yet
>   if (hdr.IsQosData () || hdr.IsBlockAck ()|| hdr.IsBlockAckReq ())
>     {
>       Time tstamp;
>       uint8_t tid = GetTid (packet, hdr);
>       Ptr<WifiMacQueue> queue;
>       Ptr<Packet> aggPacket;
>       AcIndex ac = QosUtilsMapTidToAc (tid);
>       std::map<AcIndex, Ptr<QosTxop> >::const_iterator edcaIt = m_edca.find (ac);
>       NS_ASSERT (edcaIt != m_edca.end ());
>       queue = edcaIt->second->GetWifiMacQueue ();
> 
>       if (!hdr.GetAddr1 ().IsBroadcast () && edcaIt->second->GetMpduAggregator () != 0)
>         {
>           //Have to make sure that their exist a block Ack agreement before sending an AMPDU (BlockAck Manager)
>           if (edcaIt->second->GetBaAgreementExists (hdr.GetAddr1 (), tid))
>             {
>               /* here is performed mpdu aggregation */
>               /* MSDU aggregation happened in edca if the user asked for it so m_currentPacket may contains a normal packet or a A-MSDU*/
>               currentAggregatedPacket = Create<Packet> ();
>               peekedHdr = hdr;
>               uint16_t startingSequenceNumber = 0;
>               uint16_t currentSequenceNumber = 0;
>               uint8_t qosPolicy = 0;
>               uint8_t blockAckSize = 0;
>               bool aggregated = false;
>               uint8_t i = 0;
>               aggPacket = newPacket->Copy ();
> 
>               if (!hdr.IsBlockAckReq ())
>                 {
>                   if (!hdr.IsBlockAck ())
>                     {
>                       startingSequenceNumber = peekedHdr.GetSequenceNumber ();
>                       peekedHdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
>                     }
>                   currentSequenceNumber = peekedHdr.GetSequenceNumber ();
>                   newPacket->AddHeader (peekedHdr);
>                   AddWifiMacTrailer (newPacket);
> 
>                   aggregated = edcaIt->second->GetMpduAggregator ()->Aggregate (newPacket, currentAggregatedPacket);
> 
>                   if (aggregated)
>                     {
>                       NS_LOG_DEBUG ("Adding packet with sequence number " << currentSequenceNumber << " to A-MPDU, packet size = " << newPacket->GetSize () << ", A-MPDU size = " << currentAggregatedPacket->GetSize ());
>                       i++;
>                       m_aggregateQueue[tid]->Enqueue (Create<WifiMacQueueItem> (aggPacket, peekedHdr));
>                     }
>                 }
>               else if (hdr.IsBlockAckReq ())
>                 {
>                   blockAckSize = static_cast<uint8_t> (packet->GetSize () + hdr.GetSize () + WIFI_MAC_FCS_LENGTH);
>                   qosPolicy = 3; //if the last subframe is block ack req then set ack policy of all frames to blockack
>                   packet->PeekHeader (blockAckReq);
>                   startingSequenceNumber = blockAckReq.GetStartingSequence ();
>                 }
>               /// \todo We should also handle Ack and BlockAck
>               bool retry = false;
>               //looks for other packets to the same destination with the same Tid need to extend that to include MSDUs
>               Ptr<const Packet> peekedPacket = edcaIt->second->PeekNextRetransmitPacket (peekedHdr, tid, &tstamp);
>               if (peekedPacket == 0)
>                 {
>                   Ptr<const WifiMacQueueItem> item = queue->PeekByTidAndAddress (tid,
>                                                                                  hdr.GetAddr1 ());
>                   if (item)
3509c2651,2653
<                       ReceiveOk ((*n), rxSnr, txVector, ampduSubframe);
---
>                       peekedPacket = item->GetPacket ();
>                       peekedHdr = item->GetHeader ();
>                       tstamp = item->GetTimeStamp ();
3511c2655,2658
<                   else if (firsthdr.IsData () || firsthdr.IsQosData ())
---
>                   currentSequenceNumber = edcaIt->second->PeekNextSequenceNumberFor (&peekedHdr);
> 
>                   /* here is performed MSDU aggregation (two-level aggregation) */
>                   if (peekedPacket != 0 && edcaIt->second->GetMsduAggregator () != 0)
3513,3515c2660,2661
<                       NS_LOG_DEBUG ("Deaggregate packet from " << firsthdr.GetAddr2 () << " with sequence=" << firsthdr.GetSequenceNumber ());
<                       ReceiveOk ((*n), rxSnr, txVector, ampduSubframe);
<                       if (firsthdr.IsQosAck ())
---
>                       tempPacket = PerformMsduAggregation (peekedPacket, &peekedHdr, &tstamp, currentAggregatedPacket, blockAckSize);
>                       if (tempPacket != 0)  //MSDU aggregation
3517,3518c2663
<                           NS_LOG_DEBUG ("Normal Ack");
<                           normalAck = true;
---
>                           peekedPacket = tempPacket->Copy ();
3520a2666,2687
>                 }
>               else
>                 {
>                   retry = true;
>                   currentSequenceNumber = peekedHdr.GetSequenceNumber ();
>                 }
> 
>               while (IsInWindow (currentSequenceNumber, startingSequenceNumber, 64) && !StopMpduAggregation (peekedPacket, peekedHdr, currentAggregatedPacket, blockAckSize))
>                 {
>                   //for now always send AMPDU with normal ACK
>                   if (retry == false)
>                     {
>                       currentSequenceNumber = edcaIt->second->GetNextSequenceNumberFor (&peekedHdr);
>                       peekedHdr.SetSequenceNumber (currentSequenceNumber);
>                       peekedHdr.SetFragmentNumber (0);
>                       peekedHdr.SetNoMoreFragments ();
>                       peekedHdr.SetNoRetry ();
>                     }
>                   if (qosPolicy == 0)
>                     {
>                       peekedHdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
>                     }
3523c2690
<                       NS_FATAL_ERROR ("Received A-MPDU with invalid first MPDU type");
---
>                       peekedHdr.SetQosAckPolicy (WifiMacHeader::BLOCK_ACK);
3526c2693,2699
<                   if (!psdu->IsSingle ())
---
>                   newPacket = peekedPacket->Copy ();
>                   aggPacket = newPacket->Copy ();
> 
>                   newPacket->AddHeader (peekedHdr);
>                   AddWifiMacTrailer (newPacket);
>                   aggregated = edcaIt->second->GetMpduAggregator ()->Aggregate (newPacket, currentAggregatedPacket);
>                   if (aggregated)
3528c2701,2702
<                       if (normalAck)
---
>                       m_aggregateQueue[tid]->Enqueue (Create<WifiMacQueueItem> (aggPacket, peekedHdr));
>                       if (i == 1 && hdr.IsQosData ())
3530,3531c2704
<                           //send BlockAck
<                           if (firsthdr.IsBlockAckReq ())
---
>                           if (!m_txParams.MustSendRts ())
3533c2706
<                               NS_FATAL_ERROR ("Sending a BlockAckReq with QosPolicy equal to Normal Ack");
---
>                               edcaIt->second->CompleteMpduTx (packet, hdr, tstamp);
3535,3537c2708
<                           uint8_t tid = firsthdr.GetQosTid ();
<                           AgreementsI it = m_bAckAgreements.find (std::make_pair (firsthdr.GetAddr2 (), tid));
<                           if (it != m_bAckAgreements.end ())
---
>                           else
3539,3542c2710
<                               /* See section 11.5.3 in IEEE 802.11 for the definition of this timer */
<                               ResetBlockAckInactivityTimerIfNeeded (it->second.first);
<                               NS_LOG_DEBUG ("rx A-MPDU/sendImmediateBlockAck from=" << firsthdr.GetAddr2 ());
<                               NS_ASSERT (m_sendAckEvent.IsRunning ());
---
>                               InsertInTxQueue (packet, hdr, tstamp, tid);
3544c2712,2782
<                           else
---
>                         }
>                       NS_LOG_DEBUG ("Adding packet with sequence number " << peekedHdr.GetSequenceNumber () << " to A-MPDU, packet size = " << newPacket->GetSize () << ", A-MPDU size = " << currentAggregatedPacket->GetSize ());
>                       i++;
>                       isAmpdu = true;
>                       if (!m_txParams.MustSendRts ())
>                         {
>                           edcaIt->second->CompleteMpduTx (peekedPacket, peekedHdr, tstamp);
>                         }
>                       else
>                         {
>                           InsertInTxQueue (peekedPacket, peekedHdr, tstamp, tid);
>                         }
>                       if (retry)
>                         {
>                           edcaIt->second->RemoveRetransmitPacket (tid, hdr.GetAddr1 (), peekedHdr.GetSequenceNumber ());
>                         }
>                       else
>                         {
>                           queue->Remove (peekedPacket);
>                         }
>                       newPacket = 0;
>                     }
>                   else
>                     {
>                       break;
>                     }
>                   if (retry == true)
>                     {
>                       peekedPacket = edcaIt->second->PeekNextRetransmitPacket (peekedHdr, tid, &tstamp);
>                       if (peekedPacket == 0)
>                         {
>                           //I reached the first packet that I added to this A-MPDU
>                           retry = false;
>                           Ptr<const WifiMacQueueItem> item = queue->PeekByTidAndAddress (tid,
>                                                                                          hdr.GetAddr1 ());
>                           if (item != 0)
>                             {
>                               peekedPacket = item->GetPacket ();
>                               peekedHdr = item->GetHeader ();
>                               tstamp = item->GetTimeStamp ();
>                               //find what will the sequence number be so that we don't send more than 64 packets apart
>                               currentSequenceNumber = edcaIt->second->PeekNextSequenceNumberFor (&peekedHdr);
> 
>                               if (edcaIt->second->GetMsduAggregator () != 0)
>                                 {
>                                   tempPacket = PerformMsduAggregation (peekedPacket, &peekedHdr, &tstamp, currentAggregatedPacket, blockAckSize);
>                                   if (tempPacket != 0) //MSDU aggregation
>                                     {
>                                       peekedPacket = tempPacket->Copy ();
>                                     }
>                                 }
>                             }
>                         }
>                       else
>                         {
>                           currentSequenceNumber = peekedHdr.GetSequenceNumber ();
>                         }
>                     }
>                   else
>                     {
>                       Ptr<const WifiMacQueueItem> item = queue->PeekByTidAndAddress (tid,
>                                                                                      hdr.GetAddr1 ());
>                       if (item != 0)
>                         {
>                           peekedPacket = item->GetPacket ();
>                           peekedHdr = item->GetHeader ();
>                           tstamp = item->GetTimeStamp ();
>                           //find what will the sequence number be so that we don't send more than 64 packets apart
>                           currentSequenceNumber = edcaIt->second->PeekNextSequenceNumberFor (&peekedHdr);
> 
>                           if (edcaIt->second->GetMsduAggregator () != 0 && IsInWindow (currentSequenceNumber, startingSequenceNumber, 64))
3546c2784,2788
<                               NS_LOG_DEBUG ("There's not a valid agreement for this block ack request.");
---
>                               tempPacket = PerformMsduAggregation (peekedPacket, &peekedHdr, &tstamp, currentAggregatedPacket, blockAckSize);
>                               if (tempPacket != 0) //MSDU aggregation
>                                 {
>                                   peekedPacket = tempPacket->Copy ();
>                                 }
3548a2791,2833
>                       else
>                         {
>                           peekedPacket = 0;
>                         }
>                     }
>                 }
> 
>               if (isAmpdu)
>                 {
>                   if (hdr.IsBlockAckReq ())
>                     {
>                       newPacket = packet->Copy ();
>                       peekedHdr = hdr;
>                       aggPacket = newPacket->Copy ();
>                       m_aggregateQueue[tid]->Enqueue (Create<WifiMacQueueItem> (aggPacket, peekedHdr));
>                       newPacket->AddHeader (peekedHdr);
>                       AddWifiMacTrailer (newPacket);
>                       edcaIt->second->GetMpduAggregator ()->Aggregate (newPacket, currentAggregatedPacket);
>                       currentAggregatedPacket->AddHeader (blockAckReq);
>                     }
> 
>                   if (qosPolicy == 0)
>                     {
>                       edcaIt->second->CompleteAmpduTransfer (hdr.GetAddr1 (), tid);
>                     }
> 
>                   //Add packet tag
>                   AmpduTag ampdutag;
>                   ampdutag.SetRemainingNbOfMpdus (i - 1);
>                   newPacket = currentAggregatedPacket;
>                   newPacket->AddPacketTag (ampdutag);
> 
>                   NS_LOG_DEBUG ("tx unicast A-MPDU");
>                   edcaIt->second->SetAmpduExist (hdr.GetAddr1 (), true);
>                 }
>               else
>                 {
>                   uint32_t queueSize = m_aggregateQueue[tid]->GetNPackets ();
>                   NS_ASSERT (queueSize <= 2); //since it is not an A-MPDU then only 2 packets should have been added to the queue no more
>                   if (queueSize >= 1)
>                     {
>                       //remove any packets that we added to the aggregate queue
>                       FlushAggregateQueue (tid);
3551a2837,2868
>           // VHT/HE single MPDU operation
>           WifiTxVector dataTxVector = GetDataTxVector (m_currentPacket, &m_currentHdr);
>           if (!isAmpdu
>               && hdr.IsQosData ()
>               && (dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_VHT
>                   || dataTxVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HE))
>             {
>               peekedHdr = hdr;
>               peekedHdr.SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
> 
>               currentAggregatedPacket = Create<Packet> ();
>               edcaIt->second->GetMpduAggregator ()->AggregateSingleMpdu (packet, currentAggregatedPacket);
>               m_aggregateQueue[tid]->Enqueue (Create<WifiMacQueueItem> (packet, peekedHdr));
>               if (m_txParams.MustSendRts ())
>                 {
>                   InsertInTxQueue (packet, peekedHdr, tstamp, tid);
>                 }
>               if (edcaIt->second->GetBaAgreementExists (hdr.GetAddr1 (), tid))
>                 {
>                   edcaIt->second->CompleteAmpduTransfer (peekedHdr.GetAddr1 (), tid);
>                 }
> 
>               //Add packet tag
>               AmpduTag ampdutag;
>               newPacket = currentAggregatedPacket;
>               newPacket->AddHeader (peekedHdr);
>               AddWifiMacTrailer (newPacket);
>               newPacket->AddPacketTag (ampdutag);
> 
>               NS_LOG_DEBUG ("tx unicast S-MPDU with sequence number " << hdr.GetSequenceNumber ());
>               edcaIt->second->SetAmpduExist (hdr.GetAddr1 (), true);
>             }
3554c2871,2922
<   else
---
>   return newPacket;
> }
> 
> void
> MacLow::FlushAggregateQueue (uint8_t tid)
> {
>   if (!m_aggregateQueue[tid]->IsEmpty ())
>     {
>       NS_LOG_DEBUG ("Flush aggregate queue");
>       m_aggregateQueue[tid]->Flush ();
>     }
>   m_txPackets[tid].clear ();
> }
> 
> void
> MacLow::InsertInTxQueue (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp, uint8_t tid)
> {
>   NS_LOG_FUNCTION (this);
>   Item item;
>   item.packet = packet;
>   item.hdr = hdr;
>   item.timestamp = tStamp;
>   m_txPackets[tid].push_back (item);
> }
> 
> Ptr<Packet>
> MacLow::PerformMsduAggregation (Ptr<const Packet> packet, WifiMacHeader *hdr, Time *tstamp, Ptr<Packet> currentAmpduPacket, uint8_t blockAckSize)
> {
>   bool msduAggregation = false;
>   bool isAmsdu = false;
>   Ptr<Packet> currentAmsduPacket = Create<Packet> ();
>   Ptr<Packet> tempPacket = Create<Packet> ();
> 
>   Ptr<WifiMacQueue> queue;
>   AcIndex ac = QosUtilsMapTidToAc (GetTid (packet, *hdr));
>   std::map<AcIndex, Ptr<QosTxop> >::const_iterator edcaIt = m_edca.find (ac);
>   NS_ASSERT (edcaIt != m_edca.end ());
>   queue = edcaIt->second->GetWifiMacQueue ();
> 
>   Ptr<const WifiMacQueueItem> peekedItem = queue->DequeueByTidAndAddress (hdr->GetQosTid (),
>                                                                           hdr->GetAddr1 ());
>   if (peekedItem)
>     {
>       *hdr = peekedItem->GetHeader ();
>     }
> 
>   edcaIt->second->GetMsduAggregator ()->Aggregate (packet, currentAmsduPacket,
>                                                    edcaIt->second->MapSrcAddressForAggregation (*hdr),
>                                                    edcaIt->second->MapDestAddressForAggregation (*hdr));
> 
>   peekedItem = queue->PeekByTidAndAddress (hdr->GetQosTid (), hdr->GetAddr1 ());
>   while (peekedItem != 0)
3556,3560c2924,2937
<       /* Simple MPDU */
<       NS_ASSERT (!psdu->IsAggregate ());
<       /* Check if the MPDU contains a Short SSW packet */
<       if (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL && psdu->GetSize () == 6)
<         ReceiveShortSswOk ((*psdu->begin ()), rxSnr, txVector, ampduSubframe);
---
>       *hdr = peekedItem->GetHeader ();
>       *tstamp = peekedItem->GetTimeStamp ();
>       tempPacket = currentAmsduPacket;
> 
>       msduAggregation = edcaIt->second->GetMsduAggregator ()->Aggregate (peekedItem->GetPacket (), tempPacket,
>                                                                          edcaIt->second->MapSrcAddressForAggregation (*hdr),
>                                                                          edcaIt->second->MapDestAddressForAggregation (*hdr));
> 
>       if (msduAggregation && !StopMpduAggregation (tempPacket, *hdr, currentAmpduPacket, blockAckSize))
>         {
>           isAmsdu = true;
>           currentAmsduPacket = tempPacket;
>           queue->Remove (peekedItem->GetPacket ());
>         }
3562c2939,2955
<         ReceiveOk ((*psdu->begin ()), rxSnr, txVector, ampduSubframe);
---
>         {
>           break;
>         }
>       peekedItem = queue->PeekByTidAndAddress (hdr->GetQosTid (), hdr->GetAddr1 ());
>     }
> 
>   if (isAmsdu)
>     {
>       NS_LOG_DEBUG ("A-MSDU with size = " << currentAmsduPacket->GetSize ());
>       hdr->SetQosAmsdu ();
>       hdr->SetAddr3 (GetBssid ());
>       return currentAmsduPacket;
>     }
>   else
>     {
>       queue->PushFront (Create<WifiMacQueueItem> (packet, *hdr));
>       return 0;
3578c2971
<   return (m_stationManager->GetPcfSupported () && m_cfpStart.IsStrictlyPositive ());
---
>   return (m_stationManager->HasPcfSupported () && m_cfpStart.IsStrictlyPositive ());
diff ../../NS3-WiGig/src/wifi/model/mac-low.h ../../ns-3-dev-git/src/wifi/model/mac-low.h
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
22d20
<  *          Hany Assasa <hany.assasa@gmail.com>
39c37,39
< #include "wigig-data-types.h"
---
> 
> class TwoLevelAggregationTest;
> class AmpduAggregationTest;
43d42
< class WifiMac;
49d47
< class WifiPsdu;
55,56d52
< class MsduAggregator;
< class MpduAggregator;
60c56
<  * \brief handle RTS/CTS/Data/Ack transactions.
---
>  * \brief handle RTS/CTS/DATA/ACK transactions.
65c61,64
< 
---
>   /// Allow test cases to access private members
>   friend class ::TwoLevelAggregationTest;
>   /// Allow test cases to access private members
>   friend class ::AmpduAggregationTest;
69c68
<   typedef Callback<void, Ptr<WifiMacQueueItem>> MacLowRxCallback;
---
>   typedef Callback<void, Ptr<Packet>, const WifiMacHeader*> MacLowRxCallback;
95,105d93
<    * \param tid the Traffic ID
<    * \return the QosTxop corresponding to the given TID
<    */
<   Ptr<QosTxop> GetEdca (uint8_t tid) const;
<   /**
<    * Set up WifiMac associated with this MacLow.
<    *
<    * \param mac WifiMac associated with this MacLow
<    */
<   void SetMac (const Ptr<WifiMac> mac);
<   /**
118c106
<    * Set Ack timeout of this MacLow.
---
>    * Set ACK timeout of this MacLow.
120c108
<    * \param ackTimeout Ack timeout of this MacLow
---
>    * \param ackTimeout ACK timeout of this MacLow
124c112
<    * Set Basic BlockAck timeout of this MacLow.
---
>    * Set Basic Block ACK timeout of this MacLow.
126c114
<    * \param blockAckTimeout Basic BlockAck timeout of this MacLow
---
>    * \param blockAckTimeout Basic Block ACK timeout of this MacLow
130c118
<    * Set Compressed BlockAck timeout of this MacLow.
---
>    * Set Compressed Block ACK timeout of this MacLow.
132c120
<    * \param blockAckTimeout Compressed BlockAck timeout of this MacLow
---
>    * \param blockAckTimeout Compressed Block ACK timeout of this MacLow
141a130,135
>    * Set CTS timeout of this MacLow.
>    *
>    * \param ctsTimeout CTS timeout of this MacLow
>    */
>   void SetCtsTimeout (Time ctsTimeout);
>   /**
173,198d166
<   //// WIGIG ////
<   /**
<    * Set Short Beamforming Interframe Space (SBIFS) of this MacLow.
<    *
<    * \param sbifs SBIFS of this MacLow
<    */
<   void SetSbifs (Time sbifs);
<   /**
<    * Set Medimum Beamforming Interframe Space (SBIFS) of this MacLow.
<    *
<    * \param mbifs MBIFS of this MacLow
<    */
<   void SetMbifs (Time mbifs);
<   /**
<    * Set Long Beamforming Interframe Space (LBIFS) of this MacLow.
<    *
<    * \param lbifs LBIFS of this MacLow
<    */
<   void SetLbifs (Time lbifs);
<   /**
<    * Set Beam Refinement Interframe Space (BRIFS) of this MacLow.
<    *
<    * \param sbifs SBIFS of this MacLow
<    */
<   void SetBrifs (Time brifs);
<   //// WIGIG ////
214c182
<   bool GetCtsToSelfSupported (void) const;
---
>   bool GetCtsToSelfSupported () const;
222c190
<    * Return Ack timeout of this MacLow.
---
>    * Return ACK timeout of this MacLow.
224c192
<    * \return Ack timeout
---
>    * \return ACK timeout
228c196
<    * Return Basic BlockAck timeout of this MacLow.
---
>    * Return Basic Block ACK timeout of this MacLow.
230c198
<    * \return Basic BlockAck timeout
---
>    * \return Basic Block ACK timeout
232c200
<   Time GetBasicBlockAckTimeout (void) const;
---
>   Time GetBasicBlockAckTimeout () const;
234c202
<    * Return Compressed BlockAck timeout of this MacLow.
---
>    * Return Compressed Block ACK timeout of this MacLow.
236c204
<    * \return Compressed BlockAck timeout
---
>    * \return Compressed Block ACK timeout
238c206,212
<   Time GetCompressedBlockAckTimeout (void) const;
---
>   Time GetCompressedBlockAckTimeout () const;
>   /**
>    * Return CTS timeout of this MacLow.
>    *
>    * \return CTS timeout
>    */
>   Time GetCtsTimeout (void) const;
275,300d248
<   //// WIGIG ////
<   /**
<    * Return Short Beamforming Interframe Space (SBIFS) of this MacLow.
<    *
<    * \return SBIFS
<    */
<   Time GetSbifs (void) const;
<   /**
<    * Return Medium Beamforming Interframe Space (SBIFS) of this MacLow.
<    *
<    * \return MBIFS
<    */
<   Time GetMbifs (void) const;
<   /**
<    * Return Large Beamforming Interframe Space (LBIFS) of this MacLow.
<    *
<    * \return LBIFS
<    */
<   Time GetLbifs (void) const;
<   /**
<    * Return Beamforming Refinement Interframe Space (BRIFS) of this MacLow.
<    *
<    * \return BRIFS
<    */
<   Time GetBrifs (void) const;
<   //// WIGIG ////
321c269
<   void SetRxCallback (Callback<void, Ptr<WifiMacQueueItem>> callback);
---
>   void SetRxCallback (Callback<void,Ptr<Packet>,const WifiMacHeader *> callback);
323,324c271
<    * \param channelAccessManager pointer to ChannelAccessManager in order to listen to NAV events
<    *        for every incoming and outgoing packet.
---
>    * \param dcf listen to NAV events for every incoming and outgoing packet.
326c273
<   void RegisterChannelAccessManager (Ptr<ChannelAccessManager> channelAccessManager);
---
>   void RegisterDcf (Ptr<ChannelAccessManager> dcf);
329,362d275
<    * Check whether the given MPDU, if transmitted according to the given TX vector,
<    * meets the constraint on the maximum A-MPDU size (by assuming that the frame
<    * has to be aggregated to an existing A-MPDU of the given size) and its
<    * transmission time exceeds neither the max PPDU duration (depending on the
<    * PPDU format) nor the given PPDU duration limit (if strictly positive).
<    * The given MPDU needs to be a QoS Data frame.
<    *
<    * \param mpdu the MPDU.
<    * \param txVector the TX vector used to transmit the MPDU
<    * \param ampduSize the size of the existing A-MPDU in bytes, if any
<    * \param ppduDurationLimit the limit on the PPDU duration
<    * \returns true if constraints on size and duration limit are met.
<    */
<   bool IsWithinSizeAndTimeLimits (Ptr<const WifiMacQueueItem> mpdu, WifiTxVector txVector,
<                                   uint32_t ampduSize, Time ppduDurationLimit);
<   /**
<    * Check whether an MPDU of the given size, destined to the given receiver and
<    * belonging to the given TID, if transmitted according to the given TX vector,
<    * meets the constraint on the maximum A-MPDU size (by assuming that the frame
<    * has to be aggregated to an existing A-MPDU of the given size) and its
<    * transmission time exceeds neither the max PPDU duration (depending on the
<    * PPDU format) nor the given PPDU duration limit (if strictly positive).
<    *
<    * \param mpduSize the MPDU size.
<    * \param receiver the receiver
<    * \param tid the TID
<    * \param txVector the TX vector used to transmit the MPDU
<    * \param ampduSize the size of the existing A-MPDU in bytes, if any
<    * \param ppduDurationLimit the limit on the PPDU duration
<    * \returns true if constraints on size and duration limit are met.
<    */
<   bool IsWithinSizeAndTimeLimits (uint32_t mpduSize, Mac48Address receiver, uint8_t tid,
<                                   WifiTxVector txVector, uint32_t ampduSize, Time ppduDurationLimit);
<   /**
379c292
<    * \param fragmentSize the packet fragment size (if fragmentation is used) in bytes
---
>    * \param fragmentSize the packet fragment size (if fragmentation is used)
382c295
<    * This transmission time does not include the time required for
---
>    * This transmission time includes the time required for
391,402c304,305
<    * \param item packet to send (does not include the 802.11 MAC header and checksum)
<    * \param params transmission parameters of packet.
<    * \return the transmission time that does not include the time required to transmit the frame
<    *
<    * This transmission time  only includes the time for the RTS/CTS exchange (if any)
<    * and for the Ack frame (if any).
<    */
<   Time CalculateOverheadTxTime (Ptr<const WifiMacQueueItem> item,
<                                const MacLowTransmissionParameters& params) const;
< 
<   /**
<    * \param mpdu packet to send
---
>    * \param packet packet to send
>    * \param hdr 802.11 header for packet to send
409c312,313
<   virtual void StartTransmission (Ptr<WifiMacQueueItem> mpdu,
---
>   virtual void StartTransmission (Ptr<const Packet> packet,
>                                   const WifiMacHeader* hdr,
413,428d316
<   //// WIGIG ////
<   typedef Callback<void, const WifiMacHeader &> TransmissionOkCallback;
<   typedef Callback<void> TransmissionShortSswOkCallback;
< 
<   /**
<    * \param mpdu packet to send
<    * \param parameters the transmission parameters to use for this packet.
<    * \param txop pointer to the calling Txop.
<    *
<    * Start the transmission of the input packet and notify the listener
<    * of transmission events.
<    * Note: This function is used for DMG/EDMG management and control frames transmission.
<    */
<   void TransmitSingleFrame (Ptr<WifiMacQueueItem> mpdu,
<                             MacLowTransmissionParameters params,
<                             Ptr<Txop> txop);
430,535c318,320
<    * \param mpdu packet to send
<    * \param parameters the transmission parameters to use for this packet.
<    * \param listener listen to transmission events.
<    *
<    * Start the transmission of the input packet and notify the listener
<    * of transmission events.
<    */
<   virtual void StartTransmission (Ptr<WifiMacQueueItem> mpdu,
<                                   MacLowTransmissionParameters parameters,
<                                   TransmissionOkCallback callback);
<   /**
<    * \param mpdu packet to send
<    * \param parameters the transmission parameters to use for this packet.
<    * \param listener listen to transmission events.
<    *
<    * Start the transmission of the input Short SSW packet and notify the listener
<    * of transmission events.
<    */
<   void StartShortSswTransmission (Ptr<WifiMacQueueItem> mpdu,
<                           MacLowTransmissionParameters parameters,
<                           TransmissionShortSswOkCallback callback);
<   /**
<    * Resume Transmission for the current allocation if transmission has been suspended.
<    * \param overrideDuration Flagt to indicate if we want to override duration field
<    * \param duration The duration of the current Allocation
<    * \param listener
<    */
< //  void ResumeTransmission (bool overrideDuration, Time duration, MacLowTransmissionListener *listener);
<   
<   /**
<    * IsCurrentAllocationEmpty
<    * \return True if the current allocation pointer is empty, otherwise false.
<    */
<   bool IsCurrentAllocationEmpty (void) const;
<   /**
<    * Resume Transmission for the current allocation if transmission has been suspended.
<    * \param duration The remaining duration of the current resumed allocation.
<    * \param txop Pointer to the transmit opprtunity associated with the suspedned transmission.
<    */
<   void ResumeTransmission (Time duration, Ptr<Txop> txop);
<   /**
<    * Abort suspended transmission - in case the suspended packet lifetime has passed.
<    */
<   void AbortSuspendedTransmission (void);
< 
< 
<   void ChangeAllocationPacketsAddress (AllocationID allocationId, Mac48Address destAdd);
<   /**
<    * Restore Allocation Parameters for specific allocation SP or CBAP.
<    * \param allocationId The ID of the allocation.
<    */
<   void RestoreAllocationParameters (AllocationID allocationId);
<   /**
<    * Store parameters related to the current allocation.
<    */
<   void StoreAllocationParameters (void);
<   /**
<    * This function is called upon the end of the current allocation period.
<    */
<   void EndAllocationPeriod (void);
<   /**
<    * Check whether a transmission has been suspended due to time constraints for the restored or current allocation.
<    * \return True if transmission has been suspended, otherwise false.
<    */
<   bool IsTransmissionSuspended (void) const;
<   /**
<    * Check whether we have completed the transmission of a suspended PSDU for the given Txop.
<    * \param txop A pointer to the Txop utilizing the current allocation for which the PSDU transmission has been suspended.
<    * \return True if we've completed the transmission for the restored suspended transmission corresponding to the given Txop,
<    *          otherwise false.
<    */
<   bool CompletedSuspendedPsduTransmission (Ptr<Txop> txop) const;
<   /**
<    * Check whether there has been a switch in the transmission mode (SISO/MIMO) between the suspension of the transmission and its restoration.
<    * \return True if there has been a switch in the transmission mode between the suspenssion and restoration of the transmission.
<    */
<   bool SwitchInTransmissionMode (void) const;
<   //// WIGIG ////
< 
<   /**
<    * \param txVector the TXVECTOR decoded from PHY header.
<    * \param psduDuration the duration of the PSDU that is about to be received.
<    *
<    * This method is typically invoked by the lower PHY layer to notify
<    * the MAC layer that the reception of a PSDU is starting.
<    * This is equivalent to the PHY-RXSTART primitive.
<    * If the reception is correct for at least one MPDU of the PSDU
<    * the DeaggregateAmpduAndReceive will be called after \p psduDuration.
<    * Otherwise, ReceiveError will be called after the same duration.
<    */
<   void RxStartIndication (WifiTxVector txVector, Time psduDuration);
< 
<   /**
<    * \param mpdu MPDU received
<    * \param rxSnr snr of MPDU received in linear scale
<    * \param txVector TXVECTOR of MPDU received
<    * \param ampduSubframe true if this MPDU is part of an A-MPDU
<    *
<    * This method is typically invoked by the lower PHY layer to notify
<    * the MAC layer that an MPDU was successfully received.
<    */
<   void ReceiveOk (Ptr<WifiMacQueueItem> mpdu, double rxSnr, WifiTxVector txVector, bool ampduSubframe);
<   /**
<    * \param mpdu MPDU received
<    * \param rxSnr snr of MPDU received in linear scale
<    * \param txVector TXVECTOR of MPDU received
---
>    * \param packet packet received
>    * \param rxSnr snr of packet received
>    * \param txVector TXVECTOR of packet received
539c324
<    * the MAC layer that an Short SSW packet was successfully received.
---
>    * the MAC layer that a packet was successfully received.
541,542c326
<   void ReceiveShortSswOk (Ptr<WifiMacQueueItem> mpdu, double rxSnr, WifiTxVector txVector, bool ampduSubframe);
< 
---
>   void ReceiveOk (Ptr<Packet> packet, double rxSnr, WifiTxVector txVector, bool ampduSubframe);
544c328,329
<    * \param psdu PSDU received.
---
>    * \param packet packet received.
>    * \param rxSnr snr of packet received.
547c332
<    * the MAC layer that a PSDU was unsuccessfully received.
---
>    * the MAC layer that a packet was unsuccessfully received.
549c334
<   void ReceiveError (Ptr<WifiPsdu> psdu);
---
>   void ReceiveError (Ptr<Packet> packet, double rxSnr);
555c340
<    * occurs, pending MAC transmissions (RTS, CTS, Data and Ack) are cancelled.
---
>    * occurs, pending MAC transmissions (RTS, CTS, DATA and ACK) are cancelled.
561c346
<    * into sleep mode, pending MAC transmissions (RTS, CTS, Data and Ack) are cancelled.
---
>    * into sleep mode, pending MAC transmissions (RTS, CTS, DATA and ACK) are cancelled.
567c352
<    * into off mode, pending MAC transmissions (RTS, CTS, Data and Ack) are cancelled.
---
>    * into off mode, pending MAC transmissions (RTS, CTS, DATA and ACK) are cancelled.
572c357
<    *        frame).
---
>    * frame).
574c359
<    *        mechanism.
---
>    * mechanism.
576c361
<    *        packets for which block ack was negotiated.
---
>    * packets for which block ack was negotiated.
583c368
<    * for which block ack was negotiated.
---
>    * for which Block Ack was negotiated.
589,590c374,375
<    * \param originator Address of peer participating in block ack mechanism.
<    * \param tid TID for which block ack was created.
---
>    * \param originator Address of peer participating in Block Ack mechanism.
>    * \param tid TID for which Block Ack was created.
593c378
<    * for TID <i>tid</i>. If the agreement exists, tears down it. This function is typically
---
>    * for tid <i>tid</i>. If the agreement exists, tears down it. This function is typically
605a391,399
>    * \param packet the packet to be aggregated. If the aggregation is successful, it corresponds either to the first data packet that will be aggregated or to the BAR that will be piggybacked at the end of the A-MPDU.
>    * \param hdr the WifiMacHeader for the packet.
>    * \return the A-MPDU packet if aggregation is successful, the input packet otherwise
>    *
>    * This function adds the packets that will be added to an A-MPDU to an aggregate queue
>    *
>    */
>   Ptr<Packet> AggregateToAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr);
>   /**
607c401
<    * \param rxSnr SNR of packet received in linear scale
---
>    * \param rxSnr snr of packet received
609d402
<    * \param statusPerMpdu reception status per MPDU
614,616c407
<   void DeaggregateAmpduAndReceive (Ptr<WifiPsdu> aggregatedPacket, double rxSnr, WifiTxVector txVector,
<                                    std::vector<bool> statusPerMpdu);
< 
---
>   void DeaggregateAmpduAndReceive (Ptr<Packet> aggregatedPacket, double rxSnr, WifiTxVector txVector);
618,620c409,415
<    * Return a TXVECTOR for the Data frame given the destination.
<    * The function consults WifiRemoteStationManager, which controls the rate
<    * to different destinations.
---
>    * \param peekedPacket the packet to be aggregated
>    * \param peekedHdr the WifiMacHeader for the packet.
>    * \param aggregatedPacket the current A-MPDU
>    * \param blockAckSize the size of a piggybacked block ack request
>    * \return false if the given packet can be added to an A-MPDU, true otherwise
>    *
>    * This function decides if a given packet can be added to an A-MPDU or not
622,623d416
<    * \param item the item being asked for TXVECTOR
<    * \return TXVECTOR for the given item
625c418
<   virtual WifiTxVector GetDataTxVector (Ptr<const WifiMacQueueItem> item) const;
---
>   bool StopMpduAggregation (Ptr<const Packet> peekedPacket, WifiMacHeader peekedHdr, Ptr<Packet> aggregatedPacket, uint8_t blockAckSize) const;
627d419
<    * Start NAV with the given duration.
629,630c421,423
<    * \param duration the duration
<    * \return true if NAV is reset
---
>    * This function is called to flush the aggregate queue, which is used for A-MPDU
>    * \param tid the Traffic ID
>    *
632c425
<   bool DoNavStartNow (Time duration);
---
>   void FlushAggregateQueue (uint8_t tid);
634d426
<   //// WIGIG ////
636c428
<    * Return a TXVECTOR for the DMG Control frame given the destination.
---
>    * Return a TXVECTOR for the DATA frame given the destination.
640,662c432,434
<    * \param item the item being asked for TXVECTOR
<    * \return TXVECTOR for the given item
<    */
<   WifiTxVector GetDmgTxVector (Ptr<const WifiMacQueueItem> item) const;
<   /**
<    * SLS phase has started.
<    */
<   void SLS_Phase_Started (void);
<   /**
<    * SLS phase has ended.
<    */
<   void SLS_Phase_Ended (void);
<   /**
<    * Return whether we are performing SLS or not.
<    * \return True if we are performing SLS, otherwise false.
<    */
<   bool Is_Performing_SLS (void) const;
<   /**
<    * MIMO BFT phase has started.
<    */
<   void MIMO_BFT_Phase_Started (void);
<   /**
<    * MIMO BFT phase has ended.
---
>    * \param packet the packet being asked for TXVECTOR
>    * \param hdr the WifiMacHeader
>    * \return TXVECTOR for the given packet
664c436
<   void MIMO_BFT_Phase_Ended (void);
---
>   virtual WifiTxVector GetDataTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const;
666,667c438,441
<    * Return whether we are performing MIMO BFT or not.
<    * \return True if we are performing MIMO BFT, otherwise false.
---
>    * Start NAV with the given duration.
>    *
>    * \param duration the duration
>    * \return true if NAV is reset
669,671c443
<   bool Is_Performing_MIMO_BFT (void) const;
<   //// WIGIG ////
< 
---
>   bool DoNavStartNow (Time duration);
673,676c445
<    * This function indicates whether Simulator::Now is in the CF period.
<    *
<    * \return true if Simulator::Now is in CF period,
<    *         false otherwise
---
>    * This function indicates whether it is the CF period.
681,683d449
<    *
<    * \return true if a CF frame can be transmitted in the current CFP,
<    *         false otherwise
687,718d452
<   /**
<    * Returns the aggregator used to construct A-MSDU subframes.
<    *
<    * \return the aggregator used to construct A-MSDU subframes.
<    */
<   Ptr<MsduAggregator> GetMsduAggregator (void) const;
<   /**
<    * Returns the aggregator used to construct A-MPDU subframes.
<    *
<    * \return the aggregator used to construct A-MPDU subframes.
<    */
<   Ptr<MpduAggregator> GetMpduAggregator (void) const;
< 
<   /**
<    * Set the aggregator used to construct A-MSDU subframes.
<    *
<    * \param aggr pointer to the MSDU aggregator.
<    */
<   void SetMsduAggregator (const Ptr<MsduAggregator> aggr);
<   /**
<    * Set the aggregator used to construct A-MPDU subframes.
<    *
<    * \param aggr pointer to the MPDU aggregator.
<    */
<   void SetMpduAggregator (const Ptr<MpduAggregator> aggr);
<   /**
<    * Calculate DMG/EDMG transaction time including RTS/CTS, PSDU transmission time, acknowledgemen
<    * , and interframe spacing.
<    * \param psdu Pointer to the PSDU to be transmitted.
<    * \return The total transaction time.
<    */
<   Time CalculateWiGigTransactionTime (Ptr<WifiPsdu> psdu);
729c463
<    * \return the total CF-END size in bytes
---
>    * \return the total CF-END size
733c467
<    * Forward a PSDU down to WifiPhy for transmission.
---
>    * Forward the packet down to WifiPhy for transmission. This is called for the entire A-MPDu when MPDU aggregation is used.
735c469,470
<    * \param psdu the PSDU
---
>    * \param packet the packet
>    * \param hdr the header
738c473
<   void ForwardDown (Ptr<const WifiPsdu> psdu, WifiTxVector txVector);
---
>   void ForwardDown (Ptr<const Packet> packet, const WifiMacHeader *hdr, WifiTxVector txVector);
740,742c475
<    * Return a TXVECTOR for the RTS frame given the destination.
<    * The function consults WifiRemoteStationManager, which controls the rate
<    * to different destinations.
---
>    * Forward the MPDU down to WifiPhy for transmission. This is called for each MPDU when MPDU aggregation is used.
744,745c477,479
<    * \param item the item being asked for RTS TXVECTOR
<    * \return TXVECTOR for the RTS of the given item
---
>    * \param packet the packet
>    * \param txVector the transmit vector
>    * \param mpdutype the MPDU type
747,748c481
<   WifiTxVector GetRtsTxVector (Ptr<const WifiMacQueueItem> item) const;
<   //// WIGIG ////
---
>   void SendMpdu (Ptr<const Packet> packet, WifiTxVector txVector, MpduType mpdutype);
750c483,485
<    * Return the total DMG CTS size (including FCS trailer).
---
>    * Return a TXVECTOR for the RTS frame given the destination.
>    * The function consults WifiRemoteStationManager, which controls the rate
>    * to different destinations.
752c487,489
<    * \return the total DMG CTS size
---
>    * \param packet the packet being asked for RTS TXVECTOR
>    * \param hdr the WifiMacHeader
>    * \return TXVECTOR for the RTS of the given packet
754,760c491
<   static uint32_t GetDmgCtsSize (bool addControlTrailer = false);
<   /**
<    * Get DMG Control TxVector
<    * \return
<    */
<   WifiTxVector GetDmgControlTxVector (void) const;
<   //// WIGIG ////
---
>   WifiTxVector GetRtsTxVector (Ptr<const Packet> packet, const WifiMacHeader *hdr) const;
773c504
<    * Return a TXVECTOR for the Ack frame given the destination and the mode of the Data
---
>    * Return a TXVECTOR for the ACK frame given the destination and the mode of the DATA
778,780c509,511
<    * \param to the MAC address of the Ack receiver
<    * \param dataTxMode the mode of the Data used by the sender
<    * \return TXVECTOR for the Ack
---
>    * \param to the MAC address of the ACK receiver
>    * \param dataTxMode the mode of the DATA used by the sender
>    * \return TXVECTOR for the ACK
784c515
<    * Return a TXVECTOR for the BlockAck frame given the destination and the mode of the Data
---
>    * Return a TXVECTOR for the Block ACK frame given the destination and the mode of the DATA
789,791c520,522
<    * \param to the MAC address of the BlockAck receiver
<    * \param dataTxMode the mode of the Data used by the sender
<    * \return TXVECTOR for the BlockAck
---
>    * \param to the MAC address of the Block ACK receiver
>    * \param dataTxMode the mode of the DATA used by the sender
>    * \return TXVECTOR for the Block ACK
806c537
<    * Return a TXVECTOR for the BlockAck frame given the destination and the mode of the Data
---
>    * Return a TXVECTOR for the Block ACK frame given the destination and the mode of the DATA
811,813c542,544
<    * \param to the MAC address of the BlockAck receiver
<    * \param dataTxMode the mode of the Data used by the sender
<    * \return TXVECTOR for the BlockAck
---
>    * \param to the MAC address of the Block ACK receiver
>    * \param dataTxMode the mode of the DATA used by the sender
>    * \return TXVECTOR for the Block ACK
817,824d547
<    * Get control answer mode function.
<    *
<    * \param reqMode request mode
<    *
<    * \return control answer mode
<    */
<   WifiMode GetControlAnswerMode (WifiMode reqMode) const;
<   /**
827c550
<    * \param ctsTxVector the TXVECTOR used to transmit the CTS
---
>    * \param ctsTxVector
835,836c558,559
<    * \param to the receiver MAC address
<    * \param rtsTxVector the TXVECTOR used to transmit the RTS
---
>    * \param to
>    * \param rtsTxVector
839,840c562
<   Time GetCtsDuration (Mac48Address to, WifiTxVector rtsTxVector, bool addControlTrailer = false) const;
<   //// WIGIG ////
---
>   Time GetCtsDuration (Mac48Address to, WifiTxVector rtsTxVector) const;
842c564
<    * Return the time required to transmit the DMG CTS (including preamble and FCS).
---
>    * Return the time required to transmit the ACK (including preamble and FCS).
844c566,567
<    * \return the time required to transmit the DMG CTS (including preamble and FCS)
---
>    * \param ackTxVector
>    * \return the time required to transmit the ACK (including preamble and FCS)
846c569
<   Time GetDmgCtsDuration (bool addControlTrailer = false) const;
---
>   Time GetAckDuration (WifiTxVector ackTxVector) const;
852c575
<    * \param txVector
---
>    * \param dataTxVector
855,871d577
<   Time GetDmgControlDuration (WifiTxVector txVector, uint32_t payloadSize) const;
<   //// WIGIG ////
<   /**
<    * Return the time required to transmit the Ack (including preamble and FCS).
<    *
<    * \param ackTxVector the TXVECTOR used to transmit the Ack
<    * \return the time required to transmit the Ack (including preamble and FCS)
<    */
<   Time GetAckDuration (WifiTxVector ackTxVector) const;
<   /**
<    * Return the time required to transmit the Ack to the specified address
<    * given the TXVECTOR of the Data (including preamble and FCS).
<    *
<    * \param to the receiver MAC address
<    * \param dataTxVector the TXVECTOR used to transmit the Data
<    * \return the time required to transmit the Ack (including preamble and FCS)
<    */
874c580
<    * Return the time required to transmit the BlockAck to the specified address
---
>    * Return the time required to transmit the Block ACK to the specified address
877,879c583,585
<    * \param blockAckReqTxVector the TXVECTOR used to transmit the BAR
<    * \param type the BlockAck type
<    * \return the time required to transmit the BlockAck (including preamble and FCS)
---
>    * \param blockAckReqTxVector
>    * \param type the Block ACK type
>    * \return the time required to transmit the Block ACK (including preamble and FCS)
883,884c589
<    * Return the time required to transmit the BlockAckRequest to the specified address
<    * given the TXVECTOR (including preamble and FCS).
---
>    * Check if the current packet should be sent with a RTS protection.
886,898c591,592
<    * \param blockAckReqTxVector the TX vector used to transmit the BAR
<    * \param type the BlockAckRequest type
<    * \return the time required to transmit the BlockAckRequest (including preamble and FCS)
<    */
<   Time GetBlockAckRequestDuration (WifiTxVector blockAckReqTxVector, BlockAckType type) const;
<   /**
<    * Return the time required to transmit the response frames (Ack or BAR+BA
<    * following the policy configured in the transmit parameters).
<    *
<    * \param params the transmission parameters
<    * \param dataTxVector the TX vector used to transmit the data frame
<    * \param receiver the station from which a response is expected
<    * \return the time required to transmit the response (Ack or BAR+BA)
---
>    * \return true if RTS protection should be used,
>    *         false otherwise
900,901c594
<   Time GetResponseDuration (const MacLowTransmissionParameters& params,
<                             WifiTxVector dataTxVector, Mac48Address receiver) const;
---
>   bool NeedRts (void) const;
920c613
<    * \param duration the duration to set
---
>    * \param duration
931c624
<    * Notify ChannelAccessManager that Ack timer should be started for the given duration.
---
>    * Notify ChannelAccessManager that ACK timer should be started for the given duration.
933c626
<    * \param duration the duration of the timer
---
>    * \param duration the duration
937c630
<    * Notify ChannelAccessManager that Ack timer should be reset.
---
>    * Notify ChannelAccessManager that ACK timer should be reset.
939c632
<   void NotifyAckTimeoutResetNow (void);
---
>   void NotifyAckTimeoutResetNow ();
943c636
<    * \param duration the duration of the timer
---
>    * \param duration
949c642,649
<   void NotifyCtsTimeoutResetNow (void);
---
>   void NotifyCtsTimeoutResetNow ();
>   /**
>    * Reset NAV after CTS was missed when the NAV was
>    * set with RTS.
>    *
>    * \param rtsEndRxTime
>    */
>   void NavCounterResetCtsMissed (Time rtsEndRxTime);
952c652
<    * Event handler when normal Ack timeout occurs.
---
>    * Event handler when normal ACK timeout occurs.
956c656
<    * Event handler when BlockAck timeout occurs.
---
>    * Event handler when block ACK timeout occurs.
964c664
<    * Event handler when CF-Poll timeout occurs.
---
>    * Event handler when CF-POLL timeout occurs.
974,983d673
<    * \param source the transmitter of the RTS
<    * \param duration the NAV of the RTS
<    * \param rtsTxVector the TXVECTOR used to transmit the RTS
<    * \param rtsSnr the SNR of the RTS in linear scale
<    */
<   void SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr);
<   //// WIGIG ////
<   /**
<    * Send CTS after receiving RTS.
<    *
989,990c679
<   void SendDmgCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr);
<   //// WIGIG ////
---
>   void SendCtsAfterRts (Mac48Address source, Time duration, WifiTxVector rtsTxVector, double rtsSnr);
992c681
<    * Send Ack after receiving Data.
---
>    * Send ACK after receiving DATA.
994,997c683,686
<    * \param source the transmitter of the Data
<    * \param duration the NAV of the Data
<    * \param dataTxMode the TXVECTOR used to transmit the Data
<    * \param dataSnr the SNR of the Data in linear scale
---
>    * \param source
>    * \param duration
>    * \param dataTxMode
>    * \param dataSnr
1001c690
<    * Send Data after receiving CTS.
---
>    * Send DATA after receiving CTS.
1003c692
<    * \param duration the NAV of the CTS
---
>    * \param duration
1019c708
<    * A transmission that does not require an Ack has completed.
---
>    * A transmission that does not require an ACK has completed.
1023c712
<    * Send RTS to begin RTS-CTS-Data-Ack transaction.
---
>    * Send RTS to begin RTS-CTS-DATA-ACK transaction.
1027,1028c716,717
<    * Send Data packet, which can be Data-Ack or
<    * RTS-CTS-Data-Ack transaction.
---
>    * Send DATA packet, which can be DATA-ACK or
>    * RTS-CTS-DATA-ACK transaction.
1032,1033c721,722
<    * Start a Data timer by scheduling appropriate
<    * Ack timeout.
---
>    * Start a DATA timer by scheduling appropriate
>    * ACK timeout.
1035c724
<    * \param dataTxVector the TXVECTOR used to transmit the Data
---
>    * \param dataTxVector
1042,1043c731,732
<    * \param originator Address of peer participating in block ack mechanism.
<    * \param tid TID for which block ack was created.
---
>    * \param originator Address of peer participating in Block Ack mechanism.
>    * \param tid TID for which Block Ack was created.
1047c736
<    * smaller than <i>seq</i>. All comparison are performed circularly modulo 4096.
---
>    * smaller than <i>seq</i>. All comparison are performed circularly mod 4096.
1051,1052c740,741
<    * \param originator Address of peer participating in block ack mechanism.
<    * \param tid TID for which block ack was created.
---
>    * \param originator Address of peer participating in Block Ack mechanism.
>    * \param tid TID for which Block Ack was created.
1064c753,754
<    * \param mpdu the MPDU
---
>    * \param packet the packet
>    * \param hdr the header
1069c759
<    * immediate BlockAck)
---
>    * immediate block Ack)
1071c761
<   bool ReceiveMpdu (Ptr<WifiMacQueueItem> mpdu);
---
>   bool ReceiveMpdu (Ptr<Packet> packet, WifiMacHeader hdr);
1073c763,764
<    * \param mpdu the MPDU
---
>    * \param packet the packet
>    * \param hdr the header
1081c772
<   bool StoreMpduIfNeeded (Ptr<WifiMacQueueItem> mpdu);
---
>   bool StoreMpduIfNeeded (Ptr<Packet> packet, WifiMacHeader hdr);
1083,1084c774,775
<    * Invoked after that a BlockAckRequest has been received. Looks for corresponding
<    * block ack agreement and creates a block ack bitmap on a received packets basis.
---
>    * Invoked after that a block ack request has been received. Looks for corresponding
>    * block ack agreement and creates block ack bitmap on a received packets basis.
1086,1090c777,781
<    * \param reqHdr the BAR header
<    * \param originator the transmitter of the BAR
<    * \param duration the NAV of the BAR
<    * \param blockAckReqTxMode the TXVECTOR used to transmit the BAR
<    * \param rxSnr the SNR of the BAR in linear scale
---
>    * \param reqHdr
>    * \param originator
>    * \param duration
>    * \param blockAckReqTxMode
>    * \param rxSnr
1096c787
<    * block ack agreement and creates a block ack bitmap on a received packets basis.
---
>    * block ack agreement and creates block ack bitmap on a received packets basis.
1102c793
<    * \param rxSnr the receive SNR in linear scale
---
>    * \param rxSnr the receive SNR
1104,1105c795,796
<   void SendBlockAckAfterAmpdu (uint8_t tid, Mac48Address originator, Time duration,
<                                WifiTxVector blockAckReqTxVector, double rxSnr);
---
>   void SendBlockAckAfterAmpdu (uint8_t tid, Mac48Address originator,
>                                Time duration, WifiTxVector blockAckReqTxVector, double rxSnr);
1107c798
<    * This method creates BlockAck frame with header equals to <i>blockAck</i> and start its transmission.
---
>    * This method creates block ack frame with header equals to <i>blockAck</i> and start its transmission.
1109,1114c800,805
<    * \param blockAck the BA response header to send
<    * \param originator the station to send a BA to
<    * \param immediate use immediate BA policy if true
<    * \param duration the NAV duration
<    * \param blockAckReqTxMode the TXVECTOR used to transmit the BAR
<    * \param rxSnr the received SNR in linear scale
---
>    * \param blockAck
>    * \param originator
>    * \param immediate
>    * \param duration
>    * \param blockAckReqTxMode
>    * \param rxSnr
1119c810
<    * Every time that a BlockAckRequest or a packet with Ack Policy equals to <i>Block Ack</i>
---
>    * Every time that a block ack request or a packet with ack policy equals to <i>block ack</i>
1124c815
<    * \param agreement the BA agreement
---
>    * \param agreement
1139a831,860
>   /**
>    * Checks if the given packet will be aggregated to an A-MPDU or not
>    *
>    * \param packet packet to check whether it can be aggregated in an A-MPDU
>    * \param hdr 802.11 header for packet to check whether it can be aggregated in an A-MPDU
>    * \returns true if is A-MPDU
>    */
>   bool IsAmpdu (Ptr<const Packet> packet, const WifiMacHeader hdr);
>   /**
>    * Insert in a temporary queue.
>    * It is only used with a RTS/CTS exchange for an A-MPDU transmission.
>    *
>    * \param packet packet to be inserted in the A-MPDU tx queue
>    * \param hdr 802.11 header for the packet to be inserted in the A-MPDU tx queue
>    * \param tStamp timestamp of the packet to be inserted in the A-MPDU tx queue
>    * \param tid the Traffic ID of the packet to be inserted in the A-MPDU tx queue
>    */
>   void InsertInTxQueue (Ptr<const Packet> packet, const WifiMacHeader &hdr, Time tStamp, uint8_t tid);
>   /**
>    * Perform MSDU aggregation for a given MPDU in an A-MPDU
>    *
>    * \param packet packet picked for aggregation
>    * \param hdr 802.11 header for packet picked for aggregation
>    * \param tstamp timestamp
>    * \param currentAmpduPacket current A-MPDU packet
>    * \param blockAckSize size of the piggybacked block ack request
>    *
>    * \return the aggregate if MSDU aggregation succeeded, 0 otherwise
>    */
>   Ptr<Packet> PerformMsduAggregation (Ptr<const Packet> packet, WifiMacHeader *hdr, Time *tstamp, Ptr<Packet> currentAmpduPacket, uint8_t blockAckSize);
1142d862
<   Ptr<WifiMac> m_mac; //!< Pointer to WifiMac (to fetch configuration)
1147c867,877
<    * A struct that holds information about Ack piggybacking (CF-Ack).
---
>    * A struct for packet, Wifi header, and timestamp.
>    */
>   struct Item
>   {
>     Ptr<const Packet> packet; //!< the packet
>     WifiMacHeader hdr; //!< the header
>     Time timestamp; //!< the timestamp
>   }; //!< item structure
> 
>   /**
>    * A struct that holds information about ACK piggybacking (CF-ACK).
1151,1152c881,882
<     bool appendCfAck;     //!< Flag used for PCF to indicate whether a CF-Ack should be appended
<     bool expectCfAck;     //!< Flag used for PCF to indicate whether a CF-Ack should be expected
---
>     bool appendCfAck; //!< Flag used for PCF to indicate whether a CF-ACK should be appended
>     bool expectCfAck; //!< Flag used for PCF to indicate whether a CF-ACK should be expected
1166,1170c896,897
<   Ptr<MsduAggregator> m_msduAggregator;             //!< A-MSDU aggregator
<   Ptr<MpduAggregator> m_mpduAggregator;             //!< A-MPDU aggregator
< 
<   EventId m_normalAckTimeoutEvent;      //!< Normal Ack timeout event
<   EventId m_blockAckTimeoutEvent;       //!< BlockAck timeout event
---
>   EventId m_normalAckTimeoutEvent;      //!< Normal ACK timeout event
>   EventId m_blockAckTimeoutEvent;       //!< Block ACK timeout event
1173,1174c900,901
<   EventId m_sendAckEvent;               //!< Event to send Ack
<   EventId m_sendDataEvent;              //!< Event to send Data
---
>   EventId m_sendAckEvent;               //!< Event to send ACK
>   EventId m_sendDataEvent;              //!< Event to send DATA
1176c903
<   EventId m_endTxNoAckEvent;            //!< Event for finishing transmission that does not require Ack
---
>   EventId m_endTxNoAckEvent;            //!< Event for finishing transmission that does not require ACK
1179c906,907
<   Ptr<WifiPsdu> m_currentPacket;            //!< Current packet transmitted/to be transmitted
---
>   Ptr<Packet> m_currentPacket;              //!< Current packet transmitted/to be transmitted
>   WifiMacHeader m_currentHdr;               //!< Header of the current transmitted packet
1184,1186c912,915
<   Time m_ackTimeout;                        //!< Ack timeout duration
<   Time m_basicBlockAckTimeout;              //!< Basic BlockAck timeout duration
<   Time m_compressedBlockAckTimeout;         //!< Compressed BlockAck timeout duration
---
>   Time m_ackTimeout;                        //!< ACK timeout duration
>   Time m_basicBlockAckTimeout;              //!< Basic block ACK timeout duration
>   Time m_compressedBlockAckTimeout;         //!< Compressed block ACK timeout duration
>   Time m_ctsTimeout;                        //!< CTS timeout duration
1192,1197d920
<   //// WIGIG ////
<   Time m_sbifs;                             //!< Short Beamforming Interframe Space (SBIFS) duration.
<   Time m_mbifs;                             //!< Medium Beamforming Interframe Space (MBIS) duration.
<   Time m_lbifs;                             //!< Long Beamforming Interframe Space (LBIFS) duration.
<   Time m_brifs;                             //!< Beam Refinement Protocol Interframe Spacing (BRIFS) duration.
<   //// WIGIG ////
1208a932
>   bool m_ampdu;    //!< Flag if the current transmission involves an A-MPDU
1215c939,940
<   typedef std::list<Ptr<WifiMacQueueItem>>::iterator BufferedPacketI; //!< buffered packet iterator typedef
---
>   typedef std::pair<Ptr<Packet>, WifiMacHeader> BufferedPacket; //!< buffered packet typedef
>   typedef std::list<BufferedPacket>::iterator BufferedPacketI; //!< buffered packet iterator typedef
1218c943
<   typedef std::pair<BlockAckAgreement, std::list<Ptr<WifiMacQueueItem>> > AgreementValue; //!< agreement value typedef
---
>   typedef std::pair<BlockAckAgreement, std::list<BufferedPacket> > AgreementValue; //!< agreement value typedef
1232a958,959
>   Ptr<WifiMacQueue> m_aggregateQueue[8]; //!< Queues per TID used for MPDU aggregation
>   std::vector<Item> m_txPackets[8];      //!< Contain temporary items to be sent with the next A-MPDU transmission for a given TID, once RTS/CTS exchange has succeeded.
1235,1260c962
<   CfAckInfo m_cfAckInfo; //!< Info about piggyback Acks used in PCF
< 
<   //// WIGIG ////
<   TransmissionOkCallback m_transmissionCallback;
<   TransmissionShortSswOkCallback m_transmissionShortSswCallback;
< 
< 
<   /* Variables for suspended data transmission for different allocation periods */
<   struct AllocationParameters : public SimpleRefCount<AllocationParameters> {
<     MacLowTransmissionParameters txParams;      //!< Suspended transmission MacLow parameters.
<     WifiTxVector txVector;                      //!< TxVector associated with the suspended transmission.
<     Ptr<Txop> txop;                             //!< Transmit opportunity responsbile for this suspended transmission.
<     Ptr<WifiPsdu> psdu;                         //!< PSDU to to be transmitted.
<   };
< 
<   typedef std::map<AllocationID, Ptr<AllocationParameters> > AllocationPeriodsTable;
<   typedef AllocationPeriodsTable::const_iterator AllocationPeriodsTableCI;
<   typedef AllocationPeriodsTable::iterator AllocationPeriodsTableI;
<   AllocationPeriodsTable m_allocationPeriodsTable;  //!< Table to store allocation periods (CBAP/SP) related transmission parameters.
<   AllocationID m_currentAllocationID;               //!< The ID of the current allocation served by the High MAC.
<   Ptr<AllocationParameters> m_currentAllocation;    //!< Current allocation parameters.
<   bool m_transmissionSuspended;                     //!< Flag to indicate that we have suspended transmission for the current allocation.
<   bool m_restoredSuspendedTransmission;             //!< Flag to indicate that we have more time to transmit more packets.
<   bool m_servingSLS;                                //!< Flag to indicate that we are performing BFT.
<   bool m_servingMimoBFT;                            //!< Flag to indicate that we are performing MIMO BFT.
<   //// WIGIG ////
---
>   CfAckInfo m_cfAckInfo; //!< Info about piggyback ACKs used in PCF
diff ../../NS3-WiGig/src/wifi/model/mac-low-transmission-parameters.cc ../../ns-3-dev-git/src/wifi/model/mac-low-transmission-parameters.cc
30,34c30
<     m_sendBar (BLOCK_ACK_REQUEST_NONE),
<     m_sendRts (false),
< 	//// WIGIG ////
<     m_overrideDurationId (Seconds (0))
< 	//// WIGIG ////
---
>     m_sendRts (false)
50d45
< //// WIGIG ////
52c47
< MacLowTransmissionParameters::EnableOverrideDurationId (Time durationId)
---
> MacLowTransmissionParameters::EnableBasicBlockAck (void)
54c49
<   m_overrideDurationId = durationId;
---
>   m_waitAck = BLOCK_ACK_BASIC;
58c53
< MacLowTransmissionParameters::DisableOverrideDurationId (void)
---
> MacLowTransmissionParameters::EnableCompressedBlockAck (void)
60,105c55
<   m_overrideDurationId = Seconds (0);
< }
< 
< bool
< MacLowTransmissionParameters::HasDurationId (void) const
< {
<   return (!m_overrideDurationId.IsZero ());
< }
< 
< Time
< MacLowTransmissionParameters::GetDurationId (void) const
< {
<   NS_ASSERT (!m_overrideDurationId.IsZero ());
<   return m_overrideDurationId;
< }
< //// WIGIG ////
< 
< void
< MacLowTransmissionParameters::EnableBlockAck (BlockAckType type)
< {
<   switch (type)
<     {
<     case BlockAckType::BASIC_BLOCK_ACK:
<       m_waitAck = BLOCK_ACK_BASIC;
<       break;
<     case BlockAckType::COMPRESSED_BLOCK_ACK:
<       m_waitAck = BLOCK_ACK_COMPRESSED;
<       break;
<     case BlockAckType::EXTENDED_COMPRESSED_BLOCK_ACK:
<       m_waitAck = BLOCK_ACK_EXTENDED_COMPRESSED;
<       break;
<     case BlockAckType::MULTI_TID_BLOCK_ACK:
<       m_waitAck = BLOCK_ACK_MULTI_TID;
<       break;
<     //// WIGIG ////
<     case BlockAckType::EDMG_COMPRESSED_BLOCK_ACK:
<       m_waitAck = BLOCK_ACK_EDMG_COMPRESSED;
<       break;
<     //// WIGIG ////
<     default:
<       NS_FATAL_ERROR ("Unknown Block ack type");
<       break;
<     }
< 
<   // Reset m_sendBar
<   m_sendBar = BLOCK_ACK_REQUEST_NONE;
---
>   m_waitAck = BLOCK_ACK_COMPRESSED;
109c59
< MacLowTransmissionParameters::EnableBlockAckRequest (BlockAckType type)
---
> MacLowTransmissionParameters::EnableMultiTidBlockAck (void)
111,131c61
<   switch (type)
<     {
<     case BlockAckType::BASIC_BLOCK_ACK:
<       m_sendBar = BLOCK_ACK_REQUEST_BASIC;
<       break;
<     case BlockAckType::COMPRESSED_BLOCK_ACK:
<       m_sendBar = BLOCK_ACK_REQUEST_COMPRESSED;
<       break;
<     case BlockAckType::EXTENDED_COMPRESSED_BLOCK_ACK:
<       m_sendBar = BLOCK_ACK_REQUEST_EXTENDED_COMPRESSED;
<       break;
<     case BlockAckType::MULTI_TID_BLOCK_ACK:
<       m_sendBar = BLOCK_ACK_REQUEST_MULTI_TID;
<       break;
<     default:
<       NS_FATAL_ERROR ("Unknown Block Ack Request type");
<       break;
<     }
< 
<   // Reset m_waitAck
<   m_waitAck = ACK_NONE;
---
>   m_waitAck = BLOCK_ACK_MULTI_TID;
138,139d67
<   // Reset m_sendBar
<   m_sendBar = BLOCK_ACK_REQUEST_NONE;
149,154d76
< MacLowTransmissionParameters::DisableBlockAckRequest (void)
< {
<   m_sendBar = BLOCK_ACK_REQUEST_NONE;
< }
< 
< void
173,195c95
< MacLowTransmissionParameters::MustWaitBlockAck (void) const
< {
<   bool ret;
<   switch (m_waitAck)
<     {
<     case BLOCK_ACK_BASIC:
<     case BLOCK_ACK_COMPRESSED:
<     case BLOCK_ACK_EXTENDED_COMPRESSED:
<     case BLOCK_ACK_MULTI_TID:
<     //// WIGIG ////
<     case BLOCK_ACK_EDMG_COMPRESSED:
<     //// WIGIG ////
<       ret = true;
<       break;
<     default:
<       ret = false;
<       break;
<     }
<   return ret;
< }
< 
< BlockAckType
< MacLowTransmissionParameters::GetBlockAckType (void) const
---
> MacLowTransmissionParameters::MustWaitBasicBlockAck (void) const
197,221c97
<   BlockAckType type;
<   switch (m_waitAck)
<     {
<     case BLOCK_ACK_BASIC:
<       type = BlockAckType::BASIC_BLOCK_ACK;
<       break;
<     case BLOCK_ACK_COMPRESSED:
<       type = BlockAckType::COMPRESSED_BLOCK_ACK;
<       break;
<     case BLOCK_ACK_EXTENDED_COMPRESSED:
<       type = BlockAckType::EXTENDED_COMPRESSED_BLOCK_ACK;
<       break;
<     case BLOCK_ACK_MULTI_TID:
<       type = BlockAckType::MULTI_TID_BLOCK_ACK;
<       break;
<     //// WIGIG ////
<     case BLOCK_ACK_EDMG_COMPRESSED:
<       type = BlockAckType::EDMG_COMPRESSED_BLOCK_ACK;
<       break;
<     //// WIGIG ////
<     default:
<       NS_FATAL_ERROR ("Block ack is not used");
<       break;
<     }
<   return type;
---
>   return (m_waitAck == BLOCK_ACK_BASIC) ? true : false;
225c101
< MacLowTransmissionParameters::MustSendBlockAckRequest (void) const
---
> MacLowTransmissionParameters::MustWaitCompressedBlockAck (void) const
227,240c103
<   bool ret;
<   switch (m_sendBar)
<     {
<     case BLOCK_ACK_REQUEST_BASIC:
<     case BLOCK_ACK_REQUEST_COMPRESSED:
<     case BLOCK_ACK_REQUEST_EXTENDED_COMPRESSED:
<     case BLOCK_ACK_REQUEST_MULTI_TID:
<       ret = true;
<       break;
<     default:
<       ret = false;
<       break;
<     }
<   return ret;
---
>   return (m_waitAck == BLOCK_ACK_COMPRESSED) ? true : false;
243,244c106,107
< BlockAckType
< MacLowTransmissionParameters::GetBlockAckRequestType (void) const
---
> bool
> MacLowTransmissionParameters::MustWaitMultiTidBlockAck (void) const
246,265c109
<   BlockAckType type;
<   switch (m_sendBar)
<     {
<     case BLOCK_ACK_REQUEST_BASIC:
<       type = BlockAckType::BASIC_BLOCK_ACK;
<       break;
<     case BLOCK_ACK_REQUEST_COMPRESSED:
<       type = BlockAckType::COMPRESSED_BLOCK_ACK;
<       break;
<     case BLOCK_ACK_REQUEST_EXTENDED_COMPRESSED:
<       type = BlockAckType::EXTENDED_COMPRESSED_BLOCK_ACK;
<       break;
<     case BLOCK_ACK_REQUEST_MULTI_TID:
<       type = BlockAckType::MULTI_TID_BLOCK_ACK;
<       break;
<     default:
<       NS_FATAL_ERROR ("Block ack request must not be sent");
<       break;
<     }
<   return type;
---
>   return (m_waitAck == BLOCK_ACK_MULTI_TID) ? true : false;
292,294d135
< 	 //// WIGIG ////
<      << "dur=" << params.m_overrideDurationId << ", "
< 	 //// WIGIG ////
299c140
<       os << "none, ";
---
>       os << "none";
302c143
<       os << "normal, ";
---
>       os << "normal";
305c146
<       os << "basic-block-ack, ";
---
>       os << "basic-block-ack";
308,311c149
<       os << "compressed-block-ack, ";
<       break;
<     case MacLowTransmissionParameters::BLOCK_ACK_EXTENDED_COMPRESSED:
<       os << "extended-compressed-block-ack, ";
---
>       os << "compressed-block-ack";
314,338c152
<       os << "multi-tid-block-ack, ";
<       break;
<     //// WIGIG ////
<     case MacLowTransmissionParameters::BLOCK_ACK_EDMG_COMPRESSED:
<       os << "edmg-compressed-block-ack, ";
<       break;
<     //// WIGIG ////
<     }
<   os << "bar=";
<   switch (params.m_sendBar)
<     {
<     case MacLowTransmissionParameters::BLOCK_ACK_REQUEST_NONE:
<       os << "none";
<       break;
<     case MacLowTransmissionParameters::BLOCK_ACK_REQUEST_BASIC:
<       os << "basic";
<       break;
<     case MacLowTransmissionParameters::BLOCK_ACK_REQUEST_COMPRESSED:
<       os << "compressed";
<       break;
<     case MacLowTransmissionParameters::BLOCK_ACK_REQUEST_EXTENDED_COMPRESSED:
<       os << "extended-compressed";
<       break;
<     case MacLowTransmissionParameters::BLOCK_ACK_REQUEST_MULTI_TID:
<       os << "multi-tid";
---
>       os << "multi-tid-block-ack";
diff ../../NS3-WiGig/src/wifi/model/mac-low-transmission-parameters.h ../../ns-3-dev-git/src/wifi/model/mac-low-transmission-parameters.h
26d25
< #include "ns3/nstime.h"
28d26
< #include "block-ack-type.h"
46c44
<    * Wait ACKTimeout for an Ack. If we get an Ack
---
>    * Wait ACKTimeout for an ACK. If we get an ACK
52,54c50
<    * Wait the timeout corresponding to the given BlockAck response type.
<    *
<    * \param type the BlockAck response type
---
>    * Wait BASICBLOCKACKTimeout for a Basic Block Ack Response frame.
56c52
<   void EnableBlockAck (BlockAckType type);
---
>   void EnableBasicBlockAck (void);
58,60c54,58
<    * Schedule the transmission of a BlockAckRequest of the given type.
<    *
<    * \param type the BlockAckRequest type
---
>    * Wait COMPRESSEDBLOCKACKTimeout for a Compressed Block Ack Response frame.
>    */
>   void EnableCompressedBlockAck (void);
>   /**
>    * NOT IMPLEMENTED FOR NOW
62c60
<   void EnableBlockAckRequest (BlockAckType type);
---
>   void EnableMultiTidBlockAck (void);
72c70
<    *        sent in bytes.
---
>    *        sent.
80,106d77
< 
<   //// WIGIG ////
<   /**
<    * \param durationId the value to set in the duration/Id field of
<    *        the outgoing packet.
<    *
<    * Ignore all other durationId calculation and simply force the
<    * packet's durationId field to this value.
<    */
<   void EnableOverrideDurationId (Time durationId);
<   /**
<    * Do not force the duration/id field of the packet: its
<    * value is automatically calculated by the MacLow before
<    * calling WifiPhy::Send.
<    */
<   void DisableOverrideDurationId (void);
<   /**
<    * \returns true if a duration/id was forced with
<    *         EnableOverrideDurationId, false otherwise.
<    */
<   bool HasDurationId (void) const;
<   /**
<    * \returns the duration/id forced by EnableOverrideDurationId
<    */
<   Time GetDurationId (void) const;
<   //// WIGIG ////
< 
113,117c84
<    * Do not send BlockAckRequest after data transmission
<    */
<   void DisableBlockAckRequest (void);
<   /**
<    * Do not send RTS and wait for CTS before sending data.
---
>    * Do not send rts and wait for cts before sending data.
125c92
<    * \returns true if normal ack protocol should be used, false
---
>    * \returns true if normal ACK protocol should be used, false
136c103
<   bool MustWaitBlockAck (void) const;
---
>   bool MustWaitBasicBlockAck (void) const;
138c105
<    * \returns the selected BlockAck variant.
---
>    * \returns true if compressed block ack mechanism is used, false otherwise.
140c107
<    * Only call this method if the block ack mechanism is used.
---
>    * \sa EnableCompressedBlockAck
142c109
<   BlockAckType GetBlockAckType (void) const;
---
>   bool MustWaitCompressedBlockAck (void) const;
144c111
<    * \returns true if a BlockAckRequest must be sent, false otherwise.
---
>    * \returns true if multi-tid block ack mechanism is used, false otherwise.
146c113
<    * Return true if a BlockAckRequest must be sent, false otherwise.
---
>    * \sa EnableMultiTidBlockAck
148,154c115
<   bool MustSendBlockAckRequest (void) const;
<   /**
<    * \returns the selected BlockAckRequest variant.
<    *
<    * Only call this method if a BlockAckRequest must be sent.
<    */
<   BlockAckType GetBlockAckRequestType (void) const;
---
>   bool MustWaitMultiTidBlockAck (void) const;
172c133
<   /// wait Ack enumerated type
---
>   /// wait ack enumerated type
179,193c140,141
<     BLOCK_ACK_EXTENDED_COMPRESSED,
<     BLOCK_ACK_MULTI_TID,
<     //// WIGIG ////
<     BLOCK_ACK_EDMG_COMPRESSED,
<     //// WIGIG ////
<   } m_waitAck; //!< wait Ack
<   /// send BAR enumerated type
<   enum
<   {
<     BLOCK_ACK_REQUEST_NONE,
<     BLOCK_ACK_REQUEST_BASIC,
<     BLOCK_ACK_REQUEST_COMPRESSED,
<     BLOCK_ACK_REQUEST_EXTENDED_COMPRESSED,
<     BLOCK_ACK_REQUEST_MULTI_TID
<   } m_sendBar; //!< send BAR
---
>     BLOCK_ACK_MULTI_TID
>   } m_waitAck; //!< wait ack
195d142
<   Time m_overrideDurationId; //!< override duration ID
diff ../../NS3-WiGig/src/wifi/model/mac-rx-middle.cc ../../ns-3-dev-git/src/wifi/model/mac-rx-middle.cc
25c25
< #include "wifi-mac-queue-item.h"
---
> #include "wifi-mac-header.h"
201c201
<       /* only for QoS data non-broadcast frames */
---
>       /* only for qos data non-broadcast frames */
212,213c212,213
<        * - QoS data broadcast frames
<        * - non-QoS data frames
---
>        * - qos data broadcast frames
>        * - nqos data frames
251c251
<                             ", frag=" << +hdr->GetFragmentNumber () <<
---
>                             ", frag=" << hdr->GetFragmentNumber () <<
267c267
<                             ", frag=" << +hdr->GetFragmentNumber () <<
---
>                             ", frag=" << hdr->GetFragmentNumber () <<
285c285
<                         ", frag=" << +hdr->GetFragmentNumber () <<
---
>                         ", frag=" << hdr->GetFragmentNumber () <<
299c299
< MacRxMiddle::Receive (Ptr<WifiMacQueueItem> mpdu)
---
> MacRxMiddle::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
301,310c301
<   NS_LOG_FUNCTION (*mpdu);
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
<   Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
<   //// WIGIG ////
<   if (hdr->IsSSW () || hdr->IsSSW_FBCK () || hdr->IsSSW_ACK ()  || hdr->IsDMGBeacon ())
<     {
<       m_callback (Create<WifiMacQueueItem> (packet, *hdr));
<       return;
<     }
<   //// WIGIG ////
---
>   NS_LOG_FUNCTION (packet << hdr);
336c327
<                     ", frag=" << +hdr->GetFragmentNumber ());
---
>                     ", frag=" << hdr->GetFragmentNumber ());
346c337
<                 ", frag=" << +hdr->GetFragmentNumber ());
---
>                 ", frag=" << hdr->GetFragmentNumber ());
351,362c342
<   if (aggregate == packet)
<     {
<       m_callback (mpdu);
<     }
<   else
<     {
<       // We could do this in all cases, but passing the received mpdu in case of
<       // A-MSDUs saves us the time to deaggregate the A-MSDU in MSDUs (which are
<       // kept separate in the received mpdu) and allows us to pass the originally
<       // transmitted packets (i.e., with the same UID) to the receiver.
<       m_callback (Create<WifiMacQueueItem> (aggregate, *hdr));
<     }
---
>   m_callback (aggregate, hdr);
diff ../../NS3-WiGig/src/wifi/model/mac-rx-middle.h ../../ns-3-dev-git/src/wifi/model/mac-rx-middle.h
34d33
< class WifiMacQueueItem;
47c46
<   typedef Callback<void, Ptr<WifiMacQueueItem>> ForwardUpCallback;
---
>   typedef Callback<void, Ptr<Packet>, const WifiMacHeader*> ForwardUpCallback;
55c54
<    * \param callback the callback to set
---
>    * \param callback
62c61
<    * \param callback the callback to set
---
>    * \param callback
69c68,69
<    * \param mpdu the MPDU
---
>    * \param packet the packet
>    * \param hdr MAC header
71c71
<   void Receive (Ptr<WifiMacQueueItem> mpdu);
---
>   void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
82c82
<    * \param hdr the MAC header
---
>    * \param hdr
91,92c91,92
<    * \param hdr the MAC header
<    * \param originator the packet originator status
---
>    * \param hdr
>    * \param originator
106,108c106,108
<    * \param packet the packet
<    * \param hdr the MAC header
<    * \param originator the packet originator status
---
>    * \param packet
>    * \param hdr
>    * \param originator
diff ../../NS3-WiGig/src/wifi/model/mgt-headers.cc ../../ns-3-dev-git/src/wifi/model/mgt-headers.cc
5d4
<  * Copyright (c) 2015-2020 IMDEA Networks Institute
22d20
<  *          Hany Assasa <hany.assasa@gmail.com>
25,26d22
< #include "ns3/address-utils.h"
< #include "ns3/assert.h"
28,29c24
< 
< #include "ext-headers.h"
---
> #include "ns3/address-utils.h"
31d25
< #include "wifi-information-element.h"
57a52,57
> MgtAssocResponseHeader::SetAssociationId (uint16_t aid)
> {
>   m_aid = aid;
> }
> 
> void
62a63,110
> void
> MgtProbeRequestHeader::SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities)
> {
>   m_extendedCapability = extendedcapabilities;
> }
> 
> ExtendedCapabilities
> MgtProbeRequestHeader::GetExtendedCapabilities (void) const
> {
>   return m_extendedCapability;
> }
> 
> void
> MgtProbeRequestHeader::SetHtCapabilities (HtCapabilities htcapabilities)
> {
>   m_htCapability = htcapabilities;
> }
> 
> HtCapabilities
> MgtProbeRequestHeader::GetHtCapabilities (void) const
> {
>   return m_htCapability;
> }
> 
> void
> MgtProbeRequestHeader::SetVhtCapabilities (VhtCapabilities vhtcapabilities)
> {
>   m_vhtCapability = vhtcapabilities;
> }
> 
> VhtCapabilities
> MgtProbeRequestHeader::GetVhtCapabilities (void) const
> {
>   return m_vhtCapability;
> }
> 
> void
> MgtProbeRequestHeader::SetHeCapabilities (HeCapabilities hecapabilities)
> {
>   m_heCapability = hecapabilities;
> }
> 
> HeCapabilities
> MgtProbeRequestHeader::GetHeCapabilities (void) const
> {
>   return m_heCapability;
> }
> 
76c124,127
<   size += GetInformationElementsSerializedSize ();
---
>   size += m_extendedCapability.GetSerializedSize ();
>   size += m_htCapability.GetSerializedSize ();
>   size += m_vhtCapability.GetSerializedSize ();
>   size += m_heCapability.GetSerializedSize ();
100,102c151,156
<   os << "ssid=" << m_ssid
<      << "rates=" << m_rates;
<   PrintInformationElements (os);
---
>   os << "ssid=" << m_ssid << ", "
>      << "rates=" << m_rates << ", "
>      << "Extended Capabilities=" << m_extendedCapability << " , "
>      << "HT Capabilities=" << m_htCapability << " , "
>      << "VHT Capabilities=" << m_vhtCapability << " , "
>      << "HE Capabilities=" << m_heCapability;
112c166,169
<   i = SerializeInformationElements (i);
---
>   i = m_extendedCapability.Serialize (i);
>   i = m_htCapability.Serialize (i);
>   i = m_vhtCapability.Serialize (i);
>   i = m_heCapability.Serialize (i);
122c179,182
<   i = DeserializeInformationElements (i);
---
>   i = m_extendedCapability.DeserializeIfPresent (i);
>   i = m_htCapability.DeserializeIfPresent (i);
>   i = m_vhtCapability.DeserializeIfPresent (i);
>   i = m_heCapability.DeserializeIfPresent (i);
128c188
<  *                    Probe Response
---
>  *          Probe Response
158a219,224
> SupportedRates
> MgtProbeResponseHeader::GetSupportedRates (void) const
> {
>   return m_rates;
> }
> 
160c226
< MgtProbeResponseHeader::SetSupportedRates (SupportedRates rates)
---
> MgtProbeResponseHeader::SetCapabilities (CapabilityInformation capabilities)
162c228
<   m_rates = rates;
---
>   m_capability = capabilities;
165,166c231,232
< SupportedRates
< MgtProbeResponseHeader::GetSupportedRates (void) const
---
> CapabilityInformation
> MgtProbeResponseHeader::GetCapabilities (void) const
168c234,330
<   return m_rates;
---
>   return m_capability;
> }
> 
> void
> MgtProbeResponseHeader::SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities)
> {
>   m_extendedCapability = extendedcapabilities;
> }
> 
> ExtendedCapabilities
> MgtProbeResponseHeader::GetExtendedCapabilities (void) const
> {
>   return m_extendedCapability;
> }
> 
> void
> MgtProbeResponseHeader::SetHtCapabilities (HtCapabilities htcapabilities)
> {
>   m_htCapability = htcapabilities;
> }
> 
> HtCapabilities
> MgtProbeResponseHeader::GetHtCapabilities (void) const
> {
>   return m_htCapability;
> }
> 
> void
> MgtProbeResponseHeader::SetHtOperation (HtOperation htoperation)
> {
>   m_htOperation = htoperation;
> }
> 
> HtOperation
> MgtProbeResponseHeader::GetHtOperation (void) const
> {
>   return m_htOperation;
> }
> 
> void
> MgtProbeResponseHeader::SetVhtCapabilities (VhtCapabilities vhtcapabilities)
> {
>   m_vhtCapability = vhtcapabilities;
> }
> 
> VhtCapabilities
> MgtProbeResponseHeader::GetVhtCapabilities (void) const
> {
>   return m_vhtCapability;
> }
> 
> void
> MgtProbeResponseHeader::SetVhtOperation (VhtOperation vhtoperation)
> {
>   m_vhtOperation = vhtoperation;
> }
> 
> VhtOperation
> MgtProbeResponseHeader::GetVhtOperation (void) const
> {
>   return m_vhtOperation;
> }
> 
> void
> MgtProbeResponseHeader::SetHeCapabilities (HeCapabilities hecapabilities)
> {
>   m_heCapability = hecapabilities;
> }
> 
> HeCapabilities
> MgtProbeResponseHeader::GetHeCapabilities (void) const
> {
>   return m_heCapability;
> }
> 
> void
> MgtProbeResponseHeader::SetHeOperation (HeOperation heoperation)
> {
>   m_heOperation = heoperation;
> }
> 
> HeOperation
> MgtProbeResponseHeader::GetHeOperation (void) const
> {
>   return m_heOperation;
> }
> 
> void
> MgtProbeResponseHeader::SetCfParameterSet (CfParameterSet cfparameterset)
> {
>   m_cfParameterSet = cfparameterset;
> }
> 
> CfParameterSet
> MgtProbeResponseHeader::GetCfParameterSet (void) const
> {
>   return m_cfParameterSet;
184c346
< MgtProbeResponseHeader::SetCapabilities (CapabilityInformation capabilities)
---
> MgtProbeResponseHeader::SetSupportedRates (SupportedRates rates)
186c348
<   m_capability = capabilities;
---
>   m_rates = rates;
189,190c351,352
< CapabilityInformation
< MgtProbeResponseHeader::GetCapabilities (void) const
---
> void
> MgtProbeResponseHeader::SetDsssParameterSet (DsssParameterSet dsssParameterSet)
192c354,384
<   return m_capability;
---
>   m_dsssParameterSet = dsssParameterSet;
> }
> 
> DsssParameterSet
> MgtProbeResponseHeader::GetDsssParameterSet (void) const
> {
>   return m_dsssParameterSet;
> }
> 
> void
> MgtProbeResponseHeader::SetErpInformation (ErpInformation erpInformation)
> {
>   m_erpInformation = erpInformation;
> }
> 
> ErpInformation
> MgtProbeResponseHeader::GetErpInformation (void) const
> {
>   return m_erpInformation;
> }
> 
> void
> MgtProbeResponseHeader::SetEdcaParameterSet (EdcaParameterSet edcaparameters)
> {
>   m_edcaParameterSet = edcaparameters;
> }
> 
> EdcaParameterSet
> MgtProbeResponseHeader::GetEdcaParameterSet (void) const
> {
>   return m_edcaParameterSet;
220a413,415
>   size += m_cfParameterSet.GetSerializedSize ();
>   size += m_dsssParameterSet.GetSerializedSize ();
>   size += m_erpInformation.GetSerializedSize ();
222c417,424
<   size += GetInformationElementsSerializedSize ();
---
>   size += m_edcaParameterSet.GetSerializedSize ();
>   size += m_extendedCapability.GetSerializedSize ();
>   size += m_htCapability.GetSerializedSize ();
>   size += m_htOperation.GetSerializedSize ();
>   size += m_vhtCapability.GetSerializedSize ();
>   size += m_vhtOperation.GetSerializedSize ();
>   size += m_heCapability.GetSerializedSize ();
>   size += m_heOperation.GetSerializedSize ();
229,233c431,440
<   os << "Timestamp=" << m_timestamp << "," <<
<         "BeaconInterval=" << m_beaconInterval  << "," <<
<         "rates=" << m_rates << ", "
<         "ssid=" << m_ssid;
<   PrintInformationElements (os);
---
>   os << "ssid=" << m_ssid << ", "
>      << "rates=" << m_rates << ", "
>      << "ERP information=" << m_erpInformation << ", "
>      << "Extended Capabilities=" << m_extendedCapability << " , "
>      << "HT Capabilities=" << m_htCapability << " , "
>      << "HT Operation=" << m_htOperation << " , "
>      << "VHT Capabilities=" << m_vhtCapability << " , "
>      << "VHT Operation=" << m_vhtOperation << " , "
>      << "HE Capabilities=" << m_heCapability << " , "
>      << "HE Operation=" << m_heOperation;
242a450,454
>   //supported rates
>   //fh parameter set
>   //ds parameter set
>   //cf parameter set
>   //ibss parameter set
245c457
<   i.WriteHtolsbU16 (m_beaconInterval / 1024);
---
>   i.WriteHtolsbU16 (static_cast<uint16_t> (m_beaconInterval / 1024));
248a461,463
>   i = m_cfParameterSet.Serialize (i);
>   i = m_dsssParameterSet.Serialize (i);
>   i = m_erpInformation.Serialize (i);
250c465,472
<   i = SerializeInformationElements (i);
---
>   i = m_edcaParameterSet.Serialize (i);
>   i = m_extendedCapability.Serialize (i);
>   i = m_htCapability.Serialize (i);
>   i = m_htOperation.Serialize (i);
>   i = m_vhtCapability.Serialize (i);
>   i = m_vhtOperation.Serialize (i);
>   i = m_heCapability.Serialize (i);
>   i = m_heOperation.Serialize (i);
262a485,487
>   i = m_cfParameterSet.DeserializeIfPresent (i);
>   i = m_dsssParameterSet.DeserializeIfPresent (i);
>   i = m_erpInformation.DeserializeIfPresent (i);
264c489,496
<   i = DeserializeInformationElements (i);
---
>   i = m_edcaParameterSet.DeserializeIfPresent (i);
>   i = m_extendedCapability.DeserializeIfPresent (i);
>   i = m_htCapability.DeserializeIfPresent (i);
>   i = m_htOperation.DeserializeIfPresent (i);
>   i = m_vhtCapability.DeserializeIfPresent (i);
>   i = m_vhtOperation.DeserializeIfPresent (i);
>   i = m_heCapability.DeserializeIfPresent (i);
>   i = m_heOperation.DeserializeIfPresent (i);
304c536
< MgtAssocRequestHeader::SetCapabilities (CapabilityInformation capabilities)
---
> MgtAssocRequestHeader::SetSsid (Ssid ssid)
306c538
<   m_capability = capabilities;
---
>   m_ssid = ssid;
310c542
< MgtAssocRequestHeader::SetSsid (Ssid ssid)
---
> MgtAssocRequestHeader::SetSupportedRates (SupportedRates rates)
312c544
<   m_ssid = ssid;
---
>   m_rates = rates;
320a553,558
> void
> MgtAssocRequestHeader::SetCapabilities (CapabilityInformation capabilities)
> {
>   m_capability = capabilities;
> }
> 
327,328c565,566
< uint16_t
< MgtAssocRequestHeader::GetListenInterval (void) const
---
> void
> MgtAssocRequestHeader::SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities)
330c568
<   return m_listenInterval;
---
>   m_extendedCapability = extendedcapabilities;
333,334c571,572
< Ssid
< MgtAssocRequestHeader::GetSsid (void) const
---
> ExtendedCapabilities
> MgtAssocRequestHeader::GetExtendedCapabilities (void) const
336c574
<   return m_ssid;
---
>   return m_extendedCapability;
340c578
< MgtAssocRequestHeader::SetSupportedRates (SupportedRates rates)
---
> MgtAssocRequestHeader::SetHtCapabilities (HtCapabilities htcapabilities)
342c580,616
<   m_rates = rates;
---
>   m_htCapability = htcapabilities;
> }
> 
> HtCapabilities
> MgtAssocRequestHeader::GetHtCapabilities (void) const
> {
>   return m_htCapability;
> }
> 
> void
> MgtAssocRequestHeader::SetVhtCapabilities (VhtCapabilities vhtcapabilities)
> {
>   m_vhtCapability = vhtcapabilities;
> }
> 
> VhtCapabilities
> MgtAssocRequestHeader::GetVhtCapabilities (void) const
> {
>   return m_vhtCapability;
> }
> 
> void
> MgtAssocRequestHeader::SetHeCapabilities (HeCapabilities hecapabilities)
> {
>   m_heCapability = hecapabilities;
> }
> 
> HeCapabilities
> MgtAssocRequestHeader::GetHeCapabilities (void) const
> {
>   return m_heCapability;
> }
> 
> Ssid
> MgtAssocRequestHeader::GetSsid (void) const
> {
>   return m_ssid;
350a625,630
> uint16_t
> MgtAssocRequestHeader::GetListenInterval (void) const
> {
>   return m_listenInterval;
> }
> 
377c657,660
<   size += GetInformationElementsSerializedSize ();
---
>   size += m_extendedCapability.GetSerializedSize ();
>   size += m_htCapability.GetSerializedSize ();
>   size += m_vhtCapability.GetSerializedSize ();
>   size += m_heCapability.GetSerializedSize ();
384,386c667,672
<   os << "ssid=" << m_ssid  << ", "
<      << "rates=" << m_rates;
<   PrintInformationElements (os);
---
>   os << "ssid=" << m_ssid << ", "
>      << "rates=" << m_rates << ", "
>      << "Extended Capabilities=" << m_extendedCapability << " , "
>      << "HT Capabilities=" << m_htCapability << " , "
>      << "VHT Capabilities=" << m_vhtCapability << " , "
>      << "HE Capabilities=" << m_heCapability;
398c684,687
<   i = SerializeInformationElements (i);
---
>   i = m_extendedCapability.Serialize (i);
>   i = m_htCapability.Serialize (i);
>   i = m_vhtCapability.Serialize (i);
>   i = m_heCapability.Serialize (i);
410c699,702
<   i = DeserializeInformationElements (i);
---
>   i = m_extendedCapability.DeserializeIfPresent (i);
>   i = m_htCapability.DeserializeIfPresent (i);
>   i = m_vhtCapability.DeserializeIfPresent (i);
>   i = m_heCapability.DeserializeIfPresent (i);
459a752,799
> void
> MgtReassocRequestHeader::SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities)
> {
>   m_extendedCapability = extendedcapabilities;
> }
> 
> ExtendedCapabilities
> MgtReassocRequestHeader::GetExtendedCapabilities (void) const
> {
>   return m_extendedCapability;
> }
> 
> void
> MgtReassocRequestHeader::SetHtCapabilities (HtCapabilities htcapabilities)
> {
>   m_htCapability = htcapabilities;
> }
> 
> HtCapabilities
> MgtReassocRequestHeader::GetHtCapabilities (void) const
> {
>   return m_htCapability;
> }
> 
> void
> MgtReassocRequestHeader::SetVhtCapabilities (VhtCapabilities vhtcapabilities)
> {
>   m_vhtCapability = vhtcapabilities;
> }
> 
> VhtCapabilities
> MgtReassocRequestHeader::GetVhtCapabilities (void) const
> {
>   return m_vhtCapability;
> }
> 
> void
> MgtReassocRequestHeader::SetHeCapabilities (HeCapabilities hecapabilities)
> {
>   m_heCapability = hecapabilities;
> }
> 
> HeCapabilities
> MgtReassocRequestHeader::GetHeCapabilities (void) const
> {
>   return m_heCapability;
> }
> 
511c851,854
<   size += GetInformationElementsSerializedSize ();
---
>   size += m_extendedCapability.GetSerializedSize ();
>   size += m_htCapability.GetSerializedSize ();
>   size += m_vhtCapability.GetSerializedSize ();
>   size += m_heCapability.GetSerializedSize ();
520,521c863,867
<      << "rates=" << m_rates;
<   PrintInformationElements (os);
---
>      << "rates=" << m_rates << ", "
>      << "Extended Capabilities=" << m_extendedCapability << " , "
>      << "HT Capabilities=" << m_htCapability << " , "
>      << "VHT Capabilities=" << m_vhtCapability << " , "
>      << "HE Capabilities=" << m_heCapability;
534c880,883
<   i = SerializeInformationElements (i);
---
>   i = m_extendedCapability.Serialize (i);
>   i = m_htCapability.Serialize (i);
>   i = m_vhtCapability.Serialize (i);
>   i = m_heCapability.Serialize (i);
547c896,899
<   i = DeserializeInformationElements (i);
---
>   i = m_extendedCapability.DeserializeIfPresent (i);
>   i = m_htCapability.DeserializeIfPresent (i);
>   i = m_vhtCapability.DeserializeIfPresent (i);
>   i = m_heCapability.DeserializeIfPresent (i);
604c956
< MgtAssocResponseHeader::SetAssociationId (uint16_t aid)
---
> MgtAssocResponseHeader::SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities)
606c958
<   m_aid = aid;
---
>   m_extendedCapability = extendedcapabilities;
609,610c961,1052
< uint16_t
< MgtAssocResponseHeader::GetAssociationId (void) const
---
> ExtendedCapabilities
> MgtAssocResponseHeader::GetExtendedCapabilities (void) const
> {
>   return m_extendedCapability;
> }
> 
> void
> MgtAssocResponseHeader::SetHtCapabilities (HtCapabilities htcapabilities)
> {
>   m_htCapability = htcapabilities;
> }
> 
> HtCapabilities
> MgtAssocResponseHeader::GetHtCapabilities (void) const
> {
>   return m_htCapability;
> }
> 
> void
> MgtAssocResponseHeader::SetHtOperation (HtOperation htoperation)
> {
>   m_htOperation = htoperation;
> }
> 
> HtOperation
> MgtAssocResponseHeader::GetHtOperation (void) const
> {
>   return m_htOperation;
> }
> 
> void
> MgtAssocResponseHeader::SetVhtCapabilities (VhtCapabilities vhtcapabilities)
> {
>   m_vhtCapability = vhtcapabilities;
> }
> 
> VhtCapabilities
> MgtAssocResponseHeader::GetVhtCapabilities (void) const
> {
>   return m_vhtCapability;
> }
> 
> void
> MgtAssocResponseHeader::SetVhtOperation (VhtOperation vhtoperation)
> {
>   m_vhtOperation = vhtoperation;
> }
> 
> VhtOperation
> MgtAssocResponseHeader::GetVhtOperation (void) const
> {
>   return m_vhtOperation;
> }
> 
> void
> MgtAssocResponseHeader::SetHeCapabilities (HeCapabilities hecapabilities)
> {
>   m_heCapability = hecapabilities;
> }
> 
> HeCapabilities
> MgtAssocResponseHeader::GetHeCapabilities (void) const
> {
>   return m_heCapability;
> }
> 
> void
> MgtAssocResponseHeader::SetHeOperation (HeOperation heoperation)
> {
>   m_heOperation = heoperation;
> }
> 
> HeOperation
> MgtAssocResponseHeader::GetHeOperation (void) const
> {
>   return m_heOperation;
> }
> 
> void
> MgtAssocResponseHeader::SetErpInformation (ErpInformation erpInformation)
> {
>   m_erpInformation = erpInformation;
> }
> 
> ErpInformation
> MgtAssocResponseHeader::GetErpInformation (void) const
> {
>   return m_erpInformation;
> }
> 
> void
> MgtAssocResponseHeader::SetEdcaParameterSet (EdcaParameterSet edcaparameters)
612c1054,1060
<   return m_aid;
---
>   m_edcaParameterSet = edcaparameters;
> }
> 
> EdcaParameterSet
> MgtAssocResponseHeader::GetEdcaParameterSet (void) const
> {
>   return m_edcaParameterSet;
639a1088
>   size += m_erpInformation.GetSerializedSize ();
641c1090,1097
<   size += GetInformationElementsSerializedSize ();
---
>   size += m_edcaParameterSet.GetSerializedSize ();
>   size += m_extendedCapability.GetSerializedSize ();
>   size += m_htCapability.GetSerializedSize ();
>   size += m_htOperation.GetSerializedSize ();
>   size += m_vhtCapability.GetSerializedSize ();
>   size += m_vhtOperation.GetSerializedSize ();
>   size += m_heCapability.GetSerializedSize ();
>   size += m_heOperation.GetSerializedSize ();
649,650c1105,1114
<      << "rates=" << m_rates;
<   PrintInformationElements (os);
---
>      << "aid=" << m_aid << ", "
>      << "rates=" << m_rates << ", "
>      << "ERP information=" << m_erpInformation << ", "
>      << "Extended Capabilities=" << m_extendedCapability << " , "
>      << "HT Capabilities=" << m_htCapability << " , "
>      << "HT Operation=" << m_htOperation << " , "
>      << "VHT Capabilities=" << m_vhtCapability << " , "
>      << "VHT Operation=" << m_vhtOperation << " , "
>      << "HE Capabilities=" << m_heCapability << " , "
>      << "HE Operation=" << m_heOperation;
660a1125
>   i = m_erpInformation.Serialize (i);
662c1127,1134
<   i = SerializeInformationElements (i);
---
>   i = m_edcaParameterSet.Serialize (i);
>   i = m_extendedCapability.Serialize (i);
>   i = m_htCapability.Serialize (i);
>   i = m_htOperation.Serialize (i);
>   i = m_vhtCapability.Serialize (i);
>   i = m_vhtOperation.Serialize (i);
>   i = m_heCapability.Serialize (i);
>   i = m_heOperation.Serialize (i);
672a1145
>   i = m_erpInformation.DeserializeIfPresent (i);
674c1147,1154
<   i = DeserializeInformationElements (i);
---
>   i = m_edcaParameterSet.DeserializeIfPresent (i);
>   i = m_extendedCapability.DeserializeIfPresent (i);
>   i = m_htCapability.DeserializeIfPresent (i);
>   i = m_htOperation.DeserializeIfPresent (i);
>   i = m_vhtCapability.DeserializeIfPresent (i);
>   i = m_vhtOperation.DeserializeIfPresent (i);
>   i = m_heCapability.DeserializeIfPresent (i);
>   i = m_heOperation.DeserializeIfPresent (i);
697,701d1176
<     case QOS:
<       {
<         m_actionValue = static_cast<uint8_t> (action.qos);
<         break;
<       }
707,716d1181
<     case PUBLIC:
<       {
<         m_actionValue = static_cast<uint8_t> (action.publicAction);
<         break;
<       }
<     case RADIO_MEASUREMENT:
<       {
<         m_actionValue = static_cast<uint8_t> (action.radioMeasurementAction);
<         break;
<       }
732,746d1196
<     case DMG:
<       {
<         m_actionValue = static_cast<uint8_t> (action.dmgAction);
<         break;
<       }
<     case FST:
<       {
<         m_actionValue = static_cast<uint8_t> (action.fstAction);
<         break;
<       }
<     case UNPROTECTED_DMG:
<       {
<         m_actionValue = static_cast<uint8_t> (action.unprotectedAction);
<         break;
<       }
757c1207,1222
<   return static_cast<WifiActionHeader::CategoryValue> (m_category);
---
>   switch (m_category)
>     {
>     case BLOCK_ACK:
>       return BLOCK_ACK;
>     case MESH:
>       return MESH;
>     case MULTIHOP:
>       return MULTIHOP;
>     case SELF_PROTECTED:
>       return SELF_PROTECTED;
>     case VENDOR_SPECIFIC_ACTION:
>       return VENDOR_SPECIFIC_ACTION;
>     default:
>       NS_FATAL_ERROR ("Unknown action value");
>       return SELF_PROTECTED;
>     }
767,787d1231
<     case QOS:
<       switch (m_actionValue)
<         {
<         case ADDTS_REQUEST:
<           retval.qos = ADDTS_REQUEST;
<           break;
<         case ADDTS_RESPONSE:
<           retval.qos = ADDTS_RESPONSE;
<           break;
<         case DELTS:
<           retval.qos = DELTS;
<           break;
<         case SCHEDULE:
<           retval.qos = SCHEDULE;
<           break;
<         case QOS_MAP_CONFIGURE:
<           retval.qos = QOS_MAP_CONFIGURE;
<           break;
<         }
<       break;
< 
803,838d1246
<     case PUBLIC:
<       switch (m_actionValue)
<         {
<         case QAB_REQUEST:
<           retval.publicAction = QAB_REQUEST;
<           break;
<         case QAB_RESPONSE:
<           retval.publicAction = QAB_RESPONSE;
<           break;
<         }
<       break;
< 
<     case RADIO_MEASUREMENT:
<       switch (m_actionValue)
<         {
<         case RADIO_MEASUREMENT_REQUEST:
<           retval.radioMeasurementAction = RADIO_MEASUREMENT_REQUEST;
<           break;
<         case RADIO_MEASUREMENT_REPORT:
<           retval.radioMeasurementAction = RADIO_MEASUREMENT_REPORT;
<           break;
<         case LINK_MEASUREMENT_REQUEST:
<           retval.radioMeasurementAction = LINK_MEASUREMENT_REQUEST;
<           break;
<         case LINK_MEASUREMENT_REPORT:
<           retval.radioMeasurementAction = LINK_MEASUREMENT_REPORT;
<           break;
<         case NEIGHBOR_REPORT_REQUEST:
<           retval.radioMeasurementAction = NEIGHBOR_REPORT_REQUEST;
<           break;
<         case NEIGHBOR_REPORT_RESPONSE:
<           retval.radioMeasurementAction = NEIGHBOR_REPORT_RESPONSE;
<           break;
<         }
<       break;
< 
919,1048d1326
< 
<     case DMG:
<       switch (m_actionValue)
<         {
<         case DMG_POWER_SAVE_CONFIGURATION_REQUEST:
<           retval.dmgAction = DMG_POWER_SAVE_CONFIGURATION_REQUEST;
<           break;
<         case DMG_POWER_SAVE_CONFIGURATION_RESPONSE:
<           retval.dmgAction = DMG_POWER_SAVE_CONFIGURATION_RESPONSE;
<           break;
<         case DMG_INFORMATION_REQUEST:
<           retval.dmgAction = DMG_INFORMATION_REQUEST;
<           break;
<         case DMG_INFORMATION_RESPONSE:
<           retval.dmgAction = DMG_INFORMATION_RESPONSE;
<           break;
<         case DMG_HANDOVER_REQUEST:
<           retval.dmgAction = DMG_HANDOVER_REQUEST;
<           break;
<         case DMG_HANDOVER_RESPONSE:
<           retval.dmgAction = DMG_HANDOVER_RESPONSE;
<           break;
<         case DMG_DTP_REQUEST:
<           retval.dmgAction = DMG_DTP_REQUEST;
<           break;
<         case DMG_DTP_RESPONSE:
<           retval.dmgAction = DMG_DTP_RESPONSE;
<           break;
<         case DMG_RELAY_SEARCH_REQUEST:
<           retval.dmgAction = DMG_RELAY_SEARCH_REQUEST;
<           break;
<         case DMG_RELAY_SEARCH_RESPONSE:
<           retval.dmgAction = DMG_RELAY_SEARCH_RESPONSE;
<           break;
<         case DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REQUEST:
<           retval.dmgAction = DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REQUEST;
<           break;
<         case DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REPORT:
<           retval.dmgAction = DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REPORT;
<           break;
<         case DMG_RLS_REQUEST:
<           retval.dmgAction = DMG_RLS_REQUEST;
<           break;
<         case DMG_RLS_RESPONSE:
<           retval.dmgAction = DMG_RLS_RESPONSE;
<           break;
<         case DMG_RLS_ANNOUNCEMENT:
<           retval.dmgAction = DMG_RLS_ANNOUNCEMENT;
<           break;
<         case DMG_RLS_TEARDOWN:
<           retval.dmgAction = DMG_RLS_TEARDOWN;
<           break;
<         case DMG_RELAY_ACK_REQUEST:
<           retval.dmgAction = DMG_RELAY_ACK_REQUEST;
<           break;
<         case DMG_RELAY_ACK_RESPONSE:
<           retval.dmgAction = DMG_RELAY_ACK_RESPONSE;
<           break;
<         case DMG_TPA_REQUEST:
<           retval.dmgAction = DMG_TPA_REQUEST;
<           break;
<         case DMG_TPA_RESPONSE:
<           retval.dmgAction = DMG_TPA_RESPONSE;
<           break;
<         case DMG_ROC_REQUEST:
<           retval.dmgAction = DMG_ROC_REQUEST;
<           break;
<         case DMG_ROC_RESPONSE:
<           retval.dmgAction = DMG_ROC_RESPONSE;
<           break;
<         default:
<           NS_FATAL_ERROR ("Unknown DMG management action code");
<           retval.selfProtectedAction = PEER_LINK_OPEN; /* quiet compiler */
<         }
<       break;
< 
<     case FST:
<       switch (m_actionValue)
<         {
<         case FST_SETUP_REQUEST:
<           retval.fstAction = FST_SETUP_REQUEST;
<           break;
<         case FST_SETUP_RESPONSE:
<           retval.fstAction = FST_SETUP_RESPONSE;
<           break;
<         case FST_TEAR_DOWN:
<           retval.fstAction = FST_TEAR_DOWN;
<           break;
<         case FST_ACK_REQUEST:
<           retval.fstAction = FST_ACK_REQUEST;
<           break;
<         case FST_ACK_RESPONSE:
<           retval.fstAction = FST_ACK_RESPONSE;
<           break;
<         case ON_CHANNEL_TUNNEL_REQUEST:
<           retval.fstAction = ON_CHANNEL_TUNNEL_REQUEST;
<           break;
<         default:
<           NS_FATAL_ERROR ("Unknown FST management action code");
<           retval.selfProtectedAction = PEER_LINK_OPEN; /* quiet compiler */
<         }
<       break;
< 
<     case UNPROTECTED_DMG:
<       switch (m_actionValue)
<         {
<         case UNPROTECTED_DMG_ANNOUNCE:
<           retval.unprotectedAction = UNPROTECTED_DMG_ANNOUNCE;
<           break;
<         case UNPROTECTED_DMG_BRP:
<           retval.unprotectedAction = UNPROTECTED_DMG_BRP;
<           break;
<         case UNPROTECTED_MIMO_BF_SETUP:
<           retval.unprotectedAction = UNPROTECTED_MIMO_BF_SETUP;
<           break;
<         case UNPROTECTED_MIMO_BF_POLL:
<           retval.unprotectedAction = UNPROTECTED_MIMO_BF_POLL;
<           break;
<         case UNPROTECTED_MIMO_BF_FEEDBACK:
<           retval.unprotectedAction = UNPROTECTED_MIMO_BF_FEEDBACK;
<           break;
<         case UNPROTECTED_MIMO_BF_SELECTION:
<           retval.unprotectedAction = UNPROTECTED_MIMO_BF_SELECTION;
<           break;
<         default:
<           NS_FATAL_ERROR ("Unknown Unprotected DMG action code");
<           retval.selfProtectedAction = PEER_LINK_OPEN; /* quiet compiler */
<         }
<       break;
< 
1159,1439d1436
< /***************************************************
< *               Add TS Request Frame
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (DmgAddTSRequestFrame);
< 
< DmgAddTSRequestFrame::DmgAddTSRequestFrame ()
<   : m_dialogToken (1)
< {
< }
< 
< TypeId
< DmgAddTSRequestFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::DmgAddTSRequestFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<DmgAddTSRequestFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< DmgAddTSRequestFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< DmgAddTSRequestFrame::Print (std::ostream &os) const
< {
< }
< 
< uint32_t
< DmgAddTSRequestFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1;                                      //Dialog token
<   size += m_dmgTspecElement.GetSerializedSize (); //DMG TSPEC
<   return size;
< }
< 
< void
< DmgAddTSRequestFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_dmgTspecElement.Serialize (i);
< }
< 
< uint32_t
< DmgAddTSRequestFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_dmgTspecElement.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< DmgAddTSRequestFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< DmgAddTSRequestFrame::SetDmgTspecElement (DmgTspecElement &element)
< {
<   m_dmgTspecElement = element;
< }
< 
< uint8_t
< DmgAddTSRequestFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< DmgTspecElement
< DmgAddTSRequestFrame::GetDmgTspec (void) const
< {
<   return m_dmgTspecElement;
< }
< 
< /***************************************************
< *               Add TS Response Frame
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (DmgAddTSResponseFrame);
< 
< DmgAddTSResponseFrame::DmgAddTSResponseFrame ()
<   : m_dialogToken (1)
< {
< }
< 
< TypeId
< DmgAddTSResponseFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::DmgAddTSResponseFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<DmgAddTSResponseFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< DmgAddTSResponseFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< DmgAddTSResponseFrame::Print (std::ostream &os) const
< {
< }
< 
< uint32_t
< DmgAddTSResponseFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1;                                      //Dialog token
<   size += m_status.GetSerializedSize ();          //Status Code
<   size += m_tsDelayElement.GetSerializedSize ();  //TS Delay
<   size += m_dmgTspecElement.GetSerializedSize (); //DMG TSPEC
<   return size;
< }
< 
< void
< DmgAddTSResponseFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_status.Serialize (i);
<   i = m_tsDelayElement.Serialize (i);
<   i = m_dmgTspecElement.Serialize (i);
< }
< 
< uint32_t
< DmgAddTSResponseFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_status.Deserialize (i);
<   i = m_tsDelayElement.Deserialize (i);
<   i = m_dmgTspecElement.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< DmgAddTSResponseFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< DmgAddTSResponseFrame::SetStatusCode (StatusCode status)
< {
<   m_status = status;
< }
< 
< void
< DmgAddTSResponseFrame::SetTsDelay (TsDelayElement &element)
< {
<   m_tsDelayElement = element;
< }
< 
< void
< DmgAddTSResponseFrame::SetDmgTspecElement (DmgTspecElement &element)
< {
<   m_dmgTspecElement = element;
< }
< 
< uint8_t
< DmgAddTSResponseFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< StatusCode
< DmgAddTSResponseFrame::GetStatusCode (void) const
< {
<   return m_status;
< }
< 
< TsDelayElement
< DmgAddTSResponseFrame::GetTsDelay (void) const
< {
<   return m_tsDelayElement;
< }
< 
< DmgTspecElement
< DmgAddTSResponseFrame::GetDmgTspec (void) const
< {
<   return m_dmgTspecElement;
< }
< 
< /***************************************************
< *               Delete TS Frame (8.5.3.4)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (DelTsFrame);
< 
< DelTsFrame::DelTsFrame ()
<   : m_reasonCode (0)
< {
< }
< 
< TypeId
< DelTsFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::DelTsFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<DelTsFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< DelTsFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< DelTsFrame::Print (std::ostream &os) const
< {
< }
< 
< uint32_t
< DelTsFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 3;                                        //TS Info
<   size += 2;                                        //Reason Code
<   size += m_dmgAllocationInfo.GetSerializedSize (); //DMG Allocation Info
<   return size;
< }
< 
< void
< DelTsFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.Write (m_tsInfo, 3);
<   i.WriteHtolsbU16 (m_reasonCode);
<   i = m_dmgAllocationInfo.Serialize (i);
< }
< 
< uint32_t
< DelTsFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   i.Read (m_tsInfo, 3);
<   m_reasonCode = i.ReadLsbtohU16 ();
<   i = m_dmgAllocationInfo.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< DelTsFrame::SetReasonCode (uint16_t reason)
< {
<   m_reasonCode = reason;
< }
< 
< void
< DelTsFrame::SetDmgAllocationInfo (DmgAllocationInfo info)
< {
<   m_dmgAllocationInfo = info;
< }
< 
< uint16_t
< DelTsFrame::GetReasonCode (void) const
< {
<   return m_reasonCode;
< }
< 
< DmgAllocationInfo
< DelTsFrame::GetDmgAllocationInfo (void) const
< {
<   return m_dmgAllocationInfo;
< }
1894,5691d1890
< }
< 
< /***************************************************
< *      Radio Measurement Request Frame (8.5.7.2)
< ****************************************************/
< 
< RadioMeasurementRequest::RadioMeasurementRequest ()
<   : m_dialogToken (0),
<     m_numOfRepetitions (0)
< {
< }
< 
< TypeId
< RadioMeasurementRequest::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::RadioMeasurementRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<RadioMeasurementRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< RadioMeasurementRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< RadioMeasurementRequest::Print (std::ostream &os) const
< {
< 
< }
< 
< uint32_t
< RadioMeasurementRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 3;
<   for (WifiInfoElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       size += (*iter)->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< RadioMeasurementRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_numOfRepetitions);
<   for (WifiInfoElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       i = (*iter)->Serialize (i);
<     }
< }
< 
< uint32_t
< RadioMeasurementRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<DirectionalChannelQualityRequestElement> element;
<   m_dialogToken = i.ReadU8 ();
<   m_numOfRepetitions = i.ReadLsbtohU16 ();
<   while (!i.IsEnd ())
<     {
<       element = Create<DirectionalChannelQualityRequestElement> ();
<       i = element->Deserialize (i);
<       m_list.push_back (element);
<   }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< RadioMeasurementRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< RadioMeasurementRequest::SetNumberOfRepetitions (uint16_t repetitions)
< {
<   m_numOfRepetitions = repetitions;
< }
< 
< void
< RadioMeasurementRequest::AddMeasurementRequestElement (Ptr<WifiInformationElement> elem)
< {
<   m_list.push_back (elem);
< }
< 
< uint8_t
< RadioMeasurementRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< RadioMeasurementRequest::GetNumberOfRepetitions (void) const
< {
<   return m_numOfRepetitions;
< }
< 
< WifiInfoElementList
< RadioMeasurementRequest::GetListOfMeasurementRequestElement (void) const
< {
<   return m_list;
< }
< 
< /***************************************************
< *      Radio Measurement Request Frame (8.5.7.3)
< ****************************************************/
< 
< RadioMeasurementReport::RadioMeasurementReport ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< RadioMeasurementReport::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::RadioMeasurementReport")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<RadioMeasurementReport> ()
<   ;
<   return tid;
< }
< 
< TypeId
< RadioMeasurementReport::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< RadioMeasurementReport::Print (std::ostream &os) const
< {
< 
< }
< 
< uint32_t
< RadioMeasurementReport::GetSerializedSize (void) const
< {
<   uint32_t size = 1;
<   for (WifiInfoElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       size += (*iter)->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< RadioMeasurementReport::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   for (WifiInfoElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       i = (*iter)->Serialize (i);
<     }
< }
< 
< uint32_t
< RadioMeasurementReport::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<DirectionalChannelQualityReportElement> element;
<   m_dialogToken = i.ReadU8 ();
<   while (!i.IsEnd ())
<     {
<       element = Create<DirectionalChannelQualityReportElement> ();
<       i = element->Deserialize (i);
<       m_list.push_back (element);
<   }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< RadioMeasurementReport::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< RadioMeasurementReport::AddMeasurementReportElement (Ptr<WifiInformationElement> elem)
< {
<   m_list.push_back (elem);
< }
< 
< uint8_t
< RadioMeasurementReport::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< WifiInfoElementList
< RadioMeasurementReport::GetListOfMeasurementReportElement (void) const
< {
<   return m_list;
< }
< 
< /***************************************************
< *      Link Measurement Request Frame (8.5.7.5)
< ****************************************************/
< 
< LinkMeasurementRequest::LinkMeasurementRequest ()
<   : m_dialogToken (0),
<     m_transmitPowerUsed (0),
<     m_maxTransmitPower (0)
< {
< }
< 
< TypeId
< LinkMeasurementRequest::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::LinkMeasurementRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<LinkMeasurementRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< LinkMeasurementRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< LinkMeasurementRequest::Print (std::ostream &os) const
< {
< 
< }
< 
< uint32_t
< LinkMeasurementRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 3;
<   for (WifiInformationSubelementMap::const_iterator iter = m_map.begin (); iter != m_map.end (); iter++)
<     {
<       size += iter->second->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< LinkMeasurementRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteU8 (m_transmitPowerUsed);
<   i.WriteU8 (m_maxTransmitPower);
<   for (WifiInformationSubelementMap::const_iterator iter = m_map.begin (); iter != m_map.end (); iter++)
<     {
<       iter->second->Serialize (i);
<     }
< }
< 
< uint32_t
< LinkMeasurementRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<WifiInformationElement> element;
<   uint8_t id, length;
<   m_dialogToken = i.ReadU8 ();
<   m_transmitPowerUsed = i.ReadU8 ();
<   m_maxTransmitPower = i.ReadU8 ();
<   while (!i.IsEnd ())
<     {
<       i = DeserializeElementID (i, id, length);
<       switch (id)
<         {
<           case IE_DMG_LINK_MARGIN:
<             {
<               element = Create<LinkMarginElement> ();
<               break;
<             }
<           case IE_DMG_LINK_ADAPTATION_ACKNOWLEDGMENT:
<             {
<               element = Create<LinkAdaptationAcknowledgment> ();
<               break;
<             }
<         }
<       i = element->DeserializeElementBody (i, length);
<       m_map[id] = element;
<   }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< LinkMeasurementRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< LinkMeasurementRequest::SetTransmitPowerUsed (uint8_t power)
< {
<   m_transmitPowerUsed = power;
< }
< 
< void
< LinkMeasurementRequest::SetMaxTransmitPower (uint8_t power)
< {
<   m_maxTransmitPower = power;
< }
< 
< void
< LinkMeasurementRequest::AddSubElement (Ptr<WifiInformationElement> elem)
< {
<   m_map[elem->ElementId ()] = elem;
< }
< 
< uint8_t
< LinkMeasurementRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint8_t
< LinkMeasurementRequest::GetTransmitPowerUsed (uint8_t power) const
< {
<   return m_transmitPowerUsed;
< }
< 
< uint8_t
< LinkMeasurementRequest::GetMaxTransmitPower (uint8_t power) const
< {
<   return m_maxTransmitPower;
< }
< 
< Ptr<WifiInformationElement>
< LinkMeasurementRequest::GetSubElement (WifiInformationElementId id)
< {
<   return m_map[id];
< }
< 
< WifiInformationSubelementMap
< LinkMeasurementRequest::GetListOfSubElements (void) const
< {
<   return m_map;
< }
< 
< /***************************************************
< *      Link Measurement Report Frame (8.5.7.5)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (LinkMeasurementReport);
< 
< LinkMeasurementReport::LinkMeasurementReport ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< LinkMeasurementReport::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::LinkMeasurementReport")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<LinkMeasurementReport> ()
<   ;
<   return tid;
< }
< 
< TypeId
< LinkMeasurementReport::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< LinkMeasurementReport::Print (std::ostream &os) const
< {
<   os << "Dialog Token=" << m_dialogToken;
< }
< 
< uint32_t
< LinkMeasurementReport::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 9;
<   for (WifiInformationSubelementMap::const_iterator iter = m_map.begin (); iter != m_map.end (); iter++)
<     {
<       size += iter->second->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< LinkMeasurementReport::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU32 (m_tpcElement);
<   i.WriteU8 (m_receiveAntId);
<   i.WriteU8 (m_transmitAntId);
<   i.WriteU8 (m_rcpi);
<   i.WriteU8 (m_rsni);
<   for (WifiInformationSubelementMap::const_iterator iter = m_map.begin (); iter != m_map.end (); iter++)
<     {
<       iter->second->Serialize (i);
<     }
< }
< 
< uint32_t
< LinkMeasurementReport::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<WifiInformationElement> element;
<   uint8_t id, length;
<   m_dialogToken = i.ReadU8 ();
<   m_tpcElement = i.ReadLsbtohU32 ();
<   m_receiveAntId = i.ReadU8 ();
<   m_transmitAntId = i.ReadU8 ();
<   m_rcpi = i.ReadU8 ();
<   m_rsni = i.ReadU8 ();
<   while (!i.IsEnd ())
<     {
<       i = DeserializeElementID (i, id, length);
<       switch (id)
<         {
<           case IE_DMG_LINK_MARGIN:
<             {
<               element = Create<LinkMarginElement> ();
<               break;
<             }
<           case IE_DMG_LINK_ADAPTATION_ACKNOWLEDGMENT:
<             {
<               element = Create<LinkAdaptationAcknowledgment> ();
<               break;
<             }
<         }
<       i = element->DeserializeElementBody (i, length);
<       m_map[id] = element;
<   }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< LinkMeasurementReport::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< LinkMeasurementReport::SetTpcReportElement (uint32_t elem)
< {
<   m_tpcElement = elem;
< }
< 
< void
< LinkMeasurementReport::SetReceiveAntennaId (uint8_t id)
< {
<   m_receiveAntId = id;
< }
< 
< void
< LinkMeasurementReport::SetTransmitAntennaId (uint8_t id)
< {
<   m_transmitAntId = id;
< }
< 
< void
< LinkMeasurementReport::SetRCPI (uint8_t value)
< {
<   m_rcpi = value;
< }
< 
< void
< LinkMeasurementReport::SetRSNI (uint8_t value)
< {
<   m_rsni = value;
< }
< 
< void
< LinkMeasurementReport::AddSubElement (Ptr<WifiInformationElement> elem)
< {
<   m_map[elem->ElementId ()] = elem;
< }
< 
< uint8_t
< LinkMeasurementReport::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint32_t
< LinkMeasurementReport::GetTpcReportElement (void) const
< {
<   return m_tpcElement;
< }
< 
< uint8_t
< LinkMeasurementReport::GetReceiveAntennaId (void) const
< {
<   return m_receiveAntId;
< }
< 
< uint8_t
< LinkMeasurementReport::GetTransmitAntennaId (void) const
< {
<   return m_transmitAntId;
< }
< 
< uint8_t
< LinkMeasurementReport::GetRCPI (void) const
< {
<   return m_rcpi;
< }
< 
< uint8_t
< LinkMeasurementReport::GetRSNI (void) const
< {
<   return m_rsni;
< }
< 
< Ptr<WifiInformationElement>
< LinkMeasurementReport::GetSubElement (WifiInformationElementId id)
< {
<   return m_map[id];
< }
< 
< WifiInformationSubelementMap
< LinkMeasurementReport::GetListOfSubElements (void) const
< {
<   return m_map;
< }
< 
< /***************************************************
< *               Common QAB Frame
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtQabFrame);
< 
< void
< ExtQabFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Requestor AP Address = " << m_requester
<      << ", Responder AP Address = " << m_responder;
< }
< 
< uint32_t
< ExtQabFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 6; //Requestor AP Address
<   size += 6; //Responder AP Address
< 
<   return size;
< }
< 
< void
< ExtQabFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtQabFrame::SetRequesterApAddress (Mac48Address address)
< {
<   m_requester = address;
< }
< 
< void
< ExtQabFrame::SetResponderApAddress (Mac48Address address)
< {
<   m_responder = address;
< }
< 
< uint8_t
< ExtQabFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< Mac48Address
< ExtQabFrame::GetRequesterApAddress (void) const
< {
<   return m_requester;
< }
< 
< Mac48Address
< ExtQabFrame::GetResponderApAddress (void) const
< {
<   return m_responder;
< }
< 
< /***************************************************
< *           QAB Request Frame (8.5.8.25)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtQabRequestFrame);
< 
< ExtQabRequestFrame::ExtQabRequestFrame ()
< {
<   m_dialogToken = 0;
< }
< 
< TypeId
< ExtQabRequestFrame::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtQabRequestFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtQabRequestFrame> ()
<   ;
<   return tid;
< }
< 
< void
< ExtQabRequestFrame::Print (std::ostream &os) const
< {
<   ExtQabFrame::Print (os);
<   m_element.Print (os);
< }
< 
< uint32_t
< ExtQabRequestFrame::GetSerializedSize (void) const
< {
<   return ExtQabFrame::GetSerializedSize () + m_element.GetSerializedSize ();
< }
< 
< TypeId
< ExtQabRequestFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtQabRequestFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   WriteTo (i, m_requester);
<   WriteTo (i, m_responder);
<   i = m_element.Serialize (i);
< }
< 
< uint32_t
< ExtQabRequestFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   ReadFrom (i, m_requester);
<   ReadFrom (i, m_responder);
<   i = m_element.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtQabRequestFrame::SetQuietPeriodRequestElement (QuietPeriodRequestElement &element)
< {
<   m_element = element;
< }
< 
< QuietPeriodRequestElement
< ExtQabRequestFrame::GetQuietPeriodRequestElement (void) const
< {
<   return m_element;
< }
< 
< /***************************************************
< *           QAB Response Frame (8.5.8.26)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtQabResponseFrame);
< 
< ExtQabResponseFrame::ExtQabResponseFrame ()
< {
<   m_dialogToken = 0;
< }
< 
< void
< ExtQabResponseFrame::Print (std::ostream &os) const
< {
<   ExtQabFrame::Print (os);
<   m_element.Print (os);
< }
< 
< uint32_t
< ExtQabResponseFrame::GetSerializedSize (void) const
< {
<   return ExtQabFrame::GetSerializedSize () + m_element.GetSerializedSize ();
< }
< 
< TypeId
< ExtQabResponseFrame::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtQabResponseFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtQabResponseFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtQabResponseFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtQabResponseFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   WriteTo (i, m_requester);
<   WriteTo (i, m_responder);
<   i = m_element.Serialize (i);
< }
< 
< uint32_t
< ExtQabResponseFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   ReadFrom (i, m_requester);
<   ReadFrom (i, m_responder);
<   i = m_element.Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtQabResponseFrame::SetQuietPeriodResponseElement (QuietPeriodResponseElement &element)
< {
<   m_element = element;
< }
< 
< QuietPeriodResponseElement
< ExtQabResponseFrame::GetQuietPeriodResponseElement (void) const
< {
<   return m_element;
< }
< 
< /***************************************************
< *           Common Information Frame
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtInformationFrame);
< 
< ExtInformationFrame::ExtInformationFrame ()
< {
< }
< 
< void
< ExtInformationFrame::Print (std::ostream &os) const
< {
< 
< }
< 
< uint32_t
< ExtInformationFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 6; //Subject Address
<   size += m_requestElement->GetSerializedSize (); //Request Information
<   // DMG Capabilities List
<   size += m_dmgCapabilitiesList.size () * 26; /* The whole DMG Capabilities Element Size */
<   // Wifi Information Element List (Optional)
<   size += GetInformationElementsSerializedSize ();
<   return size;
< }
< 
< void
< ExtInformationFrame::SetSubjectAddress (Mac48Address address)
< {
<   m_subjectAddress = address;
< }
< 
< void
< ExtInformationFrame::SetRequestInformationElement (Ptr<RequestElement> elem)
< {
<   m_requestElement = elem;
< }
< 
< void
< ExtInformationFrame::AddDmgCapabilitiesElement (Ptr<DmgCapabilities> elem)
< {
<   m_dmgCapabilitiesList.push_back (elem);
< }
< 
< 
< Mac48Address
< ExtInformationFrame::GetSubjectAddress (void) const
< {
<   return m_subjectAddress;
< }
< 
< Ptr<RequestElement>
< ExtInformationFrame::GetRequestInformationElement (void) const
< {
<   return m_requestElement;
< }
< 
< DmgCapabilitiesList
< ExtInformationFrame::GetDmgCapabilitiesList (void) const
< {
<   return m_dmgCapabilitiesList;
< }
< 
< /***************************************************
< *         Information Request Frame (8.5.20.4)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtInformationRequest);
< 
< TypeId
< ExtInformationRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtInformationRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtInformationRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtInformationRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtInformationRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   WriteTo (i, m_subjectAddress);
<   i = m_requestElement->Serialize (i);
<   for (DmgCapabilitiesList::const_iterator j = m_dmgCapabilitiesList.begin (); j != m_dmgCapabilitiesList.end () ; j++)
<     {
<       i = (*j)->Serialize (i);
<     }
<   i = SerializeInformationElements (i);
< }
< 
< uint32_t
< ExtInformationRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Buffer::Iterator m;
<   Ptr<DmgCapabilities> dmgCapabilities;
< 
<   ReadFrom (i, m_subjectAddress);
<   m_requestElement = Create<RequestElement> ();
<   i = m_requestElement->Deserialize (i);
< 
<   /* Deserialize DMG Capabilities Elements */
<   while (!i.IsEnd ())
<     {
<       m = i;
<       dmgCapabilities = Create<DmgCapabilities> ();
<       i = dmgCapabilities->DeserializeIfPresent (i);
<       if (i.GetDistanceFrom (m) != 0)
<         {
<           m_dmgCapabilitiesList.push_back (dmgCapabilities);
<         }
<       else
<         {
<           break;
<         }
<     }
< 
<   /* Deserialize Infomration Elements */
<   i = DeserializeInformationElements (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< 
< /***************************************************
< *         Information Response Frame (8.5.20.5)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtInformationResponse);
< 
< TypeId
< ExtInformationResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtInformationResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtInformationResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtInformationResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< uint32_t
< ExtInformationResponse::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 6; //Subject Address
<   size += m_requestElement->GetSerializedSize (); //Request Information
<   // DMG Capabilities List
<   size += m_dmgCapabilitiesList.size () * 26; /* The whole DMG Capabilities Element Size */
<   // Wifi Information Element List (Optional)
<   if (m_beamRefinement != 0)
<     {
<       size += m_beamRefinement->GetSerializedSize ();
<     }
<   if (m_channelElement != 0)
<     {
<       size += m_channelElement->GetSerializedSize ();
<     }
<   if (m_edmgChannelElement != 0)
<     {
<       size += m_edmgChannelElement->GetSerializedSize ();
<     }
<   size += GetInformationElementsSerializedSize ();
<   return size;
< }
< void
< ExtInformationResponse::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   WriteTo (i, m_subjectAddress);
<   for (DmgCapabilitiesList::const_iterator j = m_dmgCapabilitiesList.begin (); j != m_dmgCapabilitiesList.end () ; j++)
<     {
<       i = (*j)->Serialize (i);
<     }
<   i = m_requestElement->Serialize (i);
<   if (m_beamRefinement != 0)
<     {
<       i = m_beamRefinement->Serialize (i);
<     }
<   if (m_channelElement != 0)
<     {
<       i = m_channelElement->Serialize (i);
<     }
<   if (m_edmgChannelElement != 0)
<     {
<       i = m_edmgChannelElement->Serialize (i);
<     }
<   i = SerializeInformationElements (i);
< }
< 
< uint32_t
< ExtInformationResponse::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Buffer::Iterator m;
<   Ptr<DmgCapabilities> dmgCapabilities;
< 
< 
<   ReadFrom (i, m_subjectAddress);
<   /* Deserialize DMG Capabilities Elements */
<   while (!i.IsEnd ())
<     {
<       m = i;
<       dmgCapabilities = Create<DmgCapabilities> ();
<       i = dmgCapabilities->DeserializeIfPresent (i);
<       if (i.GetDistanceFrom (m) != 0)
<         {
<           m_dmgCapabilitiesList.push_back (dmgCapabilities);
<         }
<       else
<         {
<           break;
<         }
<     }
< 
<   m_requestElement = Create<RequestElement> ();
<   i = m_requestElement->Deserialize (i);
< 
<   m_beamRefinement = Create<BeamRefinementElement> ();
<   m_channelElement = Create<ChannelMeasurementFeedbackElement> ();
<   m_edmgChannelElement = Create<EDMGChannelMeasurementFeedbackElement> ();
< 
<   m = i;
<   i = m_beamRefinement->DeserializeIfPresent (i);
<   if (i.GetDistanceFrom (m) != 0)
<     {
<       bool channelPresent = false;
<       if (m_beamRefinement->IsSnrPresent ())
<         {
<           channelPresent = true;
<           if (m_beamRefinement->GetEdmgExtensionFlag ())
<             {
<               m_channelElement->SetSnrListSize (m_beamRefinement->GetExtendedNumberOfMeasurements ());
<             }
<           else
<             {
<               m_channelElement->SetSnrListSize (m_beamRefinement->GetNumberOfMeasurements ());
<             }
<         }
< 
<       if (m_beamRefinement->IsChannelMeasurementPresent ())
<         {
<           channelPresent = true;
<           if (m_beamRefinement->GetEdmgExtensionFlag ())
<             {
<               m_channelElement->SetChannelMeasurementSize (m_beamRefinement->GetExtendedNumberOfMeasurements ());
<             }
<           else
<             {
<               m_channelElement->SetChannelMeasurementSize (m_beamRefinement->GetNumberOfMeasurements ());
<             }
<           m_channelElement->SetTapComponentsSize (m_beamRefinement->GetNumberOfTapsPresent ());
<         }
< 
<       if (m_beamRefinement->IsTapDelayPresent ())
<         {
<           if (m_beamRefinement->GetEdmgExtensionFlag ())
<             {
<               m_edmgChannelElement->SetTapsDelaySize (m_beamRefinement->GetNumberOfTapsPresent ());
<             }
<           else
<             {
<               channelPresent = true;
<               m_channelElement->SetTapsDelaySize (m_beamRefinement->GetNumberOfTapsPresent ());
<             }
<         }
< 
<       if (m_beamRefinement->IsSectorIdOrderPresent ())
<         {
<           if (m_beamRefinement->GetNumberOfBeams () != 0)
<             {
<               if (m_beamRefinement->GetEdmgExtensionFlag ())
<                 {
<                   m_edmgChannelElement->SetSectorIdOrderSize (m_beamRefinement->GetNumberOfBeams ());
<                 }
<               else
<                 {
<                   channelPresent = true;
<                   m_channelElement->SetSectorIdSize (m_beamRefinement->GetNumberOfBeams ());
<                 }
<             }
<           else
<             {
<               if (m_beamRefinement->GetEdmgExtensionFlag ())
<                 {
<                   m_edmgChannelElement->SetSectorIdOrderSize (m_beamRefinement->GetExtendedNumberOfMeasurements ());
<                 }
<               else
<                 {
<                   channelPresent = true;
<                   m_channelElement->SetSectorIdSize (m_beamRefinement->GetNumberOfMeasurements ());
<                 }
<             }
<         }
< 
<       if ((m_beamRefinement->GetSectorSweepFrameType () == BRP_FRAME) || (m_beamRefinement->GetSectorSweepFrameType () == BEAM_TRACKING_FBCK))
<         {
<           if (m_beamRefinement->GetEdmgExtensionFlag ())
<             {
<               m_edmgChannelElement->SetBrpCdownSize (m_beamRefinement->GetExtendedNumberOfMeasurements ());
<             }
<         }
< 
<       if (channelPresent)
<         {
<           i = m_channelElement->Deserialize (i);
<         }
< 
<       if (m_beamRefinement->IsEdmgChannelMeasurementPresent ())
<         {
<           i = m_edmgChannelElement->Deserialize (i);
<         }
<     }
< 
<   /* Deserialize Infomration Elements */
<   i = DeserializeInformationElements (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< Ptr<BeamRefinementElement>
< ExtInformationResponse::GetBeamRefinementElement (void) const
< {
<   return m_beamRefinement;
< }
< Ptr<ChannelMeasurementFeedbackElement>
< ExtInformationResponse::GetChannelMeasurementElement (void) const
< {
<   return m_channelElement;
< }
< 
< Ptr<EDMGChannelMeasurementFeedbackElement>
< ExtInformationResponse::GetEDMGChannelMeasurementElement (void) const
< {
<   return m_edmgChannelElement;
< }
< 
< void
< ExtInformationResponse::SetBeamRefinementElement (Ptr<BeamRefinementElement> element)
< {
<   m_beamRefinement = element;
< }
< 
< void
< ExtInformationResponse::SetChannelMeasurementElement (Ptr<ChannelMeasurementFeedbackElement> element)
< {
<   m_channelElement = element;
< }
< 
< void
< ExtInformationResponse::SetEdmgChannelMeasurementElement (Ptr<EDMGChannelMeasurementFeedbackElement> element)
< {
<   m_edmgChannelElement = element;
< }
< 
< /***************************************************
< *                 Handover Request
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtHandoverRequestHeader);
< 
< ExtHandoverRequestHeader::ExtHandoverRequestHeader ()
<   : m_handoverReason (LeavingPBSS),
<     m_remainingBI (0)
< {
< }
< 
< TypeId
< ExtHandoverRequestHeader::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtHandoverRequestHeader")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtHandoverRequestHeader> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtHandoverRequestHeader::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtHandoverRequestHeader::Print (std::ostream &os) const
< {
<   os << "Handover Reason = " << m_handoverReason
<      << ", m_remainingBI = " << m_remainingBI;
< }
< 
< uint32_t
< ExtHandoverRequestHeader::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Handover Reason
<   size += 1; //Handover Remaining BI
<   return size;
< }
< 
< void
< ExtHandoverRequestHeader::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_handoverReason);
<   i.WriteU8 (m_remainingBI);
< }
< 
< uint32_t
< ExtHandoverRequestHeader::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_handoverReason = i.ReadU8 ();
<   m_remainingBI = i.ReadU8 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtHandoverRequestHeader::SetHandoverReason (enum HandoverReason reason)
< {
<   m_handoverReason = reason;
< }
< 
< void
< ExtHandoverRequestHeader::SetHandoverRemainingBI (uint8_t remaining)
< {
<   m_remainingBI = remaining;
< }
< 
< enum HandoverReason
< ExtHandoverRequestHeader::GetHandoverReason (void) const
< {
<   return static_cast<enum HandoverReason> (m_handoverReason);
< }
< 
< uint8_t
< ExtHandoverRequestHeader::GetHandoverRemainingBI (void) const
< {
<   return m_remainingBI;
< }
< 
< /***************************************************
< *                 Handover Response
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtHandoverResponseHeader);
< 
< ExtHandoverResponseHeader::ExtHandoverResponseHeader ()
<   : m_handoverResult (1),
<     m_handoverRejectReason (LowPower)
< {
< }
< 
< TypeId
< ExtHandoverResponseHeader::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtHandoverResponseHeader")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtHandoverResponseHeader> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtHandoverResponseHeader::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtHandoverResponseHeader::Print (std::ostream &os) const
< {
<   os << "Handover Result = " << m_handoverResult
<      << ", Handover Reject Reason = " << m_handoverRejectReason;
< }
< 
< uint32_t
< ExtHandoverResponseHeader::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Handover Result
<   size += 1; //Handover Reject Reason
<   return size;
< }
< 
< void
< ExtHandoverResponseHeader::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_handoverResult);
<   i.WriteU8 (m_handoverRejectReason);
< }
< 
< uint32_t
< ExtHandoverResponseHeader::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_handoverResult = i.ReadU8 ();
<   m_handoverRejectReason = i.ReadU8 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtHandoverResponseHeader::SetHandoverResult (bool result)
< {
<   m_handoverResult = result;
< }
< 
< void
< ExtHandoverResponseHeader::SetHandoverRejectReason (enum HandoverRejectReason reason)
< {
<   m_handoverRejectReason = reason;
< }
< 
< bool
< ExtHandoverResponseHeader::GetHandoverResult (void) const
< {
<   return m_handoverResult;
< }
< 
< enum HandoverRejectReason
< ExtHandoverResponseHeader::GetHandoverRejectReason (void) const
< {
<   return static_cast<enum HandoverRejectReason> (m_handoverRejectReason);
< }
< 
< /***************************************************
< *               Relay Search Request
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRelaySearchRequestHeader);
< 
< ExtRelaySearchRequestHeader::ExtRelaySearchRequestHeader ()
<   : m_dialogToken (0),
<     m_aid (0)
< {
< }
< 
< TypeId
< ExtRelaySearchRequestHeader::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRelaySearchRequestHeader")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRelaySearchRequestHeader> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRelaySearchRequestHeader::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRelaySearchRequestHeader::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Destination REDS AID = " << m_aid;
< }
< 
< uint32_t
< ExtRelaySearchRequestHeader::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += 2; //Destination REDS AID
<   return size;
< }
< 
< void
< ExtRelaySearchRequestHeader::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_aid);
< }
< 
< uint32_t
< ExtRelaySearchRequestHeader::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   m_aid = i.ReadLsbtohU16 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRelaySearchRequestHeader::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtRelaySearchRequestHeader::SetDestinationRedsAid (uint16_t aid)
< {
<   m_aid = aid;
< }
< 
< uint8_t
< ExtRelaySearchRequestHeader::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< ExtRelaySearchRequestHeader::GetDestinationRedsAid (void) const
< {
<   return m_aid;
< }
< 
< /***************************************************
< *               Relay Search Response
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRelaySearchResponseHeader);
< 
< ExtRelaySearchResponseHeader::ExtRelaySearchResponseHeader ()
<   : m_dialogToken (0),
<     m_statusCode (0)
< {
< }
< 
< TypeId
< ExtRelaySearchResponseHeader::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRelaySearchResponseHeader")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRelaySearchResponseHeader> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRelaySearchResponseHeader::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRelaySearchResponseHeader::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Status Code = " << m_statusCode;
< }
< 
< uint32_t
< ExtRelaySearchResponseHeader::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += 2; //Status Code
<   if (m_statusCode == 0)
<     {
<       size += m_list.size () * 3; //Relay Capable STA Info
<     }
<   return size;
< }
< 
< void
< ExtRelaySearchResponseHeader::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_statusCode);
<   if (m_statusCode == 0)
<     {
<       for (RelayCapableStaList::const_iterator item = m_list.begin (); item != m_list.end (); item++)
<         {
<           i.WriteU8 ((item->first & 0xFF));
<           i = item->second.Serialize (i);
<         }
<     }
< }
< 
< uint32_t
< ExtRelaySearchResponseHeader::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   RelayCapabilitiesInfo info;
<   uint16_t aid;
<   m_dialogToken = i.ReadU8 ();
<   m_statusCode = i.ReadLsbtohU16 ();
<   if (!i.IsEnd ())
<     {
<       do
<         {
<           aid = i.ReadU8 ();
<           i = info.Deserialize (i);
<           m_list[aid] = info;
<         }
<       while (!i.IsEnd ());
<     }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRelaySearchResponseHeader::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtRelaySearchResponseHeader::SetStatusCode (uint16_t code)
< {
<   m_statusCode = code;
< }
< 
< void
< ExtRelaySearchResponseHeader::AddRelayCapableStaInfo (uint8_t aid, RelayCapabilitiesInfo &element)
< {
<   m_list[aid] = element;
< }
< 
< void
< ExtRelaySearchResponseHeader::SetRelayCapableList (RelayCapableStaList &list)
< {
<   m_list = list;
< }
< 
< uint8_t
< ExtRelaySearchResponseHeader::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< ExtRelaySearchResponseHeader::GetStatusCode (void) const
< {
<   return m_statusCode;
< }
< 
< RelayCapableStaList
< ExtRelaySearchResponseHeader::GetRelayCapableList (void) const
< {
<   return m_list;
< }
< 
< /***************************************************
< *     Multi Relay Channel Measurement Request
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMultiRelayChannelMeasurementRequest);
< 
< ExtMultiRelayChannelMeasurementRequest::ExtMultiRelayChannelMeasurementRequest ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< ExtMultiRelayChannelMeasurementRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtMultiRelayChannelMeasurementRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMultiRelayChannelMeasurementRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMultiRelayChannelMeasurementRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMultiRelayChannelMeasurementRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMultiRelayChannelMeasurementRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   return size;
< }
< 
< void
< ExtMultiRelayChannelMeasurementRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
< }
< 
< uint32_t
< ExtMultiRelayChannelMeasurementRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMultiRelayChannelMeasurementRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< uint8_t
< ExtMultiRelayChannelMeasurementRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< /***************************************************
< *     Multi Relay Channel Measurement Report
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMultiRelayChannelMeasurementReport);
< 
< ExtMultiRelayChannelMeasurementReport::ExtMultiRelayChannelMeasurementReport ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< ExtMultiRelayChannelMeasurementReport::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtMultiRelayChannelMeasurementReport")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMultiRelayChannelMeasurementReport> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMultiRelayChannelMeasurementReport::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMultiRelayChannelMeasurementReport::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1;                  //Dialog Token
<   size += m_list.size () * 4; //Channel Measurement Info
<   return size;
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   Ptr<ExtChannelMeasurementInfo> info;
<   i.WriteU8 (m_dialogToken);
<   for (ChannelMeasurementInfoList::const_iterator item = m_list.begin (); item != m_list.end (); item++)
<     {
<       info = *item;
<       i = info->Serialize (i);
<     }
< }
< 
< uint32_t
< ExtMultiRelayChannelMeasurementReport::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Ptr<ExtChannelMeasurementInfo> element;
<   m_dialogToken = i.ReadU8 ();
<   while (!i.IsEnd ())
<     {
<       element = Create<ExtChannelMeasurementInfo> ();
<       i = element->Deserialize (i);
<       m_list.push_back (element);
<     }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::AddChannelMeasurementInfo (Ptr<ExtChannelMeasurementInfo> element)
< {
<   m_list.push_back (element);
< }
< 
< void
< ExtMultiRelayChannelMeasurementReport::SetChannelMeasurementList (ChannelMeasurementInfoList &list)
< {
<   m_list = list;
< }
< 
< uint8_t
< ExtMultiRelayChannelMeasurementReport::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< ChannelMeasurementInfoList
< ExtMultiRelayChannelMeasurementReport::GetChannelMeasurementInfoList (void) const
< {
<   return m_list;
< }
< 
< /***************************************************
< *        Generic Relay Link Setup Frame
< ****************************************************/
< 
< ExtRlsFrame::ExtRlsFrame ()
<   : m_destinationAid (0),
<     m_relayAid (0),
<     m_sourceAid (0)
< {
< }
< 
< uint32_t
< ExtRlsFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 2; //Destination AID
<   size += 2; //Relay AID
<   size += 2; //Source AID
<   return size;
< }
< 
< void
< ExtRlsFrame::SetDestinationAid (uint16_t aid)
< {
<   m_destinationAid = aid;
< }
< 
< void
< ExtRlsFrame::SetRelayAid (uint16_t aid)
< {
<   m_relayAid = aid;
< }
< 
< void
< ExtRlsFrame::SetSourceAid (uint16_t aid)
< {
<   m_sourceAid = aid;
< }
< 
< uint16_t
< ExtRlsFrame::GetDestinationAid (void) const
< {
<   return m_destinationAid;
< }
< 
< uint16_t
< ExtRlsFrame::GetRelayAid (void) const
< {
<   return m_relayAid;
< }
< 
< uint16_t
< ExtRlsFrame::GetSourceAid (void) const
< {
<   return m_sourceAid;
< }
< 
< /***************************************************
< *        Relay Link Setup Request 8.5.20.14
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRlsRequest);
< 
< ExtRlsRequest::ExtRlsRequest ()
<   : m_dialogToken (0)
< {
< }
< 
< TypeId
< ExtRlsRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRlsRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRlsRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRlsRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRlsRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Destination AID = " << m_destinationAid
<      << ", Relay AID = " <<  m_relayAid
<      << ", Source AID = " <<  m_sourceAid;
< }
< 
< uint32_t
< ExtRlsRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += ExtRlsFrame::GetSerializedSize ();
<   size += m_destinationCapability.GetSerializedSize (); //Destination Capability
<   size += m_relayCapability.GetSerializedSize ();       //Relay Capability
<   size += m_sourceCapability.GetSerializedSize ();      //Source Capability
<   size += m_relayParameter->GetSerializedSize ();       //Relay Transfer
<   return size;
< }
< 
< void
< ExtRlsRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_destinationAid);
<   i.WriteHtolsbU16 (m_relayAid);
<   i.WriteHtolsbU16 (m_sourceAid);
< 
<   i = m_destinationCapability.Serialize (i);
<   i = m_relayCapability.Serialize (i);
<   i = m_sourceCapability.Serialize (i);
<   i = m_relayParameter->Serialize (i);
< }
< 
< uint32_t
< ExtRlsRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   m_destinationAid = i.ReadLsbtohU16 ();
<   m_relayAid = i.ReadLsbtohU16 ();
<   m_sourceAid = i.ReadLsbtohU16 ();
< 
<   i = m_destinationCapability.Deserialize (i);
<   i = m_relayCapability.Deserialize (i);
<   i = m_sourceCapability.Deserialize (i);
< 
<   m_relayParameter = Create<RelayTransferParameterSetElement> ();
<   i = m_relayParameter->Deserialize (i);
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRlsRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtRlsRequest::SetDestinationCapabilityInformation (RelayCapabilitiesInfo &elem)
< {
<   m_destinationCapability = elem;
< }
< 
< void
< ExtRlsRequest::SetRelayCapabilityInformation (RelayCapabilitiesInfo &elem)
< {
<   m_relayCapability = elem;
< }
< 
< void
< ExtRlsRequest::SetSourceCapabilityInformation (RelayCapabilitiesInfo &elem)
< {
<   m_sourceCapability = elem;
< }
< 
< void
< ExtRlsRequest::SetRelayTransferParameterSet (Ptr<RelayTransferParameterSetElement> elem)
< {
<   m_relayParameter = elem;
< }
< 
< uint8_t
< ExtRlsRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< RelayCapabilitiesInfo
< ExtRlsRequest::GetDestinationCapabilityInformation (void) const
< {
<   return m_destinationCapability;
< }
< 
< RelayCapabilitiesInfo
< ExtRlsRequest::GetRelayCapabilityInformation (void) const
< {
<   return m_relayCapability;
< }
< 
< RelayCapabilitiesInfo
< ExtRlsRequest::GetSourceCapabilityInformation (void) const
< {
<   return m_sourceCapability;
< }
< 
< Ptr<RelayTransferParameterSetElement>
< ExtRlsRequest::GetRelayTransferParameterSet (void) const
< {
<   return m_relayParameter;
< }
< 
< /***************************************************
< *        Relay Link Setup Response 8.5.20.15
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRlsResponse);
< 
< ExtRlsResponse::ExtRlsResponse ()
<   : m_dialogToken (0),
<     m_destinationStatusCode (0),
<     m_relayStatusCode (0),
<     m_insertRelayStatus (false)
< {
< }
< 
< TypeId
< ExtRlsResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRlsResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRlsResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRlsResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRlsResponse::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Destination Status Code = " << m_destinationStatusCode;
<   if (m_insertRelayStatus)
<      os << ", Relay Status Code = " <<  m_relayStatusCode;
< }
< 
< uint32_t
< ExtRlsResponse::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 2; //Destination Status Code
<   if (m_insertRelayStatus)
<     size += 2; //Relay Status Code
< 
<   return size;
< }
< 
< void
< ExtRlsResponse::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_destinationStatusCode);
< 
<   if (m_insertRelayStatus)
<     i.WriteHtolsbU16 (m_relayStatusCode);
< }
< 
< uint32_t
< ExtRlsResponse::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   m_destinationStatusCode = i.ReadLsbtohU16 ();
< 
<   if (!i.IsEnd ())
<     m_relayStatusCode = i.ReadLsbtohU16 ();
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRlsResponse::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtRlsResponse::SetDestinationStatusCode (uint16_t status)
< {
<   m_destinationStatusCode = status;
< }
< 
< void
< ExtRlsResponse::SetRelayStatusCode (uint16_t status)
< {
<   m_insertRelayStatus = true;
<   m_relayStatusCode = status;
< }
< 
< uint8_t
< ExtRlsResponse::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< ExtRlsResponse::GetDestinationStatusCode (void) const
< {
<   return m_destinationStatusCode;
< }
< 
< uint16_t
< ExtRlsResponse::GetRelayStatusCode (void) const
< {
<   return m_relayStatusCode;
< }
< 
< /***************************************************
< *        Relay Link Setup Announcment 8.5.20.16
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRlsAnnouncment);
< 
< ExtRlsAnnouncment::ExtRlsAnnouncment ()
<   : m_status (0)
< {
< }
< 
< TypeId
< ExtRlsAnnouncment::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRlsAnnouncment")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRlsAnnouncment> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRlsAnnouncment::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRlsAnnouncment::Print (std::ostream &os) const
< {
<   os << "Status Code = " << m_status
<      << ", Destination AID = " << m_destinationAid
<      << ", Relay AID = " <<  m_relayAid
<      << ", Source AID = " <<  m_sourceAid;
< }
< 
< uint32_t
< ExtRlsAnnouncment::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 2; //Status Code
<   size += ExtRlsFrame::GetSerializedSize ();
<   return size;
< }
< 
< void
< ExtRlsAnnouncment::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteHtolsbU16 (m_status);
<   i.WriteHtolsbU16 (m_destinationAid);
<   i.WriteHtolsbU16 (m_relayAid);
<   i.WriteHtolsbU16 (m_sourceAid);
< }
< 
< uint32_t
< ExtRlsAnnouncment::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_status = i.ReadLsbtohU16 ();
<   m_destinationAid = i.ReadLsbtohU16 ();
<   m_relayAid = i.ReadLsbtohU16 ();
<   m_sourceAid = i.ReadLsbtohU16 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRlsAnnouncment::SetStatusCode (uint16_t status)
< {
<   m_status = status;
< }
< 
< uint16_t
< ExtRlsAnnouncment::GetStatusCode (void) const
< {
<   return m_status;
< }
< 
< /***************************************************
< *        Relay Link Setup Teardown 8.5.20.17
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRlsTearDown);
< 
< ExtRlsTearDown::ExtRlsTearDown ()
<   : m_reasonCode (0)
< {
< }
< 
< TypeId
< ExtRlsTearDown::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRlsTearDown")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRlsTearDown> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRlsTearDown::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtRlsTearDown::Print (std::ostream &os) const
< {
<   os << "Destination AID = " << m_destinationAid
<      << ", Relay AID = " <<  m_relayAid
<      << ", Source AID = " <<  m_sourceAid
<      << ", Reason Code = " << m_reasonCode;
< }
< 
< uint32_t
< ExtRlsTearDown::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += ExtRlsFrame::GetSerializedSize ();
<   size += 2; //Reason Code
< 
<   return size;
< }
< 
< void
< ExtRlsTearDown::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteHtolsbU16 (m_destinationAid);
<   i.WriteHtolsbU16 (m_relayAid);
<   i.WriteHtolsbU16 (m_sourceAid);
<   i.WriteHtolsbU16 (m_reasonCode);
< }
< 
< uint32_t
< ExtRlsTearDown::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_destinationAid = i.ReadLsbtohU16 ();
<   m_relayAid = i.ReadLsbtohU16 ();
<   m_sourceAid = i.ReadLsbtohU16 ();
<   m_reasonCode = i.ReadLsbtohU16 ();
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtRlsTearDown::SetReasonCode (uint16_t reason)
< {
<   m_reasonCode = reason;
< }
< 
< uint16_t
< ExtRlsTearDown::GetReasonCode (void) const
< {
<   return m_reasonCode;
< }
< 
< /***************************************************
< *          Relay Ack Request 8.5.20.18
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRelayAckRequest);
< 
< TypeId
< ExtRelayAckRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRelayAckRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRelayAckRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRelayAckRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< /***************************************************
< *          Relay Ack Response 8.5.20.19
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtRelayAckResponse);
< 
< TypeId
< ExtRelayAckResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtRelayAckResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtRelayAckResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtRelayAckResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< /*************************************************************
< * Transmission Time-Point Adjustment Request frame 8.5.20.20
< **************************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtTpaRequest);
< 
< ExtTpaRequest::ExtTpaRequest ()
<   : m_dialogToken (0),
<     m_timingOffset (0),
<     m_samplingOffset (0)
< {
< }
< 
< TypeId
< ExtTpaRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtTpaRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtTpaRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtTpaRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtTpaRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Timing Offset = " << m_timingOffset
<      << ", Sampling Frequency Offset = " <<  m_samplingOffset;
< }
< 
< uint32_t
< ExtTpaRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 2; //Timing Offset
<   size += 2; //Sampling Frequency Offset
< 
<   return size;
< }
< 
< void
< ExtTpaRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_timingOffset);
<   i.WriteHtolsbU16 (m_samplingOffset);
< }
< 
< uint32_t
< ExtTpaRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   m_timingOffset = i.ReadLsbtohU16 ();
<   m_samplingOffset = i.ReadLsbtohU16 ();
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtTpaRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtTpaRequest::SetTimingOffset (uint16_t offset)
< {
<   m_timingOffset = offset;
< }
< 
< void
< ExtTpaRequest::SetSamplingFrequencyOffset (uint16_t offset)
< {
<   m_samplingOffset = offset;
< }
< 
< uint8_t
< ExtTpaRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint16_t
< ExtTpaRequest::GetTimingOffset (void) const
< {
<   return m_timingOffset;
< }
< 
< uint16_t
< ExtTpaRequest::GetSamplingFrequencyOffset (void) const
< {
<   return m_samplingOffset;
< }
< 
< /*************************************************************
< *            Fast Session Transfer Setup Frame
< **************************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstSetupFrame);
< 
< ExtFstSetupFrame::ExtFstSetupFrame ()
< {
< }
< 
< void
< ExtFstSetupFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtFstSetupFrame::SetSessionTransition (SessionTransitionElement &elem)
< {
<   m_sessionTransition = elem;
< }
< 
< void
< ExtFstSetupFrame::SetMultiBand (Ptr<MultiBandElement> elem)
< {
<   m_multiBand = elem;
< }
< 
< void
< ExtFstSetupFrame::SetWakeupSchedule (Ptr<WakeupScheduleElement> elem)
< {
<   m_wakeupSchedule = elem;
< }
< 
< void
< ExtFstSetupFrame::SetAwakeWindow (Ptr<AwakeWindowElement> elem)
< {
<   m_awakeWindow = elem;
< }
< 
< void
< ExtFstSetupFrame::SetSwitchingStream (Ptr<SwitchingStreamElement> elem)
< {
<   m_switchingStream = elem;
< }
< 
< uint8_t
< ExtFstSetupFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< SessionTransitionElement
< ExtFstSetupFrame::GetSessionTransition (void) const
< {
<   return m_sessionTransition;
< }
< 
< Ptr<MultiBandElement>
< ExtFstSetupFrame::GetMultiBand (void) const
< {
<   return m_multiBand;
< }
< 
< Ptr<WakeupScheduleElement>
< ExtFstSetupFrame::GetWakeupSchedule (void) const
< {
<   return m_wakeupSchedule;
< }
< 
< Ptr<AwakeWindowElement>
< ExtFstSetupFrame::GetAwakeWindow (void) const
< {
<   return m_awakeWindow;
< }
< 
< Ptr<SwitchingStreamElement>
< ExtFstSetupFrame::GetSwitchingStream (void) const
< {
<   return m_switchingStream;
< }
< 
< /*************************************************************
< *       Fast Session Transfer Request 8.5.21.2
< **************************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstSetupRequest);
< 
< ExtFstSetupRequest::ExtFstSetupRequest ()
< {
<   m_dialogToken = 0;
<   m_llt = 0;
< }
< 
< TypeId
< ExtFstSetupRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstSetupRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstSetupRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstSetupRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtFstSetupRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", LLT = " << m_llt;
< }
< 
< uint32_t
< ExtFstSetupRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 4; //LLT
<   size += m_sessionTransition.GetSerializedSize ();
<   if (m_multiBand != 0)
<     size += m_multiBand->GetSerializedSize ();
<   if (m_wakeupSchedule != 0)
<     size += m_wakeupSchedule->GetSerializedSize ();
<   if (m_awakeWindow != 0)
<     size += m_awakeWindow->GetSerializedSize ();
<   if (m_switchingStream != 0)
<     size += m_switchingStream->GetSerializedSize ();
< 
<   return size;
< }
< 
< void
< ExtFstSetupRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU32 (m_llt);
<   i = m_sessionTransition.Serialize (i);
<   if (m_multiBand != 0)
<     {
<       i = m_multiBand->Serialize (i);
<     }
<   if (m_wakeupSchedule != 0)
<     {
<       i = m_wakeupSchedule->Serialize (i);
<     }
<   if (m_awakeWindow != 0)
<     {
<       i = m_awakeWindow->Serialize (i);
<     }
<   if (m_switchingStream != 0)
<     {
<       i = m_switchingStream->Serialize (i);
<     }
< }
< 
< uint32_t
< ExtFstSetupRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   m_llt = i.ReadLsbtohU32 ();
<   i = m_sessionTransition.Deserialize (i);
<   if (m_multiBand != 0)
<     {
<       i = m_multiBand->DeserializeIfPresent (i);
<     }
<   if (m_wakeupSchedule != 0)
<     {
<       i = m_wakeupSchedule->DeserializeIfPresent (i);
<     }
<   if (m_awakeWindow != 0)
<     {
<       i = m_awakeWindow->DeserializeIfPresent (i);
<     }
<   if (m_switchingStream != 0)
<     {
<       i = m_switchingStream->DeserializeIfPresent (i);
<     }
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtFstSetupRequest::SetLlt (uint32_t llt)
< {
<   m_llt = llt;
< }
< 
< uint32_t
< ExtFstSetupRequest::GetLlt (void) const
< {
<   return m_llt;
< }
< 
< /*************************************************************
< *          Fast Session Transfer Response 8.5.21.3
< **************************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstSetupResponse);
< 
< ExtFstSetupResponse::ExtFstSetupResponse ()
< {
<   m_dialogToken = 0;
<   m_statusCode = 0;
< }
< 
< TypeId
< ExtFstSetupResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstSetupResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstSetupResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstSetupResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtFstSetupResponse::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", Status Code = " << m_statusCode;
< }
< 
< uint32_t
< ExtFstSetupResponse::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
< 
<   size += 1; //Dialog Token
<   size += 2; //Status Code
<   size += m_sessionTransition.GetSerializedSize ();
<   if (m_multiBand != 0)
<     size += m_multiBand->GetSerializedSize ();
<   if (m_wakeupSchedule != 0)
<     size += m_wakeupSchedule->GetSerializedSize ();
<   if (m_awakeWindow != 0)
<     size += m_awakeWindow->GetSerializedSize ();
<   if (m_switchingStream != 0)
<     size += m_switchingStream->GetSerializedSize ();
< 
<   return size;
< }
< 
< void
< ExtFstSetupResponse::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
< 
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU16 (m_statusCode);
<   i = m_sessionTransition.Serialize (i);
<   if (m_multiBand != 0)
<     i = m_multiBand->Serialize (i);
<   if (m_wakeupSchedule != 0)
<     i = m_wakeupSchedule->Serialize (i);
<   if (m_awakeWindow != 0)
<     i = m_awakeWindow->Serialize (i);
<   if (m_switchingStream != 0)
<     i = m_switchingStream->Serialize (i);
< }
< 
< uint32_t
< ExtFstSetupResponse::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
< 
<   m_dialogToken = i.ReadU8 ();
<   m_statusCode = i.ReadLsbtohU16 ();
<   i = m_sessionTransition.Deserialize (i);
<   if (m_multiBand != 0)
<     {
<       i = m_multiBand->DeserializeIfPresent (i);
<     }
<   if (m_wakeupSchedule != 0)
<     {
<       i = m_wakeupSchedule->DeserializeIfPresent (i);
<     }
<   if (m_awakeWindow != 0)
<     {
<       i = m_awakeWindow->DeserializeIfPresent (i);
<     }
<   if (m_switchingStream != 0)
<     {
<       i = m_switchingStream->DeserializeIfPresent (i);
<     }
< 
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtFstSetupResponse::SetStatusCode (uint16_t status)
< {
<   m_statusCode = status;
< }
< 
< uint16_t
< ExtFstSetupResponse::GetStatusCode (void) const
< {
<   return m_statusCode;
< }
< 
< /***************************************************
< *     Fast Session Transfer Tear Down 8.5.21.4
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstTearDown);
< 
< ExtFstTearDown::ExtFstTearDown ()
<   : m_fstsID (0)
< {
< }
< 
< TypeId
< ExtFstTearDown::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstTearDown")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstTearDown> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstTearDown::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtFstTearDown::Print (std::ostream &os) const
< {
<   os << "FSTS ID = " << m_fstsID;
< }
< 
< uint32_t
< ExtFstTearDown::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 4; //FSTS ID
<   return size;
< }
< 
< void
< ExtFstTearDown::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteHtolsbU32 (m_fstsID);
< }
< 
< uint32_t
< ExtFstTearDown::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_fstsID = i.ReadLsbtohU32 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtFstTearDown::SetFstsID (uint32_t id)
< {
<   m_fstsID = id;
< }
< 
< uint32_t
< ExtFstTearDown::GetFstsID (void) const
< {
<   return m_fstsID;
< }
< 
< /***************************************************
< *     Fast Session Transfer Ack Request 8.5.21.5
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstAckRequest);
< 
< ExtFstAckRequest::ExtFstAckRequest ()
<   : m_dialogToken (0),
<     m_fstsID (0)
< {
< }
< 
< TypeId
< ExtFstAckRequest::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstAckRequest")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstAckRequest> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstAckRequest::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtFstAckRequest::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken
<      << ", FSTS ID = " << m_fstsID;
< }
< 
< uint32_t
< ExtFstAckRequest::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += 4; //FSTS ID
<   return size;
< }
< 
< void
< ExtFstAckRequest::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i.WriteHtolsbU32 (m_fstsID);
< }
< 
< uint32_t
< ExtFstAckRequest::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   m_fstsID = i.ReadLsbtohU32 ();
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtFstAckRequest::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtFstAckRequest::SetFstsID (uint32_t id)
< {
<   m_fstsID = id;
< }
< 
< uint8_t
< ExtFstAckRequest::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< uint32_t
< ExtFstAckRequest::GetFstsID (void) const
< {
<   return m_fstsID;
< }
< 
< /***************************************************
< *     Fast Session Transfer Ack Response 8.5.21.6
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtFstAckResponse);
< 
< TypeId
< ExtFstAckResponse::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtFstAckResponse")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtFstAckResponse> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtFstAckResponse::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< /***************************************************
< *             Announce Frame (8.5.22.2)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtAnnounceFrame);
< 
< ExtAnnounceFrame::ExtAnnounceFrame ()
<   : m_timestamp (0),
<     m_beaconInterval (0)
< {
< }
< 
< TypeId
< ExtAnnounceFrame::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtAnnounceFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtAnnounceFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtAnnounceFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtAnnounceFrame::Print (std::ostream &os) const
< {
<   os << "Timestamp = " << m_timestamp << "|"
<      << "BeaconInterval = " << m_beaconInterval;
<   PrintInformationElements (os);
< }
< 
< uint32_t
< ExtAnnounceFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Timestamp
<   size += 2; //Beacon Interval
<   size += GetInformationElementsSerializedSize ();
<   return size;
< }
< 
< void
< ExtAnnounceFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_timestamp);
<   i.WriteHtolsbU16 (m_beaconInterval);
<   i = SerializeInformationElements (i);
< }
< 
< uint32_t
< ExtAnnounceFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_timestamp = i.ReadU8 ();
<   m_beaconInterval = i.ReadLsbtohU16 ();
<   i = DeserializeInformationElements (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtAnnounceFrame::SetTimestamp (uint8_t timestamp)
< {
<   m_timestamp = timestamp;
< }
< 
< void
< ExtAnnounceFrame::SetBeaconInterval (uint16_t interval)
< {
<   m_beaconInterval = interval;
< }
< 
< uint8_t
< ExtAnnounceFrame::GetTimestamp (void) const
< {
<   return m_timestamp;
< }
< 
< uint16_t
< ExtAnnounceFrame::GetBeaconInterval (void) const
< {
<   return m_beaconInterval;
< }
< 
< /***************************************************
< *               BRP Frame (8.5.22.3)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtBrpFrame);
< 
< ExtBrpFrame::ExtBrpFrame ()
< {
< }
< 
< TypeId
< ExtBrpFrame::GetTypeId ()
< {
<   static TypeId tid = TypeId ("ns3::ExtBrpFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtBrpFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtBrpFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtBrpFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtBrpFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_brpRequestField.GetSerializedSize ();
<   size += m_beamRefinementElement.GetSerializedSize ();
<   for (ChannelMeasurementFeedbackElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       size += (*iter)->GetSerializedSize ();
<     }
<   if (m_partialSlsElement != 0)
<     size += m_partialSlsElement->GetSerializedSize ();
<   if (m_edmgBrpRequestElement != 0)
<     size += m_edmgBrpRequestElement->GetSerializedSize ();
<   for (EDMGChannelMeasurementFeedbackElementList::const_iterator iter = m_edmgList.begin (); iter != m_edmgList.end (); iter++)
<     {
<       size += (*iter)->GetSerializedSize ();
<     }
< 
<   return size;
< }
< 
< void
< ExtBrpFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_brpRequestField.Serialize (i);
<   i = m_beamRefinementElement.Serialize (i);
<   for (ChannelMeasurementFeedbackElementList::const_iterator iter = m_list.begin (); iter != m_list.end (); iter++)
<     {
<       i = (*iter)->Serialize (i);
<     }
<   if (m_partialSlsElement != 0)
<     i = m_partialSlsElement->Serialize (i);
<   if (m_edmgBrpRequestElement != 0)
<     i = m_edmgBrpRequestElement->Serialize (i);
<   for (EDMGChannelMeasurementFeedbackElementList::const_iterator iter = m_edmgList.begin (); iter != m_edmgList.end (); iter++)
<     {
<       i = (*iter)->Serialize (i);
<     }
< }
< 
< uint32_t
< ExtBrpFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Buffer::Iterator m;
< 
<   m_dialogToken = i.ReadU8 ();
<   i = m_brpRequestField.Deserialize (i);
<   i = m_beamRefinementElement.Deserialize (i);
< 
<   uint16_t numberOfMeasurements;
<   uint16_t currentMeasurements;
< 
<   /* Calculate the limit of the number of measurements that can fit within a single Channel Measurement/ EDMG Channel Measurement feedback element,
<    * considering that each information element has a maximum size of 255 bytes. */
< 
<   // Calculate the size of a single measurement according to the fields that are present
<   uint8_t channelMeasurementSize = 0;
<   uint8_t edmgChannelMeasurementSize = 0;
< 
<   if (m_beamRefinementElement.IsSnrPresent ())
<     channelMeasurementSize += 1;
<   if (m_beamRefinementElement.IsChannelMeasurementPresent ())
<     {
<       uint8_t tapSize;
<       switch (m_beamRefinementElement.GetNumberOfTapsPresent ()) {
<         case TAPS_1:
<           tapSize = 2;
<           break;
<         case TAPS_5:
<           tapSize = 5 * 2;
<           break;
<         case TAPS_15:
<           tapSize = 15 * 2;
<           break;
<         case TAPS_63:
<           tapSize = 63 * 2;
<           break;
<         default:
<           NS_FATAL_ERROR ("Value for Number of Taps present is not allowed");
<           break;
<         }
<       channelMeasurementSize += tapSize;
<     }
<   if (m_beamRefinementElement.IsSectorIdOrderPresent ())
<     {
<       if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<         edmgChannelMeasurementSize += 3;
<       else
<         channelMeasurementSize += 1;
<     }
<   if (m_beamRefinementElement.GetSectorSweepFrameType () == BRP_FRAME && m_beamRefinementElement.GetEdmgExtensionFlag ())
<     edmgChannelMeasurementSize += 1;
< 
<   // Calculate the additional space taken within the element by other fields
<   uint8_t channelAdditionalSize = 2;
<   uint8_t edmgChannelAdditionalSize = 0;
< 
<   if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<     edmgChannelAdditionalSize += 3;
< 
<   if (m_beamRefinementElement.IsTapDelayPresent ())
<     {
<       uint8_t tapSize;
<       switch (m_beamRefinementElement.GetNumberOfTapsPresent ()) {
<         case TAPS_1:
<           tapSize = 1;
<           break;
<         case TAPS_5:
<           tapSize = 5;
<           break;
<         case TAPS_15:
<           tapSize = 15;
<           break;
<         case TAPS_63:
<           tapSize = 63;
<           break;
<         default:
<           NS_FATAL_ERROR ("Value for Number of Taps present is not allowed");
<           break;
<         }
<       if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<         edmgChannelAdditionalSize += (tapSize * 2);
<       else
<         channelAdditionalSize += (tapSize * 1);
<     }
< 
<   // Calculate the maximum number of measurements within one element (Note: for simplicity we assume that we have the same number of channel and
<   // EDMG channel measurement feedback elements, so we calculate this according to the element that fits less measurements)
<   uint8_t maxMeasurements = 0;
<   if (channelMeasurementSize > 0)
<     {
<       maxMeasurements = (255 - channelAdditionalSize) / channelMeasurementSize;
<     }
<   if (edmgChannelMeasurementSize > 0)
<     {
<       uint8_t edmgMaxMeasurements = (255 - edmgChannelAdditionalSize) / edmgChannelMeasurementSize;
<       if (edmgMaxMeasurements < maxMeasurements)
<         maxMeasurements = edmgMaxMeasurements;
<     }
< 
<   // Deserialize the channel/EDMG channel measurement feedback elements
<   if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<     {
<       numberOfMeasurements = m_beamRefinementElement.GetExtendedNumberOfMeasurements ();
<     }
<   else
<     {
<       numberOfMeasurements = m_beamRefinementElement.GetNumberOfMeasurements ();
<     }
< 
<   /* Deserialize Channel Measurement Feedback Elements */
<   while (numberOfMeasurements != 0)
<     {
<       Ptr<ChannelMeasurementFeedbackElement> channelMeasurement = Create<ChannelMeasurementFeedbackElement> ();
<       if (numberOfMeasurements > maxMeasurements)
<         currentMeasurements = maxMeasurements;
<       else
<         currentMeasurements = numberOfMeasurements;
<       numberOfMeasurements -= currentMeasurements;
<       if (m_beamRefinementElement.IsSnrPresent ())
<         {
<           channelMeasurement->SetSnrListSize (currentMeasurements);
<         }
<       if (m_beamRefinementElement.IsChannelMeasurementPresent ())
<         {
<           channelMeasurement->SetChannelMeasurementSize (currentMeasurements);
<           channelMeasurement->SetTapComponentsSize (m_beamRefinementElement.GetNumberOfTapsPresent ());
<         }
<       if (m_beamRefinementElement.IsTapDelayPresent () && (!m_beamRefinementElement.GetEdmgExtensionFlag ()))
<         {
<            channelMeasurement->SetTapsDelaySize (m_beamRefinementElement.GetNumberOfTapsPresent ());
<         }
<       if (m_beamRefinementElement.IsSectorIdOrderPresent ()  && (!m_beamRefinementElement.GetEdmgExtensionFlag ()))
<         {
<            channelMeasurement->SetSectorIdSize (currentMeasurements);
<         }
<      m = i;
<      i = channelMeasurement->DeserializeIfPresent (i);
<      if (i.GetDistanceFrom (m) != 0)
<        {
<          m_list.push_back (channelMeasurement);
<        }
<      else
<        {
<          break;
<        }
<    }
< 
<   m_partialSlsElement = Create<EdmgPartialSectorLevelSweep> ();
<   i = m_partialSlsElement->DeserializeIfPresent (i);
<   m_edmgBrpRequestElement = Create<EdmgBrpRequestElement> ();
<   i = m_edmgBrpRequestElement->DeserializeIfPresent (i);
<   /* Deserialize EDMG Channel Measurement Feedback Elements */
<   if (m_beamRefinementElement.GetEdmgExtensionFlag ())
<     {
<       numberOfMeasurements = m_beamRefinementElement.GetExtendedNumberOfMeasurements ();
<       while (numberOfMeasurements != 0)
<         {
<           Ptr<EDMGChannelMeasurementFeedbackElement> edmgChannelMeasurement = Create<EDMGChannelMeasurementFeedbackElement> ();
<           if (numberOfMeasurements > maxMeasurements)
<             currentMeasurements = maxMeasurements;
<           else
<             currentMeasurements = numberOfMeasurements;
<           numberOfMeasurements -= currentMeasurements;
<           if (m_beamRefinementElement.IsTapDelayPresent ())
<             {
<                edmgChannelMeasurement->SetTapsDelaySize (m_beamRefinementElement.GetNumberOfTapsPresent ());
<             }
<           if (m_beamRefinementElement.IsSectorIdOrderPresent ())
<             {
<                edmgChannelMeasurement->SetSectorIdOrderSize (currentMeasurements);
<             }
<          if (m_beamRefinementElement.GetSectorSweepFrameType () == BRP_FRAME)
<            {
<              edmgChannelMeasurement->SetBrpCdownSize (currentMeasurements);
<            }
<          m = i;
<          i = edmgChannelMeasurement->DeserializeIfPresent (i);
<          if (i.GetDistanceFrom (m) != 0)
<            {
<              m_edmgList.push_back (edmgChannelMeasurement);
<            }
<          else
<            {
<              break;
<            }
<         }
<     }
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtBrpFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtBrpFrame::SetBrpRequestField (BRP_Request_Field &field)
< {
<   m_brpRequestField = field;
< }
< 
< void
< ExtBrpFrame::SetBeamRefinementElement (BeamRefinementElement &element)
< {
<   m_beamRefinementElement = element;
< }
< 
< void
< ExtBrpFrame::AddChannelMeasurementFeedback (ChannelMeasurementFeedbackElement *element)
< {
<   m_list.push_back (element);
< }
< 
< 
< void
< ExtBrpFrame::SetEdmgPartialSlsElement (EdmgPartialSectorLevelSweep *element)
< {
<   m_partialSlsElement = element;
< }
< 
< void
< ExtBrpFrame::SetEdmgBrpRequestElement (EdmgBrpRequestElement *element)
< {
<   m_edmgBrpRequestElement = element;
< }
< 
< void
< ExtBrpFrame::AddEdmgChannelMeasurementFeedback (EDMGChannelMeasurementFeedbackElement *element)
< {
<   m_edmgList.push_back (element);
< }
< 
< uint8_t
< ExtBrpFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< BRP_Request_Field
< ExtBrpFrame::GetBrpRequestField (void) const
< {
<   return m_brpRequestField;
< }
< 
< BeamRefinementElement
< ExtBrpFrame::GetBeamRefinementElement (void) const
< {
<   return m_beamRefinementElement;
< }
< 
< ChannelMeasurementFeedbackElementList
< ExtBrpFrame::GetChannelMeasurementFeedbackList (void) const
< {
<   return m_list;
< }
< 
< Ptr<EdmgPartialSectorLevelSweep>
< ExtBrpFrame::GetEdmgPartialSlsElement (void) const
< {
<   return m_partialSlsElement;
< }
< 
< Ptr<EdmgBrpRequestElement>
< ExtBrpFrame::GetEdmgBrpRequestElement(void) const
< {
<   return m_edmgBrpRequestElement;
< }
< 
< EDMGChannelMeasurementFeedbackElementList
< ExtBrpFrame::GetEdmgChannelMeasurementFeedbackList (void) const
< {
<   return m_edmgList;
< }
< 
< 
< /***************************************************
< *          MIMO BF Setup frame (9.6.21.4)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMimoBfSetupFrame);
< 
< ExtMimoBfSetupFrame::ExtMimoBfSetupFrame ()
< {
< }
< 
< TypeId
< ExtMimoBfSetupFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::ExtMimoBfSetupFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMimoBfSetupFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMimoBfSetupFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMimoBfSetupFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMimoBfSetupFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_mimoSetupControl.GetSerializedSize ();
<   return size;
< }
< 
< void
< ExtMimoBfSetupFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_mimoSetupControl.Serialize (i);
< }
< 
< uint32_t
< ExtMimoBfSetupFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_mimoSetupControl.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMimoBfSetupFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMimoBfSetupFrame::SetMimoSetupControlElement (MimoSetupControlElement element)
< {
<   m_mimoSetupControl = element;
< }
< 
< uint8_t
< ExtMimoBfSetupFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< MimoSetupControlElement
< ExtMimoBfSetupFrame::GetMimoSetupControlElement (void) const
< {
<   return m_mimoSetupControl;
< }
< 
< /***************************************************
< *          MIMO BF Poll frame (9.6.21.5)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMimoBfPollFrame);
< 
< ExtMimoBfPollFrame::ExtMimoBfPollFrame ()
< {
< }
< 
< TypeId
< ExtMimoBfPollFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::ExtMimoBfPollFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMimoBfPollFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMimoBfPollFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMimoBfPollFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMimoBfPollFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_mimoPollControl.GetSerializedSize ();
<   return size;
< }
< 
< void
< ExtMimoBfPollFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_mimoPollControl.Serialize (i);
< }
< 
< uint32_t
< ExtMimoBfPollFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_mimoPollControl.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMimoBfPollFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMimoBfPollFrame::SetMimoPollControlElement (MimoPollControlElement element)
< {
<   m_mimoPollControl = element;
< }
< 
< uint8_t
< ExtMimoBfPollFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< MimoPollControlElement
< ExtMimoBfPollFrame::GetMimoSetupControlElement (void) const
< {
<   return m_mimoPollControl;
< }
< 
< /***************************************************
< *          MIMO BF Feedback frame (9.6.21.6)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMimoBfFeedbackFrame);
< 
< ExtMimoBfFeedbackFrame::ExtMimoBfFeedbackFrame ()
< {
< }
< 
< TypeId
< ExtMimoBfFeedbackFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::ExtMimoBfFeedbackFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMimoBfFeedbackFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMimoBfFeedbackFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMimoBfFeedbackFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMimoBfFeedbackFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_mimoFeedbackControl.GetSerializedSize ();
<   for (ChannelMeasurementFeedbackElementListCI it = m_channelMeasurementFeedbackList.begin ();
<        it != m_channelMeasurementFeedbackList.end (); it++)
<     {
<       size += (*it)->GetSerializedSize ();
<     }
<   for (EDMGChannelMeasurementFeedbackElementListCI it = m_edmgChannelMeasurementFeedbackList.begin ();
<        it != m_edmgChannelMeasurementFeedbackList.end (); it++)
<     {
<       size += (*it)->GetSerializedSize ();
<     }
<   for (DigitalBFFeedbackElementListCI it = m_digitalBFFeedbackElementList.begin ();
<        it != m_digitalBFFeedbackElementList.end (); it++)
<     {
<       size += (*it)->GetSerializedSize ();
<     }
<   return size;
< }
< 
< void
< ExtMimoBfFeedbackFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   /* Serialize MIMO Feedback Control element */
<   i = m_mimoFeedbackControl.Serialize (i);
< 
<   /* Serialize Channel Measurement Feedback elements */
<   for (ChannelMeasurementFeedbackElementListCI it = m_channelMeasurementFeedbackList.begin ();
<        it != m_channelMeasurementFeedbackList.end (); it++)
<     {
<       i = (*it)->Serialize (i);
<     }
< 
<   /* Serialize EDMG Channel Measurement Feedback elements */
<   for (EDMGChannelMeasurementFeedbackElementListCI it = m_edmgChannelMeasurementFeedbackList.begin ();
<        it != m_edmgChannelMeasurementFeedbackList.end (); it++)
<     {
<       i = (*it)->Serialize (i);
<     }
< 
<   /* Serialize Digital BF Feedback elements */
<   for (DigitalBFFeedbackElementListCI it = m_digitalBFFeedbackElementList.begin ();
<        it != m_digitalBFFeedbackElementList.end (); it++)
<     {
<       i = (*it)->Serialize (i);
<     }
< }
< 
< uint32_t
< ExtMimoBfFeedbackFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   Buffer::Iterator m;
< 
<   m_dialogToken = i.ReadU8 ();
<   i = m_mimoFeedbackControl.Deserialize (i);
< 
<   uint8_t channelMeasurementSize = 1;
<   uint8_t edmgChannelMeasurementSize = 4;
<   if (m_mimoFeedbackControl.IsChannelMeasurementPresent ())
<     {
<       uint8_t tapSize;
<       switch (m_mimoFeedbackControl.GetNumberOfTapsPresent ()) {
<         case TAPS_1:
<           tapSize = 2;
<           break;
<         case TAPS_5:
<           tapSize = 5 * 2;
<           break;
<         case TAPS_15:
<           tapSize = 15 * 2;
<           break;
<         case TAPS_63:
<           tapSize = 63 * 2;
<           break;
<         default:
<           NS_FATAL_ERROR ("Value for Number of Taps present is not allowed");
<           break;
<         }
<       channelMeasurementSize += tapSize;
<     }
< 
<   // Calculate the additional space taken within the element by other fields
<   uint8_t channelAdditionalSize = 2;
<   uint8_t edmgChannelAdditionalSize = 3;
< 
<   if (m_mimoFeedbackControl.IsTapDelayPresent ())
<     {
<       uint8_t tapSize;
<       switch (m_mimoFeedbackControl.GetNumberOfTapsPresent ()) {
<         case TAPS_1:
<           tapSize = 1 * 2;
<           break;
<         case TAPS_5:
<           tapSize = 5 * 2;
<           break;
<         case TAPS_15:
<           tapSize = 15 * 2;
<           break;
<         case TAPS_63:
<           tapSize = 63 * 2;
<           break;
<         default:
<           NS_FATAL_ERROR ("Value for Number of Taps present is not allowed");
<           break;
<         }
<         edmgChannelAdditionalSize += tapSize;
<     }
< 
<   // Calculate the maximum number of measurements within one element (Note: for simplicity we assume that we have the same number of channel and
<   // EDMG channel measurement feedback elements, so we calculate this according to the element that fits less measurements)
<   uint8_t maxMeasurements = (255 - channelAdditionalSize) / channelMeasurementSize;
<   uint8_t edmgMaxMeasurements = (255 - edmgChannelAdditionalSize) / edmgChannelMeasurementSize;
<   if (edmgMaxMeasurements < maxMeasurements)
<      maxMeasurements = edmgMaxMeasurements;
< 
<   // Deserialize the channel/EDMG channel measurement feedback elements
<   uint8_t rxAntennas = m_mimoFeedbackControl.GetNumberOfRxAntennas ();
<   uint8_t txAntennas = m_mimoFeedbackControl.GetNumberOfTxAntennas ();
<   uint16_t numberOfMeasurements = m_mimoFeedbackControl.GetNumberOfTXSectorCombinationsPresent ()
<           * rxAntennas * txAntennas;
<   uint8_t currentMeasurements = 0;
<   /* Deserialize Channel Measurement Feedback Elements */
<   while (numberOfMeasurements != 0)
<     {
<       Ptr<ChannelMeasurementFeedbackElement> channelMeasurement = Create<ChannelMeasurementFeedbackElement> ();
<       if (numberOfMeasurements > maxMeasurements)
<         currentMeasurements = (maxMeasurements / ( txAntennas * rxAntennas )) * (txAntennas * rxAntennas);
<       else
<         currentMeasurements = numberOfMeasurements;
<       numberOfMeasurements -= currentMeasurements;
<       channelMeasurement->SetSnrListSize (currentMeasurements);
<       if (m_mimoFeedbackControl.IsChannelMeasurementPresent ())
<         {
<           channelMeasurement->SetChannelMeasurementSize (currentMeasurements);
<           channelMeasurement->SetTapComponentsSize (m_mimoFeedbackControl.GetNumberOfTapsPresent ());
<         }
<      m = i;
<      i = channelMeasurement->DeserializeIfPresent (i);
<      if (i.GetDistanceFrom (m) != 0)
<        {
<          m_channelMeasurementFeedbackList.push_back (channelMeasurement);
<        }
<      else
<        {
<          break;
<        }
<    }
<   /* Deserialize EDMG Channel Measurement Feedback Elements */
<   numberOfMeasurements = m_mimoFeedbackControl.GetNumberOfTXSectorCombinationsPresent ()
<           * m_mimoFeedbackControl.GetNumberOfRxAntennas ()
<           * m_mimoFeedbackControl.GetNumberOfTxAntennas ();
<   currentMeasurements = 0;
<   while (numberOfMeasurements != 0)
<     {
<       Ptr<EDMGChannelMeasurementFeedbackElement> edmgChannelMeasurement = Create<EDMGChannelMeasurementFeedbackElement> ();
< 
<       if (numberOfMeasurements > maxMeasurements)
<         currentMeasurements = (maxMeasurements / ( txAntennas * rxAntennas )) * (txAntennas * rxAntennas);
<       else
<          currentMeasurements = numberOfMeasurements;
<       numberOfMeasurements -= currentMeasurements;
<       if (m_mimoFeedbackControl.IsTapDelayPresent ())
<          {
<            edmgChannelMeasurement->SetTapsDelaySize (m_mimoFeedbackControl.GetNumberOfTapsPresent ());
<          }
<       edmgChannelMeasurement->SetSectorIdOrderSize (currentMeasurements);
<       edmgChannelMeasurement->SetBrpCdownSize (currentMeasurements);
<       m = i;
<       i = edmgChannelMeasurement->DeserializeIfPresent (i);
<       if (i.GetDistanceFrom (m) != 0)
<         {
<            m_edmgChannelMeasurementFeedbackList.push_back (edmgChannelMeasurement);
<         }
<       else
<         {
<           break;
<         }
<     }
<   // To do: Add deserialization for Digital Feedback
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMimoBfFeedbackFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMimoBfFeedbackFrame::SetMimoFeedbackControlElement (MIMOFeedbackControl &element)
< {
<   m_mimoFeedbackControl = element;
< }
< 
< void
< ExtMimoBfFeedbackFrame::AddChannelMeasurementFeedbackElement (Ptr<ChannelMeasurementFeedbackElement> element)
< {
<   m_channelMeasurementFeedbackList.push_back (element);
< }
< 
< void
< ExtMimoBfFeedbackFrame::AddEdmgChannelMeasurementFeedbackElement (Ptr<EDMGChannelMeasurementFeedbackElement> element)
< {
<   m_edmgChannelMeasurementFeedbackList.push_back (element);
< }
< 
< void
< ExtMimoBfFeedbackFrame::AddDigitalBfFeedbackElement (Ptr<DigitalBFFeedbackElement> element)
< {
<   m_digitalBFFeedbackElementList.push_back (element);
< }
< 
< uint8_t
< ExtMimoBfFeedbackFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< MIMOFeedbackControl
< ExtMimoBfFeedbackFrame::GetMimoFeedbackControlElement (void) const
< {
<   return m_mimoFeedbackControl;
< }
< 
< ChannelMeasurementFeedbackElementList
< ExtMimoBfFeedbackFrame::GetListOfChannelMeasurementFeedback (void) const
< {
<   return m_channelMeasurementFeedbackList;
< }
< 
< EDMGChannelMeasurementFeedbackElementList
< ExtMimoBfFeedbackFrame::GetListOfEDMGChannelMeasurementFeedback (void) const
< {
<   return m_edmgChannelMeasurementFeedbackList;
< }
< 
< DigitalBFFeedbackElementList
< ExtMimoBfFeedbackFrame::GetListOfDigitalBFFeedbackElement (void) const
< {
<   return m_digitalBFFeedbackElementList;
< }
< 
< /***************************************************
< *          MIMO BF Poll frame (9.6.21.7)
< ****************************************************/
< 
< NS_OBJECT_ENSURE_REGISTERED (ExtMimoBFSelectionFrame);
< 
< ExtMimoBFSelectionFrame::ExtMimoBFSelectionFrame ()
< {
< }
< 
< TypeId
< ExtMimoBFSelectionFrame::GetTypeId (void)
< {
<   static TypeId tid = TypeId ("ns3::ExtMimoBFSelectionFrame")
<     .SetParent<Header> ()
<     .SetGroupName ("Wifi")
<     .AddConstructor<ExtMimoBFSelectionFrame> ()
<   ;
<   return tid;
< }
< 
< TypeId
< ExtMimoBFSelectionFrame::GetInstanceTypeId (void) const
< {
<   return GetTypeId ();
< }
< 
< void
< ExtMimoBFSelectionFrame::Print (std::ostream &os) const
< {
<   os << "Dialog Token = " << m_dialogToken;
< }
< 
< uint32_t
< ExtMimoBFSelectionFrame::GetSerializedSize (void) const
< {
<   uint32_t size = 0;
<   size += 1; //Dialog Token
<   size += m_mimoSelectionControlElement.GetSerializedSize ();
<   size += m_edmgGroupIDSetElement.GetSerializedSize ();
<   return size;
< }
< 
< void
< ExtMimoBFSelectionFrame::Serialize (Buffer::Iterator start) const
< {
<   Buffer::Iterator i = start;
<   i.WriteU8 (m_dialogToken);
<   i = m_mimoSelectionControlElement.Serialize (i);
<   i = m_edmgGroupIDSetElement.Serialize (i);
< }
< 
< uint32_t
< ExtMimoBFSelectionFrame::Deserialize (Buffer::Iterator start)
< {
<   Buffer::Iterator i = start;
<   m_dialogToken = i.ReadU8 ();
<   i = m_mimoSelectionControlElement.Deserialize (i);
<   i = m_edmgGroupIDSetElement.Deserialize (i);
<   return i.GetDistanceFrom (start);
< }
< 
< void
< ExtMimoBFSelectionFrame::SetDialogToken (uint8_t token)
< {
<   m_dialogToken = token;
< }
< 
< void
< ExtMimoBFSelectionFrame::SetMIMOSelectionControlElement (MIMOSelectionControlElement &element)
< {
<   m_mimoSelectionControlElement = element;
< }
< 
< void
< ExtMimoBFSelectionFrame::SetEDMGGroupIDSetElement (EDMGGroupIDSetElement &element)
< {
<   m_edmgGroupIDSetElement = element;
< }
< 
< uint8_t
< ExtMimoBFSelectionFrame::GetDialogToken (void) const
< {
<   return m_dialogToken;
< }
< 
< MIMOSelectionControlElement
< ExtMimoBFSelectionFrame::GetMIMOSelectionControlElement (void) const
< {
<   return m_mimoSelectionControlElement;
< }
< 
< EDMGGroupIDSetElement
< ExtMimoBFSelectionFrame::GetEDMGGroupIDSetElement (void) const
< {
<   return m_edmgGroupIDSetElement;
diff ../../NS3-WiGig/src/wifi/model/mgt-headers.h ../../ns-3-dev-git/src/wifi/model/mgt-headers.h
5d4
<  * Copyright (c) 2015-2020 IMDEA Networks Institute
22d20
<  *          Hany Assasa <hany.assasa@gmail.com>
28,30d25
< #include <stdint.h>
< 
< #include "ns3/header.h"
47,54d41
< //// WIGIG ////
< #include "common-header.h"
< #include "ctrl-headers.h"
< #include "dmg-capabilities.h"
< #include "dmg-information-elements.h"
< #include "ext-headers.h"
< #include "fields-headers.h"
< //// WIGIG ////
62c49
< class MgtAssocRequestHeader : public Header, public MgtFrame
---
> class MgtAssocRequestHeader : public Header
92a80,103
>    * Set the Extended Capabilities.
>    *
>    * \param extendedcapabilities the Extended Capabilities
>    */
>   void SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities);
>   /**
>    * Set the HT capabilities.
>    *
>    * \param htcapabilities HT capabilities
>    */
>   void SetHtCapabilities (HtCapabilities htcapabilities);
>   /**
>    * Set the VHT capabilities.
>    *
>    * \param vhtcapabilities VHT capabilities
>    */
>   void SetVhtCapabilities (VhtCapabilities vhtcapabilities);
>   /**
>    * Set the HE capabilities.
>    *
>    * \param hecapabilities HE capabilities
>    */
>   void SetHeCapabilities (HeCapabilities hecapabilities);
>   /**
98a110,133
>    * Return the extended capabilities.
>    *
>    * \return the extended capabilities
>    */
>   ExtendedCapabilities GetExtendedCapabilities (void) const;
>   /**
>    * Return the HT capabilities.
>    *
>    * \return HT capabilities
>    */
>   HtCapabilities GetHtCapabilities (void) const;
>   /**
>    * Return the VHT capabilities.
>    *
>    * \return VHT capabilities
>    */
>   VhtCapabilities GetVhtCapabilities (void) const;
>   /**
>    * Return the HE capabilities.
>    *
>    * \return HE capabilities
>    */
>   HeCapabilities GetHeCapabilities (void) const;
>   /**
132a168,171
>   ExtendedCapabilities m_extendedCapability; //!< Extended capabilities
>   HtCapabilities m_htCapability;      //!< HT capabilities
>   VhtCapabilities m_vhtCapability;    //!< VHT capabilities
>   HeCapabilities m_heCapability;      //!< HE capabilities
141c180
< class MgtReassocRequestHeader : public Header, public MgtFrame
---
> class MgtReassocRequestHeader : public Header
171a211,234
>    * Set the Extended Capabilities.
>    *
>    * \param extendedcapabilities the Extended Capabilities
>    */
>   void SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities);
>   /**
>    * Set the HT capabilities.
>    *
>    * \param htcapabilities HT capabilities
>    */
>   void SetHtCapabilities (HtCapabilities htcapabilities);
>   /**
>    * Set the VHT capabilities.
>    *
>    * \param vhtcapabilities VHT capabilities
>    */
>   void SetVhtCapabilities (VhtCapabilities vhtcapabilities);
>   /**
>    * Set the HE capabilities.
>    *
>    * \param hecapabilities HE capabilities
>    */
>   void SetHeCapabilities (HeCapabilities hecapabilities);
>   /**
177a241,264
>    * Return the extended capabilities.
>    *
>    * \return the extended capabilities
>    */
>   ExtendedCapabilities GetExtendedCapabilities (void) const;
>   /**
>    * Return the HT capabilities.
>    *
>    * \return HT capabilities
>    */
>   HtCapabilities GetHtCapabilities (void) const;
>   /**
>    * Return the VHT capabilities.
>    *
>    * \return VHT capabilities
>    */
>   VhtCapabilities GetVhtCapabilities (void) const;
>   /**
>    * Return the HE capabilities.
>    *
>    * \return HE capabilities
>    */
>   HeCapabilities GetHeCapabilities (void) const;
>   /**
218a306,309
>   ExtendedCapabilities m_extendedCapability; //!< Extended capabilities
>   HtCapabilities m_htCapability;      //!< HT capabilities
>   VhtCapabilities m_vhtCapability;    //!< VHT capabilities
>   HeCapabilities m_heCapability;      //!< HE capabilities
227c318
< class MgtAssocResponseHeader : public Header, public MgtFrame
---
> class MgtAssocResponseHeader : public Header
252c343,373
<    * Return the association ID.
---
>    * Return the extended capabilities.
>    *
>    * \return the extended capabilities
>    */
>   ExtendedCapabilities GetExtendedCapabilities (void) const;
>   /**
>    * Return the HT capabilities.
>    *
>    * \return HT capabilities
>    */
>   HtCapabilities GetHtCapabilities (void) const;
>   /**
>    * Return the HT operation.
>    *
>    * \return HT operation
>    */
>   HtOperation GetHtOperation (void) const;
>   /**
>    * Return the VHT capabilities.
>    *
>    * \return VHT capabilities
>    */
>   VhtCapabilities GetVhtCapabilities (void) const;
>   /**
>    * Return the VHT operation.
>    *
>    * \return VHT operation
>    */
>   VhtOperation GetVhtOperation (void) const;
>   /**
>    * Return the HE capabilities.
254c375
<    * \return the association ID
---
>    * \return HE capabilities
256c377,395
<   uint16_t GetAssociationId (void) const;
---
>   HeCapabilities GetHeCapabilities (void) const;
>   /**
>    * Return the HE operation.
>    *
>    * \return HE operation
>    */
>   HeOperation GetHeOperation (void) const;
>   /**
>    * Return the ERP information.
>    *
>    * \return the ERP information
>    */
>   ErpInformation GetErpInformation (void) const;
>   /**
>    * Return the EDCA Parameter Set.
>    *
>    * \return the EDCA Parameter Set
>    */
>   EdcaParameterSet GetEdcaParameterSet (void) const;
263a403,432
>    * Set the extended capabilities.
>    *
>    * \param extendedcapabilities the extended capabilities
>    */
>   void SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities);
>   /**
>    * Set the VHT operation.
>    *
>    * \param vhtoperation VHT operation
>    */
>   void SetVhtOperation (VhtOperation vhtoperation);
>   /**
>    * Set the VHT capabilities.
>    *
>    * \param vhtcapabilities VHT capabilities
>    */
>   void SetVhtCapabilities (VhtCapabilities vhtcapabilities);
>   /**
>    * Set the HT capabilities.
>    *
>    * \param htcapabilities HT capabilities
>    */
>   void SetHtCapabilities (HtCapabilities htcapabilities);
>   /**
>    * Set the HT operation.
>    *
>    * \param htoperation HT operation
>    */
>   void SetHtOperation (HtOperation htoperation);
>   /**
280a450,473
>   /**
>    * Set the ERP information.
>    *
>    * \param erpInformation the ERP information
>    */
>   void SetErpInformation (ErpInformation erpInformation);
>   /**
>    * Set the EDCA Parameter Set.
>    *
>    * \param edcaParameterSet the EDCA Parameter Set
>    */
>   void SetEdcaParameterSet (EdcaParameterSet edcaParameterSet);
>   /**
>    * Set the HE capabilities.
>    *
>    * \param hecapabilities HE capabilities
>    */
>   void SetHeCapabilities (HeCapabilities hecapabilities);
>   /**
>    * Set the HE operation.
>    *
>    * \param heoperation HE operation
>    */
>   void SetHeOperation (HeOperation heoperation);
295,298c488,500
<   SupportedRates m_rates;                   //!< List of supported rates
<   CapabilityInformation m_capability;       //!< Capability information
<   StatusCode m_code;                        //!< Status code
<   uint16_t m_aid;                           //!< Association Identifier.
---
>   SupportedRates m_rates; //!< List of supported rates
>   CapabilityInformation m_capability; //!< Capability information
>   StatusCode m_code; //!< Status code
>   uint16_t m_aid; //!< aid
>   ExtendedCapabilities m_extendedCapability; //!< extended capabilities
>   HtCapabilities m_htCapability; //!< HT capabilities
>   HtOperation m_htOperation; //!< HT operation
>   VhtCapabilities m_vhtCapability; //!< VHT capabilities
>   VhtOperation m_vhtOperation; //!< VHT operation
>   ErpInformation m_erpInformation; //!< ERP information
>   EdcaParameterSet m_edcaParameterSet; //!< EDCA Parameter Set
>   HeCapabilities m_heCapability; //!< HE capabilities
>   HeOperation m_heOperation; //!< HE operation
306c508
< class MgtProbeRequestHeader : public Header, public MgtFrame
---
> class MgtProbeRequestHeader : public Header
323a526,549
>    * Set the extended capabilities.
>    *
>    * \param extendedcapabilities the extended capabilities
>    */
>   void SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities);
>   /**
>    * Set the HT capabilities.
>    *
>    * \param htcapabilities HT capabilities
>    */
>   void SetHtCapabilities (HtCapabilities htcapabilities);
>   /**
>    * Set the VHT capabilities.
>    *
>    * \param vhtcapabilities VHT capabilities
>    */
>   void SetVhtCapabilities (VhtCapabilities vhtcapabilities);
>   /**
>    * Set the HE capabilities.
>    *
>    * \param hecapabilities HE capabilities
>    */
>   void SetHeCapabilities (HeCapabilities hecapabilities);
>   /**
334a561,584
>   /**
>    * Return the extended capabilities.
>    *
>    * \return the extended capabilities
>    */
>   ExtendedCapabilities GetExtendedCapabilities (void) const;
>   /**
>    * Return the HT capabilities.
>    *
>    * \return HT capabilities
>    */
>   HtCapabilities GetHtCapabilities (void) const;
>   /**
>    * Return the VHT capabilities.
>    *
>    * \return VHT capabilities
>    */
>   VhtCapabilities GetVhtCapabilities (void) const;
>   /**
>    * Return the HE capabilities.
>    *
>    * \return HE capabilities
>    */
>   HeCapabilities GetHeCapabilities (void) const;
350a601,604
>   ExtendedCapabilities m_extendedCapability; //!< extended capabilities
>   HtCapabilities m_htCapability;   //!< HT capabilities
>   VhtCapabilities m_vhtCapability; //!< VHT capabilities
>   HeCapabilities m_heCapability; //!< HE capabilities
358c612
< class MgtProbeResponseHeader : public Header, public MgtFrame
---
> class MgtProbeResponseHeader : public Header
365c619
<    * Set the beacon interval in microseconds unit.
---
>    * Return the Service Set Identifier (SSID).
367c621
<    * \param us beacon interval in microseconds unit
---
>    * \return SSID
369c623,707
<   void SetBeaconIntervalUs (uint64_t us);
---
>   Ssid GetSsid (void) const;
>   /**
>    * Return the beacon interval in microseconds unit.
>    *
>    * \return beacon interval in microseconds unit
>    */
>   uint64_t GetBeaconIntervalUs (void) const;
>   /**
>    * Return the supported rates.
>    *
>    * \return the supported rates
>    */
>   SupportedRates GetSupportedRates (void) const;
>   /**
>    * Return the Capability information.
>    *
>    * \return Capability information
>    */
>   CapabilityInformation GetCapabilities (void) const;
>   /**
>    * Return the DSSS Parameter Set.
>    *
>    * \return the DSSS Parameter Set
>    */
>   DsssParameterSet GetDsssParameterSet (void) const;
>   /**
>    * Return the extended capabilities.
>    *
>    * \return the extended capabilities
>    */
>   ExtendedCapabilities GetExtendedCapabilities (void) const;
>   /**
>    * Return the HT capabilities.
>    *
>    * \return HT capabilities
>    */
>   HtCapabilities GetHtCapabilities (void) const;
>   /**
>    * Return the HT operation.
>    *
>    * \return HT operation
>    */
>   HtOperation GetHtOperation (void) const;
>   /**
>    * Return the VHT capabilities.
>    *
>    * \return VHT capabilities
>    */
>   VhtCapabilities GetVhtCapabilities (void) const;
>   /**
>    * Return the VHT operation.
>    *
>    * \return VHT operation
>    */
>   VhtOperation GetVhtOperation (void) const;
>   /**
>    * Return the HE capabilities.
>    *
>    * \return HE capabilities
>    */
>   HeCapabilities GetHeCapabilities (void) const;
>   /**
>    * Return the HE operation.
>    *
>    * \return HE operation
>    */
>   HeOperation GetHeOperation (void) const;
>   /**
>    * Return the ERP information.
>    *
>    * \return the ERP information
>    */
>   ErpInformation GetErpInformation (void) const;
>   /**
>    * Return the EDCA Parameter Set.
>    *
>    * \return the EDCA Parameter Set
>    */
>   EdcaParameterSet GetEdcaParameterSet (void) const;
>   /**
>    * Return the CF parameter set.
>    *
>    * \return CF parameter set
>    */
>   CfParameterSet GetCfParameterSet (void) const;
376a715,756
>    * Set the extended capabilities.
>    *
>    * \param extendedcapabilities the extended capabilities
>    */
>   void SetExtendedCapabilities (ExtendedCapabilities extendedcapabilities);
>   /**
>    * Set the HT capabilities.
>    *
>    * \param htcapabilities HT capabilities
>    */
>   void SetHtCapabilities (HtCapabilities htcapabilities);
>   /**
>    * Set the HT operation.
>    *
>    * \param htoperation HT operation
>    */
>   void SetHtOperation (HtOperation htoperation);
>   /**
>    * Set the VHT capabilities.
>    *
>    * \param vhtcapabilities VHT capabilities
>    */
>   void SetVhtCapabilities (VhtCapabilities vhtcapabilities);
>   /**
>    * Set the VHT operation.
>    *
>    * \param vhtoperation VHT operation
>    */
>   void SetVhtOperation (VhtOperation vhtoperation);
>   /**
>    * Set the HE capabilities.
>    *
>    * \param hecapabilities HE capabilities
>    */
>   void SetHeCapabilities (HeCapabilities hecapabilities);
>   /**
>    * Set the HE operation.
>    *
>    * \param heoperation HE operation
>    */
>   void SetHeOperation (HeOperation heoperation);
>   /**
382a763,768
>    * Set the beacon interval in microseconds unit.
>    *
>    * \param us beacon interval in microseconds unit
>    */
>   void SetBeaconIntervalUs (uint64_t us);
>   /**
388d773
< 
390c775
<    * Return the time stamp.
---
>    * Set the DSSS Parameter Set.
392c777
<    * \return time stamp
---
>    * \param dsssParameterSet the DSSS Parameter Set
394c779
<   uint64_t GetTimestamp ();
---
>   void SetDsssParameterSet (DsssParameterSet dsssParameterSet);
396c781
<    * Return the beacon interval in microseconds unit.
---
>    * Set the ERP information.
398c783
<    * \return beacon interval in microseconds unit
---
>    * \param erpInformation the ERP information
400c785
<   uint64_t GetBeaconIntervalUs (void) const;
---
>   void SetErpInformation (ErpInformation erpInformation);
402c787
<    * Return the Capability information.
---
>    * Set the EDCA Parameter Set.
404c789
<    * \return Capability information
---
>    * \param edcaParameterSet the EDCA Parameter Set
406c791
<   CapabilityInformation GetCapabilities (void) const;
---
>   void SetEdcaParameterSet (EdcaParameterSet edcaParameterSet);
408c793
<    * Return the Service Set Identifier (SSID).
---
>    * Set the CF parameter set.
410c795
<    * \return SSID
---
>    * \param cfparameterset CF parameter set
412c797
<   Ssid GetSsid (void) const;
---
>   void SetCfParameterSet (CfParameterSet cfparameterset);
414c799
<    * Return the supported rates.
---
>    * Return the time stamp.
416c801
<    * \return the supported rates
---
>    * \return time stamp
418c803
<   SupportedRates GetSupportedRates (void) const;
---
>   uint64_t GetTimestamp ();
437a823,833
>   DsssParameterSet m_dsssParameterSet; //!< DSSS Parameter Set
>   ExtendedCapabilities m_extendedCapability; //!< extended capabilities
>   HtCapabilities m_htCapability;       //!< HT capabilities
>   HtOperation m_htOperation;           //!< HT operation
>   VhtCapabilities m_vhtCapability;     //!< VHT capabilities
>   VhtOperation m_vhtOperation;         //!< VHT operation
>   HeCapabilities m_heCapability;       //!< HE capabilities
>   HeOperation m_heOperation;         //!< HE operation
>   ErpInformation m_erpInformation;     //!< ERP information
>   EdcaParameterSet m_edcaParameterSet; //!< EDCA Parameter Set
>   CfParameterSet m_cfParameterSet;     //!< CF parameter set
482d877
<     QOS = 1,
484,485d878
<     PUBLIC = 4,
<     RADIO_MEASUREMENT = 5,      //Category: Radio Measurement
489,491d881
<     DMG = 16,                   //Category: DMG
<     FST = 18,                   //Category: Fast Session Transfer
<     UNPROTECTED_DMG = 20,       //Category: Unprotected DMG
514,549d903
<   enum QosActionValue
<   {
<     ADDTS_REQUEST = 0,
<     ADDTS_RESPONSE = 1,
<     DELTS = 2,
<     SCHEDULE = 3,
<     QOS_MAP_CONFIGURE = 4,
<   };
< 
<   /**
<    * Block Ack Action field values
<    * See 802.11 Table 8-202
<    */
<   enum BlockAckActionValue
<   {
<     BLOCK_ACK_ADDBA_REQUEST = 0,
<     BLOCK_ACK_ADDBA_RESPONSE = 1,
<     BLOCK_ACK_DELBA = 2
<   };
< 
<   enum PublicActionValue
<   {
<     QAB_REQUEST = 16,
<     QAB_RESPONSE = 17,
<   };
< 
<   enum RadioMeasurementActionValue
<   {
<     RADIO_MEASUREMENT_REQUEST = 0,
<     RADIO_MEASUREMENT_REPORT = 1,
<     LINK_MEASUREMENT_REQUEST = 2,
<     LINK_MEASUREMENT_REPORT = 3,
<     NEIGHBOR_REPORT_REQUEST = 4,
<     NEIGHBOR_REPORT_RESPONSE = 5
<   };
< 
567,599c921,922
<    * DMG Action field values
<    * See 802.11ad Table 8-281b
<    */
<   enum DmgActionValue
<   {
<     DMG_POWER_SAVE_CONFIGURATION_REQUEST = 0,
<     DMG_POWER_SAVE_CONFIGURATION_RESPONSE = 1,
<     DMG_INFORMATION_REQUEST = 2,
<     DMG_INFORMATION_RESPONSE = 3,
<     DMG_HANDOVER_REQUEST = 4,
<     DMG_HANDOVER_RESPONSE = 5,
<     DMG_DTP_REQUEST = 6,
<     DMG_DTP_RESPONSE = 7,
<     DMG_RELAY_SEARCH_REQUEST = 8,
<     DMG_RELAY_SEARCH_RESPONSE = 9,
<     DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REQUEST = 10,
<     DMG_MULTI_RELAY_CHANNEL_MEASUREMENT_REPORT = 11,
<     DMG_RLS_REQUEST = 12,
<     DMG_RLS_RESPONSE = 13,
<     DMG_RLS_ANNOUNCEMENT = 14,
<     DMG_RLS_TEARDOWN = 15,
<     DMG_RELAY_ACK_REQUEST = 16,
<     DMG_RELAY_ACK_RESPONSE = 17,
<     DMG_TPA_REQUEST = 18,
<     DMG_TPA_RESPONSE = 19,
<     DMG_TPA_REPORT = 20,
<     DMG_ROC_REQUEST = 21,
<     DMG_ROC_RESPONSE = 22
<   };
< 
<   /**
<    * FST Action field values
<    * See 802.11ad Table 8-281x
---
>    * Block ACK action field values
>    * See 802.11 Table 8-202
601c924
<   enum FstActionValue
---
>   enum BlockAckActionValue
603,608c926,928
<     FST_SETUP_REQUEST = 0,
<     FST_SETUP_RESPONSE = 1,
<     FST_TEAR_DOWN = 2,
<     FST_ACK_REQUEST = 3,
<     FST_ACK_RESPONSE = 4,
<     ON_CHANNEL_TUNNEL_REQUEST = 5
---
>     BLOCK_ACK_ADDBA_REQUEST = 0,
>     BLOCK_ACK_ADDBA_RESPONSE = 1,
>     BLOCK_ACK_DELBA = 2
611,623d930
<   /**
<    * Unprotected DMG action field values
<    * See 802.11ad Table 8-281ae
<    */
<   enum UnprotectedDmgValue
<   {
<     UNPROTECTED_DMG_ANNOUNCE = 0,
<     UNPROTECTED_DMG_BRP = 1,
<     UNPROTECTED_MIMO_BF_SETUP = 2,
<     UNPROTECTED_MIMO_BF_POLL = 3,
<     UNPROTECTED_MIMO_BF_FEEDBACK = 4,
<     UNPROTECTED_MIMO_BF_SELECTION = 5,
<   };
630,635d936
<     QosActionValue qos;
<     BlockAckActionValue blockAck; ///< block ack
<     RadioMeasurementActionValue radioMeasurementAction;
<     PublicActionValue publicAction;
<     SelfProtectedActionValue selfProtectedAction; ///< self protected action
<     MultihopActionValue multihopAction; ///< multi hop action
637,639c938,940
<     DmgActionValue dmgAction;
<     FstActionValue fstAction;
<     UnprotectedDmgValue unprotectedAction;
---
>     MultihopActionValue multihopAction; ///< multi hop action
>     SelfProtectedActionValue selfProtectedAction; ///< self protected action
>     BlockAckActionValue blockAck; ///< block ack
678c979
<    * \returns the category value string
---
>    * \returns the categoty value string
691,725d991
< /**
<  * \ingroup wifi
<  * Implement the header for action frames of type DMG ADDTS request.
<  */
< class DmgAddTSRequestFrame : public Header
< {
< public:
<   DmgAddTSRequestFrame ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The Dialog Token field.
<   * \param token
<   */
<   void SetDialogToken (uint8_t token);
<   void SetDmgTspecElement (DmgTspecElement &element);
< 
<   uint8_t GetDialogToken (void) const;
<   DmgTspecElement GetDmgTspec (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   DmgTspecElement m_dmgTspecElement;
< 
< };
729,804c995
<  * Implement the header for action frames of type DMG ADDTS request.
<  */
< class DmgAddTSResponseFrame : public Header
< {
< public:
<   DmgAddTSResponseFrame ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The Dialog Token field.
<   * \param token
<   */
<   void SetDialogToken (uint8_t token);
<   void SetStatusCode (StatusCode status);
<   void SetTsDelay (TsDelayElement &element);
<   void SetDmgTspecElement (DmgTspecElement &element);
< 
<   uint8_t GetDialogToken (void) const;
<   StatusCode GetStatusCode (void) const;
<   TsDelayElement GetTsDelay (void) const;
<   DmgTspecElement GetDmgTspec (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   StatusCode m_status;
<   TsDelayElement m_tsDelayElement;
<   DmgTspecElement m_dmgTspecElement;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for action frames of type DELTS (8.5.3.4).
<  */
< class DelTsFrame : public Header
< {
< public:
<   DelTsFrame ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetReasonCode (uint16_t reason);
<   void SetDmgAllocationInfo (DmgAllocationInfo info);
< 
<   uint16_t GetReasonCode (void) const;
<   DmgAllocationInfo GetDmgAllocationInfo (void) const;
< 
< private:
<   uint8_t m_tsInfo[3];
<   uint16_t m_reasonCode;
<   DmgAllocationInfo m_dmgAllocationInfo;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for management frames of type Add Block Ack request.
---
>  * Implement the header for management frames of type add block ack request.
823c1014
<    * Enable delayed BlockAck.
---
>    * Enable delayed Block ACK.
827c1018
<    * Enable immediate BlockAck
---
>    * Enable immediate Block ACK
874c1065
<    * Return whether the Block Ack policy is immediate Block Ack.
---
>    * Return whether the Block ACK policy is immediate Block ACK.
876c1067
<    * \return true if immediate Block Ack is being used, false otherwise
---
>    * \return true if immediate Block ACK is being used, false otherwise
920c1111
<    * \param seqControl the raw sequence control
---
>    * \param seqControl
926c1117
<   uint8_t m_policy;        //!< Block Ack policy
---
>   uint8_t m_policy;        //!< Block ACK policy
936c1127
<  * Implement the header for management frames of type Add Block Ack response.
---
>  * Implement the header for management frames of type add block ack response.
955c1146
<    * Enable delayed BlockAck.
---
>    * Enable delayed Block ACK.
959c1150
<    * Enable immediate BlockAck.
---
>    * Enable immediate Block ACK
1006c1197
<    * Return whether the Block Ack policy is immediate Block Ack.
---
>    * Return whether the Block ACK policy is immediate Block ACK.
1008c1199
<    * \return true if immediate Block Ack is being used, false otherwise
---
>    * \return true if immediate Block ACK is being used, false otherwise
1057c1248
<  * Implement the header for management frames of type Delete Block Ack.
---
>  * Implement the header for management frames of type del block ack.
1122,2607d1312
< };
< 
< /**
<  * \ingroup wifi
<  * The Radio Measurement Request frame uses the Action frame body format. It is transmitted by a STA
<  * requesting another STA to make one or more measurements on one or more channels.
<  */
< class RadioMeasurementRequest : public Header
< {
< public:
<   RadioMeasurementRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the radio measurement request
<    * to identify the request/report transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Number of Repetitions field contains the requested number of repetitions for all the Measurement
<    * Request elements in this frame. A value of 0 in the Number of Repetitions field indicates Measurement
<    * Request elements are executed once without repetition. A value of 65 535 in the Number of Repetitions field
<    * indicates Measurement Request elements are repeated until the measurement is cancelled or superseded.
<    * \param repetitions
<    */
<   void SetNumberOfRepetitions (uint16_t repetitions);
< 
<   void AddMeasurementRequestElement (Ptr<WifiInformationElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetNumberOfRepetitions (void) const;
<   WifiInfoElementList GetListOfMeasurementRequestElement (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_numOfRepetitions;
<   WifiInfoElementList m_list;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * The Radio Measurement Report frame uses the Action frame body format. It is transmitted by a STA in
<  * response to a Radio Measurement Request frame or by a STA providing a triggered autonomous measurement report.
<  */
< class RadioMeasurementReport : public Header
< {
< public:
<   RadioMeasurementReport ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to the value in the corresponding Radio Measurement Request frame. If the
<    * Radio Measurement Report frame is not being transmitted in response to a Radio Measurement Request
<    * frame then the Dialog token is set to 0.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   void AddMeasurementReportElement (Ptr<WifiInformationElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   WifiInfoElementList GetListOfMeasurementReportElement (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   WifiInfoElementList m_list;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * The Link Measurement Request frame uses the Action frame body format and is transmitted by a STA to
<  * request another STA to respond with a Link Measurement Report frame to enable measurement of link path
<  * loss and estimation of link margin.
<  */
< class LinkMeasurementRequest : public Header
< {
< public:
<   LinkMeasurementRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the request to identify the
<    * transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Transmit Power Used field is set to the transmit power used to transmit the frame containing the Link
<    * Measurement Request, as described in 8.4.1.20.
<    * \param power
<    */
<   void SetTransmitPowerUsed (uint8_t power);
<   /**
<    * The Max Transmit Power field provides the upper limit on the transmit power as measured at the output of
<    * \the antenna connector to be used by the transmitting STA on its operating channel. This field is described in
<    * 8.4.1.19. The Max Transmit Power field is a twos complement signed integer and is 1 octet in length,
<    * providing an upper limit, in a dBm scale, on the transmit power as measured at the output of the antenna
<    * connector to be used by the transmitting STA on its operating channel. The maximum tolerance for the value
<    * reported in Max Transmit Power field is ±5 dB. The value of the Max Transmit Power field is equal to the
<    * minimum of the maximum powers at which the STA is permitted to transmit in the operating channel by
<    * device capability, policy, and regulatory authority.
<    * \param power
<    */
<   void SetMaxTransmitPower (uint8_t power);
<   void AddSubElement (Ptr<WifiInformationElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   uint8_t GetTransmitPowerUsed (uint8_t power) const;
<   uint8_t GetMaxTransmitPower (uint8_t power) const;
<   /**
<    * Get a specific SubElement by ID.
<    * \param id The ID of the Wifi SubElement.
<    * \return
<    */
<   Ptr<WifiInformationElement> GetSubElement (WifiInformationElementId id);
<   /**
<    * Get List of SubElement associated with this frame.
<    * \return
<    */
<   WifiInformationSubelementMap GetListOfSubElements (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint8_t m_transmitPowerUsed;
<   uint8_t m_maxTransmitPower;
<   WifiInformationSubelementMap m_map;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * The Link Measurement Report frame uses the Action frame body format and is transmitted by a STA in
<  * response to a Link Measurement Request frame.
<  */
< class LinkMeasurementReport : public Header
< {
< public:
<   LinkMeasurementReport ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetTpcReportElement (uint32_t elem);
<   void SetReceiveAntennaId (uint8_t id);
<   void SetTransmitAntennaId (uint8_t id);
<   void SetRCPI (uint8_t value);
<   void SetRSNI (uint8_t value);
<   void AddSubElement (Ptr<WifiInformationElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   uint32_t GetTpcReportElement (void) const;
<   uint8_t GetReceiveAntennaId (void) const;
<   uint8_t GetTransmitAntennaId (void) const;
<   uint8_t GetRCPI (void) const;
<   uint8_t GetRSNI (void) const;
<   /**
<    * Get a specific SubElement by ID.
<    * \param id The ID of the Wifi SubElement.
<    * \return
<    */
<   Ptr<WifiInformationElement> GetSubElement (WifiInformationElementId id);
<   /**
<    * Get List of SubElement associated with this frame.
<    * \return
<    */
<   WifiInformationSubelementMap GetListOfSubElements (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint32_t m_tpcElement;
<   uint8_t m_receiveAntId;
<   uint8_t m_transmitAntId;
<   uint8_t m_rcpi;
<   uint8_t m_rsni;
<   WifiInformationSubelementMap m_map;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Public QAB Frame.
<  */
< class ExtQabFrame : public Header
< {
< public:
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const = 0;
<   virtual uint32_t Deserialize (Buffer::Iterator start) = 0;
< 
<   void SetDialogToken (uint8_t token);
<   void SetRequesterApAddress (Mac48Address address);
<   void SetResponderApAddress (Mac48Address address);
< 
<   uint8_t GetDialogToken (void) const;
<   Mac48Address GetRequesterApAddress (void) const;
<   Mac48Address GetResponderApAddress (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   Mac48Address m_requester;
<   Mac48Address m_responder;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Public QAB Request (8.5.8.25).
<  * The QAB Request Action frame is transmitted by an AP to another AP to schedule quiet periods that
<  * facilitate the detection of other system operating in the same band.
<  */
< class ExtQabRequestFrame : public ExtQabFrame
< {
< public:
<   ExtQabRequestFrame ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetQuietPeriodRequestElement (QuietPeriodRequestElement &element);
< 
<   QuietPeriodRequestElement GetQuietPeriodRequestElement (void) const;
< 
< private:
<   QuietPeriodRequestElement m_element;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Public QAB Response (8.5.8.26).
<  * A QAB Response frame is sent in response to a QAB Request frame.
<  */
< class ExtQabResponseFrame : public ExtQabFrame
< {
< public:
<   ExtQabResponseFrame ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   TypeId GetInstanceTypeId (void) const;
<   void Print (std::ostream &os) const;
<   uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetQuietPeriodResponseElement (QuietPeriodResponseElement &element);
< 
<   QuietPeriodResponseElement GetQuietPeriodResponseElement (void) const;
< 
< private:
<   QuietPeriodResponseElement m_element;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type  Common Information frame.
<  */
< class ExtInformationFrame : public Header, public MgtFrame
< {
< public:
<   ExtInformationFrame ();
< 
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const = 0;
<   virtual uint32_t Deserialize (Buffer::Iterator start) = 0;
< 
<   /**
<    * Set the MAC address of the STA whose information is being requested. If this frame is sent to
<    * the PCP and the value of the Subject Address field is the broadcast address, then the STA is
<    * requesting information regarding all associated STAs.
<    * \param address The Mac address
<    */
<   void SetSubjectAddress (Mac48Address address);
<   /**
<    * Set the request element which contains a list of requested information IDs.
<    * \param elem the Request Element.
<    */
<   void SetRequestInformationElement (Ptr<RequestElement> elem);
<   /**
<    * The DMG Capabilities element carries information about the transmitter STA and other STAs known
<    * to the transmitter STA.
<    * \param elem The DMG Capabilities Information Element.
<    */
<   void AddDmgCapabilitiesElement (Ptr<DmgCapabilities> elem);
< 
< 
<   Mac48Address GetSubjectAddress (void) const;
<   Ptr<RequestElement> GetRequestInformationElement (void) const;
<   DmgCapabilitiesList GetDmgCapabilitiesList (void) const;
< 
< protected:
<   Mac48Address m_subjectAddress;
<   Ptr<RequestElement> m_requestElement;
<   DmgCapabilitiesList m_dmgCapabilitiesList;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Information Request frame (8.5.20.4).
<  */
< class ExtInformationRequest : public ExtInformationFrame
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Information Request frame (8.5.20.4).
<  */
< class ExtInformationResponse : public ExtInformationFrame
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
<   virtual uint32_t GetSerializedSize (void) const;
< 
< 
<   Ptr<BeamRefinementElement> GetBeamRefinementElement (void) const;
<   Ptr<ChannelMeasurementFeedbackElement> GetChannelMeasurementElement (void) const;
<   Ptr<EDMGChannelMeasurementFeedbackElement> GetEDMGChannelMeasurementElement (void) const;
< 
<   void SetBeamRefinementElement (Ptr<BeamRefinementElement> element);
<   void SetChannelMeasurementElement (Ptr<ChannelMeasurementFeedbackElement> element);
<   void SetEdmgChannelMeasurementElement (Ptr<EDMGChannelMeasurementFeedbackElement> element);
< 
< protected:
<   Ptr<BeamRefinementElement> m_beamRefinement;
<   Ptr<ChannelMeasurementFeedbackElement> m_channelElement;
<   Ptr<EDMGChannelMeasurementFeedbackElement> m_edmgChannelElement;
< 
< };
< 
< enum HandoverReason
< {
<   LeavingPBSS = 0,
<   LowPowerPCP = 1,
<   QualifiedSTA = 2,
<   BecomePCP = 3
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type handover request frame.
<  */
< class ExtHandoverRequestHeader : public Header
< {
< public:
<   ExtHandoverRequestHeader ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the reason that the current PCP intends to do the PCP handover.
<    * \param reason
<    */
<   void SetHandoverReason (enum HandoverReason reason);
<   /**
<    * Set the number of beacon intervals, excluding the beacon interval in which this frame
<    * is transmitted, remaining until the handover takes effect.
<    * \param length
<    */
<   void SetHandoverRemainingBI (uint8_t remaining);
< 
<   enum HandoverReason GetHandoverReason (void) const;
<   uint8_t GetHandoverRemainingBI (void) const;
< 
< private:
<   uint8_t m_handoverReason;
<   uint8_t m_remainingBI;
< 
< };
< 
< enum HandoverRejectReason
< {
<   LowPower = 0,
<   HandoverInProgress = 1,
<   InvalidBI = 2,
<   UnspecifiedReason = 3
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type handover response frame.
<  */
< class ExtHandoverResponseHeader : public Header
< {
< public:
<   ExtHandoverResponseHeader ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set whether the STA accepted the handover request.
<    * \param  result A value of 0 indicates that the STA accepts the handover request.
<    * A value of 1 indicates that the STA does not accept the handover request.
<    */
<   void SetHandoverResult (bool result);
<   /**
<    *
<    */
<   void SetHandoverRejectReason (enum HandoverRejectReason reason);
< 
<   bool GetHandoverResult (void) const;
<   enum HandoverRejectReason GetHandoverRejectReason (void) const;
< 
< private:
<   bool m_handoverResult;
<   uint8_t m_handoverRejectReason;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay Search Request frame.
<  */
< class ExtRelaySearchRequestHeader : public Header
< {
< public:
<   ExtRelaySearchRequestHeader ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetDestinationRedsAid (uint16_t aid);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetDestinationRedsAid (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_aid;
< 
< };
< 
< typedef std::map<uint16_t, RelayCapabilitiesInfo> RelayCapableStaList;
< typedef RelayCapableStaList::const_iterator RelayCapableStaListCI;
< typedef RelayCapableStaList::iterator RelayCapableStaListI;
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay Search Response frame.
<  */
< class ExtRelaySearchResponseHeader : public Header
< {
< public:
<   ExtRelaySearchResponseHeader ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetStatusCode (uint16_t status);
<   void AddRelayCapableStaInfo (uint8_t aid, RelayCapabilitiesInfo &element);
<   void SetRelayCapableList (RelayCapableStaList &list);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetStatusCode (void) const;
<   RelayCapableStaList GetRelayCapableList (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_statusCode;
<   RelayCapableStaList m_list;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Multi-relay Channel Measurement Request frame.
<  * The Multi-Relay Channel Measurement Request frame is transmitted by a STA initiating relay operation to
<  * the recipient STA in order to obtain Channel Measurements between the recipient STA and the other STA
<  * participating in the relay operation.
<  *
<  */
< class ExtMultiRelayChannelMeasurementRequest : public Header
< {
< public:
<   ExtMultiRelayChannelMeasurementRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the Multi-Relay Channel
<    * Measurement Request frame to identify the request/report transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
< 
<   uint8_t GetDialogToken (void) const;
< 
< private:
<   uint8_t m_dialogToken;
< 
< };
< 
< typedef std::vector<Ptr<ExtChannelMeasurementInfo> > ChannelMeasurementInfoList;
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay Search Response frame.
<  */
< class ExtMultiRelayChannelMeasurementReport : public Header
< {
< public:
<   ExtMultiRelayChannelMeasurementReport ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void AddChannelMeasurementInfo (Ptr<ExtChannelMeasurementInfo> element);
<   void SetChannelMeasurementList (ChannelMeasurementInfoList &list);
< 
<   uint8_t GetDialogToken (void) const;
<   ChannelMeasurementInfoList GetChannelMeasurementInfoList (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   ChannelMeasurementInfoList m_list;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement a generic header for extension frames of type RLS (Relay Link Setup) frame.
< */
< class ExtRlsFrame : public Header
< {
< public:
<  ExtRlsFrame ();
< 
<  virtual uint32_t GetSerializedSize (void) const;
<  virtual void Serialize (Buffer::Iterator start) const = 0;
<  virtual uint32_t Deserialize (Buffer::Iterator start) = 0;
< 
<  /**
<   * Set the Destination AID field value .
<   * \param aid the AID of the target destination.
<   */
<  void SetDestinationAid (uint16_t aid);
<  /**
<   * Set the Relay AID field value.
<   * \param aid the AID of the RDS.
<   */
<  void SetRelayAid (uint16_t aid);
<  /**
<   * The Source AID field value.
<   * \param aid  is the AID of the initiating STA.
<   */
<  void SetSourceAid (uint16_t aid);
< 
<  uint16_t GetDestinationAid (void) const;
<  uint16_t GetRelayAid (void) const;
<  uint16_t GetSourceAid (void) const;
< 
< protected:
<  uint16_t m_destinationAid;
<  uint16_t m_relayAid;
<  uint16_t m_sourceAid;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type RLS (Relay Link Setup) Request frame.
<  */
< class ExtRlsRequest : public ExtRlsFrame
< {
< public:
<   ExtRlsRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   void Serialize (Buffer::Iterator start) const;
<   uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the RLS Request frame to
<    * identify the request/response transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Destination Capability Information field indicates the Relay capabilities info field within the Relay
<    * capabilities element of the target destination REDS as defined in 8.4.2.150.
<    * \param elem
<    */
<   void SetDestinationCapabilityInformation (RelayCapabilitiesInfo &elem);
<   /**
<    * The Relay Capability Information field indicates the Relay capabilities info field within the Relay
<    * capabilities element of the selected RDS as defined in 8.4.2.150.
<    * \param elem
<    */
<   void SetRelayCapabilityInformation (RelayCapabilitiesInfo &elem);
<   /**
<    * The Source Capability Information field indicates the Relay capabilities info field within the Relay
<    * capabilities element of the originator of the request as defined in 8.4.2.150.
<    * \param elem
<    */
<   void SetSourceCapabilityInformation (RelayCapabilitiesInfo &elem);
<   /**
<    * The Relay Transfer Parameter Set element is defined in 8.4.2.151.
<    * \param elem
<    */
<   void SetRelayTransferParameterSet (Ptr<RelayTransferParameterSetElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   RelayCapabilitiesInfo GetDestinationCapabilityInformation (void) const;
<   RelayCapabilitiesInfo GetRelayCapabilityInformation (void) const;
<   RelayCapabilitiesInfo GetSourceCapabilityInformation (void) const;
<   Ptr<RelayTransferParameterSetElement> GetRelayTransferParameterSet (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   RelayCapabilitiesInfo m_destinationCapability;
<   RelayCapabilitiesInfo m_relayCapability;
<   RelayCapabilitiesInfo m_sourceCapability;
<   Ptr<RelayTransferParameterSetElement> m_relayParameter;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type RLS (Relay Link Setup) Response frame.
<  */
< class ExtRlsResponse : public Header
< {
< public:
<   ExtRlsResponse ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the RLS Request frame to
<    * identify the request/response transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Destination Status Code field is included when the destination REDS transmits this RLS Response
<    * frame as a result of RLS Request. It is defined in 8.4.1.9.
<    * \param aid the AID of the target destination.
<    */
<   void SetDestinationStatusCode (uint16_t status);
<   /**
<    * The Relay Status Code field is included when the relay REDS transmits this RLS Response frame as a result
<    * of RLS Request. It is defined in 8.4.1.9.
<    * \param aid the AID of the selected RDS.
<    */
<   void SetRelayStatusCode (uint16_t status);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetDestinationStatusCode (void) const;
<   uint16_t GetRelayStatusCode (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_destinationStatusCode;
<   uint16_t m_relayStatusCode;
<   bool m_insertRelayStatus;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type RLS (Relay Link Setup) Announcment frame.
< * The RLS Announcement frame is sent to announce the successful RLS.
< */
< class ExtRlsAnnouncment : public ExtRlsFrame
< {
< public:
<  ExtRlsAnnouncment ();
< 
<  /**
<   * Register this type.
<   * \return The TypeId.
<   */
<  static TypeId GetTypeId (void);
<  // Inherited
<  virtual TypeId GetInstanceTypeId (void) const;
<  virtual void Print (std::ostream &os) const;
<  virtual uint32_t GetSerializedSize (void) const;
<  void Serialize (Buffer::Iterator start) const;
<  uint32_t Deserialize (Buffer::Iterator start);
< 
<  /**
<   * Set the status code on the RLS.
<   * \param status the status of the RLS
<   */
<  void SetStatusCode (uint16_t status);
< 
<  uint16_t GetStatusCode (void) const;
< 
< private:
<  uint16_t m_status;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type RLS (Relay Link Setup) Teardown frame.
< * The RLS Teardown frame is sent to terminate a relay operation.
< */
< class ExtRlsTearDown : public ExtRlsFrame
< {
< public:
<  ExtRlsTearDown ();
< 
<  /**
<   * Register this type.
<   * \return The TypeId.
<   */
<  static TypeId GetTypeId (void);
<  // Inherited
<  virtual TypeId GetInstanceTypeId (void) const;
<  virtual void Print (std::ostream &os) const;
<  virtual uint32_t GetSerializedSize (void) const;
<  void Serialize (Buffer::Iterator start) const;
<  uint32_t Deserialize (Buffer::Iterator start);
< 
<  /**
<   * Set the reason code.
<   * \param reason the reason of the RLS teardown
<   */
<  void SetReasonCode (uint16_t reason);
< 
<  uint16_t GetReasonCode (void) const;
< 
< private:
<  uint16_t m_reasonCode;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay ACK Request frame format (8.5.20.18).
<  * The Relay ACK Request frame is sent by a source REDS to an RDS participating in a relay operation in
<  * order to determine whether all frames forwarded through the RDS were successfully received by the
<  * destination REDS also participating in the relay operation. This frame is used only when the RDS is
<  * operated in HD-DF mode and relay operation is link switching type.
<  */
< class ExtRelayAckRequest : public CtrlBAckRequestHeader
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   TypeId GetInstanceTypeId (void) const;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Relay ACK Request frame format (8.5.20.19).
<  * The Relay ACK Response frame is sent by an RDS to a source REDS participating in a relay operation in
<  * order to report which frames have been received by the destination REDS also participating in the relay
<  * operation. This frame is used only when the RDS is operated in HD-DF mode and relay operation is link
<  * switching type.
<  */
< class ExtRelayAckResponse : public CtrlBAckResponseHeader
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   TypeId GetInstanceTypeId (void) const;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type TPA (Transmission Time-Point Adjustment) Request frame.
<  * The TPA Request frame is sent by a destination REDS participating in operation based on link cooperating
<  * type to both the RDS and source REDS that belong to the same group as the destination REDS in order for
<  * them to send back their own TPA Response frames at the separately pre-defined times. Also, a source REDS
<  * sends a TPA Request frame to the RDS that is selected by the source REDS in order for the RDS to feedback
<  * its own TPA Response frame at the pre-defined time.
<  */
< class ExtTpaRequest : public Header
< {
< public:
<   ExtTpaRequest ();
< 
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a nonzero value chosen by the STA sending the TPA Request frame to
<    * identify the request/response transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   /**
<    * The Timing Offset is 2 octets in length and indicates the amount of time, in nanoseconds, that the STA
<    * identified in the RA of the frame is required to change the timing offset of its transmissions so that they
<    * arrive at the expected time at the transmitting STA.
<    */
<   void SetTimingOffset (uint16_t offset);
<   /**
<    * The Sampling Frequency Offset is 2 octets in length and indicates the amount by which to change the
<    * sampling frequency offset of the burst transmission so that bursts arrive at the destination DMG STA with
<    * no sampling frequency offset. The unit is 0.01 ppm. The Sampling Frequency Offset field is reserved when
<    * set to 0.
<    * \param offset the smapling frequency offset
<    */
<   void SetSamplingFrequencyOffset (uint16_t offset);
< 
<   uint8_t GetDialogToken (void) const;
<   uint16_t GetTimingOffset (void) const;
<   uint16_t GetSamplingFrequencyOffset (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint16_t m_timingOffset;
<   uint16_t m_samplingOffset;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) Setup frame.
< */
< class ExtFstSetupFrame : public Header
< {
< public:
<   ExtFstSetupFrame ();
< 
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const = 0;
<   virtual void Print (std::ostream &os) const = 0;
<   virtual uint32_t GetSerializedSize (void) const = 0;
<   virtual void Serialize (Buffer::Iterator start) const = 0;
<   virtual uint32_t Deserialize (Buffer::Iterator start) = 0;
< 
<   /**
<   * The Dialog Token field is set to a nonzero value chosen by the STA sending the TPA Request frame to
<   * identify the request/response transaction.
<   * \param token
<   */
<   void SetDialogToken (uint8_t token);
<   /**
<   * Set the Session Transition field defined in 8.4.2.147.
<   * \param elem the sessio transition element
<   */
<   void SetSessionTransition (SessionTransitionElement &elem);
<   /**
<   * Set the Multi-band field contains the Multi-Band element as defined in 8.4.2.140. The regulatory information
<   * contained in the Multi-band element is applicable to all the fields and elements contained in the frame.
<   * \param elem the multi-band element
<   */
<   void SetMultiBand (Ptr<MultiBandElement> elem);
<   void SetWakeupSchedule (Ptr<WakeupScheduleElement> elem);
<   void SetAwakeWindow (Ptr<AwakeWindowElement> elem);
<   void SetSwitchingStream (Ptr<SwitchingStreamElement> elem);
< 
<   uint8_t GetDialogToken (void) const;
<   SessionTransitionElement GetSessionTransition (void) const;
<   Ptr<MultiBandElement> GetMultiBand (void) const;
<   Ptr<WakeupScheduleElement> GetWakeupSchedule (void) const;
<   Ptr<AwakeWindowElement> GetAwakeWindow (void) const;
<   Ptr<SwitchingStreamElement> GetSwitchingStream (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   SessionTransitionElement m_sessionTransition;
<   Ptr<MultiBandElement> m_multiBand;
<   Ptr<WakeupScheduleElement> m_wakeupSchedule;
<   Ptr<AwakeWindowElement> m_awakeWindow;
<   Ptr<SwitchingStreamElement> m_switchingStream;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) Setup Request frame.
< * The FST Setup Request frame is an Action frame of category FST. The FST Setup Request frame allows an
< * initiating STA to announce to a peer STA whether the initiating STA intends to enable FST for the session
< * between the initiating STA and the peer STA (10.32).
< */
< class ExtFstSetupRequest : public ExtFstSetupFrame
< {
< public:
<   ExtFstSetupRequest ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The Link loss timeout (LLT) field is 32 bits and indicates the compressed maximum duration counted from
<   * the last time an MPDU was received by the initiating STA from the peer STA until the initiating STA
<   * decides to initiate FST.
<   * \param llt
<   */
<   void SetLlt (uint32_t llt);
< 
<   uint32_t GetLlt (void) const;
< 
< private:
<   uint32_t m_llt;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) Setup Response frame.
< * The FST Setup Response frame is an Action frame of category FST. This frame is transmitted in response to
< * the reception of an FST Setup Request frame.
< */
< class ExtFstSetupResponse : public ExtFstSetupFrame
< {
< public:
<   ExtFstSetupResponse ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * \param status
<   */
<   void SetStatusCode (uint16_t status);
<   /**
<   * \return Status of the FST Setup
<   */
<   uint16_t GetStatusCode (void) const;
< 
< private:
<   uint16_t m_statusCode;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) Tear Down frame.
< * This frame is transmitted to delete an established FST session between STAs.
< */
< class ExtFstTearDown : public Header
< {
< public:
<   ExtFstTearDown ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The FSTS ID field contains the identification of the FST session established between the STAs identified by
<   * the TA and RA fields of this frame
<   * \param token
<   */
<   void SetFstsID (uint32_t id);
< 
<   uint32_t GetFstsID (void) const;
< 
< private:
<   uint32_t m_fstsID;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) ACK Request frame.
< * This frame is transmitted in the frequency band an FST session is transferred to and confirms
< * the FST session transfer
< */
< class ExtFstAckRequest : public Header
< {
< public:
<   ExtFstAckRequest ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<   * The Dialog Token field is set to a nonzero value chosen by the STA sending the FST ACK Request frame to
<   * identify the request/response transaction.
<   * \param token
<   */
<   void SetDialogToken (uint8_t token);
<   /**
<   * The FSTS ID field contains the identification of the FST session established between the STAs identified by
<   * the TA and RA fields of this frame
<   * \param token
<   */
<   void SetFstsID (uint32_t id);
< 
<   uint8_t GetDialogToken (void) const;
<   uint32_t GetFstsID (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   uint32_t m_fstsID;
< 
< };
< 
< /**
< * \ingroup wifi
< * Implement the header for extension frames of type FST (Fast Session Transfer) ACK Request frame.
< * The FST Ack Response frame is an Action frame of category FST. This frame is transmitted in response to
< * the reception of an FST Ack Request frame
< */
< class ExtFstAckResponse : public ExtFstAckRequest
< {
< public:
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Unprotected DMG Announce frame (8.5.22.2).
<  * The Announce frame is an Action or an Action No Ack frame of category Unprotected DMG. Announce frames
<  * can be transmitted during the ATI of a beacon interval and can perform functions including of a DMG
<  * Beacon frame, but since this frame does not have to be transmitted as a sector sweep to a STA, it can
<  * provide much more spectrally efficient access than using a DMG Beacon frame.
<  */
< class ExtAnnounceFrame : public Header, public MgtFrame
< {
< public:
<   ExtAnnounceFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * Set the Timestamp for this frame.
<    * \param timestamp The Timestamp for this frame
<    */
<   void SetTimestamp (uint8_t timestamp);
<   /**
<    * Set the Beacon Interval.
<    * \param interval the Beacon Interval.
<    */
<   void SetBeaconInterval (uint16_t interval);
< 
<   uint8_t GetTimestamp (void) const;
<   uint16_t GetBeaconInterval (void) const;
< 
< protected:
<   uint8_t m_timestamp;
<   uint16_t m_beaconInterval;
< 
< };
< 
< /**
<  * \ingroup wifi
<  * Implement the header for extension frames of type Unprotected DMG BRP Frame (8.5.22.3).
<  * The BRP frame is an Action No Ack frame.
<  */
< class ExtBrpFrame : public Header
< {
< public:
<   /**
<    * Register this type.
<    * \return The TypeId.
<    */
<   static TypeId GetTypeId (void);
<   ExtBrpFrame (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetBrpRequestField (BRP_Request_Field &field);
<   void SetBeamRefinementElement (BeamRefinementElement &element);
<   void AddChannelMeasurementFeedback (ChannelMeasurementFeedbackElement *element);
<   void SetEdmgPartialSlsElement (EdmgPartialSectorLevelSweep *element);
<   void SetEdmgBrpRequestElement (EdmgBrpRequestElement *element);
<   void AddEdmgChannelMeasurementFeedback (EDMGChannelMeasurementFeedbackElement *element);
< 
<   uint8_t GetDialogToken (void) const;
<   BRP_Request_Field GetBrpRequestField (void) const;
<   BeamRefinementElement GetBeamRefinementElement (void) const;
<   ChannelMeasurementFeedbackElementList GetChannelMeasurementFeedbackList (void) const;
<   Ptr<EdmgPartialSectorLevelSweep> GetEdmgPartialSlsElement (void) const;
<   Ptr<EdmgBrpRequestElement> GetEdmgBrpRequestElement (void) const;
<   EDMGChannelMeasurementFeedbackElementList GetEdmgChannelMeasurementFeedbackList (void) const;
< 
< private:
<   uint8_t m_dialogToken;
<   BRP_Request_Field m_brpRequestField;
<   BeamRefinementElement m_beamRefinementElement;
<   ChannelMeasurementFeedbackElementList m_list;
<   Ptr<EdmgPartialSectorLevelSweep> m_partialSlsElement;
<   Ptr<EdmgBrpRequestElement> m_edmgBrpRequestElement;
<   EDMGChannelMeasurementFeedbackElementList m_edmgList;
< 
< };
< 
< /**
<  * \ingroup wifi
<  *
<  * The MIMO BF Setup frame is an Action No Ack frame for IEEE 802.11ay.
<  *
<  */
< class ExtMimoBfSetupFrame : public Header
< {
< public:
<   ExtMimoBfSetupFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetMimoSetupControlElement (MimoSetupControlElement element);
< 
<   uint8_t GetDialogToken (void) const;
<   MimoSetupControlElement GetMimoSetupControlElement (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   MimoSetupControlElement m_mimoSetupControl;
< 
< };
< 
< /**
<  * \ingroup wifi
<  *
<  * The MIMO BF Poll frame is an Action No Ack frame for IEEE 802.11ay.
<  *
<  */
< class ExtMimoBfPollFrame : public Header
< {
< public:
<   ExtMimoBfPollFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetMimoPollControlElement (MimoPollControlElement element);
< 
<   uint8_t GetDialogToken (void) const;
<   MimoPollControlElement GetMimoSetupControlElement (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   MimoPollControlElement m_mimoPollControl;
< 
< };
< 
< /**
<  * \ingroup wifi
<  *
<  * The MIMO BF Feedback frame is an Action No Ack frame for IEEE 802.11ay.
<  *
<  * Note: The length of a MIMO BF Feedback frame can limit the choice of channel
<  * measurement parameters such as the number of measurements and the number of taps.
<  */
< class ExtMimoBfFeedbackFrame : public Header
< {
< public:
<   ExtMimoBfFeedbackFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   /**
<    * The Dialog Token field is set to a value chosen by the STA sending the frame to uniquely identify
<    * the transaction.
<    * \param token
<    */
<   void SetDialogToken (uint8_t token);
<   void SetMimoFeedbackControlElement (MIMOFeedbackControl &element);
<   /**
<    * The MIMO BF Feedback frame contains more than one Channel Measurement Feedback element if the
<    * measurement information exceeds 255 octets. The content of each Channel Measurement Feedback
<    * element that follows the first one in a single MIMO BF Feedback frame is a continuation of the content in
<    * the previous element. The SNR, Channel Measurement, Additional SNR and Additional Channel
<    * Measurement subfields can be split between several elements. Each Channel Measurement Feedback
<    * element that is not the last Channel Measurement Feedback element in the frame is 257 octets long.
<    * Channel measurement information for a single channel measurement is always contained within a single
<    * MIMO BF Feedback frame.
<    * \param element
<    */
<   void AddChannelMeasurementFeedbackElement (Ptr<ChannelMeasurementFeedbackElement> element);
<   /**
<    * The MIMO BF Feedback frame contains more than one EDMG Channel Measurement Feedback element if
<    * the measurement information exceeds 254 octets. The content of each EDMG Channel Measurement
<    * Feedback element that follows the first one in a single MIMO BF Feedback frame is a continuation of the
<    * content in the previous element. The EDMG Sector ID Order, BRP CDOWN, Tap Delay, Additional
<    * EDMG Sector ID Order, Additional BRP CDOWN and Additional Tap Delay subfields can be split
<    * between several elements. Each EDMG Channel Measurement Feedback element that is not the last EDMG
<    * Channel Measurement Feedback element in the frame is 257 octets long. Channel measurement
<    * information for a single channel measurement is always contained within a single MIMO BF Feedback frame.
<    * \param element
<    */
<   void AddEdmgChannelMeasurementFeedbackElement (Ptr<EDMGChannelMeasurementFeedbackElement> element);
<   void AddDigitalBfFeedbackElement (Ptr<DigitalBFFeedbackElement> element);
< 
<   uint8_t GetDialogToken (void) const;
<   MIMOFeedbackControl GetMimoFeedbackControlElement (void) const;
<   ChannelMeasurementFeedbackElementList GetListOfChannelMeasurementFeedback (void) const;
<   EDMGChannelMeasurementFeedbackElementList GetListOfEDMGChannelMeasurementFeedback (void) const;
<   DigitalBFFeedbackElementList GetListOfDigitalBFFeedbackElement (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   MIMOFeedbackControl m_mimoFeedbackControl;
<   ChannelMeasurementFeedbackElementList m_channelMeasurementFeedbackList;
<   EDMGChannelMeasurementFeedbackElementList m_edmgChannelMeasurementFeedbackList;
<   DigitalBFFeedbackElementList m_digitalBFFeedbackElementList;
< 
< };
< 
< /**
<  * \ingroup wifi
<  *
<  * The MIMO BF Selection frame is an Action No Ack frame. The format of a MIMO BF Selection frame.
<  */
< class ExtMimoBFSelectionFrame : public Header
< {
< public:
<   ExtMimoBFSelectionFrame ();
< 
<   /**
<   * Register this type.
<   * \return The TypeId.
<   */
<   static TypeId GetTypeId (void);
<   // Inherited
<   virtual TypeId GetInstanceTypeId (void) const;
<   virtual void Print (std::ostream &os) const;
<   virtual uint32_t GetSerializedSize (void) const;
<   virtual void Serialize (Buffer::Iterator start) const;
<   virtual uint32_t Deserialize (Buffer::Iterator start);
< 
<   void SetDialogToken (uint8_t token);
<   void SetMIMOSelectionControlElement (MIMOSelectionControlElement &element);
<   /**
<    * The EDMG Group ID Set element is defined in 9.4.2.254. The element contains the updated
<    * list of MU groups following completion of the MU MIMO beamforming training.
<    * \param element
<    */
<   void SetEDMGGroupIDSetElement (EDMGGroupIDSetElement &element);
< 
<   uint8_t GetDialogToken (void) const;
<   MIMOSelectionControlElement GetMIMOSelectionControlElement (void) const;
<   EDMGGroupIDSetElement GetEDMGGroupIDSetElement (void) const;
< 
< protected:
<   uint8_t m_dialogToken;
<   MIMOSelectionControlElement m_mimoSelectionControlElement;
<   EDMGGroupIDSetElement m_edmgGroupIDSetElement;
< 
diff ../../NS3-WiGig/src/wifi/model/minstrel-ht-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/minstrel-ht-wifi-manager.cc
103c103
<                    "The packet length used for calculating mode TxTime (bytes)",
---
>                    "The packet length used for calculating mode TxTime",
142c142
<   for (uint8_t i = 0; i < m_numGroups; i++)
---
>   if (HasHtSupported ())
144,145c144,148
<       m_minstrelGroups[i].ratesFirstMpduTxTimeTable.clear ();
<       m_minstrelGroups[i].ratesTxTimeTable.clear ();
---
>       for (uint8_t i = 0; i < m_numGroups; i++)
>         {
>           m_minstrelGroups[i].ratesFirstMpduTxTimeTable.clear ();
>           m_minstrelGroups[i].ratesTxTimeTable.clear ();
>         }
164c167
<   // Setup PHY for legacy manager.
---
>   // Setup phy for legacy manager.
170,177d172
< MinstrelHtWifiManager::SetupMac (const Ptr<WifiMac> mac)
< {
<   NS_LOG_FUNCTION (this << mac);
<   m_legacyManager->SetupMac (mac);
<   WifiRemoteStationManager::SetupMac (mac);
< }
< 
< void
181,184c176
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
---
> 
191,192c183,184
<   // Check if the device supports HT
<   if (GetHtSupported ())
---
>   // Check if the device supports HT or VHT
>   if (HasHtSupported () || HasVhtSupported ())
197c189
<       if (GetVhtSupported ())
---
>       if (HasVhtSupported ())
210c202
<        *  - A deviceIndex, which indexes a MCS in the PHY MCS array.
---
>        *  - A deviceIndex, which indexes a MCS in the phy MCS array.
232c224
<                   if (!(!GetShortGuardIntervalSupported () && m_minstrelGroups[groupId].sgi)                   ///Is SGI supported by the transmitter?
---
>                   if (!(!GetPhy ()->GetShortGuardInterval () && m_minstrelGroups[groupId].sgi)                   ///Is SGI supported by the transmitter?
238c230
<                       // Calculate TX time for all rates of the group
---
>                       // Calculate tx time for all rates of the group
244,245c236,237
<                           AddFirstMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode, FIRST_MPDU_IN_AGGREGATE));
<                           AddMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode, MIDDLE_MPDU_IN_AGGREGATE));
---
>                           AddFirstMpduTxTime (groupId, mode, CalculateFirstMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode));
>                           AddMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode));
253c245
<       if (GetVhtSupported ())
---
>       if (HasVhtSupported ())
271c263
<                       if (!(!GetShortGuardIntervalSupported () && m_minstrelGroups[groupId].sgi)                   ///Is SGI supported by the transmitter?
---
>                       if (!(!GetPhy ()->GetShortGuardInterval () && m_minstrelGroups[groupId].sgi)                   ///Is SGI supported by the transmitter?
277c269
<                           // Calculate TX time for all rates of the group
---
>                           // Calculate tx time for all rates of the group
285,286c277,278
<                                   AddFirstMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode, FIRST_MPDU_IN_AGGREGATE));
<                                   AddMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode, MIDDLE_MPDU_IN_AGGREGATE));
---
>                                   AddFirstMpduTxTime (groupId, mode, CalculateFirstMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode));
>                                   AddMpduTxTime (groupId, mode, CalculateMpduTxDuration (GetPhy (), streams, sgi, chWidth, mode));
297a290,297
> void
> MinstrelHtWifiManager::SetupMac (const Ptr<WifiMac> mac)
> {
>   NS_LOG_FUNCTION (this << mac);
>   m_legacyManager->SetupMac (mac);
>   WifiRemoteStationManager::SetupMac (mac);
> }
> 
310,311c310
< MinstrelHtWifiManager::CalculateMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi,
<                                                 uint16_t chWidth, WifiMode mode, MpduType mpduType)
---
> MinstrelHtWifiManager::CalculateFirstMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi, uint16_t chWidth, WifiMode mode)
313c312
<   NS_LOG_FUNCTION (this << phy << +streams << +sgi << chWidth << mode << mpduType);
---
>   NS_LOG_FUNCTION (this << phy << +streams << +sgi << chWidth << mode);
319c318
<   txvector.SetStbc (0);
---
>   txvector.SetStbc (phy->GetStbc ());
322,323c321,336
<   return WifiPhy::CalculatePhyPreambleAndHeaderDuration (txvector)
<          + WifiPhy::GetPayloadDuration (m_frameLength, txvector, phy->GetFrequency (), mpduType);
---
>   return phy->CalculateTxDuration (m_frameLength, txvector, phy->GetFrequency (), MPDU_IN_AGGREGATE, 0);
> }
> 
> Time
> MinstrelHtWifiManager::CalculateMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi, uint16_t chWidth, WifiMode mode)
> {
>   NS_LOG_FUNCTION (this << phy << +streams << +sgi << chWidth << mode);
>   WifiTxVector txvector;
>   txvector.SetNss (streams);
>   txvector.SetGuardInterval (sgi ? 400 : 800);
>   txvector.SetChannelWidth (chWidth);
>   txvector.SetNess (0);
>   txvector.SetStbc (phy->GetStbc ());
>   txvector.SetMode (mode);
>   txvector.SetPreambleType (WIFI_PREAMBLE_NONE);
>   return phy->CalculateTxDuration (m_frameLength, txvector, phy->GetFrequency (), MPDU_IN_AGGREGATE, 0);
394c407
<   if (GetHtSupported ())
---
>   if (HasHtSupported () || HasVhtSupported ())
426c439
<       if (!GetHtSupported (station))
---
>       if (!GetHtSupported (station) && !GetVhtSupported (station))
428c441
<           NS_LOG_INFO ("non-HT station " << station);
---
>           NS_LOG_INFO ("Non-HT station " << station);
447a461,463
>           std::ostringstream tmp;
>           tmp << "minstrel-ht-stats-" << station->m_state->m_address << ".txt";
>           station->m_statsFile.open (tmp.str ().c_str (), std::ios::out);
457c473
<   NS_LOG_DEBUG ("DoReportRxOk m_txrate=" << static_cast<MinstrelHtWifiRemoteStation*> (st)->m_txrate);
---
>   NS_LOG_DEBUG ("DoReportRxOk m_txrate=" << ((MinstrelHtWifiRemoteStation *)st)->m_txrate);
464c480
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *)st;
484c500
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *)st;
498c514
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *)st;
522,523c538
< MinstrelHtWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> MinstrelHtWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode, double dataSnr)
525,526c540,541
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
586c601
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
630,631c645
< MinstrelHtWifiManager::DoReportAmpduTxStatus (WifiRemoteStation *st, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                                               double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> MinstrelHtWifiManager::DoReportAmpduTxStatus (WifiRemoteStation *st, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus, double rxSnr, double dataSnr)
633,634c647,648
<   NS_LOG_FUNCTION (this << st << +nSuccessfulMpdus << +nFailedMpdus << rxSnr << dataSnr << dataChannelWidth << +dataNss);
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << +nSuccessfulMpdus << +nFailedMpdus << rxSnr << dataSnr);
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
644,645c658,659
<   NS_LOG_DEBUG ("DoReportAmpduTxStatus. TxRate=" << station->m_txrate << " SuccMpdus=" <<
<                 +nSuccessfulMpdus << " FailedMpdus=" << +nFailedMpdus);
---
>   NS_LOG_DEBUG ("DoReportAmpduTxStatus. TxRate=" << station->m_txrate << " SuccMpdus= " <<
>                 +nSuccessfulMpdus << " FailedMpdus= " << +nFailedMpdus);
703c717
<    * Following implementation in Linux, in MinstrelHT lowest base rate is not used.
---
>    * Following implementation in Linux, in MinstrelHT Lowest baserate is not used.
715c729
<    * Get the IDs for all rates.
---
>    * Get the ids for all rates.
818c832
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
849c863
<       if ((group.sgi && !GetShortGuardIntervalSupported (station)) || group.chWidth > GetChannelWidth (station)  ||  group.streams > GetNumberOfSupportedStreams (station))
---
>       if ((group.sgi && !GetShortGuardInterval (station)) || group.chWidth > GetChannelWidth (station)  ||  group.streams > GetNumberOfSupportedStreams (station))
854c868
<                          "," << GetShortGuardIntervalSupported (station) << "," << GetChannelWidth (station) << ")");
---
>                          "," << GetShortGuardInterval (station) << "," << GetChannelWidth (station) << ")");
863c877
<       return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), group.sgi ? 400 : 800, GetNumberOfAntennas (), group.streams, GetNess (station), GetChannelWidthForTransmission (mode, group.chWidth), GetAggregation (station) && !station->m_isSampling, false);
---
>       return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), group.sgi ? 400 : 800, GetNumberOfAntennas (), group.streams, GetNess (station), GetChannelWidthForTransmission (mode, group.chWidth), GetAggregation (station) && !station->m_isSampling, false);
871c885
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *) st;
938c952
<       return WifiTxVector (rtsRate, GetDefaultTxPowerLevel (), GetPreambleForTransmission (rtsRate.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))),
---
>       return WifiTxVector (rtsRate, GetDefaultTxPowerLevel (), GetPreambleForTransmission (rtsRate, GetAddress (station)),
948c962
<   MinstrelHtWifiRemoteStation *station = static_cast<MinstrelHtWifiRemoteStation*> (st);
---
>   MinstrelHtWifiRemoteStation *station = (MinstrelHtWifiRemoteStation *)st;
1001a1016,1021
> bool
> MinstrelHtWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
1273c1293
<   * Do not account throughput if probability of success is below 10%
---
>   * Do not account throughput if success prob is below 10%
1436c1456
<               && !(!GetShortGuardIntervalSupported (station) && m_minstrelGroups[groupId].sgi)    ///Is SGI supported by the receiver?
---
>               && !(!GetShortGuardInterval (station) && m_minstrelGroups[groupId].sgi)             ///Is SGI supported by the receiver?
1608,1614d1627
<   if (!station->m_statsFile.is_open ())
<     {
<       std::ostringstream tmp;
<       tmp << "minstrel-ht-stats-" << station->m_state->m_address << ".txt";
<       station->m_statsFile.open (tmp.str ().c_str (), std::ios::out);
<     }
< 
1816a1830,1839
> }
> 
> void
> MinstrelHtWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported yet by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/minstrel-ht-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/minstrel-ht-wifi-manager.h
31d30
< #include "wifi-mpdu-type.h"
48,49c47,48
<   uint8_t streams;  ///< streams
<   uint8_t sgi;      ///< short guard interval (0 or 1)
---
>   uint8_t streams; ///< streams
>   uint8_t sgi; ///< short guard interval (0 or 1)
51c50
<   bool isVht;       ///< is VHT?
---
>   bool isVht; ///< is VHT?
55c54
<   TxTime ratesTxTimeTable;          ///< rates transmit time table
---
>   TxTime ratesTxTimeTable; ///< rates transmit time table
96c95
<   double throughput;            //!< Throughput of this rate (in packets per second).
---
>   double throughput;            //!< Throughput of this rate (in pkts per second).
116,118c115,117
<   uint16_t m_maxTpRate;           //!< The max throughput rate of this group in bps.
<   uint16_t m_maxTpRate2;          //!< The second max throughput rate of this group in bps.
<   uint16_t m_maxProbRate;         //!< The highest success probability rate of this group in bps.
---
>   uint16_t m_maxTpRate;           //!< The max throughput rate of this group.
>   uint16_t m_maxTpRate2;          //!< The second max throughput rate of this group.
>   uint16_t m_maxProbRate;         //!< The highest success probability rate of this group.
132c131
< static const uint8_t MAX_SUPPORTED_STREAMS = 4;  //!< Maximal number of streams supported by the PHY layer.
---
> static const uint8_t MAX_SUPPORTED_STREAMS = 4;  //!< Maximal number of streams supported by the phy layer.
137,138c136,137
< static const uint8_t MAX_HT_WIDTH = 40;          //!< Maximal channel width in MHz.
< static const uint8_t MAX_VHT_WIDTH = 160;        //!< Maximal channel width in MHz.
---
> static const uint8_t MAX_HT_WIDTH = 40;          //!< Maximal channel width.
> static const uint8_t MAX_VHT_WIDTH = 160;        //!< Maximal channel width.
150c149
<  * was correctly transmitted (an Ack is received) or a frame transmission
---
>  * was correctly transmitted (an ACK is received) or a frame transmission
181c180
<  * When this rate control is configured but non-legacy modes are not supported,
---
>  * When this rate control is configured but HT and VHT are not supported,
183,186d181
<  *
<  * This RAA does not support HE modes yet and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11ax or higher.
211a207
>   void SetHeSupported (bool enable); //HE rates not yet supported
232,233c228,229
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
238,239c234,237
<   void DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                               double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportAmpduTxStatus (WifiRemoteStation *station,
>                               uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
>                               double rxSnr, double dataSnr);
>   bool IsLowLatency (void) const;
245c243
<    * \param phy pointer to the wifi PHY
---
>    * \param phy pointer to the wifi phy
256c254,266
<    * \param phy pointer to the wifi PHY
---
>    * \param phy pointer to the wifi phy
>    * \param streams the number of streams
>    * \param sgi short guard interval enabled (0 or 1)
>    * \param chWidth the channel width (MHz)
>    * \param mode the wifi mode
>    * \returns the transmit time
>    */
>   Time CalculateMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi, uint16_t chWidth, WifiMode mode);
> 
>   /**
>    * Estimates the TxTime of a frame with a given mode and group (stream, guard interval and channel width).
>    *
>    * \param phy pointer to the wifi phy
261d270
<    * \param mpduType the type of the MPDU
264,265c273
<   Time CalculateMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi,
<                                 uint16_t chWidth, WifiMode mode, MpduType mpduType);
---
>   Time CalculateFirstMpduTxDuration (Ptr<WifiPhy> phy, uint8_t streams, uint8_t sgi, uint16_t chWidth, WifiMode mode);
268c276
<    * Obtain the TxTime saved in the group information.
---
>    * Obtain the TXtime saved in the group information.
286c294
<    * Obtain the TxTime saved in the group information.
---
>    * Obtain the TXtime saved in the group information.
313,314c321,322
<    * \param nSuccessfulMpdus the number of successfully received MPDUs
<    * \param nFailedMpdus the number of failed MPDUs
---
>    * \param nSuccessfulMpdus
>    * \param nFailedMpdus
337c345
<    * \returns the rate in bps
---
>    * \returns the rate
342c350
<    * Update the Minstrel Table every 1/10 seconds.
---
>    * Updating the Minstrel Table every 1/10 seconds.
361,362c369,370
<    * \param ewmaProb the EWMA probability
<    * \returns the throughput in bps
---
>    * \param ewmaProb
>    * \returns the throughput
411,412c419,420
<    *  - Ack timeouts
<    *  - Data transmission
---
>    *  - ACK timeouts
>    *  - DATA transmission
522c530
<    * Returns the groupId of a HT MCS with the given number of streams, if using SGI and the channel width used.
---
>    * Returns the groupId of a HT MCS with the given number of streams, if using sgi and the channel width used.
532c540
<    * Returns the groupId of a VHT MCS with the given number of streams, if using SGI and the channel width used.
---
>    * Returns the groupId of a VHT MCS with the given number of streams, if using sgi and the channel width used.
574c582
<   uint32_t m_frameLength;    //!< Frame length used for calculate modes TxTime in bytes.
---
>   uint32_t m_frameLength;    //!< Frame length used for calculate modes TxTime.
diff ../../NS3-WiGig/src/wifi/model/minstrel-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/minstrel-wifi-manager.cc
62c62
<                    "The percentage to try other rates",
---
>                    "the percentage to try other rates",
135,152d134
< void
< MinstrelWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
218a201,203
>       std::ostringstream tmp;
>       tmp << "minstrel-stats-" << station->m_state->m_address << ".txt";
>       station->m_statsFile.open (tmp.str ().c_str (), std::ios::out);
232c217
<  *  4  | Lowest base rate | Lowest base rate  | Lowest base rate
---
>  *  4  | Lowest Baserate  | Lowest baserate   | Lowest baserate
371a357
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
384c370
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
394a381
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
407c394
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
482c469
<        * Decide if direct ( 1st MRR stage) or indirect (2nd MRR stage)
---
>        * Decide if direct ( 1st mrr stage) or indirect (2nd mrr stage)
559c546
<       //calculate the perfect TX time for this rate
---
>       //calculate the perfect tx time for this rate
591c578
<               //EWMA probability (cast for gcc 3.4 compatibility)
---
>               //ewma probability (cast for gcc 3.4 compatibility)
648c635
<   //go find max throughput, second maximum throughput, high probability of success
---
>   //go find max throughput, second maximum throughput, high probability succ
717c704
<   NS_LOG_DEBUG ("DoReportRxOk m_txrate=" << static_cast<MinstrelWifiRemoteStation*> (st)->m_txrate);
---
>   NS_LOG_DEBUG ("DoReportRxOk m_txrate=" << ((MinstrelWifiRemoteStation *)st)->m_txrate);
724c711
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *)st;
739c726
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *)st;
747c734
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *)st;
759,760c746,747
< MinstrelWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                      double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> MinstrelWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                      double ackSnr, WifiMode ackMode, double dataSnr)
762,763c749,750
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *) st;
794c781
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *) st;
858c845
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *) st;
866c853
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *) st;
874c861
<   MinstrelWifiRemoteStation *station = static_cast<MinstrelWifiRemoteStation*> (st);
---
>   MinstrelWifiRemoteStation *station = (MinstrelWifiRemoteStation *)st;
892a880,885
> bool
> MinstrelWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
938c931
<       //at least one retry is permitted.
---
>       //at least one retry is permitter.
964c957
<   //First transmission (Data + Ack timeout)
---
>   //First transmission (DATA + ACK timeout)
971c964
<       //Add one re-transmission (Data + Ack timeout)
---
>       //Add one re-transmission (DATA + ACK timeout)
975c968
<       tt += (cw / 2.0) * GetMac ()->GetSlot ();
---
>       tt += NanoSeconds ((cw / 2) * GetMac ()->GetSlot ());
1035,1041d1027
<   if (!station->m_statsFile.is_open ())
<     {
<       std::ostringstream tmp;
<       tmp << "minstrel-stats-" << station->m_state->m_address << ".txt";
<       station->m_statsFile.open (tmp.str ().c_str (), std::ios::out);
<     }
< 
1097a1084,1113
> }
> 
> void
> MinstrelWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> MinstrelWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> MinstrelWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/minstrel-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/minstrel-wifi-manager.h
48,49c48,49
<   uint32_t numRateSuccess;      ///< number of successful packets
<   uint32_t prob;                ///< (# packets success)/(# total packets)
---
>   uint32_t numRateSuccess;      ///< number of successful pkts
>   uint32_t prob;                ///< (# pkts success )/(# total pkts)
55c55
<   uint32_t throughput;  ///< throughput of a rate in bps
---
>   uint32_t throughput;  ///< throughput of a rate
90c90
<    * then we wrap back to the row 1 column 1.
---
>    * then we wrap back to the row 1 col 1.
93c93
<   uint8_t m_col;                 ///< column index
---
>   uint8_t m_col;                 ///< vector index
95,97c95,97
<   uint16_t m_maxTpRate;          ///< the current throughput rate in bps
<   uint16_t m_maxTpRate2;         ///< second highest throughput rate in bps
<   uint16_t m_maxProbRate;        ///< rate with highest probability of success in bps
---
>   uint16_t m_maxTpRate;          ///< the current throughput rate
>   uint16_t m_maxTpRate2;         ///< second highest throughput rate
>   uint16_t m_maxProbRate;        ///< rate with highest prob of success
101c101
<   int m_numSamplesDeferred;      ///< number samples deferred
---
>   int m_numSamplesDeferred;      ///< number samles deferred
103c103
<   uint16_t m_sampleRate;         ///< current sample rate in bps
---
>   uint16_t m_sampleRate;         ///< current sample rate
105c105
<   uint32_t m_shortRetry;         ///< short retries such as control packets
---
>   uint32_t m_shortRetry;         ///< short retries such as control packts
108c108
<   uint16_t m_txrate;             ///< current transmit rate in bps
---
>   uint16_t m_txrate;             ///< current transmit rate
127,128c127,128
<  * Minstrel is appropriate for non-HT configurations; for HT (i.e. 802.11n
<  * or higher), users should use MinstrelHtWifiManager instead.
---
>  * Minstrel is appropriate for non-HT/VHT/HE configurations; for HT/VHT/HE
>  * (i.e. 802.11n/ac/ax), users should use MinstrelHtWifiManager instead.
130c130
<  * Wi-Fi MAC that supports 802.11n or higher.
---
>  * Wi-Fi MAC that has VhtSupported, HtSupported or HeSupported set.
170a171,173
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
184c187
<    * Update the rate.
---
>    * updating the rate
191c194
<    * Update the Minstrel Table every 1/10 seconds.
---
>    * updating the Minstrel Table every 1/10 seconds
198c201
<    * Find a rate to use from Minstrel Table.
---
>    * find a rate to use from Minstrel Table
201c204
<    * \returns the rate in bps
---
>    * \returns the rate
206c209
<    * Get data transmit vector.
---
>    * Get data transmit vector
214c217
<    * Get RTS transmit vector.
---
>    * Get RTS transmit vector
222c225
<    * Get the number of retries.
---
>    * Count retries
225c228
<    * \returns the number of retries
---
>    * \returns the number if retries
230c233
<    * Update packet counters.
---
>    * Update packet counters
237c240
<    * Update the number of retries and reset accordingly.
---
>    * update the number of retries and reset accordingly
244c247
<    * Check for initializations.
---
>    * check for initializations
251c254
<    * Initialize Sample Table.
---
>    * initialize Sample Table
258,259c261
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
267,268c269,270
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
276a279
>   bool IsLowLatency (void) const;
279c282
<    * Estimate the TxTime of a packet with a given mode.
---
>    * for estimating the TxTime of a packet with a given mode
294c297
<    * Initialize Minstrel Table.
---
>    * initialize Minstrel Table
301c304
<    * Get the next sample from Sample Table.
---
>    * getting the next sample from Sample Table
320,321c323,324
<    *  - Ack timeouts
<    *  - Data transmission
---
>    *  - ACK timeouts
>    *  - DATA transmission
332c335
<    * Print Sample Table.
---
>    * printing Sample Table
339c342
<    * Print Minstrel Table.
---
>    * printing Minstrel Table
350c353
<   typedef std::map<WifiMode, Time> TxTime;
---
>   typedef std::map<WifiMode,Time> TxTime;
diff ../../NS3-WiGig/src/wifi/model/mpdu-aggregator.cc ../../ns-3-dev-git/src/wifi/model/mpdu-aggregator.cc
19d18
<  *         Stefano Avallone <stavallo@unina.it>
26,39d24
< #include "wifi-phy.h"
< #include "wifi-tx-vector.h"
< #include "wifi-remote-station-manager.h"
< #include "mac-low.h"
< #include "wifi-mac-queue-item.h"
< #include "wifi-mac-queue.h"
< #include "msdu-aggregator.h"
< #include "wifi-net-device.h"
< #include "ht-capabilities.h"
< #include "vht-capabilities.h"
< #include "he-capabilities.h"
< #include "wifi-mac.h"
< #include "ctrl-headers.h"
< #include "wifi-mac-trailer.h"
67c52
< MpduAggregator::SetEdcaQueues (EdcaQueues edcaQueues)
---
> MpduAggregator::SetMaxAmpduSize (uint16_t maxSize)
69c54
<     m_edca = edcaQueues;
---
>   m_maxAmpduLength = maxSize;
72,73c57,58
< void
< MpduAggregator::Aggregate (Ptr<const WifiMacQueueItem> mpdu, Ptr<Packet> ampdu, bool isSingle)
---
> uint16_t
> MpduAggregator::GetMaxAmpduSize (void) const
75,78c60,61
<   NS_LOG_FUNCTION (mpdu << ampdu << isSingle);
<   NS_ASSERT (ampdu);
<   // if isSingle is true, then ampdu must be empty
<   NS_ASSERT (!isSingle || ampdu->GetSize () == 0);
---
>   return m_maxAmpduLength;
> }
80,83c63,71
<   // pad the previous A-MPDU subframe if the A-MPDU is not empty
<   if (ampdu->GetSize () > 0)
<     {
<       uint8_t padding = CalculatePadding (ampdu->GetSize ());
---
> bool
> MpduAggregator::Aggregate (Ptr<const Packet> packet, Ptr<Packet> aggregatedPacket) const
> {
>   NS_LOG_FUNCTION (this);
>   Ptr<Packet> currentPacket;
>   AmpduSubframeHeader currentHdr;
> 
>   uint8_t padding = CalculatePadding (aggregatedPacket);
>   uint32_t actualSize = aggregatedPacket->GetSize ();
84a73,74
>   if ((4 + packet->GetSize () + actualSize + padding) <= GetMaxAmpduSize ())
>     {
88c78
<           ampdu->AddAtEnd (pad);
---
>           aggregatedPacket->AddAtEnd (pad);
90,98c80,81
<     }
< 
<   // add MPDU header and trailer
<   Ptr<Packet> tmp = mpdu->GetPacket ()->Copy ();
<   tmp->AddHeader (mpdu->GetHeader ());
<   AddWifiMacTrailer (tmp);
< 
<   // add A-MPDU subframe header and MPDU to the A-MPDU
<   AmpduSubframeHeader hdr = GetAmpduSubframeHeader (static_cast<uint16_t> (tmp->GetSize ()), isSingle);
---
>       currentHdr.SetLength (static_cast<uint16_t> (packet->GetSize ()));
>       currentPacket = packet->Copy ();
100,101c83,87
<   tmp->AddHeader (hdr);
<   ampdu->AddAtEnd (tmp);
---
>       currentPacket->AddHeader (currentHdr);
>       aggregatedPacket->AddAtEnd (currentPacket);
>       return true;
>     }
>   return false;
104,105c90,91
< uint32_t
< MpduAggregator::GetSizeIfAggregated (uint32_t mpduSize, uint32_t ampduSize)
---
> void
> MpduAggregator::AggregateSingleMpdu (Ptr<const Packet> packet, Ptr<Packet> aggregatedPacket) const
107,126c93,95
<   NS_LOG_FUNCTION (mpduSize << ampduSize);
< 
<   return ampduSize + CalculatePadding (ampduSize) + 4 + mpduSize;
< }
< 
< uint32_t
< MpduAggregator::GetMaxAmpduSize (Mac48Address recipient, uint8_t tid,
<                                  WifiModulationClass modulation) const
< {
<   NS_LOG_FUNCTION (this << recipient << +tid << modulation);
< 
<   AcIndex ac = QosUtilsMapTidToAc (tid);
<   Ptr<QosTxop> qosTxop = m_edca.find (ac)->second;
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (qosTxop->GetLow ()->GetPhy ()->GetDevice ());
<   NS_ASSERT (device);
<   Ptr<WifiRemoteStationManager> stationManager = device->GetRemoteStationManager ();
<   NS_ASSERT (stationManager);
< 
<   // Find the A-MPDU max size configured on this device
<   UintegerValue size;
---
>   NS_LOG_FUNCTION (this);
>   Ptr<Packet> currentPacket;
>   AmpduSubframeHeader currentHdr;
128c97,98
<   switch (ac)
---
>   uint8_t padding = CalculatePadding (aggregatedPacket);
>   if (padding)
130,144c100,101
<       case AC_BE:
<         device->GetMac ()->GetAttribute ("BE_MaxAmpduSize", size);
<         break;
<       case AC_BK:
<         device->GetMac ()->GetAttribute ("BK_MaxAmpduSize", size);
<         break;
<       case AC_VI:
<         device->GetMac ()->GetAttribute ("VI_MaxAmpduSize", size);
<         break;
<       case AC_VO:
<         device->GetMac ()->GetAttribute ("VO_MaxAmpduSize", size);
<         break;
<       default:
<         NS_ABORT_MSG ("Unknown AC " << ac);
<         return 0;
---
>       Ptr<Packet> pad = Create<Packet> (padding);
>       aggregatedPacket->AddAtEnd (pad);
147c104,116
<   uint32_t maxAmpduSize = size.Get ();
---
>   currentHdr.SetEof (1);
>   currentHdr.SetLength (static_cast<uint16_t> (packet->GetSize ()));
>   currentPacket = packet->Copy ();
> 
>   currentPacket->AddHeader (currentHdr);
>   aggregatedPacket->AddAtEnd (currentPacket);
> }
> 
> void
> MpduAggregator::AddHeaderAndPad (Ptr<Packet> packet, bool last, bool isSingleMpdu) const
> {
>   NS_LOG_FUNCTION (this);
>   AmpduSubframeHeader currentHdr;
149c118,121
<   if (maxAmpduSize == 0)
---
>   //This is called to prepare packets from the aggregate queue to be sent so no need to check total size since it has already been
>   //done before when deciding how many packets to add to the queue
>   currentHdr.SetLength (static_cast<uint16_t> (packet->GetSize ()));
>   if (isSingleMpdu)
151,152c123
<       NS_LOG_DEBUG ("A-MPDU Aggregation is disabled on this station for AC " << ac);
<       return 0;
---
>       currentHdr.SetEof (1);
155,169c126,127
<   // Retrieve the Capabilities elements advertised by the recipient
<   //// WIGIG ////
<   Ptr<const EdmgCapabilities> edmgCapabilities = stationManager->GetStationEdmgCapabilities (recipient);
<   Ptr<const DmgCapabilities> dmgCapabilities = stationManager->GetStationDmgCapabilities (recipient);
<   //// WIGIG ////
<   Ptr<const HeCapabilities> heCapabilities = stationManager->GetStationHeCapabilities (recipient);
<   Ptr<const VhtCapabilities> vhtCapabilities = stationManager->GetStationVhtCapabilities (recipient);
<   Ptr<const HtCapabilities> htCapabilities = stationManager->GetStationHtCapabilities (recipient);
< 
<   // Determine the constraint imposed by the recipient based on the PPDU
<   // format used to transmit the A-MPDU
<   //// WIGIG ////
<   if ((modulation == WIFI_MOD_CLASS_EDMG_SC) || (modulation == WIFI_MOD_CLASS_EDMG_OFDM))
<     {
<       NS_ABORT_MSG_IF (!edmgCapabilities, "EDMG Capabilities element not received");
---
>   packet->AddHeader (currentHdr);
>   uint32_t padding = CalculatePadding (packet);
171,173c129
<       maxAmpduSize = std::min (maxAmpduSize, edmgCapabilities->GetMaxAmpduLength ());
<     }
<   else if ((modulation == WIFI_MOD_CLASS_DMG_SC) || (modulation == WIFI_MOD_CLASS_DMG_OFDM))
---
>   if (padding && !last)
175,177c131,132
<       NS_ABORT_MSG_IF (!dmgCapabilities, "DMG Capabilities element not received");
< 
<       maxAmpduSize = std::min (maxAmpduSize, dmgCapabilities->GetMaxAmpduLength ());
---
>       Ptr<Packet> pad = Create<Packet> (padding);
>       packet->AddAtEnd (pad);
179,182c134
<   //// WIGIG ////
<   else if (modulation == WIFI_MOD_CLASS_HE)
<     {
<       NS_ABORT_MSG_IF (!heCapabilities, "HE Capabilities element not received");
---
> }
184,186c136,141
<       maxAmpduSize = std::min (maxAmpduSize, heCapabilities->GetMaxAmpduLength ());
<     }
<   else if (modulation == WIFI_MOD_CLASS_VHT)
---
> bool
> MpduAggregator::CanBeAggregated (uint32_t packetSize, Ptr<Packet> aggregatedPacket, uint8_t blockAckSize) const
> {
>   uint8_t padding = CalculatePadding (aggregatedPacket);
>   uint32_t actualSize = aggregatedPacket->GetSize ();
>   if (blockAckSize > 0)
188,190c143
<       NS_ABORT_MSG_IF (!vhtCapabilities, "VHT Capabilities element not received");
< 
<       maxAmpduSize = std::min (maxAmpduSize, vhtCapabilities->GetMaxAmpduLength ());
---
>       blockAckSize = blockAckSize + 4 + padding;
192c145
<   else if (modulation == WIFI_MOD_CLASS_HT)
---
>   if ((4 + packetSize + actualSize + padding + blockAckSize) <= GetMaxAmpduSize ())
194,196c147
<       NS_ABORT_MSG_IF (!htCapabilities, "HT Capabilities element not received");
< 
<       maxAmpduSize = std::min (maxAmpduSize, htCapabilities->GetMaxAmpduLength ());
---
>       return true;
198c149
<   else  // non-HT PPDU
---
>   else
200,202c151
<       NS_LOG_DEBUG ("A-MPDU aggregation is not available for non-HT PHYs");
< 
<       maxAmpduSize = 0;
---
>       return false;
204,205d152
< 
<   return maxAmpduSize;
209,215c156
< MpduAggregator::CalculatePadding (uint32_t ampduSize)
< {
<   return (4 - (ampduSize % 4 )) % 4;
< }
< 
< AmpduSubframeHeader
< MpduAggregator::GetAmpduSubframeHeader (uint16_t mpduSize, bool isSingle)
---
> MpduAggregator::CalculatePadding (Ptr<const Packet> packet) const
217,223c158
<   AmpduSubframeHeader hdr;
<   hdr.SetLength (mpduSize);
<   if (isSingle)
<     {
<       hdr.SetEof (1);
<     }
<   return hdr;
---
>   return (4 - (packet->GetSize () % 4 )) % 4;
226,228c161,162
< std::vector<Ptr<WifiMacQueueItem>>
< MpduAggregator::GetNextAmpdu (Ptr<const WifiMacQueueItem> mpdu, WifiTxVector txVector,
<                               Time ppduDurationLimit) const
---
> MpduAggregator::DeaggregatedMpdus
> MpduAggregator::Deaggregate (Ptr<Packet> aggregatedPacket)
230,238c164,165
<   NS_LOG_FUNCTION (this << *mpdu << ppduDurationLimit);
<   std::vector<Ptr<WifiMacQueueItem>> mpduList;
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
< 
<   NS_ASSERT (mpdu->GetHeader ().IsQosData () && !recipient.IsBroadcast ());
< 
<   uint8_t tid = GetTid (mpdu->GetPacket (), mpdu->GetHeader ());
<   auto edcaIt = m_edca.find (QosUtilsMapTidToAc (tid));
<   NS_ASSERT (edcaIt != m_edca.end ());
---
>   NS_LOG_FUNCTION_NOARGS ();
>   DeaggregatedMpdus set;
240,247c167,180
<   WifiModulationClass modulation = txVector.GetMode ().GetModulationClass ();
<   uint32_t maxAmpduSize = GetMaxAmpduSize (recipient, tid, modulation);
< 
<   if (maxAmpduSize == 0)
<     {
<       NS_LOG_DEBUG ("A-MPDU aggregation disabled");
<       return mpduList;
<     }
---
>   AmpduSubframeHeader hdr;
>   Ptr<Packet> extractedMpdu = Create<Packet> ();
>   uint32_t maxSize = aggregatedPacket->GetSize ();
>   uint16_t extractedLength;
>   uint32_t padding;
>   uint32_t deserialized = 0;
> 
>   while (deserialized < maxSize)
>     {
>       deserialized += aggregatedPacket->RemoveHeader (hdr);
>       extractedLength = hdr.GetLength ();
>       extractedMpdu = aggregatedPacket->CreateFragment (0, static_cast<uint32_t> (extractedLength));
>       aggregatedPacket->RemoveAtStart (extractedLength);
>       deserialized += extractedLength;
249,256c182
<   //Have to make sure that the block ack agreement is established before sending an A-MPDU
<   if (edcaIt->second->GetBaAgreementEstablished (recipient, tid))
<     {
<       /* here is performed MPDU aggregation */
<       uint16_t startingSequenceNumber = edcaIt->second->GetBaStartingSequence (recipient, tid);
<       Ptr<WifiMacQueueItem> nextMpdu;
<       uint16_t maxMpdus = edcaIt->second->GetBaBufferSize (recipient, tid);
<       uint32_t currentAmpduSize = 0;
---
>       padding = (4 - (extractedLength % 4 )) % 4;
258,259c184
<       // check if the received MPDU meets the size and duration constraints
<       if (edcaIt->second->GetLow ()->IsWithinSizeAndTimeLimits (mpdu, txVector, 0, ppduDurationLimit))
---
>       if (padding > 0 && deserialized < maxSize)
261,262c186,187
<           // MPDU can be aggregated
<           nextMpdu = Copy (mpdu);
---
>           aggregatedPacket->RemoveAtStart (padding);
>           deserialized += padding;
265,312c190,191
<       while (nextMpdu != 0)
<         {
<           /* if we are here, nextMpdu can be aggregated to the A-MPDU.
<            * nextMpdu may be any of the following:
<            * (a) an A-MSDU (with all the constituent MSDUs dequeued from
<            *     the EDCA queue)
<            * (b) an MSDU dequeued from the EDCA queue
<            * (c) a retransmitted MSDU or A-MSDU dequeued from the BA Manager queue
<            * (d) an MPDU that was aggregated in an A-MPDU which was not
<            *     transmitted (e.g., because the RTS/CTS exchange failed)
<            */
< 
<           currentAmpduSize = GetSizeIfAggregated (nextMpdu->GetSize (), currentAmpduSize);
< 
<           NS_LOG_DEBUG ("Adding packet with sequence number " << nextMpdu->GetHeader ().GetSequenceNumber ()
<                         << " to A-MPDU, packet size = " << nextMpdu->GetSize ()
<                         << ", A-MPDU size = " << currentAmpduSize);
< 
<           // Always use the Normal Ack policy (Implicit Block Ack), for now
<           nextMpdu->GetHeader ().SetQosAckPolicy (WifiMacHeader::NORMAL_ACK);
< 
<           mpduList.push_back (nextMpdu);
< 
<           // If allowed by the BA agreement, get the next MPDU
<           nextMpdu = 0;
< 
<           Ptr<const WifiMacQueueItem> peekedMpdu;
<           peekedMpdu = edcaIt->second->PeekNextFrame (tid, recipient);
<           if (peekedMpdu != 0)
<             {
<               uint16_t currentSequenceNumber = peekedMpdu->GetHeader ().GetSequenceNumber ();
< 
<               if (IsInWindow (currentSequenceNumber, startingSequenceNumber, maxMpdus))
<                 {
<                   // dequeue the frame if constraints on size and duration limit are met.
<                   // Note that the dequeued MPDU differs from the peeked MPDU if A-MSDU
<                   // aggregation is performed during the dequeue
<                   NS_LOG_DEBUG ("Trying to aggregate another MPDU");
<                   nextMpdu = edcaIt->second->DequeuePeekedFrame (peekedMpdu, txVector, true,
<                                                                  currentAmpduSize, ppduDurationLimit);
<                 }
<             }
<         }
<       if (mpduList.size () == 1)
<         {
<           // return an empty vector if it was not possible to aggregate at least two MPDUs
<           mpduList.clear ();
<         }
---
>       std::pair<Ptr<Packet>, AmpduSubframeHeader> packetHdr (extractedMpdu, hdr);
>       set.push_back (packetHdr);
314c193,194
<   return mpduList;
---
>   NS_LOG_INFO ("Deaggreated A-MPDU: extracted " << set.size () << " MPDUs");
>   return set;
diff ../../NS3-WiGig/src/wifi/model/mpdu-aggregator.h ../../ns-3-dev-git/src/wifi/model/mpdu-aggregator.h
1,154c1,132
< /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
< /*
<  * Copyright (c) 2013
<  *
<  * This program is free software; you can redistribute it and/or modify
<  * it under the terms of the GNU General Public License version 2 as
<  * published by the Free Software Foundation;
<  *
<  * This program is distributed in the hope that it will be useful,
<  * but WITHOUT ANY WARRANTY; without even the implied warranty of
<  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<  * GNU General Public License for more details.
<  *
<  * You should have received a copy of the GNU General Public License
<  * along with this program; if not, write to the Free Software
<  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
<  *
<  * Author: Ghada Badawy <gbadawy@gmail.com>
<  */
< 
< #ifndef MPDU_AGGREGATOR_H
< #define MPDU_AGGREGATOR_H
< 
< #include "ns3/object.h"
< #include "wifi-mode.h"
< #include "qos-txop.h"
< #include "ns3/nstime.h"
< #include <vector>
< 
< namespace ns3 {
< 
< class AmpduSubframeHeader;
< class WifiTxVector;
< class Packet;
< class WifiMacQueueItem;
< 
< /**
<  * \brief Aggregator used to construct A-MPDUs
<  * \ingroup wifi
<  */
< class MpduAggregator : public Object
< {
< public:
<   /**
<    * EDCA queues typedef
<    */
<   typedef std::map<AcIndex, Ptr<QosTxop> > EdcaQueues;
< 
< 
<   /**
<    * \brief Get the type ID.
<    * \return the object TypeId
<    */
<   static TypeId GetTypeId (void);
< 
<   MpduAggregator ();
<   virtual ~MpduAggregator ();
< 
<   /**
<    * Aggregate an MPDU to an A-MPDU.
<    *
<    * \param mpdu the MPDU.
<    * \param ampdu the A-MPDU.
<    * \param isSingle whether it is a single MPDU.
<    */
<   static void Aggregate (Ptr<const WifiMacQueueItem> mpdu, Ptr<Packet> ampdu, bool isSingle);
< 
<   /**
<    * Compute the size of the A-MPDU resulting from the aggregation of an MPDU of
<    * size <i>mpduSize</i> and an A-MPDU of size <i>ampduSize</i>.
<    *
<    * \param mpduSize the MPDU size in bytes.
<    * \param ampduSize the A-MPDU size in bytes.
<    * \return the size of the resulting A-MPDU in bytes.
<    */
<   static uint32_t GetSizeIfAggregated (uint32_t mpduSize, uint32_t ampduSize);
< 
<   /**
<    * Determine the maximum size for an A-MPDU of the given TID that can be sent
<    * to the given receiver when using the given modulation class.
<    *
<    * \param recipient the receiver station address.
<    * \param tid the TID.
<    * \param modulation the modulation class.
<    * \return the maximum A-MPDU size in bytes.
<    */
<   uint32_t GetMaxAmpduSize (Mac48Address recipient, uint8_t tid,
<                             WifiModulationClass modulation) const;
< 
<   /**
<    * Attempt to aggregate other MPDUs to the given MPDU, while meeting the
<    * following constraints:
<    *
<    * - the size of the resulting A-MPDU does not exceed the maximum A-MPDU size
<    * as determined for the modulation class indicated by the given TxVector
<    *
<    * - the time to transmit the resulting PPDU, according to the given TxVector,
<    * does not exceed both the maximum PPDU duration allowed by the corresponding
<    * modulation class (if any) and the given PPDU duration limit (if distinct from
<    * Time::Min ())
<    *
<    * For now, only non-broadcast QoS Data frames can be aggregated (do not pass
<    * other types of frames to this method). MPDUs to aggregate are looked for
<    * among those with the same TID and receiver as the given MPDU.
<    *
<    * The resulting A-MPDU is returned as a vector of the constituent MPDUs
<    * (including the given MPDU), which are not actually aggregated (call the
<    * Aggregate method afterwards to get the actual A-MPDU). If aggregation was
<    * not possible (aggregation is disabled, there is no Block Ack agreement
<    * established with the receiver, or another MPDU to aggregate was not found),
<    * the returned vector is empty.
<    *
<    * \param mpdu the given MPDU.
<    * \param txVector the TxVector used to transmit the frame
<    * \param ppduDurationLimit the limit on the PPDU duration
<    * \return the resulting A-MPDU, if aggregation is possible.
<    */
<   std::vector<Ptr<WifiMacQueueItem>> GetNextAmpdu (Ptr<const WifiMacQueueItem> mpdu,
<                                                    WifiTxVector txVector,
<                                                    Time ppduDurationLimit = Time::Min ()) const;
< 
<   /**
<    * Set the map of EDCA queues.
<    *
<    * \param edcaQueues the map of EDCA queues.
<    */
<   void SetEdcaQueues (EdcaQueues edcaQueues);
< 
<   /**
<    * \param ampduSize the size of the A-MPDU that needs to be padded in bytes
<    * \return the size of the padding that must be added to the end of an A-MPDU in bytes
<    *
<    * Calculates how much padding must be added to the end of an A-MPDU of the given size
<    * (once another MPDU is aggregated).
<    * Each A-MPDU subframe is padded so that its length is multiple of 4 octets.
<    */
<   static uint8_t CalculatePadding (uint32_t ampduSize);
< 
<   /**
<    * Get the A-MPDU subframe header corresponding to the MPDU size and
<    * whether the MPDU is a single MPDU.
<    *
<    * \param mpduSize size of the MPDU in bytes.
<    * \param isSingle true if S-MPDU.
<    */
<   static AmpduSubframeHeader GetAmpduSubframeHeader (uint16_t mpduSize, bool isSingle);
< 
< private:
<   EdcaQueues m_edca;   //!< the map of EDCA queues
< };
< 
< }  //namespace ns3
< 
< #endif /* MPDU_AGGREGATOR_H */
---
> /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
> /*
>  * Copyright (c) 2013
>  *
>  * This program is free software; you can redistribute it and/or modify
>  * it under the terms of the GNU General Public License version 2 as
>  * published by the Free Software Foundation;
>  *
>  * This program is distributed in the hope that it will be useful,
>  * but WITHOUT ANY WARRANTY; without even the implied warranty of
>  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>  * GNU General Public License for more details.
>  *
>  * You should have received a copy of the GNU General Public License
>  * along with this program; if not, write to the Free Software
>  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
>  *
>  * Author: Ghada Badawy <gbadawy@gmail.com>
>  */
> 
> #ifndef MPDU_AGGREGATOR_H
> #define MPDU_AGGREGATOR_H
> 
> #include "ns3/object.h"
> 
> namespace ns3 {
> 
> class AmpduSubframeHeader;
> class WifiMacHeader;
> class Packet;
> 
> /**
>  * \brief Aggregator used to construct A-MPDUs
>  * \ingroup wifi
>  */
> class MpduAggregator : public Object
> {
> public:
>   /**
>    * A list of deaggregated packets and their A-MPDU subframe headers.
>    */
>   typedef std::list<std::pair<Ptr<Packet>, AmpduSubframeHeader> > DeaggregatedMpdus;
>   /**
>    * A constant iterator for a list of deaggregated packets and their A-MPDU subframe headers.
>    */
>   typedef std::list<std::pair<Ptr<Packet>, AmpduSubframeHeader> >::const_iterator DeaggregatedMpdusCI;
> 
>   /**
>    * \brief Get the type ID.
>    * \return the object TypeId
>    */
>   static TypeId GetTypeId (void);
> 
>   MpduAggregator ();
>   virtual ~MpduAggregator ();
> 
>   /**
>    * Sets the maximum A-MPDU size in bytes.
>    * Value 0 means that MPDU aggregation is disabled.
>    *
>    * \param maxSize the maximum A-MPDU size in bytes.
>    */
>   void SetMaxAmpduSize (uint16_t maxSize);
>   /**
>    * Returns the maximum A-MPDU size in bytes.
>    * Value 0 means that MPDU aggregation is disabled.
>    *
>    * \return the maximum A-MPDU size in bytes.
>    */
>   uint16_t GetMaxAmpduSize (void) const;
> 
>   /**
>    * \param packet Packet we have to insert into <i>aggregatedPacket</i>.
>    * \param aggregatedPacket Packet that will contain <i>packet</i>, if aggregation is possible.
>    *
>    * \return true if <i>packet</i> can be aggregated to <i>aggregatedPacket</i>, false otherwise.
>    *
>    * Adds <i>packet</i> to <i>aggregatedPacket</i>. In concrete aggregator's implementation is
>    * specified how and if <i>packet</i> can be added to <i>aggregatedPacket</i>.
>    */
>   bool Aggregate (Ptr<const Packet> packet, Ptr<Packet> aggregatedPacket) const;
>   /**
>    * \param packet the packet we want to insert into <i>aggregatedPacket</i>.
>    * \param aggregatedPacket packet that will contain the packet of size <i>packetSize</i>, if aggregation is possible.
>    *
>    * This method performs a VHT/HE single MPDU aggregation.
>    */
>   void AggregateSingleMpdu (Ptr<const Packet> packet, Ptr<Packet> aggregatedPacket) const;
>   /**
>    * \param packet the packet we want to insert into <i>aggregatedPacket</i>.
>    * \param last true if it is the last packet.
>    * \param isSingleMpdu true if it is a single MPDU
>    *
>    * Adds A-MPDU subframe header and padding to each MPDU that is part of an A-MPDU before it is sent.
>    */
>   void AddHeaderAndPad (Ptr<Packet> packet, bool last, bool isSingleMpdu) const;
>   /**
>    * \param packetSize size of the packet we want to insert into <i>aggregatedPacket</i>.
>    * \param aggregatedPacket packet that will contain the packet of size <i>packetSize</i>, if aggregation is possible.
>    * \param blockAckSize size of the piggybacked block ack request
>    *
>    * \return true if the packet of size <i>packetSize</i> can be aggregated to <i>aggregatedPacket</i>, false otherwise.
>    *
>    * This method is used to determine if a packet could be aggregated to an A-MPDU without exceeding the maximum packet size.
>    */
>   bool CanBeAggregated (uint32_t packetSize, Ptr<Packet> aggregatedPacket, uint8_t blockAckSize) const;
> 
>   /**
>    * Deaggregates an A-MPDU by removing the A-MPDU subframe header and padding.
>    *
>    * \param aggregatedPacket the aggregated packet
>    * \return list of deaggragted packets and their A-MPDU subframe headers
>    */
>   static DeaggregatedMpdus Deaggregate (Ptr<Packet> aggregatedPacket);
> 
> 
> private:
>   /**
>    * \param packet the Packet
>    * \return padding that must be added to the end of an aggregated packet
>    *
>    * Calculates how much padding must be added to the end of an aggregated packet, after that a new packet is added.
>    * Each A-MPDU subframe is padded so that its length is multiple of 4 octets.
>    */
>   uint8_t CalculatePadding (Ptr<const Packet> packet) const;
> 
>   uint16_t m_maxAmpduLength; //!< Maximum length in bytes of A-MPDUs
> };
> 
> }  //namespace ns3
> 
> #endif /* MPDU_AGGREGATOR_H */
diff ../../NS3-WiGig/src/wifi/model/msdu-aggregator.cc ../../ns-3-dev-git/src/wifi/model/msdu-aggregator.cc
19d18
<  *         Stefano Avallone <stavallo@unina.it>
26,36d24
< #include "qos-txop.h"
< #include "mpdu-aggregator.h"
< #include "wifi-remote-station-manager.h"
< #include "mac-low.h"
< #include "wifi-phy.h"
< #include "wifi-net-device.h"
< #include "ht-capabilities.h"
< #include "wifi-mac.h"
< #include "wifi-mac-queue.h"
< #include "wifi-mac-trailer.h"
< #include <algorithm>
64c52
< MsduAggregator::SetEdcaQueues (EdcaQueues map)
---
> MsduAggregator::SetMaxAmsduSize (uint16_t maxSize)
66c54
<     m_edca = map;
---
>   m_maxAmsduLength = maxSize;
70c58
< MsduAggregator::GetSizeIfAggregated (uint16_t msduSize, uint16_t amsduSize)
---
> MsduAggregator::GetMaxAmsduSize (void) const
72,75c60
<   NS_LOG_FUNCTION (msduSize << amsduSize);
< 
<   // the size of the A-MSDU subframe header is 14 bytes: DA (6), SA (6) and Length (2)
<   return amsduSize + CalculatePadding (amsduSize) + 14 + msduSize;
---
>   return m_maxAmsduLength;
78,81c63,65
< Ptr<WifiMacQueueItem>
< MsduAggregator::GetNextAmsdu (Mac48Address recipient, uint8_t tid,
<                               WifiTxVector txVector, uint32_t ampduSize,
<                               Time ppduDurationLimit) const
---
> bool
> MsduAggregator::Aggregate (Ptr<const Packet> packet, Ptr<Packet> aggregatedPacket,
>                            Mac48Address src, Mac48Address dest) const
83,106c67,69
<   NS_LOG_FUNCTION (recipient << +tid << txVector << ampduSize << ppduDurationLimit);
< 
<   /* "The Address 1 field of an MPDU carrying an A-MSDU shall be set to an
<    * individual address or to the GCR concealment address" (Section 10.12
<    * of 802.11-2016)
<    */
<   NS_ABORT_MSG_IF (recipient.IsBroadcast (), "Recipient address is broadcast");
< 
<   Ptr<QosTxop> qosTxop = m_edca.find (QosUtilsMapTidToAc (tid))->second;
<   Ptr<WifiMacQueue> queue = qosTxop->GetWifiMacQueue ();
<   WifiMacQueue::ConstIterator peekedIt = queue->PeekByTidAndAddress (tid, recipient);
< 
<   if (peekedIt == queue->end ())
<     {
<       NS_LOG_DEBUG ("No packet with the given TID and address in the queue");
<       return 0;
<     }
< 
<   /* "A STA shall not transmit an A-MSDU within a QoS Data frame under a block
<    * ack agreement unless the recipient indicates support for A-MSDU by setting
<    * the A-MSDU Supported field to 1 in its BlockAck Parameter Set field of the
<    * ADDBA Response frame" (Section 10.12 of 802.11-2016)
<    */
<   // No check required for now, as we always set the A-MSDU Supported field to 1
---
>   NS_LOG_FUNCTION (this);
>   Ptr<Packet> currentPacket;
>   AmsduSubframeHeader currentHdr;
108c71,72
<   WifiModulationClass modulation = txVector.GetMode ().GetModulationClass ();
---
>   uint8_t padding = CalculatePadding (aggregatedPacket);
>   uint32_t actualSize = aggregatedPacket->GetSize ();
110,113c74
<   // Get the maximum size of the A-MSDU we can send to the recipient
<   uint16_t maxAmsduSize = GetMaxAmsduSize (recipient, tid, modulation);
< 
<   if (maxAmsduSize == 0)
---
>   if ((14 + packet->GetSize () + actualSize + padding) <= GetMaxAmsduSize ())
115,151c76
<       return 0;
<     }
< 
<   Ptr<WifiMacQueueItem> amsdu = Create<WifiMacQueueItem> (Create<const Packet> (), (*peekedIt)->GetHeader ());
<   uint8_t nMsdu = 0;
<   // We need to keep track of the first MSDU. When it is processed, it is not known
<   // if aggregation will succeed or not.
<   WifiMacQueue::ConstIterator first = peekedIt;
< 
<   // TODO Add support for the Max Number Of MSDUs In A-MSDU field in the Extended
<   // Capabilities element sent by the recipient
< 
<   while (peekedIt != queue->end ())
<     {
<       // check if aggregating the peeked MSDU violates the A-MSDU size limit
<       uint16_t newAmsduSize = GetSizeIfAggregated ((*peekedIt)->GetPacket ()->GetSize (),
<                                                    amsdu->GetPacket ()->GetSize ());
< 
<       if (newAmsduSize > maxAmsduSize)
<         {
<           NS_LOG_DEBUG ("No other MSDU can be aggregated: maximum A-MSDU size reached");
<           break;
<         }
< 
<       // check if the A-MSDU obtained by aggregating the peeked MSDU violates
<       // the A-MPDU size limit or the PPDU duration limit
<       if (!qosTxop->GetLow ()->IsWithinSizeAndTimeLimits (amsdu->GetHeader ().GetSize () + newAmsduSize
<                                                           + WIFI_MAC_FCS_LENGTH,
<                                                           recipient, tid, txVector, ampduSize, ppduDurationLimit))
<         {
<           NS_LOG_DEBUG ("No other MSDU can be aggregated");
<           break;
<         }
< 
<       // The MSDU can be aggregated to the A-MSDU.
<       // If it is the first MSDU, move to the next one
<       if (nMsdu == 0)
---
>       if (padding)
153,154c78,79
<           amsdu = Copy (*peekedIt);
<           peekedIt++;
---
>           Ptr<Packet> pad = Create<Packet> (padding);
>           aggregatedPacket->AddAtEnd (pad);
156,165c81,88
<       // otherwise, remove it from the queue
<       else
<         {
<           amsdu->Aggregate (*peekedIt);
<           peekedIt = queue->Remove (peekedIt);
<         }
< 
<       nMsdu++;
< 
<       peekedIt = queue->PeekByTidAndAddress (tid, recipient, peekedIt);
---
>       currentHdr.SetDestinationAddr (dest);
>       currentHdr.SetSourceAddr (src);
>       currentHdr.SetLength (static_cast<uint16_t> (packet->GetSize ()));
>       currentPacket = packet->Copy ();
> 
>       currentPacket->AddHeader (currentHdr);
>       aggregatedPacket->AddAtEnd (currentPacket);
>       return true;
167,177c90
< 
<   if (nMsdu < 2)
<     {
<       NS_LOG_DEBUG ("Aggregation failed (could not aggregate at least two MSDUs)");
<       return 0;
<     }
< 
<   // Aggregation succeeded, we have to remove the first MSDU
<   queue->Remove (first);
< 
<   return amsdu;
---
>   return false;
181c94
< MsduAggregator::CalculatePadding (uint16_t amsduSize)
---
> MsduAggregator::CalculatePadding (Ptr<const Packet> packet) const
183,283c96
<   return (4 - (amsduSize % 4 )) % 4;
< }
< 
< uint16_t
< MsduAggregator::GetMaxAmsduSize (Mac48Address recipient, uint8_t tid,
<                                  WifiModulationClass modulation) const
< {
<   NS_LOG_FUNCTION (this << recipient << +tid << modulation);
< 
<   AcIndex ac = QosUtilsMapTidToAc (tid);
<   Ptr<QosTxop> qosTxop = m_edca.find (ac)->second;
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (qosTxop->GetLow ()->GetPhy ()->GetDevice ());
<   NS_ASSERT (device);
<   Ptr<WifiRemoteStationManager> stationManager = device->GetRemoteStationManager ();
<   NS_ASSERT (stationManager);
< 
<   // Find the A-MSDU max size configured on this device
<   UintegerValue size;
< 
<   switch (ac)
<     {
<       case AC_BE:
<         device->GetMac ()->GetAttribute ("BE_MaxAmsduSize", size);
<         break;
<       case AC_BK:
<         device->GetMac ()->GetAttribute ("BK_MaxAmsduSize", size);
<         break;
<       case AC_VI:
<         device->GetMac ()->GetAttribute ("VI_MaxAmsduSize", size);
<         break;
<       case AC_VO:
<         device->GetMac ()->GetAttribute ("VO_MaxAmsduSize", size);
<         break;
<       default:
<         NS_ABORT_MSG ("Unknown AC " << ac);
<         return 0;
<     }
< 
<   uint16_t maxAmsduSize = size.Get ();
< 
<   if (maxAmsduSize == 0)
<     {
<       NS_LOG_DEBUG ("A-MSDU Aggregation is disabled on this station for AC " << ac);
<       return 0;
<     }
< 
<   // Retrieve the Capabilities elements advertised by the recipient
<   //// WIGIG ////
<   Ptr<const EdmgCapabilities> edmgCapabilities = stationManager->GetStationEdmgCapabilities (recipient);
<   Ptr<const DmgCapabilities> dmgCapabilities = stationManager->GetStationDmgCapabilities (recipient);
<   //// WIGIG ////
<   Ptr<const VhtCapabilities> vhtCapabilities = stationManager->GetStationVhtCapabilities (recipient);
<   Ptr<const HtCapabilities> htCapabilities = stationManager->GetStationHtCapabilities (recipient);
< 
<   //// WIGIG ////
<   if (dmgCapabilities || edmgCapabilities)
<     {
<       /* In IEEE 802.11ad/ay, DMG STAs do not negotiate the maximum size of an A-MSDU not the maximum length of an MPDU */
<       return maxAmsduSize;
<     }
<   //// WIGIG ////
< 
<   if (!htCapabilities)
<     {
<       /* "A non-DMG STA shall not transmit an A-MSDU to a STA from which it has
<        * not received a frame containing an HT Capabilities element" (Section
<        * 10.12 of 802.11-2016)
<        */
<       NS_LOG_DEBUG ("A-MSDU Aggregation disabled because the recipient did not"
<                     " send an HT Capabilities element");
<       return 0;
<     }
< 
<   // Determine the constraint imposed by the recipient based on the PPDU
<   // format used to transmit the A-MSDU
<   if (modulation >= WIFI_MOD_CLASS_VHT)
<     {
<       // the maximum A-MSDU size is indirectly constrained by the maximum MPDU
<       // size supported by the recipient and advertised in the VHT Capabilities
<       // element (see Table 9-19 of 802.11-2016 as amended by 802.11ax)
<       NS_ABORT_MSG_IF (!vhtCapabilities, "VHT Capabilities element not received");
< 
<       maxAmsduSize = std::min (maxAmsduSize, static_cast<uint16_t>(vhtCapabilities->GetMaxMpduLength () - 56));
<     }
<   else if (modulation == WIFI_MOD_CLASS_HT)
<     {
<       // the maximum A-MSDU size is constrained by the maximum A-MSDU size
<       // supported by the recipient and advertised in the HT Capabilities
<       // element (see Table 9-19 of 802.11-2016)
< 
<       maxAmsduSize = std::min (maxAmsduSize, htCapabilities->GetMaxAmsduLength ());
<     }
<   else  // non-HT PPDU
<     {
<       // the maximum A-MSDU size is indirectly constrained by the maximum PSDU size
<       // supported by the recipient (see Table 9-19 of 802.11-2016)
< 
<       maxAmsduSize = std::min (maxAmsduSize, static_cast<uint16_t>(3839));
<     }
< 
<   return maxAmsduSize;
---
>   return (4 - (packet->GetSize () % 4 )) % 4;
315c128
<       std::pair<Ptr<const Packet>, AmsduSubframeHeader> packetHdr (extractedMsdu, hdr);
---
>       std::pair<Ptr<Packet>, AmsduSubframeHeader> packetHdr (extractedMsdu, hdr);
diff ../../NS3-WiGig/src/wifi/model/msdu-aggregator.h ../../ns-3-dev-git/src/wifi/model/msdu-aggregator.h
25,28d24
< #include "ns3/nstime.h"
< #include "wifi-mode.h"
< #include "qos-utils.h"
< #include <map>
32a29
> class WifiMacHeader;
34,36d30
< class QosTxop;
< class WifiMacQueueItem;
< class WifiTxVector;
46c40
<   typedef std::list<std::pair<Ptr<const Packet>, AmsduSubframeHeader> > DeaggregatedMsdus;
---
>   typedef std::list<std::pair<Ptr<Packet>, AmsduSubframeHeader> > DeaggregatedMsdus;
48,50c42
<   typedef std::list<std::pair<Ptr<const Packet>, AmsduSubframeHeader> >::const_iterator DeaggregatedMsdusCI;
<   /// EDCA queues typedef
<   typedef std::map<AcIndex, Ptr<QosTxop> > EdcaQueues;
---
>   typedef std::list<std::pair<Ptr<Packet>, AmsduSubframeHeader> >::const_iterator DeaggregatedMsdusCI;
62,65c54,55
<    * Compute the size of the A-MSDU resulting from the aggregation of an MSDU of
<    * size <i>msduSize</i> and an A-MSDU of size <i>amsduSize</i>.
<    * Note that only the basic A-MSDU subframe format (section 9.3.2.2.2 of IEEE
<    * 802.11-2016) is supported.
---
>    * Sets the maximum A-MSDU size in bytes.
>    * Value 0 means that MSDU aggregation is disabled.
67,69c57
<    * \param msduSize the MSDU size in bytes.
<    * \param amsduSize the A-MSDU size in bytes.
<    * \return the size of the resulting A-MSDU in bytes.
---
>    * \param maxSize the maximum A-MSDU size in bytes.
71,72c59
<   static uint16_t GetSizeIfAggregated (uint16_t msduSize, uint16_t amsduSize);
< 
---
>   void SetMaxAmsduSize (uint16_t maxSize);
74,89c61,62
<    * Dequeue MSDUs to be transmitted to a given station and belonging to a
<    * given TID from the corresponding EDCA queue and aggregate them to form
<    * an A-MSDU that meets the following constraints:
<    *
<    * - the A-MSDU size does not exceed the maximum A-MSDU size as determined for
<    * the modulation class indicated by the given TxVector
<    *
<    * - the size of the A-MPDU resulting from the aggregation of the MPDU in which
<    * the A-MSDU will be embedded and an existing A-MPDU of the given size
<    * (possibly null) does not exceed the maximum A-MPDU size as determined for
<    * the modulation class indicated by the given TxVector
<    *
<    * - the time to transmit the resulting PPDU, according to the given TxVector,
<    * does not exceed both the maximum PPDU duration allowed by the corresponding
<    * modulation class (if any) and the given PPDU duration limit (if distinct from
<    * Time::Min ())
---
>    * Returns the maximum A-MSDU size in bytes.
>    * Value 0 means that MSDU aggregation is disabled.
91,99c64
<    * If it is not possible to aggregate at least two MSDUs, no MSDU is dequeued
<    * from the EDCA queue and a null pointer is returned.
<    *
<    * \param recipient the receiver station address.
<    * \param tid the TID.
<    * \param txVector the TxVector used to transmit the frame
<    * \param ampduSize the size of the existing A-MPDU in bytes
<    * \param ppduDurationLimit the limit on the PPDU duration
<    * \return the resulting A-MSDU, if aggregation is possible, 0 otherwise.
---
>    * \return the maximum A-MSDU size in bytes.
101,103c66
<   Ptr<WifiMacQueueItem> GetNextAmsdu (Mac48Address recipient, uint8_t tid,
<                                       WifiTxVector txVector, uint32_t ampduSize = 0,
<                                       Time ppduDurationLimit = Time::Min ()) const;
---
>   uint16_t GetMaxAmsduSize (void) const;
106,107c69,71
<    * Determine the maximum size for an A-MSDU of the given TID that can be sent
<    * to the given receiver when using the given modulation class.
---
>    * Adds <i>packet</i> to <i>aggregatedPacket</i>. In concrete aggregator's implementation is
>    * specified how and if <i>packet</i> can be added to <i>aggregatedPacket</i>. If <i>packet</i>
>    * can be added returns true, false otherwise.
109,112c73,77
<    * \param recipient the receiver station address.
<    * \param tid the TID.
<    * \param modulation the modulation class.
<    * \return the maximum A-MSDU size in bytes.
---
>    * \param packet the packet.
>    * \param aggregatedPacket the aggregated packet.
>    * \param src the source address.
>    * \param dest the destination address
>    * \return true if successful.
114,115c79,80
<   uint16_t GetMaxAmsduSize (Mac48Address recipient, uint8_t tid,
<                             WifiModulationClass modulation) const;
---
>   bool Aggregate (Ptr<const Packet> packet, Ptr<Packet> aggregatedPacket,
>                   Mac48Address src, Mac48Address dest) const;
124,129d88
<   /**
<    * Set the map of EDCA queues.
<    *
<    * \param map the map of EDCA queues.
<    */
<   void SetEdcaQueues (EdcaQueues map);
130a90
> private:
132,133c92,93
<    * Calculate how much padding must be added to the end of an A-MSDU of the
<    * given size if a new MSDU is added.
---
>    * Calculates how much padding must be added to the end of aggregated packet,
>    * after that a new packet is added.
136c96
<    * \param amsduSize the size of the A-MSDU
---
>    * \param packet
140c100
<   static uint8_t CalculatePadding (uint16_t amsduSize);
---
>   uint8_t CalculatePadding (Ptr<const Packet> packet) const;
142,143c102
< private:
<   EdcaQueues m_edca;   //!< the map of EDCA queues
---
>   uint16_t m_maxAmsduLength; ///< maximum AMSDU length
Only in ../../NS3-WiGig/src/wifi/model: multi-band-net-device.cc
Only in ../../NS3-WiGig/src/wifi/model: multi-band-net-device.h
diff ../../NS3-WiGig/src/wifi/model/nist-error-rate-model.h ../../ns-3-dev-git/src/wifi/model/nist-error-rate-model.h
54,55c54,55
<    * \param p the SNR ratio (not dB)
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param p
>    * \param bValue
57c57
<    * \return the coded BER
---
>    * \return BER
63c63
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
71c71
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
79c79
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
87c87
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
95c95
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
102c102
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
109c109
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
111c111
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
120c120
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
122c122
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
131c131
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
133c133
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
142c142
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
144c144
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
153c153
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
155c155
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
163c163
<    * \param snr SNR ratio (not dB)
---
>    * \param snr snr ratio (not dB)
165c165
<    * \param bValue such that coding rate = bValue / (bValue + 1)
---
>    * \param bValue
Only in ../../NS3-WiGig/src/wifi/model: obss-pd-algorithm.cc
Only in ../../NS3-WiGig/src/wifi/model: obss-pd-algorithm.h
diff ../../NS3-WiGig/src/wifi/model/onoe-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/onoe-wifi-manager.cc
41d40
<   bool m_rateBlocked; ///< whether the rate cannot be changed
44c43
<   uint32_t m_tx_ok; ///< transmit OK
---
>   uint32_t m_tx_ok; ///< transmit ok
46c45
<   uint32_t m_tx_retr; ///< transmit retry
---
>   uint32_t m_tx_retr; ///< transmit retr
93,110d91
< void
< OnoeWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
117d97
<   station->m_rateBlocked = false;
138c118
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
140d119
<   station->m_rateBlocked = true;  // do not change rate for retransmission
147c126
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
149d127
<   station->m_rateBlocked = true;  // do not change rate for retransmission
153c131
< OnoeWifiManager::DoReportRtsOk (WifiRemoteStation *st, double ctsSnr, WifiMode ctsMode, double rtsSnr)
---
> OnoeWifiManager::DoReportRtsOk (WifiRemoteStation *station, double ctsSnr, WifiMode ctsMode, double rtsSnr)
155,157c133
<   NS_LOG_FUNCTION (this << st << ctsSnr << ctsMode << rtsSnr);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
<   station->m_rateBlocked = true;  // do not change rate
---
>   NS_LOG_FUNCTION (this << station << ctsSnr << ctsMode << rtsSnr);
161,162c137
< OnoeWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> OnoeWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode, double dataSnr)
164,165c139,140
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
168d142
<   station->m_rateBlocked = false;  // we can change the rate for next packet
175c149
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
178d151
<   station->m_rateBlocked = false;  // we can change the rate for next packet
185c158
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
188d160
<   station->m_rateBlocked = false;  // we can change the rate for next packet
204c176
<   if (Simulator::Now () < station->m_nextModeUpdate || station->m_rateBlocked)
---
>   if (Simulator::Now () < station->m_nextModeUpdate)
287c259
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
330a303
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
339c312
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (st)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
346c319
<   OnoeWifiRemoteStation *station = static_cast<OnoeWifiRemoteStation*> (st);
---
>   OnoeWifiRemoteStation *station = (OnoeWifiRemoteStation *)st;
349a323
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
363c337
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (st))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (st)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
364a339,374
> }
> 
> bool
> OnoeWifiManager::IsLowLatency (void) const
> {
>   return false;
> }
> 
> void
> OnoeWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> OnoeWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> OnoeWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/onoe-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/onoe-wifi-manager.h
42c42
<  * This RAA does not support HT modes and will error
---
>  * This RAA does not support HT, VHT nor HE modes and will error
44c44
<  * that supports 802.11n or higher.
---
>  * that has VhtSupported, HtSupported or HeSupported set.
56a57,61
>   // Inherited from WifiRemoteStationManager
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
> 
59,60c64
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
68,69c72,73
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
73a78
>   bool IsLowLatency (void) const;
diff ../../NS3-WiGig/src/wifi/model/originator-block-ack-agreement.cc ../../ns-3-dev-git/src/wifi/model/originator-block-ack-agreement.cc
22d21
< #include "ns3/log.h"
24,25d22
< #include "wifi-mac-queue-item.h"
< #include "wifi-utils.h"
29,30d25
< NS_LOG_COMPONENT_DEFINE ("OriginatorBlockAckAgreement");
< 
33c28,30
<     m_state (PENDING)
---
>     m_state (PENDING),
>     m_sentMpdus (0),
>     m_needBlockAckReq (false)
45,50c42,46
< }
< 
< OriginatorBlockAckAgreement::State
< OriginatorBlockAckAgreement::GetState (void) const
< {
<   return m_state;
---
>   if (state == INACTIVE)
>     {
>       m_needBlockAckReq = false;
>       m_sentMpdus = 0;
>     }
66c62
< OriginatorBlockAckAgreement::IsRejected (void) const
---
> OriginatorBlockAckAgreement::IsInactive (void) const
68c64
<   return (m_state == REJECTED) ? true : false;
---
>   return (m_state == INACTIVE) ? true : false;
72,102c68
< OriginatorBlockAckAgreement::IsNoReply (void) const
< {
<   return (m_state == NO_REPLY) ? true : false;
< }
< 
< bool
< OriginatorBlockAckAgreement::IsReset (void) const
< {
<   return (m_state == RESET) ? true : false;
< }
< 
< uint16_t
< OriginatorBlockAckAgreement::GetStartingSequence (void) const
< {
<   if (m_txWindow.GetWinSize () == 0)
<     {
<       // the TX window has not been initialized yet
<       return m_startingSeq;
<     }
<   return m_txWindow.GetWinStart ();
< }
< 
< std::size_t
< OriginatorBlockAckAgreement::GetDistance (uint16_t seqNumber) const
< {
<   NS_ASSERT (seqNumber < SEQNO_SPACE_SIZE);
<   return (seqNumber - GetStartingSequence () + SEQNO_SPACE_SIZE) % SEQNO_SPACE_SIZE;
< }
< 
< void
< OriginatorBlockAckAgreement::InitTxWindow (void)
---
> OriginatorBlockAckAgreement::IsUnsuccessful (void) const
104c70
<   m_txWindow.Init (m_startingSeq, m_bufferSize);
---
>   return (m_state == UNSUCCESSFUL) ? true : false;
108c74
< OriginatorBlockAckAgreement::AdvanceTxWindow (void)
---
> OriginatorBlockAckAgreement::NotifyMpduTransmission (uint16_t nextSeqNumber)
110,130c76,80
<   while (m_txWindow.At (0))
<     {
<       m_txWindow.Advance (1); // reset the current head -- ensures loop termination
<     }
< }
< 
< void
< OriginatorBlockAckAgreement::NotifyTransmittedMpdu (Ptr<const WifiMacQueueItem> mpdu)
< {
<   uint16_t mpduSeqNumber = mpdu->GetHeader ().GetSequenceNumber ();
<   uint16_t distance = GetDistance (mpduSeqNumber);
< 
<   if (distance >= SEQNO_SPACE_HALF_SIZE)
<     {
<       NS_LOG_DEBUG ("Transmitted an old MPDU, do nothing.");
<       return;
<     }
< 
<   // advance the transmit window if an MPDU beyond the current transmit window
<   // is transmitted (see Section 10.24.7.7 of 802.11-2016)
<   if (distance >= m_txWindow.GetWinSize ())
---
>   NS_ASSERT (m_sentMpdus < m_bufferSize);
>   m_sentMpdus++;
>   uint16_t delta = (nextSeqNumber - m_startingSeq + 4096) % 4096;
>   uint16_t min = m_bufferSize < 64 ? m_bufferSize : 64;
>   if (delta >= min || m_sentMpdus == m_bufferSize)
132,137c82
<       std::size_t count = distance - m_txWindow.GetWinSize () + 1;
<       m_txWindow.Advance (count);
<       // transmit window may advance further
<       AdvanceTxWindow ();
<       NS_LOG_DEBUG ("Transmitted MPDU beyond current transmit window. New starting sequence number: "
<                     << m_txWindow.GetWinStart ());
---
>       m_needBlockAckReq = true;
141,142c86,87
< void
< OriginatorBlockAckAgreement::NotifyAckedMpdu (Ptr<const WifiMacQueueItem> mpdu)
---
> bool
> OriginatorBlockAckAgreement::IsBlockAckRequestNeeded (void) const
144,161c89
<   uint16_t mpduSeqNumber = mpdu->GetHeader ().GetSequenceNumber ();
<   uint16_t distance = GetDistance (mpduSeqNumber);
< 
<   if (distance >= SEQNO_SPACE_HALF_SIZE)
<     {
<       NS_LOG_DEBUG ("Acked an old MPDU, do nothing.");
<       return;
<     }
< 
<   // when an MPDU is transmitted, the transmit window is updated such that the
<   // transmitted MPDU is in the window, hence we cannot be notified of the
<   // acknowledgment of an MPDU which is beyond the transmit window
<   m_txWindow.At (distance) = true;
< 
<   // the starting sequence number can be advanced to the sequence number of
<   // the nearest unacknowledged MPDU
<   AdvanceTxWindow ();
<   NS_LOG_DEBUG ("Starting sequence number: " << m_txWindow.GetWinStart ());
---
>   return m_needBlockAckReq;
165c93
< OriginatorBlockAckAgreement::NotifyDiscardedMpdu (Ptr<const WifiMacQueueItem> mpdu)
---
> OriginatorBlockAckAgreement::CompleteExchange (void)
167,180c95,96
<   uint16_t mpduSeqNumber = mpdu->GetHeader ().GetSequenceNumber ();
<   uint16_t distance = GetDistance (mpduSeqNumber);
< 
<   if (distance >= SEQNO_SPACE_HALF_SIZE)
<     {
<       NS_LOG_DEBUG ("Discarded an old MPDU, do nothing.");
<       return;
<     }
< 
<   m_txWindow.Advance (distance + 1);
<   // transmit window may advance further
<   AdvanceTxWindow ();
<   NS_LOG_DEBUG ("Discarded MPDU within current transmit window. New starting sequence number: "
<                 << m_txWindow.GetWinStart ());
---
>   m_needBlockAckReq = false;
>   m_sentMpdus = 0;
diff ../../NS3-WiGig/src/wifi/model/originator-block-ack-agreement.h ../../ns-3-dev-git/src/wifi/model/originator-block-ack-agreement.h
25,27d24
< #include "block-ack-window.h"
< 
< class OriginatorBlockAckWindowTest;
31,32d27
< class WifiMacQueueItem;
< 
35,56c30,31
<  * Maintains the state and information about transmitted MPDUs with Ack Policy set to Block Ack
<  * for an originator station. The state diagram is as follows:
<  *
<    \verbatim
<     /------------\ send ADDBARequest ----------------
<     |   START    |------------------>|   PENDING    |-------
<     \------------/                   ----------------       \
<           ^            receive     /        |                \
<           |        ADDBAResponse  /         |                 \
<           |          (failure)   v          |                  \
<           |        ---------------          |                   --------------------->  ----------------
<           |        |  REJECTED   |          |          receive ADDBAResponse (success)  |  ESTABLISHED |
<           |        ---------------          |      no            -------------------->  ----------------
<           |           receive    ^          | ADDBAResponse     /
<           |        ADDBAResponse  \         |                  /
<           |          (failure)     \        v                 /
<           |                         ----------------         /
<           |-------------------------|   NO_REPLY   |---------
<             Reset after timeout     ----------------
<    \endverbatim
<  *
<  * See also OriginatorBlockAckAgreement::State
---
>  * Maintains the state and information about transmitted MPDUs with ack policy block ack
>  * for an originator station.
62,63d36
<   /// allow OriginatorBlockAckWindowTest class access
<   friend class ::OriginatorBlockAckWindowTest;
67d39
<   OriginatorBlockAckAgreement ();
75a48,66
>   /*                                      receive ADDBAResponse
>    *  send ADDBARequest ---------------   status code = success  ---------------
>    *  ----------------->|   PENDING    |------------------------>|  ESTABLISHED |-----
>    *                    ---------------                          ---------------      |
>    *                          |                                    /   ^    ^         |
>    *   receive ADDBAResponse  |                receive BlockAck   /    |    |         | receive BlockAck
>    *   status code = failure  |           retryPkts + queuePkts  /     |    |         | retryPkts + queuePkts
>    *                          v                     <           /      |    |         |           >=
>    *                   ---------------     blockAckThreshold   /       |    |         | blockAckThreshold
>    *                   | UNSUCCESSFUL |                       /        |    |         |
>    *                   ---------------                       v         |    ----------|
>    *                                            --------------         |
>    *                                            |  INACTIVE   |        |
>    *                                            --------------         |
>    *                        send a MPDU (Normal Ack)   |               |
>    *                        retryPkts + queuePkts      |               |
>    *                                  >=               |               |
>    *                         blockAckThreshold         |----------------
>    */
86c77,83
<   *    with Ack Policy set to Block Ack.
---
>   *    with ack policy set to block ack.
>   *
>   *  INACTIVE:
>   *    In our implementation, block ack tear-down happens only if an inactivity timeout occurs
>   *    so we could have an active block ack but a number of packets that doesn't reach the value of
>   *    m_blockAckThreshold (see ns3::BlockAckManager). In these conditions the agreement becomes
>   *    INACTIVE until that the number of packets reaches the value of m_blockAckThreshold again.
88,99c85,95
<   *  NO_REPLY
<   *    No reply after an ADDBA request. In this state the originator will send the rest of packets
<   *    in queue using normal MPDU.
<   *
<   *  RESET
<   *    A transient state to mark the agreement for reinitialization after failed ADDBA request.
<   *    Since it is a temporary state, it is not included in the state diagram above. In this
<   *    state the next transmission will be treated as if the BA agreement is not created yet.
<   *
<   *  REJECTED (not used for now):
<   *    The agreement's state becomes REJECTED if an ADDBAResponse frame is received from recipient 
<   *    and the Status Code field is set to failure.
---
>   *  UNSUCCESSFUL (not used for now):
>   *    The agreement's state becomes UNSUCCESSFUL if:
>   *
>   *    - its previous state was PENDING and an ADDBAResponse frame wasn't received from
>   *      recipient station within an interval of time defined by m_bAckSetupTimeout attribute
>   *      in ns3::WifiMac.
>   *    - an ADDBAResponse frame is received from recipient and the Status Code field is set
>   *      to failure.
>   *
>   *    In both cases for station addressed by BlockAckAgreement::m_peer and for
>   *    TID BlockAckAgreement::m_tid block ack mechanism won't be used.
106,108c102,103
<     NO_REPLY,
<     RESET,
<     REJECTED
---
>     INACTIVE,
>     UNSUCCESSFUL
117,122d111
<    * Get the current state.
<    *
<    * \return state
<    */
<   State GetState (void) const;
<   /**
137c126
<    * Check if the current state of this agreement is NO_REPLY.
---
>    * Check if the current state of this agreement is INACTIVE.
139c128
<    * \return true if the current state of this agreement is NO_REPLY,
---
>    * \return true if the current state of this agreement is INACTIVE,
142c131
<   bool IsNoReply (void) const;
---
>   bool IsInactive (void) const;
144c133
<    * Check if the current state of this agreement is RESET.
---
>    * Check if the current state of this agreement is UNSUCCESSFUL.
146c135
<    * \return true if the current state of this agreement is RESET,
---
>    * \return true if the current state of this agreement is UNSUCCESSFUL,
149c138
<   bool IsReset (void) const;
---
>   bool IsUnsuccessful (void) const;
151c140
<    * Check if the current state of this agreement is REJECTED.
---
>    * Notifies a packet's transmission with ack policy Block Ack.
153,154c142
<    * \return true if the current state of this agreement is REJECTED,
<    *         false otherwise
---
>    * \param nextSeqNumber
156,157c144
<   bool IsRejected (void) const;
< 
---
>   void NotifyMpduTransmission (uint16_t nextSeqNumber);
159,161c146,147
<    * Return the starting sequence number of the transmit window, if a transmit
<    * window has been initialized. Otherwise, return the starting sequence number
<    * stored by the BlockAckAgreement base class.
---
>    * Returns true if all packets for which a block ack was negotiated have been transmitted so
>    * a block ack request is needed in order to acknowledge them.
163c149,150
<    * \return the starting sequence number.
---
>    * \return  true if all packets for which a block ack was negotiated have been transmitted,
>    * false otherwise
165,202c152,154
<   uint16_t GetStartingSequence (void) const;
< 
<   /**
<    * Get the distance between the current starting sequence number and the
<    * given sequence number.
<    *
<    * \param seqNumber the given sequence number
<    * \return the distance of the given sequence number from the current winstart
<    */
<   std::size_t GetDistance (uint16_t seqNumber) const;
< 
<   /**
<    * Initialize the originator's transmit window by setting its size and starting
<    * sequence number equal to the values stored by the BlockAckAgreement base class.
<    */
<   void InitTxWindow (void);
< 
<   /**
<    * Advance the transmit window so as to include the transmitted MPDU, if the
<    * latter is not an old packet and is beyond the current transmit window.
<    *
<    * \param mpdu the transmitted MPDU
<    */
<   void NotifyTransmittedMpdu (Ptr<const WifiMacQueueItem> mpdu);
<   /**
<    * Record that the given MPDU has been acknowledged and advance the transmit
<    * window if possible.
<    *
<    * \param mpdu the acknowledged MPDU
<    */
<   void NotifyAckedMpdu (Ptr<const WifiMacQueueItem> mpdu);
<   /**
<    * Advance the transmit window beyond the MPDU that has been reported to
<    * be discarded.
<    *
<    * \param mpdu the discarded MPDU
<    */
<   void NotifyDiscardedMpdu (Ptr<const WifiMacQueueItem> mpdu);
---
>   bool IsBlockAckRequestNeeded (void) const;
>   /// Complete exchange function
>   void CompleteExchange (void);
206,213c158,160
<   /**
<    * Advance the transmit window so that the starting sequence number is the
<    * nearest unacknowledged MPDU.
<    */
<   void AdvanceTxWindow (void);
< 
<   State m_state;                 ///< state
<   BlockAckWindow m_txWindow;     ///< originator's transmit window
---
>   State m_state; ///< state
>   uint16_t m_sentMpdus; ///< sent MPDUs
>   bool m_needBlockAckReq; ///< flag whether it needs a Block ACK request
diff ../../NS3-WiGig/src/wifi/model/parf-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/parf-wifi-manager.cc
105,122d104
< void
< ParfWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
182c164
<   ParfWifiRemoteStation *station = static_cast<ParfWifiRemoteStation*> (st);
---
>   ParfWifiRemoteStation *station = (ParfWifiRemoteStation *)st;
261,262c243,244
< void ParfWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                       double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> void ParfWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                       double ackSnr, WifiMode ackMode, double dataSnr)
264,265c246,247
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   ParfWifiRemoteStation *station = static_cast<ParfWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   ParfWifiRemoteStation *station = (ParfWifiRemoteStation *) st;
314c296
<   ParfWifiRemoteStation *station = static_cast<ParfWifiRemoteStation*> (st);
---
>   ParfWifiRemoteStation *station = (ParfWifiRemoteStation *) st;
317a300
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
336c319
<   return WifiTxVector (mode, station->m_powerLevel, GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, station->m_powerLevel, GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
343c326
<   /// \todo we could/should implement the ARF algorithm for
---
>   /// \todo we could/should implement the Arf algorithm for
345c328
<   ParfWifiRemoteStation *station = static_cast<ParfWifiRemoteStation*> (st);
---
>   ParfWifiRemoteStation *station = (ParfWifiRemoteStation *) st;
348a332
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
361c345
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
362a347,382
> }
> 
> bool
> ParfWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
> void
> ParfWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> ParfWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> ParfWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/parf-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/parf-wifi-manager.h
39c39
<  * This RAA does not support HT modes and will error
---
>  * This RAA does not support HT, VHT nor HE modes and will error
41c41
<  * that supports 802.11n or higher.
---
>  * that has VhtSupported, HtSupported or HeSupported set.
55a56,58
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
59,60c62
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
68,69c70,71
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
73a76
>   bool IsLowLatency (void) const;
Only in ../../NS3-WiGig/src/wifi/model: preamble-detection-model.cc
Only in ../../NS3-WiGig/src/wifi/model: preamble-detection-model.h
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-delay.cc
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-delay.h
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-engine.cc
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-engine.h
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-loss.cc
Only in ../../NS3-WiGig/src/wifi/model: qd-propagation-loss.h
diff ../../NS3-WiGig/src/wifi/model/qos-blocked-destinations.h ../../ns-3-dev-git/src/wifi/model/qos-blocked-destinations.h
34c34
<  * for a BlockAck response.
---
>  * for a block ACK response.
44c44
<    * BlockAck response).
---
>    * block ACK response).
46,47c46,47
<    * \param dest the destination MAC address
<    * \param tid the TID
---
>    * \param dest
>    * \param tid
51c51
<    * Un-block the given destination address and TID (e.g. BlockAck
---
>    * Un-block the given destination address and TID (e.g. block ACK
54,55c54,55
<    * \param dest the destination MAC address
<    * \param tid the TID
---
>    * \param dest
>    * \param tid
60c60
<    * from sending (e.g. pending BlockAck response).
---
>    * from sending (e.g. pending block ACK response).
62,63c62,63
<    * \param dest the destination MAC address
<    * \param tid the TID
---
>    * \param dest
>    * \param tid
72c72
<   std::set<std::pair<Mac48Address, uint8_t>> m_blockedQosPackets; ///< blocked QoS packets
---
>   std::set < std::pair < Mac48Address, uint8_t >> m_blockedQosPackets; ///< blocked QOS packets
diff ../../NS3-WiGig/src/wifi/model/qos-txop.cc ../../ns-3-dev-git/src/wifi/model/qos-txop.cc
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks
22,23d20
<  *          Stefano Avallone <stavalli@unina.it>
<  *          Hany Assasa <hany.assasa@gmail.com>
27d23
< #include "ns3/pointer.h"
42,44d37
< #include "wifi-phy.h"
< #include "wifi-ack-policy-selector.h"
< #include "wifi-psdu.h"
62,87c55,62
<     .AddAttribute ("UseExplicitBarAfterMissedBlockAck",
<                    "Specify whether explicit BlockAckRequest should be sent upon missed BlockAck Response.",
<                    BooleanValue (true),
<                    MakeBooleanAccessor (&QosTxop::m_useExplicitBarAfterMissedBlockAck),
<                    MakeBooleanChecker ())
<     .AddAttribute ("AddBaResponseTimeout",
<                    "The timeout to wait for ADDBA response after the Ack to "
<                    "ADDBA request is received.",
<                    TimeValue (MilliSeconds (1)),
<                    MakeTimeAccessor (&QosTxop::SetAddBaResponseTimeout,
<                                      &QosTxop::GetAddBaResponseTimeout),
<                    MakeTimeChecker ())
<     .AddAttribute ("FailedAddBaTimeout",
<                    "The timeout after a failed BA agreement. During this "
<                    "timeout, the originator resumes sending packets using normal "
<                    "MPDU. After that, BA agreement is reset and the originator "
<                    "will retry BA negotiation.",
<                    TimeValue (MilliSeconds (200)),
<                    MakeTimeAccessor (&QosTxop::SetFailedAddBaTimeout,
<                                      &QosTxop::GetFailedAddBaTimeout),
<                    MakeTimeChecker ())
<     .AddAttribute ("BlockAckManager",
<                    "The BlockAckManager object.",
<                    PointerValue (),
<                    MakePointerAccessor (&QosTxop::m_baManager),
<                    MakePointerChecker<BlockAckManager> ())
---
>     .AddTraceSource ("BackoffTrace",
>                      "Trace source for backoff values",
>                      MakeTraceSourceAccessor (&QosTxop::m_backoffTrace),
>                      "ns3::TracedValueCallback::Uint32")
>     .AddTraceSource ("CwTrace",
>                      "Trace source for contention window values",
>                      MakeTraceSourceAccessor (&QosTxop::m_cwTrace),
>                      "ns3::TracedValueCallback::Uint32")
89c64
<                      "Trace source for TXOP start and duration times",
---
>                      "Trace source for txop start and duration times",
97c72,74
<   : m_typeOfStation (STA),
---
>   : m_msduAggregator (0),
>     m_mpduAggregator (0),
>     m_typeOfStation (STA),
109a87
>   m_baManager->SetMaxPacketDelay (m_queue->GetMaxDelay ());
112d89
<   m_firstTransmission = false;
124d100
<   m_ackPolicySelector = 0;
126a103,104
>   m_msduAggregator = 0;
>   m_mpduAggregator = 0;
130,136d107
< void
< QosTxop::CopyBlockAckAgreements (Mac48Address recipient, Ptr<QosTxop> target)
< {
<   NS_LOG_FUNCTION (this << recipient << target);
< //  m_baManager->CopyAgreements (recipient, target->m_baManager);
< }
< 
138c109
< QosTxop::GetBaAgreementEstablished (Mac48Address address, uint8_t tid) const
---
> QosTxop::GetBaAgreementExists (Mac48Address address, uint8_t tid) const
140,173c111
<   return m_baManager->ExistsAgreementInState (address, tid, OriginatorBlockAckAgreement::ESTABLISHED);
< }
< 
< uint16_t
< QosTxop::GetBaBufferSize (Mac48Address address, uint8_t tid) const
< {
<   return m_baManager->GetRecipientBufferSize (address, tid);
< }
< 
< uint16_t
< QosTxop::GetBaStartingSequence (Mac48Address address, uint8_t tid) const
< {
<   return m_baManager->GetOriginatorStartingSequence (address, tid);
< }
< 
< Ptr<const WifiMacQueueItem>
< QosTxop::PrepareBlockAckRequest (Mac48Address recipient, uint8_t tid) const
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
< 
<   CtrlBAckRequestHeader reqHdr = m_low->GetEdca (tid)->m_baManager->GetBlockAckReqHeader (recipient, tid);
<   Ptr<Packet> bar = Create<Packet> ();
<   bar->AddHeader (reqHdr);
< 
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_CTL_BACKREQ);
<   hdr.SetAddr1 (recipient);
<   hdr.SetAddr2 (m_low->GetAddress ());
<   hdr.SetDsNotTo ();
<   hdr.SetDsNotFrom ();
<   hdr.SetNoRetry ();
<   hdr.SetNoMoreFragments ();
< 
<   return Create<const WifiMacQueueItem> (bar, hdr);
---
>   return m_baManager->ExistsAgreement (address, tid);
177c115
< QosTxop::ScheduleBar (Ptr<const WifiMacQueueItem> bar, bool skipIfNoDataQueued)
---
> QosTxop::CompleteAmpduTransfer (Mac48Address recipient, uint8_t tid)
179c117
<   m_baManager->ScheduleBar (bar, skipIfNoDataQueued);
---
>   m_baManager->CompleteAmpduExchange (recipient, tid);
191,203d128
< QosTxop::SetAckPolicySelector (Ptr<WifiAckPolicySelector> ackSelector)
< {
<   NS_LOG_FUNCTION (this << ackSelector);
<   m_ackPolicySelector = ackSelector;
< }
< 
< Ptr<WifiAckPolicySelector>
< QosTxop::GetAckPolicySelector (void) const
< {
<   return m_ackPolicySelector;
< }
< 
< void
216,232d140
< void
< QosTxop::ResetState (void)
< {
<   NS_LOG_FUNCTION (this); 
<   ResetCw ();
<   m_cwTrace = GetCw ();
<   GenerateBackoff ();
< }
< 
< bool
< QosTxop::HasFramesToTransmit (void)
< {
<   bool ret = (m_currentPacket != 0 || m_baManager->HasPackets () || !m_queue->IsEmpty ());
<   NS_LOG_FUNCTION (this << ret);
<   return ret;
< }
< 
234c142
< QosTxop::GetNextSequenceNumberFor (const WifiMacHeader *hdr)
---
> QosTxop::GetNextSequenceNumberFor (WifiMacHeader *hdr)
240c148
< QosTxop::PeekNextSequenceNumberFor (const WifiMacHeader *hdr)
---
> QosTxop::PeekNextSequenceNumberFor (WifiMacHeader *hdr)
245,338c153,154
< bool
< QosTxop::IsQosOldPacket (Ptr<const WifiMacQueueItem> mpdu)
< {
<   NS_LOG_FUNCTION (this << *mpdu);
< 
<   if (!mpdu->GetHeader ().IsQosData ())
<     {
<       return false;
<     }
< 
<   Mac48Address recipient = mpdu->GetHeader ().GetAddr1 ();
<   uint8_t tid = mpdu->GetHeader ().GetQosTid ();
< 
<   if (!GetBaAgreementEstablished (recipient, tid))
<     {
<       return false;
<     }
< 
<   if (QosUtilsIsOldPacket (GetBaStartingSequence (recipient, tid),
<                            mpdu->GetHeader ().GetSequenceNumber ()))
<     {
<       return true;
<     }
<   return false;
< }
< 
< Ptr<const WifiMacQueueItem>
< QosTxop::PeekNextFrame (uint8_t tid, Mac48Address recipient)
< {
<   NS_LOG_FUNCTION (this);
<   WifiMacQueue::ConstIterator it = WifiMacQueue::EMPTY;
< 
<   // lambda to peek the next frame
<   auto peek = [this, &tid, &recipient, &it] (Ptr<WifiMacQueue> queue)
<     {
<       if (tid == 8 && recipient.IsBroadcast ())  // undefined TID and recipient
<         {
<           return queue->PeekFirstAvailable (m_qosBlockedDestinations, it);
<         }
<       return queue->PeekByTidAndAddress (tid, recipient, it);
<     };
< 
<   // check if there is a packet in the BlockAckManager retransmit queue
<   it = peek (m_baManager->GetRetransmitQueue ());
<   // remove old packets
<   while (it != m_baManager->GetRetransmitQueue ()->end () && IsQosOldPacket (*it))
<     {
<       NS_LOG_DEBUG ("removing an old packet from BlockAckManager retransmit queue: " << **it);
<       it = m_baManager->GetRetransmitQueue ()->Remove (it);
<       it = peek (m_baManager->GetRetransmitQueue ());
<     }
<   if (it != m_baManager->GetRetransmitQueue ()->end ())
<     {
<       NS_LOG_DEBUG ("packet peeked from BlockAckManager retransmit queue: " << **it);
<       return *it;
<     }
< 
<   // otherwise, check if there is a packet in the EDCA queue
<   it = WifiMacQueue::EMPTY;
<   it = peek (m_queue);
<   if (it != m_queue->end ())
<     {
<       // peek the next sequence number and check if it is within the transmit window
<       // in case of QoS data frame
<       uint16_t sequence = m_txMiddle->PeekNextSequenceNumberFor (&(*it)->GetHeader ());
<       if ((*it)->GetHeader ().IsQosData ())
<         {
<           Mac48Address recipient = (*it)->GetHeader ().GetAddr1 ();
<           uint8_t tid = (*it)->GetHeader ().GetQosTid ();
< 
<           if (GetBaAgreementEstablished (recipient, tid)
<               && !IsInWindow (sequence, GetBaStartingSequence (recipient, tid), GetBaBufferSize (recipient, tid)))
<             {
<               NS_LOG_DEBUG ("packet beyond the end of the current transmit window");
<               return 0;
<             }
<         }
< 
<       WifiMacHeader hdr = (*it)->GetHeader ();
<       hdr.SetSequenceNumber (sequence);
<       hdr.SetFragmentNumber (0);
<       hdr.SetNoMoreFragments ();
<       hdr.SetNoRetry ();
<       Ptr<const WifiMacQueueItem> item = Create<const WifiMacQueueItem> ((*it)->GetPacket (), hdr, (*it)->GetTimeStamp ());
<       NS_LOG_DEBUG ("packet peeked from EDCA queue: " << *item);
<       return item;
<     }
< 
<   return 0;
< }
< 
< Ptr<WifiMacQueueItem>
< QosTxop::DequeuePeekedFrame (Ptr<const WifiMacQueueItem> peekedItem, WifiTxVector txVector,
<                              bool aggregate, uint32_t ampduSize, Time ppduDurationLimit)
---
> Ptr<const Packet>
> QosTxop::PeekNextRetransmitPacket (WifiMacHeader &header, uint8_t tid, Time *timestamp)
340,516c156
<   NS_LOG_FUNCTION (this << peekedItem << txVector << ampduSize << ppduDurationLimit);
<   NS_ASSERT (peekedItem != 0);
< 
<   // do not dequeue the frame if it is a QoS data frame that does not meet the
<   // max A-MPDU size limit (if applicable) or the duration limit (if applicable)
<   if (peekedItem->GetHeader ().IsQosData () &&
<       !m_low->IsWithinSizeAndTimeLimits (peekedItem, txVector, ampduSize, ppduDurationLimit))
<     {
<       return 0;
<     }
< 
<   Mac48Address recipient = peekedItem->GetHeader ().GetAddr1 ();
<   Ptr<WifiMacQueueItem> item;
<   Ptr<const WifiMacQueueItem> testItem;
<   WifiMacQueue::ConstIterator testIt;
< 
<   // the packet can only have been peeked from the block ack manager retransmit
<   // queue if:
<   // - the peeked packet is a QoS Data frame AND
<   // - the peeked packet is not a broadcast frame AND
<   // - an agreement has been established
<   if (peekedItem->GetHeader ().IsQosData () && !recipient.IsBroadcast ()
<       && GetBaAgreementEstablished (recipient, peekedItem->GetHeader ().GetQosTid ()))
<     {
<       uint8_t tid = peekedItem->GetHeader ().GetQosTid ();
<       testIt = m_baManager->GetRetransmitQueue ()->PeekByTidAndAddress (tid, recipient);
< 
<       if (testIt != m_baManager->GetRetransmitQueue ()->end ())
<         {
<           testItem = *testIt;
<           // if not null, the test packet must equal the peeked packet
<           NS_ASSERT (testItem->GetPacket () == peekedItem->GetPacket ());
<           // we should not be asked to dequeue an old packet
<           NS_ASSERT (!QosUtilsIsOldPacket (GetBaStartingSequence (recipient, tid),
<                                            testItem->GetHeader ().GetSequenceNumber ()));
<           item = m_baManager->GetRetransmitQueue ()->Dequeue (testIt);
<           NS_LOG_DEBUG ("dequeued from BA manager queue: " << *item);
<           return item;
<         }
<     }
< 
<   // The packet has been peeked from the EDCA queue.
<   // If it is a QoS Data frame and it is not a broadcast frame, attempt A-MSDU
<   // aggregation if aggregate is true
<   if (peekedItem->GetHeader ().IsQosData ())
<     {
<       uint8_t tid = peekedItem->GetHeader ().GetQosTid ();
<       testIt = m_queue->PeekByTidAndAddress (tid, recipient);
< 
<       NS_ASSERT (testIt != m_queue->end () && (*testIt)->GetPacket () == peekedItem->GetPacket ());
< 
<       uint16_t sequence = m_txMiddle->PeekNextSequenceNumberFor (&peekedItem->GetHeader ());
< 
<       // check if the peeked packet is within the transmit window
<       if (GetBaAgreementEstablished (recipient, tid)
<           && !IsInWindow (sequence, GetBaStartingSequence (recipient, tid), GetBaBufferSize (recipient, tid)))
<         {
<           NS_LOG_DEBUG ("packet beyond the end of the current transmit window");
<           return 0;
<         }
< 
<       // try A-MSDU aggregation
<       if (m_low->GetMsduAggregator () != 0 && !recipient.IsBroadcast () && aggregate)
<         {
<           item = m_low->GetMsduAggregator ()->GetNextAmsdu (recipient, tid, txVector, ampduSize, ppduDurationLimit);
<         }
< 
<       if (item != 0)
<         {
<           NS_LOG_DEBUG ("tx unicast A-MSDU");
<         }
<       else  // aggregation was not attempted or failed
<         {
<           item = m_queue->Dequeue (testIt);
<         }
<     }
<   else
<     {
<       // the peeked packet is a non-QoS Data frame (e.g., a DELBA Request), hence
<       // it was not peeked by TID, hence it must be the head of the queue
<       item = m_queue->DequeueFirstAvailable (m_qosBlockedDestinations);
<       NS_ASSERT (item != 0 && item->GetPacket () == peekedItem->GetPacket ());
<     }
< 
<   NS_ASSERT (item != 0);
< 
<   // Assign a sequence number to the MSDU or A-MSDU dequeued from the EDCA queue
<   uint16_t sequence = m_txMiddle->GetNextSequenceNumberFor (&item->GetHeader ());
<   item->GetHeader ().SetSequenceNumber (sequence);
<   item->GetHeader ().SetFragmentNumber (0);
<   item->GetHeader ().SetNoMoreFragments ();
<   item->GetHeader ().SetNoRetry ();
<   NS_LOG_DEBUG ("dequeued from EDCA queue: " << *item);
< 
<   return item;
< }
< 
< MacLowTransmissionParameters
< QosTxop::GetTransmissionParameters (Ptr<const WifiMacQueueItem> frame) const
< {
<   NS_LOG_FUNCTION (this << *frame);
< 
<   MacLowTransmissionParameters params;
<   Mac48Address recipient = frame->GetHeader ().GetAddr1 ();
< 
<   params.DisableNextData ();
< 
<   // broadcast frames
<   if (recipient.IsBroadcast ())
<     {
<       params.DisableRts ();
<       params.DisableAck ();
<       return params;
<     }
<   if (frame->GetHeader ().IsMgt ())
<     {
<       params.DisableRts ();
<       params.EnableAck ();
<       return params;
<     }
< 
<   // Enable/disable RTS
<   if (!frame->GetHeader ().IsBlockAckReq ()
<       && m_stationManager->NeedRts (frame->GetHeader (), frame->GetSize ())
<       && !m_low->IsCfPeriod ())
<     {
<       params.EnableRts ();
<     }
<   else
<     {
<       params.DisableRts ();
<     }
< 
<   // Select ack technique.
<   if (frame->GetHeader ().IsQosData ())
<     {
<       // Assume normal Ack by default
<       params.EnableAck ();
<     }
<   else if (frame->GetHeader ().IsBlockAckReq ())
<     {
<       // assume a BlockAck variant. Later, if this frame is not aggregated,
<       // the acknowledgment type will be switched to normal Ack
<       if (m_blockAckType == BASIC_BLOCK_ACK)
<         {
<           params.EnableBlockAck (BlockAckType::BASIC_BLOCK_ACK);
<         }
<       else if (m_blockAckType == COMPRESSED_BLOCK_ACK)
<         {
<           CtrlBAckRequestHeader baReqHdr;
<           frame->GetPacket ()->PeekHeader (baReqHdr);
<           uint8_t tid = baReqHdr.GetTidInfo ();
<           //// WIGIG ////
<           if (IsEdmgSupported ())
<             {
<               params.EnableBlockAck (BlockAckType::EDMG_COMPRESSED_BLOCK_ACK);
<             }
<           else
<           //// WIGIG ////
<             {
<               if (GetBaBufferSize (recipient, tid) > 64)
<                 {
<                   params.EnableBlockAck (BlockAckType::EXTENDED_COMPRESSED_BLOCK_ACK);
<                 }
<               else
<                 {
<                   params.EnableBlockAck (BlockAckType::COMPRESSED_BLOCK_ACK);
<                 }
<             }
<         }
<       else if (m_blockAckType == MULTI_TID_BLOCK_ACK)
<         {
<           NS_FATAL_ERROR ("Multi-tid block ack is not supported");
<         }
<     }
< 
<   return params;
---
>   return m_baManager->PeekNextPacketByTidAndAddress (header, tid, timestamp);
520c160
< QosTxop::UpdateCurrentPacket (Ptr<WifiMacQueueItem> mpdu)
---
> QosTxop::RemoveRetransmitPacket (uint8_t tid, Mac48Address recipient, uint16_t seqnumber)
522,525c162
< //  NS_LOG_FUNCTION (this << *mpdu);
<   m_currentPacket = mpdu->GetPacket ();
<   m_currentHdr = mpdu->GetHeader ();
<   m_currentPacketTimestamp = mpdu->GetTimeStamp ();
---
>   m_baManager->RemovePacket (tid, recipient, seqnumber);
528,571d164
< //// WIGIG ////
< Time
< QosTxop::GetPpduDurationLimit (Ptr<const WifiMacQueueItem> item, const MacLowTransmissionParameters &params)
< {
<   Time ppduDurationLimit = Time::Min ();
<   if (m_stationManager->IsWiGigSupported ())
<     {
<       if (GetTxopLimit ().IsStrictlyPositive ())
<         {
<           /* We have a Txop within the current allocation period. */
<           ppduDurationLimit = std::min (GetTxopRemaining (), GetAllocationRemaining ()) - m_low->CalculateOverheadTxTime (item, params);
<         }
<       else
<         {
<           /* Our limitation here is the remaining duration in the current allocation period. */
<           ppduDurationLimit = GetAllocationRemaining () - m_low->CalculateOverheadTxTime (item, params);
<         }
<     }
<   else if (GetTxopLimit ().IsStrictlyPositive ())
<     {
<       /* We only have Txop limitation */
<       ppduDurationLimit = GetTxopRemaining () - m_low->CalculateOverheadTxTime (item, params);
<     }
<   return ppduDurationLimit;
< }
< 
< Ptr<const WifiMacQueueItem>
< QosTxop::PeekFrameForTransmission (void)
< {
<   Ptr<const WifiMacQueueItem> peekedItem;
<   if (m_allocationType == SERVICE_PERIOD_ALLOCATION)
<     {
<       /* Hany: We need to convert UP to TID, it is wrong to use AC as TID (It works as a temporary solution) */
<       peekedItem = PeekNextFrame (m_ac, m_peerStation);
<     }
<   else
<     {
<       peekedItem = PeekNextFrame ();
<     }
<   return peekedItem;
< }
< 
< //// WIGIG ////
< 
579d171
<   m_firstTransmission = false;
581,597c173
<   // discard the current packet if it is a QoS Data frame with expired lifetime
<   if (m_currentPacket != 0 && m_currentHdr.IsQosData ()
<       && (m_currentPacketTimestamp + m_queue->GetMaxDelay () < Simulator::Now ()))
<     {
<       NS_LOG_DEBUG ("the lifetime of current packet expired");
<       m_currentPacket = 0;
<     }
<   // discard the current packet if there has been a switch in the transmission mode (SISO/MIMO) between its suspension and transmission
<   if ((!m_low->CompletedSuspendedPsduTransmission (this) || !m_low->IsCurrentAllocationEmpty ()) && m_low->SwitchInTransmissionMode ())
<     {
<       NS_LOG_DEBUG ("there has been a switch in the transmission mode (SISO/MIMO) for the packet destination");
<       m_currentPacket = 0;
<     }
< 
<   /* Update Allocation duration */
<   Time allocationRemaining = GetAllocationRemaining ();
<   if ((m_stationManager->HasDmgSupported () || m_stationManager->HasEdmgSupported ()) && GetTypeOfStation () != DMG_ADHOC)
---
>   if (m_currentPacket == 0)
599c175
<       if (GetAllocationRemaining ().IsZero ())
---
>       if (m_queue->IsEmpty () && !m_baManager->HasPackets ())
601,602c177
<           NS_LOG_DEBUG ("No enough time in the current allocation to transmit.");
<           m_accessAllowed = false;
---
>           NS_LOG_DEBUG ("queue is empty");
605c180
<       if (m_low->Is_Performing_SLS ())
---
>       if (m_baManager->HasBar (m_currentBar))
607c182
<           NS_LOG_DEBUG ("Performing TXSS SLS, so abort QoS-data transmission.");
---
>           SendBlockAckRequest (m_currentBar);
610c185,187
<       if (m_low->Is_Performing_MIMO_BFT ())
---
>       /* check if packets need retransmission are stored in BlockAckManager */
>       m_currentPacket = m_baManager->GetNextPacket (m_currentHdr, true);
>       if (m_currentPacket == 0)
612,669c189,190
<           NS_LOG_DEBUG ("Performing MIMO BFT, so abort QoS-data transmission.");
<           return;
<         }
<       if (!m_low->CompletedSuspendedPsduTransmission (this))
<         {
<           if (m_currentPacket != 0)
<             {
<               m_low->ResumeTransmission (allocationRemaining, this);
<               return;
<             }
<           else
<             {
<               // In case when the MSDU lifetime for the suspended transmission has expired
<               m_low->AbortSuspendedTransmission ();
<               NS_LOG_DEBUG ("Deleting allocation which incudes the packet with the expired lifetime");
<             }
< 
<         }
<       /* This happens if we have resumed a transmission, but it did not successed due to the start of an SLS phase */
<       if (m_currentHdr.IsQosData ()
<           && GetBaAgreementEstablished (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid ())
<           && !m_low->IsCurrentAllocationEmpty ())
<         {
<           if (m_currentPacket != 0)
<             {
<               m_low->ResumeTransmission (allocationRemaining, this);
<               return;
<             }
<           else
<             {
<               // In case when the MSDU lifetime for the suspended transmission has expired
<               m_low->AbortSuspendedTransmission ();
<               NS_LOG_DEBUG ("Deleting allocation which incudes the packet with the expired lifetime");
<             }
<         }
<     }
< 
<   // If the current packet is a QoS Data frame, then there must be no block ack agreement
<   // established with the receiver for the TID of the packet. Indeed, retransmission
<   // of MPDUs sent under a block ack agreement is handled through the retransmit queue.
<   //  NS_ASSERT (m_currentPacket == 0 || !m_currentHdr.IsQosData ()
<   //             || !GetBaAgreementEstablished (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid ()));
< 
<   if (m_currentPacket == 0)
<     {
<       Ptr<const WifiMacQueueItem> peekedItem = m_baManager->GetBar ();
<       if (peekedItem != 0)
<         {
<           m_currentHdr = peekedItem->GetHeader ();
<           m_currentPacket = peekedItem->GetPacket ();
<           m_currentPacketTimestamp = Simulator::Now ();
<         }
<       else
<         {
<           //// WIGIG ////
<           peekedItem = PeekFrameForTransmission ();
<           //// WIGIG ////
<           if (peekedItem == 0)
---
>           Ptr<const WifiMacQueueItem> item = m_queue->PeekFirstAvailable (m_qosBlockedDestinations);
>           if (item == 0)
671c192
<               NS_LOG_DEBUG ("no packets available for transmission");
---
>               NS_LOG_DEBUG ("no available packets in the queue");
674,676c195,196
<           // check if a block ack agreement needs to be established
<           m_currentHdr = peekedItem->GetHeader ();
<           m_currentPacket = peekedItem->GetPacket ();
---
>           m_currentHdr = item->GetHeader ();
>           m_currentPacketTimestamp = item->GetTimeStamp ();
679,680c199
<               && (!m_baManager->ExistsAgreement (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid ())
<                   || m_baManager->ExistsAgreementInState (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid (), OriginatorBlockAckAgreement::RESET))
---
>               && !m_baManager->ExistsAgreement (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid ())
685,724c204
< 
<           m_stationManager->UpdateFragmentationThreshold ();
<           Ptr<WifiMacQueueItem> item;
<           // non-broadcast QoS Data frames may be sent in MU PPDUs. Given that at this stage
<           // we do not know the bandwidth it would be given nor the selected acknowledgment
<           // sequence, we cannot determine the constraints on size and duration limit. Hence,
<           // we only peek the non-broadcast QoS Data frame. MacLow will be in charge of
<           // computing the correct limits and dequeue the frame.
<           if (peekedItem->GetHeader ().IsQosData () && !peekedItem->GetHeader ().GetAddr1 ().IsBroadcast ()
<               && !NeedFragmentation ())
<             {
<               item = Copy (peekedItem);
<             }
<           else
<             {
<               // compute the limit on the PPDU duration due to the TXOP duration, if any
<               Time ppduDurationLimit = Time::Min ();
<               //// WIGIG ////
<               if (peekedItem->GetHeader ().IsQosData () && (GetTxopLimit ().IsStrictlyPositive () || m_allocationDuration.IsStrictlyPositive ()))
<                 {
<                   MacLowTransmissionParameters params = GetTransmissionParameters (peekedItem);
<                   ppduDurationLimit = GetPpduDurationLimit (peekedItem, params);
<                 }
<               //// WIGIG ////
< //              if (peekedItem->GetHeader ().IsQosData () && GetTxopLimit ().IsStrictlyPositive ())
< //                {
< //                  MacLowTransmissionParameters params = GetTransmissionParameters (peekedItem);
< //                  ppduDurationLimit = GetTxopRemaining () - m_low->CalculateOverheadTxTime (peekedItem, params);
< //                }
< 
<               // dequeue the peeked item if it fits within the TXOP duration, if any
<               item = DequeuePeekedFrame (peekedItem, m_low->GetDataTxVector (peekedItem),
<                                          !NeedFragmentation (), 0, ppduDurationLimit);
<             }
< 
<           if (item == 0)
<             {
<               NS_LOG_DEBUG ("Not enough time in the current TXOP");
<               return;
<             }
---
>           item = m_queue->DequeueFirstAvailable (m_qosBlockedDestinations);
727a208
>           NS_ASSERT (m_currentPacket != 0);
728a210,215
>           uint16_t sequence = m_txMiddle->GetNextSequenceNumberFor (&m_currentHdr);
>           m_currentHdr.SetSequenceNumber (sequence);
>           m_stationManager->UpdateFragmentationThreshold ();
>           m_currentHdr.SetFragmentNumber (0);
>           m_currentHdr.SetNoMoreFragments ();
>           m_currentHdr.SetNoRetry ();
729a217,223
>           NS_LOG_DEBUG ("dequeued size=" << m_currentPacket->GetSize () <<
>                         ", to=" << m_currentHdr.GetAddr1 () <<
>                         ", seq=" << m_currentHdr.GetSequenceControl ());
>           if (m_currentHdr.IsQosData () && !m_currentHdr.GetAddr1 ().IsBroadcast ())
>             {
>               VerifyBlockAck ();
>             }
731d224
<       NS_ASSERT (m_currentPacket != 0);
733,736d225
<   Ptr<WifiMacQueueItem> mpdu = Create <WifiMacQueueItem> (m_currentPacket, m_currentHdr,
<                                                           m_currentPacketTimestamp);
<   m_currentParams = GetTransmissionParameters (mpdu);
< 
738a228,230
>       m_currentParams.DisableRts ();
>       m_currentParams.DisableAck ();
>       m_currentParams.DisableNextData ();
740c232
<       m_low->StartTransmission (mpdu, m_currentParams, this);
---
>       m_low->StartTransmission (m_currentPacket, &m_currentHdr, m_currentParams, this);
742,746c234
<   //With COMPRESSED_BLOCK_ACK fragmentation must be avoided.
<   else if (((m_currentHdr.IsQosData () && !m_currentHdr.IsQosAmsdu ())
<             || (m_currentHdr.IsData () && !m_currentHdr.IsQosData ()))
<            && (GetBlockAckThreshold () == 0 || m_blockAckType == BASIC_BLOCK_ACK)
<            && NeedFragmentation ())
---
>   else if (m_currentHdr.GetType () == WIFI_MAC_CTL_BACKREQ)
748,752c236,240
<       m_currentIsFragmented = true;
<       m_currentParams.DisableRts ();
<       WifiMacHeader hdr;
<       Ptr<Packet> fragment = GetFragmentPacket (&hdr);
<       if (IsLastFragment ())
---
>       SendBlockAckRequest (m_currentBar);
>     }
>   else
>     {
>       if (m_currentHdr.IsQosData () && m_currentHdr.IsQosBlockAck ())
754,755c242
<           NS_LOG_DEBUG ("fragmenting last fragment size=" << fragment->GetSize ());
<           m_currentParams.DisableNextData ();
---
>           m_currentParams.DisableAck ();
759,760c246,323
<           NS_LOG_DEBUG ("fragmenting size=" << fragment->GetSize ());
<           m_currentParams.EnableNextData (GetNextFragmentSize ());
---
>           m_currentParams.EnableAck ();
>         }
>       //With COMPRESSED_BLOCK_ACK fragmentation must be avoided.
>       if (((m_currentHdr.IsQosData () && !m_currentHdr.IsQosAmsdu ())
>            || (m_currentHdr.IsData () && !m_currentHdr.IsQosData ()))
>           && (GetBlockAckThreshold () == 0 || m_blockAckType == BASIC_BLOCK_ACK)
>           && NeedFragmentation ())
>         {
>           m_currentIsFragmented = true;
>           m_currentParams.DisableRts ();
>           WifiMacHeader hdr;
>           Ptr<Packet> fragment = GetFragmentPacket (&hdr);
>           if (IsLastFragment ())
>             {
>               NS_LOG_DEBUG ("fragmenting last fragment size=" << fragment->GetSize ());
>               m_currentParams.DisableNextData ();
>             }
>           else
>             {
>               NS_LOG_DEBUG ("fragmenting size=" << fragment->GetSize ());
>               m_currentParams.EnableNextData (GetNextFragmentSize ());
>             }
>           m_low->StartTransmission (fragment, &hdr, m_currentParams, this);
>         }
>       else
>         {
>           m_currentIsFragmented = false;
>           WifiMacHeader peekedHdr;
>           Ptr<const WifiMacQueueItem> item;
>           if (m_currentHdr.IsQosData ()
>               && (item = m_queue->PeekByTidAndAddress (m_currentHdr.GetQosTid (),
>                                                        m_currentHdr.GetAddr1 ()))
>               && !m_currentHdr.GetAddr1 ().IsBroadcast ()
>               && m_msduAggregator != 0 && !m_currentHdr.IsRetry ())
>             {
>               peekedHdr = item->GetHeader ();
>               /* here is performed aggregation */
>               Ptr<Packet> currentAggregatedPacket = Create<Packet> ();
>               m_msduAggregator->Aggregate (m_currentPacket, currentAggregatedPacket,
>                                            MapSrcAddressForAggregation (peekedHdr),
>                                            MapDestAddressForAggregation (peekedHdr));
>               bool aggregated = false;
>               bool isAmsdu = false;
>               Ptr<const WifiMacQueueItem> peekedItem = m_queue->PeekByTidAndAddress (m_currentHdr.GetQosTid (),
>                                                                                      m_currentHdr.GetAddr1 ());
>               while (peekedItem != 0)
>                 {
>                   peekedHdr = peekedItem->GetHeader ();
>                   aggregated = m_msduAggregator->Aggregate (peekedItem->GetPacket (), currentAggregatedPacket,
>                                                             MapSrcAddressForAggregation (peekedHdr),
>                                                             MapDestAddressForAggregation (peekedHdr));
>                   if (aggregated)
>                     {
>                       isAmsdu = true;
>                       m_queue->Remove (peekedItem->GetPacket ());
>                     }
>                   else
>                     {
>                       break;
>                     }
>                   peekedItem = m_queue->PeekByTidAndAddress (m_currentHdr.GetQosTid (),
>                                                              m_currentHdr.GetAddr1 ());
>                 }
>               if (isAmsdu)
>                 {
>                   m_currentHdr.SetQosAmsdu ();
>                   m_currentHdr.SetAddr3 (m_low->GetBssid ());
>                   m_currentPacket = currentAggregatedPacket;
>                   currentAggregatedPacket = 0;
>                   NS_LOG_DEBUG ("tx unicast A-MSDU");
>                 }
>             }
>           m_currentParams.DisableNextData ();
>           m_low->StartTransmission (m_currentPacket, &m_currentHdr, m_currentParams, this);
>           if (!GetAmpduExist (m_currentHdr.GetAddr1 ()))
>             {
>               CompleteTx ();
>             }
762,775d324
<       m_low->StartTransmission (Create<WifiMacQueueItem> (fragment, hdr),
<                                 m_currentParams, this);
<     }
<   else
<     {
<       //// WIGIG //// (CHECK IF IT IS CORRECT)
<       /* Check if more MSDUs are buffered for transmission */
< //      if (m_queue->HasPacketsForReceiver (m_peerStation))
< //        {
< //          m_currentHdr.SetMoreData ();
< //        }
<       //// WIGIG //// (CHECK IF IT IS CORRECT)
<       m_currentIsFragmented = false;
<       m_low->StartTransmission (mpdu, m_currentParams, this);
782c331
<   bool resetTxop = false;
---
>   bool resetDcf = false;
789,790c338
<       Ptr<const WifiMacQueueItem> item = PeekNextFrame ();
<       if (item)
---
>       if (m_baManager->HasPackets ())
792,793c340,349
<           packet = item->GetPacket ();
<           header = item->GetHeader ();
---
>           packet = m_baManager->GetNextPacket (header, false);
>         }
>       else
>         {
>           Ptr<const WifiMacQueueItem> item = m_queue->Peek ();
>           if (item)
>             {
>               packet = item->GetPacket ();
>               header = item->GetHeader ();
>             }
807c363
<               resetTxop = true;
---
>               resetDcf = true;
817c373
<           resetTxop = false;
---
>           resetDcf = false;
823c379
<               resetTxop = true;
---
>               resetDcf = true;
831c387
<       if (resetTxop)
---
>       if (resetDcf)
838c394
<           //to reset the Txop.
---
>           //to reset the dcf.
856c412,413
<   GenerateBackoff ();
---
>   m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>   StartBackoffNow (m_backoffTrace);
861c418,427
< QosTxop::NotifyMissedCts (std::list<Ptr<WifiMacQueueItem>> mpduList)
---
> QosTxop::NotifyCollision (void)
> {
>   NS_LOG_FUNCTION (this);
>   m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>   StartBackoffNow (m_backoffTrace);
>   RestartAccessIfNeeded ();
> }
> 
> void
> QosTxop::MissedCts (void)
865d430
<   NS_ASSERT (!mpduList.empty ());
868a434
>       bool resetCurrentPacket = true;
874c440,472
<       for (auto& mpdu : mpduList)
---
>       if (GetAmpduExist (m_currentHdr.GetAddr1 ()) || m_currentHdr.IsQosData ())
>         {
>           uint8_t tid = GetTid (m_currentPacket, m_currentHdr);
>           m_low->FlushAggregateQueue (tid);
> 
>           if (GetBaAgreementExists (m_currentHdr.GetAddr1 (), tid))
>             {
>               NS_LOG_DEBUG ("Transmit Block Ack Request");
>               CtrlBAckRequestHeader reqHdr;
>               reqHdr.SetType (COMPRESSED_BLOCK_ACK);
>               reqHdr.SetStartingSequence (m_txMiddle->PeekNextSequenceNumberFor (&m_currentHdr));
>               reqHdr.SetTidInfo (tid);
>               reqHdr.SetHtImmediateAck (true);
>               Ptr<Packet> bar = Create<Packet> ();
>               bar->AddHeader (reqHdr);
>               Bar request (bar, m_currentHdr.GetAddr1 (), tid, reqHdr.MustSendHtImmediateAck ());
>               m_currentBar = request;
>               WifiMacHeader hdr;
>               hdr.SetType (WIFI_MAC_CTL_BACKREQ);
>               hdr.SetAddr1 (request.recipient);
>               hdr.SetAddr2 (m_low->GetAddress ());
>               hdr.SetAddr3 (m_low->GetBssid ());
>               hdr.SetDsNotTo ();
>               hdr.SetDsNotFrom ();
>               hdr.SetNoRetry ();
>               hdr.SetNoMoreFragments ();
>               m_currentPacket = request.bar;
>               m_currentHdr = hdr;
>               resetCurrentPacket = false;
>             }
>         }
>       //to reset the dcf.
>       if (resetCurrentPacket == true)
876c474
<           m_baManager->NotifyDiscardedMpdu (mpdu);
---
>           m_currentPacket = 0;
878,879d475
<       //to reset the Txop.
<       m_currentPacket = 0;
887,900d482
<       // if a BA agreement is established, store the MPDUs in the block ack manager
<       // retransmission queue. Otherwise, this QosTxop will handle the retransmission
<       // of the (single) frame
<       if (mpduList.size () > 1 ||
<           (mpduList.front ()->GetHeader ().IsQosData ()
<            && GetBaAgreementEstablished (mpduList.front ()->GetHeader ().GetAddr1 (),
<                                          mpduList.front ()->GetHeader ().GetQosTid ())))
<         {
<           for (auto it = mpduList.rbegin (); it != mpduList.rend (); it++)
<             {
<               m_baManager->GetRetransmitQueue ()->PushFront (*it);
<             }
<           m_currentPacket = 0;
<         }
902c484,485
<   GenerateBackoff ();
---
>   m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>   StartBackoffNow (m_backoffTrace);
917c500
<           m_txOkCallback (m_currentPacket, m_currentHdr);
---
>           m_txOkCallback (m_currentHdr);
925c508,509
<           if (actionHdr.GetCategory () == WifiActionHeader::BLOCK_ACK)
---
>           if (actionHdr.GetCategory () == WifiActionHeader::BLOCK_ACK
>               && actionHdr.GetAction ().blockAck == WifiActionHeader::BLOCK_ACK_DELBA)
927c511,513
<               if (actionHdr.GetAction ().blockAck == WifiActionHeader::BLOCK_ACK_DELBA)
---
>               MgtDelBaHeader delBa;
>               p->PeekHeader (delBa);
>               if (delBa.IsByOriginator ())
929,938c515
<                   MgtDelBaHeader delBa;
<                   p->PeekHeader (delBa);
<                   if (delBa.IsByOriginator ())
<                     {
<                       m_baManager->DestroyAgreement (m_currentHdr.GetAddr1 (), delBa.GetTid ());
<                     }
<                   else
<                     {
<                       m_low->DestroyBlockAckAgreement (m_currentHdr.GetAddr1 (), delBa.GetTid ());
<                     }
---
>                   m_baManager->DestroyAgreement (m_currentHdr.GetAddr1 (), delBa.GetTid ());
940c517
<               else if (actionHdr.GetAction ().blockAck == WifiActionHeader::BLOCK_ACK_ADDBA_REQUEST)
---
>               else
942,947c519
<                   // Setup ADDBA response timeout
<                   MgtAddBaRequestHeader addBa;
<                   p->PeekHeader (addBa);
<                   Simulator::Schedule (m_addBaResponseTimeout,
<                                        &QosTxop::AddBaResponseTimeout, this,
<                                        m_currentHdr.GetAddr1 (), addBa.GetTid ());
---
>                   m_low->DestroyBlockAckAgreement (m_currentHdr.GetAddr1 (), delBa.GetTid ());
951,956d522
<       if (m_currentHdr.IsQosData () && GetBaAgreementEstablished (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid ()))
<         {
<           // notify the BA manager that the current packet was acknowledged
<           m_baManager->NotifyGotAck (Create<const WifiMacQueueItem> (m_currentPacket, m_currentHdr,
<                                                                      m_currentPacketTimestamp));
<         }
958a525,535
>       if (!HasTxop ())
>         {
>           if (m_currentHdr.IsQosData () && GetTxopLimit ().IsStrictlyPositive ())
>             {
>               m_txopTrace (m_startTxop, Simulator::Now () - m_startTxop);
>             }
>           m_cwTrace = GetCw ();
>           m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>           StartBackoffNow (m_backoffTrace);
>           RestartAccessIfNeeded ();
>         }
962a540,551
>       if (!HasTxop ())
>         {
>           if (m_currentHdr.IsQosData () && GetTxopLimit ().IsStrictlyPositive ())
>             {
>               m_txopTrace (m_startTxop, Simulator::Now () - m_startTxop);
>               m_cwTrace = GetCw ();
>               m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>               StartBackoffNow (m_backoffTrace);
>               m_fragmentNumber++;
>               RestartAccessIfNeeded ();
>             }
>         }
971,975d559
<   /* Callback if we've missed Ack/BlockAck*/
<   if (!m_missedAckCallback.IsNull ())
<     {
<       m_missedAckCallback (m_currentHdr);
<     }
980a565
>       bool resetCurrentPacket = true;
985c570
<       if (m_currentHdr.IsAction ())
---
>       if (GetAmpduExist (m_currentHdr.GetAddr1 ()) || m_currentHdr.IsQosData ())
987,989c572,574
<           WifiActionHeader actionHdr;
<           m_currentPacket->PeekHeader (actionHdr);
<           if (actionHdr.GetCategory () == WifiActionHeader::BLOCK_ACK)
---
>           uint8_t tid = GetTid (m_currentPacket, m_currentHdr);
> 
>           if (GetBaAgreementExists (m_currentHdr.GetAddr1 (), tid))
991,997c576,598
<               uint8_t tid = GetTid (m_currentPacket, m_currentHdr);
<               if (m_baManager->ExistsAgreementInState (m_currentHdr.GetAddr1 (), tid, OriginatorBlockAckAgreement::PENDING))
<                 {
<                   NS_LOG_DEBUG ("No ACK after ADDBA request");
<                   m_baManager->NotifyAgreementNoReply (m_currentHdr.GetAddr1 (), tid);
<                   Simulator::Schedule (m_failedAddBaTimeout, &QosTxop::ResetBa, this, m_currentHdr.GetAddr1 (), tid);
<                 }
---
>               //send Block ACK Request in order to shift WinStart at the receiver
>               NS_LOG_DEBUG ("Transmit Block Ack Request");
>               CtrlBAckRequestHeader reqHdr;
>               reqHdr.SetType (COMPRESSED_BLOCK_ACK);
>               reqHdr.SetStartingSequence (m_txMiddle->PeekNextSequenceNumberFor (&m_currentHdr));
>               reqHdr.SetTidInfo (tid);
>               reqHdr.SetHtImmediateAck (true);
>               Ptr<Packet> bar = Create<Packet> ();
>               bar->AddHeader (reqHdr);
>               Bar request (bar, m_currentHdr.GetAddr1 (), tid, reqHdr.MustSendHtImmediateAck ());
>               m_currentBar = request;
>               WifiMacHeader hdr;
>               hdr.SetType (WIFI_MAC_CTL_BACKREQ);
>               hdr.SetAddr1 (request.recipient);
>               hdr.SetAddr2 (m_low->GetAddress ());
>               hdr.SetAddr3 (m_low->GetBssid ());
>               hdr.SetDsNotTo ();
>               hdr.SetDsNotFrom ();
>               hdr.SetNoRetry ();
>               hdr.SetNoMoreFragments ();
>               m_currentPacket = request.bar;
>               m_currentHdr = hdr;
>               resetCurrentPacket = false;
1000c601,602
<       if (GetAmpduExist (m_currentHdr.GetAddr1 ()) || m_currentHdr.IsQosData ())
---
>       //to reset the dcf.
>       if (resetCurrentPacket == true)
1002c604
<           m_baManager->NotifyDiscardedMpdu (Create<const WifiMacQueueItem> (m_currentPacket, m_currentHdr));
---
>           m_currentPacket = 0;
1004d605
<       m_currentPacket = 0;
1011,1012d611
<       m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr,
<                                           m_currentPacket->GetSize ());
1014,1022d612
<       // std::cout << "MissedAck size= " << m_currentHdr.GetAddr2() << "   ";
<       if (m_currentHdr.IsQosData () && GetBaAgreementEstablished (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid ()))
<         {
<           // notify the BA manager that the current packet was not acknowledged
<           m_baManager->NotifyMissedAck (Create<WifiMacQueueItem> (m_currentPacket, m_currentHdr,
<                                                                   m_currentPacketTimestamp));
<           // let the BA manager handle its retransmission
<           m_currentPacket = 0;
<         }
1026c616,617
<   GenerateBackoff ();
---
>   m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>   StartBackoffNow (m_backoffTrace);
1034,1038d624
<   /*
<    * If the BlockAck frame is lost, the originator may transmit a BlockAckReq
<    * frame to solicit an immediate BlockAck frame or it may retransmit the Data
<    * frames. (IEEE std 802.11-2016 sec. 10.24.7.7
<    */
1040,1041c626
<   /* Callback if we've missed Ack/BlockAck*/
<   if (!m_missedAckCallback.IsNull ())
---
>   if (GetAmpduExist (m_currentHdr.GetAddr1 ()))
1043c628
<       m_missedAckCallback (m_currentHdr);
---
>       m_stationManager->ReportAmpduTxStatus (m_currentHdr.GetAddr1 (), tid, 0, nMpdus, 0, 0);
1045c630
<   if (m_useExplicitBarAfterMissedBlockAck || m_currentHdr.IsBlockAckReq ())
---
>   if (NeedBarRetransmission ())
1047c632
<       if (NeedBarRetransmission ())
---
>       if (!GetAmpduExist (m_currentHdr.GetAddr1 ()))
1048a634
>           //should i report this to station addressed by ADDR1?
1050,1061c636
<           if (m_currentHdr.IsBlockAckReq ())
<             {
<               m_currentHdr.SetRetry ();
<               UpdateFailedCw ();
<               m_cwTrace = GetCw ();
<             }
<           else // missed BlockAck after data frame with Implicit BAR Ack Policy
<             {
<               Ptr<const WifiMacQueueItem> bar = PrepareBlockAckRequest (m_currentHdr.GetAddr1 (), tid);
<               ScheduleBar (bar);
<               m_currentPacket = 0;
<             }
---
>           m_currentHdr.SetRetry ();
1065,1092c640,677
<           NS_LOG_DEBUG ("Block Ack Request Fail");
<           // if a BA agreement exists, we can get here if there is no outstanding
<           // MPDU whose lifetime has not expired yet.
<           m_stationManager->ReportFinalDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr,
<                                                    m_currentPacket->GetSize ());
<           if (m_baManager->ExistsAgreementInState (m_currentHdr.GetAddr1 (), tid,
<                                                    OriginatorBlockAckAgreement::ESTABLISHED))
<             {
<               // If there is any (expired) outstanding MPDU, request the BA manager to discard
<               // it, which involves the scheduling of a BAR to advance the recipient's window
<               if (m_baManager->GetNBufferedPackets (m_currentHdr.GetAddr1 (), tid) > 0)
<                 {
<                   m_baManager->DiscardOutstandingMpdus (m_currentHdr.GetAddr1 (), tid);
<                 }
<               // otherwise, it means that we have not received a BlockAck in response to a
<               // BlockAckRequest sent while no frame was outstanding, whose purpose was therefore
<               // to advance the recipient's window. Schedule a BlockAckRequest with
<               // skipIfNoDataQueued set to true, so that the BlockAckRequest is only sent
<               // if there are data frames queued for this recipient.
<               else
<                 {
<                   ScheduleBar (PrepareBlockAckRequest (m_currentHdr.GetAddr1 (), tid), true);
<                 }
<             }
<           //to reset the Txop.
<           m_currentPacket = 0;
<           ResetCw ();
<           m_cwTrace = GetCw ();
---
>           //standard says when losing a BlockAck originator may send a BAR page 139
>           NS_LOG_DEBUG ("Transmit Block Ack Request");
>           CtrlBAckRequestHeader reqHdr;
>           reqHdr.SetType (COMPRESSED_BLOCK_ACK);
>           if (m_currentHdr.IsQosData ())
>             {
>               reqHdr.SetStartingSequence (m_currentHdr.GetSequenceNumber ());
>             }
>           else if (m_currentHdr.IsBlockAckReq ())
>             {
>               CtrlBAckRequestHeader baReqHdr;
>               m_currentPacket->PeekHeader (baReqHdr);
>               reqHdr.SetStartingSequence (baReqHdr.GetStartingSequence ());
>             }
>           else if (m_currentHdr.IsBlockAck ())
>             {
>               CtrlBAckResponseHeader baRespHdr;
>               m_currentPacket->PeekHeader (baRespHdr);
>               reqHdr.SetStartingSequence (m_currentHdr.GetSequenceNumber ());
>             }
>           reqHdr.SetTidInfo (tid);
>           reqHdr.SetHtImmediateAck (true);
>           Ptr<Packet> bar = Create<Packet> ();
>           bar->AddHeader (reqHdr);
>           Bar request (bar, m_currentHdr.GetAddr1 (), tid, reqHdr.MustSendHtImmediateAck ());
>           m_currentBar = request;
>           WifiMacHeader hdr;
>           hdr.SetType (WIFI_MAC_CTL_BACKREQ);
>           hdr.SetAddr1 (request.recipient);
>           hdr.SetAddr2 (m_low->GetAddress ());
>           hdr.SetAddr3 (m_low->GetBssid ());
>           hdr.SetDsNotTo ();
>           hdr.SetDsNotFrom ();
>           hdr.SetNoRetry ();
>           hdr.SetNoMoreFragments ();
> 
>           m_currentPacket = request.bar;
>           m_currentHdr = hdr;
1093a679,680
>       UpdateFailedCw ();
>       m_cwTrace = GetCw ();
1097,1140c684,688
<       if (GetAmpduExist (m_currentHdr.GetAddr1 ()))
<         {
<           m_stationManager->ReportAmpduTxStatus (m_currentHdr.GetAddr1 (), 0, nMpdus, 0, 0, WifiTxVector ());
<         }
<       // implicit BAR and do not use BAR after missed BlockAck, hence try to retransmit data frames
<       if (!NeedDataRetransmission (m_currentPacket, m_currentHdr))
<         {
<           NS_LOG_DEBUG ("Block Ack Fail");
<           m_stationManager->ReportFinalDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr,
<                                                    m_currentPacket->GetSize ());
<           if (!m_txFailedCallback.IsNull ())
<             {
<               m_txFailedCallback (m_currentHdr);
<             }
<           if (m_currentHdr.IsAction ())
<             {
<               WifiActionHeader actionHdr;
<               m_currentPacket->PeekHeader (actionHdr);
<               if (actionHdr.GetCategory () == WifiActionHeader::BLOCK_ACK)
<                 {
<                   uint8_t tid = GetTid (m_currentPacket, m_currentHdr);
<                   if (m_baManager->ExistsAgreementInState (m_currentHdr.GetAddr1 (), tid, OriginatorBlockAckAgreement::PENDING))
<                     {
<                       NS_LOG_DEBUG ("No ACK after ADDBA request");
<                       m_baManager->NotifyAgreementNoReply (m_currentHdr.GetAddr1 (), tid);
<                       Simulator::Schedule (m_failedAddBaTimeout, &QosTxop::ResetBa, this, m_currentHdr.GetAddr1 (), tid);
<                     }
<                 }
<             }
<           //to reset the Txop.
<           m_baManager->DiscardOutstandingMpdus (m_currentHdr.GetAddr1 (), GetTid (m_currentPacket, m_currentHdr));
<           m_currentPacket = 0;
<           ResetCw ();
<           m_cwTrace = GetCw ();
<         }
<       else
<         {
<           NS_LOG_DEBUG ("Retransmit");
<           m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr, m_currentPacket->GetSize ());
<           m_baManager->NotifyMissedBlockAck (m_currentHdr.GetAddr1 (), tid);
<           m_currentPacket = 0;
<           UpdateFailedCw ();
<           m_cwTrace = GetCw ();
<         }
---
>       NS_LOG_DEBUG ("Block Ack Request Fail");
>       //to reset the dcf.
>       m_currentPacket = 0;
>       ResetCw ();
>       m_cwTrace = GetCw ();
1142c690,691
<   GenerateBackoff ();
---
>   m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>   StartBackoffNow (m_backoffTrace);
1145a695,706
> Ptr<MsduAggregator>
> QosTxop::GetMsduAggregator (void) const
> {
>   return m_msduAggregator;
> }
> 
> Ptr<MpduAggregator>
> QosTxop::GetMpduAggregator (void) const
> {
>   return m_mpduAggregator;
> }
> 
1150,1187c711,724
< 
<   // check if the BA manager retransmit queue is empty, so that expired
<   // frames (if any) are removed and a BlockAckRequest is scheduled to advance
<   // the starting sequence number of the transmit (and receiver) window
<   bool baManagerHasPackets = m_baManager->HasPackets ();
<   // remove MSDUs with expired lifetime starting from the head of the queue
<   bool queueIsNotEmpty = !m_queue->IsEmpty ();
< 
<   if ((m_stationManager->HasDmgSupported () || m_stationManager->HasEdmgSupported ()) && GetTypeOfStation () != DMG_ADHOC)
<     {
<       if (m_allocationType == CBAP_ALLOCATION)
<         {
<           if ((m_currentPacket != 0 || baManagerHasPackets || queueIsNotEmpty)
<               && !IsAccessRequested ()
<               && m_channelAccessManager->IsAccessAllowed ()
<               && !m_low->IsTransmissionSuspended ()
<               && !m_low->Is_Performing_SLS ()
<               && !m_low->Is_Performing_MIMO_BFT ())
<             {
<               Ptr<const WifiMacQueueItem> item;
<               if (m_currentPacket != 0)
<                 {
<                   item = Create<const WifiMacQueueItem> (m_currentPacket, m_currentHdr);
<                 }
<               else
<                 {
<                   item = PeekNextFrame ();
<                 }
<               if (item != 0)
<                 {
<                   m_isAccessRequestedForRts = m_stationManager->NeedRts (item->GetHeader (), item->GetSize ());
<                 }
<               else
<                 {
<                   m_isAccessRequestedForRts = false;
<                 }
<               m_channelAccessManager->RequestAccess (this);
<             }
---
>   if ((m_currentPacket != 0
>        || !m_queue->IsEmpty () || m_baManager->HasPackets ())
>       && !IsAccessRequested ())
>     {
>       Ptr<const Packet> packet;
>       WifiMacHeader hdr;
>       if (m_currentPacket != 0)
>         {
>           packet = m_currentPacket;
>           hdr = m_currentHdr;
>         }
>       else if (m_baManager->HasPackets ())
>         {
>           packet = m_baManager->GetNextPacket (hdr, false);
1191,1194c728,729
<           if ((m_currentPacket != 0 || baManagerHasPackets || queueIsNotEmpty)
<               && !IsAccessRequested ()
<               && m_accessAllowed
<               && !m_low->IsTransmissionSuspended ())
---
>           Ptr<const WifiMacQueueItem> item = m_queue->PeekFirstAvailable (m_qosBlockedDestinations);
>           if (item)
1196c731,733
<               m_channelAccessManager->RequestAccess (this, true);
---
>               packet = item->GetPacket ();
>               hdr = item->GetHeader ();
>               m_currentPacketTimestamp = item->GetTimeStamp ();
1199,1203c736
<     }
<   else
<     {
<       if ((m_currentPacket != 0 || baManagerHasPackets || queueIsNotEmpty)
<           && !IsAccessRequested ())
---
>       if (packet != 0)
1205,1222c738,742
<           Ptr<const WifiMacQueueItem> item;
<           if (m_currentPacket != 0)
<             {
<               item = Create<const WifiMacQueueItem> (m_currentPacket, m_currentHdr);
<             }
<           else
<             {
<               item = PeekNextFrame ();
<             }
<           if (item != 0)
<             {
<               m_isAccessRequestedForRts = m_stationManager->NeedRts (item->GetHeader (), item->GetSize ());
<             }
<           else
<             {
<               m_isAccessRequestedForRts = false;
<             }
<           m_channelAccessManager->RequestAccess (this);
---
>           m_isAccessRequestedForRts = m_stationManager->NeedRts (hdr.GetAddr1 (), &hdr, packet, m_low->GetDataTxVector (packet, &hdr));
>         }
>       else
>         {
>           m_isAccessRequestedForRts = false;
1223a744
>       m_channelAccessManager->RequestAccess (this);
1230,1264c751,758
<   NS_LOG_FUNCTION (this);
< 
<   // check if the BA manager retransmit queue is empty, so that expired
<   // frames (if any) are removed and a BlockAckRequest is scheduled to advance
<   // the starting sequence number of the transmit (and receiver) window
<   bool baManagerHasPackets = m_baManager->HasPackets ();
<   // remove MSDUs with expired lifetime starting from the head of the queue
<   bool queueIsNotEmpty = !m_queue->IsEmpty ();
< 
<   /* We removed m_currentPacket since we might have a suspended Transmission */
<   if ((m_stationManager->HasDmgSupported () || m_stationManager->HasEdmgSupported ()) && GetTypeOfStation () != DMG_ADHOC)
<     {
<       if (m_allocationType == CBAP_ALLOCATION)
<         {
<           if (((m_firstTransmission && m_currentPacket != 0) || m_currentPacket == 0)
<               && (queueIsNotEmpty || baManagerHasPackets)
<               && !IsAccessRequested ()
<               && m_channelAccessManager->IsAccessAllowed ()
<               && !m_low->IsTransmissionSuspended ()
<               && !m_low->Is_Performing_SLS ()
<               && !m_low->Is_Performing_MIMO_BFT ())
<             {
<               Ptr<const WifiMacQueueItem> item = PeekNextFrame ();
<               if (item != 0)
<                 {
<                   m_isAccessRequestedForRts = m_stationManager->NeedRts (item->GetHeader (), item->GetSize ());
<                 }
<               else
<                 {
<                   m_isAccessRequestedForRts = false;
<                 }
<               m_channelAccessManager->RequestAccess (this);
<             }
<         }
<       else
---
>   //NS_LOG_FUNCTION (this);
>   if (m_currentPacket == 0
>       && (!m_queue->IsEmpty () || m_baManager->HasPackets ())
>       && !IsAccessRequested ())
>     {
>       Ptr<const Packet> packet;
>       WifiMacHeader hdr;
>       if (m_baManager->HasPackets ())
1266,1272c760
<           if ((m_allocationType == SERVICE_PERIOD_ALLOCATION)
<              && (m_currentPacket == 0) && (baManagerHasPackets || queueIsNotEmpty)
<              && !IsAccessRequested ()
<              && m_accessAllowed && !m_low->IsTransmissionSuspended ())
<             {
<               m_channelAccessManager->RequestAccess (this, true);
<             }
---
>           packet = m_baManager->GetNextPacket (hdr, false);
1274,1279c762
<     }
<   else
<     {
<       if (m_currentPacket == 0
<           && (baManagerHasPackets || queueIsNotEmpty)
<           && !IsAccessRequested ())
---
>       else
1281,1282c764,765
<           Ptr<const WifiMacQueueItem> item = PeekNextFrame ();
<           if (item != 0)
---
>           Ptr<const WifiMacQueueItem> item = m_queue->PeekFirstAvailable (m_qosBlockedDestinations);
>           if (item)
1284c767,769
<               m_isAccessRequestedForRts = m_stationManager->NeedRts (item->GetHeader (), item->GetSize ());
---
>               packet = item->GetPacket ();
>               hdr = item->GetHeader ();
>               m_currentPacketTimestamp = item->GetTimeStamp ();
1286,1290d770
<           else
<             {
<               m_isAccessRequestedForRts = false;
<             }
<           m_channelAccessManager->RequestAccess (this);
1292,1314c772
<     }
< }
< 
< //// WIGIG ////
< void
< QosTxop::StartAllocationPeriod (AllocationType allocationType, AllocationID allocationID,
<                                 Mac48Address peerStation, Time allocationDuration)
< {
<   NS_LOG_FUNCTION (this << allocationType << +allocationID << peerStation << allocationDuration << +m_ac);
<   m_allocationType = allocationType;
<   m_allocationID = allocationID;
<   m_peerStation = peerStation;
<   m_allocationDuration = allocationDuration;
<   if (m_allocationType == CBAP_ALLOCATION)
<     {
<       m_firstTransmission = true;
<       m_allocationStart = Simulator::Now ();
<       ResetState ();
< 
<       /* Check if we have stored packet for this allocation period */
<       StoredPacketsCI it = m_storedPackets.find (m_allocationID);
<       NS_LOG_DEBUG ("StoredPackets=" << m_storedPackets.size () << " , AllocationID=" << +m_allocationID);
<       if (it != m_storedPackets.end ())
---
>       if (packet != 0)
1316,1319c774
<           PacketInformation info = it->second;
<           m_currentPacket = info.first;
<           m_currentHdr = info.second;
<           NS_LOG_DEBUG ("Restored packet with seq=0x" << std::hex << m_currentHdr.GetSequenceControl ());
---
>           m_isAccessRequestedForRts = m_stationManager->NeedRts (hdr.GetAddr1 (), &hdr, packet, m_low->GetDataTxVector (packet, &hdr));
1321,1323c776
<       /* Do the contention access by Channel Access Manager */
<       if ((!m_queue->IsEmpty () || m_baManager->HasPackets () || m_currentPacket != 0)
<           && !IsAccessRequested ())
---
>       else
1325c778
<           m_channelAccessManager->RequestAccess (this);
---
>           m_isAccessRequestedForRts = false;
1326a780
>       m_channelAccessManager->RequestAccess (this);
1330,1394d783
< void
< QosTxop::InitiateServicePeriodTransmission (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_accessAllowed = true;
<   m_firstTransmission = true;
<   m_allocationStart = Simulator::Now ();
< 
<   /* Check if we have stored packet for this service period (MSDU/A-MSDU) */
<   StoredPacketsCI it = m_storedPackets.find (m_allocationID);
<   NS_LOG_DEBUG ("Count=" << m_storedPackets.size () << " , AllocationID=" << +m_allocationID);
<   if (it != m_storedPackets.end ())
<     {
<       PacketInformation info = it->second;
<       m_currentPacket = info.first;
<       m_currentHdr = info.second;
<       NS_LOG_DEBUG ("Restored packet with seq=0x" << std::hex << m_currentHdr.GetSequenceControl ());
<     }
< 
<   /* Start access if we have packets in the queue or packets that need retransmit or non-restored transmission */
<   NS_LOG_DEBUG (m_queue->IsEmpty () << ", " << m_baManager->HasPackets () << ", " <<
<                 m_low->CompletedSuspendedPsduTransmission (this) << ", " << m_currentPacket << ", " << m_queue->GetNPackets ());
< 
<   if (!m_queue->IsEmpty () || m_baManager->HasPackets ()
<       || !m_low->CompletedSuspendedPsduTransmission (this) || m_currentPacket != 0)
<     {
<       m_channelAccessManager->RequestAccess (this, true);
<     }
< }
< 
< void
< QosTxop::ResumeTransmission (Time periodDuration)
< {
<   NS_LOG_FUNCTION (this << periodDuration);
<   m_allocationDuration = periodDuration;
<   m_allocationStart = Simulator::Now ();
<   m_accessAllowed = true;
<   if (!m_queue->IsEmpty () || m_baManager->HasPackets ())
<     {
<       m_channelAccessManager->RequestAccess (this, true);
<     }
< }
< 
< void
< QosTxop::AllowChannelAccess (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_accessAllowed = true;
< }
< 
< void
< QosTxop::DisableChannelAccess (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_accessAllowed = false;
< }
< 
< void
< QosTxop::SetMissedAckCallback (TxFailed callback)
< {
<   NS_LOG_FUNCTION (this << &callback);
<   m_missedAckCallback = callback;
< }
< //// WIGIG ////
< 
1398a788
>   uint16_t seqNumber = 0;
1401a792
>       seqNumber = m_currentHdr.GetSequenceNumber ();
1407a799
>       seqNumber = baReqHdr.GetStartingSequence ();
1413a806
>       seqNumber = m_currentHdr.GetSequenceNumber ();
1415c808
<   return m_baManager->NeedBarRetransmission (tid, m_currentHdr.GetAddr1 ());
---
>   return m_baManager->NeedBarRetransmission (tid, seqNumber, m_currentHdr.GetAddr1 ());
1422,1428c815,829
<   NS_ASSERT (GetTxopLimit ().IsStrictlyPositive () && GetTxopRemaining ().IsStrictlyPositive ());
< 
<   m_currentPacket = 0;
<   // peek the next BlockAckReq, if any
<   Ptr<const WifiMacQueueItem> nextFrame = m_baManager->GetBar (false);
< 
<   if (nextFrame == 0)
---
>   Time txopLimit = GetTxopLimit ();
>   NS_ASSERT (txopLimit.IsZero () || Simulator::Now () - m_startTxop <= txopLimit);
>   WifiMacHeader hdr = m_currentHdr;
>   Ptr<const Packet> peekedPacket = m_baManager->GetNextPacket (hdr, true);
>   if (peekedPacket == 0)
>     {
>       Ptr<const WifiMacQueueItem> peekedItem = m_queue->PeekByTidAndAddress (m_currentHdr.GetQosTid (),
>                                                                              m_currentHdr.GetAddr1 ());
>       if (peekedItem)
>         {
>           peekedPacket = peekedItem->GetPacket ();
>           hdr = peekedItem->GetHeader ();
>         }
>     }
>   if ((m_currentHdr.IsQosBlockAck () && peekedPacket == 0) || m_baManager->HasBar (m_currentBar))
1430c831,832
<       nextFrame = PeekNextFrame ();
---
>       SendBlockAckRequest (m_currentBar);
>       return;
1432,1433c834
< 
<   if (nextFrame != 0)
---
>   else if (peekedPacket == 0)
1435,1437c836
<       MacLowTransmissionParameters params = GetTransmissionParameters (nextFrame);
< 
<       if (GetTxopRemaining () >= m_low->CalculateOverallTxTime (nextFrame->GetPacket (), &nextFrame->GetHeader (), params))
---
>       if (txopLimit.IsStrictlyPositive ())
1439,1482c838,839
<           // check if a block ack agreement needs to be established
<           m_currentHdr = nextFrame->GetHeader ();
<           m_currentPacket = nextFrame->GetPacket ();
<           if (m_currentHdr.IsQosData () && !m_currentHdr.GetAddr1 ().IsBroadcast ()
<               && m_stationManager->GetQosSupported (m_currentHdr.GetAddr1 ())
<               && (!m_baManager->ExistsAgreement (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid ())
<                   || m_baManager->ExistsAgreementInState (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid (), OriginatorBlockAckAgreement::RESET))
<               && SetupBlockAckIfNeeded ())
<             {
<               return;
<             }
< 
<           Ptr<WifiMacQueueItem> item;
<           if (nextFrame->GetHeader ().IsBlockAckReq ())
<             {
<               item = Copy (m_baManager->GetBar ());
<             }
<           // non-broadcast QoS Data frames may be sent in MU PPDUs. Given that at this stage
<           // we do not know the bandwidth it would be given nor the selected acknowledgment
<           // sequence, we cannot determine the constraints on size and duration limit. Hence,
<           // we only peek the non-broadcast QoS Data frame. MacLow will be in charge of
<           // computing the correct limits and dequeue the frame.
<           else if (nextFrame->GetHeader ().IsQosData () && !nextFrame->GetHeader ().GetAddr1 ().IsBroadcast ())
<             {
<               item = Copy (nextFrame);
<             }
<           else
<             {
<               // dequeue the peeked frame
<               item = DequeuePeekedFrame (nextFrame, m_low->GetDataTxVector (nextFrame));
<             }
< 
<           NS_ASSERT (item != 0);
<           NS_LOG_DEBUG ("start next packet " << *item << " within the current TXOP");
<           m_currentPacket = item->GetPacket ();
<           m_currentHdr = item->GetHeader ();
<           m_currentPacketTimestamp = item->GetTimeStamp ();
<           NS_ASSERT (m_currentPacket != 0);
< 
<           m_currentParams = params;
<           m_stationManager->UpdateFragmentationThreshold ();
<           m_fragmentNumber = 0;
<           GetLow ()->StartTransmission (item, m_currentParams, this);
<           return;
---
>           NS_ASSERT (Simulator::Now () - m_startTxop <= txopLimit);
>           m_txopTrace (m_startTxop, Simulator::Now () - m_startTxop);
1483a841
>       return;
1485,1494c843,875
< 
<   // terminate TXOP because no (suitable) frame was found
<   TerminateTxop ();
< }
< 
< void
< QosTxop::TerminateTxop (void)
< {
<   NS_LOG_FUNCTION (this);
<   if (GetTxopLimit ().IsStrictlyPositive ())
---
>   m_currentParams.DisableNextData ();
>   if (m_currentHdr.IsQosData () && m_currentHdr.IsQosBlockAck ())
>     {
>       m_currentParams.DisableAck ();
>     }
>   else
>     {
>       m_currentParams.EnableAck ();
>     }
>   if (txopLimit >= GetLow ()->CalculateOverallTxTime (peekedPacket, &hdr, m_currentParams))
>     {
>       NS_LOG_DEBUG ("start next packet");
>       Ptr<WifiMacQueueItem> item = m_queue->DequeueByTidAndAddress (m_currentHdr.GetQosTid (),
>                                                                     m_currentHdr.GetAddr1 ());
>       NS_ASSERT (item != 0);
>       m_currentPacket = item->GetPacket ();
>       m_currentHdr = item->GetHeader ();
>       NS_ASSERT (m_currentPacket != 0);
>       uint16_t sequence = m_txMiddle->GetNextSequenceNumberFor (&m_currentHdr);
>       m_currentHdr.SetSequenceNumber (sequence);
>       m_stationManager->UpdateFragmentationThreshold ();
>       m_currentHdr.SetFragmentNumber (0);
>       m_currentHdr.SetNoMoreFragments ();
>       m_currentHdr.SetNoRetry ();
>       m_fragmentNumber = 0;
>       VerifyBlockAck ();
>       GetLow ()->StartTransmission (m_currentPacket, &m_currentHdr, m_currentParams, this);
>       if (!GetAmpduExist (m_currentHdr.GetAddr1 ()))
>         {
>           CompleteTx ();
>         }
>     }
>   else if (txopLimit.IsStrictlyPositive ())
1496d876
<       NS_LOG_DEBUG ("Terminating TXOP. Duration = " << Simulator::Now () - m_startTxop);
1499,1500d878
<   GenerateBackoff ();
<   RestartAccessIfNeeded ();
1515a894,931
> bool
> QosTxop::HasTxop (void) const
> {
>   NS_LOG_FUNCTION (this);
>   WifiMacHeader hdr;
>   if (!m_currentHdr.IsQosData () || GetTxopLimit ().IsZero ())
>     {
>       return false;
>     }
> 
>   Ptr<const WifiMacQueueItem> peekedItem = m_queue->PeekByTidAndAddress (m_currentHdr.GetQosTid (),
>                                                                          m_currentHdr.GetAddr1 ());
>   if (peekedItem == 0)
>     {
>       return false;
>     }
> 
>   Ptr<const Packet> peekedPacket = peekedItem->GetPacket ();
>   hdr = peekedItem->GetHeader ();
>   MacLowTransmissionParameters params = m_currentParams;
>   if (m_currentHdr.IsQosData () && m_currentHdr.IsQosBlockAck ())
>     {
>       params.DisableAck ();
>     }
>   else
>     {
>       params.EnableAck ();
>     }
> 
>   Time duration = GetLow ()->CalculateOverallTxTime (peekedPacket, &hdr, params);
>   if (m_currentPacket != 0)
>     {
>       //take into account current transmission in duration
>       duration += GetLow ()->CalculateOverallTxTime (m_currentPacket, &m_currentHdr, params);
>     }
>   return (GetTxopRemaining () >= duration);
> }
> 
1520a937,940
>   if (m_currentHdr.IsQosData () && m_currentHdr.IsQosBlockAck () && GetTxopLimit ().IsStrictlyPositive ())
>     {
>       m_txopTrace (m_startTxop, Simulator::Now () - m_startTxop);
>     }
1523d942
<   //// WIGIG //// (Missing)
1525,1526c944,946
<   //// WIGIG //// (Missing)
<   TerminateTxop ();
---
>   m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>   StartBackoffNow (m_backoffTrace);
>   StartAccessIfNeeded ();
1533,1534c953,954
<   if (m_stationManager->GetVhtSupported ()
<       || m_stationManager->GetHeSupported ()
---
>   if (m_stationManager->HasVhtSupported ()
>       || m_stationManager->HasHeSupported ()
1536c956
<       || (m_stationManager->GetHtSupported ()
---
>       || (m_stationManager->HasHtSupported ()
1538,1541c958,959
<           && GetBaAgreementEstablished (m_currentHdr.GetAddr1 (), GetTid (m_currentPacket, m_currentHdr))
<           && GetLow ()->GetMpduAggregator () != 0
<           && GetLow ()->GetMpduAggregator ()->GetMaxAmpduSize (m_currentHdr.GetAddr1 (), GetTid (m_currentPacket, m_currentHdr),
<                                                                WIFI_MOD_CLASS_HT) >= m_currentPacket->GetSize ()))
---
>           && GetBaAgreementExists (m_currentHdr.GetAddr1 (), GetTid (m_currentPacket, m_currentHdr))
>           && GetMpduAggregator ()->GetMaxAmpduSize () >= m_currentPacket->GetSize ()))
1544c962
<       //HT-delayed block ack agreement or when it is carried in an A-MPDU.
---
>       //HT-delayed Block Ack agreement or when it is carried in an A-MPDU.
1556c974
< QosTxop::IsTxopFragmentation (void) const
---
> QosTxop::IsTxopFragmentation () const
1571c989
< QosTxop::GetTxopFragmentSize (void) const
---
> QosTxop::GetTxopFragmentSize () const
1604c1022
< QosTxop::GetNTxopFragment (void) const
---
> QosTxop::GetNTxopFragment () const
1756,1757c1174
<   if (m_typeOfStation == STA || m_typeOfStation == ADHOC_STA || 
< 	m_typeOfStation == DMG_STA || m_typeOfStation == DMG_ADHOC)
---
>   if (GetTypeOfStation () == STA || GetTypeOfStation () == ADHOC_STA)
1773,1774c1190
<   if (m_typeOfStation == AP || m_typeOfStation == ADHOC_STA ||
<       m_typeOfStation == DMG_STA || m_typeOfStation == DMG_AP || m_typeOfStation == DMG_ADHOC)
---
>   if (GetTypeOfStation () == AP || GetTypeOfStation () == ADHOC_STA)
1785a1202,1215
> QosTxop::SetMsduAggregator (const Ptr<MsduAggregator> aggr)
> {
>   NS_LOG_FUNCTION (this << aggr);
>   m_msduAggregator = aggr;
> }
> 
> void
> QosTxop::SetMpduAggregator (const Ptr<MpduAggregator> aggr)
> {
>   NS_LOG_FUNCTION (this << aggr);
>   m_mpduAggregator = aggr;
> }
> 
> void
1788a1219,1220
>   WifiMacTrailer fcs;
>   m_stationManager->PrepareForQueue (hdr.GetAddr1 (), &hdr, packet);
1796a1229
>   NS_LOG_DEBUG ("received ADDBA response from " << recipient);
1798c1231
<   if (respHdr->GetStatusCode ().IsSuccess ())
---
>   if (m_baManager->ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::PENDING))
1800,1815c1233,1241
<       NS_LOG_DEBUG ("block ack agreement established with " << recipient);
<       // Even though a (destination, TID) pair is "blocked" (i.e., no more packets
<       // are sent) when an Add BA Request is sent to the destination,
<       // the current packet may still be non-null when the Add BA Response is received.
<       // In fact, if the Add BA Request timer expires, the (destination, TID) pair is
<       // "unblocked" and packets to the destination are sent again (under normal
<       // ack policy). Thus, there may be a packet needing to be retransmitted
<       // when the Add BA Response is received. If this is the case, let the block
<       // ack manager handle its retransmission.
<       if (m_currentPacket != 0 && m_currentHdr.IsQosData ()
<           && m_currentHdr.GetAddr1 () == recipient && m_currentHdr.GetQosTid () == tid)
<         {
<           Ptr<WifiMacQueueItem> mpdu = Create<WifiMacQueueItem> (m_currentPacket, m_currentHdr,
<                                                                  m_currentPacketTimestamp);
<           m_baManager->GetRetransmitQueue ()->Enqueue (mpdu);
<           m_currentPacket = 0;
---
>       if (respHdr->GetStatusCode ().IsSuccess ())
>         {
>           NS_LOG_DEBUG ("block ack agreement established with " << recipient);
>           m_baManager->UpdateAgreement (respHdr, recipient);
>         }
>       else
>         {
>           NS_LOG_DEBUG ("discard ADDBA response" << recipient);
>           m_baManager->NotifyAgreementUnsuccessful (recipient, tid);
1817,1822d1242
<       m_baManager->UpdateAgreement (respHdr, recipient);
<     }
<   else
<     {
<       NS_LOG_DEBUG ("discard ADDBA response" << recipient);
<       m_baManager->NotifyAgreementRejected (recipient, tid);
1836c1256
< QosTxop::GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, double dataSnr, WifiTxVector dataTxVector)
---
> QosTxop::GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, WifiMode txMode, double dataSnr)
1838c1258
<   NS_LOG_FUNCTION (this << blockAck << recipient << rxSnr << dataSnr << dataTxVector);
---
>   NS_LOG_FUNCTION (this << blockAck << recipient << rxSnr << txMode.GetUniqueName () << dataSnr);
1840c1260
<   m_baManager->NotifyGotBlockAck (blockAck, recipient, rxSnr, dataSnr, dataTxVector);
---
>   m_baManager->NotifyGotBlockAck (blockAck, recipient, rxSnr, txMode, dataSnr);
1843c1263
<       m_txOkCallback (m_currentPacket, m_currentHdr);
---
>       m_txOkCallback (m_currentHdr);
1846c1266,1267
<   if (m_allocationType == CBAP_ALLOCATION)
---
>   ResetCw ();
>   if (!HasTxop ())
1848c1269,1276
<       ResetCw ();
---
>       if (m_currentHdr.IsQosData () && GetTxopLimit ().IsStrictlyPositive ())
>         {
>           m_txopTrace (m_startTxop, Simulator::Now () - m_startTxop);
>         }
>       m_cwTrace = GetCw ();
>       m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>       StartBackoffNow (m_backoffTrace);
>       RestartAccessIfNeeded ();
1850,1851c1278,1287
<   //// WIGIG ////
<   else
---
> }
> 
> void
> QosTxop::VerifyBlockAck (void)
> {
>   NS_LOG_FUNCTION (this);
>   uint8_t tid = m_currentHdr.GetQosTid ();
>   Mac48Address recipient = m_currentHdr.GetAddr1 ();
>   uint16_t sequence = m_currentHdr.GetSequenceNumber ();
>   if (m_baManager->ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::INACTIVE))
1853c1289,1294
<       RestartAccessIfNeeded ();
---
>       m_baManager->SwitchToBlockAckIfNeeded (recipient, tid, sequence);
>     }
>   if ((m_baManager->ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
>       && (GetMpduAggregator () == 0 || GetMpduAggregator ()->GetMaxAmpduSize () == 0))
>     {
>       m_currentHdr.SetQosAckPolicy (WifiMacHeader::BLOCK_ACK);
1855d1295
<   //// WIGIG ////
1876c1316
< QosTxop::CompleteMpduTx (Ptr<WifiMacQueueItem> mpdu)
---
> QosTxop::CompleteTx (void)
1878,1880c1318,1319
<   NS_ASSERT (mpdu->GetHeader ().IsQosData ());
<   // If there is an established BA agreement, store the packet in the queue of outstanding packets
<   if (GetBaAgreementEstablished (mpdu->GetHeader ().GetAddr1 (), mpdu->GetHeader ().GetQosTid ()))
---
>   NS_LOG_FUNCTION (this);
>   if (m_currentHdr.IsQosData () && m_currentHdr.IsQosBlockAck ())
1882c1321,1327
<       m_baManager->StorePacket (mpdu);
---
>       if (!m_currentHdr.IsRetry ())
>         {
>           m_baManager->StorePacket (m_currentPacket, m_currentHdr, m_currentPacketTimestamp);
>         }
>       m_baManager->NotifyMpduTransmission (m_currentHdr.GetAddr1 (), m_currentHdr.GetQosTid (),
>                                            m_txMiddle->GetNextSeqNumberByTidAndAddress (m_currentHdr.GetQosTid (),
>                                                                                         m_currentHdr.GetAddr1 ()), WifiMacHeader::BLOCK_ACK);
1885a1331,1340
> void
> QosTxop::CompleteMpduTx (Ptr<const Packet> packet, WifiMacHeader hdr, Time tstamp)
> {
>   NS_ASSERT (hdr.IsQosData ());
>   m_baManager->StorePacket (packet, hdr, tstamp);
>   m_baManager->NotifyMpduTransmission (hdr.GetAddr1 (), hdr.GetQosTid (),
>                                        m_txMiddle->GetNextSeqNumberByTidAndAddress (hdr.GetQosTid (),
>                                                                                     hdr.GetAddr1 ()), WifiMacHeader::NORMAL_ACK);
> }
> 
1887c1342
< QosTxop::SetupBlockAckIfNeeded (void)
---
> QosTxop::SetupBlockAckIfNeeded ()
1894,1900c1349,1351
<       //// WIGIG //// (Double check)
<       || (m_stationManager->HasDmgSupported () && GetLow ()->GetMpduAggregator ()->GetMaxAmpduSize (recipient, tid, WIFI_MOD_CLASS_DMG_SC) > 0)
<       || (m_stationManager->HasEdmgSupported () && GetLow ()->GetMpduAggregator ()->GetMaxAmpduSize (recipient, tid, WIFI_MOD_CLASS_EDMG_SC) > 0)
<       //// WIGIG //// (Double check)
<       || (GetLow ()->GetMpduAggregator () != 0 && GetLow ()->GetMpduAggregator ()->GetMaxAmpduSize (recipient, tid, WIFI_MOD_CLASS_HT) > 0 && packets > 1)
<       || m_stationManager->GetVhtSupported ()
<       || m_stationManager->GetHeSupported ())
---
>       || (m_mpduAggregator != 0 && m_mpduAggregator->GetMaxAmpduSize () > 0 && packets > 1)
>       || m_stationManager->HasVhtSupported ()
>       || m_stationManager->HasHeSupported ())
1910a1362,1403
> QosTxop::SendBlockAckRequest (const Bar &bar)
> {
>   NS_LOG_FUNCTION (this << &bar);
>   WifiMacHeader hdr;
>   hdr.SetType (WIFI_MAC_CTL_BACKREQ);
>   hdr.SetAddr1 (bar.recipient);
>   hdr.SetAddr2 (m_low->GetAddress ());
>   hdr.SetAddr3 (m_low->GetBssid ());
>   hdr.SetDsNotTo ();
>   hdr.SetDsNotFrom ();
>   hdr.SetNoRetry ();
>   hdr.SetNoMoreFragments ();
> 
>   m_currentPacket = bar.bar;
>   m_currentHdr = hdr;
> 
>   m_currentParams.DisableRts ();
>   m_currentParams.DisableNextData ();
>   if (bar.immediate)
>     {
>       if (m_blockAckType == BASIC_BLOCK_ACK)
>         {
>           m_currentParams.EnableBasicBlockAck ();
>         }
>       else if (m_blockAckType == COMPRESSED_BLOCK_ACK)
>         {
>           m_currentParams.EnableCompressedBlockAck ();
>         }
>       else if (m_blockAckType == MULTI_TID_BLOCK_ACK)
>         {
>           NS_FATAL_ERROR ("Multi-tid block ack is not supported");
>         }
>     }
>   else
>     {
>       //Delayed block ack
>       m_currentParams.EnableAck ();
>     }
>   m_low->StartTransmission (m_currentPacket, &m_currentHdr, m_currentParams, this);
> }
> 
> void
1951c1444
<   hdr.SetAddr3 (m_low->GetBssid ());
---
>   hdr.SetAddr3 (m_low->GetAddress ());
1998d1490
<   m_currentParams.DisableOverrideDurationId ();
2000c1492
<   m_low->StartTransmission (Create<WifiMacQueueItem> (m_currentPacket, m_currentHdr), m_currentParams, this);
---
>   m_low->StartTransmission (m_currentPacket, &m_currentHdr, m_currentParams, this);
2011c1503
<   hdr.SetAddr3 (m_low->GetBssid ());
---
>   hdr.SetAddr3 (m_low->GetAddress ());
2041c1533
< QosTxop::DoInitialize (void)
---
> QosTxop::DoInitialize ()
2046c1538,1539
<   GenerateBackoff ();
---
>   m_backoffTrace = m_rng->GetInteger (0, GetCw ());
>   StartBackoffNow (m_backoffTrace);
2055c1548
<       m_txOkCallback (m_currentPacket, m_currentHdr);
---
>       m_txOkCallback (m_currentHdr);
2069,2123d1561
< void
< QosTxop::AddBaResponseTimeout (Mac48Address recipient, uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   // If agreement is still pending, ADDBA response is not received
<   if (m_baManager->ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::PENDING))
<     {
<       m_baManager->NotifyAgreementNoReply (recipient, tid);
<       Simulator::Schedule (m_failedAddBaTimeout, &QosTxop::ResetBa, this, recipient, tid);
<       GenerateBackoff ();
<       RestartAccessIfNeeded ();
<     }
< }
< 
< void
< QosTxop::ResetBa (Mac48Address recipient, uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << recipient << +tid);
<   // This function is scheduled when waiting for an ADDBA response. However,
<   // before this function is called, a DELBA request may arrive, which causes
<   // the agreement to be deleted. Hence, check if an agreement exists before
<   // notifying that the agreement has to be reset.
<   if (m_baManager->ExistsAgreement (recipient, tid)
<       && !m_baManager->ExistsAgreementInState (recipient, tid, OriginatorBlockAckAgreement::ESTABLISHED))
<     {
<       m_baManager->NotifyAgreementReset (recipient, tid);
<     }
< }
< 
< void
< QosTxop::SetAddBaResponseTimeout (Time addBaResponseTimeout)
< {
<   NS_LOG_FUNCTION (this << addBaResponseTimeout);
<   m_addBaResponseTimeout = addBaResponseTimeout;
< }
< 
< Time
< QosTxop::GetAddBaResponseTimeout (void) const
< {
<   return m_addBaResponseTimeout;
< }
< 
< void
< QosTxop::SetFailedAddBaTimeout (Time failedAddBaTimeout)
< {
<   NS_LOG_FUNCTION (this << failedAddBaTimeout);
<   m_failedAddBaTimeout = failedAddBaTimeout;
< }
< 
< Time
< QosTxop::GetFailedAddBaTimeout (void) const
< {
<   return m_failedAddBaTimeout;
< }
< 
2125c1563
< QosTxop::IsQosTxop (void) const
---
> QosTxop::IsQosTxop () const
2130a1569
> 
diff ../../NS3-WiGig/src/wifi/model/qos-txop.h ../../ns-3-dev-git/src/wifi/model/qos-txop.h
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks
30,31d28
< #include <map>
< #include <list>
35,36d31
< class TwoLevelAggregationTest;
< class HeAggregationTest;
40a36,37
> class MsduAggregator;
> class MpduAggregator;
44,45c41,55
< class WifiTxVector;
< class WifiAckPolicySelector;
---
> 
> /**
>  * Enumeration for type of station
>  */
> enum TypeOfStation
> {
>   STA,
>   AP,
>   ADHOC_STA,
>   MESH,
>   HT_STA,
>   HT_AP,
>   HT_ADHOC_STA,
>   OCB
> };
59,62c69,72
<  *   - AC_VO : voice, TID = 6,7
<  *   - AC_VI : video, TID = 4,5
<  *   - AC_BE : best-effort, TID = 0,3
<  *   - AC_BK : background, TID = 1,2
---
>  *   - AC_VO : voice, tid = 6,7
>  *   - AC_VI : video, tid = 4,5
>  *   - AC_BE : best-effort, tid = 0,3
>  *   - AC_BK : background, tid = 1,2
74c84
<  * it has been retransmitted up until the SSRC or SLRC thresholds.
---
>  * it has been retransmitted up until the ssrc or slrc thresholds.
76,77c86,87
<  * The RTS/CTS policy is similar to the fragmentation policy: when
<  * a packet is bigger than a threshold, the RTS/CTS protocol is used.
---
>  * The rts/cts policy is similar to the fragmentation policy: when
>  * a packet is bigger than a threshold, the rts/cts protocol is used.
83c93
<   /// allow AmpduAggregationTest class access
---
>   /// Allow test cases to access private members
85,88d94
<   /// allow TwoLevelAggregationTest class access
<   friend class ::TwoLevelAggregationTest;
<   /// allow HeAggregationTest class access
<   friend class ::HeAggregationTest;
101,119d106
<   // Overridden from Txop
<   bool IsQosTxop (void) const;
<   void SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> remoteManager);
<   virtual bool HasFramesToTransmit (void);
<   void NotifyAccessGranted (void);
<   void NotifyInternalCollision (void);
<   void GotAck (void);
<   void GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient,
<                     double rxSnr, double dataSnr, WifiTxVector dataTxVector);
<   void MissedBlockAck (uint8_t nMpdus);
<   void MissedAck (void);
<   void StartNextPacket (void);
<   void EndTxNoAck (void);
<   void RestartAccessIfNeeded (void);
<   void StartAccessIfNeeded (void);
<   Time GetTxopRemaining (void) const;
<   bool NeedFragmentation (void) const;
<   Ptr<Packet> GetFragmentPacket (WifiMacHeader *hdr);
< 
121c108
<    * Set the ack policy selector.
---
>    * Check for QoS TXOP.
123c110
<    * \param ackSelector the ack policy selector.
---
>    * \returns true if QoS TXOP.
125c112,113
<   void SetAckPolicySelector (Ptr<WifiAckPolicySelector> ackSelector);
---
>   bool IsQosTxop () const;
> 
127c115
<    * Return the ack policy selector.
---
>    * Set WifiRemoteStationsManager this QosTxop is associated to.
129c117
<    * \return the ack policy selector.
---
>    * \param remoteManager WifiRemoteStationManager.
131c119
<   Ptr<WifiAckPolicySelector> GetAckPolicySelector (void) const;
---
>   void SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> remoteManager);
146,149c134
<    * \param address recipient address of the peer station
<    * \param tid traffic ID.
<    *
<    * \return true if a block ack agreement is established, false otherwise.
---
>    * Returns the aggregator used to construct A-MSDU subframes.
151,152c136
<    * Checks if a block ack agreement is established with station addressed by
<    * <i>recipient</i> for TID <i>tid</i>.
---
>    * \return the aggregator used to construct A-MSDU subframes.
154c138
<   bool GetBaAgreementEstablished (Mac48Address address, uint8_t tid) const;
---
>   Ptr<MsduAggregator> GetMsduAggregator (void) const;
156,157c140
<    * \param address recipient address of the peer station
<    * \param tid traffic ID.
---
>    * Returns the aggregator used to construct A-MPDU subframes.
159,162c142
<    * \return the negotiated buffer size during ADDBA handshake.
<    *
<    * Returns the negotiated buffer size during ADDBA handshake with station addressed by
<    * <i>recipient</i> for TID <i>tid</i>.
---
>    * \return the aggregator used to construct A-MPDU subframes.
164c144,145
<   uint16_t GetBaBufferSize (Mac48Address address, uint8_t tid) const;
---
>   Ptr<MpduAggregator> GetMpduAggregator (void) const;
> 
169c150
<    * \return the starting sequence number of the originator transmit window.
---
>    * \return true if a block ack agreement exists, false otherwise.
171,173c152,153
<    * Returns the current starting sequence number of the transmit window on the
<    * originator (WinStartO) of the block ack agreement established with the given
<    * recipient for the given TID.
---
>    * Checks if a block ack agreement exists with station addressed by
>    * <i>recipient</i> for tid <i>tid</i>.
175c155
<   uint16_t GetBaStartingSequence (Mac48Address address, uint8_t tid) const;
---
>   bool GetBaAgreementExists (Mac48Address address, uint8_t tid) const;
177,178c157,158
<    * \param address recipient address
<    * \param tid traffic ID
---
>    * \param recipient address of peer station involved in block ack mechanism.
>    * \param tid Ttraffic ID of transmitted packet.
180,183c160,161
<    * Prepare a BlockAckRequest to be sent to <i>recipient</i> for Traffic ID
<    * <i>tid</i>. The header for the BlockAckRequest is requested to the QosTxop
<    * corresponding to the given TID. A block ack agreement with the given recipient
<    * for the given TID must have been established by such QosTxop.
---
>    * This function resets the status of OriginatorBlockAckAgreement after the transfer
>    * of an A-MPDU with ImmediateBlockAck policy (i.e. no BAR is scheduled).
185c163,165
<   Ptr<const WifiMacQueueItem> PrepareBlockAckRequest (Mac48Address recipient, uint8_t tid) const;
---
>   void CompleteAmpduTransfer (Mac48Address recipient, uint8_t tid);
> 
>   /* dcf notifications forwarded here */
187,191c167,175
<    * \param bar the BlockAckRequest to schedule
<    * \param skipIfNoDataQueued do not send if there is no data queued
<    *
<    * Request the block ack manager to schedule the transmission of the given
<    * BlockAckRequest.
---
>    * Notify the EDCAF that access has been granted.
>    */
>   void NotifyAccessGranted (void);
>   /**
>    * Notify the EDCAF that internal collision has occurred.
>    */
>   void NotifyInternalCollision (void);
>   /**
>    * Notify the EDCAF that collision has occurred.
193c177
<   void ScheduleBar (Ptr<const WifiMacQueueItem> bar, bool skipIfNoDataQueued = false);
---
>   void NotifyCollision (void);
197a182,189
>    */
>   void MissedCts (void);
>   /**
>    * Event handler when an ACK is received.
>    */
>   void GotAck (void);
>   /**
>    * Event handler when a Block ACK is received.
199c191,195
<    * \param mpduList the list of MPDUs that were not transmitted
---
>    * \param blockAck block ack.
>    * \param recipient address of the recipient.
>    * \param rxSnr SNR of the block ack itself.
>    * \param txMode wifi mode.
>    * \param dataSnr reported data SNR from the peer.
201,202c197
<   void NotifyMissedCts (std::list<Ptr<WifiMacQueueItem>> mpduList);
<   //// WIGIG ////
---
>   void GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, WifiMode txMode, double dataSnr);
204,206c199,200
<    * Copy BlockAck Agreements
<    * \param recipient
<    * \param target
---
>    * Event handler when a Block ACK timeout has occurred.
>    * \param nMpdus number of MPDUs sent in the A-MPDU transmission that results in a Block ACK timeout.
208,210c202
<   void CopyBlockAckAgreements (Mac48Address recipient, Ptr<QosTxop> target);
<   //// WIGIG ////
< 
---
>   void MissedBlockAck (uint8_t nMpdus);
224a217,220
>   /**
>    * Event handler when an ACK is missed.
>    */
>   void MissedAck (void);
226,229d221
<   //// WIGIG ////
<   // Overridden from Txop
<   virtual void StartAllocationPeriod (AllocationType allocationType, AllocationID allocationID,
<                                       Mac48Address peerStation, Time allocationDuration);
231c223
<    * Initiate Transmission in the current service period.
---
>    * Start transmission for the next packet if allowed by the TxopLimit.
233c225
<   void InitiateServicePeriodTransmission (void);
---
>   void StartNextPacket (void);
235c227
<    * Resume transmission in the current allocation period.
---
>    * Event handler when a transmission that does not require an ACK has completed.
237c229
<   void ResumeTransmission (Time periodDuration);
---
>   void EndTxNoAck (void);
239,240c231
<    * \param callback the callback to invoke when an ACK/BlockAck
<    * is missed from the peer side
---
>    * Restart access request if needed.
242,245c233
<   void SetMissedAckCallback (TxFailed callback);
<   void AllowChannelAccess (void);
<   void DisableChannelAccess (void);
<   virtual Time GetPpduDurationLimit (Ptr<const WifiMacQueueItem> item, const MacLowTransmissionParameters &params);
---
>   void RestartAccessIfNeeded (void);
247,252c235
<    * Peek the next frame for transmission based on the the standard and the type of current allocation.
<    * If the standard is either 11ad or 11ay, then we check what type of allocation we are serving.
<    * If the allocation is SP, then we peek frame with destinatio address that equals the peer station
<    * address in the SP allocation.
<    * Otherwise, we peek the next available frame without any constains.
<    * \returns the peeked frame.
---
>    * Request access from DCF manager if needed.
254,255c237
<   Ptr<const WifiMacQueueItem> PeekFrameForTransmission (void);
<   //// WIGIG ////
---
>   void StartAccessIfNeeded (void);
258c240
<    * Check if BlockAckRequest should be re-transmitted.
---
>    * Check if Block ACK Request should be re-transmitted.
265a248,265
>    * Check if the current packet should be fragmented.
>    *
>    * \return true if the current packet should be fragmented,
>    *         false otherwise.
>    */
>   bool NeedFragmentation (void) const;
> 
>   /**
>    * Get the next fragment from the packet with
>    * appropriate Wifi header for the fragment.
>    *
>    * \param hdr Wi-Fi header.
>    *
>    * \return the fragment with the current fragment number.
>    */
>   Ptr<Packet> GetFragmentPacket (WifiMacHeader *hdr);
> 
>   /**
272a273,285
>    * Set the aggregator used to construct A-MSDU subframes.
>    *
>    * \param aggr pointer to the MSDU aggregator.
>    */
>   void SetMsduAggregator (const Ptr<MsduAggregator> aggr);
>   /**
>    * Set the aggregator used to construct A-MPDU subframes.
>    *
>    * \param aggr pointer to the MPDU aggregator.
>    */
>   void SetMpduAggregator (const Ptr<MpduAggregator> aggr);
> 
>   /**
282c295
<    * Complete block ack configuration.
---
>    * Complete block ACK configuration.
287,288c300,301
<    * Set threshold for block ack mechanism. If number of packets in the
<    * queue reaches the threshold, block ack mechanism is used.
---
>    * Set threshold for block ACK mechanism. If number of packets in the
>    * queue reaches the threshold, block ACK mechanism is used.
294c307
<    * Return the current threshold for block ack mechanism.
---
>    * Return the current threshold for block ACK mechanism.
296c309
<    * \return the current threshold for block ack mechanism.
---
>    * \return the current threshold for block ACK mechanism.
301c314
<    * Set the BlockAck inactivity timeout.
---
>    * Set the Block Ack inactivity timeout.
303c316
<    * \param timeout the BlockAck inactivity timeout.
---
>    * \param timeout the Block Ack inactivity timeout.
307,308c320,321
<    * Sends DELBA frame to cancel a block ack agreement with STA
<    * addressed by <i>addr</i> for TID <i>tid</i>.
---
>    * Sends DELBA frame to cancel a block ack agreement with sta
>    * addressed by <i>addr</i> for tid <i>tid</i>.
316,319c329,335
<    * Stores an MPDU (part of an A-MPDU) in block ack agreement (i.e. the sender is waiting
<    * for a BlockAck containing the sequence number of this MPDU).
<    *
<    * \param mpdu received MPDU.
---
>    * Stores an MPDU (part of an A-MPDU) in blockackagreement (i.e. the sender is waiting
>    * for a blockack containing the sequence number of this MPDU).
>    * It also calls NotifyMpdu transmission that updates the status of OriginatorBlockAckAgreement.
>    *
>    * \param packet received packet.
>    * \param hdr received Wi-Fi header.
>    * \param tstamp timestamp.
321c337
<   void CompleteMpduTx (Ptr<WifiMacQueueItem> mpdu);
---
>   void CompleteMpduTx (Ptr<const Packet> packet, WifiMacHeader hdr, Time tstamp);
336,360d351
<   /**
<    * Set the timeout to wait for ADDBA response.
<    *
<    * \param addBaResponseTimeout the timeout to wait for ADDBA response
<    */
<   void SetAddBaResponseTimeout (Time addBaResponseTimeout);
<   /**
<    * Get the timeout for ADDBA response.
<    *
<    * \returns the timeout to wait for ADDBA response
<    */
<   Time GetAddBaResponseTimeout (void) const;
<   /**
<    * Set the timeout for failed BA agreement. During the timeout period,
<    * all packets will be transmitted using normal MPDU.
<    *
<    * \param failedAddBaTimeout the timeout for failed BA agreement
<    */
<   void SetFailedAddBaTimeout (Time failedAddBaTimeout);
<   /**
<    * Get the timeout for failed BA agreement.
<    *
<    * \returns the timeout for failed BA agreement
<    */
<   Time GetFailedAddBaTimeout (void) const;
369c360
<   uint16_t GetNextSequenceNumberFor (const WifiMacHeader *hdr);
---
>   uint16_t GetNextSequenceNumberFor (WifiMacHeader *hdr);
377,391c368
<   uint16_t PeekNextSequenceNumberFor (const WifiMacHeader *hdr);
<   /**
<    * Peek the next frame to transmit to the given receiver and of the given
<    * TID from the block ack manager retransmit queue first and, if not found, from
<    * the EDCA queue. If <i>tid</i> is equal to 8 (invalid value) and <i>recipient</i>
<    * is the broadcast address, the first available frame is returned.
<    * Note that A-MSDU aggregation is never attempted (this is relevant if the
<    * frame is peeked from the EDCA queue). If the frame is peeked from the EDCA
<    * queue, it is assigned a sequence number peeked from MacTxMiddle.
<    *
<    * \param tid traffic ID.
<    * \param recipient the receiver station address.
<    * \returns the peeked frame.
<    */
<   Ptr<const WifiMacQueueItem> PeekNextFrame (uint8_t tid = 8, Mac48Address recipient = Mac48Address::GetBroadcast ());
---
>   uint16_t PeekNextSequenceNumberFor (WifiMacHeader *hdr);
393,401c370
<    * Dequeue the frame that has been previously peeked by calling PeekNextFrame.
<    * If the peeked frame is a QoS Data frame, it is actually dequeued if it meets
<    * the constraint on the maximum A-MPDU size (by assuming that the frame has to
<    * be aggregated to an existing A-MPDU of the given size) and its transmission
<    * time does not exceed the given PPDU duration limit (if distinct from Time::Min ()).
<    * If the peeked frame is a unicast QoS Data frame stored in the EDCA queue,
<    * attempt to perform A-MSDU aggregation (while meeting the constraints mentioned
<    * above) if <i>aggregate</i> is true and assign a sequence number to the
<    * dequeued frame.
---
>    * Remove a packet after you peek in the retransmit queue and get it.
403,408c372,374
<    * \param peekedItem the peeked frame.
<    * \param txVector the TX vector used to transmit the peeked frame
<    * \param aggregate whether to attempt A-MSDU aggregation
<    * \param ampduSize the size of the existing A-MPDU in bytes, if any
<    * \param ppduDurationLimit the limit on the PPDU duration
<    * \returns the dequeued frame.
---
>    * \param tid traffic ID of the packet to be removed.
>    * \param recipient address of the recipient the packet was intended for.
>    * \param seqnumber sequence number of the packet to be removed.
410,412c376
<   Ptr<WifiMacQueueItem> DequeuePeekedFrame (Ptr<const WifiMacQueueItem> peekedItem, WifiTxVector txVector,
<                                             bool aggregate = true, uint32_t ampduSize = 0,
<                                             Time ppduDurationLimit = Time::Min ());
---
>   void RemoveRetransmitPacket (uint8_t tid, Mac48Address recipient, uint16_t seqnumber);
414,416c378
<    * Compute the MacLow transmission parameters for the given frame. Allowed frames
<    * are those handled by a QosTxop (QoS data frames, BlockAckReq frames, ADDBA
<    * Request/Response, DELBA Request).
---
>    * Peek in retransmit queue and get the next packet without removing it from the queue.
418,428c380,383
<    * \param frame the given frame
<    * \return the MacLow transmission parameters.
<    */
<   MacLowTransmissionParameters GetTransmissionParameters (Ptr<const WifiMacQueueItem> frame) const;
< 
<   /**
<    * Update the current packet this QosTxop is trying to transmit. This method
<    * is typically called by MacLow when it changes (i.e., by performing A-MSDU
<    * aggregation) the packet received from this QosTxop.
<    *
<    * \param mpdu the MPDU that MacLow is forwarding down to the PHY.
---
>    * \param header Wi-Fi header.
>    * \param tid traffic ID.
>    * \param timestamp the timestamp.
>    * \returns the packet.
430c385
<   void UpdateCurrentPacket (Ptr<WifiMacQueueItem> mpdu);
---
>   Ptr<const Packet> PeekNextRetransmitPacket (WifiMacHeader &header, uint8_t tid, Time *timestamp);
446c401
<    * If aggregating STA is a non-AP STA (in an infrastructure network):
---
>    * If aggregating sta is a STA (in an infrastructured network):
448c403
<    * If aggregating STA is an AP
---
>    * If aggregating sta is an AP
457c412
<    * If aggregating STA is a non-AP STA (in an infrastructure network):
---
>    * If aggregating sta is a STA (in an infrastructured network):
459c414
<    * If aggregating STA is an AP
---
>    * If aggregating sta is an AP
472,480d426
<   // Overridden from Txop
<   void DoDispose (void);
<   void DoInitialize (void);
<   void TerminateTxop (void);
<   uint32_t GetNextFragmentSize (void) const;
<   uint32_t GetFragmentSize (void) const;
<   uint32_t GetFragmentOffset (void) const;
<   bool IsLastFragment (void) const;
< 
485c431
<    * \return true if we tried to set up block ack, false otherwise.
---
>    * \return true if we tried to set up block ACK, false otherwise.
487c433
<   bool SetupBlockAckIfNeeded (void);
---
>   bool SetupBlockAckIfNeeded ();
489,490c435,436
<    * Sends an ADDBA Request to establish a block ack agreement with STA
<    * addressed by <i>recipient</i> for TID <i>tid</i>.
---
>    * Sends an ADDBA Request to establish a block ack agreement with sta
>    * addressed by <i>recipient</i> for tid <i>tid</i>.
496c442
<    * \param immediateBAck flag to indicate whether immediate BlockAck is used.
---
>    * \param immediateBAck flag to indicate whether immediate block ack is used.
501,503c447,448
<    * Check if the given MPDU is to be considered old according to the current
<    * starting sequence number of the transmit window, provided that a block ack
<    * agreement has been established with the recipient for the given TID.
---
>    * After that all packets, for which a block ack agreement was established, have been
>    * transmitted, we have to send a block ack request.
505,506c450,460
<    * \param mpdu the given MPDU
<    * \return true if the MPDU is to be considered old, false otherwise
---
>    * \param bar the block ack request.
>    */
>   void SendBlockAckRequest (const Bar &bar);
>   /**
>    * For now is typically invoked to complete transmission of a packets sent with ack policy
>    * Block Ack: the packet is buffered and dcf is reset.
>    */
>   void CompleteTx (void);
>   /**
>    * Verifies if dequeued packet has to be transmitted with ack policy Block Ack. This happens
>    * if an established block ack agreement exists with the receiver.
508c462,501
<   bool IsQosOldPacket (Ptr<const WifiMacQueueItem> mpdu);
---
>   void VerifyBlockAck (void);
>   /**
>    * Return the remaining duration in the current TXOP.
>    *
>    * \return the remaining duration in the current TXOP.
>    */
>   Time GetTxopRemaining (void) const;
>   /**
>    * Check if the station has TXOP granted for the next MPDU.
>    *
>    * \return true if the station has TXOP granted for the next MPDU,
>    *         false otherwise.
>    */
>   bool HasTxop (void) const;
> 
>   /**
>    * Calculate the size of the next fragment.
>    *
>    * \return the size of the next fragment.
>    */
>   uint32_t GetNextFragmentSize (void) const;
>   /**
>    * Calculate the size of the current fragment.
>    *
>    * \return the size of the current fragment.
>    */
>   uint32_t GetFragmentSize (void) const;
>   /**
>    * Calculate the offset for the current fragment.
>    *
>    * \return the offset for the current fragment.
>    */
>   uint32_t GetFragmentOffset (void) const;
>   /**
>    * Check if the current fragment is the last fragment.
>    *
>    * \return true if the current fragment is the last fragment,
>    *         false otherwise.
>    */
>   bool IsLastFragment (void) const;
516c509
<   bool IsTxopFragmentation (void) const;
---
>   bool IsTxopFragmentation () const;
520c513
<    * \return the size of the current TXOP fragment in bytes
---
>    * \return the size of the current TXOP fragment
522c515
<   uint32_t GetTxopFragmentSize (void) const;
---
>   uint32_t GetTxopFragmentSize () const;
528c521
<   uint32_t GetNTxopFragment (void) const;
---
>   uint32_t GetNTxopFragment () const;
533c526
<    * \returns the next TXOP fragment size in bytes
---
>    * \returns the next TXOP fragment size
540c533
<    * \returns the TXOP fragment offset in bytes
---
>    * \returns the TXOP fragment offset
543,579d535
<   /**
<    * Callback when ADDBA response is not received after timeout.
<    *
<    * \param recipient MAC address of recipient
<    * \param tid traffic ID
<    */
<   void AddBaResponseTimeout (Mac48Address recipient, uint8_t tid);
<   /**
<    * Reset BA agreement after BA negotiation failed.
<    *
<    * \param recipient MAC address of recipient
<    * \param tid traffic ID
<    */
<   void ResetBa (Mac48Address recipient, uint8_t tid);
< 
<   /**
<    * Reset state of the current EDCA.
<    */
<   void ResetState (void);
< 
<   AcIndex m_ac;                                         //!< the access category
<   TypeOfStation m_typeOfStation;                        //!< the type of station
<   Ptr<WifiAckPolicySelector> m_ackPolicySelector;       //!< the ack policy selector
<   Ptr<QosBlockedDestinations> m_qosBlockedDestinations; //!< the QoS blocked destinations
<   Ptr<BlockAckManager> m_baManager;                     //!< the block ack manager
<   uint8_t m_blockAckThreshold;                          /**< the block ack threshold (use BA mechanism if number of packets in queue reaches
<                                                              this value. If this value is 0, block ack is never used. When A-MPDU is enabled,
<                                                              block ack mechanism is used regardless of this value) */
<   BlockAckType m_blockAckType;                          //!< the BlockAck type
<   Time m_currentPacketTimestamp;                        //!< the current packet timestamp
<   uint16_t m_blockAckInactivityTimeout;                 //!< the BlockAck inactivity timeout value (in TUs, i.e. blocks of 1024 microseconds)
<   Time m_startTxop;                                     //!< the start TXOP time
<   bool m_isAccessRequestedForRts;                       //!< flag whether access is requested to transmit a RTS frame
<   bool m_currentIsFragmented;                           //!< flag whether current packet is fragmented
<   Time m_addBaResponseTimeout;                          //!< timeout for ADDBA response
<   Time m_failedAddBaTimeout;                            //!< timeout after failed BA agreement
<   bool m_useExplicitBarAfterMissedBlockAck;             //!< flag whether explicit BlockAckRequest should be sent upon missed BlockAck Response
580a537,556
>   void DoDispose (void);
>   void DoInitialize (void);
> 
>   AcIndex m_ac;                                     //!< the access category
>   Ptr<MsduAggregator> m_msduAggregator;             //!< A-MSDU aggregator
>   Ptr<MpduAggregator> m_mpduAggregator;             //!< A-MPDU aggregator
>   TypeOfStation m_typeOfStation;                    //!< the type of station
>   Ptr<QosBlockedDestinations> m_qosBlockedDestinations; //!< QOS blocked destinations
>   Ptr<BlockAckManager> m_baManager;                     //!< the Block ACK manager
>   uint8_t m_blockAckThreshold;                      //!< the Block ACK threshold
>   BlockAckType m_blockAckType;                      //!< the Block ACK type
>   Time m_currentPacketTimestamp;                    //!< the current packet timestamp
>   uint16_t m_blockAckInactivityTimeout;             //!< the Block ACK inactivity timeout
>   Bar m_currentBar;                                 //!< the current BAR
>   Time m_startTxop;                                 //!< the start TXOP time
>   bool m_isAccessRequestedForRts;                   //!< flag whether access is requested to transmit a RTS frame
>   bool m_currentIsFragmented;                       //!< flag whether current packet is fragmented
> 
>   TracedValue<uint32_t> m_backoffTrace;   //!< backoff trace value
>   TracedValue<uint32_t> m_cwTrace;        //!< CW trace value
582,583d557
<   /** DMG Allocation Variables **/
<   TxFailed m_missedAckCallback;             /* Missed Ack/BlockAck from the peer station */
diff ../../NS3-WiGig/src/wifi/model/qos-utils.cc ../../ns-3-dev-git/src/wifi/model/qos-utils.cc
23d22
< #include "ns3/queue-item.h"
130c129
<                 MgtAddBaRequestHeader reqHdr;
---
>                 MgtAddBaResponseHeader reqHdr;
161,183d159
< }
< 
< uint8_t
< SelectQueueByDSField (Ptr<QueueItem> item)
< {
<   uint8_t dscp, priority = 0;
<   if (item->GetUint8Value (QueueItem::IP_DSFIELD, dscp))
<     {
<       // if the QoS map element is implemented, it should be used here
<       // to set the priority.
<       // User priority is set to the three most significant bits of the DS field
<       priority = dscp >> 5;
<     }
< 
<   // replace the priority tag
<   SocketPriorityTag priorityTag;
<   priorityTag.SetPriority (priority);
<   item->GetPacket ()->ReplacePacketTag (priorityTag);
< 
<   // if the admission control were implemented, here we should check whether
<   // the access category assigned to the packet should be downgraded
< 
<   return static_cast<uint8_t> (QosUtilsMapTidToAc (priority));
diff ../../NS3-WiGig/src/wifi/model/qos-utils.h ../../ns-3-dev-git/src/wifi/model/qos-utils.h
30d29
< class QueueItem;
65c64
<  * If a QoS tag is attached to the packet, returns a value < 8.
---
>  * If a qos tag is attached to the packet, returns a value < 8.
82c81
<  * \param endSequence the sequence number ending the acknowledgment window
---
>  * \param endSequence
134c133
<  * Returns TID of different packet types
---
>  * Returns Tid of different packet types
137,181d135
< 
< /**
<  * \ingroup wifi
<  * \brief Determine the TX queue for a given packet
<  * \param item the packet
<  * \returns the access category
<  *
<  * Modeled after the Linux function ieee80211_select_queue (net/mac80211/wme.c).
<  * A SocketPriority tag is attached to the packet (or the existing one is
<  * replaced) to carry the user priority, which is set to the three most
<  * significant bits of the DS field (TOS field in case of IPv4 and Traffic
<  * Class field in case of IPv6). The Access Category corresponding to the
<  * user priority according to the QosUtilsMapTidToAc function is returned.
<  *
<  * The following table shows the mapping for the Diffserv Per Hop Behaviors.
<  *
<  * PHB  | TOS (binary) | UP  | Access Category
<  * -----|--------------|-----|-----------------
<  * EF   |   101110xx   |  5  |     AC_VI
<  * AF11 |   001010xx   |  1  |     AC_BK
<  * AF21 |   010010xx   |  2  |     AC_BK
<  * AF31 |   011010xx   |  3  |     AC_BE
<  * AF41 |   100010xx   |  4  |     AC_VI
<  * AF12 |   001100xx   |  1  |     AC_BK
<  * AF22 |   010100xx   |  2  |     AC_BK
<  * AF32 |   011100xx   |  3  |     AC_BE
<  * AF42 |   100100xx   |  4  |     AC_VI
<  * AF13 |   001110xx   |  1  |     AC_BK
<  * AF23 |   010110xx   |  2  |     AC_BK
<  * AF33 |   011110xx   |  3  |     AC_BE
<  * AF43 |   100110xx   |  4  |     AC_VI
<  * CS0  |   000000xx   |  0  |     AC_BE
<  * CS1  |   001000xx   |  1  |     AC_BK
<  * CS2  |   010000xx   |  2  |     AC_BK
<  * CS3  |   011000xx   |  3  |     AC_BE
<  * CS4  |   100000xx   |  4  |     AC_VI
<  * CS5  |   101000xx   |  5  |     AC_VI
<  * CS6  |   110000xx   |  6  |     AC_VO
<  * CS7  |   111000xx   |  7  |     AC_VO
<  *
<  * This method is called by the traffic control layer before enqueuing a
<  * packet in the queue disc, if a queue disc is installed on the outgoing
<  * device, or passing a packet to the device, otherwise.
<  */
< uint8_t SelectQueueByDSField (Ptr<QueueItem> item);
diff ../../NS3-WiGig/src/wifi/model/regular-wifi-mac.cc ../../ns-3-dev-git/src/wifi/model/regular-wifi-mac.cc
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
19,20c18
<  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
31d28
< #include "channel-access-manager.h"
36d32
< #include "ns3/simulator.h"
38,44d33
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "vht-configuration.h"
< #include "he-configuration.h"
< #include <algorithm>
< #include <cmath>
< #include "extended-capabilities.h"
53,57c42,44
<   : //// WIGIG ////
<     m_dmgSupported (0),
<     m_edmgSupported (0),
<     //// WIGIG ////
<     m_qosSupported (0),
---
>   : m_qosSupported (0),
>     m_htSupported (0),
>     m_vhtSupported (0),
59c46,47
<     m_dsssSupported (0)
---
>     m_dsssSupported (0),
>     m_heSupported (0)
69d56
<   m_low->SetMac (this);
82,85d68
<   //// WIGIG ////
<   m_fstId = 0;      /* Fast Session ID. */
<   //// WIGIG ////
< 
137,177d119
<   
<   WifiMac::DoDispose ();
< }
< 
< //// WIGIG ////
< void
< RegularWifiMac::MacTxOk (Mac48Address address)
< {
<   NS_LOG_FUNCTION (this << address);
<   FstSessionMap::iterator it = m_fstSessionMap.find (address);
<   if (it != m_fstSessionMap.end ())
<     {
<       FstSession *fstSession = static_cast<FstSession*> (&it->second);
<       if ((fstSession->CurrentState == FST_SETUP_COMPLETION_STATE) && fstSession->LinkLossCountDownEvent.IsRunning ())
<         {
<           NS_LOG_INFO ("Transmitted MPDU Successfully, so reset Link Count Down Timer");
<           fstSession->LinkLossCountDownEvent.Cancel ();
<           fstSession->LinkLossCountDownEvent = Simulator::Schedule (MicroSeconds (fstSession->LLT * 32),
<                                                                     &RegularWifiMac::ChangeBand, this,
<                                                                     address, fstSession->NewBandId, fstSession->IsInitiator);
<         }
<     }
< }
< 
< void
< RegularWifiMac::MacRxOk (Mac48Address address)
< {
<   NS_LOG_FUNCTION (this << address);
<   FstSessionMap::iterator it = m_fstSessionMap.find (address);
<   if (it != m_fstSessionMap.end ())
<     {
<       FstSession *fstSession = static_cast<FstSession*> (&it->second);
<       if ((fstSession->CurrentState == FST_SETUP_COMPLETION_STATE) && fstSession->LinkLossCountDownEvent.IsRunning ())
<         {
<           NS_LOG_INFO ("Received MPDU Successfully, so reset Link Count Down Timer");
<           fstSession->LinkLossCountDownEvent.Cancel ();
<           fstSession->LinkLossCountDownEvent = Simulator::Schedule (MicroSeconds (fstSession->LLT * 32),
<                                                                     &RegularWifiMac::ChangeBand, this,
<                                                                     address, fstSession->NewBandId, fstSession->IsInitiator);
<         }
<     }
179d120
< //// WIGIG ////
186,194c127,129
< 
<   //// WIGIG ////
<   /* Connect trace source for FST */
<   m_stationManager->RegisterTxOkCallback (MakeCallback (&RegularWifiMac::MacTxOk, this));
<   m_stationManager->RegisterRxOkCallback (MakeCallback (&RegularWifiMac::MacRxOk, this));
<   m_stationManager->SetDmgSupported (GetDmgSupported ());
<   m_stationManager->SetEdmgSupported (GetEdmgSupported ());
<   //// WIGIG ////
< 
---
>   m_stationManager->SetHtSupported (GetHtSupported ());
>   m_stationManager->SetVhtSupported (GetVhtSupported ());
>   m_stationManager->SetHeSupported (GetHeSupported ());
195a131
> 
196a133
> 
209c146
< Ptr<ExtendedCapabilities>
---
> ExtendedCapabilities
213,215c150,161
<   Ptr<ExtendedCapabilities> capabilities = Create<ExtendedCapabilities> ();
<   capabilities->SetHtSupported (GetHtSupported ());
<   capabilities->SetVhtSupported (GetVhtSupported ());
---
>   ExtendedCapabilities capabilities;
>   if (m_htSupported || m_vhtSupported)
>     {
>       if (m_htSupported)
>         {
>           capabilities.SetHtSupported (1);
>         }
>       if (m_vhtSupported)
>         {
>           capabilities.SetVhtSupported (1);
>         }
>     }
220c166
< Ptr<HtCapabilities>
---
> HtCapabilities
224,225c170,171
<   Ptr<HtCapabilities> capabilities = Create<HtCapabilities> ();
<   if (GetHtSupported ())
---
>   HtCapabilities capabilities;
>   if (m_htSupported)
227,254c173,188
<       Ptr<HtConfiguration> htConfiguration = GetHtConfiguration ();
<       bool greenfieldSupported = htConfiguration->GetGreenfieldSupported ();
<       bool sgiSupported = htConfiguration->GetShortGuardIntervalSupported ();
<       capabilities->SetHtSupported (1);
<       capabilities->SetLdpc (0);
<       capabilities->SetSupportedChannelWidth (m_phy->GetChannelWidth () >= 40);
<       capabilities->SetShortGuardInterval20 (sgiSupported);
<       capabilities->SetShortGuardInterval40 (m_phy->GetChannelWidth () >= 40 && sgiSupported);
<       capabilities->SetGreenfield (greenfieldSupported);
<       // Set Maximum A-MSDU Length subfield
<       uint16_t maxAmsduSize = std::max ({m_voMaxAmsduSize, m_viMaxAmsduSize,
<                                          m_beMaxAmsduSize, m_bkMaxAmsduSize});
<       if (maxAmsduSize <= 3839)
<         {
<           capabilities->SetMaxAmsduLength (3839);
<         }
<       else
<         {
<           capabilities->SetMaxAmsduLength (7935);
<         }
<       uint32_t maxAmpduLength = std::max ({m_voMaxAmpduSize, m_viMaxAmpduSize,
<                                            m_beMaxAmpduSize, m_bkMaxAmpduSize});
<       // round to the next power of two minus one
<       maxAmpduLength = (1ul << static_cast<uint32_t> (std::ceil (std::log2 (maxAmpduLength + 1)))) - 1;
<       // The maximum A-MPDU length in HT capabilities elements ranges from 2^13-1 to 2^16-1
<       capabilities->SetMaxAmpduLength (std::min (std::max (maxAmpduLength, 8191u), 65535u));
< 
<       capabilities->SetLSigProtectionSupport (!greenfieldSupported);
---
>       capabilities.SetHtSupported (1);
>       capabilities.SetLdpc (m_phy->GetLdpc ());
>       capabilities.SetSupportedChannelWidth (m_phy->GetChannelWidth () >= 40);
>       capabilities.SetShortGuardInterval20 (m_phy->GetShortGuardInterval ());
>       capabilities.SetShortGuardInterval40 (m_phy->GetChannelWidth () >= 40 && m_phy->GetShortGuardInterval ());
>       capabilities.SetGreenfield (m_phy->GetGreenfield ());
>       uint32_t maxAmsduLength = std::max (std::max (m_beMaxAmsduSize, m_bkMaxAmsduSize), std::max (m_voMaxAmsduSize, m_viMaxAmsduSize));
>       capabilities.SetMaxAmsduLength (maxAmsduLength > 3839); //0 if 3839 and 1 if 7935
>       capabilities.SetLSigProtectionSupport (!m_phy->GetGreenfield ());
>       double maxAmpduLengthExponent = std::max (std::ceil ((std::log (std::max (std::max (m_beMaxAmpduSize, m_bkMaxAmpduSize), std::max (m_voMaxAmpduSize, m_viMaxAmpduSize))
>                                                                       + 1.0)
>                                                             / std::log (2.0))
>                                                            - 13.0),
>                                                 0.0);
>       NS_ASSERT (maxAmpduLengthExponent >= 0 && maxAmpduLengthExponent <= 255);
>       capabilities.SetMaxAmpduLength (std::max<uint8_t> (3, static_cast<uint8_t> (maxAmpduLengthExponent))); //0 to 3 for HT
263c197
<           capabilities->SetRxMcsBitmask (mcs.GetMcsValue ());
---
>           capabilities.SetRxMcsBitmask (mcs.GetMcsValue ());
266c200
<           uint64_t dataRate = mcs.GetDataRate (m_phy->GetChannelWidth (), sgiSupported ? 400 : 800, nss);
---
>           uint64_t dataRate = mcs.GetDataRate (m_phy->GetChannelWidth (), m_phy->GetShortGuardInterval () ? 400 : 800, nss);
273,275c207,209
<       capabilities->SetRxHighestSupportedDataRate (static_cast<uint16_t> (maxSupportedRate / 1e6)); //in Mbit/s
<       capabilities->SetTxMcsSetDefined (m_phy->GetNMcs () > 0);
<       capabilities->SetTxMaxNSpatialStreams (m_phy->GetMaxSupportedTxSpatialStreams ());
---
>       capabilities.SetRxHighestSupportedDataRate (static_cast<uint16_t> (maxSupportedRate / 1e6)); //in Mbit/s
>       capabilities.SetTxMcsSetDefined (m_phy->GetNMcs () > 0);
>       capabilities.SetTxMaxNSpatialStreams (m_phy->GetMaxSupportedTxSpatialStreams ());
277,278c211,212
<       capabilities->SetTxRxMcsSetUnequal (0);
<       capabilities->SetTxUnequalModulation (0);
---
>       capabilities.SetTxRxMcsSetUnequal (0);
>       capabilities.SetTxUnequalModulation (0);
283c217
< Ptr<VhtCapabilities>
---
> VhtCapabilities
287,288c221,222
<   Ptr<VhtCapabilities> capabilities = Create<VhtCapabilities> ();
<   if (GetVhtSupported ())
---
>   VhtCapabilities capabilities;
>   if (m_vhtSupported)
290,293c224
<       Ptr<HtConfiguration> htConfiguration = GetHtConfiguration ();
<       Ptr<VhtConfiguration> vhtConfiguration = GetVhtConfiguration ();
<       bool sgiSupported = htConfiguration->GetShortGuardIntervalSupported ();
<       capabilities->SetVhtSupported (1);
---
>       capabilities.SetVhtSupported (1);
296c227
<           capabilities->SetSupportedChannelWidthSet (1);
---
>           capabilities.SetSupportedChannelWidthSet (1);
300c231
<           capabilities->SetSupportedChannelWidthSet (0);
---
>           capabilities.SetSupportedChannelWidthSet (0);
302,326c233,240
<       // Set Maximum MPDU Length subfield
<       uint16_t maxAmsduSize = std::max ({m_voMaxAmsduSize, m_viMaxAmsduSize,
<                                          m_beMaxAmsduSize, m_bkMaxAmsduSize});
<       if (maxAmsduSize <= 3839)
<         {
<           capabilities->SetMaxMpduLength (3895);
<         }
<       else if (maxAmsduSize <= 7935)
<         {
<           capabilities->SetMaxMpduLength (7991);
<         }
<       else
<         {
<           capabilities->SetMaxMpduLength (11454);
<         }
<       uint32_t maxAmpduLength = std::max ({m_voMaxAmpduSize, m_viMaxAmpduSize,
<                                            m_beMaxAmpduSize, m_bkMaxAmpduSize});
<       // round to the next power of two minus one
<       maxAmpduLength = (1ul << static_cast<uint32_t> (std::ceil (std::log2 (maxAmpduLength + 1)))) - 1;
<       // The maximum A-MPDU length in VHT capabilities elements ranges from 2^13-1 to 2^20-1
<       capabilities->SetMaxAmpduLength (std::min (std::max (maxAmpduLength, 8191u), 1048575u));
< 
<       capabilities->SetRxLdpc (0);
<       capabilities->SetShortGuardIntervalFor80Mhz ((m_phy->GetChannelWidth () == 80) && sgiSupported);
<       capabilities->SetShortGuardIntervalFor160Mhz ((m_phy->GetChannelWidth () == 160) && sgiSupported);
---
>       uint32_t maxMpduLength = std::max (std::max (m_beMaxAmsduSize, m_bkMaxAmsduSize), std::max (m_voMaxAmsduSize, m_viMaxAmsduSize)) + 56; //see section 9.11 of 11ac standard
>       capabilities.SetMaxMpduLength (uint8_t (maxMpduLength > 3895) + uint8_t (maxMpduLength > 7991)); //0 if 3895, 1 if 7991, 2 for 11454
>       capabilities.SetRxLdpc (m_phy->GetLdpc ());
>       capabilities.SetShortGuardIntervalFor80Mhz ((m_phy->GetChannelWidth () == 80) && m_phy->GetShortGuardInterval ());
>       capabilities.SetShortGuardIntervalFor160Mhz ((m_phy->GetChannelWidth () == 160) && m_phy->GetShortGuardInterval ());
>       double maxAmpduLengthExponent = std::max (std::ceil ((std::log (std::max (std::max (m_beMaxAmpduSize, m_bkMaxAmpduSize), std::max (m_voMaxAmpduSize, m_viMaxAmpduSize)) + 1.0) / std::log (2.0)) - 13.0), 0.0);
>       NS_ASSERT (maxAmpduLengthExponent >= 0 && maxAmpduLengthExponent <= 255);
>       capabilities.SetMaxAmpduLengthExponent (std::max<uint8_t> (7, static_cast<uint8_t> (maxAmpduLengthExponent))); //0 to 7 for VHT
340c254
<           capabilities->SetRxMcsMap (maxMcs, nss);
---
>           capabilities.SetRxMcsMap (maxMcs, nss);
344c258
<           capabilities->SetTxMcsMap (maxMcs, nss);
---
>           capabilities.SetTxMcsMap (maxMcs, nss);
360,361c274,275
<       capabilities->SetRxHighestSupportedLgiDataRate (static_cast<uint16_t> (maxSupportedRateLGI / 1e6)); //in Mbit/s
<       capabilities->SetTxHighestSupportedLgiDataRate (static_cast<uint16_t> (maxSupportedRateLGI / 1e6)); //in Mbit/s
---
>       capabilities.SetRxHighestSupportedLgiDataRate (static_cast<uint16_t> (maxSupportedRateLGI / 1e6)); //in Mbit/s
>       capabilities.SetTxHighestSupportedLgiDataRate (static_cast<uint16_t> (maxSupportedRateLGI / 1e6)); //in Mbit/s
363,364c277,278
<       capabilities->SetRxStbc (0);
<       capabilities->SetTxStbc (0);
---
>       capabilities.SetRxStbc (0);
>       capabilities.SetTxStbc (0);
369c283
< Ptr<HeCapabilities>
---
> HeCapabilities
373,374c287,288
<   Ptr<HeCapabilities> capabilities = Create<HeCapabilities> ();
<   if (GetHeSupported ())
---
>   HeCapabilities capabilities;
>   if (m_heSupported)
376,377c290
<       Ptr<HeConfiguration> heConfiguration = GetHeConfiguration ();
<       capabilities->SetHeSupported (1);
---
>       capabilities.SetHeSupported (1);
391c304
<       capabilities->SetChannelWidthSet (channelWidthSet);
---
>       capabilities.SetChannelWidthSet (channelWidthSet);
393c306
<       if (heConfiguration->GetGuardInterval () <= NanoSeconds (1600))
---
>       if (m_phy->GetGuardInterval () <= NanoSeconds (1600))
398c311
<       if (heConfiguration->GetGuardInterval () == NanoSeconds (800))
---
>       if (m_phy->GetGuardInterval () == NanoSeconds (800))
402,409c315,322
<       capabilities->SetHeLtfAndGiForHePpdus (gi);
<       uint32_t maxAmpduLength = std::max ({m_voMaxAmpduSize, m_viMaxAmpduSize,
<                                            m_beMaxAmpduSize, m_bkMaxAmpduSize});
<       // round to the next power of two minus one
<       maxAmpduLength = (1ul << static_cast<uint32_t> (std::ceil (std::log2 (maxAmpduLength + 1)))) - 1;
<       // The maximum A-MPDU length in HE capabilities elements ranges from 2^20-1 to 2^23-1
<       capabilities->SetMaxAmpduLength (std::min (std::max (maxAmpduLength, 1048575u), 8388607u));
< 
---
>       capabilities.SetHeLtfAndGiForHePpdus (gi);
>       double maxAmpduLengthExponent = std::max (std::ceil ((std::log (std::max (std::max (m_beMaxAmpduSize, m_bkMaxAmpduSize), std::max (m_voMaxAmpduSize, m_viMaxAmpduSize))
>                                                                       + 1.0)
>                                                             / std::log (2.0))
>                                                            - 13.0),
>                                                 0.0);
>       NS_ASSERT (maxAmpduLengthExponent >= 0 && maxAmpduLengthExponent <= 255);
>       capabilities.SetMaxAmpduLengthExponent (std::max<uint8_t> (7, static_cast<uint8_t> (maxAmpduLengthExponent))); //assume 0 to 7 for HE
420,421c333,334
<       capabilities->SetHighestMcsSupported (maxMcs);
<       capabilities->SetHighestNssSupported (m_phy->GetMaxSupportedTxSpatialStreams ());
---
>       capabilities.SetHighestMcsSupported (maxMcs);
>       capabilities.SetHighestNssSupported (m_phy->GetMaxSupportedTxSpatialStreams ());
426a340,403
> RegularWifiMac::SetVoMaxAmsduSize (uint16_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_voMaxAmsduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetViMaxAmsduSize (uint16_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_viMaxAmsduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetBeMaxAmsduSize (uint16_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_beMaxAmsduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetBkMaxAmsduSize (uint16_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_bkMaxAmsduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetVoMaxAmpduSize (uint16_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_voMaxAmpduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetViMaxAmpduSize (uint16_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_viMaxAmpduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetBeMaxAmpduSize (uint16_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_beMaxAmpduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
> RegularWifiMac::SetBkMaxAmpduSize (uint16_t size)
> {
>   NS_LOG_FUNCTION (this << size);
>   m_bkMaxAmpduSize = size;
>   ConfigureAggregation ();
> }
> 
> void
512,519d488
<   m_type = type;
< }
< 
< TypeOfStation
< RegularWifiMac::GetTypeOfStation (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return m_type;
614c583,596
<   //To be removed once deprecated API is cleaned up
---
>   NS_LOG_FUNCTION (this << enable);
>   m_vhtSupported = enable;
>   if (enable)
>     {
>       SetQosSupported (true);
>     }
>   if (!enable && !m_htSupported)
>     {
>       DisableAggregation ();
>     }
>   else
>     {
>       EnableAggregation ();
>     }
620,632c602,604
<   //To be removed once deprecated API is cleaned up
< }
< 
< void
< RegularWifiMac::SetHeSupported (bool enable)
< {
<   //To be removed once deprecated API is cleaned up
< }
< 
< bool
< RegularWifiMac::GetHtSupported () const
< {
<   if (GetHtConfiguration ())
---
>   NS_LOG_FUNCTION (this << enable);
>   m_htSupported = enable;
>   if (enable)
634c606
<       return true;
---
>       SetQosSupported (true);
636,642c608
<   return false;
< }
< 
< bool
< RegularWifiMac::GetVhtSupported () const
< {
<   if (GetVhtConfiguration ())
---
>   if (!enable && !m_vhtSupported)
644c610
<       return true;
---
>       DisableAggregation ();
646,652c612
<   return false;
< }
< 
< bool
< RegularWifiMac::GetHeSupported () const
< {
<   if (GetHeConfiguration ())
---
>   else
654c614
<       return true;
---
>       EnableAggregation ();
656d615
<   return false;
659d617
< //// WIGIG ////
661c619
< RegularWifiMac::SetDmgSupported (bool enable)
---
> RegularWifiMac::SetHeSupported (bool enable)
663,664c621,622
<   NS_LOG_FUNCTION (this);
<   m_dmgSupported = enable;
---
>   NS_LOG_FUNCTION (this << enable);
>   m_heSupported = enable;
668d625
<       EnableAggregation ();
670c627
<   else
---
>   if (!enable && !m_htSupported && !m_vhtSupported)
673a631,634
>   else
>     {
>       EnableAggregation ();
>     }
677c638
< RegularWifiMac::GetDmgSupported (void) const
---
> RegularWifiMac::GetVhtSupported () const
679c640
<   return m_dmgSupported;
---
>   return m_vhtSupported;
682,683c643,644
< void
< RegularWifiMac::SetEdmgSupported (bool enable)
---
> bool
> RegularWifiMac::GetHtSupported () const
685,695c646
<   NS_LOG_FUNCTION (this);
<   m_edmgSupported = enable;
<   if (enable)
<     {
<       SetQosSupported (true);
<       EnableAggregation ();
<     }
<   else
<     {
<       DisableAggregation ();
<     }
---
>   return m_htSupported;
699c650
< RegularWifiMac::GetEdmgSupported (void) const
---
> RegularWifiMac::GetHeSupported () const
701c652
<   return m_edmgSupported;
---
>   return m_heSupported;
703d653
< //// WIGIG ////
822a773,785
> RegularWifiMac::SetCtsTimeout (Time ctsTimeout)
> {
>   NS_LOG_FUNCTION (this << ctsTimeout);
>   m_low->SetCtsTimeout (ctsTimeout);
> }
> 
> Time
> RegularWifiMac::GetCtsTimeout (void) const
> {
>   return m_low->GetCtsTimeout ();
> }
> 
> void
887,892d849
< MacState
< RegularWifiMac::GetMacState (void) const
< {
<   return m_state;
< }
< 
916,924d872
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           htConfiguration->SetRifsSupported (enable);
<         }
<     }
931,939d878
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           return htConfiguration->GetRifsSupported ();
<         }
<     }
944c883
< RegularWifiMac::Enqueue (Ptr<Packet> packet,
---
> RegularWifiMac::Enqueue (Ptr<const Packet> packet,
962c901
< RegularWifiMac::ForwardUp (Ptr<const Packet> packet, Mac48Address from, Mac48Address to)
---
> RegularWifiMac::ForwardUp (Ptr<Packet> packet, Mac48Address from, Mac48Address to)
968,971d906
< //// WIGIG ////
< /**
<  * Functions for Fast Session Transfer.
<  */
973c908
< RegularWifiMac::SetupFSTSession (Mac48Address staAddress)
---
> RegularWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
975,986c910
<   NS_LOG_FUNCTION (this << staAddress);
< 
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (staAddress);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstSetupRequest requestHdr;
---
>   NS_LOG_FUNCTION (this << packet << hdr);
988,1235d911
<   /* Generate new FST Session ID */
<   m_fstId++;
< 
<   SessionTransitionElement sessionTransition;
<   Band newBand, oldBand;
<   newBand.Band_ID = Band_4_9GHz;
<   newBand.Setup = 1;
<   newBand.Operation = 1;
<   sessionTransition.SetNewBand (newBand);
<   oldBand.Band_ID = Band_60GHz;
<   oldBand.Setup = 1;
<   oldBand.Operation = 1;
<   sessionTransition.SetOldBand (oldBand);
<   sessionTransition.SetFstsID (m_fstId);
<   sessionTransition.SetSessionControl (SessionType_InfrastructureBSS, false);
< 
<   requestHdr.SetSessionTransition (sessionTransition);
<   requestHdr.SetLlt (m_llt);
<   requestHdr.SetMultiBand (GetMultiBandElement ());
<   requestHdr.SetDialogToken (10);
< 
<   /* We are the initiator of the FST session */
<   FstSession fstSession;
<   fstSession.ID = m_fstId;
<   fstSession.CurrentState = FST_INITIAL_STATE;
<   fstSession.IsInitiator = true;
<   fstSession.NewBandId = Band_4_9GHz;
<   fstSession.LLT = m_llt;
<   m_fstSessionMap[staAddress] = fstSession;
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_SETUP_REQUEST;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (requestHdr);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::SendFstSetupResponse (Mac48Address to, uint8_t token, uint16_t status, SessionTransitionElement sessionTransition)
< {
<   NS_LOG_FUNCTION (this << to << token << status);
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (to);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstSetupResponse responseHdr;
<   responseHdr.SetDialogToken (token);
<   responseHdr.SetStatusCode (status);
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_SETUP_RESPONSE;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (responseHdr);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::SendFstAckRequest (Mac48Address to, uint8_t dialog, uint32_t fstsID)
< {
<   NS_LOG_FUNCTION (this << to << dialog);
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (to);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstAckResponse requestHdr;
<   requestHdr.SetDialogToken (dialog);
<   requestHdr.SetFstsID (fstsID);
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_ACK_REQUEST;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (requestHdr);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::SendFstAckResponse (Mac48Address to, uint8_t dialog, uint32_t fstsID)
< {
<   NS_LOG_FUNCTION (this << to << dialog);
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (to);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstAckResponse responseHdr;
<   responseHdr.SetDialogToken (dialog);
<   responseHdr.SetFstsID (fstsID);
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_ACK_RESPONSE;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (responseHdr);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::SendFstTearDownFrame (Mac48Address to)
< {
<   NS_LOG_FUNCTION (this << to);
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_MGT_ACTION);
<   hdr.SetAddr1 (to);
<   hdr.SetAddr2 (GetAddress ());
<   hdr.SetAddr3 (GetAddress ());
<   hdr.SetDsNotFrom ();
<   hdr.SetDsNotTo ();
<   hdr.SetNoOrder ();
< 
<   ExtFstTearDown frame;
<   frame.SetFstsID (0);
< 
<   WifiActionHeader actionHdr;
<   WifiActionHeader::ActionValue action;
<   action.fstAction = WifiActionHeader::FST_TEAR_DOWN;
<   actionHdr.SetAction (WifiActionHeader::FST, action);
< 
<   Ptr<Packet> packet = Create<Packet> ();
<   packet->AddHeader (frame);
<   packet->AddHeader (actionHdr);
< 
<   m_txop->Queue (packet, hdr);
< }
< 
< void
< RegularWifiMac::NotifyBandChanged (enum WifiPhyStandard, Mac48Address address, bool isInitiator)
< {
<   NS_LOG_FUNCTION (this << address << isInitiator);
<   /* If we are the initiator, we send FST Ack Request in the new band */
<   if (isInitiator)
<     {
<       /* We transmit an FST ACK Request in the new frequency band */
<       FstSession *fstSession = &m_fstSessionMap[address];
<       SendFstAckRequest (address, 0, fstSession->ID);
<     }
< }
< 
< void
< RegularWifiMac::TxOk (Ptr<const Packet> currentPacket, const WifiMacHeader &hdr)
< {
<   NS_LOG_FUNCTION (this << hdr);
<   if (hdr.IsAction ())
<     {
<       WifiActionHeader actionHdr;
<       Ptr<Packet> packet = currentPacket->Copy ();
<       packet->RemoveHeader (actionHdr);
< 
<       if (actionHdr.GetCategory () == WifiActionHeader::FST)
<         {
<           switch (actionHdr.GetAction ().fstAction)
<             {
<             case WifiActionHeader::FST_SETUP_RESPONSE:
<               {
<                 NS_LOG_LOGIC ("FST Responder: Received ACK for FST Response, so transit to FST_SETUP_COMPLETION_STATE");
<                 FstSession *fstSession = &m_fstSessionMap[hdr.GetAddr1 ()];
<                 fstSession->CurrentState = FST_SETUP_COMPLETION_STATE;
<                 /* We are the responder of the FST session and we got ACK for FST Setup Response */          
<                 if (fstSession->LLT == 0)
<                   {
<                     NS_LOG_LOGIC ("FST Responder: LLT=0, so transit to FST_TRANSITION_DONE_STATE");
<                     fstSession->CurrentState = FST_TRANSITION_DONE_STATE;
<                     ChangeBand (hdr.GetAddr1 (), fstSession->NewBandId, false);
<                   }
<                 else
<                   {
<                     NS_LOG_LOGIC ("FST Responder: LLT>0, so start Link Loss Countdown");
<                     /* Initiate a Link Loss Timer */
<                     fstSession->LinkLossCountDownEvent = Simulator::Schedule (MicroSeconds (fstSession->LLT * 32),
<                                                                               &RegularWifiMac::ChangeBand, this,
<                                                                               hdr.GetAddr1 (), fstSession->NewBandId, false);
<                   }
<                 return;
<               }
<             case WifiActionHeader::FST_ACK_RESPONSE:
<               {
<                 /* We are the Responder of the FST session and we got ACK for FST ACK Response */
<                 NS_LOG_LOGIC ("FST Responder: Transmitted FST ACK Response successfully, so transit to FST_TRANSITION_CONFIRMED_STATE");
<                 FstSession *fstSession = &m_fstSessionMap[hdr.GetAddr1 ()];
<                 fstSession->CurrentState = FST_TRANSITION_CONFIRMED_STATE;
<                 return;
<               }
<             default:
<               break;
<             }
<         }
<     }
<   m_txOkCallback (hdr);
< }
< 
< void
< RegularWifiMac::ChangeBand (Mac48Address peerStation, BandID bandId, bool isInitiator)
< {
<   NS_LOG_FUNCTION (this << peerStation << bandId << isInitiator);
<   if (bandId == Band_60GHz)
<     {
<       m_bandChangedCallback (WIFI_PHY_STANDARD_80211ad, peerStation, isInitiator);
<     }
<   else if (bandId == Band_4_9GHz)
<     {
<       m_bandChangedCallback (WIFI_PHY_STANDARD_80211n_5GHZ, peerStation, isInitiator);
<     }
<   else if (bandId == Band_2_4GHz)
<     {
<       m_bandChangedCallback (WIFI_PHY_STANDARD_80211n_2_4GHZ, peerStation, isInitiator);
<     }
< }
< //// WIGIG ////
< 
< void
< RegularWifiMac::Receive (Ptr<WifiMacQueueItem> mpdu)
< {
<   NS_LOG_FUNCTION (this << *mpdu);
< 
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
<   Ptr<Packet> packet = mpdu->GetPacket ()->Copy ();
1321,1413d996
< 
<           //// WIGIG ////
< 
<           /* Fast Session Transfer */
<           case WifiActionHeader::FST:
<             switch (actionHdr.GetAction ().fstAction)
<               {
<               case WifiActionHeader::FST_SETUP_REQUEST:
<                 {
<                   ExtFstSetupRequest requestHdr;
<                   packet->RemoveHeader (requestHdr);
<                   /* We are the responder of the FST, create new entry for FST Session */
<                   FstSession fstSession;
<                   fstSession.ID = requestHdr.GetSessionTransition ().GetFstsID ();
<                   fstSession.CurrentState = FST_INITIAL_STATE;
<                   fstSession.IsInitiator = false;
<                   fstSession.NewBandId = static_cast<BandID> (requestHdr.GetSessionTransition ().GetNewBand ().Band_ID);
<                   fstSession.LLT = requestHdr.GetLlt ();
<                   m_fstSessionMap[hdr->GetAddr2 ()] = fstSession;
<                   NS_LOG_LOGIC ("FST Responder: Received FST Setup Request with LLT=" << m_llt);
<                   /* Send FST Response to the Initiator */
<                   SendFstSetupResponse (hdr->GetAddr2 (), requestHdr.GetDialogToken (), 0, requestHdr.GetSessionTransition ());
<                   return;
<                 }
<               case WifiActionHeader::FST_SETUP_RESPONSE:
<                 {
<                   ExtFstSetupResponse responseHdr;
<                   packet->RemoveHeader (responseHdr);
<                   /* We are the initiator of the FST */
<                   if (responseHdr.GetStatusCode () == 0)
<                     {
<                       /* Move the Initiator to the Setup Completion State */
<                       NS_LOG_LOGIC ("FST Initiator: Received FST Setup Response with Status=0, so transit to FST_SETUP_COMPLETION_STATE");
<                       FstSession *fstSession = &m_fstSessionMap[hdr->GetAddr2 ()];
<                       fstSession->CurrentState = FST_SETUP_COMPLETION_STATE;
<                       if (fstSession->LLT == 0)
<                         {
<                           NS_LOG_LOGIC ("FST Initiator: Received FST Setup Response with LLT=0, so transit to FST_TRANSITION_DONE_STATE");
<                           fstSession->CurrentState = FST_TRANSITION_DONE_STATE;
<                           /* Optionally transmit Broadcast FST Setup Response */
< 
<                           /* Check the new band */
<                           ChangeBand (hdr->GetAddr2 (), fstSession->NewBandId, true);
<                         }
<                       else
<                         {
<                           NS_LOG_LOGIC ("FST Initiator: Received FST Setup Response with LLT>0, so Initiate Link Loss Countdown");
<                           /* Initiate a Link Loss Timer */
<                           fstSession->LinkLossCountDownEvent = Simulator::Schedule (MicroSeconds (fstSession->LLT * 32),
<                                                                                     &RegularWifiMac::ChangeBand, this,
<                                                                                     hdr->GetAddr2 (), fstSession->NewBandId, true);
<                         }
<                     }
<                   else
<                     {
<                       NS_LOG_DEBUG ("FST Failed with " << hdr->GetAddr2 ());
<                     }
<                   return;
<                 }
<               case WifiActionHeader::FST_TEAR_DOWN:
<                 {
<                   ExtFstTearDown teardownHdr;
<                   packet->RemoveHeader (teardownHdr);
<                   FstSession *fstSession = &m_fstSessionMap[hdr->GetAddr2 ()];
<                   fstSession->CurrentState = FST_INITIAL_STATE;
<                   NS_LOG_DEBUG ("FST session with ID= " << teardownHdr.GetFstsID ()<< "is terminated");
<                   return;
<                 }
<               case WifiActionHeader::FST_ACK_REQUEST:
<                 {
<                   ExtFstAckRequest requestHdr;
<                   packet->RemoveHeader (requestHdr);
<                   SendFstAckResponse (hdr->GetAddr2 (), requestHdr.GetDialogToken (), requestHdr.GetFstsID ());
<                   NS_LOG_LOGIC ("FST Responder: Received FST ACK Request for FSTS ID=" << requestHdr.GetFstsID ()
<                                 << " so transmit FST ACK Response");
<                   return;
<                 }
<               case WifiActionHeader::FST_ACK_RESPONSE:
<                 {
<                   ExtFstAckResponse responseHdr;
<                   packet->RemoveHeader (responseHdr);
<                   /* We are the initiator, Get FST Session */
<                   FstSession *fstSession = &m_fstSessionMap[hdr->GetAddr2 ()];
<                   fstSession->CurrentState = FST_TRANSITION_CONFIRMED_STATE;
<                   NS_LOG_LOGIC ("FST Initiator: Received FST ACK Response for FSTS ID=" << responseHdr.GetFstsID ()
<                                 << " so transit to FST_TRANSITION_CONFIRMED_STATE");
<                   return;
<                 }
<               default:
<                 NS_FATAL_ERROR ("Unsupported Action field in Block Ack Action frame");
<                 return;
<               }
< 		//// WIGIG ////
1423c1006
< RegularWifiMac::DeaggregateAmsduAndForward (Ptr<WifiMacQueueItem> mpdu)
---
> RegularWifiMac::DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket, const WifiMacHeader *hdr)
1425,1426c1008,1011
<   NS_LOG_FUNCTION (this << *mpdu);
<   for (auto& msduPair : *PeekPointer (mpdu))
---
>   NS_LOG_FUNCTION (this << aggregatedPacket << hdr);
>   MsduAggregator::DeaggregatedMsdus packets = MsduAggregator::Deaggregate (aggregatedPacket);
>   for (MsduAggregator::DeaggregatedMsdusCI i = packets.begin ();
>        i != packets.end (); ++i)
1428,1429c1013,1014
<       ForwardUp (msduPair.first, msduPair.second.GetSourceAddr (),
<                  msduPair.second.GetDestinationAddr ());
---
>       ForwardUp ((*i).first, (*i).second.GetSourceAddr (),
>                  (*i).second.GetDestinationAddr ());
1442c1027
<   hdr.SetAddr3 (GetBssid ());
---
>   hdr.SetAddr3 (GetAddress ());
1445d1029
<   hdr.SetNoOrder ();
1463,1481c1047,1053
< 
<   //// WIGIG ////
<   if (m_stationManager->HasEdmgSupported ())
<     {
<       respHdr.SetBufferSize (1023);
<     }
<   else
<   //// WIGIG ////
<     {
<       Ptr<HeConfiguration> heConfiguration = GetHeConfiguration ();
<       if (heConfiguration && heConfiguration->GetMpduBufferSize () > 64)
<         {
<           respHdr.SetBufferSize (255);
<         }
<       else
<         {
<           respHdr.SetBufferSize (63);
<         }
<     }
---
>   //For now there's not no control about limit of reception. We
>   //assume that receiver has no limit on reception. However we assume
>   //that a receiver sets a bufferSize in order to satisfy next
>   //equation: (bufferSize + 1) % 16 = 0 So if a recipient is able to
>   //buffer a packet, it should be also able to buffer all possible
>   //packet's fragments. See section 7.3.1.14 in IEEE802.11e for more details.
>   respHdr.SetBufferSize (1023);
1521,1522c1093
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Not used anymore")
---
>                    MakeBooleanChecker ())
1528,1529c1099
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Not used anymore")
---
>                    MakeBooleanChecker ())
1535,1567c1105
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Not used anymore")
< 
<   	//// WIGIG ////
<     .AddAttribute ("DmgSupported",
<                    "This Boolean attribute is set to enable 802.11ad support at this STA",
<                     BooleanValue (false),
<                     MakeBooleanAccessor (&RegularWifiMac::SetDmgSupported,
<                                          &RegularWifiMac::GetDmgSupported),
<                     MakeBooleanChecker ())
<     .AddAttribute ("EdmgSupported",
<                    "This Boolean attribute is set to enable 802.11ay support at this STA",
<                     BooleanValue (false),
<                     MakeBooleanAccessor (&RegularWifiMac::SetEdmgSupported,
<                                          &RegularWifiMac::GetEdmgSupported),
<                     MakeBooleanChecker ())
< 
<     /* Fast Session Transfer Support */
<     .AddAttribute ("LLT", "The value of link loss timeout in microseconds",
<                     UintegerValue (0),
<                     MakeUintegerAccessor (&RegularWifiMac::m_llt),
<                     MakeUintegerChecker<uint32_t> ())
<     .AddAttribute ("FstTimeout", "The timeout value of FST session in TUs.",
<                     UintegerValue (10),
<                     MakeUintegerAccessor (&RegularWifiMac::m_fstTimeout),
<                     MakeUintegerChecker<uint8_t> ())
<     .AddAttribute ("SupportMultiBand",
<                    "Support multi-band operation for fast session transfer.",
<                     BooleanValue (false),
<                     MakeBooleanAccessor (&RegularWifiMac::m_supportMultiBand),
<                     MakeBooleanChecker ())
<   	//// WIGIG ////
< 
---
>                    MakeBooleanChecker ())
1574,1576c1112,1113
<                    "Maximum length in bytes of an A-MSDU for AC_VO access class "
<                    "(capped to 7935 for HT PPDUs and 11398 for VHT/HE PPDUs). "
<                    "Value 0 means A-MSDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MSDU for AC_VO access class. "
>                    "Value 0 means A-MSDU is disabled for that AC.",
1578,1579c1115,1116
<                    MakeUintegerAccessor (&RegularWifiMac::m_voMaxAmsduSize),
<                    MakeUintegerChecker<uint16_t> (0, 11398))
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetVoMaxAmsduSize),
>                    MakeUintegerChecker<uint16_t> (0, 11426))
1581,1583c1118,1119
<                    "Maximum length in bytes of an A-MSDU for AC_VI access class "
<                    "(capped to 7935 for HT PPDUs and 11398 for VHT/HE PPDUs). "
<                    "Value 0 means A-MSDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MSDU for AC_VI access class."
>                    "Value 0 means A-MSDU is disabled for that AC.",
1585,1586c1121,1122
<                    MakeUintegerAccessor (&RegularWifiMac::m_viMaxAmsduSize),
<                    MakeUintegerChecker<uint16_t> (0, 11398))
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetViMaxAmsduSize),
>                    MakeUintegerChecker<uint16_t> (0, 11426))
1588,1590c1124,1125
<                    "Maximum length in bytes of an A-MSDU for AC_BE access class "
<                    "(capped to 7935 for HT PPDUs and 11398 for VHT/HE PPDUs). "
<                    "Value 0 means A-MSDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MSDU for AC_BE access class."
>                    "Value 0 means A-MSDU is disabled for that AC.",
1592,1593c1127,1128
<                    MakeUintegerAccessor (&RegularWifiMac::m_beMaxAmsduSize),
<                    MakeUintegerChecker<uint16_t> (0, 11398))
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetBeMaxAmsduSize),
>                    MakeUintegerChecker<uint16_t> (0, 11426))
1595,1597c1130,1131
<                    "Maximum length in bytes of an A-MSDU for AC_BK access class "
<                    "(capped to 7935 for HT PPDUs and 11398 for VHT/HE PPDUs). "
<                    "Value 0 means A-MSDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MSDU for AC_BK access class."
>                    "Value 0 means A-MSDU is disabled for that AC.",
1599,1600c1133,1134
<                    MakeUintegerAccessor (&RegularWifiMac::m_bkMaxAmsduSize),
<                    MakeUintegerChecker<uint16_t> (0, 11398))
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetBkMaxAmsduSize),
>                    MakeUintegerChecker<uint16_t> (0, 11426))
1602,1604c1136,1137
<                    "Maximum length in bytes of an A-MPDU for AC_VO access class "
<                    "(capped to 65535 for HT PPDUs, 1048575 for VHT PPDUs, and 8388607 for HE PPDUs). "
<                    "Value 0 means A-MPDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MPDU for AC_VO access class."
>                    "Value 0 means A-MPDU is disabled for that AC.",
1606,1607c1139,1140
<                    MakeUintegerAccessor (&RegularWifiMac::m_voMaxAmpduSize),
<                    MakeUintegerChecker<uint32_t> ())
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetVoMaxAmpduSize),
>                    MakeUintegerChecker<uint16_t> ())
1609,1611c1142,1143
<                    "Maximum length in bytes of an A-MPDU for AC_VI access class "
<                    "(capped to 65535 for HT PPDUs, 1048575 for VHT PPDUs, and 8388607 for HE PPDUs). "
<                    "Value 0 means A-MPDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MPDU for AC_VI access class."
>                    "Value 0 means A-MPDU is disabled for that AC.",
1613,1614c1145,1146
<                    MakeUintegerAccessor (&RegularWifiMac::m_viMaxAmpduSize),
<                    MakeUintegerChecker<uint32_t> ())
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetViMaxAmpduSize),
>                    MakeUintegerChecker<uint16_t> ())
1616,1618c1148,1149
<                    "Maximum length in bytes of an A-MPDU for AC_BE access class "
<                    "(capped to 65535 for HT PPDUs, 1048575 for VHT PPDUs, and 8388607 for HE PPDUs). "
<                    "Value 0 means A-MPDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MPDU for AC_BE access class."
>                    "Value 0 means A-MPDU is disabled for that AC.",
1620,1621c1151,1152
<                    MakeUintegerAccessor (&RegularWifiMac::m_beMaxAmpduSize),
<                    MakeUintegerChecker<uint32_t> ())
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetBeMaxAmpduSize),
>                    MakeUintegerChecker<uint16_t> ())
1623,1625c1154,1155
<                    "Maximum length in bytes of an A-MPDU for AC_BK access class "
<                    "(capped to 65535 for HT PPDUs, 1048575 for VHT PPDUs, and 8388607 for HE PPDUs). "
<                    "Value 0 means A-MPDU aggregation is disabled for that AC.",
---
>                    "Maximum length in bytes of an A-MPDU for AC_BK access class."
>                    "Value 0 means A-MPDU is disabled for that AC.",
1627,1628c1157,1158
<                    MakeUintegerAccessor (&RegularWifiMac::m_bkMaxAmpduSize),
<                    MakeUintegerChecker<uint32_t> ())
---
>                    MakeUintegerAccessor (&RegularWifiMac::SetBkMaxAmpduSize),
>                    MakeUintegerChecker<uint16_t> ())
1658c1188
<                    "Represents max time (blocks of 1024 microseconds) allowed for block ack"
---
>                    "Represents max time (blocks of 1024 micro seconds) allowed for block ack"
1666c1196
<                    "Represents max time (blocks of 1024 microseconds) allowed for block ack"
---
>                    "Represents max time (blocks of 1024 micro seconds) allowed for block ack"
1674c1204
<                    "Represents max time (blocks of 1024 microseconds) allowed for block ack"
---
>                    "Represents max time (blocks of 1024 micro seconds) allowed for block ack"
1682c1212
<                    "Represents max time (blocks of 1024 microseconds) allowed for block ack"
---
>                    "Represents max time (blocks of 1024 micro seconds) allowed for block ack"
1700,1701c1230
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Use the HtConfiguration instead")
---
>                    MakeBooleanChecker ())
1747,1758d1275
<     //// WIGIG ////
<     case WIFI_PHY_STANDARD_80211ad:
<       SetDmgSupported (true);
<       cwmin = 15;
<       cwmax = 1023;
<       break;
<     case WIFI_PHY_STANDARD_80211ay:
<       SetEdmgSupported (true);
<       cwmin = 15;
<       cwmax = 1023;
<       break;
<     //// WIGIG ////
1759a1277
>       SetHeSupported (true);
1760a1279
>       SetVhtSupported (true);
1762,1772c1281,1284
<       {
<         EnableAggregation ();
<         //To be removed once deprecated attributes are removed
<         Ptr<HtConfiguration> htConfiguration = GetHtConfiguration ();
<         NS_ASSERT (htConfiguration);
<         htConfiguration->SetRifsSupported (m_rifsSupported);
<         SetQosSupported (true);
<         cwmin = 15;
<         cwmax = 1023;
<         break;
<       }
---
>       SetHtSupported (true);
>       cwmin = 15;
>       cwmax = 1023;
>       break;
1773a1286
>       SetHeSupported (true);
1775,1782c1288
<       {
<         EnableAggregation ();
<         //To be removed once deprecated RifsSupported attribute is removed
<         Ptr<HtConfiguration> htConfiguration = GetHtConfiguration ();
<         NS_ASSERT (htConfiguration);
<         htConfiguration->SetRifsSupported (m_rifsSupported);
<         SetQosSupported (true);
<       }
---
>       SetHtSupported (true);
1819a1326,1332
> RegularWifiMac::TxOk (const WifiMacHeader &hdr)
> {
>   NS_LOG_FUNCTION (this << hdr);
>   m_txOkCallback (hdr);
> }
> 
> void
1827c1340
< RegularWifiMac::EnableAggregation (void)
---
> RegularWifiMac::ConfigureAggregation (void)
1830c1343,1367
<   if (m_low->GetMsduAggregator () == 0)
---
>   if (GetVOQueue ()->GetMsduAggregator () != 0)
>     {
>       GetVOQueue ()->GetMsduAggregator ()->SetMaxAmsduSize (m_voMaxAmsduSize);
>     }
>   if (GetVIQueue ()->GetMsduAggregator () != 0)
>     {
>       GetVIQueue ()->GetMsduAggregator ()->SetMaxAmsduSize (m_viMaxAmsduSize);
>     }
>   if (GetBEQueue ()->GetMsduAggregator () != 0)
>     {
>       GetBEQueue ()->GetMsduAggregator ()->SetMaxAmsduSize (m_beMaxAmsduSize);
>     }
>   if (GetBKQueue ()->GetMsduAggregator () != 0)
>     {
>       GetBKQueue ()->GetMsduAggregator ()->SetMaxAmsduSize (m_bkMaxAmsduSize);
>     }
>   if (GetVOQueue ()->GetMpduAggregator () != 0)
>     {
>       GetVOQueue ()->GetMpduAggregator ()->SetMaxAmpduSize (m_voMaxAmpduSize);
>     }
>   if (GetVIQueue ()->GetMpduAggregator () != 0)
>     {
>       GetVIQueue ()->GetMpduAggregator ()->SetMaxAmpduSize (m_viMaxAmpduSize);
>     }
>   if (GetBEQueue ()->GetMpduAggregator () != 0)
1832,1834c1369
<       Ptr<MsduAggregator> msduAggregator = CreateObject<MsduAggregator> ();
<       msduAggregator->SetEdcaQueues (m_edca);
<       m_low->SetMsduAggregator (msduAggregator);
---
>       GetBEQueue ()->GetMpduAggregator ()->SetMaxAmpduSize (m_beMaxAmpduSize);
1836c1371
<   if (m_low->GetMpduAggregator () == 0)
---
>   if (GetBKQueue ()->GetMpduAggregator () != 0)
1838,1840c1373
<       Ptr<MpduAggregator> mpduAggregator = CreateObject<MpduAggregator> ();
<       mpduAggregator->SetEdcaQueues (m_edca);
<       m_low->SetMpduAggregator (mpduAggregator);
---
>       GetBKQueue ()->GetMpduAggregator ()->SetMaxAmpduSize (m_bkMaxAmpduSize);
1844a1378,1397
> RegularWifiMac::EnableAggregation (void)
> {
>   NS_LOG_FUNCTION (this);
>   for (EdcaQueues::const_iterator i = m_edca.begin (); i != m_edca.end (); ++i)
>     {
>       if (i->second->GetMsduAggregator () == 0)
>         {
>           Ptr<MsduAggregator> msduAggregator = CreateObject<MsduAggregator> ();
>           i->second->SetMsduAggregator (msduAggregator);
>         }
>       if (i->second->GetMpduAggregator () == 0)
>         {
>           Ptr<MpduAggregator> mpduAggregator = CreateObject<MpduAggregator> ();
>           i->second->SetMpduAggregator (mpduAggregator);
>         }
>     }
>   ConfigureAggregation ();
> }
> 
> void
1848,1849c1401,1405
<   m_low->SetMsduAggregator (0);
<   m_low->SetMpduAggregator (0);
---
>   for (EdcaQueues::const_iterator i = m_edca.begin (); i != m_edca.end (); ++i)
>     {
>       i->second->SetMsduAggregator (0);
>       i->second->SetMpduAggregator (0);
>     }
diff ../../NS3-WiGig/src/wifi/model/regular-wifi-mac.h ../../ns-3-dev-git/src/wifi/model/regular-wifi-mac.h
27,30d26
< #include "wifi-mac-header.h"
< #include "ctrl-headers.h"
< #include "mgt-headers.h"
< #include "edmg-short-ssw.h"
40,82d35
< //// WIGIG ////
< enum FST_STATES {
<   FST_INITIAL_STATE = 0,
<   FST_SETUP_COMPLETION_STATE,
<   FST_TRANSITION_DONE_STATE,
<   FST_TRANSITION_CONFIRMED_STATE
< };
< 
< struct FstSession {
<   uint32_t ID;                      //!< A unique ID that corresponds to a pair of receiver and transmitter.
<   FST_STATES CurrentState;          //!< Current state of the FST State Machine.
<   Time STT;                         //!< State transition timer.
<   bool IsInitiator;                 //!< Flag to indicate if we are the FST session initiator.
<   BandID NewBandId;                 //!< The new band the station is transferring to.
<   uint32_t LLT;                     //!< Link Loss Time (LLT) for this FST Session.
<   EventId LinkLossCountDownEvent;   //!< Event for Link Loss Timeout.
< };
< 
< /**
<  * This type defines a mapping between between the MAC Address of
<  * the Peer FST and FST Session Variables.
<  */
< typedef std::map<Mac48Address, FstSession> FstSessionMap;
< 
< //// WIGIG ////
< 
< /**
<  * The current MAC state of the STA.
<  */
< enum MacState
< {
<   ASSOCIATED,
<   WAIT_BEACON,
<   WAIT_PROBE_RESP,
<   WAIT_ASSOC_RESP,
<   UNASSOCIATED,
<   REFUSED
< };
< 
< /** This type defines a mapping between an Access Category index,
< and a pointer to the corresponding channel access function */
< typedef std::map<AcIndex, Ptr<QosTxop> > EdcaQueues;
< 
103c56,58
<   // Implementations of pure virtual methods.
---
>   /**
>    * \param slotTime the slot duration
>    */
104a60,62
>   /**
>    * \param sifs the sifs duration
>    */
105a64,69
>   /**
>    * \param eifsNoDifs the duration of an EIFS minus DIFS.
>    *
>    * This value is used to calculate the EIFS depending
>    * on AIFSN.
>    */
106a71,73
>   /**
>    * \param pifs the pifs duration.
>    */
107a75,77
>   /**
>    * \param rifs the rifs duration.
>    */
108a79,85
>   /**
>    * \param ctsTimeout the duration of a CTS timeout.
>    */
>   void SetCtsTimeout (Time ctsTimeout);
>   /**
>    * \param ackTimeout the duration of an ACK timeout.
>    */
110,113c87
<   void SetShortSlotTimeSupported (bool enable);
<   void SetSsid (Ssid ssid);
<   void SetAddress (Mac48Address address);
<   void SetPromisc (void);
---
> 
114a89,91
>   /**
>    * \return the current PIFS duration.
>    */
115a93,95
>   /**
>    * \return the current SIFS duration.
>    */
116a97,99
>   /**
>    * \return the current slot duration.
>    */
117a101,103
>   /**
>    * \return the current EIFS minus DIFS duration
>    */
119,130d104
<   Time GetAckTimeout (void) const;
<   bool GetShortSlotTimeSupported (void) const;
<   Ssid GetSsid (void) const;
<   Mac48Address GetAddress (void) const;
<   Mac48Address GetBssid (void) const;
<   virtual void Enqueue (Ptr<Packet> packet, Mac48Address to, Mac48Address from);
<   virtual bool SupportsSendFrom (void) const;
<   virtual void SetWifiPhy (const Ptr<WifiPhy> phy);
<   Ptr<WifiPhy> GetWifiPhy (void) const;
<   void ResetWifiPhy (void);
<   virtual void SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> stationManager);
< 
132,137c106
<    * This type defines the callback of a higher layer that a
<    * WifiMac(-derived) object invokes to pass a packet up the stack.
<    *
<    * \param packet the packet that has been received.
<    * \param from the MAC address of the device that sent the packet.
<    * \param to the MAC address of the device that the packet is destined for.
---
>    * \return the current CTS timeout duration.
139,146c108,110
<   typedef Callback<void, Ptr<const Packet>, Mac48Address, Mac48Address> ForwardUpCallback;
< 
<   void SetForwardUpCallback (ForwardUpCallback upCallback);
<   void SetLinkUpCallback (Callback<void> linkUp);
<   void SetLinkDownCallback (Callback<void> linkDown);
< 
<   /* Next functions are not pure virtual so non-QoS WifiMacs are not
<    * forced to implement them.
---
>   Time GetCtsTimeout (void) const;
>   /**
>    * \return the current ACK timeout duration.
148,154c112
<   void SetBasicBlockAckTimeout (Time blockAckTimeout);
<   Time GetBasicBlockAckTimeout (void) const;
<   void SetCompressedBlockAckTimeout (Time blockAckTimeout);
<   Time GetCompressedBlockAckTimeout (void) const;
< 
<   // Should be implemented by child classes
<   virtual void Enqueue (Ptr<Packet> packet, Mac48Address to) = 0;
---
>   Time GetAckTimeout (void) const;
162a121,135
> 
>   /**
>    * Enable or disable short slot time feature.
>    *
>    * \param enable true if short slot time is to be supported,
>    *               false otherwise
>    */
>   void SetShortSlotTimeSupported (bool enable);
>   /**
>    * \return whether the device supports short slot time capability.
>    *
>    * \return true if short slot time is supported,
>    *         false otherwise.
>    */
>   bool GetShortSlotTimeSupported (void) const;
168d140
<    * \deprecated
176d147
<    * \deprecated
178a150,166
> 
>   /**
>    * \return the MAC address associated to this MAC layer.
>    */
>   Mac48Address GetAddress (void) const;
>   /**
>    * \return the ssid which this MAC layer is going to try to stay in.
>    */
>   Ssid GetSsid (void) const;
>   /**
>    * \param address the current address of this MAC layer.
>    */
>   void SetAddress (Mac48Address address);
>   /**
>    * \param ssid the current ssid of this MAC layer.
>    */
>   void SetSsid (Ssid ssid);
182a171,182
>   /**
>    * \return the bssid of the network this device belongs to.
>    */
>   Mac48Address GetBssid (void) const;
>   /**
>    * \brief Sets the interface in promiscuous mode.
>    *
>    * Enables promiscuous mode on the interface. Note that any further
>    * filtering on the incoming frame path may affect the overall
>    * behavior.
>    */
>   void SetPromisc (void);
184a185,224
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
>    * \param from the address from which the packet should be sent.
>    *
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.  The extra parameter "from" allows
>    * this device to operate in a bridged mode, forwarding received
>    * frames without altering the source address.
>    */
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to, Mac48Address from);
> 
>   virtual bool SupportsSendFrom (void) const;
> 
>   /**
>    * \param packet the packet to send.
>    * \param to the address to which the packet should be sent.
>    *
>    * The packet should be enqueued in a tx queue, and should be
>    * dequeued as soon as the channel access function determines that
>    * access is granted to this MAC.
>    */
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to) = 0;
>   /**
>    * \param phy the physical layer attached to this MAC.
>    */
>   virtual void SetWifiPhy (const Ptr<WifiPhy> phy);
>   /**
>    * \return the physical layer attached to this MAC.
>    */
>   Ptr<WifiPhy> GetWifiPhy (void) const;
>   /**
>    * removes attached WifiPhy device from this MAC.
>    */
>   void ResetWifiPhy (void);
>   /**
>    * \param stationManager the station manager attached to this MAC.
>    */
>   virtual void SetWifiRemoteStationManager (const Ptr<WifiRemoteStationManager> stationManager);
>   /**
193c233
<   Ptr<ExtendedCapabilities> GetExtendedCapabilities (void) const;
---
>   ExtendedCapabilities GetExtendedCapabilities (void) const;
199c239
<   Ptr<HtCapabilities> GetHtCapabilities (void) const;
---
>   HtCapabilities GetHtCapabilities (void) const;
205c245
<   Ptr<VhtCapabilities> GetVhtCapabilities (void) const;
---
>   VhtCapabilities GetVhtCapabilities (void) const;
211,224c251
<   Ptr<HeCapabilities> GetHeCapabilities (void) const;
< 
<   /**
<    * \return Get the state of the MAC layer (Associated/MissedBeacon...)
<    */
<   virtual MacState GetMacState (void) const;
< 
< 
<   /**
<    * Accessor for the DCF object
<    *
<    * \return a smart pointer to Txop
<    */
<   Ptr<Txop> GetTxop (void) const;
---
>   HeCapabilities GetHeCapabilities (void) const;
227,233c254,255
<    * Accessor for the AC_VO channel access function
<    *
<    * \return a smart pointer to QosTxop
<    */
<   Ptr<QosTxop> GetVOQueue (void) const;
<   /**
<    * Accessor for the AC_VI channel access function
---
>    * This type defines the callback of a higher layer that a
>    * WifiMac(-derived) object invokes to pass a packet up the stack.
235c257,259
<    * \return a smart pointer to QosTxop
---
>    * \param packet the packet that has been received.
>    * \param from the MAC address of the device that sent the packet.
>    * \param to the MAC address of the device that the packet is destined for.
237c261
<   Ptr<QosTxop> GetVIQueue (void) const;
---
>   typedef Callback<void, Ptr<Packet>, Mac48Address, Mac48Address> ForwardUpCallback;
239,241c263,264
<    * Accessor for the AC_BE channel access function
<    *
<    * \return a smart pointer to QosTxop
---
>    * \param upCallback the callback to invoke when a packet must be
>    * forwarded up the stack.
243,249c266
<   Ptr<QosTxop> GetBEQueue (void) const;
<   /**
<    * Accessor for the AC_BK channel access function
<    *
<    * \return a smart pointer to QosTxop
<    */
<   Ptr<QosTxop> GetBKQueue (void) const;
---
>   void SetForwardUpCallback (ForwardUpCallback upCallback);
251c268
<    * Accessor for all EDCA Queues.
---
>    * \param linkUp the callback to invoke when the link becomes up.
253c270
<   EdcaQueues GetEdcaQueues () const;
---
>   void SetLinkUpCallback (Callback<void> linkUp);
255,256c272
<    * Setup FST session as initiator.
<    * \param staAddress The address of the sta to establish FST session with it.
---
>    * \param linkDown the callback to invoke when the link becomes down.
258,261c274,277
<   void SetupFSTSession (Mac48Address staAddress);
<   /**
<    * Get Type Of Station.
<    * \return station type
---
>   void SetLinkDownCallback (Callback<void> linkDown);
> 
>   /* Next functions are not pure virtual so non Qos WifiMacs are not
>    * forced to implement them.
263c279,283
<   TypeOfStation GetTypeOfStation (void) const;
---
>   void SetBasicBlockAckTimeout (Time blockAckTimeout);
>   Time GetBasicBlockAckTimeout (void) const;
>   void SetCompressedBlockAckTimeout (Time blockAckTimeout);
>   Time GetCompressedBlockAckTimeout (void) const;
> 
269c289
<   Ptr<MacRxMiddle> m_rxMiddle;  //!< RX middle (defragmentation etc.)
---
>   Ptr<MacRxMiddle> m_rxMiddle;  //!< RX middle (de-fragmentation etc.)
271c291
<   Ptr<MacLow> m_low;            //!< MacLow (RTS, CTS, Data, Ack etc.)
---
>   Ptr<MacLow> m_low;        //!< MacLow (RTS, CTS, DATA, ACK etc.)
273c293
<   Ptr<WifiPhy> m_phy;           //!< Wifi PHY
---
>   Ptr<WifiPhy> m_phy;       //!< Wifi PHY
281,284c301
<   //// WIGIG ////
<   Callback<void> m_sessionTransfer; //!< Callback when a session transfer takes place.
<   bool m_supportMultiBand;          //!< Flag to indicate whether we support multiband operation.
<   uint8_t m_fstTimeout;             //!< FST Session Timeout duration in TUs.
---
>   Ssid m_ssid; //!< Service Set ID (SSID)
286c303,313
<   /** Fast Session Transfer Functions **/
---
>   /** This holds a pointer to the TXOP instance for this WifiMac - used
>   for transmission of frames to non-QoS peers. */
>   Ptr<Txop> m_txop;
> 
>   /** This type defines a mapping between an Access Category index,
>   and a pointer to the corresponding channel access function */
>   typedef std::map<AcIndex, Ptr<QosTxop> > EdcaQueues;
> 
>   /** This is a map from Access Category index to the corresponding
>   channel access function */
>   EdcaQueues m_edca;
289,317c316,318
<    * Send FST Setup Response to Initiator.
<    * \param to The Mac address of the initiator.
<    * \param token The token dialog.
<    * \param status The status of the setup operation.
<    * \param sessionTransition The session transition element.
<    */
<   void SendFstSetupResponse (Mac48Address to, uint8_t token, uint16_t status, SessionTransitionElement sessionTransition);
<   /**
<    * Send FST ACK Request frame to the responder.
<    * \param to The MAC address of the responder station.
<    * \param token The token dialog.
<    * \param fstsID The ID of FST session.
<    */
<   void SendFstAckRequest (Mac48Address to, uint8_t token, uint32_t fstsID);
<   /**
<    * Send FST ACk Response frame to the initiator.
<    * \param to The MAC address of the initiator station.
<    * \param token The token dialog.
<    * \param fstsID The ID of FST session.
<    */
<   void SendFstAckResponse (Mac48Address to, uint8_t token, uint32_t fstsID);
<   /**
<    * Send FST TearDown frame to a station.
<    * \param to The MAC address of the peer station.
<    */
<   void SendFstTearDownFrame (Mac48Address to);
<   /**
<    * Get the multiband information element associated with this STA device.
<    * \return The MultiBand information element correspodning to this WifiMac.
---
>    * Accessor for the DCF object
>    *
>    * \return a smart pointer to Txop
319c320,321
<   virtual Ptr<MultiBandElement> GetMultiBandElement (void) const = 0;
---
>   Ptr<Txop> GetTxop (void) const;
> 
321,324c323,325
<    * Notify that the frequency band has changed
<    * \param standard The WiFi standard to use in the new band.
<    * \param address The address of the peer station.
<    * \param isInitiator flag to indicate whether we are the initiator of the FST or not.
---
>    * Accessor for the AC_VO channel access function
>    *
>    * \return a smart pointer to QosTxop
326c327
<   void NotifyBandChanged (WifiPhyStandard standard, Mac48Address address, bool isInitiator);
---
>   Ptr<QosTxop> GetVOQueue (void) const;
328,331c329,331
<    * Change the current operational frequency band.
<    * \param peerStation The MAC address of the peer station.
<    * \param bandId The ID of the new band.
<    * \param isInitiator True is we are the initiator of the FST, otherwise false.
---
>    * Accessor for the AC_VI channel access function
>    *
>    * \return a smart pointer to QosTxop
333c333
<   void ChangeBand (Mac48Address peerStation, BandID bandId, bool isInitiator);
---
>   Ptr<QosTxop> GetVIQueue (void) const;
335,336c335,337
<    * MacTxOk
<    * \param address
---
>    * Accessor for the AC_BE channel access function
>    *
>    * \return a smart pointer to QosTxop
338c339
<   void MacTxOk (Mac48Address address);
---
>   Ptr<QosTxop> GetBEQueue (void) const;
340,341c341,343
<    * MacRxOk
<    * \param address
---
>    * Accessor for the AC_BK channel access function
>    *
>    * \return a smart pointer to QosTxop
343,360c345
<   void MacRxOk (Mac48Address address);
< 
<   uint32_t m_llt;                   //!< Link Loss Timeout.
<   uint32_t m_fstId;                 //!< Fast session transfer ID.
<   FstSessionMap m_fstSessionMap;    //!< Maps for active FST sessions.
< 
<   //// WIGIG ////
< 
<   Ssid m_ssid;      //!< Service Set ID (SSID)
<   MacState m_state; //!< The state of the MAC layer.
< 
<   /** This holds a pointer to the DCF instance for this WifiMac - used
<   for transmission of frames to non-QoS peers. */
<   Ptr<Txop> m_txop;
< 
<   /** This is a map from Access Category index to the corresponding
<   channel access function */
<   EdcaQueues m_edca;
---
>   Ptr<QosTxop> GetBKQueue (void) const;
363c348
<    * \param standard the PHY standard to be used
---
>    * \param standard the phy standard to be used
366c351
<    * complete the configuration process for a requested PHY standard.
---
>    * complete the configuration process for a requested phy standard.
377,378c362,363
<    * \param cwMin the minimum contention window size
<    * \param cwMax the maximum contention window size
---
>    * \param cwMin the minimum congestion window size
>    * \param cwMax the maximum congestion window size
406c391,392
<    * \param mpdu the MPDU that has been received.
---
>    * \param packet the packet that has been received.
>    * \param hdr a pointer to the MAC header of the received frame.
408c394
<   virtual void Receive (Ptr<WifiMacQueueItem> mpdu);
---
>   virtual void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
411c397
<    * (i.e. we received an Ack from the receiver).
---
>    * (i.e. we received an ACK from the receiver).
413,414c399
<    * \param packet the packet that has been transmitted.
<    * \param hdr the header of the packet that we successfully sent.
---
>    * \param hdr the header of the packet that we successfully sent
416c401
<   virtual void TxOk (Ptr<const Packet> packet, const WifiMacHeader &hdr);
---
>   virtual void TxOk (const WifiMacHeader &hdr);
419c404
<    * (i.e. we did not receive an Ack from the receiver).
---
>    * (i.e. we did not receive an ACK from the receiver).
432c417
<   void ForwardUp (Ptr<const Packet> packet, Mac48Address from, Mac48Address to);
---
>   void ForwardUp (Ptr<Packet> packet, Mac48Address from, Mac48Address to);
438c423,424
<    * \param mpdu the MPDU containing the A-MSDU.
---
>    * \param aggregatedPacket the Packet containing the A-MSDU.
>    * \param hdr a pointer to the MAC header for \c aggregatedPacket.
440c426,427
<   virtual void DeaggregateAmsduAndForward (Ptr<WifiMacQueueItem> mpdu);
---
>   virtual void DeaggregateAmsduAndForward (Ptr<Packet> aggregatedPacket,
>                                            const WifiMacHeader *hdr);
517,552d503
<   //// WIGIG ////
<   /**
<    * This Boolean is set \c true if this WifiMac is to model
<    * 802.11ad. It is exposed through the attribute system.
<    */
<   bool m_dmgSupported;
<   /**
<    * Enable or disable DMG support for the device.
<    *
<    * \param enable whether DMG is supported
<    */
<   void SetDmgSupported (bool enable);
<   /**
<    * Return whether the device supports DMG.
<    *
<    * \return true if DMG is supported, false otherwise
<    */
<   bool GetDmgSupported (void) const;
<   /**
<    * This Boolean is set \c true if this WifiMac is to model
<    * 802.11ay. It is exposed through the attribute system.
<    */
<   bool m_edmgSupported;
<   /**
<    * Enable or disable EDMG support for the device.
<    *
<    * \param enable whether EDMG is supported
<    */
<   void SetEdmgSupported (bool enable);
<   /**
<    * Return whether the device supports EDMG.
<    *
<    * \return true if EDMG is supported, false otherwise
<    */
<   bool GetEdmgSupported (void) const;
<   //// WIGIG ////
565a517
> 
586c538
<    * Set the block ack threshold for AC_VO.
---
>    * Set the maximum A-MSDU size for AC_VO.
588c540,590
<    * \param threshold the block ack threshold for AC_VO.
---
>    * \param size the maximum A-MSDU size for AC_VO.
>    */
>   void SetVoMaxAmsduSize (uint16_t size);
>   /**
>    * Set the maximum A-MSDU size for AC_VI.
>    *
>    * \param size the maximum A-MSDU size for AC_VI.
>    */
>   void SetViMaxAmsduSize (uint16_t size);
>   /**
>    * Set the maximum A-MSDU size for AC_BE.
>    *
>    * \param size the maximum A-MSDU size for AC_BE.
>    */
>   void SetBeMaxAmsduSize (uint16_t size);
>   /**
>    * Set the maximum A-MSDU size for AC_BK.
>    *
>    * \param size the maximum A-MSDU size for AC_BK.
>    */
>   void SetBkMaxAmsduSize (uint16_t size);
> 
>   /**
>    * Set the maximum A-MPDU size for AC_VO.
>    *
>    * \param size the maximum A-MPDU size for AC_VO.
>    */
>   void SetVoMaxAmpduSize (uint16_t size);
>   /**
>    * Set the maximum A-MPDU size for AC_VI.
>    *
>    * \param size the maximum A-MPDU size for AC_VI.
>    */
>   void SetViMaxAmpduSize (uint16_t size);
>   /**
>    * Set the maximum A-MPDU size for AC_BE.
>    *
>    * \param size the maximum A-MPDU size for AC_BE.
>    */
>   void SetBeMaxAmpduSize (uint16_t size);
>   /**
>    * Set the maximum A-MPDU size for AC_BK.
>    *
>    * \param size the maximum A-MPDU size for AC_BK.
>    */
>   void SetBkMaxAmpduSize (uint16_t size);
> 
>   /**
>    * Set the Block ACK threshold for AC_VO.
>    *
>    * \param threshold the Block ACK threshold for AC_VO.
592c594
<    * Set the block ack threshold for AC_VI.
---
>    * Set the Block ACK threshold for AC_VI.
594c596
<    * \param threshold the block ack threshold for AC_VI.
---
>    * \param threshold the Block ACK threshold for AC_VI.
598c600
<    * Set the block ack threshold for AC_BE.
---
>    * Set the Block ACK threshold for AC_BE.
600c602
<    * \param threshold the block ack threshold for AC_BE.
---
>    * \param threshold the Block ACK threshold for AC_BE.
604c606
<    * Set the block ack threshold for AC_BK.
---
>    * Set the Block ACK threshold for AC_BK.
606c608
<    * \param threshold the block ack threshold for AC_BK.
---
>    * \param threshold the Block ACK threshold for AC_BK.
649a652,669
>     * This Boolean is set \c true iff this WifiMac is to model
>     * 802.11n. It is exposed through the attribute system.
>     *
>     * At the moment, this flag is the sole selection between HT and
>     * non-HT operation for the STA (whether IBSS, AP, or
>     * non-AP). Ultimately, we will want a HT-enabled STA to be able to
>     * fall back to non-HT operation with a non-HT peer. This'll
>     * require further intelligence - i.e., per-association HT
>     * state. Having a big switch seems like a good intermediate stage,
>     * however.
>     */
>   bool m_htSupported;
>   /**
>    * This Boolean is set \c true iff this WifiMac is to model
>    * 802.11ac. It is exposed through the attribute system.
>    */
>   bool m_vhtSupported;
>   /**
658a679,683
>   /**
>    * This Boolean is set \c true iff this WifiMac is to model
>    * 802.11ax. It is exposed through the attribute system.
>    */
>   bool m_heSupported;
659a685,686
>   /// Configure aggregation function
>   void ConfigureAggregation (void);
665,673c692,700
<   uint16_t m_voMaxAmsduSize; ///< maximum A-MSDU size for AC_VO (in bytes)
<   uint16_t m_viMaxAmsduSize; ///< maximum A-MSDU size for AC_VI (in bytes)
<   uint16_t m_beMaxAmsduSize; ///< maximum A-MSDU size for AC_BE (in bytes)
<   uint16_t m_bkMaxAmsduSize; ///< maximum A-MSDU size for AC_BK (in bytes)
< 
<   uint32_t m_voMaxAmpduSize; ///< maximum A-MPDU size for AC_VO (in bytes)
<   uint32_t m_viMaxAmpduSize; ///< maximum A-MPDU size for AC_VI (in bytes)
<   uint32_t m_beMaxAmpduSize; ///< maximum A-MPDU size for AC_BE (in bytes)
<   uint32_t m_bkMaxAmpduSize; ///< maximum A-MPDU size for AC_BK (in bytes)
---
>   uint16_t m_voMaxAmsduSize; ///< maximum A-MSDU size for AC_VO
>   uint16_t m_viMaxAmsduSize; ///< maximum A-MSDU size for AC_VI
>   uint16_t m_beMaxAmsduSize; ///< maximum A-MSDU size for AC_BE
>   uint16_t m_bkMaxAmsduSize; ///< maximum A-MSDU size for AC_BK
> 
>   uint16_t m_voMaxAmpduSize; ///< maximum A-MPDU size for AC_VO
>   uint16_t m_viMaxAmpduSize; ///< maximum A-MPDU size for AC_VI
>   uint16_t m_beMaxAmpduSize; ///< maximum A-MPDU size for AC_BE
>   uint16_t m_bkMaxAmpduSize; ///< maximum A-MPDU size for AC_BK
678d704
<   TypeOfStation m_type;  ///< type of the station
680c706
<   bool m_rifsSupported; ///< flag whether RIFS is supported (deprecated)
---
>   bool m_rifsSupported; ///< flag whether RIFS is supported
Only in ../../NS3-WiGig/src/wifi/model: rf-chain.cc
Only in ../../NS3-WiGig/src/wifi/model: rf-chain.h
diff ../../NS3-WiGig/src/wifi/model/rraa-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/rraa-wifi-manager.cc
50,51c50,51
<   uint8_t m_nRate;               //!< Number of supported rates.
<   uint8_t m_rateIndex;           //!< Current rate index.
---
>   uint8_t m_nRate;              //!< Number of supported rates.
>   uint8_t m_rateIndex;          //!< Current rate index.
71c71
<                    "Timeout for the RRAA BASIC loss estimation block",
---
>                    "Timeout for the RRAA BASIC loss estimation block (s)",
76c76
<                    "The Data frame length (in bytes) used for calculating mode TxTime.",
---
>                    "The data frame length (in bytes) used for calculating mode TxTime.",
81c81
<                    "The Ack frame length (in bytes) used for calculating mode TxTime.",
---
>                    "The ACK frame length (in bytes) used for calculating mode TxTime.",
107a108
> 
131c132
<       /* Calculate the TX Time of the Data and the corresponding Ack */
---
>       /* Calculate the TX Time of the data and the corresponding ACK*/
149,166d149
< void
< RraaWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
303c286
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
---
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
326,327c309,310
< RraaWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                  double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> RraaWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                  double ackSnr, WifiMode ackMode, double dataSnr)
329,330c312,313
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
353c336
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
---
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
356a340
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
366c350
<   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
373c357
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
---
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
376a361
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
389c374
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
395c380
<                             uint32_t size, bool normally)
---
>                             Ptr<const Packet> packet, bool normally)
397,398c382,383
<   NS_LOG_FUNCTION (this << st << size << normally);
<   RraaWifiRemoteStation *station = static_cast<RraaWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << packet << normally);
>   RraaWifiRemoteStation *station = (RraaWifiRemoteStation *) st;
468c453
< RraaWifiManager::GetThresholds (RraaWifiRemoteStation *station, uint8_t index) const
---
> RraaWifiManager::GetThresholds (RraaWifiRemoteStation *station, uint8_t rate) const
470,471c455,456
<   NS_LOG_FUNCTION (this << station << +index);
<   WifiMode mode = GetSupported (station, index);
---
>   NS_LOG_FUNCTION (this << station << +rate);
>   WifiMode mode = GetSupported (station, rate);
472a458,493
> }
> 
> bool
> RraaWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
> void
> RraaWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> RraaWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> RraaWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/rraa-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/rraa-wifi-manager.h
54c54
<  * This RAA does not support HT modes and will error
---
>  * This RAA does not support HT, VHT nor HE modes and will error
56c56
<  * that supports 802.11n or higher.
---
>  * that has VhtSupported, HtSupported or HeSupported set.
72a73,75
>   void SetHtSupported (bool enable);
>   void SetVhtSupported (bool enable);
>   void SetHeSupported (bool enable);
76,77c79
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
85,86c87,88
<   void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                        double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   void DoReportDataOk (WifiRemoteStation *station,
>                        double ackSnr, WifiMode ackMode, double dataSnr);
92c94,95
<                   uint32_t size, bool normally);
---
>                   Ptr<const Packet> packet, bool normally);
>   bool IsLowLatency (void) const;
103c106
<    * \param station the remote station
---
>    * \param station
111c114
<    * \param station the remote station
---
>    * \param station
118c121
<    * \param station the remote station
---
>    * \param station
124c127
<    * \param station the remote station
---
>    * \param station
130c133
<    * \param station the remote station
---
>    * \param station
136c139
<    * \param station the remote station
---
>    * \param station
142,143c145,146
<    * \param station the remote station
<    * \param mode the WifiMode
---
>    * \param station
>    * \param mode
145c148
<    * \return the RRAA thresholds
---
>    * \return threshold
151,152c154,155
<    * \param station the remote station
<    * \param index the mode index in the supported rates
---
>    * \param station
>    * \param rate
154c157
<    * \return the RRAA thresholds
---
>    * \return threshold
156c159
<   WifiRraaThresholds GetThresholds (RraaWifiRemoteStation *station, uint8_t index) const;
---
>   WifiRraaThresholds GetThresholds (RraaWifiRemoteStation *station, uint8_t rate) const;
160c163
<    * \param mode the WifiMode
---
>    * \param mode
162c165
<    * \return the estimated TX time
---
>    * \return time
168c171
<    * \param mode the WifiMode
---
>    * \param mode Wi-Fi mode
diff ../../NS3-WiGig/src/wifi/model/rrpaa-wifi-manager.cc ../../ns-3-dev-git/src/wifi/model/rrpaa-wifi-manager.cc
52,54c52,54
<   uint8_t m_nRate;               //!< Number of supported rates.
<   uint8_t m_prevRateIndex;       //!< Rate index of the previous transmission.
<   uint8_t m_rateIndex;           //!< Current rate index.
---
>   uint8_t m_nRate;              //!< Number of supported rates.
>   uint8_t m_prevRateIndex;      //!< Rate index of the previous transmission.
>   uint8_t m_rateIndex;          //!< Current rate index.
57c57
<   RrpaaThresholdsTable m_thresholds;  //!< RRPAA thresholds for this station.
---
>   RrpaaThresholdsTable m_thresholds;  //!< Rrpaa thresholds for this station.
71c71
<                    "If true the RRPAA-BASIC algorithm will be used, otherwise the RRPAA will be used.",
---
>                    "If true the RRAA-BASIC algorithm will be used, otherwise the RRAA will be used.",
76c76
<                    "Timeout for the RRPAA-BASIC loss estimation block.",
---
>                    "Timeout for the RRAA-BASIC loss estimation block (s).",
81c81
<                    "The Data frame length (in bytes) used for calculating mode TxTime.",
---
>                    "The data frame length (in bytes) used for calculating mode TxTime.",
86c86
<                    "The Ack frame length (in bytes) used for calculating mode TxTime.",
---
>                    "The ACK frame length (in bytes) used for calculating mode TxTime.",
161c161
<       /* Calculate the TX Time of the Data and the corresponding Ack */
---
>       /* Calculate the TX Time of the data and the corresponding ACK*/
179,196d178
< void
< RrpaaWifiManager::DoInitialize ()
< {
<   NS_LOG_FUNCTION (this);
<   if (GetHtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
<     }
<   if (GetVhtSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
<     }
<   if (GetHeSupported ())
<     {
<       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
<     }
< }
< 
345c327
<   RrpaaWifiRemoteStation *station = static_cast<RrpaaWifiRemoteStation*> (st);
---
>   RrpaaWifiRemoteStation *station = (RrpaaWifiRemoteStation *) st;
369,370c351,352
< RrpaaWifiManager::DoReportDataOk (WifiRemoteStation *st, double ackSnr, WifiMode ackMode,
<                                   double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> RrpaaWifiManager::DoReportDataOk (WifiRemoteStation *st,
>                                   double ackSnr, WifiMode ackMode, double dataSnr)
372,373c354,355
<   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr << dataChannelWidth << +dataNss);
<   RrpaaWifiRemoteStation *station = static_cast<RrpaaWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << ackSnr << ackMode << dataSnr);
>   RrpaaWifiRemoteStation *station = (RrpaaWifiRemoteStation *) st;
395c377
<   RrpaaWifiRemoteStation *station = static_cast<RrpaaWifiRemoteStation*> (st);
---
>   RrpaaWifiRemoteStation *station = (RrpaaWifiRemoteStation *) st;
398a381
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
417c400
<   return WifiTxVector (mode, station->m_powerLevel, GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   return WifiTxVector (mode, station->m_powerLevel, GetPreambleForTransmission (mode, GetAddress (station)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
423c406
<   RrpaaWifiRemoteStation *station = static_cast<RrpaaWifiRemoteStation*> (st);
---
>   RrpaaWifiRemoteStation *station = (RrpaaWifiRemoteStation *) st;
426a410
>       //avoid to use legacy rate adaptation algorithms for IEEE 802.11n/ac
439c423
<   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (GetAddress (station))), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
---
>   rtsTxVector = WifiTxVector (mode, GetDefaultTxPowerLevel (), GetPreambleForTransmission (mode, GetAddress (st)), 800, 1, 1, 0, channelWidth, GetAggregation (station), false);
445c429
<                              uint32_t size, bool normally)
---
>                              Ptr<const Packet> packet, bool normally)
447,448c431,432
<   NS_LOG_FUNCTION (this << st << size << normally);
<   RrpaaWifiRemoteStation *station = static_cast<RrpaaWifiRemoteStation*> (st);
---
>   NS_LOG_FUNCTION (this << st << packet << normally);
>   RrpaaWifiRemoteStation *station = (RrpaaWifiRemoteStation *) st;
606c590
< RrpaaWifiManager::GetThresholds (RrpaaWifiRemoteStation *station, uint8_t index) const
---
> RrpaaWifiManager::GetThresholds (RrpaaWifiRemoteStation *station, uint8_t rate) const
608,609c592,593
<   NS_LOG_FUNCTION (this << station << +index);
<   WifiMode mode = GetSupported (station, index);
---
>   NS_LOG_FUNCTION (this << station << +rate);
>   WifiMode mode = GetSupported (station, rate);
610a595,630
> }
> 
> bool
> RrpaaWifiManager::IsLowLatency (void) const
> {
>   return true;
> }
> 
> void
> RrpaaWifiManager::SetHtSupported (bool enable)
> {
>   //HT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HT rates");
>     }
> }
> 
> void
> RrpaaWifiManager::SetVhtSupported (bool enable)
> {
>   //VHT is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support VHT rates");
>     }
> }
> 
> void
> RrpaaWifiManager::SetHeSupported (bool enable)
> {
>   //HE is not supported by this algorithm.
>   if (enable)
>     {
>       NS_FATAL_ERROR ("WifiRemoteStationManager selected does not support HE rates");
>     }
diff ../../NS3-WiGig/src/wifi/model/rrpaa-wifi-manager.h ../../ns-3-dev-git/src/wifi/model/rrpaa-wifi-manager.h
48,50d47
<  * This RAA does not support HT modes and will error
<  * exit if the user tries to configure this RAA with a Wi-Fi MAC
<  * that supports 802.11n or higher.
59c56
<   double m_ori; //!< The Opportunistic Rate Increase threshold.
---
>   double m_ori; //!< The Oportunistic Rate Increase threshold.
87a85,87
>   virtual void SetHtSupported (bool enable);
>   virtual void SetVhtSupported (bool enable);
>   virtual void SetHeSupported (bool enable);
101,102c101
<   // Overridden from base class.
<   void DoInitialize (void);
---
>   //overridden from base class
110,111c109,110
<   virtual void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                                double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr);
117c116,117
<                           uint32_t size, bool normally);
---
>                           Ptr<const Packet> packet, bool normally);
>   virtual bool IsLowLatency (void) const;
121c121
<    * \param station the remote station.
---
>    * \param station The remote station.
128c128
<    * \param station the remote station
---
>    * \param station
135c135
<    * \param station the remote station
---
>    * \param station
142c142
<    * \param station the remote station
---
>    * \param station
148c148
<    * \param station the remote station
---
>    * \param station
155c155
<    * \param station the remote station
---
>    * \param station
162,163c162,163
<    * \param station the remote station
<    * \param mode the WifiMode
---
>    * \param station
>    * \param mode
165c165
<    * \return the RRPAA thresholds
---
>    * \return threshold
172,173c172,173
<    * \param station the remote station
<    * \param index the mode index in the supported rates
---
>    * \param station
>    * \param rate
175c175
<    * \return the RRPAA thresholds
---
>    * \return threshold
177c177
<   WifiRrpaaThresholds GetThresholds (RrpaaWifiRemoteStation *station, uint8_t index) const;
---
>   WifiRrpaaThresholds GetThresholds (RrpaaWifiRemoteStation *station, uint8_t rate) const;
182c182
<    * \param mode the WifiMode
---
>    * \param mode
184c184
<    * \return the estimated TX time
---
>    * \return time
190c190
<    * \param mode the WifiMode
---
>    * \param mode Wi-Fi mode
206,207c206,207
<   uint32_t m_frameLength;  //!< Data frame length used for calculate mode TxTime (in bytes).
<   uint32_t m_ackLength;    //!< Ack frame length used for calculate mode TxTime (in bytes).
---
>   uint32_t m_frameLength;  //!< Data frame length used for calculate mode TxTime.
>   uint32_t m_ackLength;    //!< Ack frame length used for calculate mode TxTime.
Only in ../../NS3-WiGig/src/wifi/model: sensitivity-lut.cc
Only in ../../NS3-WiGig/src/wifi/model: sensitivity-lut.h
Only in ../../NS3-WiGig/src/wifi/model: sensitivity-model-60-ghz.cc
Only in ../../NS3-WiGig/src/wifi/model: sensitivity-model-60-ghz.h
diff ../../NS3-WiGig/src/wifi/model/simple-frame-capture-model.cc ../../ns-3-dev-git/src/wifi/model/simple-frame-capture-model.cc
44c44
<                    DoubleValue (5),
---
>                    DoubleValue (10),
79,80c79,81
<   if ((WToDbm (currentEvent->GetRxPowerW ()) + GetMargin ()) < WToDbm (newEvent->GetRxPowerW ())
<       && (IsInCaptureWindow (currentEvent->GetStartTime ())))
---
>   if (newEvent->GetTxVector ().GetPreambleType () != WIFI_PREAMBLE_NONE
>       && (WToDbm (currentEvent->GetRxPowerW ()) + GetMargin ()) < WToDbm (newEvent->GetRxPowerW ())
>       && ((currentEvent->GetStartTime () + WifiPhy::CalculatePlcpPreambleAndHeaderDuration (currentEvent->GetTxVector ())) > Simulator::Now ()))
diff ../../NS3-WiGig/src/wifi/model/simple-frame-capture-model.h ../../ns-3-dev-git/src/wifi/model/simple-frame-capture-model.h
76c76
<   double m_margin; ///< margin for determining if a new frame (dB)
---
>   double m_margin; ///< margin for determining if a new frame
diff ../../NS3-WiGig/src/wifi/model/snr-tag.cc ../../ns-3-dev-git/src/wifi/model/snr-tag.cc
39c39
<     .AddAttribute ("Snr", "The SNR of the last packet received",
---
>     .AddAttribute ("Snr", "The snr of the last packet received",
diff ../../NS3-WiGig/src/wifi/model/snr-tag.h ../../ns-3-dev-git/src/wifi/model/snr-tag.h
45c45
<    * Create a SnrTag with the default SNR 0
---
>    * Create a SnrTag with the default snr 0
57c57
<    * \param snr the value of the SNR to set in linear scale
---
>    * \param snr the value of the snr to set
63c63
<    * \return the SNR value in linear scale
---
>    * \return the SNR value
69c69
<   double m_snr;  //!< SNR value in linear scale
---
>   double m_snr;  //!< SNR value
Only in ../../NS3-WiGig/src/wifi/model: spectrum-dmg-wifi-phy.cc
Only in ../../NS3-WiGig/src/wifi/model: spectrum-dmg-wifi-phy.h
diff ../../NS3-WiGig/src/wifi/model/spectrum-wifi-phy.cc ../../ns-3-dev-git/src/wifi/model/spectrum-wifi-phy.cc
35,36d34
< #include "wifi-ppdu.h"
< #include "wifi-psdu.h"
192a191,217
> SpectrumWifiPhy::AddOperationalChannel (uint8_t channelNumber)
> {
>   m_operationalChannelList.push_back (channelNumber);
> }
> 
> std::vector<uint8_t>
> SpectrumWifiPhy::GetOperationalChannelList () const
> {
>   std::vector<uint8_t> channelList;
>   channelList.push_back (GetChannelNumber ());  // first channel of list
>   for (std::vector<uint8_t>::size_type i = 0; i != m_operationalChannelList.size (); i++)
>     {
>       if (m_operationalChannelList[i] != GetChannelNumber ())
>         {
>           channelList.push_back (m_operationalChannelList[i]);
>         }
>     }
>   return channelList;
> }
> 
> void
> SpectrumWifiPhy::ClearOperationalChannelList ()
> {
>   m_operationalChannelList.clear ();
> }
> 
> void
220,227d244
< 
<   // Do no further processing if signal is too weak
<   // Current implementation assumes constant RX power over the PPDU duration
<   if (WToDbm (rxPowerW) < GetRxSensitivity ())
<     {
<       NS_LOG_INFO ("Received signal too weak to process: " << WToDbm (rxPowerW) << " dBm");
<       return;
<     }
244,245c261,262
<   Ptr<WifiPpdu> ppdu = Copy (wifiRxParams->ppdu);
<   StartReceivePreamble (ppdu, rxPowerW);
---
>   Ptr<Packet> packet = wifiRxParams->packet->Copy ();
>   StartReceivePreambleAndHeader (packet, rxPowerW, rxDuration);
316c333
< SpectrumWifiPhy::StartTx (Ptr<WifiPpdu> ppdu)
---
> SpectrumWifiPhy::StartTx (Ptr<Packet> packet, WifiTxVector txVector, Time txDuration)
318,322c335,336
<   NS_LOG_FUNCTION (this << ppdu);
<   WifiTxVector txVector = ppdu->GetTxVector ();
<   double txPowerDbm = GetTxPowerForTransmission (txVector) + GetTxGain ();
<   NS_LOG_DEBUG ("Start transmission: signal power before antenna gain=" << txPowerDbm << "dBm");
<   double txPowerWatts = DbmToW (txPowerDbm);
---
>   NS_LOG_DEBUG ("Start transmission: signal power before antenna gain=" << GetPowerDbm (txVector.GetTxPowerLevel ()) << "dBm");
>   double txPowerWatts = DbmToW (GetPowerDbm (txVector.GetTxPowerLevel ()) + GetTxGain ());
325c339
<   txParams->duration = ppdu->GetTxDuration ();
---
>   txParams->duration = txDuration;
330c344
<   txParams->ppdu = ppdu;
---
>   txParams->packet = packet;
336c350
< uint32_t
---
> double
339c353
<   uint32_t bandBandwidth = 0;
---
>   double bandBandwidth = 0;
378c392
<       //handle case of DSSS transmission
---
>       //handle case of use of legacy DSSS transmission
diff ../../NS3-WiGig/src/wifi/model/spectrum-wifi-phy.h ../../ns-3-dev-git/src/wifi/model/spectrum-wifi-phy.h
37d36
< class WifiPpdu;
63,66d61
<   // Implementation of pure virtual method.
<   void StartTx (Ptr<WifiPpdu> ppdu);
<   Ptr<Channel> GetChannel (void) const;
< 
72a68,86
>   /**
>    * Add a channel number to the list of operational channels.  This method
>    * is used to support scanning for strongest base station.
>    *
>    * \param channelNumber the channel number to add
>    */
>   void AddOperationalChannel (uint8_t channelNumber);
>   /**
>    * Return a list of channels to which it may be possible to roam
>    * By default, this method will return the current channel number followed
>    * by any other channel numbers that have been added.
>    *
>    * \return vector of channel numbers to which it may be possible to roam
>    */
>   std::vector<uint8_t> GetOperationalChannelList (void) const;
>   /**
>    * Clear the list of operational channels.
>    */
>   void ClearOperationalChannelList (void);
76c90
<    * and low-level PHY interface to this SpectrumWifiPhy instance.
---
>    * and low-level Phy interface to this SpectrumWifiPhy instance.
82a97,104
>    * \param packet the packet to send
>    * \param txVector the TXVECTOR that has tx parameters such as mode, the transmission mode to use to send
>    *        this packet, and txPowerLevel, a power level to use to send this packet. The real transmission
>    *        power is calculated as txPowerMin + txPowerLevel * (txPowerMax - txPowerMin) / nTxLevels
>    * \param txDuration duration of the transmission.
>    */
>   void StartTx (Ptr<Packet> packet, WifiTxVector txVector, Time txDuration);
>   /**
88c110
<    * \return the center frequency in MHz corresponding to the channel width to be used
---
>    * \return the center frequency corresponding to the channel width to be used
102,106c124,128
<    *                SpectrumSignalParameters (in case any objects downstream of the
<    *                SpectrumWifiPhy wish to adjust signal properties based on the
<    *                transmitted antenna model.  This antenna is also used when
<    *                the underlying WifiSpectrumPhyInterface::GetRxAntenna() method
<    *                is called.
---
>    * SpectrumSignalParameters (in case any objects downstream of the
>    * SpectrumWifiPhy wish to adjust signal properties based on the
>    * transmitted antenna model.  This antenna is also used when
>    * the underlying WifiSpectrumPhyInterface::GetRxAntenna() method
>    * is called.
109c131
<    * methods in the future if the modeling need for this arises
---
>    * methods in the future if the modelling need for this arises
119,121c141,143
<    * \return the SpectrumModel that this SpectrumPhy expects to be used
<    *         for all SpectrumValues that are passed to StartRx. If 0 is
<    *         returned, it means that any model will be accepted.
---
>    * \return returns the SpectrumModel that this SpectrumPhy expects to be used
>    * for all SpectrumValues that are passed to StartRx. If 0 is
>    * returned, it means that any model will be accepted.
128c150
<   uint32_t GetBandBandwidth (void) const;
---
>   double GetBandBandwidth (void) const;
144c166
<    * Callback invoked when the PHY model starts to process a signal
---
>    * Callback invoked when the Phy model starts to process a signal
152a175,176
>   Ptr<Channel> GetChannel (void) const;
> 
154a179
> 
155a181
> 
156a183
> 
157a185
> 
172c200
<    * \return Pointer to SpectrumValue
---
>    * \return Ptr to SpectrumValue
174c202
<    * This is a helper function to create the right TX PSD corresponding
---
>    * This is a helper function to create the right Tx PSD corresponding
184a213
>   std::vector<uint8_t> m_operationalChannelList; //!< List of possible channels
186,190c215,219
<   Ptr<WifiSpectrumPhyInterface> m_wifiSpectrumPhyInterface; //!< Spectrum PHY interface
<   Ptr<AntennaModel> m_antenna;                              //!< antenna model
<   mutable Ptr<const SpectrumModel> m_rxSpectrumModel;       //!< receive spectrum model
<   bool m_disableWifiReception;                              //!< forces this PHY to fail to sync on any signal
<   TracedCallback<bool, uint32_t, double, Time> m_signalCb;  //!< Signal callback
---
>   Ptr<WifiSpectrumPhyInterface> m_wifiSpectrumPhyInterface; //!< Spectrum phy interface
>   Ptr<AntennaModel> m_antenna; //!< antenna model
>   mutable Ptr<const SpectrumModel> m_rxSpectrumModel; //!< receive spectrum model
>   bool m_disableWifiReception;          //!< forces this Phy to fail to sync on any signal
>   TracedCallback<bool, uint32_t, double, Time> m_signalCb; //!< Signal callback
diff ../../NS3-WiGig/src/wifi/model/ssid.cc ../../ns-3-dev-git/src/wifi/model/ssid.cc
119a120,127
> /**
>  * Serialize SSID to the given ostream
>  *
>  * \param os
>  * \param ssid
>  *
>  * \return std::ostream
>  */
127,128c135,143
< std::istream &
< operator >> (std::istream &is, Ssid &ssid)
---
> /**
>  * Serialize from the given istream to this SSID.
>  *
>  * \param is
>  * \param ssid
>  *
>  * \return std::istream
>  */
> std::istream &operator >> (std::istream &is, Ssid &ssid)
diff ../../NS3-WiGig/src/wifi/model/ssid.h ../../ns-3-dev-git/src/wifi/model/ssid.h
38,40c38
<   /**
<    * Create SSID with broadcast SSID
<    */
---
>   // broadcast ssid
49,55d46
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
< 
79a71,100
>   /**
>    * Get the ElementID.
>    *
>    * \returns the element ID
>    */
>   WifiInformationElementId ElementId () const;
> 
>   /**
>    * Get the information field size.
>    *
>    * \returns the information field size
>    */
>   uint8_t GetInformationFieldSize () const;
> 
>   /**
>    * Get the information field size.
>    *
>    * \param start the information field iterator
>    */
>   void SerializeInformationField (Buffer::Iterator start) const;
> 
>   /**
>    * Get the information field size.
>    *
>    * \param start the information field iterator
>    * \param length the size of the information field
>    * \returns the size of the field read
>    */
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
86,93d106
< /**
<  * Serialize SSID to the given ostream
<  *
<  * \param os the output stream
<  * \param ssid the SSID
<  *
<  * \return std::ostream
<  */
95,102d107
< /**
<  * Serialize from the given istream to this SSID.
<  *
<  * \param is the input stream
<  * \param ssid the SSID
<  *
<  * \return std::istream
<  */
diff ../../NS3-WiGig/src/wifi/model/status-code.cc ../../ns-3-dev-git/src/wifi/model/status-code.cc
47,52d46
< StatusCodeValue
< StatusCode::GetStatusCodeValue (void) const
< {
<   return static_cast<StatusCodeValue> (m_code);
< }
< 
72a67,74
> /**
>  * Serialize StatusCode to the given ostream.
>  *
>  * \param os
>  * \param code
>  *
>  * \return std::ostream
>  */
diff ../../NS3-WiGig/src/wifi/model/status-code.h ../../ns-3-dev-git/src/wifi/model/status-code.h
28,40d27
< enum StatusCodeValue
< {
<   STATUS_CODE_SUCCESS = 0,
<   STATUS_CODE_FAILURE = 1,
<   STATUS_CODE_REJECTED_WITH_SUGGESTED_CHANGES = 39,
<   STATUS_CODE_REJECT_WITH_SCHEDULE = 83,
<   STATUS_CODE_PENDING_ADMITTING_FST_SESSION = 86,
<   STATUS_CODE_PERFORMING_FST_NOW = 87,
<   STATUS_CODE_PENDING_GAP_IN_BA_WINDOW = 88,
<   STATUS_CODE_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL = 99,
<   STATUS_CODE_DENIED_DUE_TO_SPECTRUM_MANAGEMENT = 103,
< };
< 
56,60d42
<   /**
<    * Set status code value.
<    * \param value The status code.
<    */
<   void SetStatusCodeValue (StatusCodeValue value);
69,74d50
<   /**
<    * Return the value of the status code.
<    *
<    * \return the value of the status code.
<    */
<   StatusCodeValue GetStatusCodeValue (void) const;
109,116d84
< /**
<  * Serialize StatusCode to the given ostream.
<  *
<  * \param os the output stream
<  * \param code the StatusCode
<  *
<  * \return std::ostream
<  */
diff ../../NS3-WiGig/src/wifi/model/sta-wifi-mac.cc ../../ns-3-dev-git/src/wifi/model/sta-wifi-mac.cc
31,33d30
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "he-configuration.h"
91d87
<     m_aid (0),
116,122d111
< uint16_t
< StaWifiMac::GetAssociationId (void) const
< {
<   NS_ASSERT_MSG (IsAssociated (), "This station is not associated to any AP");
<   return m_aid;
< }
< 
172c161
<   if (GetHtSupported ())
---
>   if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
174,175c163,164
<       probe.AddWifiInformationElement (GetExtendedCapabilities ());
<       probe.AddWifiInformationElement (GetHtCapabilities ());
---
>       probe.SetExtendedCapabilities (GetExtendedCapabilities ());
>       probe.SetHtCapabilities (GetHtCapabilities ());
177c166
<   if (GetVhtSupported ())
---
>   if (GetVhtSupported () || GetHeSupported ())
179c168
<       probe.AddWifiInformationElement (GetVhtCapabilities ());
---
>       probe.SetVhtCapabilities (GetVhtCapabilities ());
183c172
<       probe.AddWifiInformationElement (GetHeCapabilities ());
---
>       probe.SetHeCapabilities (GetHeCapabilities ());
213c202
<       if (GetHtSupported ())
---
>       if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
215,216c204,205
<           assoc.AddWifiInformationElement (GetExtendedCapabilities ());
<           assoc.AddWifiInformationElement (GetHtCapabilities ());
---
>           assoc.SetExtendedCapabilities (GetExtendedCapabilities ());
>           assoc.SetHtCapabilities (GetHtCapabilities ());
218c207
<       if (GetVhtSupported ())
---
>       if (GetVhtSupported () || GetHeSupported ())
220c209
<           assoc.AddWifiInformationElement (GetVhtCapabilities ());
---
>           assoc.SetVhtCapabilities (GetVhtCapabilities ());
224c213
<           assoc.AddWifiInformationElement (GetHeCapabilities ());
---
>           assoc.SetHeCapabilities (GetHeCapabilities ());
236c225
<       if (GetHtSupported ())
---
>       if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
238,239c227,228
<           reassoc.AddWifiInformationElement (GetExtendedCapabilities ());
<           reassoc.AddWifiInformationElement (GetHtCapabilities ());
---
>           reassoc.SetExtendedCapabilities (GetExtendedCapabilities ());
>           reassoc.SetHtCapabilities (GetHtCapabilities ());
241c230
<       if (GetVhtSupported ())
---
>       if (GetVhtSupported () || GetHeSupported ())
243c232
<           reassoc.AddWifiInformationElement (GetVhtCapabilities ());
---
>           reassoc.SetVhtCapabilities (GetVhtCapabilities ());
247c236
<           reassoc.AddWifiInformationElement (GetHeCapabilities ());
---
>           reassoc.SetHeCapabilities (GetHeCapabilities ());
313c302
<          association with a given SSID.
---
>          association with a given ssid.
434,448d422
< Ptr<MultiBandElement>
< StaWifiMac::GetMultiBandElement (void) const
< {
<   Ptr<MultiBandElement> multiband = Create<MultiBandElement> ();
<   multiband->SetStaRole (ROLE_NON_PCP_NON_AP);
<   multiband->SetStaMacAddressPresent (false); /* The same MAC address is used across all the bands */
<   multiband->SetBandID (Band_2_4GHz);
<   multiband->SetOperatingClass (18);          /* Europe */
<   multiband->SetChannelNumber (m_phy->GetChannelNumber ());
<   multiband->SetBssID (GetBssid ());
<   multiband->SetConnectionCapability (0);     /* Non-AP/Non-PCP */
<   multiband->SetFstSessionTimeout (m_fstTimeout);
<   return multiband;
< }
< 
450c424
< StaWifiMac::Enqueue (Ptr<Packet> packet, Mac48Address to)
---
> StaWifiMac::Enqueue (Ptr<const Packet> packet, Mac48Address to)
496c470
<   if (GetQosSupported ())
---
>   if (GetQosSupported () || GetHtSupported () || GetVhtSupported () || GetHeSupported ())
498c472
<       hdr.SetNoOrder (); // explicitly set to 0 for the time being since HT control field is not yet implemented (set it to 1 when implemented)
---
>       hdr.SetNoOrder (); // explicitly set to 0 for the time being since HT/VHT/HE control field is not yet implemented (set it to 1 when implemented)
520c494
< StaWifiMac::Receive (Ptr<WifiMacQueueItem> mpdu)
---
> StaWifiMac::Receive (Ptr<Packet> packet, const WifiMacHeader *hdr)
522,524c496
<   NS_LOG_FUNCTION (this << *mpdu);
<   const WifiMacHeader* hdr = &mpdu->GetHeader ();
<   Ptr<const Packet> packet = mpdu->GetPacket ();
---
>   NS_LOG_FUNCTION (this << packet << hdr);
567c539
<               DeaggregateAmsduAndForward (mpdu);
---
>               DeaggregateAmsduAndForward (packet, hdr);
593,594c565
<       Ptr<Packet> copy = packet->Copy ();
<       copy->RemoveHeader (beacon);
---
>       packet->RemoveHeader (beacon);
604,605c575,576
<       Ptr<CfParameterSet> cfParameterSet = StaticCast<CfParameterSet> (beacon.GetInformationElement (std::make_pair (IE_CF_PARAMETER_SET, 0)));
<       if (cfParameterSet && (cfParameterSet->GetCFPCount () == 0))
---
>       CfParameterSet cfParameterSet = beacon.GetCfParameterSet ();
>       if (cfParameterSet.GetCFPCount () == 0)
610c581
<               m_low->DoNavStartNow (MicroSeconds (cfParameterSet->GetCFPMaxDurationUs ()));
---
>               m_low->DoNavStartNow (MicroSeconds (cfParameterSet.GetCFPMaxDurationUs ()));
614c585
<               m_low->DoNavStartNow (MicroSeconds (cfParameterSet->GetCFPDurRemainingUs ()));
---
>               m_low->DoNavStartNow (MicroSeconds (cfParameterSet.GetCFPDurRemainingUs ()));
649c620
<           bool removed = copy->RemovePacketTag (snrTag);
---
>           bool removed = packet->RemovePacketTag (snrTag);
667,668c638
<           Ptr<Packet> copy = packet->Copy ();
<           copy->RemoveHeader (probeResp);
---
>           packet->RemoveHeader (probeResp);
675c645
<           bool removed = copy->RemovePacketTag (snrTag);
---
>           bool removed = packet->RemovePacketTag (snrTag);
692c662
<           packet->PeekHeader (assocResp);
---
>           packet->RemoveHeader (assocResp);
700d669
<               m_aid = assocResp.GetAssociationId ();
734c703
<   RegularWifiMac::Receive (Create<WifiMacQueueItem> (packet, *hdr));
---
>   RegularWifiMac::Receive (packet, hdr);
781,783c750,752
<       Ptr<ErpInformation> erpInformation = StaticCast<ErpInformation> (beacon.GetInformationElement (std::make_pair (IE_ERP_INFORMATION, 0)));
<       isShortPreambleEnabled &= !erpInformation->GetBarkerPreambleMode ();
<       if (erpInformation && (erpInformation->GetUseProtection () != 0))
---
>       ErpInformation erpInformation = beacon.GetErpInformation ();
>       isShortPreambleEnabled &= !erpInformation.GetBarkerPreambleMode ();
>       if (erpInformation.GetUseProtection () != 0)
805,806c774,775
<       Ptr<EdcaParameterSet> edcaParameters = StaticCast<EdcaParameterSet> (beacon.GetInformationElement (std::make_pair (IE_EDCA_PARAMETER_SET, 0)));
<       if (edcaParameters->IsQosSupported ())
---
>       EdcaParameterSet edcaParameters = beacon.GetEdcaParameterSet ();
>       if (edcaParameters.IsQosSupported ())
810,813c779,782
<           SetEdcaParameters (AC_BE, edcaParameters->GetBeCWmin (), edcaParameters->GetBeCWmax (), edcaParameters->GetBeAifsn (), 32 * MicroSeconds (edcaParameters->GetBeTxopLimit ()));
<           SetEdcaParameters (AC_BK, edcaParameters->GetBkCWmin (), edcaParameters->GetBkCWmax (), edcaParameters->GetBkAifsn (), 32 * MicroSeconds (edcaParameters->GetBkTxopLimit ()));
<           SetEdcaParameters (AC_VI, edcaParameters->GetViCWmin (), edcaParameters->GetViCWmax (), edcaParameters->GetViAifsn (), 32 * MicroSeconds (edcaParameters->GetViTxopLimit ()));
<           SetEdcaParameters (AC_VO, edcaParameters->GetVoCWmin (), edcaParameters->GetVoCWmax (), edcaParameters->GetVoAifsn (), 32 * MicroSeconds (edcaParameters->GetVoTxopLimit ()));
---
>           SetEdcaParameters (AC_BE, edcaParameters.GetBeCWmin (), edcaParameters.GetBeCWmax (), edcaParameters.GetBeAifsn (), 32 * MicroSeconds (edcaParameters.GetBeTxopLimit ()));
>           SetEdcaParameters (AC_BK, edcaParameters.GetBkCWmin (), edcaParameters.GetBkCWmax (), edcaParameters.GetBkAifsn (), 32 * MicroSeconds (edcaParameters.GetBkTxopLimit ()));
>           SetEdcaParameters (AC_VI, edcaParameters.GetViCWmin (), edcaParameters.GetViCWmax (), edcaParameters.GetViAifsn (), 32 * MicroSeconds (edcaParameters.GetViTxopLimit ()));
>           SetEdcaParameters (AC_VO, edcaParameters.GetVoCWmin (), edcaParameters.GetVoCWmax (), edcaParameters.GetVoAifsn (), 32 * MicroSeconds (edcaParameters.GetVoTxopLimit ()));
819,820c788,789
<       Ptr<HtCapabilities> htCapabilities = StaticCast<HtCapabilities> (beacon.GetInformationElement (std::make_pair (IE_HT_CAPABILITIES, 0)));
<       if (!htCapabilities->IsSupportedMcs (0))
---
>       HtCapabilities htCapabilities = beacon.GetHtCapabilities ();
>       if (!htCapabilities.IsSupportedMcs (0))
827,828c796,797
<           Ptr<HtOperation> htOperation = StaticCast<HtOperation> (beacon.GetInformationElement (std::make_pair (IE_HT_OPERATION, 0)));
<           if (htOperation->GetNonGfHtStasPresent ())
---
>           HtOperation htOperation = beacon.GetHtOperation ();
>           if (htOperation.GetNonGfHtStasPresent ())
836c805
<           if (!GetVhtSupported () && GetHtConfiguration ()->GetRifsSupported () && htOperation->GetRifsMode ())
---
>           if (!GetVhtSupported () && GetRifsSupported () && htOperation.GetRifsMode ())
848c817
<       Ptr<VhtCapabilities> vhtCapabilities = StaticCast<VhtCapabilities> (beacon.GetInformationElement (std::make_pair (IE_VHT_CAPABILITIES, 0)));
---
>       VhtCapabilities vhtCapabilities = beacon.GetVhtCapabilities ();
850c819
<       if (vhtCapabilities->GetRxHighestSupportedLgiDataRate () > 0)
---
>       if (vhtCapabilities.GetRxHighestSupportedLgiDataRate () > 0)
853c822
<           Ptr<VhtOperation> vhtOperation = StaticCast<VhtOperation> (beacon.GetInformationElement (std::make_pair (IE_VHT_OPERATION, 0)));
---
>           VhtOperation vhtOperation = beacon.GetVhtOperation ();
857c826
<               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedRxMcs (mcs.GetMcsValue ()))
---
>               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities.IsSupportedRxMcs (mcs.GetMcsValue ()))
864c833
<   if (GetHtSupported ())
---
>   if (GetHtSupported () || GetVhtSupported ())
866c835
<       Ptr<ExtendedCapabilities> extendedCapabilities = StaticCast<ExtendedCapabilities> (beacon.GetInformationElement (std::make_pair (IE_EXTENDED_CAPABILITIES, 0)));
---
>       ExtendedCapabilities extendedCapabilities = beacon.GetExtendedCapabilities ();
871,872c840,844
<       Ptr<HeCapabilities> heCapabilities = StaticCast<HeCapabilities> (beacon.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<       if (heCapabilities->GetSupportedMcsAndNss () != 0)
---
>       HeCapabilities heCapabilities = beacon.GetHeCapabilities ();
>       //todo: once we support non constant rate managers, we should add checks here whether HE is supported by the peer
>       m_stationManager->AddStationHeCapabilities (apAddr, heCapabilities);
>       HeOperation heOperation = beacon.GetHeOperation ();
>       for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
874,876c846,847
<           m_stationManager->AddStationHeCapabilities (apAddr, heCapabilities);
<           Ptr<HeOperation> htCapabilities = StaticCast<HeOperation> (beacon.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_OPERATION)));
<           for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
---
>           WifiMode mcs = m_phy->GetMcs (i);
>           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities.IsSupportedRxMcs (mcs.GetMcsValue ()))
878,882c849
<               WifiMode mcs = m_phy->GetMcs (i);
<               if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities->IsSupportedRxMcs (mcs.GetMcsValue ()))
<                 {
<                   m_stationManager->AddSupportedMcs (apAddr, mcs);
<                 }
---
>               m_stationManager->AddSupportedMcs (apAddr, mcs);
939,940c906,907
<           Ptr<ErpInformation> erpInformation = StaticCast<ErpInformation> (probeResp.GetInformationElement (std::make_pair (IE_ERP_INFORMATION, 0)));
<           isShortPreambleEnabled &= !erpInformation->GetBarkerPreambleMode ();
---
>           ErpInformation erpInformation = probeResp.GetErpInformation ();
>           isShortPreambleEnabled &= !erpInformation.GetBarkerPreambleMode ();
986,987c953,954
<           Ptr<ErpInformation> erpInformation = StaticCast<ErpInformation> (assocResp.GetInformationElement (std::make_pair (IE_ERP_INFORMATION, 0)));
<           isShortPreambleEnabled &= !erpInformation->GetBarkerPreambleMode ();
---
>           ErpInformation erpInformation = assocResp.GetErpInformation ();
>           isShortPreambleEnabled &= !erpInformation.GetBarkerPreambleMode ();
1006,1007c973,974
<       Ptr<EdcaParameterSet> edcaParameters = StaticCast<EdcaParameterSet> (assocResp.GetInformationElement (std::make_pair (IE_EDCA_PARAMETER_SET, 0)));
<       if (edcaParameters->IsQosSupported ())
---
>       EdcaParameterSet edcaParameters = assocResp.GetEdcaParameterSet ();
>       if (edcaParameters.IsQosSupported ())
1011,1014c978,981
<           SetEdcaParameters (AC_BE, edcaParameters->GetBeCWmin (), edcaParameters->GetBeCWmax (), edcaParameters->GetBeAifsn (), 32 * MicroSeconds (edcaParameters->GetBeTxopLimit ()));
<           SetEdcaParameters (AC_BK, edcaParameters->GetBkCWmin (), edcaParameters->GetBkCWmax (), edcaParameters->GetBkAifsn (), 32 * MicroSeconds (edcaParameters->GetBkTxopLimit ()));
<           SetEdcaParameters (AC_VI, edcaParameters->GetViCWmin (), edcaParameters->GetViCWmax (), edcaParameters->GetViAifsn (), 32 * MicroSeconds (edcaParameters->GetViTxopLimit ()));
<           SetEdcaParameters (AC_VO, edcaParameters->GetVoCWmin (), edcaParameters->GetVoCWmax (), edcaParameters->GetVoAifsn (), 32 * MicroSeconds (edcaParameters->GetVoTxopLimit ()));
---
>           SetEdcaParameters (AC_BE, edcaParameters.GetBeCWmin (), edcaParameters.GetBeCWmax (), edcaParameters.GetBeAifsn (), 32 * MicroSeconds (edcaParameters.GetBeTxopLimit ()));
>           SetEdcaParameters (AC_BK, edcaParameters.GetBkCWmin (), edcaParameters.GetBkCWmax (), edcaParameters.GetBkAifsn (), 32 * MicroSeconds (edcaParameters.GetBkTxopLimit ()));
>           SetEdcaParameters (AC_VI, edcaParameters.GetViCWmin (), edcaParameters.GetViCWmax (), edcaParameters.GetViAifsn (), 32 * MicroSeconds (edcaParameters.GetViTxopLimit ()));
>           SetEdcaParameters (AC_VO, edcaParameters.GetVoCWmin (), edcaParameters.GetVoCWmax (), edcaParameters.GetVoAifsn (), 32 * MicroSeconds (edcaParameters.GetVoTxopLimit ()));
1020,1021c987,988
<       Ptr<HtCapabilities> htCapabilities = StaticCast<HtCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_HT_CAPABILITIES, 0)));
<       if (!htCapabilities->IsSupportedMcs (0))
---
>       HtCapabilities htCapabilities = assocResp.GetHtCapabilities ();
>       if (!htCapabilities.IsSupportedMcs (0))
1028,1029c995,996
<           Ptr<HtOperation> htOperation = StaticCast<HtOperation> (assocResp.GetInformationElement (std::make_pair (IE_HT_OPERATION, 0)));
<           if (htOperation->GetNonGfHtStasPresent ())
---
>           HtOperation htOperation = assocResp.GetHtOperation ();
>           if (htOperation.GetNonGfHtStasPresent ())
1037c1004
<           if (!GetVhtSupported () && GetHtConfiguration ()->GetRifsSupported () && htOperation->GetRifsMode ())
---
>           if (!GetVhtSupported () && GetRifsSupported () && htOperation.GetRifsMode ())
1049,1050c1016,1018
<       Ptr<VhtCapabilities> vhtCapabilities = StaticCast<VhtCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_VHT_CAPABILITIES, 0)));      //we will always fill in RxHighestSupportedLgiDataRate field at TX, so this can be used to check whether it supports VHT
<       if (vhtCapabilities->GetRxHighestSupportedLgiDataRate () > 0)
---
>       VhtCapabilities vhtCapabilities = assocResp.GetVhtCapabilities ();
>       //we will always fill in RxHighestSupportedLgiDataRate field at TX, so this can be used to check whether it supports VHT
>       if (vhtCapabilities.GetRxHighestSupportedLgiDataRate () > 0)
1053c1021
<           Ptr<VhtOperation> vhtOperation = StaticCast<VhtOperation> (assocResp.GetInformationElement (std::make_pair (IE_VHT_OPERATION, 0)));
---
>           VhtOperation vhtOperation = assocResp.GetVhtOperation ();
1058,1064c1026,1029
<       Ptr<HeCapabilities> heCapabilities = StaticCast<HeCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
<       if (heCapabilities->GetSupportedMcsAndNss () != 0)
<         {
<           m_stationManager->AddStationHeCapabilities (apAddr, heCapabilities);
<           Ptr<HeOperation> heOperation = StaticCast<HeOperation> (assocResp.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_OPERATION)));
<           GetHeConfiguration ()->SetAttribute ("BssColor", UintegerValue (heOperation->GetBssColor ()));
<         }
---
>       HeCapabilities hecapabilities = assocResp.GetHeCapabilities ();
>       //todo: once we support non constant rate managers, we should add checks here whether HE is supported by the peer
>       m_stationManager->AddStationHeCapabilities (apAddr, hecapabilities);
>       HeOperation heOperation = assocResp.GetHeOperation ();
1080c1045
<       Ptr<HtCapabilities> htCapabilities = StaticCast<HtCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_HT_CAPABILITIES,0)));
---
>       HtCapabilities htCapabilities = assocResp.GetHtCapabilities ();
1084c1049
<           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HT && htCapabilities->IsSupportedMcs (mcs.GetMcsValue ()))
---
>           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HT && htCapabilities.IsSupportedMcs (mcs.GetMcsValue ()))
1093c1058,1059
<       Ptr<VhtCapabilities> vhtCapabilities = StaticCast<VhtCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_VHT_CAPABILITIES,0)));      for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
---
>       VhtCapabilities vhtcapabilities = assocResp.GetVhtCapabilities ();
>       for (uint8_t i = 0; i < m_phy->GetNMcs (); i++)
1096c1062
<           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedRxMcs (mcs.GetMcsValue ()))
---
>           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtcapabilities.IsSupportedRxMcs (mcs.GetMcsValue ()))
1103c1069
<   if (GetHtSupported ())
---
>   if (GetHtSupported () || GetVhtSupported ())
1105c1071
<       Ptr<ExtendedCapabilities> extendedCapabilities = StaticCast<ExtendedCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_EXTENDED_CAPABILITIES, 0)));
---
>       ExtendedCapabilities extendedCapabilities = assocResp.GetExtendedCapabilities ();
1110c1076
<       Ptr<HeCapabilities> heCapabilities = StaticCast<HeCapabilities> (assocResp.GetInformationElement (std::make_pair (IE_EXTENSION, IE_EXT_HE_CAPABILITIES)));
---
>       HeCapabilities heCapabilities = assocResp.GetHeCapabilities ();
1114c1080
<           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities->IsSupportedRxMcs (mcs.GetMcsValue ()))
---
>           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HE && heCapabilities.IsSupportedRxMcs (mcs.GetMcsValue ()))
1134c1100
<   if (GetHtSupported ())
---
>   if (GetHtSupported () || GetVhtSupported () || GetHeSupported ())
1148c1114
<   capabilities.SetShortPreamble (m_phy->GetShortPhyPreambleSupported () || GetErpSupported ());
---
>   capabilities.SetShortPreamble (m_phy->GetShortPlcpPreambleSupported () || GetErpSupported ());
diff ../../NS3-WiGig/src/wifi/model/sta-wifi-mac.h ../../ns-3-dev-git/src/wifi/model/sta-wifi-mac.h
29,32d28
< class TwoLevelAggregationTest;
< class AmpduAggregationTest;
< class HeAggregationTest;
< 
48c44
<   double m_snr;                       ///< SNR in linear scale
---
>   double m_snr;                       ///< SNR
109,114d104
<   /// Allow test cases to access private members
<   friend class ::TwoLevelAggregationTest;
<   /// Allow test cases to access private members
<   friend class ::AmpduAggregationTest;
<   /// Allow test cases to access private members
<   friend class ::HeAggregationTest;
135c125
<    * The packet should be enqueued in a TX queue, and should be
---
>    * The packet should be enqueued in a tx queue, and should be
139c129
<   void Enqueue (Ptr<Packet> packet, Mac48Address to);
---
>   void Enqueue (Ptr<const Packet> packet, Mac48Address to);
146,161d135
<   /**
<    * Return whether we are associated with an AP.
<    *
<    * \return true if we are associated with an AP, false otherwise
<    */
<   bool IsAssociated (void) const;
< 
<   /**
<    * Return the association ID.
<    *
<    * \return the association ID
<    */
<   uint16_t GetAssociationId (void) const;
< 
< protected:
<   Ptr<MultiBandElement> GetMultiBandElement (void) const;
193c167,168
<    * \param mpdu the received MPDU
---
>    * \param packet the received packet
>    * \param hdr the MAC header of the received packet
195c170
<   void Receive (Ptr<WifiMacQueueItem> mpdu);
---
>   void Receive (Ptr<Packet> packet, const WifiMacHeader *hdr);
268a244,249
>    * Return whether we are associated with an AP.
>    *
>    * \return true if we are associated with an AP, false otherwise
>    */
>   bool IsAssociated (void) const;
>   /**
322d302
<   uint16_t m_aid;              ///< Association AID
325c305
<   Time m_assocRequestTimeout;  ///< association request timeout
---
>   Time m_assocRequestTimeout;  ///< assoc request timeout
328c308
<   EventId m_assocRequestEvent; ///< association request event
---
>   EventId m_assocRequestEvent; ///< assoc request event
333c313
<   std::vector<ApInfo> m_candidateAps; ///< list of candidate APs to associate to
---
>   std::vector<ApInfo> m_candidateAps; ///< list of candidate APs to associate
339,340c319,320
<   TracedCallback<Mac48Address> m_assocLogger;   ///< association logger
<   TracedCallback<Mac48Address> m_deAssocLogger; ///< disassociation logger
---
>   TracedCallback<Mac48Address> m_assocLogger;   ///< assoc logger
>   TracedCallback<Mac48Address> m_deAssocLogger; ///< deassoc logger
diff ../../NS3-WiGig/src/wifi/model/supported-rates.cc ../../ns-3-dev-git/src/wifi/model/supported-rates.cc
296a297,304
> /**
>  * Serialize SupportedRates to the given ostream.
>  *
>  * \param os
>  * \param rates
>  *
>  * \return std::ostream
>  */
diff ../../NS3-WiGig/src/wifi/model/supported-rates.h ../../ns-3-dev-git/src/wifi/model/supported-rates.h
50c50
<    * \param rates the extended supported rates
---
>    * \param rates
54c54,64
<   // Implementations of pure virtual methods of WifiInformationElement
---
>   /**
>    * Set supported rates.
>    *
>    * \param rates the supported rates
>    */
>   void SetSupportedRates (SupportedRates *rates);
> 
>   /**
>    * Get element ID.
>    * \returns the wifi information element ID
>    */
55a66,69
>   /**
>    * Get information field size.
>    * \returns the information field size
>    */
56a71,75
>   /**
>    * Serialize information field.
>    *
>    * \param start the iterator
>    */
57a77,83
>   /**
>    * Deserialize information field.
>    *
>    * \param start the iterator
>    * \param length the field length (bytes)
>    * \returns length of the information field deserialized (bytes)
>    */
60,65d85
<   /* This information element is a bit special in that it is only
<     included if there are more than 8 rates. To support this we
<     override the Serialize and GetSerializedSize methods of
<     WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
68c88,91
<    * Set supported rates.
---
>    * This information element is a bit special in that it is only
>    * included if there are more than 8 rates. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
70c93,95
<    * \param rates the supported rates
---
>    * \param start
>    *
>    * \return an iterator
72c97,105
<   void SetSupportedRates (SupportedRates *rates);
---
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this supported rates
>    * information element.
>    *
>    * \return the serialized size of this supported rates
>    *         information element
>    */
>   uint16_t GetSerializedSize () const;
102,109d134
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start,
<                                        uint8_t length);
< 
118,123c143,148
<   /**
<    * This defines the maximum number of supported rates that a STA is
<    * allowed to have. Currently this number is set for IEEE 802.11b/g and SISO IEEE 802.11n
<    * stations which need 2 rates each from Clauses 15 and 18, and then 8
<    * from Clause 19.
<    */
---
> /**
>  * This defines the maximum number of supported rates that a STA is
>  * allowed to have. Currently this number is set for IEEE 802.11b/g and SISO IEE 802.11n
>  * stations which need 2 rates each from Clauses 15 and 18, and then 8
>  * from Clause 19.
>  */
129c154
<    * \param bs the rate to be added in bps
---
>    * \param bs the rate to be added
135c160
<    * \param bs the rate to be set in bps
---
>    * \param bs the rate to be set
150c175
<    * \param bs the rate to be checked in bps
---
>    * \param bs the rate to be checked
160c185
<    * \param bs the rate to be checked in bps
---
>    * \param bs the rate to be checked
170c195
<    * \param bs the rate to be checked in bps
---
>    * \param bs the rate to be checked
186c211
<    * \return the rate in bps
---
>    * \return the rate
188a214,240
>   /**
>    * Get the ElementID.
>    *
>    * \returns the element ID
>    */
>   WifiInformationElementId ElementId () const;
>   /**
>    * Get the information field size.
>    *
>    * \returns the information field size
>    */
>   uint8_t GetInformationFieldSize () const;
>   /**
>    * Get the information field size.
>    *
>    * \param start the information field iterator
>    */
>   void SerializeInformationField (Buffer::Iterator start) const;
>   /**
>    * Get the information field size.
>    *
>    * \param start the information field iterator
>    * \param length the size of the information field (bytes)
>    * \returns the size of the field read (bytes)
>    */
>   uint8_t DeserializeInformationField (Buffer::Iterator start,
>                                        uint8_t length);
203c255
<   uint8_t m_rates[MAX_SUPPORTED_RATES];  //!< List of supported bit rates (divided by 500000)
---
>   uint8_t m_rates[MAX_SUPPORTED_RATES];  //!< List of supported bitrate (divided by 500000)
206,213d257
< /**
<  * Serialize SupportedRates to the given ostream.
<  *
<  * \param os output stream
<  * \param rates the SupportedRates
<  *
<  * \return std::ostream
<  */
Only in ../../NS3-WiGig/src/wifi/model: threshold-preamble-detection-model.cc
Only in ../../NS3-WiGig/src/wifi/model: threshold-preamble-detection-model.h
diff ../../NS3-WiGig/src/wifi/model/txop.cc ../../ns-3-dev-git/src/wifi/model/txop.cc
25d24
< #include "ns3/socket.h"
32,40d30
< #include "wifi-mac-trailer.h"
< 
< #include "ns3/ipv4-header.h"
< #include "ns3/llc-snap-header.h"
< #include <iostream>
< #include <fstream>
< 
< using namespace ns3;
< using namespace std;
82,89d71
<     .AddTraceSource ("BackoffTrace",
<                      "Trace source for backoff values",
<                      MakeTraceSourceAccessor (&Txop::m_backoffTrace),
<                      "ns3::TracedCallback::Uint32Callback")
<     .AddTraceSource ("CwTrace",
<                      "Trace source for contention window values",
<                      MakeTraceSourceAccessor (&Txop::m_cwTrace),
<                      "ns3::TracedValueCallback::Uint32")
99d80
<     m_backoff (0),
103,111c84
<     //// WIGIG ////
<     m_txopLimit (Seconds (0.0)),
<     //// WIGIG ////
<     m_currentPacket (0),
<     //// WIGIG ////
<     m_allocationType (CBAP_ALLOCATION),
<     m_allocationStart (Seconds (0)),
<     m_allocationDuration (Seconds (0))
<     //// WIGIG ////
---
>     m_currentPacket (0)
164c137
< Txop::SetTxOkCallback (TxPacketOk callback)
---
> Txop::SetTxOkCallback (TxOk callback)
171,177d143
< Txop::SetTxOkNoAckCallback (TxOk callback)
< {
<   NS_LOG_FUNCTION (this << &callback);
<   m_txOkNoAckCallback = callback;
< }
< 
< void
217d182
<       m_cwTrace = GetCw ();
230d194
<       m_cwTrace = GetCw ();
305d268
< 
332,340d294
< bool
< Txop::HasFramesToTransmit (void)
< {
<   bool ret = (m_currentPacket != 0 || !m_queue->IsEmpty ());
<   NS_LOG_FUNCTION (this << ret);
<   return ret;
< }
< 
< //// WIGIG ////
342,398c296
< Txop::ResetState (void)
< {
<   NS_LOG_FUNCTION (this);
<   ResetCw ();
<   m_cwTrace = GetCw ();
<   GenerateBackoff ();
< }
< 
< void
< Txop::SetAllocationType (AllocationType allocationType)
< {
<   NS_LOG_FUNCTION (this << +allocationType);
<   m_allocationType = allocationType;
< }
< 
< Time
< Txop::GetAllocationRemaining (void) const
< {
<   Time remainingAllocation = m_allocationDuration;
<   remainingAllocation -= (Simulator::Now () - m_allocationStart);
<   if (remainingAllocation.IsStrictlyNegative ())
<     {
<       remainingAllocation = Seconds (0);
<     }
<   NS_LOG_FUNCTION (this << remainingAllocation);
<   return remainingAllocation;
< }
< 
< Time
< Txop::GetRemainingTimeForTransmission (void)
< {
<   Time remainingTime = Seconds (0);
<   if (m_stationManager->IsWiGigSupported ())
<     {
<       if (GetTxopLimit ().IsStrictlyPositive () && GetAllocationRemaining () >= GetTxopRemaining ())
<         {
<           /* The remaining allocation duration should always be larger than the Txop remaining*/
<           remainingTime = GetTxopRemaining ();
<         }
<       else if (GetTxopLimit ().IsZero ())
<         {
<           /* Our limitation here is the remaining duration in the current allocation period. */
<           remainingTime = GetAllocationRemaining ();
<         }
<     }
<   else if (GetTxopLimit ().IsStrictlyPositive ())
<     {
<       /* We only have Txop limitation */
<       remainingTime = GetTxopRemaining ();
<     }
<   return remainingTime;
< }
< 
< //// WIGIG ////
< 
< void
< Txop::Queue (Ptr<Packet> packet, const WifiMacHeader &hdr)
---
> Txop::Queue (Ptr<const Packet> packet, const WifiMacHeader &hdr)
401,407c299
<   // remove the priority tag attached, if any
<   SocketPriorityTag priorityTag;
<   packet->RemovePacketTag (priorityTag);
<   if (m_channelAccessManager->NeedBackoffUponAccess (this))
<     {
<       GenerateBackoff ();
<     }
---
>   m_stationManager->PrepareForQueue (hdr.GetAddr1 (), &hdr, packet);
427,428c319
<       && !m_low->IsCfPeriod ()
<       && m_channelAccessManager->IsAccessAllowed ())
---
>       && !m_low->IsCfPeriod ())
441,442c332
<       && !m_low->IsCfPeriod ()
<       && m_channelAccessManager->IsAccessAllowed ())
---
>       && !m_low->IsCfPeriod ())
448,505d337
< //// WIGIG ////
< void
< Txop::StartAllocationPeriod (AllocationType allocationType, AllocationID allocationID,
<                              Mac48Address peerStation, Time allocationDuration)
< {
<   NS_LOG_FUNCTION (this << allocationType << +allocationID << peerStation << allocationDuration);
<   m_allocationType = allocationType;
<   m_allocationID = allocationID;
<   m_peerStation = peerStation;
<   m_allocationDuration = allocationDuration;
<   m_allocationStart = Simulator::Now ();
<   ResetState ();
< 
<   /* Check if we have stored packet for this allocation period */
<   StoredPacketsCI it = m_storedPackets.find (m_allocationID);
<   if (it != m_storedPackets.end ())
<     {
<       PacketInformation info = it->second;
<       m_currentPacket = info.first;
<       m_currentHdr = info.second;
<     }
< 
<   StartAccessIfNeeded ();
< }
< 
< void
< Txop::ResumeTxopTransmission (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_ASSERT_MSG (m_allocationType == CBAP_ALLOCATION, "Allocation type must be CBAP.");
<   ResetState ();
<   RestartAccessIfNeeded ();
< }
< 
< void
< Txop::EndAllocationPeriod (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_accessAllowed = false;
<   /* Store parameters related to this Allocation period which include MSDU/A-MSDU */
<   if (m_currentPacket != 0)
<     {
<       NS_LOG_DEBUG ("Store packet with seq=0x" << std::hex << m_currentHdr.GetSequenceControl ()
<                     << " for AllocationID=" << +m_allocationID);
<       m_storedPackets[m_allocationID] = std::make_pair (m_currentPacket, m_currentHdr);
<       m_currentPacket = 0;
<     }
<   else
<     {
<       StoredPacketsI it = m_storedPackets.find (m_allocationID);
<       if (it != m_storedPackets.end ())
<         {
<           m_storedPackets.erase (it);
<         }
<     }
< }
< //// WIGIG ////
< 
517,518c349
<   m_cwTrace = GetCw ();
<   GenerateBackoff ();
---
>   StartBackoffNow (m_rng->GetInteger (0, GetCw ()));
582,602d412
< //// WIGIG ////
< 
< Time
< Txop::GetPpduDurationLimit (Ptr<const WifiMacQueueItem> item, const MacLowTransmissionParameters &params)
< {
<   Time ppduDurationLimit = Time::Min ();
<   if (m_stationManager->IsWiGigSupported ())
<     {
<       ppduDurationLimit = GetAllocationRemaining () - m_low->CalculateOverheadTxTime (item, params);
<     }
<   return ppduDurationLimit;
< }
< 
< bool
< Txop::IsEdmgSupported (void) const
< {
<   NS_LOG_FUNCTION (this);
<   return m_stationManager->HasEdmgSupported ();
< }
< //// WIGIG ////
< 
643,657d452
<   //// WIGIG ////
<   if (m_stationManager->HasDmgSupported () || m_stationManager->HasEdmgSupported ())
<     {
<       if (GetAllocationRemaining ().IsZero ())
<         {
<           NS_LOG_DEBUG ("No more time in the current CBAP Allocation");
<           return;
<         }
<       if (m_low->Is_Performing_SLS ())
<         {
<           NS_LOG_DEBUG ("Performing SLS, abort frames transmission.");
<           return;
<         }
<     }
<   //// WIGIG ////
681c476
<   if (m_currentHdr.GetAddr1 ().IsGroup () || m_currentHdr.IsActionNoAck ())
---
>   if (m_currentHdr.GetAddr1 ().IsGroup ())
687,688c482
<       GetLow ()->StartTransmission (Create<WifiMacQueueItem> (m_currentPacket, m_currentHdr),
<                                     m_currentParams, this);
---
>       GetLow ()->StartTransmission (m_currentPacket, &m_currentHdr, m_currentParams, this);
695d488
<           m_currentParams.DisableRts ();
708,709c501
<           GetLow ()->StartTransmission (Create<WifiMacQueueItem> (fragment, hdr),
<                                         m_currentParams, this);
---
>           GetLow ()->StartTransmission (fragment, &hdr, m_currentParams, this);
713,721d504
<           uint32_t size = m_currentHdr.GetSize () + m_currentPacket->GetSize () + WIFI_MAC_FCS_LENGTH;
<           if (m_stationManager->NeedRts (m_currentHdr, size) && !m_low->IsCfPeriod ())
<             {
<               m_currentParams.EnableRts ();
<             }
<           else
<             {
<               m_currentParams.DisableRts ();
<             }
723,724c506
<           GetLow ()->StartTransmission (Create<WifiMacQueueItem> (m_currentPacket, m_currentHdr),
<                                         m_currentParams, this);
---
>           GetLow ()->StartTransmission (m_currentPacket, &m_currentHdr, m_currentParams, this);
730c512
< Txop::GenerateBackoff (void)
---
> Txop::NotifyInternalCollision (void)
733,736c515
<   m_backoff = m_rng->GetInteger (0, GetCw ());
<   // std::cout << m_backoff <<"\n";
<   m_backoffTrace (m_backoff);
<   StartBackoffNow (m_backoff);
---
>   NotifyCollision ();
740c519
< Txop::NotifyInternalCollision (void)
---
> Txop::NotifyCollision (void)
743c522
<   GenerateBackoff ();
---
>   StartBackoffNow (m_rng->GetInteger (0, GetCw ()));
801c580
<       //to reset the Txop.
---
>       //to reset the dcf.
804d582
<       m_cwTrace = GetCw ();
809d586
<       m_cwTrace = GetCw ();
811c588
<   GenerateBackoff ();
---
>   StartBackoffNow (m_rng->GetInteger (0, GetCw ()));
825c602
<           m_txOkCallback (m_currentPacket, m_currentHdr);
---
>           m_txOkCallback (m_currentHdr);
833,834c610
<       m_cwTrace = GetCw ();
<       GenerateBackoff ();
---
>       StartBackoffNow (m_rng->GetInteger (0, GetCw ()));
857c633
<       //to reset the Txop.
---
>       //to reset the dcf.
860d635
<       m_cwTrace = GetCw ();
865,866d639
<       m_stationManager->ReportDataFailed (m_currentHdr.GetAddr1 (), &m_currentHdr,
<                                           m_currentPacket->GetSize ());
869d641
<       m_cwTrace = GetCw ();
871c643
<   GenerateBackoff ();
---
>   StartBackoffNow (m_rng->GetInteger (0, GetCw ()));
926,928d697
<   //// WIGIG ////
<   m_currentParams.DisableOverrideDurationId ();
<   //// WIGIG ////
937c706
<   GetLow ()->StartTransmission (Create<WifiMacQueueItem> (fragment, hdr), m_currentParams, this);
---
>   GetLow ()->StartTransmission (fragment, &hdr, m_currentParams, this);
954,956c723,724
<   m_cwTrace = GetCw ();
<   GenerateBackoff ();
<   if (!m_txOkNoAckCallback.IsNull ())
---
>   StartBackoffNow (m_rng->GetInteger (0, GetCw ()));
>   if (!m_txOkCallback.IsNull ())
958c726
<       m_txOkNoAckCallback (m_currentHdr);
---
>       m_txOkCallback (m_currentHdr);
1054c822
< Txop::GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, double dataSnr, WifiTxVector dataTxVector)
---
> Txop::GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, WifiMode txMode, double dataSnr)
1066c834
< Txop::ServingSLS (void) const
---
> Txop::HasTxop (void) const
1069,1081d836
< }
< 
< Time
< Txop::GetTxopRemaining (void) const
< {
<   NS_LOG_WARN ("GetTxopRemaining should not be called for non QoS!");
<   return Seconds (0);
< }
< 
< void
< Txop::TerminateTxop (void)
< {
<   NS_LOG_WARN ("TerminateTxop should not be called for non QoS!");
diff ../../NS3-WiGig/src/wifi/model/txop.h ../../ns-3-dev-git/src/wifi/model/txop.h
24d23
< #include "ns3/traced-value.h"
27d25
< #include "wigig-data-types.h"
41d38
< class WifiTxVector;
61c58
<  * it has been retransmitted up until the SSRC or SLRC thresholds.
---
>  * it has been retransmitted up until the ssrc or slrc thresholds.
63,64c60,61
<  * The RTS/CTS policy is similar to the fragmentation policy: when
<  * a packet is bigger than a threshold, the RTS/CTS protocol is used.
---
>  * The rts/cts policy is similar to the fragmentation policy: when
>  * a packet is bigger than a threshold, the rts/cts protocol is used.
69a67,68
>   /// allow DcfListener class access
>   friend class DcfListener;
77,82d75
<    * typedef for a callback to invoke when a
<    * packet transmission was completed successfully.
<    */
<   typedef Callback <void, Ptr<const Packet>, const WifiMacHeader&> TxPacketOk;
< 
<   /**
114c107
<    * \param low MacLow to associate.
---
>    * \param low MacLow.
120c113
<    * \param manager ChannelAccessManager to associate.
---
>    * \param manager ChannelAccessManager.
126c119
<    * \param remoteManager WifiRemoteStationManager to associate.
---
>    * \param remoteManager WifiRemoteStationManager.
132c125
<    * \param txMiddle MacTxMiddle to associate.
---
>    * \param txMiddle MacTxMiddle.
140c133
<   void SetTxOkCallback (TxPacketOk callback);
---
>   void SetTxOkCallback (TxOk callback);
143,148c136
<    * transmission without ACK was completed successfully.
<    */
<   void SetTxOkNoAckCallback (TxOk callback) ;
<   /**
<    * \param callback the callback to invoke when a
<    *        packet transmission was completed unsuccessfully.
---
>    * packet transmission was completed unsuccessfully.
153c141
<    *        packet is dropped.
---
>    * packet is dropped.
160c148
<    * \return the associated MacLow
---
>    * \return MacLow
167c155
<    * \return the associated WifiMacQueue
---
>    * \return WifiMacQueue
193c181
<    *        Value zero corresponds to default Txop.
---
>    * Value zero corresponds to default DCF.
220,223d207
<   /**
<    * Reset state of the current EDCA.
<    */
<   void ResetState (void);
255c239
<   virtual void Queue (Ptr<Packet> packet, const WifiMacHeader &hdr);
---
>   virtual void Queue (Ptr<const Packet> packet, const WifiMacHeader &hdr);
258c242
<    * Sends CF frame to STA with address <i>addr</i>.
---
>    * Sends CF frame to sta with address <i>addr</i>.
271c255
<    * Event handler when an Ack is received.
---
>    * Event handler when an ACK is received.
275c259
<    * Event handler when an Ack is missed.
---
>    * Event handler when an ACK is missed.
285c269
<    * \param expectedCfAck flag to indicate whether a CF-Ack was expected in the response.
---
>    * \param expectedCfAck flag to indicate whether a CF-ACK was expected in the response.
289c273
<    * Event handler when a BlockAck is received.
---
>    * Event handler when a Block ACK is received.
291c275
<    * \param blockAck BlockAck header.
---
>    * \param blockAck block ack.
293,295c277,279
<    * \param rxSnr SNR of the BlockAck itself in linear scale.
<    * \param dataSnr reported data SNR from the peer in linear scale.
<    * \param dataTxVector TXVECTOR used to send the Data.
---
>    * \param rxSnr SNR of the block ack itself.
>    * \param txMode wifi mode.
>    * \param dataSnr reported data SNR from the peer.
297,298c281
<   virtual void GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient,
<                             double rxSnr, double dataSnr, WifiTxVector dataTxVector);
---
>   virtual void GotBlockAck (const CtrlBAckResponseHeader *blockAck, Mac48Address recipient, double rxSnr, WifiMode txMode, double dataSnr);
300,301c283,284
<    * Event handler when a BlockAck timeout has occurred.
<    * \param nMpdus the number of MPDUs sent in the A-MPDU transmission that results in a BlockAck timeout.
---
>    * Event handler when a Block ACK timeout has occurred.
>    * \param nMpdus the number of MPDUs sent in the A-MPDU transmission that results in a Block ACK timeout.
320c303
<    * does not require an Ack has completed.
---
>    * does not require an ACK has completed.
325c308
<    * Return the remaining duration in the current TXOP.
---
>    * Check if the station has TXOP granted for the next MPDU.
327,331c310,311
<    * \return the remaining duration in the current TXOP.
<    */
<   virtual Time GetTxopRemaining (void) const;
<   /**
<    * Update backoff and restart access if needed.
---
>    * \return true if the station has TXOP granted for the next MPDU,
>    *         false otherwise
333c313
<   virtual void TerminateTxop (void);
---
>   virtual bool HasTxop (void) const;
355,404d334
<   //// WIGIG ////
<   /**
<    * Check if the current station is performing SLS TXSS in CBAP.
<    * \return true if the station is performing SLS in CBAP, false
<    *         otherwise.
<    */
<   virtual bool ServingSLS (void) const;
<   /**
<    * Start a new allocation period in the DTI channel access period.
<    * \param allocationType The type of the allocation (SP/CBAP)
<    * \param allocationID The ID of the allocation.
<    * \param peerStation The MAC address of the peer station.
<    * \param allocationDuration The total duration of the current allocation.
<    */
<   virtual void StartAllocationPeriod (AllocationType allocationType, AllocationID allocationID,
<                                       Mac48Address peerStation, Time allocationDuration);
<   /**
<    * Resume TXOP normal operation.
<    * Note: We call this function after performing SLS.
<    */
<   void ResumeTxopTransmission (void);
<   /**
<    * End Current Contention Period.
<    */
<   void EndAllocationPeriod (void);
<   /**
<    * Get the remaining duration in the current allocation.
<    * \return The remaining time in the current allocation.
<    */
<   Time GetAllocationRemaining (void) const;
<   /**
<    * Get the remaining time for transmission in the current allocation/Txop period.
<    * \return The remaining time for transmission in the current allocation/Txop period.
<    */
<   Time GetRemainingTimeForTransmission (void);
<   /**
<    * Get duration limit for the PPDU to be transmitted.
<    * \param item
<    * \param params The MacLow transmission parameters for the given frame.
<    * \return PPDU duration limit.
<    */
<   virtual Time GetPpduDurationLimit (Ptr<const WifiMacQueueItem> item, const MacLowTransmissionParameters &params);
<   /**
<    * Check whether EDMG is supported.
<    * This function is used for selecting the correct blockack type.
<    * \return True if EDMG is supported; otherwise false.
<    */
<   bool IsEdmgSupported (void) const;
<   //// WIGIG ////
< 
420,428d349
<   //// WIGIG ////
<   friend class DmgAdhocWifiMac;
<   /**
<    * This function is used to set the type of the allocation used for communication during the data transmission interval.
<    * \param allocationType CBAP or SP.
<    */
<   void SetAllocationType (AllocationType allocationType);
<   //// WIGIG ////
< 
435c356
<   /* Txop notifications forwarded here */
---
>   /* dcf notifications forwarded here */
441c362
<    * Notify the Txop that access has been granted.
---
>    * Notify the DCF that access has been granted.
445c366
<    * Notify the Txop that internal collision has occurred.
---
>    * Notify the DCF that internal collision has occurred.
448,453d368
< 
<   /**
<    * Check if the Txop has frames to transmit.
<    * \return true if the Txop has frames to transmit.
<    */
<   virtual bool HasFramesToTransmit (void);
455c370
<    * Generate a new backoff now.
---
>    * Notify the DCF that collision has occurred.
457c372,373
<   virtual void GenerateBackoff (void);
---
>   virtual void NotifyCollision (void);
> 
463c379
<    * Request access from Txop if needed.
---
>    * Request access from DCF manager if needed.
469c385
<    *          minCW.
---
>    * minCW.
500,501c416,417
<    * \param nSlots the number of slots to decrement
<    * \param backoffUpdateBound the time at which backoff should start
---
>    * \param nSlots
>    * \param backoffUpdateBound
515c431
<    * Check if Data should be re-transmitted if Ack was missed.
---
>    * Check if DATA should be re-transmitted if ACK was missed.
519c435
<    * \return true if Data should be re-transmitted,
---
>    * \return true if DATA should be re-transmitted,
549c465
<    * \return the size of the next fragment in bytes.
---
>    * \return the size of the next fragment.
555c471
<    * \return the size of the current fragment in bytes.
---
>    * \return the size of the current fragment.
561c477
<    * \return the offset for the current fragment in bytes.
---
>    * \return the offset for the current fragment.
580d495
< TxOk m_txOkNoAckCallback; 							//!< the transmit OK No ACK callback
582,596c497,510
<   TxPacketOk m_txOkCallback;                        //!< the transmit OK callback
<   TxFailed m_txFailedCallback;                      //!< the transmit failed callback
<   TxDropped m_txDroppedCallback;                    //!< the packet dropped callback
<   Ptr<WifiMacQueue> m_queue;                        //!< the wifi MAC queue
<   Ptr<MacTxMiddle> m_txMiddle;                      //!< the MacTxMiddle
<   Ptr <MacLow> m_low;                               //!< the MacLow
<   Ptr<WifiRemoteStationManager> m_stationManager;   //!< the wifi remote station manager
<   Ptr<UniformRandomVariable> m_rng;                 //!< the random stream
< 
<   uint32_t m_cwMin;        //!< the minimum contention window
<   uint32_t m_cwMax;        //!< the maximum contention window
<   uint32_t m_cw;           //!< the current contention window
<   uint32_t m_backoff;      //!< the current backoff
<   bool m_accessRequested;  //!< flag whether channel access is already requested
<   uint32_t m_backoffSlots; //!< the number of backoff slots
---
>   TxOk m_txOkCallback; //!< the transmit OK callback
>   TxFailed m_txFailedCallback; //!< the transmit failed callback
>   TxDropped m_txDroppedCallback; //!< the packet dropped callback
>   Ptr<WifiMacQueue> m_queue; //!< the wifi MAC queue
>   Ptr<MacTxMiddle> m_txMiddle; //!< the MacTxMiddle
>   Ptr <MacLow> m_low; //!< the MacLow
>   Ptr<WifiRemoteStationManager> m_stationManager; //!< the wifi remote station manager
>   Ptr<UniformRandomVariable> m_rng; //!<  the random stream
> 
>   uint32_t m_cwMin;       //!< the CW minimum
>   uint32_t m_cwMax;       //!< the CW maximum
>   uint32_t m_cw;          //!< the current CW
>   bool m_accessRequested; //!< flag whether channel access is already requested
>   uint32_t m_backoffSlots; //!< the backoff slots
605c519
<   Time m_txopLimit;       //!< the TXOP limit time
---
>   Time m_txopLimit;       //!< the txop limit time
607,630c521,524
<   Ptr<const Packet> m_currentPacket;            //!< the current packet
<   WifiMacHeader m_currentHdr;                   //!< the current header
<   MacLowTransmissionParameters m_currentParams; //!< current transmission parameters
<   uint8_t m_fragmentNumber;                     //!< the fragment number
<   TracedCallback<uint32_t> m_backoffTrace;      //!< backoff trace value
<   TracedValue<uint32_t> m_cwTrace;              //!< CW trace value
< 
<   //// WIGIG ////
<   /* Store packet and header for Allocation Period */
<   typedef std::pair<Ptr<const Packet>, WifiMacHeader> PacketInformation;
<   typedef std::map<AllocationID, PacketInformation> StoredPackets;
<   typedef StoredPackets::iterator StoredPacketsI;
<   typedef StoredPackets::const_iterator StoredPacketsCI;
<   StoredPackets m_storedPackets;    //!< Stored packets based on allocation ID.
< 
<   /** DMG/EDMG Allocation Variables **/
<   AllocationID m_allocationID;        //!< The ID for the current allocation.
<   AllocationType m_allocationType;    //!< The type of the current allocation. (CBAP/SP)
<   Mac48Address m_peerStation;         //!< The address of the peer station for SP allocation.
<   Time m_allocationStart;             //!< The start time of the current allocation.
<   Time m_allocationDuration;          //!< The duration of the current allocation.
<   bool m_firstTransmission;           //!< Flag to indicate if this is the first transmission in the current allocation period.
<   bool m_accessAllowed;               //!< Flag to indicate whether the access is allowed for the curent EDCA Queue.
<   //// WIGIG ////
---
>   Ptr<const Packet> m_currentPacket; //!< the current packet
>   WifiMacHeader m_currentHdr; //!< the current header
>   MacLowTransmissionParameters m_currentParams; ///< current transmission parameters
>   uint8_t m_fragmentNumber; //!< the fragment number
diff ../../NS3-WiGig/src/wifi/model/vht-capabilities.cc ../../ns-3-dev-git/src/wifi/model/vht-capabilities.cc
66c66
< VhtCapabilities::SetVhtSupported (uint8_t vhtSupported)
---
> VhtCapabilities::SetVhtSupported (uint8_t vhtsupported)
68c68
<   m_vhtSupported = vhtSupported;
---
>   m_vhtSupported = vhtsupported;
211c211
< VhtCapabilities::SetMaxMpduLength (uint16_t length)
---
> VhtCapabilities::SetMaxMpduLength (uint8_t length)
213,226c213
<   NS_ABORT_MSG_IF (length != 3895 && length != 7991 && length != 11454,
<                    "Invalid MPDU Max Length value");
<   if (length == 11454)
<     {
<       m_maxMpduLength = 2;
<     }
<   else if (length == 7991)
<     {
<       m_maxMpduLength = 1;
<     }
<   else
<     {
<       m_maxMpduLength = 0;
<     }
---
>   m_maxMpduLength = length;
230c217
< VhtCapabilities::SetSupportedChannelWidthSet (uint8_t channelWidthSet)
---
> VhtCapabilities::SetSupportedChannelWidthSet (uint8_t channelwidthset)
232c219
<   m_supportedChannelWidthSet = channelWidthSet;
---
>   m_supportedChannelWidthSet = channelwidthset;
236c223
< VhtCapabilities::SetRxLdpc (uint8_t rxLdpc)
---
> VhtCapabilities::SetRxLdpc (uint8_t rxldpc)
238c225
<   m_rxLdpc = rxLdpc;
---
>   m_rxLdpc = rxldpc;
242c229
< VhtCapabilities::SetShortGuardIntervalFor80Mhz (uint8_t shortGuardInterval)
---
> VhtCapabilities::SetShortGuardIntervalFor80Mhz (uint8_t shortguardinterval)
244c231
<   m_shortGuardIntervalFor80Mhz = shortGuardInterval;
---
>   m_shortGuardIntervalFor80Mhz = shortguardinterval;
248c235
< VhtCapabilities::SetShortGuardIntervalFor160Mhz (uint8_t shortGuardInterval)
---
> VhtCapabilities::SetShortGuardIntervalFor160Mhz (uint8_t shortguardinterval)
250c237
<   m_shortGuardIntervalFor160Mhz = shortGuardInterval;
---
>   m_shortGuardIntervalFor160Mhz = shortguardinterval;
254c241
< VhtCapabilities::SetRxStbc (uint8_t rxStbc)
---
> VhtCapabilities::SetRxStbc (uint8_t rxstbc)
256c243
<   m_rxStbc = rxStbc;
---
>   m_rxStbc = rxstbc;
260c247
< VhtCapabilities::SetTxStbc (uint8_t txStbc)
---
> VhtCapabilities::SetTxStbc (uint8_t txstbc)
262c249
<   m_txStbc = txStbc;
---
>   m_txStbc = txstbc;
266c253
< VhtCapabilities::SetMaxAmpduLength (uint32_t maxampdulength)
---
> VhtCapabilities::SetMaxAmpduLengthExponent (uint8_t exponent)
268,276c255
<   for (uint8_t i = 0; i <= 7; i++)
<     {
<       if ((1ul << (13 + i)) - 1 == maxampdulength)
<         {
<           m_maxAmpduLengthExponent = i;
<           return;
<         }
<     }
<   NS_ABORT_MSG ("Invalid A-MPDU Max Length value");
---
>   m_maxAmpduLengthExponent = exponent;
334c313
< VhtCapabilities::SetRxHighestSupportedLgiDataRate (uint16_t supportedDatarate)
---
> VhtCapabilities::SetRxHighestSupportedLgiDataRate (uint16_t supporteddatarate)
336c315
<   m_rxHighestSupportedLongGuardIntervalDataRate = supportedDatarate;
---
>   m_rxHighestSupportedLongGuardIntervalDataRate = supporteddatarate;
340,346c319
< VhtCapabilities::SetTxHighestSupportedLgiDataRate (uint16_t supportedDatarate)
< {
<   m_txHighestSupportedLongGuardIntervalDataRate = supportedDatarate;
< }
< 
< uint16_t
< VhtCapabilities::GetMaxMpduLength (void) const
---
> VhtCapabilities::SetTxHighestSupportedLgiDataRate (uint16_t supporteddatarate)
348,360c321
<   if (m_maxMpduLength == 0)
<     {
<       return 3895;
<     }
<   if (m_maxMpduLength == 1)
<     {
<       return 7991;
<     }
<   if (m_maxMpduLength == 2)
<     {
<       return 11454;
<     }
<   NS_ABORT_MSG ("The value 3 is reserved");
---
>   m_txHighestSupportedLongGuardIntervalDataRate = supporteddatarate;
387,392d347
< uint32_t
< VhtCapabilities::GetMaxAmpduLength (void) const
< {
<   return (1ul << (13 + m_maxAmpduLengthExponent)) - 1;
< }
< 
417a373,380
> /**
>  * output stream output operator
>  *
>  * \param os output stream
>  * \param VhtCapabilities the VHT capabilities
>  *
>  * \returns output stream
>  */
diff ../../NS3-WiGig/src/wifi/model/vht-capabilities.h ../../ns-3-dev-git/src/wifi/model/vht-capabilities.h
37a38,43
>   /**
>    * Set the VHT supported field.
>    *
>    * \param vhtsupported the VHT supported field
>    */
>   void SetVhtSupported (uint8_t vhtsupported);
39c45,49
<   // Implementations of pure virtual methods of WifiInformationElement
---
>   /**
>    * Return the element ID.
>    *
>    * \returns the wifi information element ID
>    */
40a51,55
>   /**
>    * Return the information field size.
>    *
>    * \returns the information field size
>    */
41a57,61
>   /**
>    * Serialize the information field.
>    *
>    * \param start the information field iterator
>    */
43,50d62
<   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is an VHT STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
52c64
<    * Set the VHT supported field.
---
>    * Deserialize the information field.
54c66,68
<    * \param vhtSupported the VHT supported field
---
>    * \param start the information field iterator
>    * \param length the information field
>    * \returns the information field
56c70
<   void SetVhtSupported (uint8_t vhtSupported);
---
>   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
88c102
<    * \param length the maximum MPDU length (3895, 7991 or 11454)
---
>    * \param length the maximum MPDU length
90c104
<   void SetMaxMpduLength (uint16_t length);
---
>   void SetMaxMpduLength (uint8_t length);
94c108
<    * \param channelWidthSet the supported channel width set
---
>    * \param channelwidthset the supported channel width set
96c110
<   void SetSupportedChannelWidthSet (uint8_t channelWidthSet);
---
>   void SetSupportedChannelWidthSet (uint8_t channelwidthset);
100c114
<    * \param rxLdpc the receive LDPC
---
>    * \param rxldpc the receive LDPC
102c116
<   void SetRxLdpc (uint8_t rxLdpc);
---
>   void SetRxLdpc (uint8_t rxldpc);
104c118
<    * Set the short guard interval 80 MHz.
---
>    * Set the short guard interval 80 Mhz.
106c120
<    * \param shortGuardInterval the short guard interval 80 MHz
---
>    * \param shortguardinterval the short guard interval 80 Mhz
108c122
<   void SetShortGuardIntervalFor80Mhz (uint8_t shortGuardInterval);
---
>   void SetShortGuardIntervalFor80Mhz (uint8_t shortguardinterval);
110c124
<    * Set the short guard interval 160 MHz.
---
>    * Set the short guard interval 160 Mhz.
112c126
<    * \param shortGuardInterval the short guard interval 160 MHz
---
>    * \param shortguardinterval the short guard interval 160 Mhz
114c128
<   void SetShortGuardIntervalFor160Mhz (uint8_t shortGuardInterval);
---
>   void SetShortGuardIntervalFor160Mhz (uint8_t shortguardinterval);
118c132
<    * \param rxStbc the receive STBC
---
>    * \param rxstbc the receive STBC
120c134
<   void SetRxStbc (uint8_t rxStbc);
---
>   void SetRxStbc (uint8_t rxstbc);
124c138
<    * \param txStbc the receive STBC
---
>    * \param txstbc the receive STBC
126c140
<   void SetTxStbc (uint8_t txStbc);
---
>   void SetTxStbc (uint8_t txstbc);
128c142
<    * Set the maximum AMPDU length.
---
>    * Set the maximum AMPDU length exponent.
130c144
<    * \param maxAmpduLength 2^(13 + x) - 1, x in the range 0 to 7
---
>    * \param exponent the maximum AMPDU length exponent
132c146
<   void SetMaxAmpduLength (uint32_t maxAmpduLength);
---
>   void SetMaxAmpduLengthExponent (uint8_t exponent);
135,140d148
<    * Get the maximum MPDU length.
<    *
<    * \return the maximum MPDU length in bytes
<    */
<   uint16_t GetMaxMpduLength (void) const;
<   /**
143c151
<    * \returns the supported channel width set
---
>    * \returns the maximum MPDU length
178c186
<    * \param supportedDatarate receive highest supported LGI data rate
---
>    * \param supporteddatarate receive highest supported LGI data rate
180c188
<   void SetRxHighestSupportedLgiDataRate (uint16_t supportedDatarate);
---
>   void SetRxHighestSupportedLgiDataRate (uint16_t supporteddatarate);
184c192
<    * \param supportedDatarate transmit highest supported LGI data rate
---
>    * \param supporteddatarate transmit highest supported LGI data rate
186c194
<   void SetTxHighestSupportedLgiDataRate (uint16_t supportedDatarate);
---
>   void SetTxHighestSupportedLgiDataRate (uint16_t supporteddatarate);
191c199
<    * \param nss the NSS
---
>    * \param Nss the NSS
194c202
<   bool IsSupportedMcs (uint8_t mcs, uint8_t nss) const;
---
>   bool IsSupportedMcs (uint8_t mcs, uint8_t Nss) const;
204c212
<    * Returns true if transmit MCS is supported.
---
>    * Get the is transmit MCS supported.
207c215
<    * \returns whether transmit MCS is supported
---
>    * \returns is transmit MCS supported
211c219
<    * Returns true if receive MCS is supported.
---
>    * Get the is receive MCS supported.
214c222
<    * \returns whether receive MCS is supported
---
>    * \returns is receive MCS supported
219c227,237
<    * Return the maximum A-MPDU length.
---
>    * This information element is a bit special in that it is only
>    * included if the STA is an VHT STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start the iterator
>    * \returns the serialized size
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Get the serialized size.
221c239
<    * \return the maximum A-MPDU length in bytes
---
>    * \returns the serialized size
223c241
<   uint32_t GetMaxAmpduLength (void) const;
---
>   uint16_t GetSerializedSize () const;
228,244c246,262
<   uint8_t m_maxMpduLength;               ///< maximum MPDU length
<   uint8_t m_supportedChannelWidthSet;    ///< supported channel width set
<   uint8_t m_rxLdpc;                      ///< receive LDPC
<   uint8_t m_shortGuardIntervalFor80Mhz;  ///< short guard interval for 80 MHz
<   uint8_t m_shortGuardIntervalFor160Mhz; ///< short guard interval for 160 MHz
<   uint8_t m_txStbc;                      ///< transmit STBC
<   uint8_t m_rxStbc;                      ///< receive STBC
<   uint8_t m_suBeamformerCapable;         ///< SU beamformer capable
<   uint8_t m_suBeamformeeCapable;         ///< SU beamformee capable
<   uint8_t m_beamformeeStsCapable;        ///< beamformee STS capable
<   uint8_t m_numberOfSoundingDimensions;  ///< number of sounding dimensions
<   uint8_t m_muBeamformerCapable;         ///< MU beamformer capable
<   uint8_t m_muBeamformeeCapable;         ///< MU beamformee capable
<   uint8_t m_vhtTxopPs;                   ///< VHT TXOP PS
<   uint8_t m_htcVhtCapable;               ///< HTC VHT capable
<   uint8_t m_maxAmpduLengthExponent;      ///< maximum A-MPDU length exponent
<   uint8_t m_vhtLinkAdaptationCapable;    ///< VHT link adaptation capable
---
>   uint8_t m_maxMpduLength; ///< maximum MPDU length
>   uint8_t m_supportedChannelWidthSet; ///< supported channel width set
>   uint8_t m_rxLdpc; ///< receive LDPC
>   uint8_t m_shortGuardIntervalFor80Mhz; ///< short guard interval 80 MHz
>   uint8_t m_shortGuardIntervalFor160Mhz;  ///< short guard interval 160 MHz
>   uint8_t m_txStbc; ///< transmit STBC
>   uint8_t m_rxStbc; ///< receive STBC
>   uint8_t m_suBeamformerCapable; ///< SU beam former capable
>   uint8_t m_suBeamformeeCapable; ///< SU beam formee capable
>   uint8_t m_beamformeeStsCapable; ///< beam formee STS capable
>   uint8_t m_numberOfSoundingDimensions; ///< number of sounding dimensions
>   uint8_t m_muBeamformerCapable; ///< MU beam former capable
>   uint8_t m_muBeamformeeCapable; ///< MU beam formee capable
>   uint8_t m_vhtTxopPs; ///< VHT TXOP PS
>   uint8_t m_htcVhtCapable; ///< HTC VHT capable
>   uint8_t m_maxAmpduLengthExponent; ///< maximum AMPDU length exponent
>   uint8_t m_vhtLinkAdaptationCapable; ///< VHT link adaptation capable
249c267
<   std::vector<uint8_t> m_rxMcsMap;                        ///< receive MCS map
---
>   std::vector<uint8_t> m_rxMcsMap; ///< receive MCS map
251,252c269,270
<   std::vector<uint8_t> m_txMcsMap;                        ///< transmit MCS map
<   uint16_t m_txHighestSupportedLongGuardIntervalDataRate; ///< transmit highest supported long guard interval data rate
---
>   std::vector<uint8_t> m_txMcsMap; ///< transmit MCS map
>   uint16_t m_txHighestSupportedLongGuardIntervalDataRate;  ///< transmit highest supported long guard interval data rate
258,265d275
< /**
<  * output stream output operator
<  *
<  * \param os the output stream
<  * \param VhtCapabilities the VHT capabilities
<  *
<  * \returns output stream
<  */
Only in ../../NS3-WiGig/src/wifi/model: vht-configuration.cc
Only in ../../NS3-WiGig/src/wifi/model: vht-configuration.h
diff ../../NS3-WiGig/src/wifi/model/vht-operation.cc ../../ns-3-dev-git/src/wifi/model/vht-operation.cc
41c41
< VhtOperation::SetVhtSupported (uint8_t vhtSupported)
---
> VhtOperation::SetVhtSupported (uint8_t vhtsupported)
43c43
<   m_vhtSupported = vhtSupported;
---
>   m_vhtSupported = vhtsupported;
49c49
<   //we should not be here if VHT is not supported
---
>   //we should not be here if vht is not supported
163a164,171
> /**
>  * output stream output operator
>  *
>  * \param os output stream
>  * \param VhtOperation the VHT operation
>  *
>  * \returns output stream
>  */
diff ../../NS3-WiGig/src/wifi/model/vht-operation.h ../../ns-3-dev-git/src/wifi/model/vht-operation.h
33a34,35
>  *
>  * \see attribute_VhtOperation
39,51d40
< 
<   // Implementations of pure virtual methods of WifiInformationElement
<   WifiInformationElementId ElementId () const;
<   uint8_t GetInformationFieldSize () const;
<   void SerializeInformationField (Buffer::Iterator start) const;
<   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
<   /* This information element is a bit special in that it is only
<      included if the STA is a VHT STA. To support this we
<      override the Serialize and GetSerializedSize methods of
<      WifiInformationElement. */
<   Buffer::Iterator Serialize (Buffer::Iterator start) const;
<   uint16_t GetSerializedSize () const;
< 
55c44
<    * \param vhtSupported the VHT supported information element
---
>    * \param vhtsupported the VHT supported information element
57c46
<   void SetVhtSupported (uint8_t vhtSupported);
---
>   void SetVhtSupported (uint8_t vhtsupported);
116a106,149
>   /**
>    * Return the element ID.
>    *
>    * \returns the element ID
>    */
>   WifiInformationElementId ElementId () const;
>   /**
>    * Return the information field size.
>    *
>    * \returns the information field size
>    */
>   uint8_t GetInformationFieldSize () const;
>   /**
>    * Serialize the information field.
>    *
>    * \param start the information field iterator
>    */
>   void SerializeInformationField (Buffer::Iterator start) const;
>   /**
>    * Deserialize the information field.
>    *
>    * \param start the iterator
>    * \param length the length
>    * \returns the information field size
>    */
>   uint8_t DeserializeInformationField (Buffer::Iterator start, uint8_t length);
>   /**
>    * This information element is a bit special in that it is only
>    * included if the STA is a VHT STA. To support this we
>    * override the Serialize and GetSerializedSize methods of
>    * WifiInformationElement.
>    *
>    * \param start
>    *
>    * \return an iterator
>    */
>   Buffer::Iterator Serialize (Buffer::Iterator start) const;
>   /**
>    * Return the serialized size of this VHT Operations IE.
>    *
>    * \return the serialized size of this VHT Operations IE
>    */
>   uint16_t GetSerializedSize () const;
> 
122c155
<   uint8_t m_channelCenterFrequencySegment1; ///< channel center frequency segment 1
---
>   uint8_t m_channelCenterFrequencySegment1; ///< channel center frequency segment 0
131,138d163
< /**
<  * output stream output operator
<  *
<  * \param os the output stream
<  * \param VhtOperation the VHT operation
<  *
<  * \returns output stream
<  */
Only in ../../NS3-WiGig/src/wifi/model: wifi-ack-policy-selector.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-ack-policy-selector.h
diff ../../NS3-WiGig/src/wifi/model/wifi-information-element.cc ../../ns-3-dev-git/src/wifi/model/wifi-information-element.cc
25,46d24
< Buffer::Iterator
< DeserializeExtensionElementID (Buffer::Iterator i, uint8_t &elementID, uint8_t &length, uint8_t &extElementID)
< {
<   Buffer::Iterator start = i;
<   elementID = i.ReadU8 ();
<   if (elementID != IE_EXTENSION)
<     {
<       return start;
<     }
<   length = i.ReadU8 ();
<   extElementID = i.ReadU8 ();
<   return i;
< }
< 
< Buffer::Iterator
< DeserializeElementID (Buffer::Iterator i, uint8_t &elementID, uint8_t &length)
< {
<   elementID = i.ReadU8 ();
<   length = i.ReadU8 ();
<   return i;
< }
< 
62,67d39
< WifiInformationElementId
< WifiInformationElement::ElementIdExt () const
< {
<   return 0;
< }
< 
73,83c45,46
<   if (ElementId () == IE_EXTENSION)
<     {
<       i.WriteU8 (ElementIdExt ());
<       SerializeInformationField (i);
<       i.Next (GetInformationFieldSize () - 1);
<     }
<   else
<     {
<       SerializeInformationField (i);
<       i.Next (GetInformationFieldSize ());
<     }
---
>   SerializeInformationField (i);
>   i.Next (GetInformationFieldSize ());
117,136d79
<   if (ElementId () == IE_EXTENSION)
<     {
<       uint8_t elementIdExt = i.ReadU8 ();
<       //If the element here isn't the one we're after then we immediately
<       //return the iterator we were passed indicating that we haven't
<       //taken anything from the buffer.
<       if (elementIdExt != ElementIdExt ())
<         {
<           return start;
<         }
<       DeserializeInformationField (i, length - 1);
<       i.Next (length - 1);
<     }
<   else
<     {
<       DeserializeInformationField (i, length);
<       i.Next (length);
<     }
<   return i;
< }
138,140d80
< Buffer::Iterator
< WifiInformationElement::DeserializeElementBody (Buffer::Iterator i, uint8_t length)
< {
142a83
> 
155,159d95
<     {
<       return false;
<     }
< 
<   if (ElementIdExt () != a.ElementIdExt ())
diff ../../NS3-WiGig/src/wifi/model/wifi-information-element.h ../../ns-3-dev-git/src/wifi/model/wifi-information-element.h
25,26d24
< #include "ns3/simple-ref-count.h"
< #include "map"
44,47d41
< /**
<  * This type is used to represent an Information Element ID Extension.
<  */
< typedef uint8_t WifiInformationElementIdExtension;
51c45
<  * 802.11-2016. See the comments for WifiInformationElementId - this could
---
>  * 802.11-2007. See the comments for WifiInformationElementId - this could
142c136
< #define IE_WAKEUP_SCHEDULE_OLD                  ((WifiInformationElementId)102)
---
> #define IE_WAKEUP_SCHEDULE                      ((WifiInformationElementId)102)
194,195c188,190
< // 222 to 254 are reserved
< #define IE_EXTENSION                            ((WifiInformationElementId)255)
---
> // 222 to 255 are reserved
> #define IE_HE_CAPABILITIES                      ((WifiInformationElementId)255) //todo: not defined yet in the standard!
> #define IE_HE_OPERATION                         ((WifiInformationElementId)255) //todo: not defined yet in the standard!
197,277d191
< #define IE_EXT_HE_CAPABILITIES                  ((WifiInformationElementId)35)
< #define IE_EXT_HE_OPERATION                     ((WifiInformationElementId)36)
< 
< // 143 to 190 are 802.11ad in 802.11-2012
< #define IE_WAKEUP_SCHEDULE                     ((WifiInformationElementId)143)
< #define IE_EXTENDED_SCHEDULE                   ((WifiInformationElementId)144)
< #define IE_STA_AVAILABILITY                    ((WifiInformationElementId)145)
< #define IE_DMG_TSPEC                           ((WifiInformationElementId)146)
< #define IE_NEXT_DMG_ATI                        ((WifiInformationElementId)147)
< #define IE_DMG_CAPABILITIES                    ((WifiInformationElementId)148)
< #define IE_DMG_OPERATION                       ((WifiInformationElementId)151)
< #define IE_DMG_BSS_PARAMETER_CHANGE            ((WifiInformationElementId)152)
< #define IE_DMG_BEAM_REFINEMENT                 ((WifiInformationElementId)153)
< #define IE_CHANNEL_MEASUREMENT_FEEDBACK        ((WifiInformationElementId)154)
< #define IE_AWAKE_WINDOW                        ((WifiInformationElementId)157)
< #define IE_MULTI_BAND                          ((WifiInformationElementId)158)
< #define IE_ADDBA_EXTENSION                     ((WifiInformationElementId)159)
< #define IE_NEXT_PCP_LIST                       ((WifiInformationElementId)160)
< #define IE_PCP_HANDOVER                        ((WifiInformationElementId)161)
< #define IE_DMG_LINK_MARGIN                     ((WifiInformationElementId)162)
< #define IE_SWITCHING_STREAM                    ((WifiInformationElementId)163)
< #define IE_SESSION_TRANSITION                  ((WifiInformationElementId)164)
< #define IE_DYNAMIC_TONE_PAIRING_REPORT         ((WifiInformationElementId)165)
< #define IE_CLUSTER_REPORT                      ((WifiInformationElementId)166)
< #define IE_RELAY_CAPABILITIES                  ((WifiInformationElementId)167)
< #define IE_RELAY_TRANSFER_PARAMETER_SET        ((WifiInformationElementId)168)
< #define IE_BEAMLINK_MAINENANCE                 ((WifiInformationElementId)169)
< #define IE_DMG_LINK_ADAPTATION_ACKNOWLEDGMENT  ((WifiInformationElementId)172)
< #define IE_QUIET_PERIOD_REQUEST                ((WifiInformationElementId)175)
< #define IE_QUIET_PERIOD_RESPONSE               ((WifiInformationElementId)177)
< #define IE_ECPAC_POLICY                        ((WifiInformationElementId)182)
< 
< /**
<  * Definition of the Element ID Extension field in 802.11ay_D5.0
<  */
< #define IE_EXTENSION_EDMG_CAPABILITIES                    ((WifiInformationElementIdExtension)61)
< #define IE_EXTENSION_EDMG_OPERATION                       ((WifiInformationElementIdExtension)62)
< #define IE_EXTENSION_EDMG_EXTENDED_SCHEDULE               ((WifiInformationElementIdExtension)63)
< #define IE_EXTENSION_EDMG_CHANNEL_MEASUREMENT_FEEDBACK    ((WifiInformationElementIdExtension)64)
< #define IE_EXTENSION_EDMG_GROUP_ID_SET                    ((WifiInformationElementIdExtension)65)
< #define IE_EXTENSION_EDMG_BRP_REQUEST                     ((WifiInformationElementIdExtension)66)
< #define IE_EXTENSION_EDMG_TRAINING_FIELD_SCHEDULE         ((WifiInformationElementIdExtension)67)
< #define IE_EXTENSION_EDMG_PARTIAL_SECTOR_SWEEP            ((WifiInformationElementIdExtension)68)
< #define IE_EXTENSION_MIMO_SETUP_CONTROL                   ((WifiInformationElementIdExtension)69)
< #define IE_EXTENSION_MIMO_POLL_CONTROL                    ((WifiInformationElementIdExtension)70)
< #define IE_EXTENSION_MIMO_FEEDBACK_CONTROL                ((WifiInformationElementIdExtension)71)
< #define IE_EXTENSION_MIMO_SELECTION_CONTROL               ((WifiInformationElementIdExtension)72)
< #define IE_EXTENSION_EDMG_FLOW_CONTROL_EXTENSION          ((WifiInformationElementIdExtension)73)
< #define IE_EXTENSION_QOS_TRIGGERED_UNSCHEDULED            ((WifiInformationElementIdExtension)74)
< #define IE_EXTENSION_UNSLICITED_BLOCK_ACK_EXTENSION       ((WifiInformationElementIdExtension)75)
< #define IE_EXTENSION_SEGMENATION_REASSEMBLY               ((WifiInformationElementIdExtension)76)
< #define IE_EXTENSION_TDD_SLOT_STRUCTURE                   ((WifiInformationElementIdExtension)77)
< #define IE_EXTENSION_TDD_SLOT_SCHEDULE                    ((WifiInformationElementIdExtension)78)
< #define IE_EXTENSION_TDD_ROUTE                            ((WifiInformationElementIdExtension)79)
< #define IE_EXTENSION_DIGITAL_BF_FEEDBACK                  ((WifiInformationElementIdExtension)80)
< #define IE_EXTENSION_TDD_BANDWIDTH_REQUEST                ((WifiInformationElementIdExtension)81)
< #define IE_EXTENSION_TDD_SYNCHRONIZATION                  ((WifiInformationElementIdExtension)82)
< #define IE_EXTENSION_EDMG_WIDE_BANDWIDTH_CHANNEL_SWITCH   ((WifiInformationElementIdExtension)83)
< #define IE_EXTENSION_DMG_DISCOVERY_ASSISTANCE             ((WifiInformationElementIdExtension)84)
< #define IE_EXTENSION_EXTENDED_LINK_MEASUREMENT            ((WifiInformationElementIdExtension)85)
< #define IE_EXTENSION_DMG_STA_TRANSCEIVER_PARAMETERS       ((WifiInformationElementIdExtension)86)
< 
< /**
<  * Deserialize IE ID, length and Extension ID. The iterator passed in  must be
<  * pointing at the Element ID of an information element.
<  *
<  * \param i an iterator which points to where the IE should be read.
<  *
<  * \return an iterator
<  */
< Buffer::Iterator DeserializeExtensionElementID (Buffer::Iterator i, uint8_t &elementID, uint8_t &length, uint8_t &extElementID);
< 
< /**
<  * Deserialize IE ID and length. The iterator passed in  must be
<  * pointing at the Element ID of an information element.
<  *
<  * \param i an iterator which points to where the IE should be read.
<  *
<  * \return an iterator
<  */
< Buffer::Iterator DeserializeElementID (Buffer::Iterator i, uint8_t &elementID, uint8_t &length);
351,359d264
<    * Deserialize IE Body. The iterator passed in must be pointing at
<    * the Element Body of an information element.
<    *
<    * \param i an iterator which points to where the IE body should be read.
<    *
<    * \return an iterator
<    */
<   Buffer::Iterator DeserializeElementBody (Buffer::Iterator i, uint8_t length);
<   /**
363c268
<    * \return the size of the serialized IE in bytes
---
>    * \return the size of the serialized IE
401,405d305
<   /**
<    * \returns Own unique Element ID Extension
<    */
<   virtual WifiInformationElementId ElementIdExt () const;
< 
425,430d324
< 
< typedef std::vector<Ptr<WifiInformationElement> > WifiInfoElementList;
< typedef std::pair<WifiInformationElementId, WifiInformationElementIdExtension> WifiInfoElementId;
< typedef std::vector<WifiInfoElementId> WifiInformationElementIdList;
< typedef std::map<WifiInfoElementId, Ptr<WifiInformationElement> > WifiInformationElementMap;
< typedef std::map<WifiInformationElementId, Ptr<WifiInformationElement> > WifiInformationSubelementMap;
diff ../../NS3-WiGig/src/wifi/model/wifi-information-element-vector.h ../../ns-3-dev-git/src/wifi/model/wifi-information-element-vector.h
130c130,131
<   uint16_t m_maxSize;   //!< Size in bytes (actually, max packet length)
---
>   /// Size in bytes (actually, max packet length)
>   uint16_t m_maxSize;
diff ../../NS3-WiGig/src/wifi/model/wifi-mac.cc ../../ns-3-dev-git/src/wifi/model/wifi-mac.cc
26,29d25
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "vht-configuration.h"
< #include "he-configuration.h"
95c91
<   //This value must be revisited
---
>   //This value must be rivisited
102c98
<   //This value must be revisited
---
>   //This value must be rivisited
133c129,134
<     .AddAttribute ("AckTimeout", "When this timeout expires, the Data/Ack handshake has failed.",
---
>     .AddAttribute ("CtsTimeout", "When this timeout expires, the RTS/CTS handshake has failed.",
>                    TimeValue (GetDefaultCtsAckTimeout ()),
>                    MakeTimeAccessor (&WifiMac::SetCtsTimeout,
>                                      &WifiMac::GetCtsTimeout),
>                    MakeTimeChecker ())
>     .AddAttribute ("AckTimeout", "When this timeout expires, the DATA/ACK handshake has failed.",
210,227d210
< WifiMac::DoDispose ()
< {
<   m_device = 0;
< }
< 
< void
< WifiMac::SetDevice (const Ptr<NetDevice> device)
< {
<   m_device = device;
< }
< 
< Ptr<NetDevice>
< WifiMac::GetDevice (void) const
< {
<   return m_device;
< }
< 
< void
234,239d216
< Time
< WifiMac::GetMaxPropagationDelay (void) const
< {
<   return m_maxPropagationDelay;
< }
< 
271,276d247
< WifiMac::RegisterBandChangedCallback (BandChangedCallback callback)
< {
<   m_bandChangedCallback = callback;
< }
< 
< void
280d250
<   m_standard = standard;
310,315d279
<     case WIFI_PHY_STANDARD_80211ad:
<       Configure80211ad ();
<       break;
<     case WIFI_PHY_STANDARD_80211ay:
<       Configure80211ay ();
<       break;
330,335d293
< WifiPhyStandard
< WifiMac::GetCurrentstandard (void) const
< {
<   return m_standard;
< }
< 
343a302
>   SetCtsTimeout (MicroSeconds (16 + 44 + 9 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
354a314
>   SetCtsTimeout (MicroSeconds (10 + 304 + 20 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
369a330
>   SetCtsTimeout (MicroSeconds (10 + 304 + 20 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
380a342
>   SetCtsTimeout (MicroSeconds (32 + 88 + 13 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
391a354
>   SetCtsTimeout (MicroSeconds (64 + 176 + 21 + GetDefaultMaxPropagationDelay ().GetMicroSeconds () * 2));
433,481d395
<   SetCompressedBlockAckTimeout (GetSifs () + GetSlot () + MicroSeconds (85) + GetDefaultMaxPropagationDelay () * 2);
< }
< 
< //// WIGIG ////
< /*
<  * Physical Layer Characteristics for IEEE 802.11ad.
<  */
< void
< WifiMac::Configure80211ad (void)
< {
<   SetRifs (MicroSeconds (1));	/* aRIFSTime in Table 21-31 */
<   SetSifs (MicroSeconds (3));	/* aSIFSTime in Table 21-31 */
<   SetSlot (MicroSeconds (5));	/* aSlotTime in Table 21-31 */
<   SetMaxPropagationDelay (NanoSeconds (100));	/* aAirPropagationTime << 0.1 usec in Table 21-31 */
<   SetPifs (GetSifs () + GetSlot ());	/* 802.11-2007 9.2.10 */
<   SetEifsNoDifs (GetSifs () + NanoSeconds (13164));
<   /* ACK is sent using SC-MCS1, ACK Size = 14 Bytes, PayloadDuration = 618 ns, TotalTx = 3091 ns */
< //  SetAckTimeout (GetSifs () + NanoSeconds (3091) + GetSlot () + GetMaxPropagationDelay () * 2);
<   /* We need to distinguish between two ACK MCS */
<   /* ACK is sent using MCS-0, ACK Size = 14 Bytes, PayloadDuration = 4218 ns, TotalTx = 13164 ns */
<   SetAckTimeout (GetSifs () + NanoSeconds (13164) + GetSlot () + GetMaxPropagationDelay () * 2);
<   /* BlockAck is sent using either MCS-0 or SC-MCS-1/4, we assume MCS-0 in our calculation */
<   /* BasicBlockAck Size = 152 Bytes */
<   SetBasicBlockAckTimeout (GetSifs () + GetSlot () + MicroSeconds (52) + GetDefaultMaxPropagationDelay () * 2);
<   /* CompressedBlockAck Size = 32 Bytes = 18.836 ns using MCS-0 */
<   SetCompressedBlockAckTimeout (GetSifs () + GetSlot () + MicroSeconds (19) + GetDefaultMaxPropagationDelay () * 2);
< }
< 
< /*
<  * Physical Layer Characteristics for IEEE 802.11ay.
<  */
< void
< WifiMac::Configure80211ay (void)
< {
<   SetRifs (MicroSeconds (1));	/* aRIFSTime in Table 21-31 */
<   SetSifs (MicroSeconds (3));	/* aSIFSTime in Table 21-31 */
<   SetSlot (MicroSeconds (5));	/* aSlotTime in Table 21-31 */
<   SetMaxPropagationDelay (NanoSeconds (100));	/* aAirPropagationTime << 0.1 usec in Table 21-31 */
<   SetPifs (GetSifs () + GetSlot ());	/* 802.11-2007 9.2.10 */
<   SetEifsNoDifs (GetSifs () + NanoSeconds (14473));
<   /* ACK is sent using SC-MCS1, ACK Size = 14 Bytes, PayloadDuration = 618 ns, TotalTx = 3091 */
< //  SetAckTimeout (GetSifs () + NanoSeconds (3091) + GetSlot () + GetMaxPropagationDelay () * 2);
<   /* We need to distinguish between two ACK MCS */
<   SetAckTimeout (GetSifs () + NanoSeconds (14473) + GetSlot () + GetMaxPropagationDelay () * 2);
<   /* BlockAck is sent using either MCS-0 or SC-MCS-1/4, we assume MCS-0 in our calculation */
<   /* BasicBlockAck Size = 152 Bytes */
<   SetBasicBlockAckTimeout (GetSifs () + GetSlot () + NanoSeconds (55927) + GetDefaultMaxPropagationDelay () * 2);
<   /* BasicBlockAck Size = 153 Bytes considering Window Size of 1024 and sent using EDMG_MCS0 */
<   SetCompressedBlockAckTimeout (GetSifs () + GetSlot () + NanoSeconds (56073) + GetDefaultMaxPropagationDelay () * 2);
483d396
< //// WIGIG ////
489c402
<   /* see IEEE 802.11 section 7.3.2.29 */
---
>   /* see IEE802.11 section 7.3.2.29 */
540,560d452
< }
< 
< Ptr<HtConfiguration>
< WifiMac::GetHtConfiguration (void) const
< {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<       return device->GetHtConfiguration ();
< }
< 
< Ptr<VhtConfiguration>
< WifiMac::GetVhtConfiguration (void) const
< {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<       return device->GetVhtConfiguration ();
< }
< 
< Ptr<HeConfiguration>
< WifiMac::GetHeConfiguration (void) const
< {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<       return device->GetHeConfiguration ();
diff ../../NS3-WiGig/src/wifi/model/wifi-mac.h ../../ns-3-dev-git/src/wifi/model/wifi-mac.h
24d23
< #include "ns3/net-device.h"
33,35d31
< class HtConfiguration;
< class VhtConfiguration;
< class HeConfiguration;
49,50d44
<   virtual void DoDispose ();
< 
58,70d51
<    * Sets the device this PHY is associated with.
<    *
<    * \param device the device this PHY is associated with
<    */
<   void SetDevice (const Ptr<NetDevice> device);
<   /**
<    * Return the device this PHY is associated with
<    *
<    * \return the device this PHY is associated with
<    */
<   Ptr<NetDevice> GetDevice (void) const;
< 
<   /**
75c56
<    * \param sifs the SIFS duration
---
>    * \param sifs the sifs duration
86c67
<    * \param pifs the PIFS duration.
---
>    * \param pifs the pifs duration.
90c71
<    * \param rifs the RIFS duration.
---
>    * \param rifs the rifs duration.
94c75,79
<    * \param ackTimeout the duration of an Ack timeout.
---
>    * \param ctsTimeout the duration of a CTS timeout.
>    */
>   virtual void SetCtsTimeout (Time ctsTimeout) = 0;
>   /**
>    * \param ackTimeout the duration of an ACK timeout.
104c89
<    * \param ssid the current SSID of this MAC layer.
---
>    * \param ssid the current ssid of this MAC layer.
108,109d92
<    * Enable or disable short slot time feature.
<    *
144c127
<    * \return the current Ack timeout duration.
---
>    * \return the current CTS timeout duration.
146c129
<   virtual Time GetAckTimeout (void) const = 0;
---
>   virtual Time GetCtsTimeout (void) const = 0;
148,150c131
<    * \return the maximum propagation delay.
<    *
<    * Unused for now.
---
>    * \return the current ACK timeout duration.
152c133
<   Time GetMaxPropagationDelay (void) const;
---
>   virtual Time GetAckTimeout (void) const = 0;
158c139
<    * \return the SSID which this MAC layer is going to try to stay in.
---
>    * \return the ssid which this MAC layer is going to try to stay in.
166c147
<    * \return the BSSID of the network this device belongs to.
---
>    * \return the bssid of the network this device belongs to.
172a154,157
>   /**
>    * \return whether the device supports RIFS capability.
>    */
>   virtual bool GetRifsSupported (void) const = 0;
179c164
<    * The packet should be enqueued in a TX queue, and should be
---
>    * The packet should be enqueued in a tx queue, and should be
185c170
<   virtual void Enqueue (Ptr<Packet> packet, Mac48Address to, Mac48Address from) = 0;
---
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to, Mac48Address from) = 0;
190c175
<    * The packet should be enqueued in a TX queue, and should be
---
>    * The packet should be enqueued in a tx queue, and should be
194c179
<   virtual void Enqueue (Ptr<Packet> packet, Mac48Address to) = 0;
---
>   virtual void Enqueue (Ptr<const Packet> packet, Mac48Address to) = 0;
208c193
<    * \return the physical layer attached to this MAC
---
>    * \return currently attached WifiPhy device
212c197
<    * Remove currently attached WifiPhy device from this MAC.
---
>    * remove currently attached WifiPhy device from this MAC.
225,226c210
<    * \param upCallback the callback to invoke when a packet must be
<    *        forwarded up the stack.
---
>    * \param upCallback the callback to invoke when a packet must be forwarded up the stack.
228c212
<   virtual void SetForwardUpCallback (Callback<void, Ptr<const Packet>, Mac48Address, Mac48Address> upCallback) = 0;
---
>   virtual void SetForwardUpCallback (Callback<void,Ptr<Packet>, Mac48Address, Mac48Address> upCallback) = 0;
237c221
<   /* Next functions are not pure virtual so non QoS WifiMacs are not
---
>   /* Next functions are not pure virtual so non Qos WifiMacs are not
242c226
<    * \param blockAckTimeout the duration for basic BlockAck timeout.
---
>    * \param blockAckTimeout the duration for basic block ACK timeout.
244c228
<    * Sets the timeout for basic BlockAck.
---
>    * Sets the timeout for basic block ACK.
248c232
<    * \return the current basic BlockAck timeout duration.
---
>    * \return the current basic block ACK timeout duration.
252c236
<    * \param blockAckTimeout the duration for compressed BlockAck timeout
---
>    * \param blockAckTimeout
254c238
<    * Sets the timeout for compressed BlockAck.
---
>    * Sets the timeout for compressed block ACK.
258c242
<    * \return the current compressed BlockAck timeout duration.
---
>    * \return the current compressed block ACK timeout duration.
301c285
<    * parameters such as SIFS time, slot time, timeout values, etc.,
---
>    * parameters such as sifs time, slot time, timeout values, etc.,
314,315d297
<    * \sa WifiMac::Configure80211ad
<    * \sa WifiMac::Configure80211ay
318,337d299
<   WifiPhyStandard GetCurrentstandard (void) const;
< 
<   //// WIGIG ////
<   typedef Callback<void, WifiPhyStandard, Mac48Address, bool> BandChangedCallback;
<   void RegisterBandChangedCallback (BandChangedCallback callback);
<   virtual void NotifyBandChanged (WifiPhyStandard, Mac48Address address, bool isInitiator) = 0;
<   //// WIGIG ////
< 
<   /**
<    * \return pointer to HtConfiguration if it exists
<    */
<   Ptr<HtConfiguration> GetHtConfiguration (void) const;
<   /**
<    * \return pointer to VhtConfiguration if it exists
<    */
<   Ptr<VhtConfiguration> GetVhtConfiguration (void) const;
<   /**
<    * \return pointer to HeConfiguration if it exists
<    */
<   Ptr<HeConfiguration> GetHeConfiguration (void) const;
343,344c305,306
<    * \param cwmin the minimum contention window for the DCF
<    * \param cwmax the maximum contention window for the DCF
---
>    * \param cwmin the minimum congestion window for the DCF
>    * \param cwmax the maximum congestion window for the DCF
352,366d313
<   //// WIGIG ////
<   /**
<    * This method sets 802.11ad 60 GHz standards-compliant defaults for following attributes:
<    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
<    */
<   virtual void Configure80211ad (void);
<   /**
<    * This method sets 802.11ay 60 GHz standards-compliant defaults for following attributes:
<    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
<    */
<   virtual void Configure80211ay (void);
< 
<   WifiPhyStandard m_standard;
<   BandChangedCallback m_bandChangedCallback;
<   //// WIGIG ////
398c345
<    * Return default SIFS + default CTS-Ack delay
---
>    * Return default SIFS + default CTS-ACK delay
402c349
<    * \return the default CTS-Ack delay
---
>    * \return the default CTS-ACK delay
408c355
<    * \return the default CTS and Ack timeout
---
>    * \return the default CTS and ACK timeout
410c357
<    * Return the default CTS and Ack timeout.
---
>    * Return the default CTS and ACK timeout.
417c364
<    * Return the default basic BlockAck delay.
---
>    * Return the default basic block ACK delay.
420c367
<    * \return the default basic BlockAck delay
---
>    * \return the default basic block ACK delay
424c371
<    * Return the default basic BlockAck timeout.
---
>    * Return the default basic block ACK timeout.
426c373
<    * \return the default basic BlockAck timeout
---
>    * \return the default basic block ACK timeout
430c377
<    * Return the default compressed BlockAck delay.
---
>    * Return the default compressed block ACK delay.
433c380
<    * \return the default compressed BlockAck delay
---
>    * \return the default compressed block ACK delay
437c384
<    * Return the default compressed BlockAck timeout.
---
>    * Return the default compressed block ACK timeout.
439c386
<    * \return the default compressed BlockAck timeout
---
>    * \return the default compressed block ACK timeout
444c391
<    * \param standard the PHY standard to be used
---
>    * \param standard the phy standard to be used
447,448c394,395
<    * the configuration process for a requested PHY standard. Subclasses should
<    * implement this method to configure their DCF queues according to the
---
>    * the configuration process for a requested phy standard. Subclasses should
>    * implement this method to configure their dcf queues according to the
454d400
<   Ptr<NetDevice> m_device;    ///< Pointer to the device
458c404
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
463c409
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
468c414
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
473,474c419,420
<    * This method sets 802.11 with 10 MHz channel spacing standards-compliant defaults
<    * for following attributes: SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * This method sets 802.11 with 10Mhz channel spacing standards-compliant defaults
>    * for following attributes: Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
478,479c424,425
<    * This method sets 802.11 with 5 MHz channel spacing standards-compliant defaults
<    * for following attributes: SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * This method sets 802.11 with 5Mhz channel spacing standards-compliant defaults
>    * for following attributes: Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
484c430
<    * SIFS, RIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Rifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
490c436
<    * SIFS, RIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Rifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
495c441
<   * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>   * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
500c446
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
506c452
<    * SIFS, Slot, EifsNoDifs, PIFS, CtsTimeout, and AckTimeout.
---
>    * Sifs, Slot, EifsNoDifs, Pifs, CtsTimeout, and AckTimeout.
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-header.cc ../../ns-3-dev-git/src/wifi/model/wifi-mac-header.cc
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
22d20
<  *          Hany Assasa <hany.assasa@gmail.com>
38,39c36
<   TYPE_DATA = 2,
<   TYPE_Extension = 3  // Extension frame type for DMG.
---
>   TYPE_DATA = 2
45c42
<   SUBTYPE_CTL_EXTENSION = 6, // Extension subtype for DMG Control Frame Extension.
---
>   //Reserved: 0 - 6
56,71d52
< /*
<  * Enumeration for DMG Control Frame Extension.
<  */
< enum
< {
<   SUBTYPE_CTL_EXTENSION_POLL = 2,
<   SUBTYPE_CTL_EXTENSION_SPR = 3,
<   SUBTYPE_CTL_EXTENSION_GRANT = 4,
<   SUBTYPE_CTL_EXTENSION_DMG_CTS = 5,
<   SUBTYPE_CTL_EXTENSION_DMG_DTS = 6,
<   SUBTYPE_CTL_EXTENSION_GRANT_ACK = 7,
<   SUBTYPE_CTL_EXTENSION_SSW = 8,
<   SUBTYPE_CTL_EXTENSION_SSW_FBCK = 9,
<   SUBTYPE_CTL_EXTENSION_SSW_ACK = 10
< };
< 
76,81c57
<     m_amsduPresent (0),
<     m_dmgPpdu (false),
<     m_beamRefinementRequired (false),
<     m_beamTrackingRequired (false),
<     m_trainingFieldLength (0),
<     m_edmgTrainingFieldLength (0)
---
>     m_amsduPresent (0)
174,218d149
<     case WIFI_MAC_CTL_DMG_POLL:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_POLL;
<       break;
<     case WIFI_MAC_CTL_DMG_SPR:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_SPR;
<       break;
<     case WIFI_MAC_CTL_DMG_GRANT:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_GRANT;
<       break;
<     case WIFI_MAC_CTL_DMG_CTS:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_DMG_CTS;
<       break;
<     case WIFI_MAC_CTL_DMG_DTS:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_DMG_DTS;
<       break;
<     case WIFI_MAC_CTL_DMG_SSW:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_SSW;
<       break;
<     case WIFI_MAC_CTL_DMG_SSW_FBCK:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_SSW_FBCK;
<       break;
<     case WIFI_MAC_CTL_DMG_SSW_ACK:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_SSW_ACK;
<       break;
<     case WIFI_MAC_CTL_DMG_GRANT_ACK:
<       m_ctrlType = TYPE_CTL;
<       m_ctrlSubtype = SUBTYPE_CTL_EXTENSION;
<       m_ctrlFrameExtension = SUBTYPE_CTL_EXTENSION_GRANT_ACK;
<       break;
331,334d261
<     case WIFI_MAC_EXTENSION_DMG_BEACON:
<       m_ctrlType = TYPE_Extension;
<       m_ctrlSubtype = 0;
<       break;
358,359c285
< void
< WifiMacHeader::SetId (uint16_t id)
---
> void WifiMacHeader::SetId (uint16_t id)
364,365c290
< void
< WifiMacHeader::SetSequenceNumber (uint16_t seq)
---
> void WifiMacHeader::SetSequenceNumber (uint16_t seq)
370,371c295
< void
< WifiMacHeader::SetFragmentNumber (uint8_t frag)
---
> void WifiMacHeader::SetFragmentNumber (uint8_t frag)
376,377c300
< void
< WifiMacHeader::SetNoMoreFragments (void)
---
> void WifiMacHeader::SetNoMoreFragments (void)
382,383c305
< void
< WifiMacHeader::SetMoreFragments (void)
---
> void WifiMacHeader::SetMoreFragments (void)
388,389c310
< void
< WifiMacHeader::SetOrder (void)
---
> void WifiMacHeader::SetOrder (void)
394,395c315
< void
< WifiMacHeader::SetNoOrder (void)
---
> void WifiMacHeader::SetNoOrder (void)
400,401c320
< void
< WifiMacHeader::SetRetry (void)
---
> void WifiMacHeader::SetRetry (void)
406,407c325
< void
< WifiMacHeader::SetNoRetry (void)
---
> void WifiMacHeader::SetNoRetry (void)
412,425c330
< void
< WifiMacHeader::SetMoreData (void)
< {
<   m_ctrlMoreData = 1;
< }
< 
< void
< WifiMacHeader::SetNoMoreData (void)
< {
<   m_ctrlMoreData = 0;
< }
< 
< void
< WifiMacHeader::SetQosTid (uint8_t tid)
---
> void WifiMacHeader::SetQosTid (uint8_t tid)
430,431c335
< void
< WifiMacHeader::SetQosEosp ()
---
> void WifiMacHeader::SetQosEosp ()
436,437c340
< void
< WifiMacHeader::SetQosNoEosp ()
---
> void WifiMacHeader::SetQosNoEosp ()
461,478d363
< void
< WifiMacHeader::SetQosNormalAck ()
< {
<   m_qosAckPolicy = 0;
< }
< 
< void
< WifiMacHeader::SetQosBlockAck ()
< {
<   m_qosAckPolicy = 3;
< }
< 
< void
< WifiMacHeader::SetQosNoAck ()
< {
<   m_qosAckPolicy = 1;
< }
< 
582,603c467,470
<         case SUBTYPE_CTL_EXTENSION:
<           switch (m_ctrlFrameExtension)
<             {
<             case SUBTYPE_CTL_EXTENSION_POLL:
<               return WIFI_MAC_CTL_DMG_POLL;
<             case SUBTYPE_CTL_EXTENSION_SPR:
<               return WIFI_MAC_CTL_DMG_SPR;
<             case SUBTYPE_CTL_EXTENSION_GRANT:
<               return WIFI_MAC_CTL_DMG_GRANT;
<             case SUBTYPE_CTL_EXTENSION_DMG_CTS:
<               return WIFI_MAC_CTL_DMG_CTS;
<             case SUBTYPE_CTL_EXTENSION_DMG_DTS:
<               return WIFI_MAC_CTL_DMG_DTS;
<             case SUBTYPE_CTL_EXTENSION_GRANT_ACK:
<               return WIFI_MAC_CTL_DMG_GRANT_ACK;
<             case SUBTYPE_CTL_EXTENSION_SSW:
<               return WIFI_MAC_CTL_DMG_SSW;
<             case SUBTYPE_CTL_EXTENSION_SSW_FBCK:
<               return WIFI_MAC_CTL_DMG_SSW_FBCK;
<             case SUBTYPE_CTL_EXTENSION_SSW_ACK:
<               return WIFI_MAC_CTL_DMG_SSW_ACK;
<             }
---
>         case SUBTYPE_CTL_END:
>           return WIFI_MAC_CTL_END;
>         case SUBTYPE_CTL_END_ACK:
>           return WIFI_MAC_CTL_END_ACK;
640,648c507
< 	break;
< 
<     case TYPE_Extension:
<       switch (m_ctrlSubtype)
<         {
<         case 0:
<           return WIFI_MAC_EXTENSION_DMG_BEACON;
<         }
<         break;
---
>       break;
670a530
> 
692,697d551
< WifiMacHeader::IsExtension (void) const
< {
<   return (m_ctrlType == TYPE_Extension);
< }
< 
< bool
778,789d631
< WifiMacHeader::IsDmgCts (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_CTS);
< }
< 
< bool
< WifiMacHeader::IsDmgDts (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_DTS);
< }
< 
< bool
862,867d703
< WifiMacHeader::IsActionNoAck () const
< {
<   return (GetType () == WIFI_MAC_MGT_ACTION_NO_ACK);
< }
< 
< bool
885,926d720
< bool
< WifiMacHeader::IsDMGBeacon (void) const
< {
<   return (GetType () == WIFI_MAC_EXTENSION_DMG_BEACON);
< }
< 
< bool
< WifiMacHeader::IsSSW (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_SSW);
< }
< 
< bool
< WifiMacHeader::IsSSW_FBCK (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_SSW_FBCK);
< }
< 
< bool
< WifiMacHeader::IsSSW_ACK (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_SSW_ACK);
< }
< 
< bool
< WifiMacHeader::IsPollFrame (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_POLL);
< }
< 
< bool
< WifiMacHeader::IsSprFrame (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_SPR);
< }
< 
< bool
< WifiMacHeader::IsGrantFrame (void) const
< {
<   return (GetType () == WIFI_MAC_CTL_DMG_GRANT);
< }
< 
964,969d757
< WifiMacHeader::IsMoreData (void) const
< {
<   return (m_ctrlMoreData == 1);
< }
< 
< bool
1003,1028d790
< WifiMacHeader::QosAckPolicy
< WifiMacHeader::GetQosAckPolicy (void) const
< {
<   NS_ASSERT (IsQosData ());
<   QosAckPolicy policy;
< 
<   switch (m_qosAckPolicy)
<     {
<     case 0:
<       policy = NORMAL_ACK;
<       break;
<     case 1:
<       policy = NO_ACK;
<       break;
<     case 2:
<       policy = NO_EXPLICIT_ACK;
<       break;
<     case 3:
<       policy = BLOCK_ACK;
<       break;
<     default:
<       NS_ABORT_MSG ("Unknown QoS Ack policy");
<     }
<   return policy;
< }
< 
1048a811,814
>   val |= (m_ctrlToDs << 8) & (0x1 << 8);
>   val |= (m_ctrlFromDs << 9) & (0x1 << 9);
>   val |= (m_ctrlMoreFrag << 10) & (0x1 << 10);
>   val |= (m_ctrlRetry << 11) & (0x1 << 11);
1052,1066d817
< 
<   if ((m_ctrlType == 1) && (m_ctrlSubtype == 6))
<     {
<       /* Frame Control for DMG */
<       val |= (m_ctrlFrameExtension << 8) & (0xf << 8);
<     }
<   else
<     {
<       /* Frame Control for Non-DMG */
<       val |= (m_ctrlToDs << 8) & (0x1 << 8);
<       val |= (m_ctrlFromDs << 9) & (0x1 << 9);
<       val |= (m_ctrlMoreFrag << 10) & (0x1 << 10);
<       val |= (m_ctrlRetry << 11) & (0x1 << 11);
<     }
< 
1078,1087c829
<   if (m_dmgPpdu)
<     {
<       val |= m_qosAmsduType << 8;
<       val |= m_qosRdg << 9;
<       val |= m_qosAcConstraint << 15;
<     }
<   else
<     {
<       val |= m_qosStuff << 8;
<     }
---
>   val |= m_qosStuff << 8;
1096,1115c838,844
< 
<   if ((m_ctrlType == 1) && (m_ctrlSubtype == 6))
<     {
<       /* Frame Control for DMG */
<       m_ctrlFrameExtension = (ctrl >> 8) & 0x0F;
<       m_ctrlMoreData = (ctrl >> 13) & 0x01;
<       m_ctrlWep = (ctrl >> 14) & 0x01;
<       m_ctrlOrder = (ctrl >> 15) & 0x01;
<     }
<   else
<     {
<       /* Frame Control for Non-DMG */
<       m_ctrlToDs = (ctrl >> 8) & 0x01;
<       m_ctrlFromDs = (ctrl >> 9) & 0x01;
<       m_ctrlMoreFrag = (ctrl >> 10) & 0x01;
<       m_ctrlRetry = (ctrl >> 11) & 0x01;
<       m_ctrlMoreData = (ctrl >> 13) & 0x01;
<       m_ctrlWep = (ctrl >> 14) & 0x01;
<       m_ctrlOrder = (ctrl >> 15) & 0x01;
<     }
---
>   m_ctrlToDs = (ctrl >> 8) & 0x01;
>   m_ctrlFromDs = (ctrl >> 9) & 0x01;
>   m_ctrlMoreFrag = (ctrl >> 10) & 0x01;
>   m_ctrlRetry = (ctrl >> 11) & 0x01;
>   m_ctrlMoreData = (ctrl >> 13) & 0x01;
>   m_ctrlWep = (ctrl >> 14) & 0x01;
>   m_ctrlOrder = (ctrl >> 15) & 0x01;
1117d845
< 
1124d851
< 
1132,1141c859
<   if (m_dmgPpdu)
<     {
<       m_qosAmsduType = (qos >> 8) & 0x1;
<       m_qosRdg = (qos >> 9) & 0x1;
<       m_qosAcConstraint = (qos >> 15) & 0x1;
<     }
<   else
<     {
<       m_qosStuff = (qos >> 8) & 0x00ff;
<     }
---
>   m_qosStuff = (qos >> 8) & 0x00ff;
1170,1186d887
<         case SUBTYPE_CTL_EXTENSION:
<           switch (m_ctrlFrameExtension)
<             {
<             case SUBTYPE_CTL_EXTENSION_POLL:
<             case SUBTYPE_CTL_EXTENSION_SPR:
<             case SUBTYPE_CTL_EXTENSION_GRANT:
<             case SUBTYPE_CTL_EXTENSION_DMG_CTS:
<             case SUBTYPE_CTL_EXTENSION_SSW:
<             case SUBTYPE_CTL_EXTENSION_SSW_FBCK:
<             case SUBTYPE_CTL_EXTENSION_SSW_ACK:
<             case SUBTYPE_CTL_EXTENSION_GRANT_ACK:
<               size = 2 + 2 + 6 + 6;
<               break;
<             case SUBTYPE_CTL_EXTENSION_DMG_DTS:
<               size = 2 + 2 + 6;
<               break;
<             }
1200,1202d900
<     case TYPE_Extension:
<       size = 2 + 2 + 6;
<       break;
1207,1257d904
< void
< WifiMacHeader::SetAsDmgPpdu (void)
< {
<   m_dmgPpdu = true;
<   m_ctrlOrder = 0;
< }
< 
< bool
< WifiMacHeader::IsDmgPpdu (void) const
< {
<   return m_dmgPpdu;
< }
< 
< void
< WifiMacHeader::SetQosAmsduType (AMSDU_Type type)
< {
<   m_qosAmsduType = static_cast<uint8_t> (type);
< }
< 
< void WifiMacHeader::SetQosRdGrant (bool value)
< {
<   m_qosRdg = value;
< }
< 
< void
< WifiMacHeader::SetQosAcConstraint (bool value)
< {
<   m_qosAcConstraint = value;
< }
< 
< AMSDU_Type
< WifiMacHeader::GetQosAmsduType (void) const
< {
<   NS_ASSERT (m_dmgPpdu && IsQosData ());
<   return static_cast<AMSDU_Type> (m_qosAmsduType);
< }
< 
< bool
< WifiMacHeader::IsQosRdGrant (void) const
< {
<   NS_ASSERT (m_dmgPpdu && IsQosData ());
<   return (m_qosRdg == 1);
< }
< 
< bool
< WifiMacHeader::GetQosAcConstraint (void) const
< {
<   NS_ASSERT (m_dmgPpdu && IsQosData ());
<   return m_qosAcConstraint;
< }
< 
1276,1287d922
<       FOO (CTL_DMG_POLL);
<       FOO (CTL_DMG_SPR);
<       FOO (CTL_DMG_GRANT);
<       FOO (CTL_DMG_CTS);
<       FOO (CTL_DMG_DTS);
<       FOO (CTL_DMG_GRANT_ACK);
<       FOO (CTL_DMG_SSW);
<       FOO (CTL_DMG_SSW_FBCK);
<       FOO (CTL_DMG_SSW_ACK);
< 
<       FOO (EXTENSION_DMG_BEACON);
< 
1422,1431d1056
<     case WIFI_MAC_CTL_DMG_POLL:
<     case WIFI_MAC_CTL_DMG_SPR:
<     case WIFI_MAC_CTL_DMG_GRANT:
<     case WIFI_MAC_CTL_DMG_CTS:
<     case WIFI_MAC_CTL_DMG_DTS:
<     case WIFI_MAC_CTL_DMG_SSW:
<     case WIFI_MAC_CTL_DMG_SSW_FBCK:
<     case WIFI_MAC_CTL_DMG_SSW_ACK:
<     case WIFI_MAC_CTL_DMG_GRANT_ACK:
<     case WIFI_MAC_EXTENSION_DMG_BEACON:
1488,1504d1112
<         case SUBTYPE_CTL_EXTENSION:
<           switch (m_ctrlFrameExtension)
<             {
<             case SUBTYPE_CTL_EXTENSION_POLL:
<             case SUBTYPE_CTL_EXTENSION_SPR:
<             case SUBTYPE_CTL_EXTENSION_GRANT:
<             case SUBTYPE_CTL_EXTENSION_DMG_CTS:
<             case SUBTYPE_CTL_EXTENSION_GRANT_ACK:
<             case SUBTYPE_CTL_EXTENSION_SSW:
<             case SUBTYPE_CTL_EXTENSION_SSW_FBCK:
<             case SUBTYPE_CTL_EXTENSION_SSW_ACK:
<               WriteTo(i, m_addr2); // TA Address Field.
<               break;
<             case SUBTYPE_CTL_EXTENSION_DMG_DTS:
<               break;
<             }
<           break;
1525,1526d1132
<     case TYPE_Extension:
<       break;
1562,1578d1167
<         case SUBTYPE_CTL_EXTENSION:
<           switch (m_ctrlFrameExtension)
<             {
<             case SUBTYPE_CTL_EXTENSION_POLL:
<             case SUBTYPE_CTL_EXTENSION_SPR:
<             case SUBTYPE_CTL_EXTENSION_GRANT:
<             case SUBTYPE_CTL_EXTENSION_DMG_CTS:
<             case SUBTYPE_CTL_EXTENSION_GRANT_ACK:
<             case SUBTYPE_CTL_EXTENSION_SSW:
<             case SUBTYPE_CTL_EXTENSION_SSW_FBCK:
<             case SUBTYPE_CTL_EXTENSION_SSW_ACK:
<               ReadFrom(i, m_addr2); // TA Address Field.
<               break;
<             case SUBTYPE_CTL_EXTENSION_DMG_DTS:
<               break;
<             }
<           break;
1594,1595d1182
<     case TYPE_Extension:
<       break;
1598,1671d1184
< }
< 
< /* 802.11ad Functions */
< 
< void
< WifiMacHeader::SetPacketType (PacketType type)
< {
<   m_brpPacketType = type;
< }
< 
< PacketType
< WifiMacHeader::GetPacketType (void) const
< {
<   return m_brpPacketType;
< }
< 
< void
< WifiMacHeader::SetTrainngFieldLength (uint8_t length)
< {
<   m_trainingFieldLength = length;
< }
< 
< uint8_t
< WifiMacHeader::GetTrainngFieldLength (void) const
< {
<   return m_trainingFieldLength;
< }
< 
< void
< WifiMacHeader::SetEdmgTrainingFieldLength (uint8_t length)
< {
<   m_edmgTrainingFieldLength = length;
< }
< 
< uint8_t
< WifiMacHeader::GetEdmgTrainingFieldLength (void) const
< {
<   return m_edmgTrainingFieldLength;
< }
< 
< void
< WifiMacHeader::RequestBeamRefinement (void)
< {
<   m_beamRefinementRequired = true;
< }
< 
< void
< WifiMacHeader::DisableBeamRefinement (void)
< {
<   m_beamRefinementRequired = false;
< }
< 
< bool
< WifiMacHeader::IsBeamRefinementRequested (void) const
< {
<   return (m_beamRefinementRequired == true);
< }
< 
< void
< WifiMacHeader::RequestBeamTracking (void)
< {
<   m_beamTrackingRequired = true;
< }
< 
< void
< WifiMacHeader::DisableBeamTracking (void)
< {
<   m_beamTrackingRequired = false;
< }
< 
< bool
< WifiMacHeader::IsBeamTrackingRequested (void) const
< {
<   return (m_beamTrackingRequired == true);
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-header.h ../../ns-3-dev-git/src/wifi/model/wifi-mac-header.h
5d4
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
20,22c19,20
<  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
<  *          Mirko Banchi <mk.banchi@gmail.com>
<  *          Hany Assasa <hany.assasa@gmail.com>
---
>  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
>  * Author: Mirko Banchi <mk.banchi@gmail.com>
30d27
< #include "wifi-phy-standard.h"
50,60d46
<   // New Control Frames for 802.11ad.
<   WIFI_MAC_CTL_DMG_POLL,
<   WIFI_MAC_CTL_DMG_SPR,
<   WIFI_MAC_CTL_DMG_GRANT,
<   WIFI_MAC_CTL_DMG_CTS,
<   WIFI_MAC_CTL_DMG_DTS,
<   WIFI_MAC_CTL_DMG_SSW,
<   WIFI_MAC_CTL_DMG_SSW_FBCK,
<   WIFI_MAC_CTL_DMG_SSW_ACK,
<   WIFI_MAC_CTL_DMG_GRANT_ACK,
< 
90,100d75
< 
<   /*
<    *  Extension Frames for DMG.
<    */
<   WIFI_MAC_EXTENSION_DMG_BEACON,
< };
< 
< enum AMSDU_Type
< {
<   AMSDU_TYPE_BASIC = 0,
<   AMSDU_TYPE_SHORT = 1,
112c87
<    * Ack policy for QoS frames.
---
>    * ACK policy for QoS frames.
244,251d218
<    * Set the More Data bit in the Frame Control field.
<    */
<   void SetMoreData (void);
<   /**
<    * Un-set the More Data bit in the Frame Control field.
<    */
<   void SetNoMoreData (void);
<   /**
266c233
<    * Set the QoS Ack policy in the QoS control field.
---
>    * Set the QoS ACK policy in the QoS control field.
268c235
<    * \param policy the Qos Ack policy
---
>    * \param policy
272,283d238
<    * Set the QoS ACK policy in the QoS control field to normal ACK.
<    */
<   void SetQosNormalAck (void);
<   /**
<    * Set the QoS ACK policy in the QoS control field to block ACK.
<    */
<   void SetQosBlockAck (void);
<   /**
<    * Set the QoS ACK policy in the QoS control field to no ACK.
<    */
<   void SetQosNoAck (void);
<   /**
294c249
<    * \param txop the TXOP limit
---
>    * \param txop
306,330d260
<    * Set as DMG PPDU.
<    */
<   void SetAsDmgPpdu (void);
<   /**
<    * Check whether the curent PPDU is DMG
<    * \return True if the frame is DMG PPDU, otherwise false.
<    */
<   bool IsDmgPpdu (void) const;
<   /**
<    * Set the type of A-MSDU.
<    */
<   void SetQosAmsduType (AMSDU_Type type);
<   /**
<    * The RDG/More PPDU subfield of the HT Control field is interpreted differently depending on whether it is
<    * transmitted by an RD initiator or an RD responder, as defined in Table 8-13.
<    * \return
<    */
<   void SetQosRdGrant (bool value);
<   /**
<    * The AC Constraint subfield of the QoS Control field for DMG frames indicates whether the mapped AC of
<    * an RD data frame is constrained to a single AC, as defined in Table 8-12
<    * \return
<    */
<   void SetQosAcConstraint (bool value);
<   /**
380c310
<    * Data with QoS)
---
>    * DATA with QoS)
387c317
<    * possible values for QoS Data.
---
>    * possible values for QoS DATA.
412,417d341
<    * Return true if the Type is Extension.
<    *
<    * \return true if Type is Extension, false otherwise
<    */
<   bool IsExtension (void) const;
<   /**
424c348
<    * Return true if the header is a CF-Ack header.
---
>    * Return true if the header is a CF-ACK header.
426c350
<    * \return true if the header is a CF-Ack header, false otherwise
---
>    * \return true if the header is a CF_ACK header, false otherwise
430c354
<    * Return true if the header is a CF-End header.
---
>    * Return true if the header is a CF-END header.
432c356
<    * \return true if the header is a CF-End header, false otherwise
---
>    * \return true if the header is a CF_END header, false otherwise
448,460c372
<    * Return true if the header is a DMG CTS header.
<    *
<    * \return true if the header is a DMG CTS header, false otherwise
<    */
<   bool IsDmgCts (void) const;
<   /**
<    * Return true if the header is a DTS header.
<    *
<    * \return true if the header is a DTS header, false otherwise
<    */
<   bool IsDmgDts (void) const;
<   /**
<    * Return true if the header is an Ack header.
---
>    * Return true if the header is an ACK header.
462c374
<    * \return true if the header is an Ack header, false otherwise
---
>    * \return true if the header is an ACK header, false otherwise
466c378
<    * Return true if the header is a BlockAckRequest header.
---
>    * Return true if the header is a Block ACK Request header.
468c380
<    * \return true if the header is a BlockAckRequest header, false otherwise
---
>    * \return true if the header is a Block ACK Request header, false otherwise
472c384
<    * Return true if the header is a BlockAck header.
---
>    * Return true if the header is a Block ACK header.
474c386
<    * \return true if the header is a BlockAck header, false otherwise
---
>    * \return true if the header is a Block ACK header, false otherwise
520,561d431
<    * Return true if the header is a DMG Beacon header.
<    *
<    * \return true if the header is a DMG Beacon header, false otherwise
<    */
<   bool IsDMGBeacon (void) const;
<   /**
<    * Return true if the header is a SSW header.
<    *
<    * \return true if the header is a SSW header, false otherwise
<    */
<   bool IsSSW (void) const;
<   /**
<    * Return true if the header is a SSW-Feedback header.
<    *
<    * \return true if the header is a SSW-Feedback header, false otherwise
<    */
<   bool IsSSW_FBCK (void) const;
<   /**
<    * Return true if the header is a SSW-ACK header.
<    *
<    * \return true if the header is a SSW-ACK header, false otherwise
<    */
<   bool IsSSW_ACK (void) const;
<   /**
<    * Return true if the header is a Poll header.
<    *
<    * \return true if the header is a Poll header, false otherwise
<    */
<   bool IsPollFrame (void) const;
<   /**
<    * Return true if the header is a SPR header.
<    *
<    * \return true if the header is a SPR header, false otherwise
<    */
<   bool IsSprFrame (void) const;
<   /**
<    * Return true if the header is a Grant header.
<    *
<    * \return true if the header is a Grant header, false otherwise
<    */
<   bool IsGrantFrame (void) const;
<   /**
584,590c454
<   bool IsAction (void) const;
<   /**
<    * Return true if the header is an Action No Ack header.
<    *
<    * \return true if the header is an Action No Ack header, false otherwise
<    */
<   bool IsActionNoAck (void) const;
---
>   bool IsAction () const;
597c461
<   bool IsMultihopAction (void) const;
---
>   bool IsMultihopAction () const;
635,640d498
<    * Return if the More Data bit is set.
<    *
<    * \return true if the More Data bit is set, false otherwise
<    */
<   bool IsMoreData (void) const;
<   /**
647c505
<    * Return if the QoS Ack policy is Block Ack.
---
>    * Return if the QoS ACK policy is Block ACK.
649c507
<    * \return true if the QoS Ack policy is Block Ack, false otherwise
---
>    * \return true if the QoS ACK policy is Block ACK, false otherwise
653c511
<    * Return if the QoS Ack policy is No Ack.
---
>    * Return if the QoS ACK policy is No ACK.
655c513
<    * \return true if the QoS Ack policy is No Ack, false otherwise
---
>    * \return true if the QoS ACK policy is No ACK, false otherwise
659c517
<    * Return if the QoS Ack policy is Normal Ack.
---
>    * Return if the QoS ACK policy is Normal ACK.
661c519
<    * \return true if the QoS Ack policy is No Ack, false otherwise
---
>    * \return true if the QoS ACK policy is No ACK, false otherwise
684,711d541
<    * Return the QoS Ack policy in the QoS control field.
<    *
<    * \return the QoS Ack policy in the QoS control field
<    */
<   QosAckPolicy GetQosAckPolicy (void) const;
<   /**
<    * Return the TXOP limit.
<    *
<    * \return the TXOP limit
<    */
<   uint8_t GetQosTxopLimit (void) const;
<   /**
<    * Return the type of A-MSDU
<    *
<    * \return the type of A-MSDU
<    */
<   AMSDU_Type GetQosAmsduType (void) const;
<   /**
<    * Check if it is RD Grant.
<    *
<    * \return True if RDG is set, otherwise false.
<    */
<   bool IsQosRdGrant (void) const;
<   /**
<    * \return
<    */
<   bool GetQosAcConstraint (void) const;
<   /**
731,738d560
<   /**
<    * Request Beam Refinement Option.
<    */
<   void RequestBeamRefinement (void);
<   /**
<    * Disable Beam Refinement Option.
<    */
<   void DisableBeamRefinement (void);
740,782d561
<   bool IsBeamRefinementRequested (void) const;
<   /**
<    * Set BRP Packet Type.
<    * \param type The type of BRP packet.
<    */
<   void SetPacketType (PacketType type);
<   /**
<    * Get BRP Packet Type.
<    * \return The type of BRP packet.
<    */
<   PacketType GetPacketType (void) const;
<   /**
<    * Set the length of the training field.
<    * \param length The length of the training field.
<    */
<   void SetTrainngFieldLength (uint8_t length);
<   /**
<    * Get the length of the training field.
<    * \return The length of te training field.
<    */
<   uint8_t GetTrainngFieldLength (void) const;
<   /**
<    * Set the length of the EDMG training field.
<    * \param length The length of the EDMG training field.
<    */
<   void SetEdmgTrainingFieldLength (uint8_t length);
<   /**
<    * Get the length of the EDMG training field.
<    * \return The length of the EDMGtraining field.
<    */
<   uint8_t GetEdmgTrainingFieldLength (void) const;
<   /**
<    * Request Beam Tracking.
<    */
<   void RequestBeamTracking (void);
<   /**
<    * Disable Beam Tracking Capability.
<    */
<   void DisableBeamTracking (void);
<   /**
<    * \return True if Beam Tracking requested, otherwise false.
<    */
<   bool IsBeamTrackingRequested (void) const;
822,825c601,604
<   uint8_t m_ctrlType;     ///< control type
<   uint8_t m_ctrlSubtype;  ///< control subtype
<   uint8_t m_ctrlToDs;     ///< control to DS
<   uint8_t m_ctrlFromDs;   ///< control from DS
---
>   uint8_t m_ctrlType; ///< control type
>   uint8_t m_ctrlSubtype; ///< control subtype
>   uint8_t m_ctrlToDs; ///< control to DS
>   uint8_t m_ctrlFromDs; ///< control from DS
827c606
<   uint8_t m_ctrlRetry;    ///< control retry
---
>   uint8_t m_ctrlRetry; ///< control retry
829,856c608,621
<   uint8_t m_ctrlWep;      ///< control WEP
<   uint8_t m_ctrlOrder;    ///< control order (set to 1 for QoS Data and Management frames to signify that HT/VHT/HE control field is present, knowing that the latter are not implemented yet)
<   uint16_t m_duration;    ///< duration
<   Mac48Address m_addr1;   ///< address 1
<   Mac48Address m_addr2;   ///< address 2
<   Mac48Address m_addr3;   ///< address 3
<   uint8_t m_seqFrag;      ///< sequence fragment
<   uint16_t m_seqSeq;      ///< sequence sequence
<   Mac48Address m_addr4;   ///< address 4
<   uint8_t m_qosTid;       ///< QoS TID
<   uint8_t m_qosEosp;      ///< QoS EOSP
<   uint8_t m_qosAckPolicy; ///< QoS Ack policy
<   uint8_t m_amsduPresent; ///< A-MSDU present
<   uint8_t m_qosStuff;     ///< QoS stuff
< 
<   /* DMG QoS Control Field */
<   bool m_dmgPpdu;
<   uint8_t m_qosAmsduType;
<   uint8_t m_qosRdg;
<   uint8_t m_qosAcConstraint;
<   /* New fields for DMG Support. */
<   uint32_t m_ctrlFrameExtension;
<   bool m_beamRefinementRequired;
<   bool m_beamTrackingRequired;
<   PacketType m_brpPacketType;
<   uint8_t m_trainingFieldLength;
<   /* New fields for EDMG support */
<   uint8_t m_edmgTrainingFieldLength;
---
>   uint8_t m_ctrlWep; ///< control WEP
>   uint8_t m_ctrlOrder; ///< control order (set to 1 for QoS Data and Management frames to signify that HT/VHT/HE control field is present, knowing that the latter are not implemented yet)
>   uint16_t m_duration; ///< duration
>   Mac48Address m_addr1; ///< address 1
>   Mac48Address m_addr2; ///< address 2
>   Mac48Address m_addr3; ///< address 3
>   uint8_t m_seqFrag; ///< sequence fragment
>   uint16_t m_seqSeq; ///< sequence sequence
>   Mac48Address m_addr4; ///< address 4
>   uint8_t m_qosTid; ///< QOS TID
>   uint8_t m_qosEosp; ///< QOS EOSP
>   uint8_t m_qosAckPolicy; ///< QOS ack policy
>   uint8_t m_amsduPresent; ///< AMSDU present
>   uint8_t m_qosStuff; ///< QOS stuff
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-queue.cc ../../ns-3-dev-git/src/wifi/model/wifi-mac-queue.cc
28,36d27
< #include "ns3/ipv4-header.h"
< #include "ns3/llc-snap-header.h"
< 
< #include <iostream>
< #include <fstream>
< 
< using namespace ns3;
< using namespace std;
< 
42d32
< NS_OBJECT_TEMPLATE_CLASS_DEFINE (Queue, WifiMacQueueItem);
51,56d40
<     .AddAttribute ("MaxSize",
<                    "The max queue size",
<                    QueueSizeValue (QueueSize ("500p")),
<                    MakeQueueSizeAccessor (&QueueBase::SetMaxSize,
<                                           &QueueBase::GetMaxSize),
<                    MakeQueueSizeChecker ())
66,68d49
<     .AddTraceSource ("Expired", "MPDU dropped because its lifetime expired.",
<                      MakeTraceSourceAccessor (&WifiMacQueue::m_traceExpired),
<                      "ns3::WifiMacQueueItem::TracedCallback")
74,75c55
<   : m_expiredPacketsPresent (false),
<     NS_LOG_TEMPLATE_DEFINE ("WifiMacQueue")
---
>   : NS_LOG_TEMPLATE_DEFINE ("WifiMacQueue")
84,87d63
< static std::list<Ptr<WifiMacQueueItem>> g_emptyWifiMacQueue;
< 
< const WifiMacQueue::ConstIterator WifiMacQueue::EMPTY = g_emptyWifiMacQueue.end ();
< 
110,122d85
<       m_traceExpired (*it);
<       // Ptr<Packet> copy = (*it)->GetPacket()->Copy();
<       // if (copy->GetSize() == 1480)
<       // {
<       //   LlcSnapHeader llc;
<       //   Ipv4Header iHD;
<       //   copy->RemoveHeader(llc);
<       //   copy->PeekHeader (iHD);
<       //   copy->AddHeader(llc);
<       //   uint8_t pri = iHD.GetPri();
<         // std::cout << int(pri) <<" queue packet drop by time\n";
< 
<       // }
124d86
<       // std::cout << copy->GetSize() <<" queue packet drop by time\n";
134,160c96,98
<   NS_LOG_FUNCTION (this << *item);
<   return Insert (end (), item);
< }
< 
< bool
< WifiMacQueue::PushFront (Ptr<WifiMacQueueItem> item)
< {
<   NS_LOG_FUNCTION (this << *item);
< 
<   return Insert (begin (), item);
< }
< 
< void
< WifiMacQueue::LabelExceeded (uint32_t IncomingLabel,ConstIterator &it2)
< {
<   NS_LOG_FUNCTION (this);
<   //Remove all the packet in queue which size = 1480 and Label is smaller than IncomingLabel.
<       Ptr<Packet> copy = (*it2)->GetPacket()->Copy();
< 
<       if (copy->GetSize() == 1480)
<       {   
<         LlcSnapHeader llc;
<         Ipv4Header iHD;
<         copy->RemoveHeader(llc);
<         copy->PeekHeader (iHD);
<         copy->AddHeader(llc);
<         uint32_t FindingLabel = iHD.GetEncodedLabel();
---
>   NS_LOG_FUNCTION (this << item);
>   NS_ASSERT_MSG (GetMaxSize ().GetUnit () == QueueSizeUnit::PACKETS,
>                  "WifiMacQueues must be in packet mode");
162c100,105
<         if (FindingLabel < IncomingLabel-10)
---
>   // if the queue is full, remove the first stale packet (if any) encountered
>   // starting from the head of the queue, in order to make room for the new packet.
>   if (QueueBase::GetNPackets () == GetMaxSize ().GetValue ())
>     {
>       auto it = Head ();
>       while (it != Tail () && !TtlExceeded (it))
164,166c107
<           auto curr = it2++;
<           DoRemove (curr);
<           std::cout <<"Incoming " << IncomingLabel << ",Remove " << FindingLabel << "\n";
---
>           it++;
168,170c109
<       }
< }
< 
---
>     }
171a111,115
>   if (QueueBase::GetNPackets () == GetMaxSize ().GetValue () && m_dropPolicy == DROP_OLDEST)
>     {
>       NS_LOG_DEBUG ("Remove the oldest item in the queue");
>       DoRemove (Head ());
>     }
173c117,118
< double NowLable = 0;
---
>   return DoEnqueue (Tail (), item);
> }
175d119
<  
177c121
< WifiMacQueue::Insert (ConstIterator pos, Ptr<WifiMacQueueItem> item)
---
> WifiMacQueue::PushFront (Ptr<WifiMacQueueItem> item)
179c123
<   NS_LOG_FUNCTION (this << *item);
---
>   NS_LOG_FUNCTION (this << item);
183,251c127,132
< 
<   // insert the item if the queue is not full
<   // if (QueueBase::GetNPackets () < GetMaxSize ().GetValue ())
<   if (QueueBase::GetNPackets () < GetMaxSize ().GetValue ())
<     {
<       Ptr<Packet> copy = item->GetPacket()->Copy ();
<       if (item->GetPacket()->GetSize () == 1480)
<       {
<         LlcSnapHeader llc;
<         Ipv4Header iHD;
<         copy->RemoveHeader(llc);
<         copy->PeekHeader (iHD);
<         copy->AddHeader(llc);
<         // uint32_t m_RecvIncomingLabel = iHD.GetEncodedLabel();
<         // uint8_t pri = iHD.GetPri();
< 
<         // if (pri%2 ==1 )
<         // {
<           // std::cout << "1\n";
<           // ofstream fout;
<           // fout.open( "2_AP1_queue.txt" ,ios::app);
<           // fout << Simulator::Now ().GetSeconds () <<  " "  << QueueBase::GetNPackets () << "\n";
<           // fout.close();
<         // } 
<         // else if (pri%2 == 0)
<         // {
<           // std::cout << "AP222222222222222222222\n";
<             // ofstream fout;
<             // fout.open( "2_AP2_queue.txt" ,ios::app);
<             // fout << Simulator::Now ().GetSeconds () <<  " "  << QueueBase::GetNPackets () << "\n";
<             // fout.close();
<         // }
<         // uint8_t EncodeNumber = iHD.GetEncodedPacketNumber();
<         // std::cout << "m_RecvIncomingLabel =" << m_RecvIncomingLabel << "\n"; // I have the new label
< 
<         // if (m_RecvIncomingLabel > NowLable)
<         // {
<         //   NowLable = m_RecvIncomingLabel;
<         //   // ConstIterator it2 = begin ();
<         //   // while (it2 != end ())
<         //   // {
<         //   //   LabelExceeded(m_RecvIncomingLabel,it2);
<         //   //   it2++;
<         //   // }
<         //   return DoEnqueue (pos, item);
<         // }
<         // else //if (m_RecvIncomingLabel == NowLable)
<         // {
<         //   return DoEnqueue (pos, item);
<         // }
<         // return DoEnqueue (pos, item);
<       }
<       return DoEnqueue (pos, item);
<       // else
<       // {
<       //   return DoEnqueue (pos, item);
<       // }
<     }
<     // std::cout << QueueBase::GetNPackets () << "\n";
<   // the queue is full; scan the list in the attempt to remove stale packets
<   ConstIterator it = begin ();
< 
<   while (it != end ())
<     {
<       if (it == pos && TtlExceeded (it))
<         {
<           return DoEnqueue (it, item);
<         }
<       if (TtlExceeded (it))
---
>   // if the queue is full, remove the first stale packet (if any) encountered
>   // starting from the head of the queue, in order to make room for the new packet.
>   if (QueueBase::GetNPackets () == GetMaxSize ().GetValue ())
>     {
>       auto it = Head ();
>       while (it != Tail () && !TtlExceeded (it))
253c134
<           return DoEnqueue (pos, item);
---
>           it++;
255d135
<       it++;
258,259c138
<   // the queue is still full, remove the oldest item if the policy is drop oldest
<    if (m_dropPolicy == DROP_OLDEST)
---
>   if (QueueBase::GetNPackets () == GetMaxSize ().GetValue () && m_dropPolicy == DROP_OLDEST)
262c141
<       DoRemove (begin ());
---
>       DoRemove (Head ());
264,265c143,144
<     return DoEnqueue (pos, item);
<       // return 0;
---
> 
>   return DoEnqueue (Head (), item);
272c151
<   for (ConstIterator it = begin (); it != end (); )
---
>   for (auto it = Head (); it != Tail (); )
287d165
<   ConstIterator it = PeekByAddress (dest);
289c167
<   if (it == end ())
---
>   for (auto it = Head (); it != Tail (); )
291,300c169,174
<       return 0;
<     }
<   return Dequeue (it);
< }
< 
< Ptr<WifiMacQueueItem>
< WifiMacQueue::DequeueByTid (uint8_t tid)
< {
<   NS_LOG_FUNCTION (this << +tid);
<   ConstIterator it = PeekByTid (tid);
---
>       if (!TtlExceeded (it))
>         {
>           if ((*it)->GetHeader ().IsData () && (*it)->GetDestinationAddress () == dest)
>             {
>               return DoDequeue (it);
>             }
302,304c176,177
<   if (it == end ())
<     {
<       return 0;
---
>           it++;
>         }
306c179,180
<   return Dequeue (it);
---
>   NS_LOG_DEBUG ("The queue is empty");
>   return 0;
312,315c186,187
<   NS_LOG_FUNCTION (this << +tid << dest);
<   ConstIterator it = PeekByTidAndAddress (tid, dest);
< 
<   if (it == end ())
---
>   NS_LOG_FUNCTION (this << dest);
>   for (auto it = Head (); it != Tail (); )
317,326c189,195
<       return 0;
<     }
<   return Dequeue (it);
< }
< 
< Ptr<WifiMacQueueItem>
< WifiMacQueue::DequeueFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets)
< {
<   NS_LOG_FUNCTION (this);
<   ConstIterator it = PeekFirstAvailable (blockedPackets);
---
>       if (!TtlExceeded (it))
>         {
>           if ((*it)->GetHeader ().IsQosData () && (*it)->GetDestinationAddress () == dest
>               && (*it)->GetHeader ().GetQosTid () == tid)
>             {
>               return DoDequeue (it);
>             }
328,330c197,198
<   if (it == end ())
<     {
<       return 0;
---
>           it++;
>         }
332c200,201
<   return Dequeue (it);
---
>   NS_LOG_DEBUG ("The queue is empty");
>   return 0;
336c205
< WifiMacQueue::Dequeue (ConstIterator pos)
---
> WifiMacQueue::DequeueFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets)
339,352c208
< 
<   if (!m_expiredPacketsPresent)
<     {
<       if (TtlExceeded (pos))
<         {
<           NS_LOG_DEBUG ("Packet lifetime expired");
<           return 0;
<         }
<       return DoDequeue (pos);
<     }
< 
<   // remove stale items queued before the given position
<   ConstIterator it = begin ();
<   while (it != end ())
---
>   for (auto it = Head (); it != Tail (); )
354c210
<       if (it == pos)
---
>       if (!TtlExceeded (it))
356,359c212,213
<           // reset the flag signaling the presence of expired packets before returning
<           m_expiredPacketsPresent = false;
< 
<           if (TtlExceeded (it))
---
>           if (!(*it)->GetHeader ().IsQosData ()
>               || !blockedPackets->IsBlocked ((*it)->GetHeader ().GetAddr1 (), (*it)->GetHeader ().GetQosTid ()))
361c215
<               return 0;
---
>               return DoDequeue (it);
363,366c217
<           return DoDequeue (it);
<         }
<       else if (!TtlExceeded (it))
<         {
---
> 
370c221
<   NS_LOG_DEBUG ("Invalid iterator");
---
>   NS_LOG_DEBUG ("The queue is empty");
378c229
<   for (auto it = begin (); it != end (); it++)
---
>   for (auto it = Head (); it != Tail (); it++)
386,387d236
<       // signal the presence of expired packets
<       m_expiredPacketsPresent = true;
393,394c242,243
< WifiMacQueue::ConstIterator
< WifiMacQueue::PeekByAddress (Mac48Address dest, ConstIterator pos) const
---
> Ptr<const WifiMacQueueItem>
> WifiMacQueue::PeekByTidAndAddress (uint8_t tid, Mac48Address dest)
397,453c246
<   ConstIterator it = (pos != EMPTY ? pos : begin ());
<   while (it != end ())
<     {
<       // skip packets that stayed in the queue for too long. They will be
<       // actually removed from the queue by the next call to a non-const method
<       if (Simulator::Now () <= (*it)->GetTimeStamp () + m_maxDelay)
<         {
<           if (((*it)->GetHeader ().IsData () || (*it)->GetHeader ().IsQosData ())
<               && (*it)->GetDestinationAddress () == dest)
<             {
<               return it;
<             }
<         }
<       else
<         {
<           // signal the presence of expired packets
<           m_expiredPacketsPresent = true;
<         }
<       it++;
<     }
<   NS_LOG_DEBUG ("The queue is empty");
<   return end ();
< }
< 
< WifiMacQueue::ConstIterator
< WifiMacQueue::PeekByTid (uint8_t tid, ConstIterator pos) const
< {
<   NS_LOG_FUNCTION (this << +tid);
<   ConstIterator it = (pos != EMPTY ? pos : begin ());
<   while (it != end ())
<     {
<       // skip packets that stayed in the queue for too long. They will be
<       // actually removed from the queue by the next call to a non-const method
<       if (Simulator::Now () <= (*it)->GetTimeStamp () + m_maxDelay)
<         {
<           if ((*it)->GetHeader ().IsQosData () && (*it)->GetHeader ().GetQosTid () == tid)
<             {
<               return it;
<             }
<         }
<       else
<         {
<           // signal the presence of expired packets
<           m_expiredPacketsPresent = true;
<         }
<       it++;
<     }
<   NS_LOG_DEBUG ("The queue is empty");
<   return end ();
< }
< 
< WifiMacQueue::ConstIterator
< WifiMacQueue::PeekByTidAndAddress (uint8_t tid, Mac48Address dest, ConstIterator pos) const
< {
<   NS_LOG_FUNCTION (this << +tid << dest);
<   ConstIterator it = (pos != EMPTY ? pos : begin ());
<   while (it != end ())
---
>   for (auto it = Head (); it != Tail (); )
455,457c248
<       // skip packets that stayed in the queue for too long. They will be
<       // actually removed from the queue by the next call to a non-const method
<       if (Simulator::Now () <= (*it)->GetTimeStamp () + m_maxDelay)
---
>       if (!TtlExceeded (it))
462c253
<               return it;
---
>               return DoPeek (it);
463a255,256
> 
>           it++;
465,470d257
<       else
<         {
<           // signal the presence of expired packets
<           m_expiredPacketsPresent = true;
<         }
<       it++;
473c260
<   return end ();
---
>   return 0;
476,477c263,264
< WifiMacQueue::ConstIterator
< WifiMacQueue::PeekFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets, ConstIterator pos) const
---
> Ptr<const WifiMacQueueItem>
> WifiMacQueue::PeekFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets)
480,481c267
<   ConstIterator it = (pos != EMPTY ? pos : begin ());
<   while (it != end ())
---
>   for (auto it = Head (); it != Tail (); )
483,485c269
<       // skip packets that stayed in the queue for too long. They will be
<       // actually removed from the queue by the next call to a non-const method
<       if (Simulator::Now () <= (*it)->GetTimeStamp () + m_maxDelay)
---
>       if (!TtlExceeded (it))
487c271
<           if (!(*it)->GetHeader ().IsQosData () || !blockedPackets
---
>           if (!(*it)->GetHeader ().IsQosData ()
490c274
<               return it;
---
>               return DoPeek (it);
491a276,277
> 
>           it++;
493,498d278
<       else
<         {
<           // signal the presence of expired packets
<           m_expiredPacketsPresent = true;
<         }
<       it++;
501c281
<   return end ();
---
>   return 0;
509c289
<   for (ConstIterator it = begin (); it != end (); )
---
>   for (auto it = Head (); it != Tail (); )
524c304
<   for (ConstIterator it = begin (); it != end (); )
---
>   for (auto it = Head (); it != Tail (); )
541,574d320
< WifiMacQueue::ConstIterator
< WifiMacQueue::Remove (ConstIterator pos, bool removeExpired)
< {
<   NS_LOG_FUNCTION (this);
< 
<   if (!removeExpired)
<     {
<       ConstIterator curr = pos++;
<       DoRemove (curr);
<       return pos;
<     }
< 
<   // remove stale items queued before the given position
<   ConstIterator it = begin ();
<   while (it != end ())
<     {
<       if (it == pos)
<         {
<           // reset the flag signaling the presence of expired packets before returning
<           m_expiredPacketsPresent = false;
< 
<           ConstIterator curr = pos++;
<           DoRemove (curr);
<           return pos;
<         }
<       else if (!TtlExceeded (it))
<         {
<           it++;
<         }
<     }
<   NS_LOG_DEBUG ("Invalid iterator");
<   return end ();
< }
< 
582c328
<   for (ConstIterator it = begin (); it != end (); )
---
>   for (auto it = Head (); it != Tail (); )
603c349
<   for (ConstIterator it = begin (); it != end (); )
---
>   for (auto it = Head (); it != Tail (); )
620,718d365
< //uint32_t
< //WifiMacQueue::GetNPacketsByTidAndAddress (uint8_t tid, WifiMacHeader::AddressType type,
< //                                          Mac48Address addr)
< //{
< //  NS_LOG_FUNCTION (this << addr);
< 
< //  uint32_t nPackets = 0;
< 
< //  for (ConstIterator it = begin (); it != end (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          if ((*it)->GetHeader ().IsQosData () && (*it)->GetAddress (type) == addr
< //              && (*it)->GetHeader ().GetQosTid () == tid)
< //            {
< //              nPackets++;
< //            }
< 
< //          it++;
< //        }
< //    }
< //  NS_LOG_DEBUG ("returns " << nPackets);
< //  return nPackets;
< //}
< 
< //void
< //WifiMacQueue::TransferPacketsByAddress (Mac48Address addr, Ptr<WifiMacQueue> destQueue)
< //{
< //  for (auto it = Head (); it != Tail (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          if (((*it)->GetHeader ().IsData ()) && ((*it)->GetHeader ().GetAddr1 () == addr))
< //            {
< //              /* Copy the item to the new Queue */
< //              Ptr<WifiMacQueueItem> item = Create<WifiMacQueueItem> ((*it)->GetPacket (), (*it)->GetHeader ());
< //              destQueue->Enqueue (item);
< //              it = m_packets.erase (it);
< //              m_nBytes -= item->GetSize ();
< //              m_nPackets--;
< //            }
< //          else
< //            {
< //              it++;
< //            }
< //        }
< //    }
< //}
< 
< //void
< //WifiMacQueue::QuickTransfer (Ptr<WifiMacQueue> destQueue)
< //{
< //  for (auto it = Head (); it != Tail (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          /* Copy the item to the new Queue */
< //          Ptr<WifiMacQueueItem> item = Create<WifiMacQueueItem> ((*it)->GetPacket (), (*it)->GetHeader ());
< //          destQueue->Enqueue (item);
< //          it = m_packets.erase (it);
< //          m_nBytes -= item->GetSize ();
< //          m_nPackets--;
< //        }
< //    }
< //}
< 
< //bool
< //WifiMacQueue::HasPacketsForReceiver (Mac48Address addr)
< //{
< //  for (auto it = Head (); it != Tail (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          if ((*it)->GetHeader ().GetAddr1 () == addr)
< //            {
< //              return true;
< //            }
< //          it++;
< //        }
< //    }
< //  return false;
< //}
< 
< //void
< //WifiMacQueue::ChangePacketsReceiverAddress (Mac48Address OriginalAddress, Mac48Address newAddress)
< //{
< //  for (auto it = Head (); it != Tail (); )
< //    {
< //      if (!TtlExceeded (it))
< //        {
< //          if (((*it)->GetHeader ().IsData ()) && ((*it)->GetHeader ().GetAddr1 () == OriginalAddress))
< //            {
< //              (*it)->SetAddress (WifiMacHeader::ADDR1, newAddress);
< //            }
< //          it++;
< //        }
< //    }
< //}
< 
723c370
<   for (ConstIterator it = begin (); it != end (); )
---
>   for (auto it = Head (); it != Tail (); )
740c387
<   for (ConstIterator it = begin (); it != end (); )
---
>   for (auto it = Head (); it != Tail (); )
755c402
<   for (ConstIterator it = begin (); it != end (); )
---
>   for (auto it = Head (); it != Tail (); )
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-queue.h ../../ns-3-dev-git/src/wifi/model/wifi-mac-queue.h
28d27
< #include "ns3/queue.h"
34,41d32
< // The following explicit template instantiation declaration prevents modules
< // including this header file from implicitly instantiating Queue<WifiMacQueueItem>.
< // This would cause python examples using wifi to crash at runtime with the
< // following error message: "Trying to allocate twice the same UID:
< // ns3::Queue<WifiMacQueueItem>"
< extern template class Queue<WifiMacQueueItem>;
< 
< 
75,80d65
<   /// allow the usage of iterators and const iterators
<   using Queue<WifiMacQueueItem>::ConstIterator;
<   using Queue<WifiMacQueueItem>::Iterator;
<   using Queue<WifiMacQueueItem>::begin;
<   using Queue<WifiMacQueueItem>::end;
< 
109,116d93
<    * Enqueue the given Wifi MAC queue item before the given position.
<    *
<    * \param pos the position before which the item is to be inserted
<    * \param item the Wifi MAC queue item to be enqueued
<    * \return true if success, false if the packet has been dropped
<    */
<   bool Insert (ConstIterator pos, Ptr<WifiMacQueueItem> item);
<   /**
123,124c100,101
<    * Search and return, if present in the queue, the first packet (either Data
<    * frame or QoS Data frame) having the receiver address equal to <i>addr</i>.
---
>    * Search and return, if present in the queue, the first packet having the
>    * address indicated by <i>type</i> equal to <i>addr</i>.
135,145c112
<    * TID equal to <i>tid</i>.
<    * This method removes the packet from the queue.
<    *
<    * \param tid the given TID
<    *
<    * \return the packet
<    */
<   Ptr<WifiMacQueueItem> DequeueByTid (uint8_t tid);
<   /**
<    * Search and return, if present in the queue, the first packet having the
<    * address indicated by <i>type</i> equal to <i>addr</i>, and TID
---
>    * address indicated by <i>type</i> equal to <i>addr</i>, and tid
159c126
<    * if it is a QoS packet with a TID and an address1 fields equal to <i>tid</i> and <i>addr</i>
---
>    * if it is a QoS packet with a tid and an address1 fields equal to <i>tid</i> and <i>addr</i>
164,172c131
<    * \param blockedPackets the destination address & TID pairs that are waiting for a BlockAck response
<    *
<    * \return the packet
<    */
<   Ptr<WifiMacQueueItem> DequeueFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets = nullptr);
<   /**
<    * Dequeue the item at position <i>pos</i> in the queue. Return a null
<    * pointer if the given iterator is invalid, the queue is empty or the
<    * lifetime of the item pointed to by the given iterator is expired.
---
>    * \param blockedPackets
174,175c133
<    * \param pos the position of the item to be dequeued
<    * \return the dequeued item, if any
---
>    * \return packet
177c135
<   Ptr<WifiMacQueueItem> Dequeue (WifiMacQueue::ConstIterator pos);
---
>   Ptr<WifiMacQueueItem> DequeueFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets);
185,197d142
<    * Search and return, if present in the queue, the first packet (either Data
<    * frame or QoS Data frame) having the receiver address equal to <i>addr</i>.
<    * If <i>pos</i> is a valid iterator, the search starts from the packet pointed
<    * to by the given iterator.
<    * This method does not remove the packet from the queue.
<    *
<    * \param dest the given destination
<    * \param pos the iterator pointing to the packet the search starts from
<    *
<    * \return an iterator pointing to the peeked packet
<    */
<   ConstIterator PeekByAddress (Mac48Address dest, ConstIterator pos = EMPTY) const;
<   /**
199,215c144,147
<    * TID equal to <i>tid</i>. If <i>pos</i> is a valid iterator, the search starts
<    * from the packet pointed to by the given iterator.
<    * This method does not remove the packet from the queue.
<    *
<    * \param tid the given TID
<    * \param pos the iterator pointing to the packet the search starts from
<    *
<    * \return an iterator pointing to the peeked packet
<    */
<   ConstIterator PeekByTid (uint8_t tid, ConstIterator pos = EMPTY) const;
<   /**
<    * Search and return, if present in the queue, the first packet having the
<    * receiver address equal to <i>dest</i>, and TID equal to <i>tid</i>.
<    * If <i>pos</i> is a valid iterator, the search starts from the packet pointed
<    * to by the given iterator. This method does not remove the packet from the queue.
<    * It is typically used by ns3::QosTxop in order to perform correct MSDU aggregation
<    * (A-MSDU).
---
>    * address indicated by <i>type</i> equal to <i>addr</i>, and tid
>    * equal to <i>tid</i>. This method does not remove the packet from the queue.
>    * It is typically used by ns3::QosTxop in order to perform correct MSDU
>    * aggregation (A-MSDU).
219d150
<    * \param pos the iterator pointing to the packet the search starts from
221c152
<    * \return an iterator pointing to the peeked packet
---
>    * \return packet
223c154,155
<   ConstIterator PeekByTidAndAddress (uint8_t tid, Mac48Address dest, ConstIterator pos = EMPTY) const;
---
>   Ptr<const WifiMacQueueItem> PeekByTidAndAddress (uint8_t tid,
>                                                    Mac48Address dest);
227,228c159
<    * \param blockedPackets the destination address & TID pairs that are waiting for a BlockAck response
<    * \param pos the iterator pointing to the packet the search starts from
---
>    * \param blockedPackets
230c161
<    * \return an iterator pointing to the peeked packet
---
>    * \return packet
232,233c163
<   ConstIterator PeekFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets = nullptr,
<                                     ConstIterator pos = EMPTY) const;
---
>   Ptr<const WifiMacQueueItem> PeekFirstAvailable (const Ptr<QosBlockedDestinations> blockedPackets);
251,261d180
<    * Remove the item at position <i>pos</i> in the queue and return an iterator
<    * pointing to the item following the removed one. If <i>removeExpired</i> is
<    * true, all the items in the queue from the head to the given position are
<    * removed if their lifetime expired.
<    *
<    * \param pos the position of the item to be removed
<    * \param removeExpired true to remove expired items
<    * \return an iterator pointing to the item following the removed one
<    */
<   ConstIterator Remove (ConstIterator pos, bool removeExpired = false);
<   /**
271c190
<    * Return the number of QoS packets having TID equal to <i>tid</i> and
---
>    * Return the number of QoS packets having tid equal to <i>tid</i> and
302,304d220
<   static const ConstIterator EMPTY;         //!< Invalid iterator to signal an empty queue
< 
< 
315d230
<   void LabelExceeded (uint32_t IncomingLabel,ConstIterator &it);
319,322d233
<   mutable bool m_expiredPacketsPresent;     //!< True if expired packets are in the queue
< 
<   /// Traced callback: fired when a packet is dropped due to lifetime expiration
<   TracedCallback<Ptr<const WifiMacQueueItem> > m_traceExpired;
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-queue-item.cc ../../ns-3-dev-git/src/wifi/model/wifi-mac-queue-item.cc
25,26d24
< #include "ns3/packet.h"
< #include "ns3/log.h"
28,29d25
< #include "wifi-mac-trailer.h"
< #include "wifi-utils.h"
36,40d31
<   : WifiMacQueueItem (p, header, Simulator::Now ())
< {
< }
< 
< WifiMacQueueItem::WifiMacQueueItem (Ptr<const Packet> p, const WifiMacHeader & header, Time tstamp)
43,55c34
<     m_tstamp (tstamp),
<     m_isShortSsw (false)
< {
<   if (header.IsQosData () && header.IsQosAmsdu ())
<     {
<       m_msduList = MsduAggregator::Deaggregate (p->Copy ());
<     }
< }
< 
< WifiMacQueueItem::WifiMacQueueItem (Ptr<const Packet> p)
<   : m_packet (p),
<     m_tstamp (Simulator::Now ()),
<     m_isShortSsw (true)
---
>     m_tstamp (Simulator::Now ())
75,80d53
< WifiMacHeader&
< WifiMacQueueItem::GetHeader (void)
< {
<   return m_header;
< }
< 
96,241c69
<   if (m_isShortSsw)
<     {
<       NS_ABORT_MSG_IF (m_packet->GetSize () != 6, "Short SSW packets have payload of 6 Bytes");
<       return m_packet->GetSize ();
<     }
<   else
<     return m_packet->GetSize () + m_header.GetSerializedSize () + WIFI_MAC_FCS_LENGTH;
< }
< 
< Ptr<Packet>
< WifiMacQueueItem::GetProtocolDataUnit (void) const
< {
<   Ptr<Packet> mpdu = m_packet->Copy ();
<   if (!m_isShortSsw)
<     {
<       mpdu->AddHeader (m_header);
<       AddWifiMacTrailer (mpdu);
<     }
<   return mpdu;
< }
< 
< void
< WifiMacQueueItem::Aggregate (Ptr<const WifiMacQueueItem> msdu)
< {
<   NS_ASSERT (msdu != 0);
<   NS_LOG_FUNCTION (this << *msdu);
<   NS_ABORT_MSG_IF (!msdu->GetHeader ().IsQosData () || msdu->GetHeader ().IsQosAmsdu (),
<                    "Only QoS data frames that do not contain an A-MSDU can be aggregated");
< 
<   if (m_msduList.empty ())
<     {
<       // An MSDU is going to be aggregated to this MPDU, hence this has to be an A-MSDU now
<       Ptr<const WifiMacQueueItem> firstMsdu = Create<const WifiMacQueueItem> (*this);
<       m_packet = Create<Packet> ();
<       DoAggregate (firstMsdu);
< 
<       m_header.SetQosAmsdu ();
<       // Set Address3 according to Table 9-26 of 802.11-2016
<       if (m_header.IsToDs () && !m_header.IsFromDs ())
<         {
<           // from STA to AP: BSSID is in Address1
<           m_header.SetAddr3 (m_header.GetAddr1 ());
<         }
<       else if (!m_header.IsToDs () && m_header.IsFromDs ())
<         {
<           // from AP to STA: BSSID is in Address2
<           m_header.SetAddr3 (m_header.GetAddr2 ());
<         }
<       // in the WDS case (ToDS = FromDS = 1), both Address 3 and Address 4 need
<       // to be set to the BSSID, but neither Address 1 nor Address 2 contain the
<       // BSSID. Hence, it is left up to the caller to set these Address fields.
<     }
<   DoAggregate (msdu);
< }
< 
< void
< WifiMacQueueItem::DoAggregate (Ptr<const WifiMacQueueItem> msdu)
< {
<   NS_LOG_FUNCTION (this << *msdu);
< 
<   // build the A-MSDU Subframe header
<   AmsduSubframeHeader hdr;
<   /*
<    * (See Table 9-26 of 802.11-2016)
<    *
<    * ToDS | FromDS |  DA   |  SA
<    *   0  |   0    | Addr1 | Addr2
<    *   0  |   1    | Addr1 | Addr3
<    *   1  |   0    | Addr3 | Addr2
<    *   1  |   1    | Addr3 | Addr4
<    */
<   hdr.SetDestinationAddr (msdu->GetHeader ().IsToDs () ? msdu->GetHeader ().GetAddr3 ()
<                                                        : msdu->GetHeader ().GetAddr1 ());
<   hdr.SetSourceAddr (!msdu->GetHeader ().IsFromDs () ? msdu->GetHeader ().GetAddr2 ()
<                                                      : (!msdu->GetHeader ().IsToDs ()
<                                                         ? msdu->GetHeader ().GetAddr3 ()
<                                                         : msdu->GetHeader ().GetAddr4 ()));
<   hdr.SetLength (static_cast<uint16_t> (msdu->GetPacket ()->GetSize ()));
< 
<   m_msduList.push_back ({msdu->GetPacket (), hdr});
< 
<   // build the A-MSDU
<   NS_ASSERT (m_packet);
<   Ptr<Packet> amsdu = m_packet->Copy ();
< 
<   // pad the previous A-MSDU subframe if the A-MSDU is not empty
<   if (m_packet->GetSize () > 0)
<     {
<       uint8_t padding = MsduAggregator::CalculatePadding (m_packet->GetSize ());
< 
<       if (padding)
<         {
<           amsdu->AddAtEnd (Create<Packet> (padding));
<         }
<     }
< 
<   // add A-MSDU subframe header and MSDU
<   Ptr<Packet> amsduSubframe = msdu->GetPacket ()->Copy ();
<   amsduSubframe->AddHeader (hdr);
<   amsdu->AddAtEnd (amsduSubframe);
<   m_packet = amsdu;
< 
<   /* "The expiration of the A-MSDU lifetime timer occurs only when the lifetime
<     * timer of all of the constituent MSDUs of the A-MSDU have expired" (Section
<     * 10.12 of 802.11-2016)
<     */
<   // The timestamp of the A-MSDU is the most recent among those of the MSDUs
<   m_tstamp = Max (m_tstamp, msdu->GetTimeStamp ());
< }
< 
< 
< MsduAggregator::DeaggregatedMsdusCI
< WifiMacQueueItem::begin (void)
< {
<   return m_msduList.begin ();
< }
< 
< MsduAggregator::DeaggregatedMsdusCI
< WifiMacQueueItem::end (void)
< {
<   return m_msduList.end ();
< }
< 
< void
< WifiMacQueueItem::Print (std::ostream& os) const
< {
<   os << "size=" << m_packet->GetSize ()
<      << ", to=" << m_header.GetAddr1 ()
<      << ", seqN=" << m_header.GetSequenceNumber ()
<      << ", lifetime=" << (Simulator::Now () - m_tstamp).GetMicroSeconds () << "us";
<   if (m_header.IsQosData ())
<     {
<       os << ", tid=" << +m_header.GetQosTid ();
<       if (m_header.IsQosNoAck ())
<         {
<           os << ", ack=NoAck";
<         }
<       else if (m_header.IsQosAck ())
<         {
<           os << ", ack=NormalAck";
<         }
<       else if (m_header.IsQosBlockAck ())
<         {
<           os << ", ack=BlockAck";
<         }
<     }
---
>   return m_packet->GetSize () + m_header.GetSerializedSize ();
244,248c72
< std::ostream & operator << (std::ostream &os, const WifiMacQueueItem &item)
< {
<   item.Print (os);
<   return os;
< }
---
> NS_OBJECT_TEMPLATE_CLASS_DEFINE (Queue, WifiMacQueueItem);
diff ../../NS3-WiGig/src/wifi/model/wifi-mac-queue-item.h ../../ns-3-dev-git/src/wifi/model/wifi-mac-queue-item.h
27a28
> #include "ns3/queue.h"
29,30d29
< #include "msdu-aggregator.h"
< #include "amsdu-subframe-header.h"
35d33
< class Packet;
49c47
<    * \param header the Wifi MAC header included in the created item.
---
>    * \param header the Wifi Mac header included in the created item.
53,66d50
<   /**
<    * \brief Create a Wifi MAC queue item containing a packet and a Wifi MAC header.
<    * \param p the const packet included in the created item.
<    * \param header the Wifi MAC header included in the created item.
<    * \param tstamp the timestamp associated with the created item.
<    */
<   WifiMacQueueItem (Ptr<const Packet> p, const WifiMacHeader & header, Time tstamp);
< 
<   /**
<    * \brief Create a Wifi MAC queue item containing only a packet and without a Wifi MAC header. Used for Short SSW packets.
<    * \param p the const packet included in the created item.
<    */
<   WifiMacQueueItem (Ptr<const Packet> p);
< 
82,87d65
<    * \brief Get the header stored in this item
<    * \return the header stored in this item.
<    */
<   WifiMacHeader & GetHeader (void);
< 
<   /**
100,101c78
<    * \brief Return the size of the packet stored by this item, including header
<    *        size and trailer size
---
>    * \brief Return the size of the packet included in this item
103c80
<    * \return the size of the packet stored by this item in bytes.
---
>    * \return the size of the packet included in this item.
106a84
> private:
108,111c86,88
<    * \brief Aggregate the MSDU contained in the given MPDU to this MPDU (thus
<    *        constituting an A-MSDU). Note that the given MPDU cannot contain
<    *        an A-MSDU.
<    * \param msdu the MPDU containing the MSDU to aggregate
---
>    * \brief Default constructor
>    *
>    * Defined and unimplemented to avoid misuse
113,114c90
<   void Aggregate (Ptr<const WifiMacQueueItem> msdu);
< 
---
>   WifiMacQueueItem ();
116c92
<    * \brief Get a constant iterator pointing to the first MSDU in the list of aggregated MSDUs.
---
>    * \brief Copy constructor
118c94
<    * \return a constant iterator pointing to the first MSDU in the list of aggregated MSDUs
---
>    * Defined and unimplemented to avoid misuse
120c96
<   MsduAggregator::DeaggregatedMsdusCI begin (void);
---
>   WifiMacQueueItem (const WifiMacQueueItem &);
122c98
<    * \brief Get a constant iterator indicating past-the-last MSDU in the list of aggregated MSDUs.
---
>    * \brief Assignment operator
124c100,101
<    * \return a constant iterator indicating past-the-last MSDU in the list of aggregated MSDUs
---
>    * Defined and unimplemented to avoid misuse
>    * \returns
126c103
<   MsduAggregator::DeaggregatedMsdusCI end (void);
---
>   WifiMacQueueItem &operator = (const WifiMacQueueItem &);
128,134c105,108
<   /**
<    * \brief Get the MAC protocol data unit (MPDU) corresponding to this item
<    *        (i.e. a copy of the packet stored in this item wrapped with MAC
<    *        header and trailer)
<    * \return the MAC protocol data unit corresponding to this item.
<    */
<   Ptr<Packet> GetProtocolDataUnit (void) const;
---
>   Ptr<const Packet> m_packet;  //!< The packet contained in this queue item
>   WifiMacHeader m_header;      //!< Wifi MAC header associated with the packet
>   Time m_tstamp;               //!< timestamp when the packet arrived at the queue
> };
136,140d109
<   /**
<    * \brief Print the item contents.
<    * \param os output stream in which the data should be printed.
<    */
<   virtual void Print (std::ostream &os) const;
142,156c111,116
< private:
<   /**
<    * \brief Aggregate the MSDU contained in the given MPDU to this MPDU (thus
<    *        constituting an A-MSDU). Note that the given MPDU cannot contain
<    *        an A-MSDU.
<    * \param msdu the MPDU containing the MSDU to aggregate
<    */
<   void DoAggregate (Ptr<const WifiMacQueueItem> msdu);
< 
<   Ptr<const Packet> m_packet;                   //!< The packet (MSDU or A-MSDU) contained in this queue item
<   WifiMacHeader m_header;                       //!< Wifi MAC header associated with the packet
<   Time m_tstamp;                                //!< timestamp when the packet arrived at the queue
<   MsduAggregator::DeaggregatedMsdus m_msduList; //!< The list of aggregated MSDUs included in this MPDU
<   bool m_isShortSsw;                            //!< A flag which specifies if the packet is a Short SSW packet and does not have a Wifi Mac Header.
< };
---
> // The following explicit template instantiation declaration prevents modules
> // including this header file from implicitly instantiating Queue<WifiMacQueueItem>.
> // This would cause python examples using wifi to crash at runtime with the
> // following error message: "Trying to allocate twice the same uid:
> // ns3::Queue<WifiMacQueueItem>"
> extern template class Queue<WifiMacQueueItem>;
158,165d117
< /**
<  * \brief Stream insertion operator.
<  *
<  * \param os the output stream
<  * \param item the WifiMacQueueItem
<  * \returns a reference to the stream
<  */
< std::ostream& operator<< (std::ostream& os, const WifiMacQueueItem &item);
diff ../../NS3-WiGig/src/wifi/model/wifi-mode.cc ../../ns-3-dev-git/src/wifi/model/wifi-mode.cc
28a29,37
> /**
>  * Check if the two WifiModes are identical.
>  *
>  * \param a WifiMode
>  * \param b WifiMode
>  *
>  * \return true if the two WifiModes are identical,
>  *         false otherwise
>  */
33c42,50
< 
---
> /**
>  * Compare two WifiModes
>  *
>  * \param a WifiMode
>  * \param b WifiMode
>  *
>  * \return true if a is less than b,
>  *         false otherwise
>  */
38c55,62
< 
---
> /**
>  * Serialize WifiMode to ostream (human-readable).
>  *
>  * \param os std::ostream
>  * \param mode
>  *
>  * \return std::ostream
>  */
44c68,75
< 
---
> /**
>  * Serialize WifiMode from istream (human-readable).
>  *
>  * \param is std::istream
>  * \param mode
>  *
>  * \return std::istream
>  */
67a99,104
>   else
>     {
>       //We should not go here!
>       NS_ASSERT (false);
>       return false;
>     }
80,103d116
<     case WIFI_CODE_RATE_7_8:
<       phyRate = dataRate * 8 / 7;
<       break;
<     case WIFI_CODE_RATE_5_8:
<       phyRate = dataRate * 8 / 5;
<       break;
<     case WIFI_CODE_RATE_13_16:
<       phyRate = dataRate * 16 / 13;
<       break;
<     case WIFI_CODE_RATE_1_4:
<       phyRate = dataRate * 4;
<       break;
<     case WIFI_CODE_RATE_13_28:
<       phyRate = dataRate * 28 / 13;
<       break;
<     case WIFI_CODE_RATE_13_21:
<       phyRate = dataRate * 21 / 13;
<       break;
<     case WIFI_CODE_RATE_52_63:
<       phyRate = dataRate * 63 / 52;
<       break;
<     case WIFI_CODE_RATE_13_14:
<       phyRate = dataRate * 14 / 13;
<       break;
143,149d155
< WifiMode::GetDmgDataRate (void) const
< {
<   WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   return item->dataRate;
< }
< 
< uint64_t
315,324d320
<   else if ((item->modClass == WIFI_MOD_CLASS_DMG_CTRL) ||
<            (item->modClass == WIFI_MOD_CLASS_DMG_SC) ||
<            (item->modClass == WIFI_MOD_CLASS_DMG_OFDM) ||
<            (item->modClass == WIFI_MOD_CLASS_DMG_LP_SC) ||
<            (item->modClass == WIFI_MOD_CLASS_EDMG_CTRL) ||
<            (item->modClass == WIFI_MOD_CLASS_EDMG_SC) ||
<            (item->modClass == WIFI_MOD_CLASS_EDMG_OFDM) )
<     {
<       return item->dataRate;
<     }
454c450
<           NS_ASSERT (item->modClass != WIFI_MOD_CLASS_VHT);
---
>           NS_ASSERT (item->modClass == WIFI_MOD_CLASS_HE);
485,489c481
<   if (item->modClass == WIFI_MOD_CLASS_HT || item->modClass == WIFI_MOD_CLASS_VHT || item->modClass == WIFI_MOD_CLASS_HE
<       || item->modClass == WIFI_MOD_CLASS_DMG_CTRL || item->modClass == WIFI_MOD_CLASS_DMG_SC
<       || item->modClass == WIFI_MOD_CLASS_DMG_OFDM || item->modClass == WIFI_MOD_CLASS_DMG_LP_SC
<       || item->modClass == WIFI_MOD_CLASS_EDMG_CTRL || item->modClass == WIFI_MOD_CLASS_EDMG_SC
<       || item->modClass == WIFI_MOD_CLASS_EDMG_OFDM)
---
>   if (item->modClass == WIFI_MOD_CLASS_HT || item->modClass == WIFI_MOD_CLASS_VHT || item->modClass == WIFI_MOD_CLASS_HE)
501,521d492
< uint64_t
< WifiMode::GetBandwidth (void) const
< {
<   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   return item->bandwidth;
< }
< 
< uint64_t
< WifiMode::GetPhyRate (void) const
< {
<   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   return item->phyRate;
< }
< 
< uint64_t
< WifiMode::GetDataRate (void) const
< {
<   struct WifiModeFactory::WifiModeItem *item = WifiModeFactory::GetFactory ()->Get (m_uid);
<   return item->dataRate;
< }
< 
540c511
<   if (item->modClass >= WIFI_MOD_CLASS_HT)
---
>   if (item->modClass == WIFI_MOD_CLASS_HT || item->modClass == WIFI_MOD_CLASS_VHT || item->modClass == WIFI_MOD_CLASS_HE)
753,754c724,725
<   NS_ASSERT (modClass < WIFI_MOD_CLASS_HT);
<   //fill unused MCS item with a dummy value
---
>   NS_ASSERT (modClass != WIFI_MOD_CLASS_HT && modClass != WIFI_MOD_CLASS_VHT && modClass != WIFI_MOD_CLASS_HE);
>   //fill unused mcs item with a dummy value
761,832d731
< WifiModeFactory::CreateWifiMode (std::string uniqueName,
<                                  uint8_t mcsValue,
<                                  WifiModulationClass modClass,
<                                  bool isMandatory,
<                                  uint64_t bandwidth,
<                                  uint64_t dataRate,
<                                  WifiCodeRate codingRate,
<                                  uint16_t constellationSize)
< {
<   WifiModeFactory *factory = GetFactory ();
<   uint32_t uid = factory->AllocateUid (uniqueName);
<   WifiModeItem *item = factory->Get (uid);
<   item->uniqueUid = uniqueName;
<   item->mcsValue = mcsValue;
<   item->modClass = modClass;
<   //The modulation class for this WifiMode must be valid.
<   NS_ASSERT (modClass != WIFI_MOD_CLASS_UNKNOWN);
<   item->bandwidth = bandwidth;
<   item->dataRate = dataRate;
<   item->codingRate = codingRate;
< 
<   switch (codingRate)
<     {
<     case WIFI_CODE_RATE_5_6:
<       item->phyRate = dataRate * 6 / 5;
<       break;
<     case WIFI_CODE_RATE_3_4:
<       item->phyRate = dataRate * 4 / 3;
<       break;
<     case WIFI_CODE_RATE_2_3:
<       item->phyRate = dataRate * 3 / 2;
<       break;
<     case WIFI_CODE_RATE_1_2:
<       item->phyRate = dataRate * 2 / 1;
<       break;
<     case WIFI_CODE_RATE_5_8:
<       item->phyRate = dataRate * 8 / 5;
<       break;
<     case WIFI_CODE_RATE_13_16:
<       item->phyRate = dataRate * 16 / 13;
<       break;
<     case WIFI_CODE_RATE_1_4:
<       item->phyRate = dataRate * 4 / 1;
<       break;
<     case WIFI_CODE_RATE_7_8:
<       item->phyRate = dataRate * 8 / 7;
<       break;
<     case WIFI_CODE_RATE_UNDEFINED:
<     default:
<       NS_ABORT_MSG ("Non-supported coding rate");
<       break;
<     }
< 
<   //Check for compatibility between modulation class and coding
<   //rate. If modulation class is DSSS then coding rate must be
<   //undefined, and vice versa. I could have done this with an
<   //assertion, but it seems better to always give the error (i.e.,
<   //not only in non-optimised builds) and the cycles that extra test
<   //here costs are only suffered at simulation setup.
<   if ((codingRate == WIFI_CODE_RATE_UNDEFINED) != (modClass == WIFI_MOD_CLASS_DSSS))
<     {
<       NS_FATAL_ERROR ("Error in creation of WifiMode named " << uniqueName << std::endl
<                                                              << "Code rate must be WIFI_CODE_RATE_UNDEFINED iff Modulation Class is WIFI_MOD_CLASS_DSSS");
<     }
< 
<   item->constellationSize = constellationSize;
<   item->isMandatory = isMandatory;
< 
<   return WifiMode (uid);
< }
< 
< WifiMode
843c742,743
<   NS_ASSERT (modClass >= WIFI_MOD_CLASS_HT);
---
>   //The modulation class must be either HT, VHT or HE
>   NS_ASSERT (modClass == WIFI_MOD_CLASS_HT || modClass == WIFI_MOD_CLASS_VHT || modClass == WIFI_MOD_CLASS_HE);
diff ../../NS3-WiGig/src/wifi/model/wifi-mode.h ../../ns-3-dev-git/src/wifi/model/wifi-mode.h
59,72d58
<   /** DMG Control PHY (Clause 21.4) 802.11ad */
<   WIFI_MOD_CLASS_DMG_CTRL,
<   /** DMG OFDM PHY (Clause 21.5) 802.11ad */
<   WIFI_MOD_CLASS_DMG_OFDM,
<   /** DMG SC PHY (Clause 21.6) 802.11ad */
<   WIFI_MOD_CLASS_DMG_SC,
<   /** DMG Low-Power SC PHY (Clause 21.7) 802.11ad */
<   WIFI_MOD_CLASS_DMG_LP_SC,
<   /** DMG Control PHY (Clause 21.4) 802.11ay */
<   WIFI_MOD_CLASS_EDMG_CTRL,
<   /** DMG OFDM PHY (Clause 21.5) 802.11ay */
<   WIFI_MOD_CLASS_EDMG_OFDM,
<   /** DMG SC PHY (Clause 21.6) 802.11ay */
<   WIFI_MOD_CLASS_EDMG_SC,
97,113c83
<   WIFI_CODE_RATE_5_6,
<   /** Rate 5/8 */
<   WIFI_CODE_RATE_5_8,
<   /** Rate 13/16 */
<   WIFI_CODE_RATE_13_16,
<   /** Rate 1/4 - really 1/2 rep 2 */
<   WIFI_CODE_RATE_1_4,
<   /** Rate 13/28 */
<   WIFI_CODE_RATE_13_28,
<   /** Rate 13/21 */
<   WIFI_CODE_RATE_13_21,
<   /** Rate 52/63 */
<   WIFI_CODE_RATE_52_63,
<   /** Rate 13/14 */
<   WIFI_CODE_RATE_13_14,
<   /** Rate 7/8 */
<   WIFI_CODE_RATE_7_8,
---
>   WIFI_CODE_RATE_5_6
143c113
<    * \returns the physical bit rate of this signal in bps.
---
>    * \returns the physical bit rate of this signal.
146c116
<    * data rate is 3.25Mbps, the PHY rate is 6.5Mbps
---
>    * data rate is 3.25Mbps, the phy rate is 6.5Mbps
152c122
<    * \returns the physical bit rate of this signal in bps.
---
>    * \returns the physical bit rate of this signal.
155c125
<    * data rate is 3.25Mbps, the PHY rate is 6.5Mbps
---
>    * data rate is 3.25Mbps, the phy rate is 6.5Mbps
164c134
<    * \returns the data bit rate of this signal in bps.
---
>    * \returns the data bit rate of this signal.
179,183d148
<   /**
<    *
<    * \returns the data bit rate of this DMG signal.
<    */
<   uint64_t GetDmgDataRate (void) const;
208c173
<    * \returns the UID associated to this wireless mode.
---
>    * \returns the uid associated to this wireless mode.
210c175
<    * Each specific wireless mode should have a different UID.
---
>    * Each specific wireless mode should have a different uid.
212c177
<    * should have different UIDs.
---
>    * should have different uids.
231c196
<    * \param mode the WifiMode
---
>    * \param mode wifi mode
237c202
<    * \param mode the WifiMode
---
>    * \param mode wifi mode
258,272d222
<   /**
<    * \returns the number of Hz used by this signal
<    */
<   uint64_t GetBandwidth (void) const;
<   /**
<    * \returns the physical bit rate of this signal.
<    *
<    * If a transmission mode uses 1/2 FEC, and if its
<    * data rate is 3Mbps, the phy rate is 6Mbps
<    */
<   uint64_t GetPhyRate (void) const;
<   /**
<    * \returns the data bit rate of this signal.
<    */
<   uint64_t GetDataRate (void) const;
276a227,228
>   /// allow WifiPhyTag class access
>   friend class WifiPhyTag; // access the UID-based constructor
286,294c238
< /**
<  * Check if the two WifiModes are identical.
<  *
<  * \param a WifiMode
<  * \param b WifiMode
<  *
<  * \return true if the two WifiModes are identical,
<  *         false otherwise
<  */
---
> /// equality operator
296,304d239
< /**
<  * Compare two WifiModes
<  *
<  * \param a WifiMode
<  * \param b WifiMode
<  *
<  * \return true if a is less than b,
<  *         false otherwise
<  */
306,313d240
< /**
<  * Serialize WifiMode to ostream (human-readable).
<  *
<  * \param os the output stream
<  * \param mode the WifiMode
<  *
<  * \return std::ostream
<  */
315,322d241
< /**
<  * Serialize WifiMode from istream (human-readable).
<  *
<  * \param is the input stream
<  * \param mode the WifiMode
<  *
<  * \return std::istream
<  */
362c281
<    * Create a non-HT WifiMode.
---
>    * Create a WifiMode (not used for HT or VHT).
373,400d291
<    * \param mcsValue the MCS value
<    * \param modClass the class of modulation
<    * \param isMandatory true if this WifiMode is mandatory, false otherwise.
<    * \param bandwidth the bandwidth (Hz) of the signal generated when the
<    *        associated WifiMode is used.
<    * \param dataRate the rate (bits/second) measured at the MAC SAP..
<    * \param codingRate if convolutional coding is used for this rate
<    *        then this parameter specifies the convolutional coding rate
<    *        used. If there is no explicit convolutional coding step (e.g.,
<    *        for DSSS rates) then the caller should set this parameter to
<    *        WIFI_CODE_RATE_UNCODED.
<    * \param constellationSize the order of the constellation used.
<    *
<    * \return WifiMode
<    *
<    * Create a WifiMode.
<    */
<   static WifiMode CreateWifiMode (std::string uniqueName,
<                                   uint8_t mcsValue,
<                                   WifiModulationClass modClass,
<                                   bool isMandatory,
<                                   uint64_t bandwidth,
<                                   uint64_t dataRate,
<                                   WifiCodeRate codingRate,
<                                   uint16_t constellationSize);
<   /**
<    * \param uniqueName the name of the associated WifiMode. This name
<    *        must be unique accross _all_ instances.
434,436d324
<     uint64_t bandwidth;
<     uint64_t dataRate;
<     uint64_t phyRate;
449c337
<    * \return the WifiMode
---
>    * \return WifiMode
455c343
<    * \param uniqueUid the unique UID
---
>    * \param uniqueUid
457c345
<    * \return the allocated UID index
---
>    * \return uid
461c349
<    * Return a WifiModeItem at the given UID index.
---
>    * Return a WifiModeItem at the given uid index.
463c351
<    * \param uid the UID index
---
>    * \param uid
465c353
<    * \return WifiModeItem at the given UID
---
>    * \return WifiModeItem at the given uid
diff ../../NS3-WiGig/src/wifi/model/wifi-mpdu-type.h ../../ns-3-dev-git/src/wifi/model/wifi-mpdu-type.h
34,40c34,36
<   /** The MPDU is a single MPDU */
<   SINGLE_MPDU,
<   /** The MPDU is the first aggregate in an A-MPDU with multiple MPDUs, but is not the last aggregate */
<   FIRST_MPDU_IN_AGGREGATE,
<   /** The MPDU is part of an A-MPDU with multiple MPDUs, but is neither the first nor the last aggregate */
<   MIDDLE_MPDU_IN_AGGREGATE,
<   /** The MPDU is the last aggregate in an A-MPDU with multiple MPDUs */
---
>   /** The MPDU is part of an A-MPDU, but is not the last aggregate */
>   MPDU_IN_AGGREGATE,
>   /** The MPDU is the last aggregate in an A-MPDU */
diff ../../NS3-WiGig/src/wifi/model/wifi-net-device.cc ../../ns-3-dev-git/src/wifi/model/wifi-net-device.cc
22a23
> #include "ns3/socket.h"
26c27
< #include "ns3/uinteger.h"
---
> #include "ns3/net-device-queue-interface.h"
29,43c30,31
< #include "wifi-mac.h"
< #include "ht-configuration.h"
< #include "vht-configuration.h"
< #include "he-configuration.h"
< #include "ns3/ipv4-header.h"
< 
< #include "ns3/srnc.h"
< #include "ns3/srnc-header.h"
< #include "ns3/srnc-tag.h"
< 
< #include <iostream>
< #include <fstream>
< 
< using namespace ns3;
< using namespace std;
---
> #include "regular-wifi-mac.h"
> #include "wifi-mac-queue.h"
82,96d69
<     .AddAttribute ("HtConfiguration",
<                    "The HtConfiguration object.",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiNetDevice::GetHtConfiguration),
<                    MakePointerChecker<HtConfiguration> ())
<     .AddAttribute ("VhtConfiguration",
<                    "The VhtConfiguration object.",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiNetDevice::GetVhtConfiguration),
<                    MakePointerChecker<VhtConfiguration> ())
<     .AddAttribute ("HeConfiguration",
<                    "The HeConfiguration object.",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiNetDevice::GetHeConfiguration),
<                    MakePointerChecker<HeConfiguration> ())
117,146c90,96
<   if (m_mac)
<     {
<       m_mac->Dispose ();
<       m_mac = 0;
<     }
<   if (m_phy)
<     {
<       m_phy->Dispose ();
<       m_phy = 0;
<     }
<   if (m_stationManager)
<     {
<       m_stationManager->Dispose ();
<       m_stationManager = 0;
<     }
<   if (m_htConfiguration)
<     {
<       m_htConfiguration->Dispose ();
<       m_htConfiguration = 0;
<     }
<   if (m_vhtConfiguration)
<     {
<       m_vhtConfiguration->Dispose ();
<       m_vhtConfiguration = 0;
<     }
<   if (m_heConfiguration)
<     {
<       m_heConfiguration->Dispose ();
<       m_heConfiguration = 0;
<     }
---
>   m_mac->Dispose ();
>   m_phy->Dispose ();
>   m_stationManager->Dispose ();
>   m_mac = 0;
>   m_phy = 0;
>   m_stationManager = 0;
>   m_queueInterface = 0;
154,165c104,106
<   if (m_phy)
<     {
<       m_phy->Initialize ();
<     }
<   if (m_mac)
<     {
<       m_mac->Initialize ();
<     }
<   if (m_stationManager)
<     {
<       m_stationManager->Initialize ();
<     }
---
>   m_phy->Initialize ();
>   m_mac->Initialize ();
>   m_stationManager->Initialize ();
190a132,202
> WifiNetDevice::NotifyNewAggregate (void)
> {
>   NS_LOG_FUNCTION (this);
>   if (m_queueInterface == 0)
>     {
>       Ptr<NetDeviceQueueInterface> ndqi = this->GetObject<NetDeviceQueueInterface> ();
>       //verify that it's a valid netdevice queue interface and that
>       //the netdevice queue interface was not set before
>       if (ndqi != 0)
>         {
>           m_queueInterface = ndqi;
>           // register the select queue callback
>           m_queueInterface->SetSelectQueueCallback (MakeCallback (&WifiNetDevice::SelectQueue, this));
>           m_queueInterface->SetLateTxQueuesCreation (true);
>           FlowControlConfig ();
>         }
>     }
>   NetDevice::NotifyNewAggregate ();
> }
> 
> void
> WifiNetDevice::FlowControlConfig (void)
> {
>   if (m_mac == 0 || m_queueInterface == 0)
>     {
>       return;
>     }
> 
>   Ptr<RegularWifiMac> mac = DynamicCast<RegularWifiMac> (m_mac);
>   if (mac == 0)
>     {
>       NS_LOG_WARN ("Flow control is only supported by RegularWifiMac");
>       return;
>     }
> 
>   BooleanValue qosSupported;
>   mac->GetAttributeFailSafe ("QosSupported", qosSupported);
>   PointerValue ptr;
>   Ptr<WifiMacQueue> wmq;
>   if (qosSupported.Get ())
>     {
>       m_queueInterface->SetTxQueuesN (4);
>       m_queueInterface->CreateTxQueues ();
> 
>       mac->GetAttributeFailSafe ("BE_Txop", ptr);
>       wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
>       m_queueInterface->ConnectQueueTraces<WifiMacQueueItem> (wmq, 0);
> 
>       mac->GetAttributeFailSafe ("BK_Txop", ptr);
>       wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
>       m_queueInterface->ConnectQueueTraces<WifiMacQueueItem> (wmq, 1);
> 
>       mac->GetAttributeFailSafe ("VI_Txop", ptr);
>       wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
>       m_queueInterface->ConnectQueueTraces<WifiMacQueueItem> (wmq, 2);
> 
>       mac->GetAttributeFailSafe ("VO_Txop", ptr);
>       wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
>       m_queueInterface->ConnectQueueTraces<WifiMacQueueItem> (wmq, 3);
>     }
>   else
>     {
>       m_queueInterface->CreateTxQueues ();
> 
>       mac->GetAttributeFailSafe ("Txop", ptr);
>       wmq = ptr.Get<Txop> ()->GetWifiMacQueue ();
>       m_queueInterface->ConnectQueueTraces<WifiMacQueueItem> (wmq, 0);
>     }
> }
> 
> void
194a207
>   FlowControlConfig ();
337,357d349
<   // Ptr<Node> RxNowNode = GetNode();
< 
<   // Ipv4Header iHD;
<   // packet->PeekHeader (iHD);
<   // uint32_t m_RecvIncomingLabel = iHD.GetEncodedLabel();
<   // uint8_t pri = iHD.GetPri();
<   // std::cout << "pkt size = " << packet->GetSize ()  << "nodeid = " << RxNowNodeID << "\n";
<   // if (RxNowNodeID  == 3)
<   // {
<   //   ofstream fout;
<   //   fout.open( "0_AP1_lable.txt" ,ios::app);
<   //   fout << Simulator::Now ().GetSeconds ()  <<  " "  << m_RecvIncomingLabel+(int(pri)/2)*10000 << "\n";
<   //   fout.close();
<   // }
<   // else if (RxNowNodeID  == 4)
<   // {
<   //   ofstream fout;
<   //   fout.open( "0_AP2_lable.txt" ,ios::app);
<   //   fout << Simulator::Now ().GetSeconds ()  <<  " "  << m_RecvIncomingLabel+(int(pri)/2)*10000 << "\n";
<   //   fout.close();
<   // }
360a353
> 
392c385
< WifiNetDevice::ForwardUp (Ptr<const Packet> packet, Mac48Address from, Mac48Address to)
---
> WifiNetDevice::ForwardUp (Ptr<Packet> packet, Mac48Address from, Mac48Address to)
414d406
<   Ptr<Packet> copy = packet->Copy ();
418,419c410,411
<       copy->RemoveHeader (llc);
<       m_forwardUp (this, copy, llc.GetType (), from);
---
>       packet->RemoveHeader (llc);
>       m_forwardUp (this, packet, llc.GetType (), from);
423c415
<       copy->RemoveHeader (llc);
---
>       packet->RemoveHeader (llc);
428,429c420,421
<       m_mac->NotifyPromiscRx (copy);
<       m_promiscRx (this, copy, llc.GetType (), from, to, type);
---
>       m_mac->NotifyPromiscRx (packet);
>       m_promiscRx (this, packet, llc.GetType (), from, to, type);
480,481c472,473
< void
< WifiNetDevice::SetHtConfiguration (Ptr<HtConfiguration> htConfiguration)
---
> uint8_t
> WifiNetDevice::SelectQueue (Ptr<QueueItem> item) const
483,484c475
<   m_htConfiguration = htConfiguration;
< }
---
>   NS_LOG_FUNCTION (this << item);
486,490c477
< Ptr<HtConfiguration>
< WifiNetDevice::GetHtConfiguration (void) const
< {
<   return m_htConfiguration;
< }
---
>   NS_ASSERT (m_queueInterface != 0);
492,496c479,482
< void
< WifiNetDevice::SetVhtConfiguration (Ptr<VhtConfiguration> vhtConfiguration)
< {
<   m_vhtConfiguration = vhtConfiguration;
< }
---
>   if (m_queueInterface->GetNTxQueues () == 1)
>     {
>       return 0;
>     }
498,502c484,491
< Ptr<VhtConfiguration>
< WifiNetDevice::GetVhtConfiguration (void) const
< {
<   return m_vhtConfiguration;
< }
---
>   uint8_t dscp, priority = 0;
>   if (item->GetUint8Value (QueueItem::IP_DSFIELD, dscp))
>     {
>       // if the QoS map element is implemented, it should be used here
>       // to set the priority.
>       // User priority is set to the three most significant bits of the DS field
>       priority = dscp >> 5;
>     }
504,508c493,496
< void
< WifiNetDevice::SetHeConfiguration (Ptr<HeConfiguration> heConfiguration)
< {
<   m_heConfiguration = heConfiguration;
< }
---
>   // replace the priority tag
>   SocketPriorityTag priorityTag;
>   priorityTag.SetPriority (priority);
>   item->GetPacket ()->ReplacePacketTag (priorityTag);
510,513c498,501
< Ptr<HeConfiguration>
< WifiNetDevice::GetHeConfiguration (void) const
< {
<   return m_heConfiguration;
---
>   // if the admission control were implemented, here we should check whether
>   // the access category assigned to the packet should be downgraded
> 
>   return static_cast<uint8_t> (QosUtilsMapTidToAc (priority));
diff ../../NS3-WiGig/src/wifi/model/wifi-net-device.h ../../ns-3-dev-git/src/wifi/model/wifi-net-device.h
32,34c32,33
< class HtConfiguration;
< class VhtConfiguration;
< class HeConfiguration;
---
> class NetDeviceQueueInterface;
> class QueueItem;
66c65
<    * \param mac the MAC layer to use.
---
>    * \param mac the mac layer to use.
70c69
<    * \param phy the PHY layer to use.
---
>    * \param phy the phy layer to use.
78c77
<    * \returns the MAC we are currently using.
---
>    * \returns the mac we are currently using.
82c81
<    * \returns the PHY we are currently using.
---
>    * \returns the phy we are currently using.
90,113d88
<   /**
<    * \param htConfiguration pointer to HtConfiguration
<    */
<   void SetHtConfiguration (Ptr<HtConfiguration> htConfiguration);
<   /**
<    * \return pointer to HtConfiguration if it exists
<    */
<   Ptr<HtConfiguration> GetHtConfiguration (void) const;
<   /**
<    * \param vhtConfiguration pointer to VhtConfiguration
<    */
<   void SetVhtConfiguration (Ptr<VhtConfiguration> vhtConfiguration);
<   /**
<    * \return pointer to VhtConfiguration if it exists
<    */
<   Ptr<VhtConfiguration> GetVhtConfiguration (void) const;
<   /**
<    * \param heConfiguration pointer to HeConfiguration
<    */
<   void SetHeConfiguration (Ptr<HeConfiguration> heConfiguration);
<   /**
<    * \return pointer to HeConfiguration if it exists
<    */
<   Ptr<HeConfiguration> GetHeConfiguration (void) const;
144a120
>   void NotifyNewAggregate (void);
149,151c125,127
<    * \param packet the packet to forward up
<    * \param from the source address
<    * \param to the destination address
---
>    * \param packet
>    * \param from
>    * \param to
153c129
<   void ForwardUp (Ptr<const Packet> packet, Mac48Address from, Mac48Address to);
---
>   void ForwardUp (Ptr<Packet> packet, Mac48Address from, Mac48Address to);
187a164,211
>   /**
>    * Perform the actions needed to support flow control and dynamic queue limits
>    */
>   void FlowControlConfig (void);
> 
>   /**
>    * \brief Determine the tx queue for a given packet
>    * \param item the packet
>    * \returns the access category
>    *
>    * Modelled after the Linux function ieee80211_select_queue (net/mac80211/wme.c).
>    * A SocketPriority tag is attached to the packet (or the existing one is
>    * replaced) to carry the user priority, which is set to the three most
>    * significant bits of the DS field (TOS field in case of IPv4 and Traffic
>    * Class field in case of IPv6). The Access Category corresponding to the
>    * user priority according to the QosUtilsMapTidToAc function is returned.
>    *
>    * The following table shows the mapping for the Diffserv Per Hop Behaviors.
>    *
>    * PHB  | TOS (binary) | UP  | Access Category
>    * -----|--------------|-----|-----------------
>    * EF   |   101110xx   |  5  |     AC_VI
>    * AF11 |   001010xx   |  1  |     AC_BK
>    * AF21 |   010010xx   |  2  |     AC_BK
>    * AF31 |   011010xx   |  3  |     AC_BE
>    * AF41 |   100010xx   |  4  |     AC_VI
>    * AF12 |   001100xx   |  1  |     AC_BK
>    * AF22 |   010100xx   |  2  |     AC_BK
>    * AF32 |   011100xx   |  3  |     AC_BE
>    * AF42 |   100100xx   |  4  |     AC_VI
>    * AF13 |   001110xx   |  1  |     AC_BK
>    * AF23 |   010110xx   |  2  |     AC_BK
>    * AF33 |   011110xx   |  3  |     AC_BE
>    * AF43 |   100110xx   |  4  |     AC_VI
>    * CS0  |   000000xx   |  0  |     AC_BE
>    * CS1  |   001000xx   |  1  |     AC_BK
>    * CS2  |   010000xx   |  2  |     AC_BK
>    * CS3  |   011000xx   |  3  |     AC_BE
>    * CS4  |   100000xx   |  4  |     AC_VI
>    * CS5  |   101000xx   |  5  |     AC_VI
>    * CS6  |   110000xx   |  6  |     AC_VO
>    * CS7  |   111000xx   |  7  |     AC_VO
>    *
>    * This method is called by the traffic control layer before enqueuing a
>    * packet in the queue disc, if a queue disc is installed on the outgoing
>    * device, or passing a packet to the device, otherwise.
>    */
>   uint8_t SelectQueue (Ptr<QueueItem> item) const;
193,195c217
<   Ptr<HtConfiguration> m_htConfiguration; //!< the HtConfiguration
<   Ptr<VhtConfiguration> m_vhtConfiguration; //!< the VhtConfiguration
<   Ptr<HeConfiguration> m_heConfiguration; //!< the HeConfiguration
---
>   Ptr<NetDeviceQueueInterface> m_queueInterface;   //!< NetDevice queue interface
197c219
<   NetDevice::PromiscReceiveCallback m_promiscRx; //!< promiscuous receive callback
---
>   NetDevice::PromiscReceiveCallback m_promiscRx; //!< promiscious receive callback
diff ../../NS3-WiGig/src/wifi/model/wifi-phy.cc ../../ns-3-dev-git/src/wifi/model/wifi-phy.cc
27d26
< #include "ns3/error-model.h"
28a28
> #include "wifi-phy-tag.h"
32d31
< #include "preamble-detection-model.h"
35,41d33
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "he-configuration.h"
< #include "mpdu-aggregator.h"
< #include "wifi-psdu.h"
< #include "wifi-ppdu.h"
< #include "dmg-wifi-phy.h"
127c119
<   { std::make_pair (54, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5270, 40) },
---
>   { std::make_pair (54, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5230, 40) },
132c124
<   { std::make_pair (126, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5630, 40) },
---
>   { std::make_pair (126, WIFI_PHY_STANDARD_UNSPECIFIED), std::make_pair (5590, 40) },
159,199c151
<   { std::make_pair (184, WIFI_PHY_STANDARD_80211_10MHZ), std::make_pair (5920, 10) },
<   //// WIGIG ////
<   /* 802.11ad (2.16 GHz channels at the 56.16-64.8 GHz band) */
<   { std::make_pair (1, WIFI_PHY_STANDARD_80211ad), std::make_pair (58320, 2160) },
<   { std::make_pair (2, WIFI_PHY_STANDARD_80211ad), std::make_pair (60480, 2160) },
<   { std::make_pair (3, WIFI_PHY_STANDARD_80211ad), std::make_pair (62640, 2160) },
<   { std::make_pair (4, WIFI_PHY_STANDARD_80211ad), std::make_pair (64800, 2160) },
<   { std::make_pair (5, WIFI_PHY_STANDARD_80211ad), std::make_pair (66960, 2160) },
<   { std::make_pair (6, WIFI_PHY_STANDARD_80211ad), std::make_pair (69120, 2160) },
< 
<   /* IEEE 802.11ay D5.0 Figure 28-7 – Channelization used by EDMG STAs */
<   { std::make_pair (1, WIFI_PHY_STANDARD_80211ay), std::make_pair (58320, 2160) },
<   { std::make_pair (2, WIFI_PHY_STANDARD_80211ay), std::make_pair (60480, 2160) },
<   { std::make_pair (3, WIFI_PHY_STANDARD_80211ay), std::make_pair (62640, 2160) },
<   { std::make_pair (4, WIFI_PHY_STANDARD_80211ay), std::make_pair (64800, 2160) },
<   { std::make_pair (5, WIFI_PHY_STANDARD_80211ay), std::make_pair (66960, 2160) },
<   { std::make_pair (6, WIFI_PHY_STANDARD_80211ay), std::make_pair (69120, 2160) },
<   { std::make_pair (7, WIFI_PHY_STANDARD_80211ay), std::make_pair (71280, 2160) },
<   { std::make_pair (8, WIFI_PHY_STANDARD_80211ay), std::make_pair (73440, 2160) },
< 
<   { std::make_pair (9, WIFI_PHY_STANDARD_80211ay), std::make_pair (59400, 4320) },
<   { std::make_pair (10, WIFI_PHY_STANDARD_80211ay), std::make_pair (61560, 4320) },
<   { std::make_pair (11, WIFI_PHY_STANDARD_80211ay), std::make_pair (63720, 4320) },
<   { std::make_pair (12, WIFI_PHY_STANDARD_80211ay), std::make_pair (65880, 4320) },
<   { std::make_pair (13, WIFI_PHY_STANDARD_80211ay), std::make_pair (68040, 4320) },
<   { std::make_pair (14, WIFI_PHY_STANDARD_80211ay), std::make_pair (70200, 4320) },
<   { std::make_pair (15, WIFI_PHY_STANDARD_80211ay), std::make_pair (72360, 4320) },
< 
<   { std::make_pair (17, WIFI_PHY_STANDARD_80211ay), std::make_pair (60480, 6480) },
<   { std::make_pair (18, WIFI_PHY_STANDARD_80211ay), std::make_pair (62640, 6480) },
<   { std::make_pair (19, WIFI_PHY_STANDARD_80211ay), std::make_pair (64800, 6480) },
<   { std::make_pair (20, WIFI_PHY_STANDARD_80211ay), std::make_pair (66960, 6480) },
<   { std::make_pair (21, WIFI_PHY_STANDARD_80211ay), std::make_pair (69120, 6480) },
<   { std::make_pair (22, WIFI_PHY_STANDARD_80211ay), std::make_pair (71280, 6480) },
< 
<   { std::make_pair (25, WIFI_PHY_STANDARD_80211ay), std::make_pair (61560, 8640) },
<   { std::make_pair (26, WIFI_PHY_STANDARD_80211ay), std::make_pair (63720, 8640) },
<   { std::make_pair (27, WIFI_PHY_STANDARD_80211ay), std::make_pair (65880, 8640) },
<   { std::make_pair (28, WIFI_PHY_STANDARD_80211ay), std::make_pair (68040, 8640) },
<   { std::make_pair (29, WIFI_PHY_STANDARD_80211ay), std::make_pair (70200, 8640) },
<   //// WIGIG ////
---
>   { std::make_pair (184, WIFI_PHY_STANDARD_80211_10MHZ), std::make_pair (5920, 10) }
215c167
<                    "Whether 5MHz, 10MHz, 20MHz, 22MHz, 40MHz, 80 MHz or 160 MHz or 2160.",
---
>                    "Whether 5MHz, 10MHz, 20MHz, 22MHz, 40MHz, 80 MHz or 160 MHz.",
219c171
<                    MakeUintegerChecker<uint16_t> (5, 2160))
---
>                    MakeUintegerChecker<uint16_t> (5, 160))
228,229c180,181
<                    "this threshold (dBm) to allow the PHY layer to detect the signal.",
<                    DoubleValue (-101.0),
---
>                    "this threshold (dbm) to allow the PHY layer to detect the signal.",
>                    DoubleValue (-96.0),
231,238d182
<                    MakeDoubleChecker<double> (),
<                    TypeId::DEPRECATED, "Replaced by RxSensitivity.")
<     .AddAttribute ("RxSensitivity",
<                    "The energy of a received signal should be higher than "
<                    "this threshold (dBm) for the PHY to detect the signal.",
<                    DoubleValue (-101.0),
<                    MakeDoubleAccessor (&WifiPhy::SetRxSensitivity,
<                                        &WifiPhy::GetRxSensitivity),
240,246c184,189
<     .AddAttribute ("CcaEdThreshold",
<                    "The energy of a non Wi-Fi received signal should be higher than "
<                    "this threshold (dBm) to allow the PHY layer to declare CCA BUSY state. "
<                    "This check is performed on the 20 MHz primary channel only.",
<                    DoubleValue (-62.0),
<                    MakeDoubleAccessor (&WifiPhy::SetCcaEdThreshold,
<                                        &WifiPhy::GetCcaEdThreshold),
---
>     .AddAttribute ("CcaMode1Threshold",
>                    "The energy of a received signal should be higher than "
>                    "this threshold (dbm) to allow the PHY layer to declare CCA BUSY state.",
>                    DoubleValue (-99.0),
>                    MakeDoubleAccessor (&WifiPhy::SetCcaMode1Threshold,
>                                        &WifiPhy::GetCcaMode1Threshold),
267c210
<                    "Maximum available transmission level (dBm).",
---
>                    "Maximum available transmission level (dbm).",
273c216
<                    "Minimum available transmission level (dBm).",
---
>                    "Minimum available transmission level (dbm).",
324,325c267
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Use the HtConfiguration instead")
---
>                    MakeBooleanChecker ())
332,333c274,286
<                    MakeTimeChecker (NanoSeconds (800), NanoSeconds (3200)),
<                    TypeId::DEPRECATED, "Use the HeConfiguration instead")
---
>                    MakeTimeChecker (NanoSeconds (400), NanoSeconds (3200)))
>     .AddAttribute ("LdpcEnabled",
>                    "Whether or not LDPC is enabled (not supported yet!).",
>                    BooleanValue (false),
>                    MakeBooleanAccessor (&WifiPhy::GetLdpc,
>                                         &WifiPhy::SetLdpc),
>                    MakeBooleanChecker ())
>     .AddAttribute ("STBCEnabled",
>                    "Whether or not STBC is enabled (not supported yet!).",
>                    BooleanValue (false),
>                    MakeBooleanAccessor (&WifiPhy::GetStbc,
>                                         &WifiPhy::SetStbc),
>                    MakeBooleanChecker ())
340,341c293
<                    MakeBooleanChecker (),
<                    TypeId::DEPRECATED, "Use the HtConfiguration instead")
---
>                    MakeBooleanChecker ())
343c295
<                    "Whether or not short PHY preamble is supported."
---
>                    "Whether or not short PLCP preamble is supported."
345c297
<                    "Note: 802.11g APs and STAs always support short PHY preamble.",
---
>                    "Note: 802.11g APs and STAs always support short PLCP preamble.",
347,348c299,300
<                    MakeBooleanAccessor (&WifiPhy::GetShortPhyPreambleSupported,
<                                         &WifiPhy::SetShortPhyPreambleSupported),
---
>                    MakeBooleanAccessor (&WifiPhy::GetShortPlcpPreambleSupported,
>                                         &WifiPhy::SetShortPlcpPreambleSupported),
355,367d306
<     .AddAttribute ("PreambleDetectionModel",
<                    "Ptr to an object that implements the preamble detection model",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiPhy::m_preambleDetectionModel),
<                    MakePointerChecker <PreambleDetectionModel> ())
<     .AddAttribute ("PostReceptionErrorModel",
<                    "An optional packet error model can be added to the receive "
<                    "packet process after any propagation-based (SNR-based) error "
<                    "models have been applied. Typically this is used to force "
<                    "specific packet drops, for testing purposes.",
<                    PointerValue (),
<                    MakePointerAccessor (&WifiPhy::m_postReceptionErrorModel),
<                    MakePointerChecker<ErrorModel> ())
373,377d311
<     .AddTraceSource ("PhyTxPsduBegin",
<                      "Trace source indicating a PSDU "
<                      "has begun transmitting over the channel medium",
<                      MakeTraceSourceAccessor (&WifiPhy::m_phyTxPsduBeginTrace),
<                      "ns3::WifiPhy::PsduTxBeginCallback")
380c314,317
<                      "has been completely transmitted over the channel.",
---
>                      "has been completely transmitted over the channel. "
>                      "NOTE: the only official WifiPhy implementation "
>                      "available to this date never fires "
>                      "this trace source.",
394,398d330
<     .AddTraceSource ("PhyRxPayloadBegin",
<                      "Trace source indicating the reception of the "
<                      "payload of a PPDU has begun",
<                      MakeTraceSourceAccessor (&WifiPhy::m_phyRxPayloadBeginTrace),
<                      "ns3::WifiPhy::PhyRxPayloadBeginTracedCallback")
420,423d351
<     .AddTraceSource ("EndOfHePreamble",
<                      "Trace source indicating the end of the 802.11ax preamble (after training fields)",
<                      MakeTraceSourceAccessor (&WifiPhy::m_phyEndOfHePreambleTrace),
<                      "ns3::WifiPhy::EndOfHePreambleTracedCallback")
429c357,359
<   : m_txMpduReferenceNumber (0xffffffff),
---
>   : m_mpdusNum (0),
>     m_plcpSuccess (false),
>     m_txMpduReferenceNumber (0xffffffff),
432,437c362
<     m_endPhyRxEvent (),
<     m_endPreambleDetectionEvent (),
<     m_endTxEvent (),
<     m_currentEvent (0),
<     m_wifiRadioEnergyModel (0),
<     m_isConstructed (false),
---
>     m_endPlcpRxEvent (),
438a364
>     m_isConstructed (false),
443,444d368
<     m_powerRestricted (false),
<     m_channelAccessRequested (false),
449c373,376
<     m_timeLastPreambleDetected (Seconds (0))
---
>     m_totalAmpduSize (0),
>     m_totalAmpduNumSymbols (0),
>     m_currentEvent (0),
>     m_wifiRadioEnergyModel (0)
454d380
<   m_interference.SetWifiPhy (this);
466,469d391
<   m_endTxEvent.Cancel ();
<   m_endRxEvent.Cancel ();
<   m_endPhyRxEvent.Cancel ();
<   m_endPreambleDetectionEvent.Cancel ();
474d395
<   m_postReceptionErrorModel = 0;
477d397
<   m_mcsIndexMap.clear ();
493,498d412
< Ptr<WifiPhyStateHelper>
< WifiPhy::GetState (void) const
< {
<   return m_state;
< }
< 
560,565d473
<   SetRxSensitivity (threshold);
< }
< 
< void
< WifiPhy::SetRxSensitivity (double threshold)
< {
567c475
<   m_rxSensitivityW = DbmToW (threshold);
---
>   m_edThresholdW = DbmToW (threshold);
571c479
< WifiPhy::GetRxSensitivity (void) const
---
> WifiPhy::GetEdThreshold (void) const
573c481
<   return WToDbm (m_rxSensitivityW);
---
>   return WToDbm (m_edThresholdW);
577c485
< WifiPhy::SetCcaEdThreshold (double threshold)
---
> WifiPhy::SetCcaMode1Threshold (double threshold)
580c488
<   m_ccaEdThresholdW = DbmToW (threshold);
---
>   m_ccaMode1ThresholdW = DbmToW (threshold);
584c492
< WifiPhy::GetCcaEdThreshold (void) const
---
> WifiPhy::GetCcaMode1Threshold (void) const
586c494
<   return WToDbm (m_ccaEdThresholdW);
---
>   return WToDbm (m_ccaMode1ThresholdW);
597,602d504
< double
< WifiPhy::GetRxNoiseFigure (void) const
< {
<   return RatioToDb (m_interference.GetNoiseFigure ());
< }
< 
668a571,596
> WifiPhy::SetLdpc (bool ldpc)
> {
>   NS_LOG_FUNCTION (this << ldpc);
>   m_ldpc = ldpc;
> }
> 
> bool
> WifiPhy::GetLdpc (void) const
> {
>   return m_ldpc;
> }
> 
> void
> WifiPhy::SetStbc (bool stbc)
> {
>   NS_LOG_FUNCTION (this << stbc);
>   m_stbc = stbc;
> }
> 
> bool
> WifiPhy::GetStbc (void) const
> {
>   return m_stbc;
> }
> 
> void
672,680d599
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           htConfiguration->SetGreenfieldSupported (greenfield);
<         }
<     }
687,695d605
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           return htConfiguration->GetGreenfieldSupported ();
<         }
<     }
703,711d612
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           htConfiguration->SetShortGuardIntervalSupported (shortGuardInterval);
<         }
<     }
718,726d618
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       if (htConfiguration)
<         {
<           return htConfiguration->GetShortGuardIntervalSupported ();
<         }
<     }
735,743d626
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<       if (heConfiguration)
<         {
<           heConfiguration->SetGuardInterval (guardInterval);
<         }
<     }
750,758d632
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (GetDevice ());
<   if (device)
<     {
<       Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<       if (heConfiguration)
<         {
<           return heConfiguration->GetGuardInterval ();
<         }
<     }
763c637
< WifiPhy::SetShortPhyPreambleSupported (bool enable)
---
> WifiPhy::SetShortPlcpPreambleSupported (bool enable)
770c644
< WifiPhy::GetShortPhyPreambleSupported (void) const
---
> WifiPhy::GetShortPlcpPreambleSupported (void) const
779,790d652
<   //TODO: to be removed once deprecated API is cleaned up
<   Ptr<HtConfiguration> htConfiguration = DynamicCast<WifiNetDevice> (device)->GetHtConfiguration ();
<   if (htConfiguration)
<     {
<       htConfiguration->SetShortGuardIntervalSupported (m_shortGuardInterval);
<       htConfiguration->SetGreenfieldSupported (m_greenfield);
<     }
<   Ptr<HeConfiguration> heConfiguration = DynamicCast<WifiNetDevice> (device)->GetHeConfiguration ();
<   if (heConfiguration)
<     {
<       heConfiguration->SetGuardInterval (m_guardInterval);
<     }
826,832d687
< WifiPhy::SetPostReceptionErrorModel (const Ptr<ErrorModel> em)
< {
<   NS_LOG_FUNCTION (this << em);
<   m_postReceptionErrorModel = em;
< }
< 
< void
836,842d690
<   m_frameCaptureModel->SetWifiPhy (this);
< }
< 
< void
< WifiPhy::SetPreambleDetectionModel (const Ptr<PreambleDetectionModel> model)
< {
<   m_preambleDetectionModel = model;
935,943d782
<     //// WIGIG ////
<     case WIFI_PHY_STANDARD_80211ad:
<     case WIFI_PHY_STANDARD_80211ay:
<       SetChannelWidth (2160);
<       SetFrequency (58320);
<       // Channel number should be aligned by SetFrequency () to 1
<       NS_ASSERT (GetChannelNumber () == 1);
<       break;
<     //// WIGIG ////
1054,1078d892
< WifiPhy::PushMcs (WifiMode mode)
< {
<   NS_LOG_FUNCTION (this << mode);
< 
<   WifiModulationClass modulation = mode.GetModulationClass ();
<   NS_ASSERT (modulation == WIFI_MOD_CLASS_HT || modulation == WIFI_MOD_CLASS_VHT
<              || modulation == WIFI_MOD_CLASS_HE);
< 
<   m_mcsIndexMap[modulation][mode.GetMcsValue ()] = m_deviceMcsSet.size ();
<   m_deviceMcsSet.push_back (mode);
< }
< 
< void
< WifiPhy::RebuildMcsMap (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_mcsIndexMap.clear ();
<   uint8_t index = 0;
<   for (auto& mode : m_deviceMcsSet)
<     {
<       m_mcsIndexMap[mode.GetModulationClass ()][mode.GetMcsValue ()] = index++;
<     }
< }
< 
< void
1103,1111c917,924
<       RebuildMcsMap ();
<       PushMcs (WifiPhy::GetHtMcs0 ());
<       PushMcs (WifiPhy::GetHtMcs1 ());
<       PushMcs (WifiPhy::GetHtMcs2 ());
<       PushMcs (WifiPhy::GetHtMcs3 ());
<       PushMcs (WifiPhy::GetHtMcs4 ());
<       PushMcs (WifiPhy::GetHtMcs5 ());
<       PushMcs (WifiPhy::GetHtMcs6 ());
<       PushMcs (WifiPhy::GetHtMcs7 ());
---
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs0 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs1 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs2 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs3 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs4 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs5 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs6 ());
>       m_deviceMcsSet.push_back (WifiPhy::GetHtMcs7 ());
1114,1121c927,934
<           PushMcs (WifiPhy::GetHtMcs8 ());
<           PushMcs (WifiPhy::GetHtMcs9 ());
<           PushMcs (WifiPhy::GetHtMcs10 ());
<           PushMcs (WifiPhy::GetHtMcs11 ());
<           PushMcs (WifiPhy::GetHtMcs12 ());
<           PushMcs (WifiPhy::GetHtMcs13 ());
<           PushMcs (WifiPhy::GetHtMcs14 ());
<           PushMcs (WifiPhy::GetHtMcs15 ());
---
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs8 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs9 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs10 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs11 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs12 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs13 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs14 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs15 ());
1125,1132c938,945
<           PushMcs (WifiPhy::GetHtMcs16 ());
<           PushMcs (WifiPhy::GetHtMcs17 ());
<           PushMcs (WifiPhy::GetHtMcs18 ());
<           PushMcs (WifiPhy::GetHtMcs19 ());
<           PushMcs (WifiPhy::GetHtMcs20 ());
<           PushMcs (WifiPhy::GetHtMcs21 ());
<           PushMcs (WifiPhy::GetHtMcs22 ());
<           PushMcs (WifiPhy::GetHtMcs23 ());
---
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs16 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs17 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs18 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs19 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs20 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs21 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs22 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs23 ());
1136,1143c949,956
<           PushMcs (WifiPhy::GetHtMcs24 ());
<           PushMcs (WifiPhy::GetHtMcs25 ());
<           PushMcs (WifiPhy::GetHtMcs26 ());
<           PushMcs (WifiPhy::GetHtMcs27 ());
<           PushMcs (WifiPhy::GetHtMcs28 ());
<           PushMcs (WifiPhy::GetHtMcs29 ());
<           PushMcs (WifiPhy::GetHtMcs30 ());
<           PushMcs (WifiPhy::GetHtMcs31 ());
---
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs24 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs25 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs26 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs27 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs28 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs29 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs30 ());
>           m_deviceMcsSet.push_back (WifiPhy::GetHtMcs31 ());
1171,1180c984,993
<   PushMcs (WifiPhy::GetVhtMcs0 ());
<   PushMcs (WifiPhy::GetVhtMcs1 ());
<   PushMcs (WifiPhy::GetVhtMcs2 ());
<   PushMcs (WifiPhy::GetVhtMcs3 ());
<   PushMcs (WifiPhy::GetVhtMcs4 ());
<   PushMcs (WifiPhy::GetVhtMcs5 ());
<   PushMcs (WifiPhy::GetVhtMcs6 ());
<   PushMcs (WifiPhy::GetVhtMcs7 ());
<   PushMcs (WifiPhy::GetVhtMcs8 ());
<   PushMcs (WifiPhy::GetVhtMcs9 ());
---
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs0 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs1 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs2 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs3 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs4 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs5 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs6 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs7 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs8 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetVhtMcs9 ());
1188a1002
>   Configure80211n ();
1193,1209c1007,1018
<   else
<     {
<       Configure80211n ();
<     }
< 
<   PushMcs (WifiPhy::GetHeMcs0 ());
<   PushMcs (WifiPhy::GetHeMcs1 ());
<   PushMcs (WifiPhy::GetHeMcs2 ());
<   PushMcs (WifiPhy::GetHeMcs3 ());
<   PushMcs (WifiPhy::GetHeMcs4 ());
<   PushMcs (WifiPhy::GetHeMcs5 ());
<   PushMcs (WifiPhy::GetHeMcs6 ());
<   PushMcs (WifiPhy::GetHeMcs7 ());
<   PushMcs (WifiPhy::GetHeMcs8 ());
<   PushMcs (WifiPhy::GetHeMcs9 ());
<   PushMcs (WifiPhy::GetHeMcs10 ());
<   PushMcs (WifiPhy::GetHeMcs11 ());
---
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs0 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs1 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs2 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs3 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs4 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs5 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs6 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs7 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs8 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs9 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs10 ());
>   m_deviceMcsSet.push_back (WifiPhy::GetHeMcs11 ());
1328,1335c1137
<   DoConfigureStandard ();
< }
< 
< void
< WifiPhy::DoConfigureStandard (void)
< {
<   NS_LOG_FUNCTION (this);
<   switch (m_standard)
---
>   switch (standard)
1355a1158,1159
>       Configure80211n ();
>       break;
1362a1167,1168
>       Configure80211ax ();
>       break;
1443c1249
< WifiPhy::SetChannelWidth (uint16_t channelWidth)
---
> WifiPhy::SetChannelWidth (uint16_t channelwidth)
1445,1454c1251,1255
<   NS_LOG_FUNCTION (this << channelWidth);
<   //// WIGIG ////
<   NS_ASSERT_MSG (channelWidth == 5 || channelWidth == 10 || channelWidth == 20 || channelWidth == 22
<                  || channelWidth == 40 || channelWidth == 80 || channelWidth == 160
<                  || channelWidth == 2160 || channelWidth == 4320 || channelWidth == 6480 || channelWidth == 8640,
<                  "wrong channel width value");
<   //// WIGIG ////
<   bool changed = (m_channelWidth != channelWidth);
<   m_channelWidth = channelWidth;
<   AddSupportedChannelWidth (channelWidth);
---
>   NS_LOG_FUNCTION (this << channelwidth);
>   NS_ASSERT_MSG (channelwidth == 5 || channelwidth == 10 || channelwidth == 20 || channelwidth == 22 || channelwidth == 40 || channelwidth == 80 || channelwidth == 160, "wrong channel width value");
>   bool changed = (m_channelWidth == channelwidth);
>   m_channelWidth = channelwidth;
>   AddSupportedChannelWidth (channelwidth);
1485c1286
<   bool changed = (m_txSpatialStreams != streams);
---
>   bool changed = (m_txSpatialStreams == streams);
1504c1305
<   bool changed = (m_rxSpatialStreams != streams);
---
>   bool changed = (m_rxSpatialStreams == streams);
1622,1623d1422
<   m_powerRestricted = false;
<   m_channelAccessRequested = false;
1636c1435
<       m_endPhyRxEvent.Cancel ();
---
>       m_endPlcpRxEvent.Cancel ();
1638d1436
<       m_endPreambleDetectionEvent.Cancel ();
1647,1651d1444
<       if (m_endPreambleDetectionEvent.IsRunning ())
<         {
<           m_endPreambleDetectionEvent.Cancel ();
<           m_endRxEvent.Cancel ();
<         }
1682,1683d1474
<   m_powerRestricted = false;
<   m_channelAccessRequested = false;
1696c1487
<       m_endPhyRxEvent.Cancel ();
---
>       m_endPlcpRxEvent.Cancel ();
1698d1488
<       m_endPreambleDetectionEvent.Cancel ();
1707,1711d1496
<       if (m_endPreambleDetectionEvent.IsRunning ())
<         {
<           m_endPreambleDetectionEvent.Cancel ();
<           m_endRxEvent.Cancel ();
<         }
1743,1744d1527
<   m_powerRestricted = false;
<   m_channelAccessRequested = false;
1777,1783c1560,1575
<   m_powerRestricted = false;
<   m_channelAccessRequested = false;
<   m_endPhyRxEvent.Cancel ();
<   m_endRxEvent.Cancel ();
<   m_endPreambleDetectionEvent.Cancel ();
<   m_endTxEvent.Cancel ();
<   m_state->SwitchToOff ();
---
>   switch (m_state->GetState ())
>     {
>     case WifiPhyState::RX:
>       m_endPlcpRxEvent.Cancel ();
>       m_endRxEvent.Cancel ();
>     case WifiPhyState::TX:
>     case WifiPhyState::SWITCHING:
>     case WifiPhyState::CCA_BUSY:
>     case WifiPhyState::IDLE:
>     case WifiPhyState::SLEEP:
>       m_state->SwitchToOff ();
>       break;
>     default:
>       NS_ASSERT (false);
>       break;
>     }
1804c1596
<         Time delayUntilCcaEnd = m_interference.GetEnergyDuration (m_ccaEdThresholdW);
---
>         Time delayUntilCcaEnd = m_interference.GetEnergyDuration (m_ccaMode1ThresholdW);
1835c1627
<         Time delayUntilCcaEnd = m_interference.GetEnergyDuration (m_ccaEdThresholdW);
---
>         Time delayUntilCcaEnd = m_interference.GetEnergyDuration (DbmToW (GetCcaMode1Threshold ()));
1848c1640
< WifiPhy::GetHtPhyHeaderMode ()
---
> WifiPhy::GetHtPlcpHeaderMode ()
1854c1646
< WifiPhy::GetVhtPhyHeaderMode ()
---
> WifiPhy::GetVhtPlcpHeaderMode ()
1860c1652
< WifiPhy::GetHePhyHeaderMode ()
---
> WifiPhy::GetHePlcpHeaderMode ()
1866,1872c1658
< WifiPhy::GetPreambleDetectionDuration (void)
< {
<   return MicroSeconds (4);
< }
< 
< Time
< WifiPhy::GetPhyTrainingSymbolDuration (WifiTxVector txVector)
---
> WifiPhy::GetPlcpTrainingSymbolDuration (WifiTxVector txVector)
1909,1910c1695
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_VHT_MU:
---
>     case WIFI_PREAMBLE_VHT:
1913d1697
<     case WIFI_PREAMBLE_HE_MU:
1921c1705
< WifiPhy::GetPhyHtSigHeaderDuration (WifiPreamble preamble)
---
> WifiPhy::GetPlcpHtSigHeaderDuration (WifiPreamble preamble)
1936c1720
< WifiPhy::GetPhySigA1Duration (WifiPreamble preamble)
---
> WifiPhy::GetPlcpSigA1Duration (WifiPreamble preamble)
1940c1724
<     case WIFI_PREAMBLE_VHT_SU:
---
>     case WIFI_PREAMBLE_VHT:
1942,1943d1725
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_MU:
1953c1735
< WifiPhy::GetPhySigA2Duration (WifiPreamble preamble)
---
> WifiPhy::GetPlcpSigA2Duration (WifiPreamble preamble)
1957c1739
<     case WIFI_PREAMBLE_VHT_SU:
---
>     case WIFI_PREAMBLE_VHT:
1959,1960d1740
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_MU:
1970c1750
< WifiPhy::GetPhySigBDuration (WifiPreamble preamble)
---
> WifiPhy::GetPlcpSigBDuration (WifiPreamble preamble)
1974,1975c1754,1755
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_MU:
---
>     case WIFI_PREAMBLE_VHT:
>       //VHT-SIG-B
1976a1757,1759
>     case WIFI_PREAMBLE_HE_SU:
>       //HE-SIG-B: MU not supported so HE-SIG-B not used
>       return MicroSeconds (0);
1984c1767
< WifiPhy::GetPhyHeaderMode (WifiTxVector txVector)
---
> WifiPhy::GetPlcpHeaderMode (WifiTxVector txVector)
1986,1987c1769
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   switch (preamble)
---
>   switch (txVector.GetMode ().GetModulationClass ())
1989,2054c1771,1805
<     //// WIGIG ////
<     case WIFI_PREAMBLE_DMG_CTRL:
<       return DmgWifiPhy::GetDMG_MCS0 ();
<     case WIFI_PREAMBLE_DMG_SC:
<       return DmgWifiPhy::GetDMG_MCS1 ();
<     case WIFI_PREAMBLE_DMG_OFDM:
<       return DmgWifiPhy::GetDMG_MCS13 ();
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       return DmgWifiPhy::GetEDMG_MCS0 ();
<     case WIFI_PREAMBLE_EDMG_SC:
<       return DmgWifiPhy::GetEDMG_SC_MCS1 ();
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       return DmgWifiPhy::GetEDMG_OFDM_MCS1 ();
<     //// WIGIG ////
<     case WIFI_PREAMBLE_LONG:
<     case WIFI_PREAMBLE_SHORT:
<       {
<         switch (txVector.GetMode ().GetModulationClass ())
<           {
<             case WIFI_MOD_CLASS_OFDM:
<               {
<                 switch (txVector.GetChannelWidth ())
<                   {
<                     case 5:
<                       return WifiPhy::GetOfdmRate1_5MbpsBW5MHz ();
<                     case 10:
<                       return WifiPhy::GetOfdmRate3MbpsBW10MHz ();
<                     case 20:
<                     default:
<                       //(Section 17.3.2 "PPDU frame format"; IEEE Std 802.11-2016)
<                       //actually this is only the first part of the PhyHeader,
<                       //because the last 16 bits of the PhyHeader are using the
<                       //same mode of the payload
<                       return WifiPhy::GetOfdmRate6Mbps ();
<                   }
<               }
<             case WIFI_MOD_CLASS_ERP_OFDM:
<               return WifiPhy::GetErpOfdmRate6Mbps ();
<             case WIFI_MOD_CLASS_DSSS:
<             case WIFI_MOD_CLASS_HR_DSSS:
<               {
<                 if (preamble == WIFI_PREAMBLE_LONG || txVector.GetMode () == WifiPhy::GetDsssRate1Mbps ())
<                   {
<                     //(Section 16.2.3 "PPDU field definitions" and Section 16.2.2.2 "Long PPDU format"; IEEE Std 802.11-2016)
<                     return WifiPhy::GetDsssRate1Mbps ();
<                   }
<                 else
<                   {
<                     //(Section 16.2.2.3 "Short PPDU format"; IEEE Std 802.11-2016)
<                     return WifiPhy::GetDsssRate2Mbps ();
<                   }
<               }
<             default:
<               NS_FATAL_ERROR ("unsupported modulation class");
<               return WifiMode ();
<           }
<       }
<     case WIFI_PREAMBLE_HT_MF:
<     case WIFI_PREAMBLE_HT_GF:
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_HE_ER_SU:
<     case WIFI_PREAMBLE_HE_MU:
<     case WIFI_PREAMBLE_HE_TB:
<       return WifiPhy::GetOfdmRate6Mbps ();
---
>     case WIFI_MOD_CLASS_OFDM:
>     case WIFI_MOD_CLASS_HT:
>     case WIFI_MOD_CLASS_VHT:
>     case WIFI_MOD_CLASS_HE:
>       switch (txVector.GetChannelWidth ())
>         {
>         case 5:
>           return WifiPhy::GetOfdmRate1_5MbpsBW5MHz ();
>         case 10:
>           return WifiPhy::GetOfdmRate3MbpsBW10MHz ();
>         case 20:
>         case 40:
>         case 80:
>         case 160:
>         default:
>           //(Section 18.3.2 "PLCP frame format"; IEEE Std 802.11-2012)
>           //actually this is only the first part of the PlcpHeader,
>           //because the last 16 bits of the PlcpHeader are using the
>           //same mode of the payload
>           return WifiPhy::GetOfdmRate6Mbps ();
>         }
>     case WIFI_MOD_CLASS_ERP_OFDM:
>       return WifiPhy::GetErpOfdmRate6Mbps ();
>     case WIFI_MOD_CLASS_DSSS:
>     case WIFI_MOD_CLASS_HR_DSSS:
>       if (txVector.GetPreambleType () == WIFI_PREAMBLE_LONG || txVector.GetMode () == WifiPhy::GetDsssRate1Mbps ())
>         {
>           //(Section 16.2.3 "PLCP field definitions" and Section 17.2.2.2 "Long PPDU format"; IEEE Std 802.11-2012)
>           return WifiPhy::GetDsssRate1Mbps ();
>         }
>       else //WIFI_PREAMBLE_SHORT
>         {
>           //(Section 17.2.2.3 "Short PPDU format"; IEEE Std 802.11-2012)
>           return WifiPhy::GetDsssRate2Mbps ();
>         }
2056c1807
<       NS_FATAL_ERROR ("unsupported preamble type");
---
>       NS_FATAL_ERROR ("unsupported modulation class");
2062c1813
< WifiPhy::GetPhyHeaderDuration (WifiTxVector txVector)
---
> WifiPhy::GetPlcpHeaderDuration (WifiTxVector txVector)
2065c1816
<   switch (txVector.GetPreambleType ())
---
>   if (preamble == WIFI_PREAMBLE_NONE)
2067,2090c1818,1822
<     //// WIGIG ////
<     case WIFI_PREAMBLE_DMG_CTRL:
<       /* From Annex L (L.5.2.5) */
<       return NanoSeconds (4654);
<     case WIFI_PREAMBLE_DMG_SC:
<       /* From Table 21-4 in 802.11ad spec 21.3.4 */
<       return NanoSeconds (582);
<     case WIFI_PREAMBLE_DMG_OFDM:
<       /* From Table 21-4 in 802.11ad spec 21.3.4 */
<       return NanoSeconds (242);
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       /* From Annex L (L.5.2.5) */
<       /* For EDMG STAs: the L-Header + EDMG-Header-A1 get encoded in the first LDCP codeword - same duration as L-Header (4654).
<        * EDMG-Header-A2 + bits from the payload get encoded in the second LDCP codeword - calculated by GetEDMG_HeaderA_Duration */
<       return NanoSeconds (4654) + GetEDMG_HeaderA_Duration (txVector);
<     case WIFI_PREAMBLE_EDMG_SC:
<       /* From Table 21-4 in 802.11ad spec 21.3.4 */
<       return NanoSeconds (582) + GetEDMG_HeaderA_Duration (txVector) + GetEDMG_HeaderB_Duration (txVector);
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       /* From Table 21-4 in 802.11ad spec 21.3.4 */
<       return NanoSeconds (242) + GetEDMG_HeaderA_Duration (txVector) + GetEDMG_HeaderB_Duration (txVector);
<     //// WIGIG ////
<     case WIFI_PREAMBLE_LONG:
<     case WIFI_PREAMBLE_SHORT:
---
>       return MicroSeconds (0);
>     }
>   switch (txVector.GetMode ().GetModulationClass ())
>     {
>     case WIFI_MOD_CLASS_OFDM:
2092c1824
<         switch (txVector.GetMode ().GetModulationClass ())
---
>         switch (txVector.GetChannelWidth ())
2094,2115c1826,1833
<           case WIFI_MOD_CLASS_OFDM:
<             {
<               switch (txVector.GetChannelWidth ())
<                 {
<                 case 20:
<                 default:
<                   //(Section 17.3.3 "PHY preamble (SYNC))" and Figure 17-4 "OFDM training structure"; IEEE Std 802.11-2016)
<                   //also (Section 17.3.2.4 "Timing related parameters" Table 17-5 "Timing-related parameters"; IEEE Std 802.11-2016)
<                   //We return the duration of the SIGNAL field only, since the
<                   //SERVICE field (which strictly speaking belongs to the PHY
<                   //header, see Section 17.3.2 and Figure 17-1) is sent using the
<                   //payload mode.
<                   return MicroSeconds (4);
<                 case 10:
<                   //(Section 17.3.2.4 "Timing related parameters" Table 17-5 "Timing-related parameters"; IEEE Std 802.11-2016)
<                   return MicroSeconds (8);
<                 case 5:
<                   //(Section 17.3.2.4 "Timing related parameters" Table 17-5 "Timing-related parameters"; IEEE Std 802.11-2016)
<                   return MicroSeconds (16);
<                 }
<             }
<           case WIFI_MOD_CLASS_ERP_OFDM:
---
>           case 20:
>           default:
>             //(Section 18.3.3 "PLCP preamble (SYNC))" and Figure 18-4 "OFDM training structure"; IEEE Std 802.11-2012)
>             //also (Section 18.3.2.4 "Timing related parameters" Table 18-5 "Timing-related parameters"; IEEE Std 802.11-2012)
>             //We return the duration of the SIGNAL field only, since the
>             //SERVICE field (which strictly speaking belongs to the PLCP
>             //header, see Section 18.3.2 and Figure 18-1) is sent using the
>             //payload mode.
2117,2130c1835,1849
<           case WIFI_MOD_CLASS_DSSS:
<           case WIFI_MOD_CLASS_HR_DSSS:
<             {
<               if ((preamble == WIFI_PREAMBLE_SHORT) && (txVector.GetMode ().GetDataRate (22) > 1000000))
<                 {
<                   //(Section 16.2.2.3 "Short PPDU format" and Figure 16-2 "Short PPDU format"; IEEE Std 802.11-2016)
<                   return MicroSeconds (24);
<                 }
<               else
<                 {
<                   //(Section 16.2.2.2 "Long PPDU format" and Figure 16-1 "Short PPDU format"; IEEE Std 802.11-2016)
<                   return MicroSeconds (48);
<                 }
<             }
---
>           case 10:
>             //(Section 18.3.2.4 "Timing related parameters" Table 18-5 "Timing-related parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (8);
>           case 5:
>             //(Section 18.3.2.4 "Timing related parameters" Table 18-5 "Timing-related parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (16);
>           }
>       }
>     case WIFI_MOD_CLASS_HT:
>       {
>         //L-SIG
>         //IEEE 802.11n Figure 20.1
>         switch (preamble)
>           {
>           case WIFI_PREAMBLE_HT_MF:
2132c1851,1852
<             NS_FATAL_ERROR ("modulation class is not matching the preamble type");
---
>             return MicroSeconds (4);
>           case WIFI_PREAMBLE_HT_GF:
2136,2138c1856,1857
<     case WIFI_PREAMBLE_HT_MF:
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_VHT_MU:
---
>     case WIFI_MOD_CLASS_ERP_OFDM:
>     case WIFI_MOD_CLASS_VHT:
2141,2144c1860
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_HE_ER_SU:
<     case WIFI_PREAMBLE_HE_MU:
<     case WIFI_PREAMBLE_HE_TB:
---
>     case WIFI_MOD_CLASS_HE:
2147,2148c1863,1874
<     case WIFI_PREAMBLE_HT_GF:
<       return MicroSeconds (0);
---
>     case WIFI_MOD_CLASS_DSSS:
>     case WIFI_MOD_CLASS_HR_DSSS:
>       if ((preamble == WIFI_PREAMBLE_SHORT) && (txVector.GetMode ().GetDataRate (22) > 1000000))
>         {
>           //(Section 17.2.2.3 "Short PPDU format" and Figure 17-2 "Short PPDU format"; IEEE Std 802.11-2012)
>           return MicroSeconds (24);
>         }
>       else //WIFI_PREAMBLE_LONG
>         {
>           //(Section 17.2.2.2 "Long PPDU format" and Figure 17-1 "Short PPDU format"; IEEE Std 802.11-2012)
>           return MicroSeconds (48);
>         }
2150c1876
<       NS_FATAL_ERROR ("unsupported preamble type");
---
>       NS_FATAL_ERROR ("unsupported modulation class");
2156,2162c1882
< WifiPhy::GetStartOfPacketDuration (WifiTxVector txVector)
< {
<   return MicroSeconds (4);
< }
< 
< Time
< WifiPhy::GetPhyPreambleDuration (WifiTxVector txVector)
---
> WifiPhy::GetPlcpPreambleDuration (WifiTxVector txVector)
2165c1885
<   switch (txVector.GetPreambleType ())
---
>   if (preamble == WIFI_PREAMBLE_NONE)
2167,2195c1887,1891
<     //// WIGIG ////
<     case WIFI_PREAMBLE_DMG_CTRL:
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       // CTRL Preamble = (6400 + 1152) Samples * Tc (Chip Time for SC), Tc = Tccp = 0.57ns.
<       // CTRL Preamble = 4.291 micro seconds.
<       return NanoSeconds (4291);
< 
<     case WIFI_PREAMBLE_DMG_SC:
<       // SC Preamble = 3328 Samples (STF: 2176 + CEF: 1152) * Tc (Chip Time for SC), Tc = 0.57ns.
<       // SC Preamble = 1.89 micro seconds.
<       return NanoSeconds (1891);
< 
<     case WIFI_PREAMBLE_DMG_OFDM:
<       // OFDM Preamble = 4992 Samples (STF: 2176 + CEF: 1152) * Ts (Chip Time for OFDM), Tc = 0.38ns.
<       // OFDM Preamble = 1.89 micro seconds.
<       return NanoSeconds (1891);
< 
<     case WIFI_PREAMBLE_EDMG_SC:
<       // SC Preamble = 3328 Samples (STF: 2176 + CEF: 1152) * Tc (Chip Time for SC), Tc = 0.57ns.
<       // SC Preamble = 1.89 micro seconds.
<       return NanoSeconds (1891) + GetEDMGPreambleDuration (txVector);
< 
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       // OFDM Preamble = 4992 Samples (STF: 2176 + CEF: 1152) * Ts (Chip Time for OFDM), Tc = 0.38ns.
<       // OFDM Preamble = 1.89 micro seconds.
<       return NanoSeconds (1891) + GetEDMGPreambleDuration (txVector);
<     //// WIGIG ////
<     case WIFI_PREAMBLE_LONG:
<     case WIFI_PREAMBLE_SHORT:
---
>       return MicroSeconds (0);
>     }
>   switch (txVector.GetMode ().GetModulationClass ())
>     {
>     case WIFI_MOD_CLASS_OFDM:
2197c1893
<         switch (txVector.GetMode ().GetModulationClass ())
---
>         switch (txVector.GetChannelWidth ())
2199,2236c1895,1907
<             case WIFI_MOD_CLASS_OFDM:
<               {
<                 switch (txVector.GetChannelWidth ())
<                   {
<                     case 20:
<                     default:
<                       //(Section 17.3.3 "PHY preamble (SYNC))" Figure 17-4 "OFDM training structure"
<                       //also Section 17.3.2.3 "Modulation-dependent parameters" Table 17-4 "Modulation-dependent parameters"; IEEE Std 802.11-2016)
<                       return MicroSeconds (16);
<                     case 10:
<                       //(Section 17.3.3 "PHY preamble (SYNC))" Figure 17-4 "OFDM training structure"
<                       //also Section 17.3.2.3 "Modulation-dependent parameters" Table 17-4 "Modulation-dependent parameters"; IEEE Std 802.11-2016)
<                       return MicroSeconds (32);
<                     case 5:
<                       //(Section 17.3.3 "PHY preamble (SYNC))" Figure 17-4 "OFDM training structure"
<                       //also Section 17.3.2.3 "Modulation-dependent parameters" Table 17-4 "Modulation-dependent parameters"; IEEE Std 802.11-2016)
<                       return MicroSeconds (64);
<                   }
<               }
<             case WIFI_MOD_CLASS_ERP_OFDM:
<               return MicroSeconds (16);
<             case WIFI_MOD_CLASS_DSSS:
<             case WIFI_MOD_CLASS_HR_DSSS:
<               {
<                 if ((preamble == WIFI_PREAMBLE_SHORT) && (txVector.GetMode ().GetDataRate (22) > 1000000))
<                   {
<                     //(Section 17.2.2.3 "Short PPDU format)" Figure 17-2 "Short PPDU format"; IEEE Std 802.11-2012)
<                     return MicroSeconds (72);
<                   }
<                 else
<                   {
<                     //(Section 17.2.2.2 "Long PPDU format)" Figure 17-1 "Long PPDU format"; IEEE Std 802.11-2012)
<                     return MicroSeconds (144);
<                   }
<               }
<             default:
<               NS_FATAL_ERROR ("modulation class is not matching the preamble type");
<               return MicroSeconds (0);
---
>           case 20:
>           default:
>             //(Section 18.3.3 "PLCP preamble (SYNC))" Figure 18-4 "OFDM training structure"
>             //also Section 18.3.2.3 "Modulation-dependent parameters" Table 18-4 "Modulation-dependent parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (16);
>           case 10:
>             //(Section 18.3.3 "PLCP preamble (SYNC))" Figure 18-4 "OFDM training structure"
>             //also Section 18.3.2.3 "Modulation-dependent parameters" Table 18-4 "Modulation-dependent parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (32);
>           case 5:
>             //(Section 18.3.3 "PLCP preamble (SYNC))" Figure 18-4 "OFDM training structure"
>             //also Section 18.3.2.3 "Modulation-dependent parameters" Table 18-4 "Modulation-dependent parameters"; IEEE Std 802.11-2012)
>             return MicroSeconds (64);
2239,2245c1910,1912
<     case WIFI_PREAMBLE_HT_MF:
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_HE_ER_SU:
<     case WIFI_PREAMBLE_HE_MU:
<     case WIFI_PREAMBLE_HE_TB:
---
>     case WIFI_MOD_CLASS_HT:
>     case WIFI_MOD_CLASS_VHT:
>     case WIFI_MOD_CLASS_HE:
2248,2249c1915
<     case WIFI_PREAMBLE_HT_GF:
<       //HT-GF-STF + HT-LTF1
---
>     case WIFI_MOD_CLASS_ERP_OFDM:
2250a1917,1928
>     case WIFI_MOD_CLASS_DSSS:
>     case WIFI_MOD_CLASS_HR_DSSS:
>       if ((preamble == WIFI_PREAMBLE_SHORT) && (txVector.GetMode ().GetDataRate (22) > 1000000))
>         {
>           //(Section 17.2.2.3 "Short PPDU format)" Figure 17-2 "Short PPDU format"; IEEE Std 802.11-2012)
>           return MicroSeconds (72);
>         }
>       else //WIFI_PREAMBLE_LONG
>         {
>           //(Section 17.2.2.2 "Long PPDU format)" Figure 17-1 "Long PPDU format"; IEEE Std 802.11-2012)
>           return MicroSeconds (144);
>         }
2252c1930
<       NS_FATAL_ERROR ("unsupported preamble type");
---
>       NS_FATAL_ERROR ("unsupported modulation class");
2258c1936
< WifiPhy::GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype)
---
> WifiPhy::GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency)
2260,2262c1938
<   uint32_t totalAmpduSize;
<   double totalAmpduNumSymbols;
<   return GetPayloadDuration (size, txVector, frequency, mpdutype, false, totalAmpduSize, totalAmpduNumSymbols);
---
>   return GetPayloadDuration (size, txVector, frequency, NORMAL_MPDU, 0);
2266,2267c1942
< WifiPhy::GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype,
<                              bool incFlag, uint32_t &totalAmpduSize, double &totalAmpduNumSymbols)
---
> WifiPhy::GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype, uint8_t incFlag)
2269a1945
>   WifiPreamble preamble = txVector.GetPreambleType ();
2272,2647d1947
<   if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_DMG_CTRL)
<     {
<       uint32_t Ncw;                       /* Number of LDPC codewords. */
<       uint32_t Ldpcw;                     /* Number of bits in the second and any subsequent codeword except the last. */
<       uint32_t Ldplcw;                    /* Number of bits in the last codeword. */
<       uint32_t DencodedSymmbols;          /* Number of differentailly encoded payload symbols. */
<       uint32_t Chips;                     /* Number of chips (After spreading using Ga32 Golay Sequence). */
<       uint32_t Nbits = (size - 8) * 8;    /* Number of bits in the payload part. */
< 
<       Ncw = 1 + (uint32_t) ceil ((double (size) - 6) * 8/168);
<       Ldpcw = (uint32_t) ceil ((double (size) - 6) * 8/(Ncw - 1));
<       Ldplcw = (size - 6) * 8 - (Ncw - 2) * Ldpcw;
<       DencodedSymmbols = (672 - (504 - Ldpcw)) * (Ncw - 2) + (672 - (504 - Ldplcw));
<       //      DencodedSymmbols = (Ldpcw + 168) * (Ncw-2) + Ldplcw + 168;
<       Chips = DencodedSymmbols * 32;
<       /* Make sure the result is in nanoseconds. */
<       double ret = double (Chips)/1.76;
<       NS_LOG_DEBUG ("bits " << Nbits << " Diff encoded Symmbols " << DencodedSymmbols << " rate " << payloadMode.GetDataRate() << " Payload Time " << ret << " ns");
< 
<       return NanoSeconds (ceil (ret));
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_DMG_LP_SC)
<     {
<       //        uint32_t Nbits = (size * 8);  /* Number of bits in the payload part. */
<       //        uint32_t Nrsc;                /* The total number of Reed Solomon codewords */
<       //        uint32_t Nrses;               /* The total number of Reed Solomon encoded symbols */
<       //        Nrsc = (uint32_t) ceil(Nbits/208);
<       //        Nrses = Nbits + Nrsc * 16;
< 
<       //        uint32_t Nsbc;                 /* Short Block code Size */
<       //        if (payloadMode.GetCodeRate() == WIFI_CODE_RATE_13_28)
<       //          Nsbc = 16;
<       //        else if (payloadMode.GetCodeRate() == WIFI_CODE_RATE_13_21)
<       //          Nsbc = 12;
<       //        else if (payloadMode.GetCodeRate() == WIFI_CODE_RATE_52_63)
<       //          Nsbc = 9;
<       //        else if (payloadMode.GetCodeRate() == WIFI_CODE_RATE_13_14)
<       //          Nsbc = 8;
<       //        else
<       //          NS_FATAL_ERROR("unsupported code rate");
< 
<       //        uint32_t Ncbps;               /* Ncbps = Number of coded bits per symbol. Check Table 21-21 for different constellations. */
<       //        if (payloadMode.GetConstellationSize() == 2)
<       //          Ncbps = 336;
<       //        else if (payloadMode.GetConstellationSize() == 4)
<       //          Ncbps = 2 * 336;
<       //          NS_FATAL_ERROR("unsupported constellation size");
< 
<       //        uint32_t Neb;                 /* Total number of encoded bits */
<       //        uint32_t Nblks;               /* Total number of 512 blocks containing 392 data symbols */
<       //        Neb = Nsbc * Nrses;
<       //        Nblks = (uint32_t) ceil(neb/());
<       return NanoSeconds (0);
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_DMG_SC)
<     {
<       /* 21.3.4 Timeing Related Parameters, Table 21-4 TData = (Nblks * 512 + 64) * Tc. */
<       /* 21.6.3.2.3.3 (4), Compute Nblks = The number of symbol blocks. */
< 
<       uint32_t Ncbpb; // Ncbpb = Number of coded bits per symbol block. Check Table 21-20 for different constellations.
<       if (payloadMode.GetConstellationSize () == 2)
<         Ncbpb = 448;
<       else if (payloadMode.GetConstellationSize () == 4)
<         Ncbpb = 2 * 448;
<       else if (payloadMode.GetConstellationSize () == 16)
<         Ncbpb = 4 * 448;
<       else if (payloadMode.GetConstellationSize () == 64)
<         Ncbpb = 6 * 448;
<       else
<         NS_FATAL_ERROR ("unsupported constellation size");
< 
<       uint32_t Nbits = (size * 8); /* Nbits = Number of bits in the payload part. */
<       uint32_t Ncbits;             /* Ncbits = Number of coded bits in the payload part. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_4)
<         Ncbits = Nbits * 4;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_2)
<         Ncbits = Nbits * 2;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_13_16)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 16.0 / 13);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_3_4)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 4.0 / 3);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 5);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_7_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 7);
<       else
<         NS_FATAL_ERROR ("unsupported code rate");
< 
<       uint16_t Lcw; /* The LDPC codeword length. */
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_7_8)
<         Lcw = 624;
<       else
<         Lcw = 672;
< 
<       uint32_t Ncw = (uint32_t) ceil (double (Ncbits) / double (Lcw));  /* Ncw = The number of LDPC codewords. */
<       uint32_t Nblks = (uint32_t) ceil (double (Ncw) * double (Lcw) / Ncbpb);  /* Nblks = The number of symbol blocks. */
< 
<       /* Make sure the result is in nanoseconds. */
<       uint32_t tData = lrint (ceil ((double (Nblks) * 512 + 64) / 1.76)); /* The duration of the data part */
<       NS_LOG_DEBUG ("bits " << Nbits << " cbits " << Ncbits
<                     << " Ncw " << Ncw
<                     << " Nblks " << Nblks
<                     << " rate " << payloadMode.GetDataRate() << " Payload Time " << tData << " ns");
< 
<       if (txVector.GetTrainngFieldLength () != 0)
<         {
<           if (tData < OFDMSCMin)
<             tData = OFDMSCMin;
<         }
<       return NanoSeconds (tData);
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_DMG_OFDM)
<     {
<       /* 21.3.4 Timeing Related Parameters, Table 21-4 TData = Nsym * Tsys(OFDM) */
<       /* 21.5.3.2.3.3 (5), Compute Nsym = Number of OFDM Symbols */
< 
<       uint32_t Ncbps; // Ncbps = Number of coded bits per symbol. Check Table 21-20 for different constellations.
<       if (payloadMode.GetConstellationSize () == 2)
<         Ncbps = 336;
<       else if (payloadMode.GetConstellationSize () == 4)
<         Ncbps = 2 * 336;
<       else if (payloadMode.GetConstellationSize () == 16)
<         Ncbps = 4 * 336;
<       else if (payloadMode.GetConstellationSize () == 64)
<         Ncbps = 6 * 336;
<       else
<         NS_FATAL_ERROR ("unsupported constellation size");
< 
<       uint32_t Nbits = (size * 8); /* Nbits = Number of bits in the payload part. */
<       uint32_t Ncbits;             /* Ncbits = Number of coded bits in the payload part. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_4)
<         Ncbits = Nbits * 4;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_2)
<         Ncbits = Nbits * 2;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_13_16)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 16.0 / 13);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_3_4)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 4.0 / 3);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 5);
<       else
<         NS_FATAL_ERROR ("unsupported code rate");
< 
<       uint32_t Ncw = (uint32_t) ceil (double (Ncbits) / 672.0);         /* Ncw = The number of LDPC codewords.  */
<       uint32_t Nsym = (uint32_t) ceil (double (Ncw * 672.0) / Ncbps);   /* Nsym = Number of OFDM Symbols. */
< 
<       /* Make sure the result is in nanoseconds */
<       uint32_t tData;       /* The duration of the data part */
<       tData = Nsym * 242;   /* Tsys(OFDM) = 242ns */
<       NS_LOG_DEBUG ("bits " << Nbits << " cbits " << Ncbits << " rate " << payloadMode.GetDataRate() << " Payload Time " << tData << " ns");
< 
<       if (txVector.GetTrainngFieldLength () != 0)
<         {
<           if (tData < OFDMBRPMin)
<             tData = OFDMBRPMin;
<         }
<       return NanoSeconds (tData);
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL)
<     {
<       uint32_t Ncw;                       /* Number of LDPC codewords. */
<       uint32_t Ldpcw;                     /* Number of bits in the second and any subsequent codeword except the last. */
<       uint32_t Ldplcw;                    /* Number of bits in the last codeword. */
<       uint32_t DencodedSymmbols;          /* Number of differentailly encoded payload symbols. */
<       uint32_t Chips;                     /* Number of chips (After spreading using Ga32 Golay Sequence). */
<       uint32_t Nbits = (size - 8) * 8;    /* Number of bits in the payload part. */
< 
<       Ncw = 1 + (uint32_t) ceil ((double (size) + L_EDMG_Header_A2) * 8/168);
<       Ldpcw = (uint32_t) ceil ((double (size) + L_EDMG_Header_A2) * 8/(Ncw - 1));
<       Ldplcw = (size + L_EDMG_Header_A2) * 8 - (Ncw - 2) * Ldpcw;
<       //DencodedSymmbols = (672 - (504 - Ldpcw)) * (Ncw - 3) + (672 - (504 - Ldplcw));
<       // Change to Ncw-3 once the duration of Header A is calculated properly
<       DencodedSymmbols = (Ldpcw + 168) * (Ncw-2) + (Ldplcw +168);
<       Chips = DencodedSymmbols * 32;
< 
<       /* Make sure the result is in nanoseconds. */
<       double ret = double (Chips)/1.76;
<       NS_LOG_DEBUG ("bits " << Nbits << " Diff encoded Symmbols " << DencodedSymmbols << " rate " << payloadMode.GetDataRate() << " Payload Time " << ret << " ns");
< 
<       return NanoSeconds (ceil (ret));
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_EDMG_SC)
<     {
<       /* 29.12.3.3 TXTIME calculation for EDMG SC mode, TData = (Nblks * 512 + Ngi) * Tc. */
<       /* 29.5.9.4 (d4), Compute Nblks = The number of symbol blocks. */
< 
<       //Once multiple users are enabled - calculate Nblcks for each user - then set Nblks to the maximum Nblks from all users - for loop for all users
<       uint16_t Nspb;  /* Number of symbols per SC symbol block for GI length. */
< 
<       if (txVector.GetGaurdIntervalType () == GI_SHORT)
<         Nspb = 480 * txVector.GetNCB ();
<       else if (txVector.GetGaurdIntervalType () == GI_NORMAL)
<         Nspb = 448 * txVector.GetNCB ();
<       else if (txVector.GetGaurdIntervalType () == GI_LONG)
<         Nspb = 384 * txVector.GetNCB ();
<       else
<         NS_FATAL_ERROR ("Unsupported guard interval length");
< 
<       // For now we are assuming that the same MCS is used for all STS
<       uint32_t Ncbps; // Ncbps = Number of coded bits per symbol. Check Table 21-20 for different constellations.
<       if (payloadMode.GetConstellationSize () == 2)
<         Ncbps = 1;
<       else if (payloadMode.GetConstellationSize () == 4)
<         Ncbps = 2;
<       else if (payloadMode.GetConstellationSize () == 16)
<         Ncbps = 4;
<       else if (payloadMode.GetConstellationSize () == 64)
<         Ncbps = 6;
<       else
<         NS_FATAL_ERROR ("unsupported constellation size");
< 
<       Ncbps = Ncbps * txVector.Get_NUM_STS ();
< 
<       uint32_t Nbits = (size * 8); /* Nbits = Number of bits in the payload part. */
<       uint32_t Ncbits;             /* Ncbits = Number of coded bits in the payload part. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_4)
<         Ncbits = Nbits * 4;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_2)
<         Ncbits = Nbits * 2;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_13_16)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 16.0 / 13);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_3_4)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 4.0 / 3);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 5);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_7_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 7);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_2_3)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 3.0 / 2);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_6)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 6.0 / 5);
<       else
<         NS_FATAL_ERROR ("unsupported code rate");
< 
<       uint16_t Lcw; /* The LDPC codeword length. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_2_3 || payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_6)
<         Lcw = 504;
<       else
<         Lcw = 672;
<       if (txVector.GetLdcpCwLength ())
<         {
<           Lcw = Lcw * 2;
<         }
< 
<       uint32_t Ncw = (uint32_t) ceil (double (Ncbits) / double (Lcw));  /* Ncw = The number of LDPC codewords. */
<       uint32_t Nblks = (uint32_t) ceil ((double (Ncw) * double (Lcw)) / (Ncbps * Nspb));  /* Nblks = The number of symbol blocks. */
< 
<       if (txVector.GetEDMGTrainingFieldLength () != 0)
<         {
<           if (Nblks < aBRPminSCblocks)
<             Nblks = aBRPminSCblocks;
<         }
< 
<       uint8_t Ngi = 0; /* the size of the guard interval */
< 
<       if (txVector.GetGaurdIntervalType () == GI_LONG)
<         Ngi = 128;
<       else if (txVector.GetGaurdIntervalType () == GI_NORMAL)
<         Ngi = 64;
<       else if (txVector.GetGaurdIntervalType () == GI_SHORT)
<         {
<           if ((txVector.GetNumUsers () == 1) && ((txVector.GetTransmitMask () != CH_BANDWIDTH_216) || (txVector.Get_NUM_STS () != 1)))
<             Ngi = 32;
<           else
<             Ngi = 64;
<         }
< 
<       /* Make sure the result is in nanoseconds. */
<       uint32_t tData = lrint (ceil ((double (Nblks) * 512 + Ngi) / 1.76)); /* The duration of the data part */
<       NS_LOG_DEBUG ("bits " << Nbits
<                     << " cbits " << Ncbits
<                     << " Ncbps " << Ncbps
<                     << " Nspb " << Nspb
<                     << " Ncw " << Ncw
<                     << " Nblks " << Nblks
<                     << " data-rate " << payloadMode.GetDataRate()
<                     << " phy-rate " << payloadMode.GetPhyRate ()
<                     << " Payload Time " << tData << " ns");
< 
<       return NanoSeconds (tData);
<     }
<   else if (payloadMode.GetModulationClass () == WIFI_MOD_CLASS_EDMG_OFDM)
<     {
<       /* 29.12.3.4 TXTIME calculation for EDMG OFDM mode, TData = (Nsym * (512 + Ngi)) * Ts */
<       /* 21.5.3.2.3.3 (5), Compute Nsym = Number of OFDM Symbols */
< 
<       //Once multiple users are enabled - calculate Nsym for each user - then set Nsym to the maximum Nsym from all users - for loop for all users
< 
<       uint32_t Nsd; // Nsd = Number of data subcarriers.
<       if (txVector.GetNCB () == 1)
<         Nsd = 336;
<       else if (txVector.GetNCB () == 2)
<         Nsd = 734;
<       else if (txVector.GetNCB () == 3)
<         Nsd = 1134;
<       else if (txVector.GetNCB () == 4)
<         Nsd = 1532;
<       else
<         NS_FATAL_ERROR("Unsupported number of continous channels");
< 
<       // Once multimple space-time streams are enabled - sum the Nbpsc for all space-time streams.
<       uint32_t Nbpsc; // Nbpsc = Number of coded bits per constellation point Check Table 115 (ayD4) for different constellations.
<       if (payloadMode.GetConstellationSize () == 2)
<         Nbpsc = 1;
<       else if (payloadMode.GetConstellationSize () == 4)
<         Nbpsc = 2;
<       else if (payloadMode.GetConstellationSize () == 16)
<         Nbpsc = 4;
<       else if (payloadMode.GetConstellationSize () == 64)
<         Nbpsc = 6;
<       else
<         NS_FATAL_ERROR ("unsupported constellation size");
< 
<       // For MIMO case
<       Nbpsc = Nbpsc * txVector.Get_NUM_STS ();
< 
<       uint32_t Ncbps; // Ncbps = Number of coded bits per symbol. Check Table 21-20 for different constellations.
<       Ncbps = Nsd * Nbpsc;
< 
<       uint32_t Nbits = (size * 8); /* Nbits = Number of bits in the payload part. */
<       uint32_t Ncbits;             /* Ncbits = Number of coded bits in the payload part. */
< 
<       if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_1_2)
<         Ncbits = Nbits * 2;
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_7_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 7);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_13_16)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 16.0 / 13);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_3_4)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 4.0 / 3);
<       else if (payloadMode.GetCodeRate () == WIFI_CODE_RATE_5_8)
<         Ncbits = (uint32_t) ceil (double (Nbits) * 8.0 / 5);
<       else
<         NS_FATAL_ERROR ("unsupported code rate");
< 
<       uint16_t Lcw; /* The LDPC codeword length. */
<       Lcw = 672;
<       if (txVector.GetLdcpCwLength ())
<         {
<           Lcw = Lcw * 2;
<         }
< 
<       uint32_t Ncw = (uint32_t) ceil (double (Ncbits) / double (Lcw)); /* Ncw = The number of LDPC codewords.  */
<       uint32_t Nsym = (uint32_t) ceil (double (Ncw * Lcw) / Ncbps);    /* Nsym = Number of OFDM Symbols. */
< 
<       if (txVector.GetEDMGTrainingFieldLength () != 0)
<         {
<           if (Nsym < aBRPminOFDMblocks)
<             Nsym = aBRPminOFDMblocks;
<         }
< 
<       uint8_t Ngi = 0; /* the size of the guard interval */
<       if (txVector.GetGaurdIntervalType () == GI_LONG)
<         Ngi = 192;
<       else if (txVector.GetGaurdIntervalType () == GI_NORMAL)
<         Ngi = 96;
<       else if (txVector.GetGaurdIntervalType () == GI_SHORT)
<         Ngi = 48;
< 
<       /* Make sure the result is in nanoseconds */
<       uint32_t tData;       /* The duration of the data part */
<       tData = lrint (ceil ((double (Nsym * (512 + Ngi)) / 2.64))); /* The duration of the data part */
<       NS_LOG_DEBUG ("bits " << Nbits << " cbits " << Ncbits << " rate " << payloadMode.GetDataRate() << " Payload Time " << tData << " ns");
< 
<       if (txVector.GetTrainngFieldLength () != 0)
<         {
<           if (tData < OFDMBRPMin)
<             tData = OFDMBRPMin;
<         }
<       return NanoSeconds (tData);
<     }
< 
2659c1959
<   if (payloadMode == GetHtMcs21 ()
---
>   if (payloadMode == GetHtMcs21()
2795c2095
<         //In the future has to create a station manager that only uses these data rates if sender and receiver support GI
---
>         //In the future has to create a stationmanager that only uses these data rates if sender and receiver support GI
2804c2104
<         //In the future has to create a station manager that only uses these data rates if sender and receiver support GI
---
>         //In the future has to create a stationmanager that only uses these data rates if sender and receiver support GI
2817c2117
<   if (mpdutype == FIRST_MPDU_IN_AGGREGATE)
---
>   if (mpdutype == MPDU_IN_AGGREGATE && preamble != WIFI_PREAMBLE_NONE)
2823,2824c2123,2124
<           totalAmpduSize += size;
<           totalAmpduNumSymbols += numSymbols;
---
>           m_totalAmpduSize += size;
>           m_totalAmpduNumSymbols += numSymbols;
2827c2127
<   else if (mpdutype == MIDDLE_MPDU_IN_AGGREGATE)
---
>   else if (mpdutype == MPDU_IN_AGGREGATE && preamble == WIFI_PREAMBLE_NONE)
2833,2834c2133,2134
<           totalAmpduSize += size;
<           totalAmpduNumSymbols += numSymbols;
---
>           m_totalAmpduSize += size;
>           m_totalAmpduNumSymbols += numSymbols;
2837c2137
<   else if (mpdutype == LAST_MPDU_IN_AGGREGATE)
---
>   else if (mpdutype == LAST_MPDU_IN_AGGREGATE && preamble == WIFI_PREAMBLE_NONE)
2840,2843c2140,2143
<       uint32_t totalSize = totalAmpduSize + size;
<       numSymbols = lrint (stbc * ceil ((16 + totalSize * 8.0 + 6 * Nes) / (stbc * numDataBitsPerSymbol)));
<       NS_ASSERT (totalAmpduNumSymbols <= numSymbols);
<       numSymbols -= totalAmpduNumSymbols;
---
>       uint32_t totalAmpduSize = m_totalAmpduSize + size;
>       numSymbols = lrint (stbc * ceil ((16 + totalAmpduSize * 8.0 + 6 * Nes) / (stbc * numDataBitsPerSymbol)));
>       NS_ASSERT (m_totalAmpduNumSymbols <= numSymbols);
>       numSymbols -= m_totalAmpduNumSymbols;
2846,2847c2146,2147
<           totalAmpduSize = 0;
<           totalAmpduNumSymbols = 0;
---
>           m_totalAmpduSize = 0;
>           m_totalAmpduNumSymbols = 0;
2850c2150
<   else if (mpdutype == NORMAL_MPDU || mpdutype == SINGLE_MPDU)
---
>   else if (mpdutype == NORMAL_MPDU && preamble != WIFI_PREAMBLE_NONE)
2852,2854c2152,2154
<       //Not an A-MPDU or single MPDU (i.e. the current payload contains both service and padding)
<       //The number of OFDM symbols in the data field when BCC encoding
<       //is used is given in equation 19-32 of the IEEE 802.11-2016 standard.
---
>       //Not an A-MPDU
>       // The number of OFDM symbols in the data field when BCC encoding 
>       // is used is given in equation 19-32 of the IEEE 802.11-2016 standard.
2859c2159
<       NS_FATAL_ERROR ("Unknown MPDU type");
---
>       NS_FATAL_ERROR ("Wrong combination of preamble and packet type");
2881c2181,2182
<             && (mpdutype == NORMAL_MPDU || mpdutype == SINGLE_MPDU || mpdutype == LAST_MPDU_IN_AGGREGATE)) //at 2.4 GHz
---
>             && ((mpdutype == NORMAL_MPDU && preamble != WIFI_PREAMBLE_NONE)
>                 || (mpdutype == LAST_MPDU_IN_AGGREGATE && preamble == WIFI_PREAMBLE_NONE))) //at 2.4 GHz
2893c2194,2195
<             && ((mpdutype == NORMAL_MPDU || mpdutype == SINGLE_MPDU || mpdutype == LAST_MPDU_IN_AGGREGATE))) //at 2.4 GHz
---
>             && ((mpdutype == NORMAL_MPDU && preamble != WIFI_PREAMBLE_NONE)
>                 || (mpdutype == LAST_MPDU_IN_AGGREGATE && preamble == WIFI_PREAMBLE_NONE))) //at 2.4 GHz
2911,2973d2212
< //// WIGIG ////
< Time
< WifiPhy::GetEDMGPreambleDuration (WifiTxVector txVector)
< {
<   switch (txVector.GetMode ().GetModulationClass ())
<     {
<     case WIFI_MOD_CLASS_EDMG_SC:
<       if ((txVector.GetNumUsers () == 1) && (txVector.GetTransmitMask () == CH_BANDWIDTH_216) && (txVector.Get_NUM_STS () == 1))
<         {
<           return NanoSeconds (0);
<         }
<       else if ((txVector.GetNumUsers () >= 1) && ((txVector.GetTransmitMask () != CH_BANDWIDTH_216) || (txVector.Get_NUM_STS () != 1)))
<         {
<           return NanoSeconds (1380 + (1152 + 1280 * (txVector.Get_SC_EDMG_CEF () - 1))/1.76);
<         }
< 
<     case WIFI_MOD_CLASS_EDMG_OFDM:
<       // OFDM Preamble = 4992 Samples (STF: 2176 + CEF: 1152) * Ts (Chip Time for OFDM), Tc = 0.38ns.
<       // OFDM Preamble = 1.89 micro seconds.
<       return NanoSeconds (1450 + (704 * txVector.Get_OFDM_EDMG_CEF ())/1.76);
< 
<     default:
<       NS_FATAL_ERROR ("Unsupported EDMG preamble");
<       return MicroSeconds (0);
<     }
< }
< 
< Time
< WifiPhy::GetEDMG_HeaderA_Duration (WifiTxVector txVector)
< {
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   switch (preamble)
<     {
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       {
< //        uint32_t Ncw;                       /* Number of LDPC codewords. */
< //        uint32_t Ldpcw;                     /* Number of bits in the second and any subsequent codeword except the last. */
< //        Ncw = 1 + (uint32_t) ceil ((double (size) + L_EDMG_Header_A2) * 8/168);
< //        Ldpcw = (uint32_t) ceil ((double (size) + L_EDMG_Header_A2) * 8/(Ncw - 1));
< //        double ret = double ((Ldpcw + 168) * 32)/1.76;
< //        return NanoSeconds (ceil (ret));
<         return NanoSeconds (0);
<       }
< 
<     case WIFI_PREAMBLE_EDMG_SC:
<       if ((txVector.GetNumUsers () == 1) && (txVector.GetTransmitMask () == CH_BANDWIDTH_216) && (txVector.Get_NUM_STS () == 1))
<         {
<           return NanoSeconds (580);
<         }
<       else if ((txVector.GetNumUsers () >= 1) && ((txVector.GetTransmitMask () != CH_BANDWIDTH_216) || (txVector.Get_NUM_STS () != 1)))
<         {
<           return NanoSeconds (620);
<         }
< 
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       return NanoSeconds (620);
< 
<     default:
<       NS_FATAL_ERROR ("Unsupported EDMG preamble for Header-A");
<       return MicroSeconds (0);
<     }
< }
< 
2975c2214
< WifiPhy::GetEDMG_HeaderB_Duration (WifiTxVector txVector)
---
> WifiPhy::CalculatePlcpPreambleAndHeaderDuration (WifiTxVector txVector)
2978,3009c2217,2224
<   switch (preamble)
<     {
<     case WIFI_PREAMBLE_EDMG_SC:
<       if (txVector.GetNumUsers () == 1)
<         {
<           return NanoSeconds (0);
<         }
<       else if (txVector.GetNumUsers () >= 1)
<         {
<           return NanoSeconds (290);
<         }
< 
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       if (txVector.GetNumUsers () == 1)
<         {
<           return NanoSeconds (0);
<         }
<       else if (txVector.GetNumUsers () >= 1)
<         {
<           return NanoSeconds ((512 + txVector.GetGuardInterval ())/2.64);
<         }
< 
<     default:
<       NS_FATAL_ERROR ("Unsupported EDMG preamble for Header-B");
<       return MicroSeconds (0);
<     }
< }
< 
< Time
< WifiPhy::GetLastRxDuration (void) const
< {
<   return m_rxDuration;
---
>   Time duration = GetPlcpPreambleDuration (txVector)
>     + GetPlcpHeaderDuration (txVector)
>     + GetPlcpHtSigHeaderDuration (preamble)
>     + GetPlcpSigA1Duration (preamble)
>     + GetPlcpSigA2Duration (preamble)
>     + GetPlcpTrainingSymbolDuration (txVector)
>     + GetPlcpSigBDuration (preamble);
>   return duration;
3011d2225
< //// WIGIG ////
3014c2228
< WifiPhy::CalculatePhyPreambleAndHeaderDuration (WifiTxVector txVector)
---
> WifiPhy::CalculateTxDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype, uint8_t incFlag)
3016,3023c2230,2231
<   WifiPreamble preamble = txVector.GetPreambleType ();
<   Time duration = GetPhyPreambleDuration (txVector)
<     + GetPhyHeaderDuration (txVector)
<     + GetPhyHtSigHeaderDuration (preamble)
<     + GetPhySigA1Duration (preamble)
<     + GetPhySigA2Duration (preamble)
<     + GetPhyTrainingSymbolDuration (txVector)
<     + GetPhySigBDuration (preamble);
---
>   Time duration = CalculatePlcpPreambleAndHeaderDuration (txVector)
>     + GetPayloadDuration (size, txVector, frequency, mpdutype, incFlag);
3030,3032c2238
<   Time duration = CalculatePhyPreambleAndHeaderDuration (txVector)
<     + GetPayloadDuration (size, txVector, frequency);
<   return duration;
---
>   return CalculateTxDuration (size, txVector, frequency, NORMAL_MPDU, 0);
3036c2242
< WifiPhy::NotifyTxBegin (Ptr<const WifiPsdu> psdu, double txPowerW)
---
> WifiPhy::NotifyTxBegin (Ptr<const Packet> packet)
3038,3041c2244
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyTxBeginTrace (mpdu->GetProtocolDataUnit (), txPowerW);
<     }
---
>   m_phyTxBeginTrace (packet);
3045c2248
< WifiPhy::NotifyTxEnd (Ptr<const WifiPsdu> psdu)
---
> WifiPhy::NotifyTxEnd (Ptr<const Packet> packet)
3047,3050c2250
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyTxEndTrace (mpdu->GetProtocolDataUnit ());
<     }
---
>   m_phyTxEndTrace (packet);
3054c2254
< WifiPhy::NotifyTxDrop (Ptr<const WifiPsdu> psdu)
---
> WifiPhy::NotifyTxDrop (Ptr<const Packet> packet)
3056,3059c2256
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyTxDropTrace (mpdu->GetProtocolDataUnit ());
<     }
---
>   m_phyTxDropTrace (packet);
3063c2260
< WifiPhy::NotifyRxBegin (Ptr<const WifiPsdu> psdu)
---
> WifiPhy::NotifyRxBegin (Ptr<const Packet> packet)
3065,3068c2262
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyRxBeginTrace (mpdu->GetProtocolDataUnit ());
<     }
---
>   m_phyRxBeginTrace (packet);
3072c2266
< WifiPhy::NotifyRxEnd (Ptr<const WifiPsdu> psdu)
---
> WifiPhy::NotifyRxEnd (Ptr<const Packet> packet)
3074,3086c2268
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyRxEndTrace (mpdu->GetProtocolDataUnit ());
<     }
< }
< 
< void
< WifiPhy::NotifyRxDrop (Ptr<const WifiPsdu> psdu, WifiPhyRxfailureReason reason)
< {
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       m_phyRxDropTrace (mpdu->GetProtocolDataUnit (), reason);
<     }
---
>   m_phyRxEndTrace (packet);
3090,3091c2272
< WifiPhy::NotifyMonitorSniffRx (Ptr<const WifiPsdu> psdu, uint16_t channelFreqMhz, WifiTxVector txVector,
<                                SignalNoiseDbm signalNoise, std::vector<bool> statusPerMpdu)
---
> WifiPhy::NotifyRxDrop (Ptr<const Packet> packet)
3093,3117c2274
<   MpduInfo aMpdu;
<   if (psdu->IsAggregate ())
<     {
<       //Expand A-MPDU
<       NS_ASSERT_MSG (txVector.IsAggregation (), "TxVector with aggregate flag expected here according to PSDU");
<       aMpdu.mpduRefNumber = ++m_rxMpduReferenceNumber;
<       size_t nMpdus = psdu->GetNMpdus ();
<       NS_ASSERT_MSG (statusPerMpdu.size () == nMpdus, "Should have one reception status per MPDU");
<       aMpdu.type = (psdu->IsSingle ()) ? SINGLE_MPDU: FIRST_MPDU_IN_AGGREGATE;
<       for (size_t i = 0; i < nMpdus;)
<         {
<           if (statusPerMpdu.at (i)) //packet received without error, hand over to sniffer
<             {
<               m_phyMonitorSniffRxTrace (psdu->GetAmpduSubframe (i), channelFreqMhz, txVector, aMpdu, signalNoise);
<             }
<           ++i;
<           aMpdu.type = (i == (nMpdus - 1)) ? LAST_MPDU_IN_AGGREGATE : MIDDLE_MPDU_IN_AGGREGATE;
<         }
<     }
<   else
<     {
<       aMpdu.type = NORMAL_MPDU;
<       NS_ASSERT_MSG (statusPerMpdu.size () == 1, "Should have one reception status for normal MPDU");
<       m_phyMonitorSniffRxTrace (psdu->GetPacket (), channelFreqMhz, txVector, aMpdu, signalNoise);
<     }
---
>   m_phyRxDropTrace (packet);
3121c2278
< WifiPhy::NotifyMonitorSniffTx (Ptr<const WifiPsdu> psdu, uint16_t channelFreqMhz, WifiTxVector txVector)
---
> WifiPhy::NotifyMonitorSniffRx (Ptr<const Packet> packet, uint16_t channelFreqMhz, WifiTxVector txVector, MpduInfo aMpdu, SignalNoiseDbm signalNoise)
3123,3142c2280
<   MpduInfo aMpdu;
<   if (psdu->IsAggregate ())
<     {
<       //Expand A-MPDU
<       NS_ASSERT_MSG (txVector.IsAggregation (), "TxVector with aggregate flag expected here according to PSDU");
<       aMpdu.mpduRefNumber = ++m_rxMpduReferenceNumber;
<       size_t nMpdus = psdu->GetNMpdus ();
<       aMpdu.type = (psdu->IsSingle ()) ? SINGLE_MPDU: FIRST_MPDU_IN_AGGREGATE;
<       for (size_t i = 0; i < nMpdus;)
<         {
<           m_phyMonitorSniffTxTrace (psdu->GetAmpduSubframe (i), channelFreqMhz, txVector, aMpdu);
<           ++i;
<           aMpdu.type = (i == (nMpdus - 1)) ? LAST_MPDU_IN_AGGREGATE : MIDDLE_MPDU_IN_AGGREGATE;
<         }
<     }
<   else
<     {
<       aMpdu.type = NORMAL_MPDU;
<       m_phyMonitorSniffTxTrace (psdu->GetPacket (), channelFreqMhz, txVector, aMpdu);
<     }
---
>   m_phyMonitorSniffRxTrace (packet, channelFreqMhz, txVector, aMpdu, signalNoise);
3146c2284
< WifiPhy::NotifyEndOfHePreamble (HePreambleParameters params)
---
> WifiPhy::NotifyMonitorSniffTx (Ptr<const Packet> packet, uint16_t channelFreqMhz, WifiTxVector txVector, MpduInfo aMpdu)
3148c2286
<   m_phyEndOfHePreambleTrace (params);
---
>   m_phyMonitorSniffTxTrace (packet, channelFreqMhz, txVector, aMpdu);
3152c2290
< WifiPhy::Send (Ptr<const WifiPsdu> psdu, WifiTxVector txVector)
---
> WifiPhy::SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, MpduType mpdutype)
3154c2292,2296
<   NS_LOG_FUNCTION (this << *psdu << txVector);
---
>   NS_LOG_FUNCTION (this << packet << txVector.GetMode ()
>                         << txVector.GetMode ().GetDataRate (txVector)
>                         << txVector.GetPreambleType ()
>                         << +txVector.GetTxPowerLevel ()
>                         << +mpdutype);
3162d2303
<   NS_ASSERT (m_endTxEvent.IsExpired ());
3172c2313
<       NotifyTxDrop (psdu);
---
>       NotifyTxDrop (packet);
3176c2317
<   Time txDuration = CalculateTxDuration (psdu->GetSize (), txVector, GetFrequency ());
---
>   Time txDuration = CalculateTxDuration (packet->GetSize (), txVector, GetFrequency (), mpdutype, 1);
3179,3190c2320
<   if ((m_currentEvent != 0) && (m_currentEvent->GetEndTime () > (Simulator::Now () + m_state->GetDelayUntilIdle ())))
<     {
<       //that packet will be noise _after_ the transmission.
<       MaybeCcaBusyDuration ();
<     }
< 
<   if (m_currentEvent != 0)
<     {
<       AbortCurrentReception (RECEPTION_ABORTED_BY_TX);
<     }
< 
<   if (m_powerRestricted)
---
>   if (m_state->IsStateRx ())
3192c2322,2324
<       NS_LOG_DEBUG ("Transmitting with power restriction");
---
>       m_endPlcpRxEvent.Cancel ();
>       m_endRxEvent.Cancel ();
>       m_interference.NotifyRxEnd ();
3194c2326,2327
<   else
---
>   NotifyTxBegin (packet);
>   if ((mpdutype == MPDU_IN_AGGREGATE) && (txVector.GetPreambleType () != WIFI_PREAMBLE_NONE))
3196c2329,2330
<       NS_LOG_DEBUG ("Transmitting without power restriction");
---
>       //send the first MPDU in an MPDU
>       m_txMpduReferenceNumber++;
3198c2332,2340
< 
---
>   MpduInfo aMpdu;
>   aMpdu.type = mpdutype;
>   aMpdu.mpduRefNumber = m_txMpduReferenceNumber;
>   NotifyMonitorSniffTx (packet, GetFrequency (), txVector, aMpdu);
>   m_state->SwitchToTx (txDuration, packet, GetPowerDbm (txVector.GetTxPowerLevel ()), txVector);
> 
>   Ptr<Packet> newPacket = packet->Copy (); // obtain non-const Packet
>   WifiPhyTag oldtag;
>   newPacket->RemovePacketTag (oldtag);
3204,3212c2346
< 
<   double txPowerW = DbmToW (GetTxPowerForTransmission (txVector) + GetTxGain ());
<   NotifyTxBegin (psdu, txPowerW);
<   m_phyTxPsduBeginTrace (psdu, txVector, txPowerW);
<   NotifyMonitorSniffTx (psdu, GetFrequency (), txVector);
<   m_state->SwitchToTx (txDuration, psdu->GetPacket (), GetPowerDbm (txVector.GetTxPowerLevel ()), txVector);
< 
<   Ptr<WifiPpdu> ppdu = Create<WifiPpdu> (psdu, txVector, txDuration, GetFrequency ());
< 
---
>   uint8_t isFrameComplete = 1;
3215c2349
<       ppdu->SetTruncatedTx ();
---
>       isFrameComplete = 0;
3216a2351,2352
>   WifiPhyTag tag (txVector, mpdutype, isFrameComplete);
>   newPacket->AddPacketTag (tag);
3218,3223c2354
<   m_endTxEvent = Simulator::Schedule (txDuration, &WifiPhy::NotifyTxEnd, this, psdu);
< 
<   StartTx (ppdu);
< 
<   m_channelAccessRequested = false;
<   m_powerRestricted = false;
---
>   StartTx (newPacket, txVector, txDuration);
3227c2358
< WifiPhy::StartReceiveHeader (Ptr<Event> event)
---
> WifiPhy::StartReceivePreambleAndHeader (Ptr<Packet> packet, double rxPowerW, Time rxDuration)
3229,3240c2360,2362
<   NS_LOG_FUNCTION (this << *event);
<   NS_ASSERT (!IsStateRx ());
<   NS_ASSERT (m_endPhyRxEvent.IsExpired ());
<   NS_ASSERT (m_currentEvent != 0);
<   NS_ASSERT (event->GetStartTime () == m_currentEvent->GetStartTime ());
<   NS_ASSERT (event->GetEndTime () == m_currentEvent->GetEndTime ());
< 
<   InterferenceHelper::SnrPer snrPer = m_interference.CalculateNonHtPhyHeaderSnrPer (event);
<   double snr = snrPer.snr;
<   NS_LOG_DEBUG ("snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per);
< 
<   if (!m_preambleDetectionModel || (m_preambleDetectionModel->IsPreambleDetected (event->GetRxPowerW (), snr, m_channelWidth)))
---
>   WifiPhyTag tag;
>   bool found = packet->RemovePacketTag (tag);
>   if (!found)
3242,3274c2364,2365
<       NotifyRxBegin (event->GetPsdu ());
< 
<       m_timeLastPreambleDetected = Simulator::Now ();
<       WifiTxVector txVector = event->GetTxVector ();
< 
<       if ((txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT) && (txVector.GetPreambleType () == WIFI_PREAMBLE_HT_GF))
<         {
<           //No non-HT PHY header for HT GF
<           Time remainingPreambleHeaderDuration = CalculatePhyPreambleAndHeaderDuration (txVector) - GetPreambleDetectionDuration ();
<           m_state->SwitchMaybeToCcaBusy (remainingPreambleHeaderDuration);
<           m_endPhyRxEvent = Simulator::Schedule (remainingPreambleHeaderDuration, &WifiPhy::StartReceivePayload, this, event);
<         }
<       else
<         {
<           //Schedule end of non-HT PHY header
<           Time remainingPreambleAndNonHtHeaderDuration = GetPhyPreambleDuration (txVector) + GetPhyHeaderDuration (txVector) - GetPreambleDetectionDuration ();
<           m_state->SwitchMaybeToCcaBusy (remainingPreambleAndNonHtHeaderDuration);
<           m_endPhyRxEvent = Simulator::Schedule (remainingPreambleAndNonHtHeaderDuration, &WifiPhy::ContinueReceiveHeader, this, event);
<         }
<     }
<   else
<     {
<       NS_LOG_DEBUG ("Drop packet because PHY preamble detection failed");
<       NotifyRxDrop (event->GetPsdu (), PREAMBLE_DETECT_FAILURE);
<       m_interference.NotifyRxEnd ();
<       m_currentEvent = 0;
< 
<       // Like CCA-SD, CCA-ED is governed by the 4μs CCA window to flag CCA-BUSY
<       // for any received signal greater than the CCA-ED threshold.
<       if (event->GetEndTime () > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           MaybeCcaBusyDuration ();
<         }
---
>       NS_FATAL_ERROR ("Received Wi-Fi Signal with no WifiPhyTag");
>       return;
3276d2366
< }
3278,3285c2368,2373
< void
< WifiPhy::ContinueReceiveHeader (Ptr<Event> event)
< {
<   NS_LOG_FUNCTION (this << *event);
<   NS_ASSERT (m_endPhyRxEvent.IsExpired ());
< 
<   InterferenceHelper::SnrPer snrPer;
<   snrPer = m_interference.CalculateNonHtPhyHeaderSnrPer (event);
---
>   WifiTxVector txVector = tag.GetWifiTxVector ();
>   Ptr<Event> event;
>   event = m_interference.Add (packet,
>                               txVector,
>                               rxDuration,
>                               rxPowerW);
3287c2375,2377
<   if (m_random->GetValue () > snrPer.per) //non-HT PHY header reception succeeded
---
>   //This function should be later split to check separately whether plcp preamble and plcp header can be successfully received.
>   //Note: plcp preamble reception is not yet modeled.
>   if (m_state->GetState () == WifiPhyState::OFF)
3289,3303c2379,2380
<       NS_LOG_DEBUG ("Received non-HT PHY header");
<       WifiTxVector txVector = event->GetTxVector ();
<       Time remainingRxDuration = event->GetEndTime () - Simulator::Now ();
<       m_state->SwitchMaybeToCcaBusy (remainingRxDuration);
<       Time remainingPreambleHeaderDuration = CalculatePhyPreambleAndHeaderDuration (txVector) - GetPhyPreambleDuration (txVector) - GetPhyHeaderDuration (txVector);
<       m_endPhyRxEvent = Simulator::Schedule (remainingPreambleHeaderDuration, &WifiPhy::StartReceivePayload, this, event);
<     }
<   else //non-HT PHY header reception failed
<     {
<       NS_LOG_DEBUG ("Abort reception because non-HT PHY header reception failed");
<       AbortCurrentReception (L_SIG_FAILURE);
<       if (event->GetEndTime () > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           MaybeCcaBusyDuration ();
<         }
---
>       NS_LOG_DEBUG ("Cannot start RX because device is OFF");
>       return;
3305d2381
< }
3307,3315c2383
< void
< WifiPhy::StartReceivePreamble (Ptr<WifiPpdu> ppdu, double rxPowerW)
< {
<   NS_LOG_FUNCTION (this << *ppdu << rxPowerW);
<   WifiTxVector txVector = ppdu->GetTxVector ();
<   Time rxDuration = ppdu->GetTxDuration ();
<   Ptr<const WifiPsdu> psdu = ppdu->GetPsdu ();
<   Ptr<Event> event = m_interference.Add (ppdu, txVector, rxDuration, rxPowerW);
<   Time endRx = Simulator::Now () + rxDuration;
---
>   NS_LOG_FUNCTION (this << packet << WToDbm (rxPowerW) << rxDuration);
3317c2385
<   if (m_state->GetState () == WifiPhyState::OFF)
---
>   if (tag.GetFrameComplete () == 0)
3319,3323c2387,2389
<       NS_LOG_DEBUG ("Cannot start RX because device is OFF");
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           MaybeCcaBusyDuration ();
<         }
---
>       NS_LOG_DEBUG ("drop packet because of incomplete frame");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
3327c2393,2394
<   if (ppdu->IsTruncatedTx ())
---
>   if (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_HT
>       && (txVector.GetNss () != (1 + (txVector.GetMode ().GetMcsValue () / 8))))
3329,3334c2396
<       NS_LOG_DEBUG ("Packet reception stopped because transmitter has been switched off");
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           MaybeCcaBusyDuration ();
<         }
<       return;
---
>       NS_FATAL_ERROR ("MCS value does not match NSS value: MCS = " << +txVector.GetMode ().GetMcsValue () << ", NSS = " << +txVector.GetNss ());
3337c2399,2400
<   if (!txVector.GetModeInitialized ())
---
>   Time endRx = Simulator::Now () + rxDuration;
>   if (txVector.GetNss () > GetMaxSupportedRxSpatialStreams ())
3339,3342c2402,2405
<       //If SetRate method was not called above when filling in txVector, this means the PHY does support the rate indicated in PHY SIG headers
<       NS_LOG_DEBUG ("drop packet because of unsupported RX mode");
<       NotifyRxDrop (psdu, UNSUPPORTED_SETTINGS);
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
---
>       NS_LOG_DEBUG ("drop packet because not enough RX antennas");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
>       if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
3343a2407,2408
>           //that packet will be noise _after_ the transmission of the
>           //currently-transmitted packet.
3344a2410
>           return;
3346d2411
<       return;
3348a2414
>   MpduType mpdutype = tag.GetMpduType ();
3353c2419,2420
<       NotifyRxDrop (psdu, CHANNEL_SWITCHING);
---
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
3359c2426
<        * busy due to other devices' transmissions started before the end of
---
>        * busy due to other devices' tramissions started before the end of
3362c2429
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
---
>       if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
3364c2431,2432
<           //that packet will be noise _after_ the completion of the channel switching.
---
>           //that packet will be noise _after_ the completion of the
>           //channel switching.
3365a2434
>           return;
3371d2439
<           && m_frameCaptureModel->IsInCaptureWindow (m_timeLastPreambleDetected)
3374c2442
<           AbortCurrentReception (FRAME_CAPTURE_PACKET_SWITCH);
---
>           AbortCurrentReception ();
3376c2444
<           StartRx (event, rxPowerW);
---
>           StartRx (packet, txVector, mpdutype, rxPowerW, rxDuration, event);
3380c2448
<           NS_LOG_DEBUG ("Drop packet because already in Rx (power=" <<
---
>           NS_LOG_DEBUG ("drop packet because already in Rx (power=" <<
3382,3383c2450,2451
<           NotifyRxDrop (psdu, RXING);
<           if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
---
>           NotifyRxDrop (packet);
>           if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
3385c2453,2454
<               //that packet will be noise _after_ the reception of the currently-received packet.
---
>               //that packet will be noise _after_ the reception of the
>               //currently-received packet.
3386a2456
>               return;
3391c2461
<       NS_LOG_DEBUG ("Drop packet because already in Tx (power=" <<
---
>       NS_LOG_DEBUG ("drop packet because already in Tx (power=" <<
3393,3394c2463,2464
<       NotifyRxDrop (psdu, TXING);
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
---
>       NotifyRxDrop (packet);
>       if (endRx > Simulator::Now () + m_state->GetDelayUntilIdle ())
3396c2466,2467
<           //that packet will be noise _after_ the transmission of the currently-transmitted packet.
---
>           //that packet will be noise _after_ the transmission of the
>           //currently-transmitted packet.
3397a2469
>           return;
3401,3427d2472
<       if (m_currentEvent != 0)
<         {
<           if (m_frameCaptureModel != 0
<               && m_frameCaptureModel->IsInCaptureWindow (m_timeLastPreambleDetected)
<               && m_frameCaptureModel->CaptureNewFrame (m_currentEvent, event))
<             {
<               AbortCurrentReception (FRAME_CAPTURE_PACKET_SWITCH);
<               NS_LOG_DEBUG ("Switch to new packet");
<               StartRx (event, rxPowerW);
<             }
<           else
<             {
<               NS_LOG_DEBUG ("Drop packet because already in Rx (power=" <<
<                             rxPowerW << "W)");
<               NotifyRxDrop (psdu, RXING);
<               if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<                 {
<                   //that packet will be noise _after_ the reception of the currently-received packet.
<                   MaybeCcaBusyDuration ();
<                 }
<             }
<         }
<       else
<         {
<           StartRx (event, rxPowerW);
<         }
<       break;
3429c2474
<       StartRx (event, rxPowerW);
---
>       StartRx (packet, txVector, mpdutype, rxPowerW, rxDuration, event);
3432,3438c2477,2479
<       NS_LOG_DEBUG ("Drop packet because in sleep mode");
<       NotifyRxDrop (psdu, SLEEPING);
<       if (endRx > (Simulator::Now () + m_state->GetDelayUntilIdle ()))
<         {
<           //that packet will be noise _after_ the sleep period.
<           MaybeCcaBusyDuration ();
<         }
---
>       NS_LOG_DEBUG ("drop packet because in sleep mode");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
3454c2495
<   Time delayUntilCcaEnd = m_interference.GetEnergyDuration (m_ccaEdThresholdW);
---
>   Time delayUntilCcaEnd = m_interference.GetEnergyDuration (DbmToW (GetCcaMode1Threshold ()));
3457d2497
<       NS_LOG_DEBUG ("In CCA Busy State for " << delayUntilCcaEnd);
3460,3463d2499
<   else
<     {
<       NS_LOG_DEBUG ("Not in CCA Busy State");
<     }
3467,3472c2503,2510
< WifiPhy::StartReceivePayload (Ptr<Event> event)
< {
<   NS_LOG_FUNCTION (this << *event);
<   NS_ASSERT (m_endPhyRxEvent.IsExpired ());
<   NS_ASSERT (m_endRxEvent.IsExpired ());
<   WifiTxVector txVector = event->GetTxVector ();
---
> WifiPhy::StartReceivePacket (Ptr<Packet> packet,
>                              WifiTxVector txVector,
>                              MpduType mpdutype,
>                              Ptr<Event> event)
> {
>   NS_LOG_FUNCTION (this << packet << txVector.GetMode () << txVector.GetPreambleType () << +mpdutype);
>   NS_ASSERT (IsStateRx ());
>   NS_ASSERT (m_endPlcpRxEvent.IsExpired ());
3474,3488c2512,2518
<   bool canReceivePayload;
<   if (txMode.GetModulationClass () >= WIFI_MOD_CLASS_HT)
<     {
<       InterferenceHelper::SnrPer snrPer;
<       snrPer = m_interference.CalculateHtPhyHeaderSnrPer (event);
<       NS_LOG_DEBUG ("snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per);
<       canReceivePayload = (m_random->GetValue () > snrPer.per);
<     }
<   else
<     {
<       //If we are here, this means non-HT PHY header was already successfully received
<       canReceivePayload = true;
<     }
<   Time payloadDuration = event->GetEndTime () - event->GetStartTime () - CalculatePhyPreambleAndHeaderDuration (txVector);
<   if (canReceivePayload) //PHY reception succeeded
---
> 
>   InterferenceHelper::SnrPer snrPer;
>   snrPer = m_interference.CalculatePlcpHeaderSnrPer (event);
> 
>   NS_LOG_DEBUG ("snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per);
> 
>   if (m_random->GetValue () > snrPer.per) //plcp reception succeeded
3490,3495c2520
<       if (txVector.GetNss () > GetMaxSupportedRxSpatialStreams ())
<         {
<           NS_LOG_DEBUG ("Packet reception could not be started because not enough RX antennas");
<           NotifyRxDrop (event->GetPsdu (), UNSUPPORTED_SETTINGS);
<         }
<       else if ((txVector.GetChannelWidth () >= 40) && (txVector.GetChannelWidth () > GetChannelWidth ()))
---
>       if (IsModeSupported (txMode) || IsMcsSupported (txMode))
3497,3498c2522,2523
<           NS_LOG_DEBUG ("Packet reception could not be started because not enough channel width");
<           NotifyRxDrop (event->GetPsdu (), UNSUPPORTED_SETTINGS);
---
>           NS_LOG_DEBUG ("receiving plcp payload"); //endReceive is already scheduled
>           m_plcpSuccess = true;
3500c2525
<       else if (!IsModeSupported (txMode) && !IsMcsSupported (txMode))
---
>       else //mode is not allowed
3502,3518c2527,2529
<           NS_LOG_DEBUG ("Drop packet because it was sent using an unsupported mode (" << txMode << ")");
<           NotifyRxDrop (event->GetPsdu (), UNSUPPORTED_SETTINGS);
<         }
<       else
<         {
<           m_state->SwitchToRx (payloadDuration);
<           m_endRxEvent = Simulator::Schedule (payloadDuration, &WifiPhy::EndReceive, this, event);
<           NS_LOG_DEBUG ("Receiving PSDU");
<           m_phyRxPayloadBeginTrace (txVector, payloadDuration); //this callback (equivalent to PHY-RXSTART primitive) is triggered only if headers have been correctly decoded and that the mode within is supported
<           if (txMode.GetModulationClass () == WIFI_MOD_CLASS_HE)
<             {
<               HePreambleParameters params;
<               params.rssiW = event->GetRxPowerW ();
<               params.bssColor = event->GetTxVector ().GetBssColor ();
<               NotifyEndOfHePreamble (params);
<             }
<           return;
---
>           NS_LOG_DEBUG ("drop packet because it was sent using an unsupported mode (" << txMode << ")");
>           NotifyRxDrop (packet);
>           m_plcpSuccess = false;
3521c2532
<   else //PHY reception failed
---
>   else //plcp reception failed
3523,3524c2534,2536
<       NS_LOG_DEBUG ("Drop packet because HT PHY header reception failed");
<       NotifyRxDrop (event->GetPsdu (), SIG_A_FAILURE);
---
>       NS_LOG_DEBUG ("drop packet because plcp preamble/header reception failed");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
3526d2537
<   m_endRxEvent = Simulator::Schedule (payloadDuration, &WifiPhy::ResetReceive, this, event);
3530c2541
< WifiPhy::EndReceive (Ptr<Event> event)
---
> WifiPhy::EndReceive (Ptr<Packet> packet, WifiPreamble preamble, MpduType mpdutype, Ptr<Event> event)
3532,3534c2543,2544
<   Time psduDuration = event->GetEndTime () - event->GetStartTime ();
<   NS_LOG_FUNCTION (this << *event << psduDuration);
<   NS_ASSERT (GetLastRxEndTime () == Simulator::Now ());
---
>   NS_LOG_FUNCTION (this << packet << event);
>   NS_ASSERT (IsStateRx ());
3537,3598c2547,2548
<   double snr = m_interference.CalculateSnr (event);
<   std::vector<bool> statusPerMpdu;
<   SignalNoiseDbm signalNoise;
< 
<   Ptr<const WifiPsdu> psdu = event->GetPsdu ();
<   Time relativeStart = NanoSeconds (0);
<   bool receptionOkAtLeastForOneMpdu = false;
<   std::pair<bool, SignalNoiseDbm> rxInfo;
<   WifiTxVector txVector = event->GetTxVector ();
<   size_t nMpdus = psdu->GetNMpdus ();
<   if (nMpdus > 1)
<     {
<       //Extract all MPDUs of the A-MPDU to compute per-MPDU PER stats
<       Time remainingAmpduDuration = psduDuration;
<       MpduType mpdutype = FIRST_MPDU_IN_AGGREGATE;
<       auto mpdu = psdu->begin ();
<       uint32_t totalAmpduSize = 0;
<       double totalAmpduNumSymbols = 0.0;
<       for (size_t i = 0; i < nMpdus && mpdu != psdu->end (); ++mpdu)
<         {
<           Time mpduDuration = GetPayloadDuration (psdu->GetAmpduSubframeSize (i), txVector,
<                                                   GetFrequency (), mpdutype, true, totalAmpduSize, totalAmpduNumSymbols);
<           remainingAmpduDuration -= mpduDuration;
<           if (i == (nMpdus - 1) && !remainingAmpduDuration.IsZero ()) //no more MPDU coming
<             {
<               mpduDuration += remainingAmpduDuration; //apply a correction just in case rounding had induced slight shift
<             }
<           rxInfo = GetReceptionStatus (Create<WifiPsdu> (*mpdu, false),
<                                        event, relativeStart, mpduDuration);
<           NS_LOG_DEBUG ("Extracted MPDU #" << i << ": duration: " << mpduDuration.GetNanoSeconds () << "ns" <<
<                         ", correct reception: " << rxInfo.first <<
<                         ", Signal/Noise: " << rxInfo.second.signal << "/" << rxInfo.second.noise << "dBm");
<           signalNoise = rxInfo.second; //same information for all MPDUs
<           statusPerMpdu.push_back (rxInfo.first);
<           receptionOkAtLeastForOneMpdu |= rxInfo.first;
< 
<           //Prepare next iteration
<           ++i;
<           relativeStart += mpduDuration;
<           mpdutype = (i == (nMpdus - 1)) ? LAST_MPDU_IN_AGGREGATE : MIDDLE_MPDU_IN_AGGREGATE;
<         }
<     }
<   else
<     {
<       rxInfo = GetReceptionStatus (psdu, event, relativeStart, psduDuration);
<       signalNoise = rxInfo.second; //same information for all MPDUs
<       statusPerMpdu.push_back (rxInfo.first);
<       receptionOkAtLeastForOneMpdu = rxInfo.first;
<     }
< 
<   NotifyRxEnd (psdu);
< 
<   if (receptionOkAtLeastForOneMpdu)
<     {
<       NotifyMonitorSniffRx (psdu, GetFrequency (), txVector, signalNoise, statusPerMpdu);
<       m_state->SwitchFromRxEndOk (Copy (psdu), snr, txVector, statusPerMpdu);
<     }
<   else
<     {
<       m_state->SwitchFromRxEndError (Copy (psdu), snr);
<     }
< 
---
>   InterferenceHelper::SnrPer snrPer;
>   snrPer = m_interference.CalculatePlcpPayloadSnrPer (event);
3601,3602d2550
<   MaybeCcaBusyDuration ();
< }
3604,3623c2552
< std::pair<bool, SignalNoiseDbm>
< WifiPhy::GetReceptionStatus (Ptr<const WifiPsdu> psdu, Ptr<Event> event, Time relativeMpduStart, Time mpduDuration)
< {
<   NS_LOG_FUNCTION (this << *psdu << *event << relativeMpduStart << mpduDuration);
<   InterferenceHelper::SnrPer snrPer;
<   snrPer = m_interference.CalculatePayloadSnrPer (event, std::make_pair (relativeMpduStart, relativeMpduStart + mpduDuration));
< 
<   NS_LOG_DEBUG ("mode=" << (event->GetTxVector ().GetMode ().GetDataRate (event->GetTxVector ())) <<
<                 ", snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per << ", size=" << psdu->GetSize () <<
<                 ", relativeStart = " << relativeMpduStart.GetNanoSeconds () << "ns, duration = " << mpduDuration.GetNanoSeconds () << "ns");
< 
<   // There are two error checks: PER and receive error model check.
<   // PER check models is typical for Wi-Fi and is based on signal modulation;
<   // Receive error model is optional, if we have an error model and
<   // it indicates that the packet is corrupt, drop the packet.
<   SignalNoiseDbm signalNoise;
<   signalNoise.signal = WToDbm (event->GetRxPowerW ());
<   signalNoise.noise = WToDbm (event->GetRxPowerW () / snrPer.snr);
<   if (m_random->GetValue () > snrPer.per &&
<       !(m_postReceptionErrorModel && m_postReceptionErrorModel->IsCorrupt (psdu->GetPacket ()->Copy ())))
---
>   if (m_plcpSuccess == true)
3625,3626c2554,2574
<       NS_LOG_DEBUG ("Reception succeeded: " << psdu);
<       return std::make_pair (true, signalNoise);
---
>       NS_LOG_DEBUG ("mode=" << (event->GetPayloadMode ().GetDataRate (event->GetTxVector ())) <<
>                     ", snr(dB)=" << RatioToDb (snrPer.snr) << ", per=" << snrPer.per << ", size=" << packet->GetSize ());
> 
>       if (m_random->GetValue () > snrPer.per)
>         {
>           NotifyRxEnd (packet);
>           SignalNoiseDbm signalNoise;
>           signalNoise.signal = WToDbm (event->GetRxPowerW ());
>           signalNoise.noise = WToDbm (event->GetRxPowerW () / snrPer.snr);
>           MpduInfo aMpdu;
>           aMpdu.type = mpdutype;
>           aMpdu.mpduRefNumber = m_rxMpduReferenceNumber;
>           NotifyMonitorSniffRx (packet, GetFrequency (), event->GetTxVector (), aMpdu, signalNoise);
>           m_state->SwitchFromRxEndOk (packet, snrPer.snr, event->GetTxVector ());
>         }
>       else
>         {
>           /* failure. */
>           NotifyRxDrop (packet);
>           m_state->SwitchFromRxEndError (packet, snrPer.snr);
>         }
3630,3631c2578
<       NS_LOG_DEBUG ("Reception failed: " << psdu);
<       return std::make_pair (false, signalNoise);
---
>       m_state->SwitchFromRxEndError (packet, snrPer.snr);
3633d2579
< }
3635,3639c2581
< void
< WifiPhy::EndReceiveInterBss (void)
< {
<   NS_LOG_FUNCTION (this);
<   if (!m_channelAccessRequested)
---
>   if (preamble == WIFI_PREAMBLE_NONE && mpdutype == LAST_MPDU_IN_AGGREGATE)
3641c2583
<       m_powerRestricted = false;
---
>       m_plcpSuccess = false;
3643,3654d2584
< }
< 
< void
< WifiPhy::ResetReceive (Ptr<Event> event)
< {
<   NS_LOG_FUNCTION (this << *event);
<   NS_ASSERT (event->GetEndTime () == Simulator::Now ());
<   NS_ASSERT (!IsStateRx ());
<   m_interference.NotifyRxEnd ();
<   m_currentEvent = 0;
<   MaybeCcaBusyDuration ();
< }
3656,3660d2585
< //// WIGIG ////
< void
< WifiPhy::EndAllocationPeriod (void)
< {
<   NS_ABORT_MSG ("Should not be called for normal WifiPhy");
3662d2586
< //// WIGIG ////
3664,3669d2587
< void
< WifiPhy::NotifyChannelAccessRequested (void)
< {
<   NS_LOG_FUNCTION (this);
<   m_channelAccessRequested = true;
< }
4576,4578c3494
<   WifiModulationClass modulation = mcs.GetModulationClass ();
<   if (modulation == WIFI_MOD_CLASS_HT || modulation == WIFI_MOD_CLASS_VHT
<       || modulation == WIFI_MOD_CLASS_HE)
---
>   for (uint8_t i = 0; i < GetNMcs (); i++)
4580c3496,3499
<       return IsMcsSupported (modulation, mcs.GetMcsValue ());
---
>       if (mcs == GetMcs (i))
>         {
>           return true;
>         }
4585,4598d3503
< bool
< WifiPhy::IsMcsSupported (WifiModulationClass mc, uint8_t mcs) const
< {
<   if (m_mcsIndexMap.find (mc) == m_mcsIndexMap.end ())
<     {
<       return false;
<     }
<   if (m_mcsIndexMap.at (mc).find (mcs) == m_mcsIndexMap.at (mc).end ())
<     {
<       return false;
<     }
<   return true;
< }
< 
4623,4652d3527
< WifiMode
< WifiPhy::GetMcs (WifiModulationClass modulation, uint8_t mcs) const
< {
<   NS_ASSERT_MSG (IsMcsSupported (modulation, mcs), "Unsupported MCS");
<   uint8_t index = m_mcsIndexMap.at (modulation).at (mcs);
<   NS_ASSERT (index < m_deviceMcsSet.size ());
<   WifiMode mode = m_deviceMcsSet[index];
<   NS_ASSERT (mode.GetModulationClass () == modulation);
<   NS_ASSERT (mode.GetMcsValue () == mcs);
<   return mode;
< }
< 
< WifiMode
< WifiPhy::GetHtMcs (uint8_t mcs) const
< {
<   return GetMcs (WIFI_MOD_CLASS_HT, mcs);
< }
< 
< WifiMode
< WifiPhy::GetVhtMcs (uint8_t mcs) const
< {
<   return GetMcs (WIFI_MOD_CLASS_VHT, mcs);
< }
< 
< WifiMode
< WifiPhy::GetHeMcs (uint8_t mcs) const
< {
<   return GetMcs (WIFI_MOD_CLASS_HE, mcs);
< }
< 
4707,4712d3581
< Time
< WifiPhy::GetLastRxEndTime (void) const
< {
<   return m_state->GetLastRxEndTime ();
< }
< 
4722c3591
<   Time delayUntilCcaEnd = m_interference.GetEnergyDuration (m_ccaEdThresholdW);
---
>   Time delayUntilCcaEnd = m_interference.GetEnergyDuration (DbmToW (GetCcaMode1Threshold ()));
4731c3600
< WifiPhy::AbortCurrentReception (WifiPhyRxfailureReason reason)
---
> WifiPhy::AbortCurrentReception ()
4733,4738c3602,3603
<   NS_LOG_FUNCTION (this << reason);
<   if (m_endPreambleDetectionEvent.IsRunning ())
<     {
<       m_endPreambleDetectionEvent.Cancel ();
<     }
<   if (m_endPhyRxEvent.IsRunning ())
---
>   NS_LOG_FUNCTION (this);
>   if (m_endPlcpRxEvent.IsRunning ())
4740c3605
<       m_endPhyRxEvent.Cancel ();
---
>       m_endPlcpRxEvent.Cancel ();
4746c3611
<   NotifyRxDrop (m_currentEvent->GetPsdu (), reason);
---
>   NotifyRxDrop (m_currentEvent->GetPacket ());
4748,4751c3613
<   if (reason == OBSS_PD_CCA_RESET)
<     {
<       m_state->SwitchFromRxAbort ();
<     }
---
>   m_state->SwitchFromRxAbort ();
4756c3618
< WifiPhy::ResetCca (bool powerRestricted, double txPowerMaxSiso, double txPowerMaxMimo)
---
> WifiPhy::StartRx (Ptr<Packet> packet, WifiTxVector txVector, MpduType mpdutype, double rxPowerW, Time rxDuration, Ptr<Event> event)
4758,4771c3620,3621
<   NS_LOG_FUNCTION (this << powerRestricted << txPowerMaxSiso << txPowerMaxMimo);
<   m_powerRestricted = powerRestricted;
<   m_txPowerMaxSiso = txPowerMaxSiso;
<   m_txPowerMaxMimo = txPowerMaxMimo;
<   NS_ASSERT ((m_currentEvent->GetEndTime () - Simulator::Now ()).IsPositive ());
<   Simulator::Schedule (m_currentEvent->GetEndTime () - Simulator::Now (), &WifiPhy::EndReceiveInterBss, this);
<   AbortCurrentReception (OBSS_PD_CCA_RESET);
< }
< 
< double
< WifiPhy::GetTxPowerForTransmission (WifiTxVector txVector) const
< {
<   NS_LOG_FUNCTION (this << m_powerRestricted);
<   if (!m_powerRestricted)
---
>   NS_LOG_FUNCTION (this << packet << txVector << +mpdutype << rxPowerW << rxDuration);
>   if (rxPowerW > m_edThresholdW) //checked here, no need to check in the payload reception (current implementation assumes constant rx power over the packet duration)
4773,4777c3623,3634
<       return GetPowerDbm (txVector.GetTxPowerLevel ());
<     }
<   else
<     {
<       if (txVector.GetNss () > 1)
---
>       AmpduTag ampduTag;
>       WifiPreamble preamble = txVector.GetPreambleType ();
>       if (preamble == WIFI_PREAMBLE_NONE && (m_mpdusNum == 0 || m_plcpSuccess == false))
>         {
>           m_plcpSuccess = false;
>           m_mpdusNum = 0;
>           NS_LOG_DEBUG ("drop packet because no PLCP preamble/header has been received");
>           NotifyRxDrop (packet);
>           MaybeCcaBusyDuration ();
>           return;
>         }
>       else if (preamble != WIFI_PREAMBLE_NONE && packet->PeekPacketTag (ampduTag) && m_mpdusNum == 0)
4779c3636,3638
<           return std::min (m_txPowerMaxMimo, GetPowerDbm (txVector.GetTxPowerLevel ()));
---
>           //received the first MPDU in an MPDU
>           m_mpdusNum = ampduTag.GetRemainingNbOfMpdus ();
>           m_rxMpduReferenceNumber++;
4781c3640
<       else
---
>       else if (preamble == WIFI_PREAMBLE_NONE && packet->PeekPacketTag (ampduTag) && m_mpdusNum > 0)
4783c3642,3661
<           return std::min (m_txPowerMaxSiso, GetPowerDbm (txVector.GetTxPowerLevel ()));
---
>           //received the other MPDUs that are part of the A-MPDU
>           if (ampduTag.GetRemainingNbOfMpdus () < (m_mpdusNum - 1))
>             {
>               NS_LOG_DEBUG ("Missing MPDU from the A-MPDU " << m_mpdusNum - ampduTag.GetRemainingNbOfMpdus ());
>               m_mpdusNum = ampduTag.GetRemainingNbOfMpdus ();
>             }
>           else
>             {
>               m_mpdusNum--;
>             }
>         }
>       else if (preamble != WIFI_PREAMBLE_NONE && packet->PeekPacketTag (ampduTag) && m_mpdusNum > 0)
>         {
>           NS_LOG_DEBUG ("New A-MPDU started while " << m_mpdusNum << " MPDUs from previous are lost");
>           m_mpdusNum = ampduTag.GetRemainingNbOfMpdus ();
>         }
>       else if (preamble != WIFI_PREAMBLE_NONE && m_mpdusNum > 0 )
>         {
>           NS_LOG_DEBUG ("Didn't receive the last MPDUs from an A-MPDU " << m_mpdusNum);
>           m_mpdusNum = 0;
4785,4786d3662
<     }
< }
4788,4791c3664,3669
< void
< WifiPhy::StartRx (Ptr<Event> event, double rxPowerW)
< {
<   NS_LOG_FUNCTION (this << *event << rxPowerW);
---
>       NS_LOG_DEBUG ("sync to signal (power=" << rxPowerW << "W)");
>       m_currentEvent = event;
>       m_state->SwitchToRx (rxDuration);
>       NS_ASSERT (m_endPlcpRxEvent.IsExpired ());
>       NotifyRxBegin (packet);
>       m_interference.NotifyRxStart ();
4793,4794c3671,3677
<   NS_LOG_DEBUG ("sync to signal (power=" << rxPowerW << "W)");
<   m_interference.NotifyRxStart (); //We need to notify it now so that it starts recording events
---
>       if (preamble != WIFI_PREAMBLE_NONE)
>         {
>           NS_ASSERT (m_endPlcpRxEvent.IsExpired ());
>           Time preambleAndHeaderDuration = CalculatePlcpPreambleAndHeaderDuration (txVector);
>           m_endPlcpRxEvent = Simulator::Schedule (preambleAndHeaderDuration, &WifiPhy::StartReceivePacket, this,
>                                                   packet, txVector, mpdutype, event);
>         }
4796,4811c3679,3681
<   if (!m_endPreambleDetectionEvent.IsRunning ())
<     {
<       Time startOfPreambleDuration = GetPreambleDetectionDuration ();
<       Time remainingRxDuration = event->GetDuration () - startOfPreambleDuration;
<       m_endPreambleDetectionEvent = Simulator::Schedule (startOfPreambleDuration, &WifiPhy::StartReceiveHeader, this, event);
<     }
<   else if ((m_frameCaptureModel != 0) && (rxPowerW > m_currentEvent->GetRxPowerW ()))
<     {
<       NS_LOG_DEBUG ("Received a stronger signal during preamble detection: drop current packet and switch to new packet");
<       NotifyRxDrop (m_currentEvent->GetPsdu (), PREAMBLE_DETECTION_PACKET_SWITCH);
<       m_interference.NotifyRxEnd ();
<       m_endPreambleDetectionEvent.Cancel ();
<       m_interference.NotifyRxStart ();
<       Time startOfPreambleDuration = GetPreambleDetectionDuration ();
<       Time remainingRxDuration = event->GetDuration () - startOfPreambleDuration;
<       m_endPreambleDetectionEvent = Simulator::Schedule (startOfPreambleDuration, &WifiPhy::StartReceiveHeader, this, event);
---
>       NS_ASSERT (m_endRxEvent.IsExpired ());
>       m_endRxEvent = Simulator::Schedule (rxDuration, &WifiPhy::EndReceive, this,
>                                           packet, preamble, mpdutype, event);
4815,4817c3685,3689
<       NS_LOG_DEBUG ("Drop packet because RX is already decoding preamble");
<       NotifyRxDrop (event->GetPsdu (), BUSY_DECODING_PREAMBLE);
<       return;
---
>       NS_LOG_DEBUG ("drop packet because signal power too Small (" <<
>                     rxPowerW << "<" << m_edThresholdW << ")");
>       NotifyRxDrop (packet);
>       m_plcpSuccess = false;
>       MaybeCcaBusyDuration ();
4819d3690
<   m_currentEvent = event;
4827a3699,3722
> }
> 
> std::ostream& operator<< (std::ostream& os, WifiPhyState state)
> {
>   switch (state)
>     {
>     case WifiPhyState::IDLE:
>       return (os << "IDLE");
>     case WifiPhyState::CCA_BUSY:
>       return (os << "CCA_BUSY");
>     case WifiPhyState::TX:
>       return (os << "TX");
>     case WifiPhyState::RX:
>       return (os << "RX");
>     case WifiPhyState::SWITCHING:
>       return (os << "SWITCHING");
>     case WifiPhyState::SLEEP:
>       return (os << "SLEEP");
>     case WifiPhyState::OFF:
>       return (os << "OFF");
>     default:
>       NS_FATAL_ERROR ("Invalid WifiPhy state");
>       return (os << "INVALID");
>     }
diff ../../NS3-WiGig/src/wifi/model/wifi-phy.h ../../ns-3-dev-git/src/wifi/model/wifi-phy.h
26,27d25
< #include "ns3/deprecated.h"
< #include "ns3/error-model.h"
32d29
< #include "wigig-data-types.h"
45d41
< class PreambleDetectionModel;
48,126d43
< class WifiPsdu;
< class WifiPpdu;
< 
< /**
<  * Enumeration of the possible reception failure reasons.
<  */
< enum WifiPhyRxfailureReason
< {
<   UNKNOWN = 0,
<   UNSUPPORTED_SETTINGS,
<   CHANNEL_SWITCHING,
<   RXING,
<   TXING,
<   SLEEPING,
<   BUSY_DECODING_PREAMBLE,
<   PREAMBLE_DETECT_FAILURE,
<   RECEPTION_ABORTED_BY_TX,
<   L_SIG_FAILURE,
<   SIG_A_FAILURE,
<   PREAMBLE_DETECTION_PACKET_SWITCH,
<   FRAME_CAPTURE_PACKET_SWITCH,
<   OBSS_PD_CCA_RESET,
<   //// WIGIG ////
<   DMG_HEADER_FAILURE,
<   ALLOCATION_ENDED
<   //// WIGIG ////
< };
< 
< 
< /**
< * \brief Stream insertion operator.
< *
< * \param os the stream
< * \param reason the failure reason
< * \returns a reference to the stream
< */
< inline std::ostream& operator<< (std::ostream& os, WifiPhyRxfailureReason reason)
< {
<   switch (reason)
<     {
<     case UNSUPPORTED_SETTINGS:
<       return (os << "UNSUPPORTED_SETTINGS");
<     case CHANNEL_SWITCHING:
<       return (os << "CHANNEL_SWITCHING");
<     case RXING:
<       return (os << "RXING");
<     case TXING:
<       return (os << "TXING");
<     case SLEEPING:
<       return (os << "SLEEPING");
<     case BUSY_DECODING_PREAMBLE:
<       return (os << "BUSY_DECODING_PREAMBLE");
<     case PREAMBLE_DETECT_FAILURE:
<       return (os << "PREAMBLE_DETECT_FAILURE");
<     case RECEPTION_ABORTED_BY_TX:
<       return (os << "RECEPTION_ABORTED_BY_TX");
<     case L_SIG_FAILURE:
<       return (os << "L_SIG_FAILURE");
<     case SIG_A_FAILURE:
<       return (os << "SIG_A_FAILURE");
<     case PREAMBLE_DETECTION_PACKET_SWITCH:
<       return (os << "PREAMBLE_DETECTION_PACKET_SWITCH");
<     case FRAME_CAPTURE_PACKET_SWITCH:
<       return (os << "FRAME_CAPTURE_PACKET_SWITCH");
<     case OBSS_PD_CCA_RESET:
<       return (os << "OBSS_PD_CCA_RESET");
<     //// WIGIG ////
<     case DMG_HEADER_FAILURE:
<       return (os << "DMG_HEADER_FAILURE");
<     case ALLOCATION_ENDED:
<       return (os << "ALLOCATION_ENDED");
<     //// WIGIG ////
<     case UNKNOWN:
<     default:
<       NS_FATAL_ERROR ("Unknown reason");
<       return (os << "UNKNOWN");
<     }
< }
< 
142,148d58
< /// Parameters for receive HE preamble
< struct HePreambleParameters
< {
<   double rssiW; ///< RSSI in W
<   uint8_t bssColor; ///< BSS color
< };
< 
167,173d76
<    * Return the WifiPhyStateHelper of this PHY
<    *
<    * \return the WifiPhyStateHelper of this PHY
<    */
<   Ptr<WifiPhyStateHelper> GetState (void) const;
< 
<   /**
205c108
<    * Start receiving the PHY preamble of a PPDU (i.e. the first bit of the preamble has arrived).
---
>    * Starting receiving the plcp of a packet (i.e. the first bit of the preamble has arrived).
207c110
<    * \param ppdu the arriving PPDU
---
>    * \param packet the arriving packet
208a112
>    * \param rxDuration the duration needed for the reception of the packet
210,231c114,116
<   void StartReceivePreamble (Ptr<WifiPpdu> ppdu, double rxPowerW);
< 
<   /**
<    * Start receiving the PHY header of a PPDU (i.e. after the end of receiving the preamble).
<    *
<    * \param event the event holding incoming PPDU's information
<    */
<   virtual void StartReceiveHeader (Ptr<Event> event);
< 
<   /**
<    * Continue receiving the PHY header of a PPDU (i.e. after the end of receiving the non-HT header part).
<    *
<    * \param event the event holding incoming PPDU's information
<    */
<   virtual void ContinueReceiveHeader (Ptr<Event> event);
< 
<   /**
<    * Start receiving the PSDU (i.e. the first symbol of the PSDU has arrived).
<    *
<    * \param event the event holding incoming PPDU's information
<    */
<   void StartReceivePayload (Ptr<Event> event);
---
>   void StartReceivePreambleAndHeader (Ptr<Packet> packet,
>                                       double rxPowerW,
>                                       Time rxDuration);
234c119
<    * The last symbol of the PPDU has arrived.
---
>    * Starting receiving the payload of a packet (i.e. the first bit of the packet has arrived).
236c121,124
<    * \param event the corresponding event of the first time the packet arrives (also storing packet and TxVector information)
---
>    * \param packet the arriving packet
>    * \param txVector the TXVECTOR of the arriving packet
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::MpduType.
>    * \param event the corresponding event of the first time the packet arrives
238c126,129
<   void EndReceive (Ptr<Event> event);
---
>   void StartReceivePacket (Ptr<Packet> packet,
>                            WifiTxVector txVector,
>                            MpduType mpdutype,
>                            Ptr<Event> event);
241c132
<    * Reset PHY at the end of the packet under reception after it has failed the PHY header.
---
>    * The last bit of the packet has arrived.
243,249c134,137
<    * \param event the corresponding event of the first time the packet arrives (also storing packet and TxVector information)
<    */
<   void ResetReceive (Ptr<Event> event);
< 
<   /**
<    * For HE receptions only, check and possibly modify the transmit power restriction state at
<    * the end of PPDU reception.
---
>    * \param packet the packet that the last bit has arrived
>    * \param preamble the preamble of the arriving packet
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::MpduType.
>    * \param event the corresponding event of the first time the packet arrives
251c139
<   void EndReceiveInterBss (void);
---
>   void EndReceive (Ptr<Packet> packet, WifiPreamble preamble, MpduType mpdutype, Ptr<Event> event);
254,256c142,144
<    * \param psdu the PSDU to send
<    * \param txVector the TXVECTOR that has TX parameters such as mode, the transmission mode to use to send
<    *        this PSDU, and txPowerLevel, a power level to use to send the whole PPDU. The real transmission
---
>    * \param packet the packet to send
>    * \param txVector the TXVECTOR that has tx parameters such as mode, the transmission mode to use to send
>    *        this packet, and txPowerLevel, a power level to use to send this packet. The real transmission
257a146
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::MpduType.
259c148
<   virtual void Send (Ptr<const WifiPsdu> psdu, WifiTxVector txVector);
---
>   void SendPacket (Ptr<const Packet> packet, WifiTxVector txVector, MpduType mpdutype = NORMAL_MPDU);
262,267c151,155
<    * \param ppdu the PPDU to send
<    */
<   virtual void StartTx (Ptr<WifiPpdu> ppdu) = 0;
<   //// WIGIG ////
<   /**
<    * End current allocation period.
---
>    * \param packet the packet to send
>    * \param txVector the TXVECTOR that has tx parameters such as mode, the transmission mode to use to send
>    *        this packet, and txPowerLevel, a power level to use to send this packet. The real transmission
>    *        power is calculated as txPowerMin + txPowerLevel * (txPowerMax - txPowerMin) / nTxLevels
>    * \param txDuration duration of the transmission.
269,270c157
<   virtual void EndAllocationPeriod (void);
<   //// WIGIG ////
---
>   virtual void StartTx (Ptr<Packet> packet, WifiTxVector txVector, Time txDuration) = 0;
317,320d203
<   /**
<    * \return the current state of the PHY layer.
<    */
<   WifiPhyState GetPhyState (void) const;
335a219
> 
337c221,223
<    * Return the end time of the last received packet.
---
>    * \param size the number of bytes in the packet to send
>    * \param txVector the TXVECTOR used for the transmission of this packet
>    * \param frequency the channel center frequency (MHz)
339c225
<    * \return the end time of the last received packet
---
>    * \return the total amount of time this PHY will stay busy for the transmission of these bytes.
341,342c227
<   Time GetLastRxEndTime (void) const;
< 
---
>   Time CalculateTxDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency);
346a232,233
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::MpduType.
>    * \param incFlag this flag is used to indicate that the static variables need to be update or not. This function is called a couple of times for the same packet so static variables should not be increased each time.
350c237
<   static Time CalculateTxDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency);
---
>   Time CalculateTxDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype, uint8_t incFlag);
355c242
<    * \return the total amount of time this PHY will stay busy for the transmission of the PHY preamble and PHY header.
---
>    * \return the total amount of time this PHY will stay busy for the transmission of the PLCP preamble and PLCP header.
357,362c244,245
<   static Time CalculatePhyPreambleAndHeaderDuration (WifiTxVector txVector);
<   /**
<    *
<    * \return the preamble detection duration, which is the time correlation needs to detect the start of an incoming frame.
<    */
<   virtual Time GetPreambleDetectionDuration (void);
---
>   static Time CalculatePlcpPreambleAndHeaderDuration (WifiTxVector txVector);
> 
368c251
<   static Time GetPhyTrainingSymbolDuration (WifiTxVector txVector);
---
>   static Time GetPlcpTrainingSymbolDuration (WifiTxVector txVector);
371c254
<    *         in Mixed Format and Greenfield format PHY header
---
>    *         in Mixed Format and greenfield format PLCP header
373c256
<   static WifiMode GetHtPhyHeaderMode ();
---
>   static WifiMode GetHtPlcpHeaderMode ();
377c260
<   static WifiMode GetVhtPhyHeaderMode ();
---
>   static WifiMode GetVhtPlcpHeaderMode ();
381c264
<   static WifiMode GetHePhyHeaderMode ();
---
>   static WifiMode GetHePlcpHeaderMode ();
385c268
<    * \return the duration of the HT-SIG in Mixed Format and Greenfield format PHY header
---
>    * \return the duration of the HT-SIG in Mixed Format and greenfield format PLCP header
387c270
<   static Time GetPhyHtSigHeaderDuration (WifiPreamble preamble);
---
>   static Time GetPlcpHtSigHeaderDuration (WifiPreamble preamble);
391c274
<    * \return the duration of the SIG-A1 in PHY header
---
>    * \return the duration of the SIG-A1 in PLCP header
393c276
<   static Time GetPhySigA1Duration (WifiPreamble preamble);
---
>   static Time GetPlcpSigA1Duration (WifiPreamble preamble);
397c280
<    * \return the duration of the SIG-A2 in PHY header
---
>    * \return the duration of the SIG-A2 in PLCP header
399c282
<   static Time GetPhySigA2Duration (WifiPreamble preamble);
---
>   static Time GetPlcpSigA2Duration (WifiPreamble preamble);
403c286
<    * \return the duration of the SIG-B in PHY header
---
>    * \return the duration of the SIG-B in PLCP header
405c288
<   static Time GetPhySigBDuration (WifiPreamble preamble);
---
>   static Time GetPlcpSigBDuration (WifiPreamble preamble);
409c292
<    * \return the WifiMode used for the transmission of the PHY header
---
>    * \return the WifiMode used for the transmission of the PLCP header
411c294
<   static WifiMode GetPhyHeaderMode (WifiTxVector txVector);
---
>   static WifiMode GetPlcpHeaderMode (WifiTxVector txVector);
415c298
<    * \return the duration of the PHY header
---
>    * \return the duration of the PLCP header
417c300
<   static Time GetPhyHeaderDuration (WifiTxVector txVector);
---
>   static Time GetPlcpHeaderDuration (WifiTxVector txVector);
421c304
<    * \return the duration of the PHY preamble
---
>    * \return the duration of the PLCP preamble
423c306
<   static Time GetPhyPreambleDuration (WifiTxVector txVector);
---
>   static Time GetPlcpPreambleDuration (WifiTxVector txVector);
428d310
<    * \param mpdutype the type of the MPDU as defined in WifiPhy::MpduType.
432c314
<   static Time GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype = NORMAL_MPDU);
---
>   Time GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency);
438,444c320
<    * \param incFlag this flag is used to indicate that the variables need to be update or not
<    * This function is called a couple of times for the same packet so variables should not be increased each time.
<    * \param totalAmpduSize the total size of the previously transmitted MPDUs for the concerned A-MPDU.
<    * If incFlag is set, this parameter will be updated.
<    * \param totalAmpduNumSymbols the number of symbols previously transmitted for the MPDUs in the concerned A-MPDU,
<    * used for the computation of the number of symbols needed for the last MPDU.
<    * If incFlag is set, this parameter will be updated.
---
>    * \param incFlag this flag is used to indicate that the static variables need to be update or not. This function is called a couple of times for the same packet so static variables should not be increased each time
448,493c324
<   static Time GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype, bool incFlag, uint32_t &totalAmpduSize, double &totalAmpduNumSymbols);
< 
<   //// WIGIG ////
<   /**
<    * \param txVector the transmission parameters used for this packet
<    *
<    * \return the duration of the EDMG header A
<    */
<   static Time GetEDMG_HeaderA_Duration (WifiTxVector txVector);
<   /**
<    * \param txVector the transmission parameters used for this packet
<    *
<    * \return the duration of the EDMG preamble
<    */
<   static Time GetEDMGPreambleDuration (WifiTxVector txVector);
<   /**
<    * \param txVector the transmission parameters used for this packet
<    *
<    * \return the duration of the EDMG header B
<    */
<   static Time GetEDMG_HeaderB_Duration (WifiTxVector txVector);
<   //// WIGIG ////
< 
<   /**
<    * \param size the number of bytes in the packet to send
<    * \param txvector the transmission parameters used for this packet
<    * \param preamble the type of preamble to use for this packet.
<    *
<    * \return the number of bits in the PPDU.
<    */
<   uint64_t CaluclateTransmittedBits (uint32_t size, WifiTxVector txvector);
<   /**
<    * \return the duration of the last received packet.
<    */
<   Time GetLastRxDuration (void) const;
<   /**
<    * \return the duration of the last transmitted packet.
<    */
<   Time GetLastTxDuration (void) const;
< 
<   /**
<    * \param txVector the transmission parameters used for this packet
<    *
<    * \return the duration until the start of the packet
<    */
<   static Time GetStartOfPacketDuration (WifiTxVector txVector);
---
>   Time GetPayloadDuration (uint32_t size, WifiTxVector txVector, uint16_t frequency, MpduType mpdutype, uint8_t incFlag);
551,560d381
<   /**
<    * Check if the given MCS of the given modulation class is supported by the PHY.
<    *
<    * \param mc the modulation class
<    * \param mcs the MCS value
<    *
<    * \return true if the given mode is supported,
<    *         false otherwise
<    */
<   bool IsMcsSupported (WifiModulationClass mc, uint8_t mcs) const;
566,567c387,388
<    * \return the minimum SNR which is required to achieve
<    *          the requested BER for the specified transmission vector. (W/W)
---
>    * \return the minimum snr which is required to achieve
>    *          the requested ber for the specified transmission vector. (W/W)
578c399
<   * \return the membership selector whose index is specified.
---
>   * \return the memebership selector whose index is specified.
590c411
<   * \return the membership selector whose index is specified.
---
>   * \return the memebership selector whose index is specified.
615,655d435
<   /**
<    * Get the WifiMode object corresponding to the given MCS of the given
<    * modulation class.
<    *
<    * \param modulation the modulation class
<    * \param mcs the MCS value
<    *
<    * \return the WifiMode object corresponding to the given MCS of the given
<    *         modulation class
<    */
<   WifiMode GetMcs (WifiModulationClass modulation, uint8_t mcs) const;
<   /**
<    * Get the WifiMode object corresponding to the given MCS of the
<    * HT modulation class.
<    *
<    * \param mcs the MCS value
<    *
<    * \return the WifiMode object corresponding to the given MCS of the
<    *         HT modulation class
<    */
<   WifiMode GetHtMcs (uint8_t mcs) const;
<   /**
<    * Get the WifiMode object corresponding to the given MCS of the
<    * VHT modulation class.
<    *
<    * \param mcs the MCS value
<    *
<    * \return the WifiMode object corresponding to the given MCS of the
<    *         VHT modulation class
<    */
<   WifiMode GetVhtMcs (uint8_t mcs) const;
<   /**
<    * Get the WifiMode object corresponding to the given MCS of the
<    * HE modulation class.
<    *
<    * \param mcs the MCS value
<    *
<    * \return the WifiMode object corresponding to the given MCS of the
<    *         HE modulation class
<    */
<   WifiMode GetHeMcs (uint8_t mcs) const;
664c444
<    * This method may fail to take action if the PHY model determines that
---
>    * This method may fail to take action if the Phy model determines that
687,692d466
<   /**
<    * Configure the PHY-level parameters for different Wi-Fi standard.
<    *
<    * \param standard the Wi-Fi standard
<    */
<   virtual void DoConfigureStandard (void);
723c497
<    * A pair of a center Frequency (MHz) and a ChannelWidth (MHz)
---
>    * A pair of a center Frequency and a ChannelWidth
1282,1283c1056
<    * \param psdu the PSDU being transmitted
<    * \param txPowerW the transmit power in Watts
---
>    * \param packet the packet being transmitted
1285c1058
<   void NotifyTxBegin (Ptr<const WifiPsdu> psdu, double txPowerW);
---
>   void NotifyTxBegin (Ptr<const Packet> packet);
1290c1063
<    * \param psdu the PSDU being transmitted
---
>    * \param packet the packet that was transmitted
1292c1065
<   void NotifyTxEnd (Ptr<const WifiPsdu> psdu);
---
>   void NotifyTxEnd (Ptr<const Packet> packet);
1297c1070
<    * \param psdu the PSDU being transmitted
---
>    * \param packet the packet that was failed to transmitted
1299c1072
<   void NotifyTxDrop (Ptr<const WifiPsdu> psdu);
---
>   void NotifyTxDrop (Ptr<const Packet> packet);
1304c1077
<    * \param psdu the PSDU being transmitted
---
>    * \param packet the packet being received
1306c1079
<   void NotifyRxBegin (Ptr<const WifiPsdu> psdu);
---
>   void NotifyRxBegin (Ptr<const Packet> packet);
1311c1084
<    * \param psdu the PSDU being transmitted
---
>    * \param packet the packet received
1313c1086
<   void NotifyRxEnd (Ptr<const WifiPsdu> psdu);
---
>   void NotifyRxEnd (Ptr<const Packet> packet);
1318,1319c1091
<    * \param psdu the PSDU being transmitted
<    * \param reason the reason the packet was dropped
---
>    * \param packet the packet that was not successfully received
1321c1093
<   void NotifyRxDrop (Ptr<const WifiPsdu> psdu, WifiPhyRxfailureReason reason);
---
>   void NotifyRxDrop (Ptr<const Packet> packet);
1324c1096
<    * Public method used to fire a MonitorSniffer trace for a wifi PSDU being received.
---
>    * Public method used to fire a MonitorSniffer trace for a wifi packet being received.
1326,1328d1097
<    * This method will extract all MPDUs if packet is an A-MPDU and will fire tracedCallback.
<    * The A-MPDU reference number (RX side) is set within the method. It must be a different value
<    * for each A-MPDU but the same for each subframe within one A-MPDU.
1330c1099
<    * \param psdu the PSDU being received
---
>    * \param packet the packet being received
1338c1107,1109
<    * \param txVector the TXVECTOR that holds RX parameters
---
>    * \param txVector the TXVECTOR that holds rx parameters
>    * \param aMpdu the type of the packet (0 is not A-MPDU, 1 is a MPDU that is part of an A-MPDU and 2 is the last MPDU in an A-MPDU)
>    *        and the A-MPDU reference number (must be a different value for each A-MPDU but the same for each subframe within one A-MPDU)
1340d1110
<    * \param statusPerMpdu reception status per MPDU
1342c1112
<   void NotifyMonitorSniffRx (Ptr<const WifiPsdu> psdu,
---
>   void NotifyMonitorSniffRx (Ptr<const Packet> packet,
1345,1346c1115,1116
<                              SignalNoiseDbm signalNoise,
<                              std::vector<bool> statusPerMpdu);
---
>                              MpduInfo aMpdu,
>                              SignalNoiseDbm signalNoise);
1360c1130
<    * \param txVector the TXVECTOR that holds RX parameters
---
>    * \param txVector the TXVECTOR that holds rx parameters
1374c1144
<    * Public method used to fire a MonitorSniffer trace for a wifi PSDU being transmitted.
---
>    * Public method used to fire a MonitorSniffer trace for a wifi packet being transmitted.
1376,1378d1145
<    * This method will extract all MPDUs if packet is an A-MPDU and will fire tracedCallback.
<    * The A-MPDU reference number (RX side) is set within the method. It must be a different value
<    * for each A-MPDU but the same for each subframe within one A-MPDU.
1380c1147
<    * \param psdu the PSDU being received
---
>    * \param packet the packet being transmitted
1383c1150,1152
<    * \param txVector the TXVECTOR that holds TX parameters
---
>    * \param txVector the TXVECTOR that holds tx parameters
>    * \param aMpdu the type of the packet (0 is not A-MPDU, 1 is a MPDU that is part of an A-MPDU and 2 is the last MPDU in an A-MPDU)
>    *        and the A-MPDU reference number (must be a different value for each A-MPDU but the same for each subframe within one A-MPDU)
1385c1154
<   void NotifyMonitorSniffTx (Ptr<const WifiPsdu> psdu,
---
>   void NotifyMonitorSniffTx (Ptr<const Packet> packet,
1387c1156,1157
<                              WifiTxVector txVector);
---
>                              WifiTxVector txVector,
>                              MpduInfo aMpdu);
1395c1165
<    * \param txVector the TXVECTOR that holds TX parameters
---
>    * \param txVector the TXVECTOR that holds tx parameters
1407,1438d1176
<    * TracedCallback signature for PSDU transmit events.
<    *
<    * \param psdu the PSDU being transmitted
<    * \param txVector the TXVECTOR holding the TX parameters
<    * \param txPowerW the transmit power in Watts
<    */
<   typedef void (* PsduTxBeginCallback)(Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW);
< 
<   /**
<    * Public method used to fire a EndOfHePreamble trace once both HE SIG fields have been received, as well as training fields.
<    *
<    * \param params the HE preamble parameters
<    */
<   void NotifyEndOfHePreamble (HePreambleParameters params);
< 
<   /**
<    * TracedCallback signature for end of HE-SIG-A events.
<    *
<    *
<    * \param params the HE preamble parameters
<    */
<   typedef void (* EndOfHePreambleCallback)(HePreambleParameters params);
< 
<   /**
<    * TracedCallback signature for start of PSDU reception events.
<    *
<    * \param txVector the TXVECTOR decoded from the PHY header
<    * \param psduDuration the duration of the PSDU
<    */
<   typedef void (* PhyRxPayloadBeginTracedCallback)(WifiTxVector txVector, Time psduDuration);
< 
<   /**
1451c1189
<    * this threshold (dBm) to allow the PHY layer to detect the signal.
---
>    * this threshold (dbm) to allow the PHY layer to detect the signal.
1454,1455d1191
<    *
<    * \deprecated
1459,1461c1195
<    * Sets the receive sensitivity threshold (dBm).
<    * The energy of a received signal should be higher than
<    * this threshold to allow the PHY layer to detect the signal.
---
>    * Return the energy detection threshold (dBm).
1463c1197
<    * \param threshold the receive sensitivity threshold in dBm
---
>    * \return the energy detection threshold in dBm
1465,1471c1199
<   void SetRxSensitivity (double threshold);
<   /**
<    * Return the receive sensitivity threshold (dBm).
<    *
<    * \return the receive sensitivity threshold in dBm
<    */
<   double GetRxSensitivity (void) const;
---
>   double GetEdThreshold (void) const;
1479c1207
<   void SetCcaEdThreshold (double threshold);
---
>   void SetCcaMode1Threshold (double threshold);
1485c1213
<   double GetCcaEdThreshold (void) const;
---
>   double GetCcaMode1Threshold (void) const;
1493,1498d1220
<    * Return the RX noise figure (dBm).
<    *
<    * \return the RX noise figure in dBm
<    */
<   double GetRxNoiseFigure (void) const;
<   /**
1631,1632d1352
<    *
<    * \deprecated
1639,1640d1358
<    *
<    * \deprecated
1645,1646d1362
<    *
<    * \deprecated
1651,1652d1366
<    *
<    * \deprecated
1655a1370,1392
>    * Enable or disable LDPC.
>    * \param ldpc Enable or disable LDPC
>    */
>   void SetLdpc (bool ldpc);
>   /**
>    * Return if LDPC is supported.
>    *
>    * \return true if LDPC is supported, false otherwise
>    */
>   bool GetLdpc (void) const;
>   /**
>    * Enable or disable STBC.
>    *
>    * \param stbc Enable or disable STBC
>    */
>   void SetStbc (bool stbc);
>   /**
>    * Return whether STBC is supported.
>    *
>    * \return true if STBC is supported, false otherwise
>    */
>   bool GetStbc (void) const;
>   /**
1659,1660d1395
<    *
<    * \deprecated
1667,1668d1401
<    *
<    * \deprecated
1672c1405
<    * Enable or disable short PHY preamble.
---
>    * Enable or disable short PLCP preamble.
1674c1407
<    * \param preamble sets whether short PHY preamble is supported or not
---
>    * \param preamble sets whether short PLCP preamble is supported or not
1676c1409
<   void SetShortPhyPreambleSupported (bool preamble);
---
>   void SetShortPlcpPreambleSupported (bool preamble);
1678c1411
<    * Return whether short PHY preamble is supported.
---
>    * Return whether short PLCP preamble is supported.
1680c1413
<    * \returns if short PHY preamble is supported or not
---
>    * \returns if short PLCP preamble is supported or not
1682c1415
<   bool GetShortPhyPreambleSupported (void) const;
---
>   bool GetShortPlcpPreambleSupported (void) const;
1691,1702d1423
<    * Attach a receive ErrorModel to the WifiPhy.
<    *
<    * The WifiPhy may optionally include an ErrorModel in
<    * the packet receive chain. The error model is additive
<    * to any modulation-based error model based on SNR, and
<    * is typically used to force specific packet losses or
<    * for testing purposes.
<    *
<    * \param em Pointer to the ErrorModel.
<    */
<   void SetPostReceptionErrorModel (const Ptr<ErrorModel> em);
<   /**
1709,1714d1429
<    * Sets the preamble detection model.
<    *
<    * \param preambleDetectionModel the preamble detection model
<    */
<   void SetPreambleDetectionModel (const Ptr<PreambleDetectionModel> preambleDetectionModel);
<   /**
1722c1437
<    * \return the channel width in MHz
---
>    * \return the channel width
1726c1441
<    * \param channelWidth the channel width (in MHz)
---
>    * \param channelwidth channel width
1728c1443
<   virtual void SetChannelWidth (uint16_t channelWidth);
---
>   virtual void SetChannelWidth (uint16_t channelwidth);
1730c1445
<    * \param width the channel width (in MHz) to support
---
>    * \param channelwidth channel width (in MHz) to support
1732c1447
<   void AddSupportedChannelWidth (uint16_t width);
---
>   void AddSupportedChannelWidth (uint16_t channelwidth);
1748,1771d1462
<   /**
<    * Reset PHY to IDLE, with some potential TX power restrictions for the next transmission.
<    *
<    * \param powerRestricted flag whether the transmit power is restricted for the next transmission
<    * \param txPowerMaxSiso the SISO transmit power restriction for the next transmission in dBm
<    * \param txPowerMaxMimo the MIMO transmit power restriction for the next transmission in dBm
<    */
<   void ResetCca (bool powerRestricted, double txPowerMaxSiso = 0, double txPowerMaxMimo = 0);
<   /**
<    * Compute the transmit power (in dBm) for the next transmission.
<    *
<    * \param txVector the TXVECTOR
<    * \return the transmit power in dBm for the next transmission
<    */
<   double GetTxPowerForTransmission (WifiTxVector txVector) const;
<   /**
<    * Notify the PHY that an access to the channel was requested.
<    * This is typically called by the channel access manager to
<    * to notify the PHY about an ongoing transmission.
<    * The PHY will use this information to determine whether
<    * it should use power restriction as imposed by OBSS_PD SR.
<    */
<   void NotifyChannelAccessRequested (void);
< 
1793c1484
<    * \param frequency frequency to try to switch to in MHz
---
>    * \param frequency frequency to try to switch to
1800c1491
<    * Check if PHY state should move to CCA busy state based on current
---
>    * Check if Phy state should move to CCA busy state based on current
1803c1494
<    * class is higher than the CcaEdThreshold
---
>    * class is higher than the CcaMode1Threshold
1806,1815d1496
<   /**
<    * Due to newly arrived signal, the current reception cannot be continued and has to be aborted
<    * \param reason the reason the reception is aborted
<    *
<    */
<   void AbortCurrentReception (WifiPhyRxfailureReason reason);
<   /**
<    * Eventually switch to CCA busy
<    */
<   void MaybeCcaBusyDuration (void);
1820a1502,1503
>   uint16_t m_mpdusNum;                 //!< carries the number of expected mpdus that are part of an A-MPDU
>   bool m_plcpSuccess;                  //!< Flag if the PLCP of the packet or the first MPDU in an A-MPDU has been received
1824,1831c1507,1508
<   EventId m_endRxEvent;                //!< the end of receive event
<   EventId m_endPhyRxEvent;             //!< the end of PHY receive event
<   EventId m_endPreambleDetectionEvent; //!< the end of preamble detection event
< 
<   EventId m_endTxEvent;                //!< the end of transmit event
< 
<   Time m_txDuration;                   //!< Total time spent in sending packets with their preamble.
<   Time m_rxDuration;                   //!< Duration of the last received packet.
---
>   EventId m_endRxEvent;                //!< the end reeive event
>   EventId m_endPlcpRxEvent;            //!< the end PLCP receive event
1833,1879c1510
<   /**
<    * This vector holds the set of transmission modes that this
<    * WifiPhy(-derived class) can support. In conversation we call this
<    * the DeviceRateSet (not a term you'll find in the standard), and
<    * it is a superset of standard-defined parameters such as the
<    * OperationalRateSet, and the BSSBasicRateSet (which, themselves,
<    * have a superset/subset relationship).
<    *
<    * Mandatory rates relevant to this WifiPhy can be found by
<    * iterating over this vector looking for WifiMode objects for which
<    * WifiMode::IsMandatory() is true.
<    *
<    * A quick note is appropriate here (well, here is as good a place
<    * as any I can find)...
<    *
<    * In the standard there is no text that explicitly precludes
<    * production of a device that does not support some rates that are
<    * mandatory (according to the standard) for PHYs that the device
<    * happens to fully or partially support.
<    *
<    * This approach is taken by some devices which choose to only support,
<    * for example, 6 and 9 Mbps ERP-OFDM rates for cost and power
<    * consumption reasons (i.e., these devices don't need to be designed
<    * for and waste current on the increased linearity requirement of
<    * higher-order constellations when 6 and 9 Mbps more than meet their
<    * data requirements). The wording of the standard allows such devices
<    * to have an OperationalRateSet which includes 6 and 9 Mbps ERP-OFDM
<    * rates, despite 12 and 24 Mbps being "mandatory" rates for the
<    * ERP-OFDM PHY.
<    *
<    * Now this doesn't actually have any impact on code, yet. It is,
<    * however, something that we need to keep in mind for the
<    * future. Basically, the key point is that we can't be making
<    * assumptions like "the Operational Rate Set will contain all the
<    * mandatory rates".
<    */
<   WifiModeList m_deviceRateSet;
<   WifiModeList m_deviceMcsSet; //!< the device MCS set
< 
<   Ptr<Event> m_currentEvent; //!< Hold the current event
<   Ptr<WifiRadioEnergyModel> m_wifiRadioEnergyModel; //!< Wifi radio energy model
<   Ptr<FrameCaptureModel> m_frameCaptureModel; //!< Frame capture model
< 
<   Time m_lastTxDuration;
<   bool m_isConstructed;                     //!< true when ready to set frequency
< 
< protected:
---
> private:
1918c1549
<    * supported rates for Holland.
---
>    * supported rates for holland.
1937c1568
<    * Configure the device MCS set with the appropriate HtMcs modes for
---
>    * Configure the device Mcs set with the appropriate HtMcs modes for
1942,1951d1572
<    * Add the given MCS to the device MCS set.
<    *
<    * \param mode the MCS to add to the device MCS set
<    */
<   void PushMcs (WifiMode mode);
<   /**
<    * Rebuild the mapping of MCS values to indices in the device MCS set.
<    */
<   void RebuildMcsMap (void);
<   /**
1971,1972c1592,1593
<    * \param frequency The center frequency to use in MHz
<    * \param width The channel width to use in MHz
---
>    * \param frequency The center frequency to use
>    * \param width The channel width to use
1985c1606
<    * Starting receiving the PPDU after having detected the medium is idle or after a reception switch.
---
>    * Due to newly arrived signal, the current reception cannot be continued and has to be aborted
1987,1988d1607
<    * \param event the event holding incoming PPDU's information
<    * \param rxPowerW the receive power in W
1990c1609,1610
<   virtual void StartRx (Ptr<Event> event, double rxPowerW);
---
>   void AbortCurrentReception (void);
> 
1992,1999c1612
<    * Get the reception status for the provided MPDU and notify.
<    *
<    * \param psdu the arriving MPDU formatted as a PSDU
<    * \param event the event holding incoming PPDU's information
<    * \param relativeMpduStart the relative start time of the MPDU within the A-MPDU. 0 for normal MPDUs
<    * \param mpduDuration the duration of the MPDU
<    *
<    * \return information on MPDU reception: status, signal power (dBm), and noise power (in dBm)
---
>    * Eventually switch to CCA busy
2001,2004c1614
<   std::pair<bool, SignalNoiseDbm> GetReceptionStatus (Ptr<const WifiPsdu> psdu,
<                                                       Ptr<Event> event,
<                                                       Time relativeMpduStart,
<                                                       Time mpduDuration);
---
>   void MaybeCcaBusyDuration (void);
2007,2008c1617
<    * The trace source fired when a packet begins the transmission process on
<    * the medium.
---
>    * Starting receiving the packet after having detected the medium is idle or after a reception switch.
2010c1619,1624
<    * \see class CallBackTraceSource
---
>    * \param packet the arriving packet
>    * \param txVector the TXVECTOR of the arriving packet
>    * \param mpdutype the type of the MPDU as defined in WifiPhy::MpduType.
>    * \param rxPowerW the receive power in W
>    * \param rxDuration the duration needed for the reception of the packet
>    * \param event the corresponding event of the first time the packet arrives
2012c1626,1632
<   TracedCallback<Ptr<const Packet>, double > m_phyTxBeginTrace;
---
>   void StartRx (Ptr<Packet> packet,
>                 WifiTxVector txVector,
>                 MpduType mpdutype,
>                 double rxPowerW,
>                 Time rxDuration,
>                 Ptr<Event> event);
> 
2014c1634
<    * The trace source fired when a PSDU begins the transmission process on
---
>    * The trace source fired when a packet begins the transmission process on
2019c1639
<   TracedCallback<Ptr<const WifiPsdu>, WifiTxVector, double /* TX power (W) */> m_phyTxPsduBeginTrace;
---
>   TracedCallback<Ptr<const Packet> > m_phyTxBeginTrace;
2030c1650
<    * The trace source fired when the PHY layer drops a packet as it tries
---
>    * The trace source fired when the phy layer drops a packet as it tries
2046,2061d1665
<    * The trace source fired when the reception of the PHY payload (PSDU) begins.
<    *
<    * This traced callback models the behavior of the PHY-RXSTART
<    * primitive which is launched upon correct decoding of
<    * the PHY header and support of modes within.
<    * We thus assume that it is sent just before starting
<    * the decoding of the payload, since it's there that
<    * support of the header's content is checked. In addition,
<    * it's also at that point that the correct decoding of
<    * HT-SIG, VHT-SIGs, and HE-SIGs are checked.
<    *
<    * \see class CallBackTraceSource
<    */
<   TracedCallback<WifiTxVector, Time> m_phyRxPayloadBeginTrace;
< 
<   /**
2070c1674
<    * The trace source fired when the PHY layer drops a packet it has received.
---
>    * The trace source fired when the phy layer drops a packet it has received.
2074c1678
<   TracedCallback<Ptr<const Packet>, WifiPhyRxfailureReason > m_phyRxDropTrace;
---
>   TracedCallback<Ptr<const Packet> > m_phyRxDropTrace;
2077c1681
<    * A trace source that emulates a Wi-Fi device in monitor mode
---
>    * A trace source that emulates a wifi device in monitor mode
2086c1690
<    *       const references because of their sizes.
---
>    * const  references because of their sizes.
2091c1695
<    * A trace source that emulates a Wi-Fi device in monitor mode
---
>    * A trace source that emulates a wifi device in monitor mode
2105c1709,1714
<    * A trace source that indicates the end of both HE SIG fields as well as training fields for received 802.11ax packets
---
>    * This vector holds the set of transmission modes that this
>    * WifiPhy(-derived class) can support. In conversation we call this
>    * the DeviceRateSet (not a term you'll find in the standard), and
>    * it is a superset of standard-defined parameters such as the
>    * OperationalRateSet, and the BSSBasicRateSet (which, themselves,
>    * have a superset/subset relationship).
2107c1716,1742
<    * \see class CallBackTraceSource
---
>    * Mandatory rates relevant to this WifiPhy can be found by
>    * iterating over this vector looking for WifiMode objects for which
>    * WifiMode::IsMandatory() is true.
>    *
>    * A quick note is appropriate here (well, here is as good a place
>    * as any I can find)...
>    *
>    * In the standard there is no text that explicitly precludes
>    * production of a device that does not support some rates that are
>    * mandatory (according to the standard) for PHYs that the device
>    * happens to fully or partially support.
>    *
>    * This approach is taken by some devices which choose to only support,
>    * for example, 6 and 9 Mbps ERP-OFDM rates for cost and power
>    * consumption reasons (i.e., these devices don't need to be designed
>    * for and waste current on the increased linearity requirement of
>    * higher-order constellations when 6 and 9 Mbps more than meet their
>    * data requirements). The wording of the standard allows such devices
>    * to have an OperationalRateSet which includes 6 and 9 Mbps ERP-OFDM
>    * rates, despite 12 and 24 Mbps being "mandatory" rates for the
>    * ERP-OFDM PHY.
>    *
>    * Now this doesn't actually have any impact on code, yet. It is,
>    * however, something that we need to keep in mind for the
>    * future. Basically, the key point is that we can't be making
>    * assumptions like "the Operational Rate Set will contain all the
>    * mandatory rates".
2109,2112c1744,1745
<   TracedCallback<HePreambleParameters> m_phyEndOfHePreambleTrace;
< 
<   /// Maps MCS values to indices in m_deviceMcsSet, for HT, VHT and HE modulation classes
<   std::map<WifiModulationClass, std::map<uint8_t /* MCS value */, uint8_t /* index */>> m_mcsIndexMap;
---
>   WifiModeList m_deviceRateSet;
>   WifiModeList m_deviceMcsSet; //!< the device MCS set
2116a1750
>   bool m_isConstructed;                     //!< true when ready to set frequency
2118c1752
<   uint16_t m_initialFrequency;              //!< Store frequency until initialization (MHz)
---
>   uint16_t m_initialFrequency;              //!< Store frequency until initialization
2120c1754
<   uint16_t m_channelWidth;                  //!< Channel width (MHz)
---
>   uint16_t m_channelWidth;                  //!< Channel width
2122,2123c1756,1757
<   double   m_rxSensitivityW;      //!< Receive sensitivity threshold in watts
<   double   m_ccaEdThresholdW;     //!< Clear channel assessment (CCA) threshold in watts
---
>   double   m_edThresholdW;        //!< Energy detection threshold in watts
>   double   m_ccaMode1ThresholdW;  //!< Clear channel assessment (CCA) threshold in watts
2130,2137c1764,1768
<   bool m_powerRestricted;        //!< Flag whether transmit power is restricted by OBSS PD SR
<   double m_txPowerMaxSiso;       //!< SISO maximum transmit power due to OBSS PD SR power restriction (dBm)
<   double m_txPowerMaxMimo;       //!< MIMO maximum transmit power due to OBSS PD SR power restriction (dBm)
<   bool m_channelAccessRequested; //!< Flag if channels access has been requested (used for OBSS_PD SR)
< 
<   bool     m_greenfield;         //!< Flag if GreenField format is supported (deprecated)
<   bool     m_shortGuardInterval; //!< Flag if HT/VHT short guard interval is supported (deprecated)
<   bool     m_shortPreamble;      //!< Flag if short PHY preamble is supported
---
>   bool     m_ldpc;               //!< Flag if LDPC is used
>   bool     m_stbc;               //!< Flag if STBC is used
>   bool     m_greenfield;         //!< Flag if GreenField format is supported
>   bool     m_shortGuardInterval; //!< Flag if HT/VHT short guard interval is supported
>   bool     m_shortPreamble;      //!< Flag if short PLCP preamble is supported
2139c1770
<   Time m_guardInterval; //!< Supported HE guard interval (deprecated)
---
>   Time m_guardInterval; //!< Supported HE guard interval
2146c1777
<   static ChannelToFrequencyWidthMap m_channelToFrequencyWidth;                               //!< the channel to frequency width map
---
>   static ChannelToFrequencyWidthMap m_channelToFrequencyWidth; //!< the channel to frequency width map
2148c1779
<   std::vector<uint16_t> m_supportedChannelWidthSet; //!< Supported channel width set (MHz)
---
>   std::vector<uint16_t> m_supportedChannelWidthSet; //!< Supported channel width
2152a1784,1785
>   uint32_t m_totalAmpduSize;     //!< Total size of the previously transmitted MPDUs in an A-MPDU, used for the computation of the number of symbols needed for the last MPDU in the A-MPDU
>   double m_totalAmpduNumSymbols; //!< Number of symbols previously transmitted for the MPDUs in an A-MPDU, used for the computation of the number of symbols needed for the last MPDU in the A-MPDU
2157,2159c1790,1792
<   Ptr<PreambleDetectionModel> m_preambleDetectionModel; //!< Preamble detection model
<   Ptr<ErrorModel> m_postReceptionErrorModel;            //!< Error model for receive packet events
<   Time m_timeLastPreambleDetected;                      //!< Record the time the last preamble was detected
---
>   Ptr<Event> m_currentEvent; //!< Hold the current event
>   Ptr<FrameCaptureModel> m_frameCaptureModel; //!< Frame capture model
>   Ptr<WifiRadioEnergyModel> m_wifiRadioEnergyModel; //!< Wifi radio energy model
2161c1794
<   Callback<void> m_capabilitiesChangedCallback;         //!< Callback when PHY capabilities changed
---
>   Callback<void> m_capabilitiesChangedCallback; //!< Callback when PHY capabilities changed
2162a1796,1802
> 
> /**
>  * \param os          output stream
>  * \param state       wifi state to stringify
>  * \return output stream
>  */
> std::ostream& operator<< (std::ostream& os, WifiPhyState state);
Only in ../../NS3-WiGig/src/wifi/model: wifi-phy-header.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-phy-header.h
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-listener.h ../../ns-3-dev-git/src/wifi/model/wifi-phy-listener.h
30c30
<  * \brief receive notifications about PHY events.
---
>  * \brief receive notifications about phy events.
70c70
<    * \param txPowerDbm the nominal TX power in dBm
---
>    * \param txPowerDbm the nominal tx power in dBm
76c76
<    * unless they have received a CCA busy report.
---
>    * unless they have received a cca busy report.
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-standard.h ../../ns-3-dev-git/src/wifi/model/wifi-phy-standard.h
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
19,20c18
<  * Authors: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
<  *          Hany Assasa <Hany.assasa@gmail.com>
---
>  * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>
54,57d51
<   /** PHY for 802.11ad (Clause 21) */
<   WIFI_PHY_STANDARD_80211ad,
<   /** PHY for 802.11ay (Clause 29) */
<   WIFI_PHY_STANDARD_80211ay,
66,75d59
< };
< 
< /**
<  * \ingroup wifi
<  * Identifies the TRN Field to appended to the end of the packet.
<  */
< enum PacketType {
<   TRN_R  = 0,
<   TRN_T  = 1,
<   TRN_RT = 2,
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-state.h ../../ns-3-dev-git/src/wifi/model/wifi-phy-state.h
25,26d24
< #include "ns3/fatal-error.h"
< 
62,92d59
< 
< /**
< * \brief Stream insertion operator.
< *
< * \param os the stream
< * \param state the state
< * \returns a reference to the stream
< */
< inline std::ostream& operator<< (std::ostream& os, WifiPhyState state)
< {
<   switch (state)
<     {
<     case IDLE:
<       return (os << "IDLE");
<     case CCA_BUSY:
<       return (os << "CCA_BUSY");
<     case TX:
<       return (os << "TX");
<     case RX:
<       return (os << "RX");
<     case SWITCHING:
<       return (os << "SWITCHING");
<     case SLEEP:
<       return (os << "SLEEP");
<     case OFF:
<       return (os << "OFF");
<     default:
<       NS_FATAL_ERROR ("Invalid state");
<       return (os << "INVALID");
<     }
< }
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-state-helper.cc ../../ns-3-dev-git/src/wifi/model/wifi-phy-state-helper.cc
28d27
< #include "wifi-psdu.h"
63c62,63
<   : m_sleeping (false),
---
>   : m_rxing (false),
>     m_sleeping (false),
168a169,170
>       retval = Seconds (0);
>       break;
169a172,174
>       NS_FATAL_ERROR ("Cannot determine when the device will wake up.");
>       retval = Seconds (0);
>       break;
170a176
>       NS_FATAL_ERROR ("Cannot determine when the device will be switched on.");
188,193d193
< Time
< WifiPhyStateHelper::GetLastRxEndTime (void) const
< {
<   return m_endRx;
< }
< 
209c209
<   else if (m_endRx > Simulator::Now ())
---
>   else if (m_rxing)
343,352c343
<       Time ccaBusyDuration = idleStart - ccaBusyStart;
<       if (ccaBusyDuration.IsStrictlyPositive ())
<         {
<           m_stateLogger (ccaBusyStart, ccaBusyDuration, WifiPhyState::CCA_BUSY);
<         }
<     }
<   Time idleDuration = now - idleStart;
<   if (idleDuration.IsStrictlyPositive ())
<     {
<       m_stateLogger (idleStart, idleDuration, WifiPhyState::IDLE);
---
>       m_stateLogger (ccaBusyStart, idleStart - ccaBusyStart, WifiPhyState::CCA_BUSY);
353a345
>   m_stateLogger (idleStart, now - idleStart, WifiPhyState::IDLE);
368a361
>       m_rxing = false;
397a391
>   NS_ASSERT (!m_rxing);
412c406
<       NS_FATAL_ERROR ("Invalid WifiPhy state " << GetState ());
---
>       NS_FATAL_ERROR ("Invalid WifiPhy state.");
415a410
>   m_rxing = true;
432a428
>       m_rxing = false;
465c461
< WifiPhyStateHelper::SwitchFromRxEndOk (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu)
---
> WifiPhyStateHelper::SwitchFromRxEndOk (Ptr<Packet> packet, double snr, WifiTxVector txVector)
467,471c463,464
<   NS_LOG_FUNCTION (this << *psdu << snr << txVector << statusPerMpdu.size () <<
<                    std::all_of(statusPerMpdu.begin(), statusPerMpdu.end(), [](bool v) { return v; })); //returns true if all true
<   NS_ASSERT (statusPerMpdu.size () != 0);
<   NS_ASSERT (m_endRx == Simulator::Now ());
<   m_rxOkTrace (psdu->GetPacket (), snr, txVector.GetMode (), txVector.GetPreambleType ());
---
>   NS_LOG_FUNCTION (this << packet << snr << txVector);
>   m_rxOkTrace (packet, snr, txVector.GetMode (), txVector.GetPreambleType ());
476c469
<       m_rxOkCallback (psdu, snr, txVector, statusPerMpdu);
---
>       m_rxOkCallback (packet, snr, txVector);
478d470
< }
480,491d471
< void
< WifiPhyStateHelper::SwitchFromRxEndError (Ptr<WifiPsdu> psdu, double snr)
< {
<   NS_LOG_FUNCTION (this << *psdu << snr);
<   NS_ASSERT (m_endRx == Simulator::Now ());
<   m_rxErrorTrace (psdu->GetPacket (), snr);
<   NotifyRxEndError ();
<   DoSwitchFromRx ();
<   if (!m_rxErrorCallback.IsNull ())
<     {
<       m_rxErrorCallback (psdu);
<     }
494,495d473
< //// WIGIG ////
< 
497c475
< WifiPhyStateHelper::ReportPsduRxOk (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu)
---
> WifiPhyStateHelper::SwitchFromRxEndError (Ptr<Packet> packet, double snr)
499,514c477,479
<   NS_LOG_FUNCTION (this << *psdu << snr << txVector << statusPerMpdu.size () <<
<                    std::all_of(statusPerMpdu.begin(), statusPerMpdu.end(), [](bool v) { return v; })); //returns true if all true
<   NS_ASSERT (statusPerMpdu.size () != 0);
<   m_rxOkTrace (psdu->GetPacket (), snr, txVector.GetMode (), txVector.GetPreambleType ());
<   if (!m_rxOkCallback.IsNull ())
<     {
<       m_rxOkCallback (psdu, snr, txVector, statusPerMpdu);
<     }
< }
< 
< void
< WifiPhyStateHelper::SwitchFromRxEndOk (void)
< {
<   NS_LOG_FUNCTION (this);
<   NS_ASSERT (m_endRx == Simulator::Now ());
<   NotifyRxEndOk ();
---
>   NS_LOG_FUNCTION (this << packet << snr);
>   m_rxErrorTrace (packet, snr);
>   NotifyRxEndError ();
516,522d480
< }
< 
< void
< WifiPhyStateHelper::ReportPsduEndError (Ptr<WifiPsdu> psdu, double snr)
< {
<   NS_LOG_FUNCTION (this << *psdu << snr);
<   m_rxErrorTrace (psdu->GetPacket (), snr);
525c483
<       m_rxErrorCallback (psdu);
---
>       m_rxErrorCallback (packet, snr);
530,539d487
< WifiPhyStateHelper::SwitchFromRxEndError (void)
< {
<   NS_LOG_FUNCTION (this);
<   NotifyRxEndOk ();
<   DoSwitchFromRx ();
< }
< 
< //// WIGIG ////
< 
< void
542a491,493
>   NS_ASSERT (IsStateRx ());
>   NS_ASSERT (m_rxing);
> 
546c497,498
<   m_endRx = Simulator::Now ();
---
>   m_rxing = false;
> 
554,557c506
<   if (GetState () != WifiPhyState::RX)
<     {
<       NotifyMaybeCcaBusyStart (duration);
<     }
---
>   NotifyMaybeCcaBusyStart (duration);
564,565d512
<     case WifiPhyState::RX:
<       return;
627c574,575
<   NotifyRxEndOk ();
---
>   NS_ASSERT (m_rxing);
>   m_endRx = Simulator::Now ();
629,631c577
<   m_endCcaBusy = Simulator::Now ();
<   NotifyMaybeCcaBusyStart (Seconds (0));
<   NS_ASSERT (IsStateIdle ());
---
>   NS_ASSERT (!IsStateRx ());
644a591
>       m_rxing = false;
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-state-helper.h ../../ns-3-dev-git/src/wifi/model/wifi-phy-state-helper.h
37d36
< class WifiPsdu;
40,47c39,42
<  * Callback if PSDU successfully received (i.e. if aggregate,
<  * it means that at least one MPDU of the A-MPDU was received,
<  * considering that the per-MPDU reception status is also provided).
<  *
<  * arg1: PSDU received successfully
<  * arg2: SNR of PSDU in linear scale
<  * arg3: TXVECTOR of PSDU
<  * arg4: vector of per-MPDU status of reception.
---
>  * arg1: packet received successfully
>  * arg2: snr of packet
>  * arg3: TXVECTOR of packet
>  * arg4: type of preamble used for packet.
49c44
< typedef Callback<void, Ptr<WifiPsdu>, double, WifiTxVector, std::vector<bool>> RxOkCallback;
---
> typedef Callback<void, Ptr<Packet>, double, WifiTxVector> RxOkCallback;
51,53c46,47
<  * Callback if PSDU unsuccessfully received
<  *
<  * arg1: PSDU received unsuccessfully
---
>  * arg1: packet received unsuccessfully
>  * arg2: snr of packet
55c49
< typedef Callback<void, Ptr<WifiPsdu>> RxErrorCallback;
---
> typedef Callback<void, Ptr<Packet>, double> RxErrorCallback;
76c70
<    * \param callback the RxOkCallback to set
---
>    * \param callback
82c76
<    * \param callback the RxErrorCallback to set
---
>    * \param callback
88c82
<    * \param listener the WifiPhyListener to register
---
>    * \param listener
94c88
<    * \param listener the WifiPhyListener to unregister
---
>    * \param listener
157,162d150
<   /**
<    * Return the time the last RX end.
<    *
<    * \return the time the last RX end.
<    */
<   Time GetLastRxEndTime (void) const;
169,170c157,158
<    * \param txPowerDbm the nominal TX power in dBm
<    * \param txVector the TX vector of the packet
---
>    * \param txPowerDbm the nominal tx power in dBm
>    * \param txVector the tx vector of the packet
185,202d172
<   /*
<    * Switch from RX after the reception was successful.
<    *
<    * \param psdu the successfully received PSDU
<    * \param snr the SNR of the received PSDU in linear scale
<    * \param txVector TXVECTOR of the PSDU
<    * \param statusPerMpdu reception status per MPDU
<    */
<   void SwitchFromRxEndOk (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu);
<   /**
<    * Switch from RX after the reception failed.
<    *
<    * \param psdu the PSDU that we failed to received
<    * \param snr the SNR of the received PSDU in linear scale
<    */
<   void SwitchFromRxEndError (Ptr<WifiPsdu> psdu, double snr);
< 
<   //// WIGIG ////
204c174
<    * Report correct reception of an PSDU and keep waiting for the TRN Field.
---
>    * Switch from RX after the reception was successful.
206c176
<    * \param psdu the successfully received PSDU
---
>    * \param packet the successfully received packet
209,213d178
<    * \param statusPerMpdu reception status per MPDU
<    */
<   void ReportPsduRxOk (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu);
<   /**
<    * Switch from RX after the reception was successful.
215c180
<   void SwitchFromRxEndOk (void);
---
>   void SwitchFromRxEndOk (Ptr<Packet> packet, double snr, WifiTxVector txVector);
217c182
<    * Report erroronous reception of PSDU and keep waiting for the TRN Field.
---
>    * Switch from RX after the reception failed.
219c184
<    * \param psdu the PSDU that we failed to received
---
>    * \param packet the packet that we failed to received
222,228c187
<   void ReportPsduEndError (Ptr<WifiPsdu> psdu, double snr);
<   /**
<    * Switch from RX after the reception failed.
<    */
<   void SwitchFromRxEndError (void);
<   //// WIGIG ////
< 
---
>   void SwitchFromRxEndError (Ptr<Packet> packet, double snr);
263c222
<    * \param [in] start Time when the \pname{state} started.
---
>    * \param [in] start Time when the \p state started.
265c224
<    *             the \pname{state}.
---
>    *             the \p state.
271c230
<    * TracedCallback signature for receive end OK event.
---
>    * TracedCallback signature for receive end ok event.
274c233
<    * \param [in] snr    The SNR of the received packet in linear scale.
---
>    * \param [in] snr    The SNR of the received packet.
284c243
<    * \param [in] snr          The SNR of the received packet in linear scale.
---
>    * \param [in] snr          The SNR of the received packet.
319c278
<    * \param txPowerDbm the nominal TX power in dBm
---
>    * \param txPowerDbm the nominal tx power in dBm
375c334
<   bool m_rxing;
---
>   bool m_rxing; ///< receiving
380c339
<   Time m_endCcaBusy; ///< end CCA busy
---
>   Time m_endCcaBusy; ///< endn CCA busy
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-tag.cc ../../ns-3-dev-git/src/wifi/model/wifi-phy-tag.cc
43c43
<   return 3;
---
>   return (sizeof (WifiTxVector) + 2 + 1);
49,50c49,50
<   i.WriteU8 (static_cast<uint8_t> (m_preamble));
<   i.WriteU8 (static_cast<uint8_t> (m_modulation));
---
>   i.Write ((uint8_t *)&m_wifiTxVector, sizeof (WifiTxVector));
>   i.WriteU16 (static_cast<uint16_t> (m_mpduType));
57,58c57,58
<   m_preamble = static_cast<WifiPreamble> (i.ReadU8 ());
<   m_modulation = static_cast<WifiModulationClass> (i.ReadU8 ());
---
>   i.Read ((uint8_t *)&m_wifiTxVector, sizeof (WifiTxVector));
>   m_mpduType = static_cast<MpduType> (i.ReadU16 ());
65c65
<   os << +m_preamble << " " << +m_modulation << " " << m_frameComplete;
---
>   os << m_wifiTxVector << " " << m_mpduType << " " << m_frameComplete;
72,74c72,74
< WifiPhyTag::WifiPhyTag (WifiPreamble preamble, WifiModulationClass modulation, uint8_t frameComplete)
<   : m_preamble (preamble),
<     m_modulation (modulation),
---
> WifiPhyTag::WifiPhyTag (WifiTxVector txVector, MpduType mpdutype, uint8_t frameComplete)
>   : m_wifiTxVector (txVector),
>     m_mpduType (mpdutype),
79,80c79,80
< WifiPreamble
< WifiPhyTag::GetPreambleType (void) const
---
> WifiTxVector
> WifiPhyTag::GetWifiTxVector (void) const
82c82
<   return m_preamble;
---
>   return m_wifiTxVector;
85,86c85,86
< WifiModulationClass
< WifiPhyTag::GetModulation (void) const
---
> MpduType
> WifiPhyTag::GetMpduType (void) const
88c88
<   return m_modulation;
---
>   return m_mpduType;
diff ../../NS3-WiGig/src/wifi/model/wifi-phy-tag.h ../../ns-3-dev-git/src/wifi/model/wifi-phy-tag.h
25,26c25,26
< #include "wifi-preamble.h"
< #include "wifi-mode.h"
---
> #include "wifi-mpdu-type.h"
> #include "wifi-tx-vector.h"
52,53c52,53
<    * \param preamble the preamble type
<    * \param modulation the modulation
---
>    * \param txVector the WifiTxVector
>    * \param mpdutype the mpduType
56c56
<   WifiPhyTag (WifiPreamble preamble, WifiModulationClass modulation, uint8_t frameComplete);
---
>   WifiPhyTag (WifiTxVector txVector, MpduType mpdutype, uint8_t frameComplete);
58,59c58,59
<    * Getter for preamble parameter
<    * \return the preamble type
---
>    * Getter for WifiTxVector parameter
>    * \return the WifiTxVector
61c61
<   WifiPreamble GetPreambleType (void) const;
---
>   WifiTxVector GetWifiTxVector (void) const;
63,64c63,64
<    * Getter for modulation parameter
<    * \return the modulation
---
>    * Getter for mpduType parameter
>    * \return mpduType the mpduType
66c66
<   WifiModulationClass GetModulation (void) const;
---
>   MpduType GetMpduType (void) const;
81,83c81,83
<   WifiPreamble m_preamble;          ///< preamble type
<   WifiModulationClass m_modulation; ///< modulation used for transmission
<   uint8_t m_frameComplete;          ///< Used to indicate that TX stopped sending before the end of the frame
---
>   WifiTxVector m_wifiTxVector; ///< wifi transmit vector
>   MpduType m_mpduType; ///< MPDU type
>   uint8_t m_frameComplete; ///< Used to indicate that TX stopped sending before the end of the frame
Only in ../../NS3-WiGig/src/wifi/model: wifi-ppdu.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-ppdu.h
diff ../../NS3-WiGig/src/wifi/model/wifi-preamble.h ../../ns-3-dev-git/src/wifi/model/wifi-preamble.h
24,25d23
< #include "ns3/fatal-error.h"
< 
38,47c36
<   WIFI_PREAMBLE_VHT_SU,
<   WIFI_PREAMBLE_VHT_MU,
<   //// WIGIG ////
<   WIFI_PREAMBLE_DMG_CTRL,
<   WIFI_PREAMBLE_DMG_SC,
<   WIFI_PREAMBLE_DMG_OFDM,
<   WIFI_PREAMBLE_EDMG_CTRL,
<   WIFI_PREAMBLE_EDMG_SC,
<   WIFI_PREAMBLE_EDMG_OFDM,
<   //// WIGIG ////
---
>   WIFI_PREAMBLE_VHT,
51c40,41
<   WIFI_PREAMBLE_HE_TB
---
>   WIFI_PREAMBLE_HE_TB,
>   WIFI_PREAMBLE_NONE
53,103d42
< 
< /**
< * \brief Stream insertion operator.
< *
< * \param os the stream
< * \param preamble the preamble
< * \returns a reference to the stream
< */
< inline std::ostream& operator<< (std::ostream& os, WifiPreamble preamble)
< {
<   switch (preamble)
<     {
<     //// WIGIG ////
<     case WIFI_PREAMBLE_DMG_CTRL:
<       return (os << "DMG_CTRL");
<     case WIFI_PREAMBLE_DMG_SC:
<       return (os << "DMG_SC");
<     case WIFI_PREAMBLE_DMG_OFDM:
<       return (os << "DMG_OFDM");
<     case WIFI_PREAMBLE_EDMG_CTRL:
<       return (os << "EDMG_CTRL");
<     case WIFI_PREAMBLE_EDMG_SC:
<       return (os << "EDMG_SC");
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       return (os << "EDMG_OFDM");
<       //// WIGIG ////
<     case WIFI_PREAMBLE_LONG:
<       return (os << "LONG");
<     case WIFI_PREAMBLE_SHORT:
<       return (os << "SHORT");
<     case WIFI_PREAMBLE_HT_MF:
<       return (os << "HT_MF");
<     case WIFI_PREAMBLE_HT_GF:
<       return (os << "HT_GF");
<     case WIFI_PREAMBLE_VHT_SU:
<       return (os << "VHT_SU");
<     case WIFI_PREAMBLE_VHT_MU:
<       return (os << "VHT_MU");
<     case WIFI_PREAMBLE_HE_SU:
<       return (os << "HE_SU");
<     case WIFI_PREAMBLE_HE_ER_SU:
<       return (os << "HE_ER_SU");
<     case WIFI_PREAMBLE_HE_MU:
<       return (os << "HE_MU");
<     case WIFI_PREAMBLE_HE_TB:
<       return (os << "HE_TB");
<     default:
<       NS_FATAL_ERROR ("Invalid preamble");
<       return (os << "INVALID");
<     }
< }
Only in ../../NS3-WiGig/src/wifi/model: wifi-psdu.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-psdu.h
diff ../../NS3-WiGig/src/wifi/model/wifi-radio-energy-model.cc ../../ns-3-dev-git/src/wifi/model/wifi-radio-energy-model.cc
54c54
<                    "The radio TX current in Ampere.",
---
>                    "The radio Tx current in Ampere.",
60c60
<                    "The radio RX current in Ampere.",
---
>                    "The radio Rx current in Ampere.",
77c77
<     .AddAttribute ("TxCurrentModel", "A pointer to the attached TX current model.",
---
>     .AddAttribute ("TxCurrentModel", "A pointer to the attached tx current model.",
100c100
<   // set callback for updating the TX current
---
>   // set callback for updating the tx current
128c128
<   NS_ASSERT (duration.IsPositive ()); // check if duration is valid
---
>   NS_ASSERT (duration.GetNanoSeconds () >= 0); // check if duration is valid
130a131
>   double energyToDecrease = 0.0;
132c133,158
<   double energyToDecrease = duration.GetSeconds () * GetStateA (m_currentState) * supplyVoltage;
---
>   switch (m_currentState)
>     {
>     case WifiPhyState::IDLE:
>       energyToDecrease = duration.GetSeconds () * m_idleCurrentA * supplyVoltage;
>       break;
>     case WifiPhyState::CCA_BUSY:
>       energyToDecrease = duration.GetSeconds () * m_ccaBusyCurrentA * supplyVoltage;
>       break;
>     case WifiPhyState::TX:
>       energyToDecrease = duration.GetSeconds () * m_txCurrentA * supplyVoltage;
>       break;
>     case WifiPhyState::RX:
>       energyToDecrease = duration.GetSeconds () * m_rxCurrentA * supplyVoltage;
>       break;
>     case WifiPhyState::SWITCHING:
>       energyToDecrease = duration.GetSeconds () * m_switchingCurrentA * supplyVoltage;
>       break;
>     case WifiPhyState::SLEEP:
>       energyToDecrease = duration.GetSeconds () * m_sleepCurrentA * supplyVoltage;
>       break;
>     case WifiPhyState::OFF:
>       energyToDecrease = 0;
>       break;
>     default:
>       NS_FATAL_ERROR ("WifiRadioEnergyModel:Undefined radio state: " << m_currentState);
>     }
273,276c299
<   if (state == WifiPhyState::OFF)
<     {
<       NS_FATAL_ERROR ("Requested maximum remaining time for OFF state");
<     }
---
>   Time remainingTime;
279,280c302,325
<   double current = GetStateA (state);
<   return Seconds (remainingEnergy / (current * supplyVoltage));
---
>   switch (state)
>     {
>     case WifiPhyState::IDLE:
>       remainingTime = NanoSeconds (static_cast<uint64_t> (1e9 * (remainingEnergy / (m_idleCurrentA * supplyVoltage))));
>       break;
>     case WifiPhyState::CCA_BUSY:
>       remainingTime = NanoSeconds (static_cast<uint64_t> (1e9 * (remainingEnergy / (m_ccaBusyCurrentA * supplyVoltage))));
>       break;
>     case WifiPhyState::TX:
>       remainingTime = NanoSeconds (static_cast<uint64_t> (1e9 * (remainingEnergy / (m_txCurrentA * supplyVoltage))));
>       break;
>     case WifiPhyState::RX:
>       remainingTime = NanoSeconds (static_cast<uint64_t> (1e9 * (remainingEnergy / (m_rxCurrentA * supplyVoltage))));
>       break;
>     case WifiPhyState::SWITCHING:
>       remainingTime = NanoSeconds (static_cast<uint64_t> (1e9 * (remainingEnergy / (m_switchingCurrentA * supplyVoltage))));
>       break;
>     case WifiPhyState::SLEEP:
>       remainingTime = NanoSeconds (static_cast<uint64_t> (1e9 * (remainingEnergy / (m_sleepCurrentA * supplyVoltage))));
>       break;
>     default:
>       NS_FATAL_ERROR ("WifiRadioEnergyModel: undefined radio state " << state);
>     }
>   return remainingTime;
307a353
>   double energyToDecrease = 0.0;
309c355,380
<   double energyToDecrease = duration.GetSeconds () * GetStateA (m_currentState) * supplyVoltage;
---
>   switch (m_currentState)
>     {
>     case WifiPhyState::IDLE:
>       energyToDecrease = (duration.GetNanoSeconds () * m_idleCurrentA * supplyVoltage) / 1e9;
>       break;
>     case WifiPhyState::CCA_BUSY:
>       energyToDecrease = (duration.GetNanoSeconds () * m_ccaBusyCurrentA * supplyVoltage) / 1e9;
>       break;
>     case WifiPhyState::TX:
>       energyToDecrease = (duration.GetNanoSeconds () * m_txCurrentA * supplyVoltage) / 1e9;
>       break;
>     case WifiPhyState::RX:
>       energyToDecrease = (duration.GetNanoSeconds () * m_rxCurrentA * supplyVoltage) / 1e9;
>       break;
>     case WifiPhyState::SWITCHING:
>       energyToDecrease = (duration.GetNanoSeconds () * m_switchingCurrentA * supplyVoltage) / 1e9;
>       break;
>     case WifiPhyState::SLEEP:
>       energyToDecrease = (duration.GetNanoSeconds () * m_sleepCurrentA * supplyVoltage) / 1e9;
>       break;
>     case WifiPhyState::OFF:
>       energyToDecrease = 0.0;
>       break;
>     default:
>       NS_FATAL_ERROR ("WifiRadioEnergyModel: undefined radio state " << m_currentState);
>     }
398c469
< WifiRadioEnergyModel::GetStateA (int state) const
---
> WifiRadioEnergyModel::DoGetCurrentA (void) const
400c471
<   switch (state)
---
>   switch (m_currentState)
415a487,488
>     default:
>       NS_FATAL_ERROR ("WifiRadioEnergyModel: undefined radio state " << m_currentState);
417,423d489
<   NS_FATAL_ERROR ("WifiRadioEnergyModel: undefined radio state " << state);
< }
< 
< double
< WifiRadioEnergyModel::DoGetCurrentA (void) const
< {
<   return GetStateA (m_currentState);
diff ../../NS3-WiGig/src/wifi/model/wifi-radio-energy-model.h ../../ns-3-dev-git/src/wifi/model/wifi-radio-energy-model.h
46c46
<    * Callback type for updating the transmit current based on the nominal TX power.
---
>    * Callback type for updating the transmit current based on the nominal tx power.
61c61
<    * \brief Sets the update TX current callback.
---
>    * \brief Sets the update tx current callback.
63c63
<    * \param callback Update TX current callback.
---
>    * \param callback Update tx current callback.
101c101
<    * \param txPowerDbm the nominal TX power in dBm
---
>    * \param txPowerDbm the nominal tx power in dBm
155,156c155,156
<    * Callback used to update the TX current stored in WifiRadioEnergyModel based on
<    * the nominal TX power used to transmit the current frame.
---
>    * Callback used to update the tx current stored in WifiRadioEnergyModel based on
>    * the nominal tx power used to transmit the current frame.
210c210
<  * transmit power can also be achieved through a wifi TX current model.
---
>  * transmit power can also be achieved through a wifi tx current model.
244c244
<    * \returns Total energy consumption of the wifi device in watts.
---
>    * \returns Total energy consumption of the wifi device.
252c252
<    * \brief Gets idle current in Amperes.
---
>    * \brief Gets idle current.
258c258
<    * \brief Sets idle current in Amperes.
---
>    * \brief Sets idle current.
264c264
<    * \brief Gets CCA busy current in Amperes.
---
>    * \brief Gets CCA busy current.
270c270
<    * \brief Sets CCA busy current in Amperes.
---
>    * \brief Sets CCA busy current.
276c276
<    * \brief Gets transmit current in Amperes.
---
>    * \brief Gets transmit current.
282c282
<    * \brief Sets transmit current in Amperes.
---
>    * \brief Sets transmit current.
288c288
<    * \brief Gets receive current in Amperes.
---
>    * \brief Gets receive current.
294c294
<    * \brief Sets receive current in Amperes.
---
>    * \brief Sets receive current.
300c300
<    * \brief Gets switching current in Amperes.
---
>    * \brief Gets switching current.
306c306
<    * \brief Sets switching current in Amperes.
---
>    * \brief Sets switching current.
312c312
<    * \brief Gets sleep current in Amperes.
---
>    * \brief Gets sleep current.
318c318
<    * \brief Sets sleep current in Amperes.
---
>    * \brief Sets sleep current.
344c344
<    * \param model the model used to compute the wifi TX current.
---
>    * \param model the model used to compute the wifi tx current.
349,350c349,350
<    * \brief Calls the CalcTxCurrent method of the TX current model to
<    *        compute the TX current based on such model
---
>    * \brief Calls the CalcTxCurrent method of the tx current model to
>    *        compute the tx current based on such model
352c352
<    * \param txPowerDbm the nominal TX power in dBm
---
>    * \param txPowerDbm the nominal tx power in dBm
403,409c403
<    * \param state the wifi state
<    * \returns draw of device in Amperes, at given state.
<    */
<   double GetStateA (int state) const;
< 
<   /**
<    * \returns Current draw of device in Amperes, at current state.
---
>    * \returns Current draw of device, at current state.
426,431c420,425
<   double m_txCurrentA; ///< transmit current in Amperes
<   double m_rxCurrentA; ///< receive current in Amperes
<   double m_idleCurrentA; ///< idle current in Amperes
<   double m_ccaBusyCurrentA; ///< CCA busy current in Amperes
<   double m_switchingCurrentA; ///< switching current in Amperes
<   double m_sleepCurrentA; ///< sleep current in Amperes
---
>   double m_txCurrentA; ///< transmit current
>   double m_rxCurrentA; ///< receive current
>   double m_idleCurrentA; ///< idle current
>   double m_ccaBusyCurrentA; ///< CCA busy current
>   double m_switchingCurrentA; ///< switching current
>   double m_sleepCurrentA; ///< sleep current
434c428
<   /// This variable keeps track of the total energy consumed by this model in watts.
---
>   /// This variable keeps track of the total energy consumed by this model.
Only in ../../NS3-WiGig/src/wifi/model: wifi-remote-station-info.cc
Only in ../../NS3-WiGig/src/wifi/model: wifi-remote-station-info.h
diff ../../NS3-WiGig/src/wifi/model/wifi-remote-station-manager.cc ../../ns-3-dev-git/src/wifi/model/wifi-remote-station-manager.cc
24a25
> #include "ns3/packet.h"
25a27
> #include "ns3/tag.h"
27d28
< #include "dmg-wifi-mac.h"
33,37c34,40
< #include "ht-configuration.h"
< #include "vht-configuration.h"
< #include "he-configuration.h"
< #include "wifi-net-device.h"
< #include "dmg-wifi-phy.h"
---
> #include "ht-capabilities.h"
> #include "vht-capabilities.h"
> #include "he-capabilities.h"
> 
> /***************************************************************
>  *           Packet Mode Tagger
>  ***************************************************************/
42a46,317
> /**
>  * HighLatencyDataTxVectorTag class
>  */
> class HighLatencyDataTxVectorTag : public Tag
> {
> public:
>   HighLatencyDataTxVectorTag ();
>   /**
>    * Constructor
>    *
>    * \param dataTxVector TXVECTOR for data frames
>    */
>   HighLatencyDataTxVectorTag (WifiTxVector dataTxVector);
>   /**
>    * \returns the transmission mode to use to send this packet
>    */
>   WifiTxVector GetDataTxVector (void) const;
> 
>   /**
>    * \brief Get the type ID.
>    * \return the object TypeId
>    */
>   static TypeId GetTypeId (void);
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (TagBuffer i) const;
>   virtual void Deserialize (TagBuffer i);
>   virtual void Print (std::ostream &os) const;
> 
> private:
>   WifiTxVector m_dataTxVector; ///< TXVECTOR for data frames
> };
> 
> HighLatencyDataTxVectorTag::HighLatencyDataTxVectorTag ()
> {
> }
> 
> HighLatencyDataTxVectorTag::HighLatencyDataTxVectorTag (WifiTxVector dataTxVector)
>   : m_dataTxVector (dataTxVector)
> {
> }
> 
> WifiTxVector
> HighLatencyDataTxVectorTag::GetDataTxVector (void) const
> {
>   return m_dataTxVector;
> }
> 
> TypeId
> HighLatencyDataTxVectorTag::GetTypeId (void)
> {
>   static TypeId tid = TypeId ("ns3::HighLatencyDataTxVectorTag")
>     .SetParent<Tag> ()
>     .SetGroupName ("Wifi")
>     .AddConstructor<HighLatencyDataTxVectorTag> ()
>   ;
>   return tid;
> }
> 
> TypeId
> HighLatencyDataTxVectorTag::GetInstanceTypeId (void) const
> {
>   return GetTypeId ();
> }
> 
> uint32_t
> HighLatencyDataTxVectorTag::GetSerializedSize (void) const
> {
>   return sizeof (WifiTxVector);
> }
> 
> void
> HighLatencyDataTxVectorTag::Serialize (TagBuffer i) const
> {
>   i.Write ((uint8_t *)&m_dataTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyDataTxVectorTag::Deserialize (TagBuffer i)
> {
>   i.Read ((uint8_t *)&m_dataTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyDataTxVectorTag::Print (std::ostream &os) const
> {
>   os << "Data=" << m_dataTxVector;
> }
> 
> /**
>  * HighLatencyRtsTxVectorTag class
>  */
> class HighLatencyRtsTxVectorTag : public Tag
> {
> public:
>   HighLatencyRtsTxVectorTag ();
>   /**
>    * Constructor
>    *
>    * \param rtsTxVector TXVECTOR for RTS frames
>    */
>   HighLatencyRtsTxVectorTag (WifiTxVector rtsTxVector);
>   /**
>    * \returns the transmission mode to use to send the RTS prior to the
>    *          transmission of the data packet itself.
>    */
>   WifiTxVector GetRtsTxVector (void) const;
> 
>   /**
>    * \brief Get the type ID.
>    * \return the object TypeId
>    */
>   static TypeId GetTypeId (void);
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (TagBuffer i) const;
>   virtual void Deserialize (TagBuffer i);
>   virtual void Print (std::ostream &os) const;
> 
> private:
>   WifiTxVector m_rtsTxVector; ///< TXVECTOR for data frames
> };
> 
> HighLatencyRtsTxVectorTag::HighLatencyRtsTxVectorTag ()
> {
> }
> 
> HighLatencyRtsTxVectorTag::HighLatencyRtsTxVectorTag (WifiTxVector rtsTxVector)
>   : m_rtsTxVector (rtsTxVector)
> {
> }
> 
> WifiTxVector
> HighLatencyRtsTxVectorTag::GetRtsTxVector (void) const
> {
>   return m_rtsTxVector;
> }
> 
> TypeId
> HighLatencyRtsTxVectorTag::GetTypeId (void)
> {
>   static TypeId tid = TypeId ("ns3::HighLatencyRtsTxVectorTag")
>     .SetParent<Tag> ()
>     .SetGroupName ("Wifi")
>     .AddConstructor<HighLatencyRtsTxVectorTag> ()
>   ;
>   return tid;
> }
> 
> TypeId
> HighLatencyRtsTxVectorTag::GetInstanceTypeId (void) const
> {
>   return GetTypeId ();
> }
> 
> uint32_t
> HighLatencyRtsTxVectorTag::GetSerializedSize (void) const
> {
>   return sizeof (WifiTxVector);
> }
> 
> void
> HighLatencyRtsTxVectorTag::Serialize (TagBuffer i) const
> {
>   i.Write ((uint8_t *)&m_rtsTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyRtsTxVectorTag::Deserialize (TagBuffer i)
> {
>   i.Read ((uint8_t *)&m_rtsTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyRtsTxVectorTag::Print (std::ostream &os) const
> {
>   os << "Rts=" << m_rtsTxVector;
> }
> 
> /**
>  * HighLatencyCtsToSelfTxVectorTag class
>  */
> class HighLatencyCtsToSelfTxVectorTag : public Tag
> {
> public:
>   HighLatencyCtsToSelfTxVectorTag ();
>   /**
>    * Constructor
>    *
>    * \param ctsToSelfTxVector TXVECTOR for CTS-to-self frames
>    */
>   HighLatencyCtsToSelfTxVectorTag (WifiTxVector ctsToSelfTxVector);
>   /**
>    * \returns the transmission mode to use for the CTS-to-self.
>    */
>   WifiTxVector GetCtsToSelfTxVector (void) const;
> 
>   /**
>    * \brief Get the type ID.
>    * \return the object TypeId
>    */
>   static TypeId GetTypeId (void);
>   virtual TypeId GetInstanceTypeId (void) const;
>   virtual uint32_t GetSerializedSize (void) const;
>   virtual void Serialize (TagBuffer i) const;
>   virtual void Deserialize (TagBuffer i);
>   virtual void Print (std::ostream &os) const;
> 
> private:
>   WifiTxVector m_ctsToSelfTxVector; ///< TXVECTOR for CTS-to-self frames
> };
> 
> HighLatencyCtsToSelfTxVectorTag::HighLatencyCtsToSelfTxVectorTag ()
> {
> }
> 
> HighLatencyCtsToSelfTxVectorTag::HighLatencyCtsToSelfTxVectorTag (WifiTxVector ctsToSelfTxVector)
>   : m_ctsToSelfTxVector (ctsToSelfTxVector)
> {
> }
> 
> WifiTxVector
> HighLatencyCtsToSelfTxVectorTag::GetCtsToSelfTxVector (void) const
> {
>   return m_ctsToSelfTxVector;
> }
> 
> TypeId
> HighLatencyCtsToSelfTxVectorTag::GetTypeId (void)
> {
>   static TypeId tid = TypeId ("ns3::HighLatencyCtsToSelfTxVectorTag")
>     .SetParent<Tag> ()
>     .SetGroupName ("Wifi")
>     .AddConstructor<HighLatencyCtsToSelfTxVectorTag> ()
>   ;
>   return tid;
> }
> 
> TypeId
> HighLatencyCtsToSelfTxVectorTag::GetInstanceTypeId (void) const
> {
>   return GetTypeId ();
> }
> 
> uint32_t
> HighLatencyCtsToSelfTxVectorTag::GetSerializedSize (void) const
> {
>   return sizeof (WifiTxVector);
> }
> 
> void
> HighLatencyCtsToSelfTxVectorTag::Serialize (TagBuffer i) const
> {
>   i.Write ((uint8_t *)&m_ctsToSelfTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyCtsToSelfTxVectorTag::Deserialize (TagBuffer i)
> {
>   i.Read ((uint8_t *)&m_ctsToSelfTxVector, sizeof (WifiTxVector));
> }
> 
> void
> HighLatencyCtsToSelfTxVectorTag::Print (std::ostream &os) const
> {
>   os << "Cts To Self=" << m_ctsToSelfTxVector;
> }
> 
> } //namespace ns3
> 
> namespace ns3 {
> 
50a326,335
>     .AddAttribute ("IsLowLatency",
>                    "If true, we attempt to modelize a so-called low-latency device: "
>                    "a device where decisions about tx parameters can be made on a per-packet basis and "
>                    "feedback about the transmission of each packet is obtained before sending the next. "
>                    "Otherwise, we modelize a high-latency device, that is a device where we cannot update "
>                    "our decision about tx parameters after every packet transmission.",
>                    TypeId::ATTR_GET,
>                    BooleanValue (true), //this value is ignored because there is no setter
>                    MakeBooleanAccessor (&WifiRemoteStationManager::IsLowLatency),
>                    MakeBooleanChecker ())
116,125d400
<     //// WIGIG ////
<     .AddTraceSource ("MacTxOK",
<                      "The transmission of an MPDU packet by the MAC layer has successed",
<                      MakeTraceSourceAccessor (&WifiRemoteStationManager::m_macTxOk),
<                      "ns3::Mac48Address::TracedCallback")
<     .AddTraceSource ("MacRxOK",
<                      "The reception of an MPDU packet by the MAC layer has successed",
<                      MakeTraceSourceAccessor (&WifiRemoteStationManager::m_macRxOk),
<                      "ns3::WifiRemoteStationManager::MacRxOkTracedCallback")
<     //// WIGIG ////
131,135c406,409
<   : m_pcfSupported (false),
<     //// WIGIG ////
<     m_dmgSupported (false),
<     m_edmgSupported (false),
<     //// WIGIG ////
---
>   : m_htSupported (false),
>     m_vhtSupported (false),
>     m_heSupported (false),
>     m_pcfSupported (false),
166c440
<   //acknowledgments.
---
>   //acknowledgements.
168,178c442
<   //// WIGIG ////
<   if (HasDmgSupported () || HasEdmgSupported ())
<     {
<       /* For data transmission DMG/EDMG MCS-1 is selected */
<       m_defaultTxMode = phy->GetMode (1);
<     }
<   else
<     {
<       m_defaultTxMode = phy->GetMode (0);
<     }
<   //// WIGIG ////
---
>   m_defaultTxMode = phy->GetMode (0);
180c444
<   if (GetHtSupported ())
---
>   if (HasHtSupported () || HasVhtSupported () || HasHeSupported ())
218a483,489
> WifiRemoteStationManager::SetHtSupported (bool enable)
> {
>   NS_LOG_FUNCTION (this << enable);
>   m_htSupported = enable;
> }
> 
> void
265,277c536
< WifiRemoteStationManager::GetHtSupported (void) const
< {
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<   Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<   if (htConfiguration)
<     {
<       return true;
<     }
<   return false;
< }
< 
< bool
< WifiRemoteStationManager::GetVhtSupported (void) const
---
> WifiRemoteStationManager::HasHtSupported (void) const
279,297c538
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<   Ptr<VhtConfiguration> vhtConfiguration = device->GetVhtConfiguration ();
<   if (vhtConfiguration)
<     {
<       return true;
<     }
<   return false;
< }
< 
< bool
< WifiRemoteStationManager::GetHeSupported (void) const
< {
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<   Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<   if (heConfiguration)
<     {
<       return true;
<     }
<   return false;
---
>   return m_htSupported;
301c542
< WifiRemoteStationManager::SetPcfSupported (bool enable)
---
> WifiRemoteStationManager::SetVhtSupported (bool enable)
303c544
<   m_pcfSupported = enable;
---
>   m_vhtSupported = enable;
307c548
< WifiRemoteStationManager::GetPcfSupported (void) const
---
> WifiRemoteStationManager::HasVhtSupported (void) const
309c550
<   return m_pcfSupported;
---
>   return m_vhtSupported;
312,358d552
< bool
< WifiRemoteStationManager::GetGreenfieldSupported (void) const
< {
<   if (GetHtSupported ())
<     {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       NS_ASSERT (htConfiguration); //If HT is supported, we should have a HT configuration attached
<       if (htConfiguration->GetGreenfieldSupported ())
<         {
<           return true;
<         }
<     }
<   return false;
< }
< 
< bool
< WifiRemoteStationManager::GetShortGuardIntervalSupported (void) const
< {
<   if (GetHtSupported ())
<     {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       NS_ASSERT (htConfiguration); //If HT is supported, we should have a HT configuration attached
<       if (htConfiguration->GetShortGuardIntervalSupported ())
<         {
<           return true;
<         }
<     }
<   return false;
< }
< 
< uint16_t
< WifiRemoteStationManager::GetGuardInterval (void) const
< {
<   uint16_t gi = 0;
<   if (GetHeSupported ())
<     {
<       Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<       Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<       NS_ASSERT (heConfiguration); //If HE is supported, we should have a HE configuration attached
<       gi = static_cast<uint16_t>(heConfiguration->GetGuardInterval ().GetNanoSeconds ());
<     }
<   return gi;
< }
< 
< //// WIGIG ////
360c554
< WifiRemoteStationManager::SetDmgSupported (bool enable)
---
> WifiRemoteStationManager::SetHeSupported (bool enable)
362c556
<   m_dmgSupported = enable;
---
>   m_heSupported = enable;
366c560
< WifiRemoteStationManager::HasDmgSupported (void) const
---
> WifiRemoteStationManager::HasHeSupported (void) const
368c562
<   return m_dmgSupported;
---
>   return m_heSupported;
372,378c566
< WifiRemoteStationManager::SetEdmgSupported (bool enable)
< {
<   m_edmgSupported = enable;
< }
< 
< bool
< WifiRemoteStationManager::HasEdmgSupported (void) const
---
> WifiRemoteStationManager::SetPcfSupported (bool enable)
380c568
<   return m_edmgSupported;
---
>   m_pcfSupported = enable;
384c572
< WifiRemoteStationManager::IsWiGigSupported (void) const
---
> WifiRemoteStationManager::HasPcfSupported (void) const
386c574
<   return (m_dmgSupported || m_edmgSupported);
---
>   return m_pcfSupported;
389,390d576
< //// WIGIG ////
< 
398c584
< WifiRemoteStationManager::AddSupportedPhyPreamble (Mac48Address address, bool isShortPreambleSupported)
---
> WifiRemoteStationManager::AddSupportedPlcpPreamble (Mac48Address address, bool isShortPreambleSupported)
449,459d634
< //// WIGIG ////
< void
< WifiRemoteStationManager::RemoveAllSupportedModes (Mac48Address address)
< {
<   NS_LOG_FUNCTION (this << address);
<   NS_ASSERT (!address.IsGroup ());
<   WifiRemoteStationState *state = LookupState (address);
<   state->m_operationalRateSet.clear ();
< }
< //// WIGIG ////
< 
547d721
< //// WIGIG //// (MODIFIED)
549c723
< WifiRemoteStationManager::RecordWaitAssocTxOk (Mac48Address address, uint8_t associationID)
---
> WifiRemoteStationManager::RecordWaitAssocTxOk (Mac48Address address)
552,554c726
<   WifiRemoteStationState *state = LookupState (address);
<   state->m_state = WifiRemoteStationState::WAIT_ASSOC_TX_OK;
<   state->m_aid = associationID;
---
>   LookupState (address)->m_state = WifiRemoteStationState::WAIT_ASSOC_TX_OK;
557c729
< uint8_t
---
> void
561,563c733
<   WifiRemoteStationState *state = LookupState (address);
<   state->m_state = WifiRemoteStationState::GOT_ASSOC_TX_OK;
<   return state->m_aid;
---
>   LookupState (address)->m_state = WifiRemoteStationState::GOT_ASSOC_TX_OK;
565d734
< //// WIGIG ////
581d749
< //// WIGIG ////
583c751
< WifiRemoteStationManager::RecordLinkSnr (Mac48Address address, double snr)
---
> WifiRemoteStationManager::PrepareForQueue (Mac48Address address, const WifiMacHeader *header, Ptr<const Packet> packet)
585,587c753,775
<   NS_LOG_FUNCTION (this << address << snr);
<   NS_ASSERT (!address.IsGroup ());
<   LookupState (address)->m_linkSnr = snr;
---
>   NS_LOG_FUNCTION (this << address << *header << packet);
>   if (IsLowLatency () || address.IsGroup ())
>     {
>       return;
>     }
>   WifiRemoteStation *station = Lookup (address, header);
>   WifiTxVector rts = DoGetRtsTxVector (station);
>   WifiTxVector data = DoGetDataTxVector (station);
>   WifiTxVector ctstoself = DoGetCtsToSelfTxVector ();
>   HighLatencyDataTxVectorTag datatag;
>   HighLatencyRtsTxVectorTag rtstag;
>   HighLatencyCtsToSelfTxVectorTag ctstoselftag;
>   //first, make sure that the tag is not here anymore.
>   ConstCast<Packet> (packet)->RemovePacketTag (datatag);
>   ConstCast<Packet> (packet)->RemovePacketTag (rtstag);
>   ConstCast<Packet> (packet)->RemovePacketTag (ctstoselftag);
>   datatag = HighLatencyDataTxVectorTag (data);
>   rtstag = HighLatencyRtsTxVectorTag (rts);
>   ctstoselftag = HighLatencyCtsToSelfTxVectorTag (ctstoself);
>   //and then, add it back
>   packet->AddPacketTag (datatag);
>   packet->AddPacketTag (rtstag);
>   packet->AddPacketTag (ctstoselftag);
590,591c778,779
< double
< WifiRemoteStationManager::GetLinkSnr (Mac48Address address) const
---
> uint16_t
> WifiRemoteStationManager::GetChannelWidthForTransmission (WifiMode mode, uint16_t maxSupportedChannelWidth)
593,594c781,796
<   NS_ASSERT (!address.IsGroup ());
<   return LookupState (address)->m_linkSnr;
---
>   NS_LOG_FUNCTION (mode << maxSupportedChannelWidth);
>   WifiModulationClass modulationClass = mode.GetModulationClass ();
>   if (maxSupportedChannelWidth > 20
>       && (modulationClass == WifiModulationClass::WIFI_MOD_CLASS_OFDM // all non-HT OFDM control and management frames
>           || modulationClass == WifiModulationClass::WIFI_MOD_CLASS_ERP_OFDM)) // special case of beacons at 2.4 GHz
>     {
>       NS_LOG_LOGIC ("Channel width reduced to 20 MHz");
>       return 20;
>     }
>   //at 2.4 GHz basic rate can be non-ERP DSSS
>   if (modulationClass == WifiModulationClass::WIFI_MOD_CLASS_DSSS
>       || modulationClass == WifiModulationClass::WIFI_MOD_CLASS_HR_DSSS)
>     {
>       return 22;
>     }
>   return maxSupportedChannelWidth;
596d797
< //// WIGIG ////
599c800
< WifiRemoteStationManager::GetDataTxVector (const WifiMacHeader &header)
---
> WifiRemoteStationManager::GetDataTxVector (Mac48Address address, const WifiMacHeader *header, Ptr<const Packet> packet)
601,621c802,803
<   NS_LOG_FUNCTION (this << header);
<   Mac48Address address = header.GetAddr1 ();
<   //// WIGIG ////
<   /* Beam Tracking is Requested */
<   if (header.IsBeamTrackingRequested ())
<     {
<       WifiTxVector v = DoGetDataTxVector (Lookup (address));
<       v.RequestBeamTracking ();
<       v.SetPacketType (header.GetPacketType ());
<       v.SetTrainngFieldLength (header.GetTrainngFieldLength ());
<       v.SetEDMGTrainingFieldLength (header.GetEdmgTrainingFieldLength ());
<       v.Set_TRN_SEQ_LEN (StaticCast<DmgWifiMac> (m_wifiMac)->GetTrnSeqLength ());
<       v.SetChannelAggregation (StaticCast<DmgWifiMac> (m_wifiMac)->GetChannelAggregation ());
<       v.Set_EDMG_TRN_P (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_P ());
<       v.Set_EDMG_TRN_M (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_M ());
<       v.Set_EDMG_TRN_N (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_N ());
<       v.Set_RxPerTxUnits (StaticCast<DmgWifiMac> (m_wifiMac)->Get_RxPerTxUnits ());
<       return v;
<     }
<   //// WIGIG ////
<   if (!header.IsMgt () && address.IsGroup ())
---
>   NS_LOG_FUNCTION (this << address << *header << packet);
>   if (!header->IsMgt () && address.IsGroup ())
626c808
<       v.SetPreambleType (GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (address)));
---
>       v.SetPreambleType (GetPreambleForTransmission (mode, address));
629c811
<       v.SetGuardInterval (ConvertGuardIntervalToNanoSeconds (mode, DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ())));
---
>       v.SetGuardInterval (ConvertGuardIntervalToNanoSeconds (mode, m_wifiPhy->GetShortGuardInterval (), m_wifiPhy->GetGuardInterval ()));
633c815
<       v.SetStbc (0);
---
>       v.SetStbc (m_wifiPhy->GetStbc ());
636,655c818
<   //// WIGIG ////
< //  if ((header.IsMgt () || header.IsBlockAckReq ()) && m_dmgSupported && !m_edmgSupported)
< //    {
< //      WifiTxVector v;
< //      v.SetMode (WifiMode ("DMG_MCS0"));
< //      v.SetPreambleType (WIFI_PREAMBLE_LONG);
< //      v.SetTxPowerLevel (m_defaultTxPowerLevel);
< //      v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
< //      return v;
< //    }
< //  if ((header.IsMgt () || header.IsBlockAckReq ()) && m_edmgSupported)
< //    {
< //      WifiTxVector v;
< //      v.SetMode (WifiMode ("EDMG_MCS0"));
< //      v.SetPreambleType (WIFI_PREAMBLE_LONG);
< //      v.SetTxPowerLevel (m_defaultTxPowerLevel);
< //      v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
< //      return v;
< //    }
<   if (header.IsMgt () && m_dmgSupported && !m_edmgSupported)
---
>   if (!IsLowLatency ())
657,662c820,827
<       WifiTxVector v;
<       v.SetMode (WifiMode ("DMG_MCS0"));
<       v.SetPreambleType (WIFI_PREAMBLE_DMG_CTRL);
<       v.SetTxPowerLevel (m_defaultTxPowerLevel);
<       v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
<       return v;
---
>       HighLatencyDataTxVectorTag datatag;
>       bool found;
>       found = ConstCast<Packet> (packet)->PeekPacketTag (datatag);
>       NS_ASSERT (found);
>       //cast found to void, to suppress 'found' set but not used
>       //compiler warning
>       (void) found;
>       return datatag.GetDataTxVector ();
664,676c829,830
<   if (header.IsMgt () && m_edmgSupported)
<     {
<       WifiTxVector v;
<       v.SetMode (WifiMode ("EDMG_MCS0"));
<       v.SetPreambleType (WIFI_PREAMBLE_EDMG_CTRL);
<       v.SetTxPowerLevel (m_defaultTxPowerLevel);
<       v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
<       v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
<       return v;
<     }
<   //// WIGIG ////
<   WifiTxVector txVector;
<   if (header.IsMgt () && !m_dmgSupported && !m_edmgSupported)     //// WIGIG ////
---
>   WifiTxVector txVector = DoGetDataTxVector (Lookup (address, header));
>   if (header->IsMgt ())
689,690c843
<       txVector.SetPreambleType (GetPreambleForTransmission (mgtMode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (address)));
<       txVector.SetTxPowerLevel (m_defaultTxPowerLevel);
---
>       txVector.SetPreambleType (GetPreambleForTransmission (mgtMode, address));
692,717c845
<       txVector.SetGuardInterval (ConvertGuardIntervalToNanoSeconds (mgtMode, DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ())));
<     }
<   else
<     {
<       txVector = DoGetDataTxVector (Lookup (address));
<       /* Check if the packet should be transmitted in MIMO mode */
<       if (m_edmgSupported)
<         {
<           DATA_COMMUNICATION_MODE dataMode = StaticCast<DmgWifiMac> (m_wifiMac)->GetStationDataCommunicationMode (address);
<           if (dataMode != DATA_MODE_SISO)
<             {
<               NS_LOG_DEBUG ("Communication with this station should be done in MIMO mode");
<               /* Note: For now we assume that the number of antennas used to communicate with the station is equal to the number of STS */
<               txVector.SetNumberOfTxChains (StaticCast<DmgWifiMac> (m_wifiMac)->GetStationNStreams (address));
<               txVector.Set_NUM_STS (StaticCast<DmgWifiMac> (m_wifiMac)->GetStationNStreams (address));
<             }
<           txVector.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
<         }
<     }
<   Ptr<WifiNetDevice> device = DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ());
<   Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<   if (heConfiguration)
<     {
<       UintegerValue bssColor;
<       heConfiguration->GetAttribute ("BssColor", bssColor);
<       txVector.SetBssColor (bssColor.Get ());
---
>       txVector.SetGuardInterval (ConvertGuardIntervalToNanoSeconds (mgtMode, m_wifiPhy->GetShortGuardInterval (), m_wifiPhy->GetGuardInterval ()));
722d849
< //// WIGIG ////
724c851,852
< WifiRemoteStationManager::GetDmgTxVector (Mac48Address address, const WifiMacHeader *header, Ptr<const Packet> packet)
---
> WifiRemoteStationManager::GetCtsToSelfTxVector (const WifiMacHeader *header,
>                                                 Ptr<const Packet> packet)
726,780c854,855
<   NS_LOG_FUNCTION (this << address << *header << packet);
<   WifiTxVector v;
< 
<   if (header->IsActionNoAck ()) /* BRP Frame */
<     {
<       if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ad)
<         {
<           v.SetMode (WifiMode ("DMG_MCS0")); /* The BRP Frame shall be transmitted at DMG MCS0 */
<         }
<       else if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<         {
<           v.SetMode (WifiMode ("EDMG_MCS0")); /* The BRP Frame shall be transmitted at DMG MCS0 */
<         }
<       v.SetPacketType (header->GetPacketType ());
<       v.SetTrainngFieldLength (header->GetTrainngFieldLength ());
<       v.SetEDMGTrainingFieldLength (header->GetEdmgTrainingFieldLength ());
<       v.SetChannelAggregation (StaticCast<DmgWifiMac> (m_wifiMac)->GetChannelAggregation ());
<       if (header->GetEdmgTrainingFieldLength () != 0)
<         {
<           v.Set_TRN_SEQ_LEN (StaticCast<DmgWifiMac> (m_wifiMac)->GetTrnSeqLength ());
<           v.Set_EDMG_TRN_P (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_P ());
<           v.Set_EDMG_TRN_M (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_M ());
<           v.Set_EDMG_TRN_N (StaticCast<DmgWifiMac> (m_wifiMac)->Get_EDMG_TRN_N ());
<           v.Set_RxPerTxUnits (StaticCast<DmgWifiMac> (m_wifiMac)->Get_RxPerTxUnits ());
<           v.SetBrpCdown (StaticCast<DmgWifiMac> (m_wifiMac)->GetBrpCdown ());
<         }
<       v.SetSender (m_wifiMac->GetAddress ());
<     }
<   else if (header->IsDMGBeacon () || header->IsSSW () || header->IsSSW_FBCK () || header->IsSSW_ACK ()) /* Beamforming Training (SLS) */
<     {
<       if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ad)
<         {
<           v.SetMode (WifiMode ("DMG_MCS0"));
<         }
<       else if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<         {
<           v.SetMode (WifiMode ("EDMG_MCS0"));
<         }
<       // EDMG SPs are allowed to append TRN-R fields to DMG Beacons
<       if ((header->IsDMGBeacon ()) && (header->GetEdmgTrainingFieldLength () != 0) && (header->GetPacketType () == TRN_R))
<         {
<           v.SetPacketType (TRN_R);
<           v.SetEDMGTrainingFieldLength (header->GetEdmgTrainingFieldLength ());
<           v.Set_TRN_SEQ_LEN (StaticCast<DmgWifiMac> (m_wifiMac)->GetTrnSeqLength ());
<           v.SetChannelAggregation (StaticCast<DmgWifiMac> (m_wifiMac)->GetChannelAggregation ());
<           v.SetSender (m_wifiMac->GetAddress ());
<           v.SetDMGBeacon (true);
<         }
<       else
<         {
<           v.SetEDMGTrainingFieldLength (0);
<         }
<       v.SetTrainngFieldLength (0);
<     }
<   else if (header->IsPollFrame () || header->IsGrantFrame () || header->IsSprFrame ()) /* Dynamic Polling */
---
>   NS_LOG_FUNCTION (this << *header << packet);
>   if (!IsLowLatency ())
782,791c857,864
<       if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ad)
<         {
<           v.SetMode (WifiMode ("DMG_MCS1"));
<         }
<       else if (m_wifiPhy->GetStandard () == WIFI_PHY_STANDARD_80211ay)
<         {
<           v.SetMode (WifiMode ("EDMG_MCS1"));
<         }
<       v.SetTrainngFieldLength (0);
<       v.SetEDMGTrainingFieldLength (0);
---
>       HighLatencyCtsToSelfTxVectorTag ctstoselftag;
>       bool found;
>       found = ConstCast<Packet> (packet)->PeekPacketTag (ctstoselftag);
>       NS_ASSERT (found);
>       //cast found to void, to suppress 'found' set but not used
>       //compiler warning
>       (void) found;
>       return ctstoselftag.GetCtsToSelfTxVector ();
793,799c866
< 
<   v.SetPreambleType (GetPreambleForTransmission (v.GetMode ().GetModulationClass ()));
<   v.SetTxPowerLevel (m_defaultTxPowerLevel);
<   v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
<   v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
< 
<   return v;
---
>   return DoGetCtsToSelfTxVector ();
801d867
< //// WIGIG ////
804c870
< WifiRemoteStationManager::GetCtsToSelfTxVector (void)
---
> WifiRemoteStationManager::DoGetCtsToSelfTxVector (void)
814c880
<       defaultPreamble = WIFI_PREAMBLE_VHT_SU;
---
>       defaultPreamble = WIFI_PREAMBLE_VHT;
828c894
<                        ConvertGuardIntervalToNanoSeconds (defaultMode, DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ())),
---
>                        ConvertGuardIntervalToNanoSeconds (defaultMode, m_wifiPhy->GetShortGuardInterval (), m_wifiPhy->GetGuardInterval ()),
838c904,905
< WifiRemoteStationManager::GetRtsTxVector (Mac48Address address)
---
> WifiRemoteStationManager::GetRtsTxVector (Mac48Address address, const WifiMacHeader *header,
>                                           Ptr<const Packet> packet)
840,857c907,909
<   NS_LOG_FUNCTION (this << address);
<   if (address.IsGroup ())
<     {
<         WifiMode mode = GetNonUnicastMode ();
<         WifiTxVector v;
<         v.SetMode (mode);
<         v.SetPreambleType (GetPreambleForTransmission (mode.GetModulationClass (), GetShortPreambleEnabled (), UseGreenfieldForDestination (address)));
<         v.SetTxPowerLevel (m_defaultTxPowerLevel);
<         v.SetChannelWidth (GetChannelWidthForTransmission (mode, m_wifiPhy->GetChannelWidth ()));
<         v.SetGuardInterval (ConvertGuardIntervalToNanoSeconds (mode, DynamicCast<WifiNetDevice> (m_wifiPhy->GetDevice ())));
<         v.SetNTx (1);
<         v.SetNss (1);
<         v.SetNess (0);
<         v.SetStbc (0);
<         return v;
<     }
<   //// WIGIG ////
<   if (HasDmgSupported () || HasEdmgSupported ())
---
>   NS_LOG_FUNCTION (this << address << *header << packet);
>   NS_ASSERT (!address.IsGroup ());
>   if (!IsLowLatency ())
859c911,918
<       return GetDmgControlTxVector ();
---
>       HighLatencyRtsTxVectorTag rtstag;
>       bool found;
>       found = ConstCast<Packet> (packet)->PeekPacketTag (rtstag);
>       NS_ASSERT (found);
>       //cast found to void, to suppress 'found' set but not used
>       //compiler warning
>       (void) found;
>       return rtstag.GetRtsTxVector ();
861,862c920
<   //// WIGIG ////
<   return DoGetRtsTxVector (Lookup (address));
---
>   return DoGetRtsTxVector (Lookup (address, header));
870,871c928,929
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
<   m_ssrc[ac]++;
---
>   WifiRemoteStation *station = Lookup (address, header);
>   station->m_ssrc++;
873c931
<   DoReportRtsFailed (Lookup (address));
---
>   DoReportRtsFailed (station);
882c940
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
---
>   WifiRemoteStation *station = Lookup (address, header);
886c944
<       m_slrc[ac]++;
---
>       station->m_slrc++;
890c948
<       m_ssrc[ac]++;
---
>       station->m_ssrc++;
893c951
<   DoReportDataFailed (Lookup (address));
---
>   DoReportDataFailed (station);
902,907c960,962
<   WifiRemoteStation *station = Lookup (address);
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
<   station->m_state->m_info.NotifyTxSuccess (m_ssrc[ac]);
<   m_ssrc[ac] = 0;
<   m_macTxOk (address);
<   m_txCallbackOk (address);
---
>   WifiRemoteStation *station = Lookup (address, header);
>   station->m_state->m_info.NotifyTxSuccess (station->m_ssrc);
>   station->m_ssrc = 0;
914c969
<                                         WifiTxVector dataTxVector, uint32_t packetSize)
---
>                                         uint32_t packetSize)
916c971
<   NS_LOG_FUNCTION (this << address << *header << ackSnr << ackMode << dataSnr << dataTxVector << packetSize);
---
>   NS_LOG_FUNCTION (this << address << *header << ackSnr << ackMode << dataSnr);
918,919c973
<   WifiRemoteStation *station = Lookup (address);
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
---
>   WifiRemoteStation *station = Lookup (address, header);
923,924c977,978
<       station->m_state->m_info.NotifyTxSuccess (m_slrc[ac]);
<       m_slrc[ac] = 0;
---
>       station->m_state->m_info.NotifyTxSuccess (station->m_slrc);
>       station->m_slrc = 0;
928,929c982,983
<       station->m_state->m_info.NotifyTxSuccess (m_ssrc[ac]);
<       m_ssrc[ac] = 0;
---
>       station->m_state->m_info.NotifyTxSuccess (station->m_ssrc);
>       station->m_ssrc = 0;
931,933c985
<   m_macTxOk (address);
<   m_txCallbackOk (address);
<   DoReportDataOk (station, ackSnr, ackMode, dataSnr, dataTxVector.GetChannelWidth (), dataTxVector.GetNss ());
---
>   DoReportDataOk (station, ackSnr, ackMode, dataSnr);
941,942c993
<   WifiRemoteStation *station = Lookup (address);
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
---
>   WifiRemoteStation *station = Lookup (address, header);
944c995
<   m_ssrc[ac] = 0;
---
>   station->m_ssrc = 0;
955,956c1006
<   WifiRemoteStation *station = Lookup (address);
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
---
>   WifiRemoteStation *station = Lookup (address, header);
961c1011
<       m_slrc[ac] = 0;
---
>       station->m_slrc = 0;
965c1015
<       m_ssrc[ac] = 0;
---
>       station->m_ssrc = 0;
972c1022,1023
< WifiRemoteStationManager::ReportRxOk (Mac48Address address, const WifiMacHeader *header, double rxSnr, WifiMode txMode)
---
> WifiRemoteStationManager::ReportRxOk (Mac48Address address, const WifiMacHeader *header,
>                                       double rxSnr, WifiMode txMode)
974c1025
<   NS_LOG_FUNCTION (this << address << rxSnr << txMode);
---
>   NS_LOG_FUNCTION (this << address << *header << rxSnr << txMode);
979,982c1030,1031
<   m_rxSnr = rxSnr;
<   m_rxCallbackOk (address);
<   m_macRxOk (header->GetType (), address, rxSnr);
<   DoReportRxOk (Lookup (address), rxSnr, txMode);
---
>   WifiRemoteStation *station = Lookup (address, header);
>   DoReportRxOk (station, rxSnr, txMode);
986c1035
< WifiRemoteStationManager::ReportAmpduTxStatus (Mac48Address address,
---
> WifiRemoteStationManager::ReportAmpduTxStatus (Mac48Address address, uint8_t tid,
988c1037
<                                                double rxSnr, double dataSnr, WifiTxVector dataTxVector)
---
>                                                double rxSnr, double dataSnr)
990c1039
<   NS_LOG_FUNCTION (this << address << +nSuccessfulMpdus << +nFailedMpdus << rxSnr << dataSnr << dataTxVector);
---
>   NS_LOG_FUNCTION (this << address << +tid << +nSuccessfulMpdus << +nFailedMpdus << rxSnr << dataSnr);
991a1041
>   WifiRemoteStation *station = Lookup (address, tid);
996c1046
<   DoReportAmpduTxStatus (Lookup (address), nSuccessfulMpdus, nFailedMpdus, rxSnr, dataSnr, dataTxVector.GetChannelWidth (), dataTxVector.GetNss ());
---
>   DoReportAmpduTxStatus (station, nSuccessfulMpdus, nFailedMpdus, rxSnr, dataSnr);
1000c1050,1051
< WifiRemoteStationManager::NeedRts (const WifiMacHeader &header, uint32_t size)
---
> WifiRemoteStationManager::NeedRts (Mac48Address address, const WifiMacHeader *header,
>                                    Ptr<const Packet> packet, WifiTxVector txVector)
1002,1004d1052
<   NS_LOG_FUNCTION (this << header << size);
<   Mac48Address address = header.GetAddr1 ();
<   WifiTxVector txVector = GetDataTxVector (header);
1005a1054
>   NS_LOG_FUNCTION (this << address << *header << packet << mode);
1029,1039c1078,1079
<   else if (m_edmgSupported)
<     {
<       DATA_COMMUNICATION_MODE dataMode = StaticCast<DmgWifiMac> (m_wifiMac)->GetStationDataCommunicationMode (address);
<       if (dataMode != DATA_MODE_SISO)
<         {
<           NS_LOG_DEBUG ("WifiRemoteStationManager::NeedRTS returning true to protect MIMO transmission");
<           return true;
<         }
<     }
<   bool normally = (size > m_rtsCtsThreshold);
<   return DoNeedRts (Lookup (address), size, normally);
---
>   bool normally = (packet->GetSize () + header->GetSize () + WIFI_MAC_FCS_LENGTH) > m_rtsCtsThreshold;
>   return DoNeedRts (Lookup (address, header), packet, normally);
1068c1108
<       //search for the BSS Basic Rate set, if the used mode is in the basic set then there is no need for CTS To Self
---
>       //search for the BSS Basic Rate set, if the used mode is in the basic set then there is no need for Cts To Self
1077c1117
<       if (GetHtSupported ())
---
>       if (HasHtSupported ())
1079c1119
<           //search for the BSS Basic MCS set, if the used mode is in the basic set then there is no need for CTS To Self
---
>           //search for the BSS Basic MCS set, if the used mode is in the basic set then there is no need for Cts To Self
1140c1180
<   AcIndex ac = QosUtilsMapTidToAc ((header->IsQosData ()) ? header->GetQosTid () : 0);
---
>   WifiRemoteStation *station = Lookup (address, header);
1145c1185
<       retryCount = m_slrc[ac];
---
>       retryCount = station->m_slrc;
1150c1190
<       retryCount = m_ssrc[ac];
---
>       retryCount = station->m_ssrc;
1155c1195
<   return DoNeedRetransmission (Lookup (address), packet, normally);
---
>   return DoNeedRetransmission (station, packet, normally);
1166a1207
>   WifiRemoteStation *station = Lookup (address, header);
1169c1210
<   return DoNeedFragmentation (Lookup (address), packet, normally);
---
>   return DoNeedFragmentation (station, packet, normally);
1281c1322,1502
< //// WIGIG ////
---
> bool
> WifiRemoteStationManager::IsAllowedControlAnswerModulationClass (WifiModulationClass modClassReq, WifiModulationClass modClassAnswer) const
> {
>   switch (modClassReq)
>     {
>     case WIFI_MOD_CLASS_DSSS:
>       return (modClassAnswer == WIFI_MOD_CLASS_DSSS);
>     case WIFI_MOD_CLASS_HR_DSSS:
>       return (modClassAnswer == WIFI_MOD_CLASS_DSSS || modClassAnswer == WIFI_MOD_CLASS_HR_DSSS);
>     case WIFI_MOD_CLASS_ERP_OFDM:
>       return (modClassAnswer == WIFI_MOD_CLASS_DSSS || modClassAnswer == WIFI_MOD_CLASS_HR_DSSS || modClassAnswer == WIFI_MOD_CLASS_ERP_OFDM);
>     case WIFI_MOD_CLASS_OFDM:
>       return (modClassAnswer == WIFI_MOD_CLASS_OFDM);
>     case WIFI_MOD_CLASS_HT:
>     case WIFI_MOD_CLASS_VHT:
>     case WIFI_MOD_CLASS_HE:
>       return true;
>     default:
>       NS_FATAL_ERROR ("Modulation class not defined");
>       return false;
>     }
> }
> 
> WifiMode
> WifiRemoteStationManager::GetControlAnswerMode (Mac48Address address, WifiMode reqMode)
> {
>   /**
>    * The standard has relatively unambiguous rules for selecting a
>    * control response rate (the below is quoted from IEEE 802.11-2012,
>    * Section 9.7):
>    *
>    * To allow the transmitting STA to calculate the contents of the
>    * Duration/ID field, a STA responding to a received frame shall
>    * transmit its Control Response frame (either CTS or ACK), other
>    * than the BlockAck control frame, at the highest rate in the
>    * BSSBasicRateSet parameter that is less than or equal to the
>    * rate of the immediately previous frame in the frame exchange
>    * sequence (as defined in Annex G) and that is of the same
>    * modulation class (see Section 9.7.8) as the received frame...
>    */
>   NS_LOG_FUNCTION (this << address << reqMode);
>   WifiMode mode = GetDefaultMode ();
>   bool found = false;
>   //First, search the BSS Basic Rate set
>   for (WifiModeListIterator i = m_bssBasicRateSet.begin (); i != m_bssBasicRateSet.end (); i++)
>     {
>       if ((!found || i->IsHigherDataRate (mode))
>           && (!i->IsHigherDataRate (reqMode))
>           && (IsAllowedControlAnswerModulationClass (reqMode.GetModulationClass (), i->GetModulationClass ())))
>         {
>           mode = *i;
>           //We've found a potentially-suitable transmit rate, but we
>           //need to continue and consider all the basic rates before
>           //we can be sure we've got the right one.
>           found = true;
>         }
>     }
>   if (HasHtSupported () || HasVhtSupported () || HasHeSupported ())
>     {
>       if (!found)
>         {
>           mode = GetDefaultMcs ();
>           for (WifiModeListIterator i = m_bssBasicMcsSet.begin (); i != m_bssBasicMcsSet.end (); i++)
>             {
>               if ((!found || i->IsHigherDataRate (mode))
>                   && (!i->IsHigherDataRate (reqMode))
>                   && (i->GetModulationClass () == reqMode.GetModulationClass ()))
>                 {
>                   mode = *i;
>                   //We've found a potentially-suitable transmit rate, but we
>                   //need to continue and consider all the basic rates before
>                   //we can be sure we've got the right one.
>                   found = true;
>                 }
>             }
>         }
>     }
>   //If we found a suitable rate in the BSSBasicRateSet, then we are
>   //done and can return that mode.
>   if (found)
>     {
>       NS_LOG_DEBUG ("WifiRemoteStationManager::GetControlAnswerMode returning " << mode);
>       return mode;
>     }
> 
>   /**
>    * If no suitable basic rate was found, we search the mandatory
>    * rates. The standard (IEEE 802.11-2007, Section 9.6) says:
>    *
>    *   ...If no rate contained in the BSSBasicRateSet parameter meets
>    *   these conditions, then the control frame sent in response to a
>    *   received frame shall be transmitted at the highest mandatory
>    *   rate of the PHY that is less than or equal to the rate of the
>    *   received frame, and that is of the same modulation class as the
>    *   received frame. In addition, the Control Response frame shall
>    *   be sent using the same PHY options as the received frame,
>    *   unless they conflict with the requirement to use the
>    *   BSSBasicRateSet parameter.
>    *
>    * \todo Note that we're ignoring the last sentence for now, because
>    * there is not yet any manipulation here of PHY options.
>    */
>   for (uint8_t idx = 0; idx < m_wifiPhy->GetNModes (); idx++)
>     {
>       WifiMode thismode = m_wifiPhy->GetMode (idx);
>       /* If the rate:
>        *
>        *  - is a mandatory rate for the PHY, and
>        *  - is equal to or faster than our current best choice, and
>        *  - is less than or equal to the rate of the received frame, and
>        *  - is of the same modulation class as the received frame
>        *
>        * ...then it's our best choice so far.
>        */
>       if (thismode.IsMandatory ()
>           && (!found || thismode.IsHigherDataRate (mode))
>           && (!thismode.IsHigherDataRate (reqMode))
>           && (IsAllowedControlAnswerModulationClass (reqMode.GetModulationClass (), thismode.GetModulationClass ())))
>         {
>           mode = thismode;
>           //As above; we've found a potentially-suitable transmit
>           //rate, but we need to continue and consider all the
>           //mandatory rates before we can be sure we've got the right one.
>           found = true;
>         }
>     }
>   if (HasHtSupported () || HasVhtSupported () || HasHeSupported ())
>     {
>       for (uint8_t idx = 0; idx < m_wifiPhy->GetNMcs (); idx++)
>         {
>           WifiMode thismode = m_wifiPhy->GetMcs (idx);
>           if (thismode.IsMandatory ()
>               && (!found || thismode.IsHigherDataRate (mode))
>               && (!thismode.IsHigherCodeRate (reqMode))
>               && (thismode.GetModulationClass () == reqMode.GetModulationClass ()))
>             {
>               mode = thismode;
>               //As above; we've found a potentially-suitable transmit
>               //rate, but we need to continue and consider all the
>               //mandatory rates before we can be sure we've got the right one.
>               found = true;
>             }
>         }
>     }
> 
>   /**
>    * If we still haven't found a suitable rate for the response then
>    * someone has messed up the simulation config. This probably means
>    * that the WifiPhyStandard is not set correctly, or that a rate that
>    * is not supported by the PHY has been explicitly requested in a
>    * WifiRemoteStationManager (or descendant) configuration.
>    *
>    * Either way, it is serious - we can either disobey the standard or
>    * fail, and I have chosen to do the latter...
>    */
>   if (!found)
>     {
>       NS_FATAL_ERROR ("Can't find response rate for " << reqMode);
>     }
> 
>   NS_LOG_DEBUG ("WifiRemoteStationManager::GetControlAnswerMode returning " << mode);
>   return mode;
> }
> 
> WifiTxVector
> WifiRemoteStationManager::GetCtsTxVector (Mac48Address address, WifiMode rtsMode)
> {
>   NS_ASSERT (!address.IsGroup ());
>   WifiMode ctsMode = GetControlAnswerMode (address, rtsMode);
>   WifiTxVector v;
>   v.SetMode (ctsMode);
>   v.SetPreambleType (GetPreambleForTransmission (ctsMode, address));
>   v.SetTxPowerLevel (DoGetCtsTxPowerLevel (address, ctsMode));
>   v.SetChannelWidth (GetChannelWidthForTransmission (ctsMode, DoGetCtsTxChannelWidth (address, ctsMode)));
>   v.SetGuardInterval (DoGetCtsTxGuardInterval (address, ctsMode));
>   v.SetNss (DoGetCtsTxNss (address, ctsMode));
>   v.SetNess (DoGetCtsTxNess (address, ctsMode));
>   v.SetStbc (m_wifiPhy->GetStbc ());
>   return v;
> }
> 
1283c1504
< WifiRemoteStationManager::GetDmgControlTxVector (void)
---
> WifiRemoteStationManager::GetAckTxVector (Mac48Address address, WifiMode dataMode)
1285c1506,1507
<   WifiMode mode = m_wifiPhy->GetMode (0);
---
>   NS_ASSERT (!address.IsGroup ());
>   WifiMode ackMode = GetControlAnswerMode (address, dataMode);
1287,1291c1509,1516
<   v.SetMode (mode);
<   v.SetTxPowerLevel (m_defaultTxPowerLevel);
<   v.SetPreambleType (GetPreambleForTransmission (mode.GetModulationClass ()));
<   v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
<   v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
---
>   v.SetMode (ackMode);
>   v.SetPreambleType (GetPreambleForTransmission (ackMode, address));
>   v.SetTxPowerLevel (DoGetAckTxPowerLevel (address, ackMode));
>   v.SetChannelWidth (GetChannelWidthForTransmission (ackMode, DoGetAckTxChannelWidth (address, ackMode)));
>   v.SetGuardInterval (DoGetAckTxGuardInterval (address, ackMode));
>   v.SetNss (DoGetAckTxNss (address, ackMode));
>   v.SetNess (DoGetAckTxNess (address, ackMode));
>   v.SetStbc (m_wifiPhy->GetStbc ());
1296c1521
< WifiRemoteStationManager::GetDmgLowestScVector (void)
---
> WifiRemoteStationManager::GetBlockAckTxVector (Mac48Address address, WifiMode blockAckReqMode)
1298c1523,1524
<   WifiMode mode = m_wifiPhy->GetMode (1);
---
>   NS_ASSERT (!address.IsGroup ());
>   WifiMode blockAckMode = GetControlAnswerMode (address, blockAckReqMode);
1300,1304c1526,1533
<   v.SetMode (mode); // DMG/EDMG SC Modulation Class (MCS1)
<   v.SetTxPowerLevel (m_defaultTxPowerLevel);
<   v.SetPreambleType (GetPreambleForTransmission (mode.GetModulationClass ()));
<   v.SetChannelWidth (m_wifiPhy->GetChannelWidth ());
<   v.SetChBandwidth (StaticCast<DmgWifiPhy> (m_wifiPhy)->GetChannelConfiguration ());
---
>   v.SetMode (blockAckMode);
>   v.SetPreambleType (GetPreambleForTransmission (blockAckMode, address));
>   v.SetTxPowerLevel (DoGetBlockAckTxPowerLevel (address, blockAckMode));
>   v.SetChannelWidth (GetChannelWidthForTransmission (blockAckMode, DoGetBlockAckTxChannelWidth (address, blockAckMode)));
>   v.SetGuardInterval (DoGetBlockAckTxGuardInterval (address, blockAckMode));
>   v.SetNss (DoGetBlockAckTxNss (address, blockAckMode));
>   v.SetNess (DoGetBlockAckTxNess (address, blockAckMode));
>   v.SetStbc (m_wifiPhy->GetStbc ());
1307c1536,1625
< //// WIGIG ////
---
> 
> uint8_t
> WifiRemoteStationManager::DoGetCtsTxPowerLevel (Mac48Address address, WifiMode ctsMode)
> {
>   return m_defaultTxPowerLevel;
> }
> 
> uint16_t
> WifiRemoteStationManager::DoGetCtsTxChannelWidth (Mac48Address address, WifiMode ctsMode)
> {
>   return m_wifiPhy->GetChannelWidth ();
> }
> 
> uint16_t
> WifiRemoteStationManager::DoGetCtsTxGuardInterval (Mac48Address address, WifiMode ctsMode)
> {
>   return ConvertGuardIntervalToNanoSeconds (ctsMode, m_wifiPhy->GetShortGuardInterval (), m_wifiPhy->GetGuardInterval ());
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetCtsTxNss (Mac48Address address, WifiMode ctsMode)
> {
>   return 1;
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetCtsTxNess (Mac48Address address, WifiMode ctsMode)
> {
>   return 0;
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetAckTxPowerLevel (Mac48Address address, WifiMode ackMode)
> {
>   return m_defaultTxPowerLevel;
> }
> 
> uint16_t
> WifiRemoteStationManager::DoGetAckTxChannelWidth (Mac48Address address, WifiMode ctsMode)
> {
>   return m_wifiPhy->GetChannelWidth ();
> }
> 
> uint16_t
> WifiRemoteStationManager::DoGetAckTxGuardInterval (Mac48Address address, WifiMode ackMode)
> {
>   return ConvertGuardIntervalToNanoSeconds (ackMode, m_wifiPhy->GetShortGuardInterval (), m_wifiPhy->GetGuardInterval ());
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetAckTxNss (Mac48Address address, WifiMode ackMode)
> {
>   return 1;
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetAckTxNess (Mac48Address address, WifiMode ackMode)
> {
>   return 0;
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetBlockAckTxPowerLevel (Mac48Address address, WifiMode blockAckMode)
> {
>   return m_defaultTxPowerLevel;
> }
> 
> uint16_t
> WifiRemoteStationManager::DoGetBlockAckTxChannelWidth (Mac48Address address, WifiMode ctsMode)
> {
>   return m_wifiPhy->GetChannelWidth ();
> }
> 
> uint16_t
> WifiRemoteStationManager::DoGetBlockAckTxGuardInterval (Mac48Address address, WifiMode blockAckMode)
> {
>   return ConvertGuardIntervalToNanoSeconds (blockAckMode, m_wifiPhy->GetShortGuardInterval (), m_wifiPhy->GetGuardInterval ());
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetBlockAckTxNss (Mac48Address address, WifiMode blockAckMode)
> {
>   return 1;
> }
> 
> uint8_t
> WifiRemoteStationManager::DoGetBlockAckTxNess (Mac48Address address, WifiMode blockAckMode)
> {
>   return 0;
> }
1339,1341d1656
<   state->m_htCapabilities = 0;
<   state->m_vhtCapabilities = 0;
<   state->m_heCapabilities = 0;
1343c1658,1661
<   state->m_guardInterval = GetGuardInterval ();
---
>   state->m_shortGuardInterval = m_wifiPhy->GetShortGuardInterval ();
>   state->m_guardInterval = static_cast<uint16_t> (m_wifiPhy->GetGuardInterval ().GetNanoSeconds ());
>   state->m_greenfield = m_wifiPhy->GetGreenfield ();
>   state->m_streams = 1;
1345a1664,1665
>   state->m_stbc = false;
>   state->m_ldpc = false;
1347,1349c1667,1669
<   state->m_dmgSupported = false;
<   state->m_edmgSupported = false;
<   state->m_linkSnr = -100;
---
>   state->m_htSupported = false;
>   state->m_vhtSupported = false;
>   state->m_heSupported = false;
1356c1676
< WifiRemoteStationManager::Lookup (Mac48Address address) const
---
> WifiRemoteStationManager::Lookup (Mac48Address address, const WifiMacHeader *header) const
1358c1678,1693
<   NS_LOG_FUNCTION (this << address);
---
>   uint8_t tid;
>   if (header->IsQosData ())
>     {
>       tid = header->GetQosTid ();
>     }
>   else
>     {
>       tid = 0;
>     }
>   return Lookup (address, tid);
> }
> 
> WifiRemoteStation *
> WifiRemoteStationManager::Lookup (Mac48Address address, uint8_t tid) const
> {
>   NS_LOG_FUNCTION (this << address << +tid);
1361c1696,1697
<       if ((*i)->m_state->m_address == address)
---
>       if ((*i)->m_tid == tid
>           && (*i)->m_state->m_address == address)
1369a1706,1708
>   station->m_tid = tid;
>   station->m_ssrc = 0;
>   station->m_slrc = 0;
1384c1723
< WifiRemoteStationManager::AddStationHtCapabilities (Mac48Address from, Ptr<HtCapabilities> htCapabilities)
---
> WifiRemoteStationManager::AddStationHtCapabilities (Mac48Address from, HtCapabilities htCapabilities)
1390c1729,1730
<   if (htCapabilities->GetSupportedChannelWidth () == 1)
---
>   state->m_shortGuardInterval = htCapabilities.GetShortGuardInterval20 ();
>   if (htCapabilities.GetSupportedChannelWidth () == 1)
1398a1739,1740
>   state->m_greenfield = htCapabilities.GetGreenfield ();
>   state->m_streams = htCapabilities.GetRxHighestSupportedAntennas ();
1402c1744
<       if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HT && htCapabilities->IsSupportedMcs (mcs.GetMcsValue ()))
---
>       if (mcs.GetModulationClass () == WIFI_MOD_CLASS_HT && htCapabilities.IsSupportedMcs (mcs.GetMcsValue ()))
1407c1749
<   state->m_htCapabilities = htCapabilities;
---
>   state->m_htSupported = true;
1411c1753
< WifiRemoteStationManager::AddStationVhtCapabilities (Mac48Address from, Ptr<VhtCapabilities> vhtCapabilities)
---
> WifiRemoteStationManager::AddStationVhtCapabilities (Mac48Address from, VhtCapabilities vhtCapabilities)
1417c1759
<   if (vhtCapabilities->GetSupportedChannelWidthSet () == 1)
---
>   if (vhtCapabilities.GetSupportedChannelWidthSet () == 1)
1430a1773,1774
>   state->m_ldpc = (vhtCapabilities.GetRxLdpc () != 0);
>   state->m_stbc = (vhtCapabilities.GetTxStbc () != 0 || vhtCapabilities.GetRxStbc () != 0);
1436c1780
<           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities->IsSupportedMcs (mcs.GetMcsValue (), i))
---
>           if (mcs.GetModulationClass () == WIFI_MOD_CLASS_VHT && vhtCapabilities.IsSupportedMcs (mcs.GetMcsValue (), i))
1442,1455c1786
<   state->m_vhtCapabilities = vhtCapabilities;
< }
< 
< //// WIGIG ////
< void
< WifiRemoteStationManager::AddStationDmgCapabilities (Mac48Address from, Ptr<DmgCapabilities> dmgCapabilities)
< {
<   //Used by all stations to record DMG capabilities of remote stations
<   NS_LOG_FUNCTION (this << from << dmgCapabilities);
<   WifiRemoteStationState *state;
<   state = LookupState (from);
<   state->m_qosSupported = true;
<   state->m_dmgSupported = true;
<   state->m_dmgCapabilities = dmgCapabilities;
---
>   state->m_vhtSupported = true;
1459,1485c1790
< WifiRemoteStationManager::AddStationEdmgCapabilities (Mac48Address from, Ptr<EdmgCapabilities> edmgCapabilities)
< {
<   //Used by all stations to record EDMG capabilities of remote stations
<   NS_LOG_FUNCTION (this << from << edmgCapabilities);
<   WifiRemoteStationState *state;
<   state = LookupState (from);
<   state->m_qosSupported = true;
<   state->m_edmgSupported = true;
<   state->m_edmgCapabilities = edmgCapabilities;
< }
< 
< Ptr<const DmgCapabilities>
< WifiRemoteStationManager::GetStationDmgCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_dmgCapabilities;
< }
< 
< Ptr<const EdmgCapabilities>
< WifiRemoteStationManager::GetStationEdmgCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_edmgCapabilities;
< }
< 
< //// WIGIG ////
< 
< void
< WifiRemoteStationManager::AddStationHeCapabilities (Mac48Address from, Ptr<HeCapabilities> heCapabilities)
---
> WifiRemoteStationManager::AddStationHeCapabilities (Mac48Address from, HeCapabilities heCapabilities)
1493c1798
<       if (heCapabilities->GetChannelWidthSet () & 0x04)
---
>       if (heCapabilities.GetChannelWidthSet () & 0x04)
1497c1802
<       else if (heCapabilities->GetChannelWidthSet () & 0x02)
---
>       else if (heCapabilities.GetChannelWidthSet () & 0x02)
1505c1810
<       if (heCapabilities->GetChannelWidthSet () & 0x01)
---
>       if (heCapabilities.GetChannelWidthSet () & 0x01)
1514c1819
<   if (heCapabilities->GetHeLtfAndGiForHePpdus () >= 2)
---
>   if (heCapabilities.GetHeLtfAndGiForHePpdus () >= 2)
1518c1823
<   else if (heCapabilities->GetHeLtfAndGiForHePpdus () == 1)
---
>   else if (heCapabilities.GetHeLtfAndGiForHePpdus () == 1)
1532,1533c1837,1838
<               && heCapabilities->GetHighestNssSupported () >= i
<               && heCapabilities->GetHighestMcsSupported () >= j)
---
>               && heCapabilities.GetHighestNssSupported () >= i
>               && heCapabilities.GetHighestMcsSupported () >= j)
1539c1844
<   state->m_heCapabilities = heCapabilities;
---
>   state->m_heSupported = true;
1543,1560d1847
< Ptr<const HtCapabilities>
< WifiRemoteStationManager::GetStationHtCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_htCapabilities;
< }
< 
< Ptr<const VhtCapabilities>
< WifiRemoteStationManager::GetStationVhtCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_vhtCapabilities;
< }
< 
< Ptr<const HeCapabilities>
< WifiRemoteStationManager::GetStationHeCapabilities (Mac48Address from)
< {
<   return LookupState (from)->m_heCapabilities;
< }
< 
1564,1570c1851
<   Ptr<const HtCapabilities> htCapabilities = LookupState (address)->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return false;
<     }
<   return htCapabilities->GetGreenfield ();
---
>   return LookupState (address)->m_greenfield;
1601,1602d1881
<   m_ssrc.fill (0);
<   m_slrc.fill (0);
1609c1888
<   if (mode.GetModulationClass () >= WIFI_MOD_CLASS_HT)
---
>   if (mode.GetModulationClass () == WIFI_MOD_CLASS_HT || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT || mode.GetModulationClass () == WIFI_MOD_CLASS_HE)
1611c1890
<       NS_FATAL_ERROR ("It is not allowed to add a HT rate in the BSSBasicRateSet!");
---
>       NS_FATAL_ERROR ("It is not allowed to add a (V)HT rate in the BSSBasicRateSet!");
1725c2004
<                                      uint32_t size, bool normally)
---
>                                      Ptr<const Packet> packet, bool normally)
1745c2024
< WifiRemoteStationManager::DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus, double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss)
---
> WifiRemoteStationManager::DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus, double rxSnr, double dataSnr)
1768c2047
<   //IEEE 802.11g standard defines that if the protection mechanism is enabled, RTS, CTS and CTS-To-Self
---
>   //IEEE 802.11g standard defines that if the protection mechanism is enabled, Rts, Cts and Cts-To-Self
1805c2084
< WifiRemoteStationManager::GetShortGuardIntervalSupported (const WifiRemoteStation *station) const
---
> WifiRemoteStationManager::GetShortGuardInterval (const WifiRemoteStation *station) const
1807,1813c2086
<   Ptr<const HtCapabilities> htCapabilities = station->m_state->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return false;
<     }
<   return htCapabilities->GetShortGuardInterval20 ();
---
>   return station->m_state->m_shortGuardInterval;
1825,1831c2098
<   Ptr<const HtCapabilities> htCapabilities = station->m_state->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return false;
<     }
<   return htCapabilities->GetGreenfield ();
---
>   return station->m_state->m_greenfield;
1843,1849c2110
<   Ptr<const HtCapabilities> htCapabilities = station->m_state->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return 1;
<     }
<   return htCapabilities->GetRxHighestSupportedAntennas ();
---
>   return station->m_state->m_streams;
1870,1895d2130
< //// WIGIG ////
< void
< WifiRemoteStationManager::RegisterTxOkCallback (Callback<void, Mac48Address> callback)
< {
<   m_txCallbackOk = callback;
< }
< 
< void
< WifiRemoteStationManager::RegisterRxOkCallback (Callback<void, Mac48Address> callback)
< {
<   m_rxCallbackOk = callback;
< }
< 
< uint32_t
< WifiRemoteStationManager::GetNAssociatedStation (void) const
< {
<   return m_states.size ();
< }
< 
< double
< WifiRemoteStationManager::GetRxSnr (void) const
< {
<   return m_rxSnr;
< }
< //// WIGIG ////
< 
1911c2146
<   return (station->m_state->m_htCapabilities != 0);
---
>   return station->m_state->m_htSupported;
1917c2152
<   return (station->m_state->m_vhtCapabilities != 0);
---
>   return station->m_state->m_vhtSupported;
1923c2158
<   return (station->m_state->m_heCapabilities != 0);
---
>   return station->m_state->m_heSupported;
1954c2189
< WifiRemoteStationManager::GetShortGuardIntervalSupported (Mac48Address address) const
---
> WifiRemoteStationManager::GetShortGuardInterval (Mac48Address address) const
1956,1962c2191
<   Ptr<const HtCapabilities> htCapabilities = LookupState (address)->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return false;
<     }
<   return htCapabilities->GetShortGuardInterval20 ();
---
>   return LookupState (address)->m_shortGuardInterval;
1968,1974c2197
<   Ptr<const HtCapabilities> htCapabilities = LookupState (address)->m_htCapabilities;
< 
<   if (!htCapabilities)
<     {
<       return 1;
<     }
<   return htCapabilities->GetRxHighestSupportedAntennas ();
---
>   return LookupState (address)->m_streams;
1986c2209
<   return (LookupState (address)->m_htCapabilities != 0);
---
>   return LookupState (address)->m_htSupported;
1992,1998c2215
<   return (LookupState (address)->m_vhtCapabilities != 0);
< }
< 
< bool
< WifiRemoteStationManager::GetHeSupported (Mac48Address address) const
< {
<   return (LookupState (address)->m_heCapabilities != 0);
---
>   return LookupState (address)->m_vhtSupported;
2008c2225
< WifiRemoteStationManager::GetNumberOfAntennas (void) const
---
> WifiRemoteStationManager::GetNumberOfAntennas (void)
2014c2231
< WifiRemoteStationManager::GetMaxNumberOfTransmitStreams (void) const
---
> WifiRemoteStationManager::GetMaxNumberOfTransmitStreams (void)
2019,2020c2236,2306
< bool
< WifiRemoteStationManager::UseGreenfieldForDestination (Mac48Address dest) const
---
> WifiPreamble
> WifiRemoteStationManager::GetPreambleForTransmission (WifiMode mode, Mac48Address dest)
> {
>   NS_LOG_FUNCTION (this << mode << dest);
>   WifiPreamble preamble;
>   if (mode.GetModulationClass () == WIFI_MOD_CLASS_HE)
>     {
>       preamble = WIFI_PREAMBLE_HE_SU;
>     }
>   else if (mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
>     {
>       preamble = WIFI_PREAMBLE_VHT;
>     }
>   else if (mode.GetModulationClass () == WIFI_MOD_CLASS_HT && m_wifiPhy->GetGreenfield () && GetGreenfieldSupported (dest) && !GetUseGreenfieldProtection ())
>     {
>       //If protection for greenfield is used we go for HT_MF preamble which is the default protection for GF format defined in the standard.
>       preamble = WIFI_PREAMBLE_HT_GF;
>     }
>   else if (mode.GetModulationClass () == WIFI_MOD_CLASS_HT)
>     {
>       preamble = WIFI_PREAMBLE_HT_MF;
>     }
>   else if (GetShortPreambleEnabled ())
>     {
>       preamble = WIFI_PREAMBLE_SHORT;
>     }
>   else
>     {
>       preamble = WIFI_PREAMBLE_LONG;
>     }
>   NS_LOG_DEBUG ("selected preamble=" << preamble);
>   return preamble;
> }
> 
> WifiRemoteStation::~WifiRemoteStation ()
> {
>   NS_LOG_FUNCTION (this);
> }
> 
> WifiRemoteStationInfo::WifiRemoteStationInfo ()
>   : m_memoryTime (Seconds (1.0)),
>     m_lastUpdate (Seconds (0.0)),
>     m_failAvg (0.0)
> {
>   NS_LOG_FUNCTION (this);
> }
> 
> double
> WifiRemoteStationInfo::CalculateAveragingCoefficient ()
> {
>   double retval = std::exp (static_cast<double> (m_lastUpdate.GetMicroSeconds () - Simulator::Now ().GetMicroSeconds ()) / m_memoryTime.GetMicroSeconds ());
>   m_lastUpdate = Simulator::Now ();
>   return retval;
> }
> 
> void
> WifiRemoteStationInfo::NotifyTxSuccess (uint32_t retryCounter)
> {
>   double coefficient = CalculateAveragingCoefficient ();
>   m_failAvg = static_cast<double> (retryCounter) / (1 + retryCounter) * (1 - coefficient) + coefficient * m_failAvg;
> }
> 
> void
> WifiRemoteStationInfo::NotifyTxFailed ()
> {
>   double coefficient = CalculateAveragingCoefficient ();
>   m_failAvg = (1 - coefficient) + coefficient * m_failAvg;
> }
> 
> double
> WifiRemoteStationInfo::GetFrameErrorRate () const
2022c2308
<   return (GetGreenfieldSupported () && GetGreenfieldSupported (dest) && !GetUseGreenfieldProtection ());
---
>   return m_failAvg;
diff ../../NS3-WiGig/src/wifi/model/wifi-remote-station-manager.h ../../ns-3-dev-git/src/wifi/model/wifi-remote-station-manager.h
24d23
< #include <array>
26a26
> #include "ns3/nstime.h"
30,40c30
< #include "wifi-utils.h"
< #include "qos-utils.h"
< #include "wifi-remote-station-info.h"
< #include "ht-capabilities.h"
< #include "vht-capabilities.h"
< #include "he-capabilities.h"
< //// WIGIG ////
< #include "dmg-capabilities.h"
< #include "edmg-capabilities.h"
< #include "wifi-mac-header.h"
< //// WIGIG ////
---
> #include "wifi-preamble.h"
43a34,36
> struct WifiRemoteStation;
> struct WifiRemoteStationState;
> 
47a41,43
> class HtCapabilities;
> class VhtCapabilities;
> class HeCapabilities;
51,71c47
<  * Enumeration for type of station
<  */
< enum TypeOfStation
< {
<   DMG_STA,
<   DMG_AP,
<   DMG_ADHOC,
<   STA,
<   AP,
<   ADHOC_STA,
<   MESH,
<   HT_STA,
<   HT_AP,
<   HT_ADHOC_STA,
<   OCB
< };
< 
< struct WifiRemoteStationState;
< 
< /**
<  * \brief hold per-remote-station state.
---
>  * \brief Tid independent remote station statistics
73,79c49,50
<  * The state in this class is used to keep track
<  * of association status if we are in an infrastructure
<  * network and to perform the selection of TX parameters
<  * on a per-packet basis.
<  *
<  * This class is typically subclassed and extended by
<  * rate control implementations
---
>  * Structure is similar to struct sta_info in Linux kernel (see
>  * net/mac80211/sta_info.h)
81,90c52
< struct WifiRemoteStation
< {
<   virtual ~WifiRemoteStation () {};
<   WifiRemoteStationState *m_state;  //!< Remote station state
< };
< 
< /**
<  * A struct that holds information about each remote station.
<  */
< struct WifiRemoteStationState
---
> class WifiRemoteStationInfo
91a54,55
> public:
>   WifiRemoteStationInfo ();
93c57,59
<    * State of the station
---
>    * \brief Updates average frame error rate when data or RTS was transmitted successfully.
>    *
>    * \param retryCounter is slrc or ssrc value at the moment of success transmission.
95,102c61,63
<   enum
<   {
<     BRAND_NEW,
<     DISASSOC,
<     WAIT_ASSOC_TX_OK,
<     GOT_ASSOC_TX_OK
<   } m_state;
< 
---
>   void NotifyTxSuccess (uint32_t retryCounter);
>   /// Updates average frame error rate when final data or RTS has failed.
>   void NotifyTxFailed ();
104,110c65,66
<    * This member is the list of WifiMode objects that comprise the
<    * OperationalRateSet parameter for this remote station. This list
<    * is constructed through calls to
<    * WifiRemoteStationManager::AddSupportedMode(), and an API that
<    * allows external access to it is available through
<    * WifiRemoteStationManager::GetNSupported() and
<    * WifiRemoteStationManager::GetSupported().
---
>    * Return frame error rate (probability that frame is corrupted due to transmission error).
>    * \returns the frame error rate
112,134c68,84
<   WifiModeList m_operationalRateSet; //!< operational rate set
<   WifiModeList m_operationalMcsSet;  //!< operational MCS set
<   Mac48Address m_address;            //!< Mac48Address of the remote station
<   WifiRemoteStationInfo m_info;      //!< remote station info
<   Ptr<const HtCapabilities> m_htCapabilities;     //!< remote station HT capabilities
<   Ptr<const VhtCapabilities> m_vhtCapabilities;   //!< remote station VHT capabilities
<   Ptr<const HeCapabilities> m_heCapabilities;     //!< remote station HE capabilities
<   Ptr<const DmgCapabilities> m_dmgCapabilities;   //!< remote station DMG capabilities
<   Ptr<const EdmgCapabilities> m_edmgCapabilities; //!< remote station EDMG capabilities
< 
<   uint16_t m_channelWidth;    //!< Channel width (in MHz) supported by the remote station
<   uint16_t m_guardInterval;   //!< HE Guard interval duration (in nanoseconds) supported by the remote station
<   uint8_t m_ness;             //!< Number of extended spatial streams of the remote station
<   bool m_aggregation;         //!< Flag if MPDU aggregation is used by the remote station
<   bool m_shortPreamble;       //!< Flag if short PHY preamble is supported by the remote station
<   bool m_shortSlotTime;       //!< Flag if short ERP slot time is supported by the remote station
<   //// WIGIG ////
<   bool m_dmgSupported;        //!< Flag if DMG is supported by the station
<   bool m_edmgSupported;       //!< Flag if EDMG is supported by the station
<   uint8_t m_aid;              //!< Association identifier assigned to the station.
<   double m_linkSnr;           //!< The SNR of the link after beamforming training.
<   //// WIGIG ////
<   bool m_qosSupported;        //!< Flag if QoS is supported by the station
---
>   double GetFrameErrorRate () const;
> private:
>   /**
>    * \brief Calculate averaging coefficient for frame error rate. Depends on time of the last update.
>    *
>    * \attention Calling this method twice gives different results,
>    * because it resets time of last update.
>    *
>    * \return average coefficient for frame error rate
>    */
>   double CalculateAveragingCoefficient ();
>   /// averaging coefficient depends on the memory time
>   Time m_memoryTime;
>   /// when last update has occurred
>   Time m_lastUpdate;
>   /// moving percentage of failed frames
>   double m_failAvg;
163,171d112
<    * A vector of WifiRemoteStations
<    */
<   typedef std::vector <WifiRemoteStation *> Stations;
<   /**
<    * A vector of WifiRemoteStationStates
<    */
<   typedef std::vector <WifiRemoteStationState *> StationStates;
< 
<   /**
235c176
<    * \param htCapabilities the HT capabilities of the station
---
>    * \param htcapabilities the HT capabilities of the station
237c178
<   void AddStationHtCapabilities (Mac48Address from, Ptr<HtCapabilities> htcapabilities);
---
>   void AddStationHtCapabilities (Mac48Address from, HtCapabilities htcapabilities);
242c183
<    * \param vhtCapabilities the VHT capabilities of the station
---
>    * \param vhtcapabilities the VHT capabilities of the station
244c185
<   void AddStationVhtCapabilities (Mac48Address from, Ptr<VhtCapabilities> vhtcapabilities);
---
>   void AddStationVhtCapabilities (Mac48Address from, VhtCapabilities vhtcapabilities);
249,271c190
<    * \param heCapabilities the HE capabilities of the station
<    */
<   void AddStationHeCapabilities (Mac48Address from, Ptr<HeCapabilities> heCapabilities);
<   //// WIGIG ////
<   /**
<    * Records DMG capabilities of the remote station.
<    *
<    * \param from the address of the station being recorded
<    * \param dmgCapabilities the DMG capabilities of the station
<    */
<   void AddStationDmgCapabilities (Mac48Address from, Ptr<DmgCapabilities> dmgCapabilities);
<   /**
<    * Records EDMG capabilities of the remote station.
<    *
<    * \param from the address of the station being recorded
<    * \param edmgCapabilities the EDMG capabilities of the station
<    */
<   void AddStationEdmgCapabilities (Mac48Address from, Ptr<EdmgCapabilities> edmgCapabilities);
<   /**
<    * Return the DMG capabilities sent by the remote station.
<    *
<    * \param from the address of the remote station
<    * \return the DMG capabilities sent by the remote station
---
>    * \param hecapabilities the HE capabilities of the station
273c192
<   Ptr<const DmgCapabilities> GetStationDmgCapabilities (Mac48Address from);
---
>   void AddStationHeCapabilities (Mac48Address from, HeCapabilities hecapabilities);
275c194
<    * Return the EDMG capabilities sent by the remote station.
---
>    * Enable or disable HT capability support.
277,278c196
<    * \param from the address of the remote station
<    * \return the EDMG capabilities sent by the remote station
---
>    * \param enable enable or disable HT capability support
280,282c198
<   Ptr<const EdmgCapabilities> GetStationEdmgCapabilities (Mac48Address from);
< 
<   //// WIGIG ////
---
>   virtual void SetHtSupported (bool enable);
284c200
<    * Return the HT capabilities sent by the remote station.
---
>    * Return whether the device has HT capability support enabled.
286,287c202
<    * \param from the address of the remote station
<    * \return the HT capabilities sent by the remote station
---
>    * \return true if HT capability support is enabled, false otherwise
289c204
<   Ptr<const HtCapabilities> GetStationHtCapabilities (Mac48Address from);
---
>   bool HasHtSupported (void) const;
291c206
<    * Return the VHT capabilities sent by the remote station.
---
>    * Enable or disable VHT capability support.
293,294c208
<    * \param from the address of the remote station
<    * \return the VHT capabilities sent by the remote station
---
>    * \param enable enable or disable VHT capability support
296c210
<   Ptr<const VhtCapabilities> GetStationVhtCapabilities (Mac48Address from);
---
>   virtual void SetVhtSupported (bool enable);
298c212
<    * Return the HE capabilities sent by the remote station.
---
>    * Return whether the device has VHT capability support enabled.
300,301c214
<    * \param from the address of the remote station
<    * \return the HE capabilities sent by the remote station
---
>    * \return true if VHT capability support is enabled, false otherwise
303c216
<   Ptr<const HeCapabilities> GetStationHeCapabilities (Mac48Address from);
---
>   bool HasVhtSupported (void) const;
305c218
<    * Return whether the device has HT capability support enabled.
---
>    * Enable or disable HE capability support.
307c220
<    * \return true if HT capability support is enabled, false otherwise
---
>    * \param enable enable or disable HE capability support
309,315c222
<   bool GetHtSupported (void) const;
<   /**
<    * Return whether the device has VHT capability support enabled.
<    *
<    * \return true if VHT capability support is enabled, false otherwise
<    */
<   bool GetVhtSupported (void) const;
---
>   virtual void SetHeSupported (bool enable);
321c228
<   bool GetHeSupported (void) const;
---
>   bool HasHeSupported (void) const;
327c234
<   void SetPcfSupported (bool enable);
---
>   virtual void SetPcfSupported (bool enable);
333,351c240
<   bool GetPcfSupported (void) const;
<   /**
<    * Return whether the device has HT Greenfield support enabled.
<    *
<    * \return true if HT Grenfield support is enabled, false otherwise
<    */
<   bool GetGreenfieldSupported (void) const;
<   /**
<    * Return whether the device has SGI support enabled.
<    *
<    * \return true if SGI support is enabled, false otherwise
<    */
<   bool GetShortGuardIntervalSupported (void) const;
<   /**
<    * Return the supported HE guard interval duration (in nanoseconds).
<    *
<    * \return the supported HE guard interval duration (in nanoseconds)
<    */
<   uint16_t GetGuardInterval (void) const;
---
>   bool HasPcfSupported (void) const;
379c268
<    * Enable or disable protection for stations that do not support HT Greenfield format.
---
>    * Enable or disable protection for stations that do not support HT greenfield format.
381c270
<    * \param enable enable or disable protection for stations that do not support HT Greenfield format
---
>    * \param enable enable or disable protection for stations that do not support HT greenfield format
385c274
<    * Return whether protection for stations that do not support HT Greenfield format is enabled.
---
>    * Return whether protection for stations that do not support HT greenfield format is enabled.
387c276
<    * \return true if protection for stations that do not support HT Greenfield is enabled,
---
>    * \return true if protection for stations that do not support HT greenfield is enabled,
392c281
<    * Enable or disable short PHY preambles.
---
>    * Enable or disable short PLCP preambles.
394c283
<    * \param enable enable or disable short PHY preambles
---
>    * \param enable enable or disable short PLCP preambles
398c287
<    * Return whether the device uses short PHY preambles.
---
>    * Return whether the device uses short PLCP preambles.
400c289
<    * \return true if short PHY preambles are enabled,
---
>    * \return true if short PLCP preambles are enabled,
431,462d319
<   //// WIGIG ////
<   /**
<    * Enable or disable DMG capability support.
<    *
<    * \param enable enable or disable DMG capability support
<    */
<   void SetDmgSupported (bool enable);
<   /**
<    * Return whether the device has DMG capability support enabled.
<    *
<    * \return true if DMG capability support is enabled, false otherwise
<    */
<   bool HasDmgSupported (void) const;
<   /**
<    * Enable or disable EDMG capability support.
<    *
<    * \param enable enable or disable EDMG capability support
<    */
<   void SetEdmgSupported (bool enable);
<   /**
<    * Return whether the device has EDMG capability support enabled.
<    *
<    * \return true if EDMG capability support is enabled, false otherwise
<    */
<   bool HasEdmgSupported (void) const;
<   /**
<    * Return whether the device has DMG or EDMG capability support enabled.
<    *
<    * \return true if either the DMG or the EDMG capability support is enabled, false otherwise.
<    */
<   bool IsWiGigSupported (void) const;
<   //// WIGIG ////
520c377
<    * Return whether the station supports short PHY preamble or not.
---
>    * Return whether the station supports short PLCP preamble or not.
524c381
<    * \return true if short PHY preamble is supported by the station,
---
>    * \return true if short PLCP preamble is supported by the station,
570c427
<    * \return the basic MCS at the given list index
---
>    * \return the basic mcs at the given list index
596c453
<   bool GetShortGuardIntervalSupported (Mac48Address address) const;
---
>   bool GetShortGuardInterval (Mac48Address address) const;
631,639d487
<   /**
<    * Return whether the station supports HE or not.
<    *
<    * \param address the address of the station
<    *
<    * \return true if HE is supported by the station,
<    *         false otherwise
<    */
<   bool GetHeSupported (Mac48Address address) const;
681c529
<    * Record whether the short PHY preamble is supported by the station.
---
>    * Record whether the short PLCP preamble is supported by the station.
684c532
<    * \param isShortPreambleSupported whether or not short PHY preamble is supported by the station
---
>    * \param isShortPreambleSupported whether or not short PLCP preamble is supported by the station
686c534
<   void AddSupportedPhyPreamble (Mac48Address address, bool isShortPreambleSupported);
---
>   void AddSupportedPlcpPreamble (Mac48Address address, bool isShortPreambleSupported);
722d569
<   //// WIGIG //// (MODIFIED)
728d574
<    * \param assocaitionID The association identifier that we provide to the station.
730c576
<   void RecordWaitAssocTxOk (Mac48Address address, uint8_t associationID = 0);
---
>   void RecordWaitAssocTxOk (Mac48Address address);
736d581
<    * \return Association identifier assigned to the station.
738,739c583
<   uint8_t RecordGotAssocTxOk (Mac48Address address);
<   //// WIGIG ////
---
>   void RecordGotAssocTxOk (Mac48Address address);
754,760d597
<   //// WIGIG ////
<   /**
<    * Invoked in a STA or AP to delete all of the suppported MCS by a destination.
<    *
<    * \param address the address of the station being recorded
<    */
<   void RemoveAllSupportedModes (Mac48Address address);
762,769c599,601
<    * Records link's SNR value with a particular station after performing beamforming training.
<    *
<    * \param address The MAC address of the peer station.
<    * \param snr The SNR in dB of the link after performing beamforming training.
<    */
<   void RecordLinkSnr (Mac48Address address, double snr);
<   /**
<    * Return the latest SNR value after performing beamforming training with a the specified station.
---
>    * \param address remote address
>    * \param header MAC header
>    * \param packet the packet to queue
771,772c603,606
<    * \param address The MAC address of the peer station.
<    * \return The SNR in dB of the link after performing beamforming training.
---
>    * This method is typically invoked just before queuing a packet for transmission.
>    * It is a no-op unless the IsLowLatency attribute of the attached ns3::WifiRemoteStationManager
>    * is set to false, in which case, the tx parameters of the packet are calculated and stored in
>    * the packet as a tag. These tx parameters are later retrieved from GetDadaMode and GetRtsMode.
774,775c608,610
<   double GetLinkSnr (Mac48Address address) const;
<   //// WIGIG ////
---
>   void PrepareForQueue (Mac48Address address, const WifiMacHeader *header,
>                         Ptr<const Packet> packet);
> 
776a612
>    * \param address remote address
777a614
>    * \param packet the packet to send
781,782c618,619
<   WifiTxVector GetDataTxVector (const WifiMacHeader &header);
<   //// WIGIG ////
---
>   WifiTxVector GetDataTxVector (Mac48Address address, const WifiMacHeader *header,
>                                 Ptr<const Packet> packet);
788c625,626
<    * \return the transmission mode to use to send this DMG packet
---
>    * \return the TXVECTOR to use to send the RTS prior to the
>    *         transmission of the data packet itself.
790,791c628,629
<   WifiTxVector GetDmgTxVector (Mac48Address address, const WifiMacHeader *header, Ptr<const Packet> packet);
<   //// WIGIG ////
---
>   WifiTxVector GetRtsTxVector (Mac48Address address, const WifiMacHeader *header,
>                                Ptr<const Packet> packet);
793c631,632
<    * \param address remote address
---
>    * \param header MAC header
>    * \param packet the packet to send
795c634
<    * \return the TXVECTOR to use to send the RTS prior to the
---
>    * \return the transmission mode to use to send the CTS-to-self prior to the
798c637,638
<   WifiTxVector GetRtsTxVector (Mac48Address address);
---
>   WifiTxVector GetCtsToSelfTxVector (const WifiMacHeader *header,
>                                      Ptr<const Packet> packet);
801c641
<    * it is implemented in wifi remote station manager
---
>    * it is implemented in wifiremote station manager
806c646
<   WifiTxVector GetCtsToSelfTxVector (void);
---
>   WifiTxVector DoGetCtsToSelfTxVector (void);
827c667
<    * Should be invoked whenever we receive the CTS associated to an RTS
---
>    * Should be invoked whenever we receive the Cts associated to an RTS
840c680
<    * Should be invoked whenever we receive the ACK associated to a data packet
---
>    * Should be invoked whenever we receive the Ack associated to a data packet
848d687
<    * \param dataTxVector the TXVECTOR of the DATA we sent
852,853c691
<                      double ackSnr, WifiMode ackMode,
<                      double dataSnr, WifiTxVector dataTxVector,
---
>                      double ackSnr, WifiMode ackMode, double dataSnr,
878c716,717
<    * \param nSuccessfulMpdus number of successfully transmitted MPDUs
---
>    * \param tid TID of the DATA packet
>    * \param nSuccessfulMpdus number of successfully transmitted MPDUs.
880c719
<    * \param nFailedMpdus number of unsuccessfully transmitted MPDUs
---
>    * \param nFailedMpdus number of unsuccessfully transmitted MPDUs.
883d721
<    * \param dataTxVector the TXVECTOR of the MPDUs we sent
885,886c723
<   void ReportAmpduTxStatus (Mac48Address address, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                             double rxSnr, double dataSnr, WifiTxVector dataTxVector);
---
>   void ReportAmpduTxStatus (Mac48Address address, uint8_t tid, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus, double rxSnr, double dataSnr);
891,892c728,729
<    * \param rxSnr the SNR of the packet received
<    * \param txMode the transmission mode used for the packet received
---
>    * \param rxSnr the snr of the packet received
>    * \param txMode the transmission mode used for the packet received.
899a737
>    * \param address remote address
901c739,740
<    * \param size the size of the frame to send in bytes
---
>    * \param packet the packet to send
>    * \param txVector the TXVECTOR of the packet to send
904c743
<    *         frame before sending it, false otherwise.
---
>    *         packet before sending it, false otherwise.
906c745,746
<   bool NeedRts (const WifiMacHeader &header, uint32_t size);
---
>   bool NeedRts (Mac48Address address, const WifiMacHeader *header,
>                 Ptr<const Packet> packet, WifiTxVector txVector);
908c748
<    * Return if we need to do CTS-to-self before sending a DATA.
---
>    * Return if we need to do Cts-to-self before sending a DATA.
912c752
<    * \return true if CTS-to-self is needed,
---
>    * \return true if Cts-to-self is needed,
968a809,829
>    * \param address remote address
>    * \param rtsMode the transmission mode used to send an RTS we just received
>    *
>    * \return the transmission mode to use for the CTS to complete the RTS/CTS handshake.
>    */
>   WifiTxVector GetCtsTxVector (Mac48Address address, WifiMode rtsMode);
>   /**
>    * \param address
>    * \param dataMode the transmission mode used to send an ACK we just received
>    *
>    * \return the transmission mode to use for the ACK to complete the data/ACK handshake.
>    */
>   WifiTxVector GetAckTxVector (Mac48Address address, WifiMode dataMode);
>   /**
>    * \param address
>    * \param dataMode the transmission mode used to send an ACK we just received
>    *
>    * \return the transmission mode to use for the ACK to complete the data/ACK handshake.
>    */
>   WifiTxVector GetBlockAckTxVector (Mac48Address address, WifiMode dataMode);
>   /**
985c846
<    * \return the number of antennas supported by the PHY layer
---
>    * \return the number of antennas supported by the phy layer
987c848
<   uint8_t GetNumberOfAntennas (void) const;
---
>   uint8_t GetNumberOfAntennas (void);
989,997c850
<    * \return the maximum number of spatial streams supported by the PHY layer
<    */
<   uint8_t GetMaxNumberOfTransmitStreams (void) const;
<   /**
<    * \returns whether HT greenfield should be used for a given destination address.
<    *
<    * \param dest the destination address
<    *
<    * \return whether HT greenfield should be used for a given destination address
---
>    * \return the maximum number of spatial streams supported by the phy layer
999c852
<   bool UseGreenfieldForDestination (Mac48Address dest) const;
---
>   uint8_t GetMaxNumberOfTransmitStreams (void);
1019,1043d871
<   //// WIGIG ////
<   /**
<    * \return the DMG Control transmission mode (MCS0).
<    */
<   WifiTxVector GetDmgControlTxVector (void);
<   /**
<    * \return the DMG Lowest SC transmission mode (MCS1).
<    */
<   WifiTxVector GetDmgLowestScVector (void);
<   /**
<    * Return the number of associated stations.
<    *
<    * \return Number of associated stations.
<    */
<   uint32_t GetNAssociatedStation (void) const;
<   /**
<    * Return the value of the last received SNR.
<    *
<    * \return the value of the last received SNR.
<    */
<   double GetRxSnr (void) const;
<   void RegisterTxOkCallback (Callback<void, Mac48Address> callback);
<   void RegisterRxOkCallback (Callback<void, Mac48Address> callback);
<   //// WIGIG ////
< 
1159c987
<   bool GetShortGuardIntervalSupported (const WifiRemoteStation *station) const;
---
>   bool GetShortGuardInterval (const WifiRemoteStation *station) const;
1202a1031,1049
>   /**
>    * Return the preamble to be used for the transmission.
>    *
>    * \param mode the mode selected for the transmission
>    * \param dest address of the recipient
>    *
>    * \return the preamble to be used for the transmission
>    */
>   WifiPreamble GetPreambleForTransmission (WifiMode mode, Mac48Address dest);
>   /**
>    * Return the channel width that corresponds to the selected mode (instead of
>    * letting the PHY's default channel width). This is especially useful when using
>    * non-HT modes with HT/VHT/HE capable stations (with default width above 20 MHz).
>    *
>    * \param mode selected WifiMode
>    * \param maxSupportedChannelWidth maximum channel width supported by the PHY layer
>    * \return channel width adapted to the selected mode
>    */
>   static uint16_t GetChannelWidthForTransmission (WifiMode mode, uint16_t maxSupportedChannelWidth);
1207c1054
<    * \return a pointer to the WifiPhy
---
>    * \return WifiPhy
1213c1060
<    * \return a pointer to the WifiMac
---
>    * \return WifiMac
1221,1223c1068,1070
<    * \param size the size of the frame to send in bytes
<    * \param normally indicates whether the normal 802.11 RTS enable mechanism would
<    *        request that the RTS is sent or not.
---
>    * \param packet the packet to send
>    * \param normally indicates whether the normal 802.11 rts enable mechanism would
>    *        request that the rts is sent or not.
1225c1072
<    * \return true if we want to use an RTS/CTS handshake for this frame before sending it,
---
>    * \return true if we want to use an RTS/CTS handshake for this packet before sending it,
1231c1078
<                           uint32_t size, bool normally);
---
>                           Ptr<const Packet> packet, bool normally);
1258a1106,1112
>    * \return whether this manager is a manager designed to work in low-latency environments.
>    *
>    * Note: In this context, low vs high latency is defined in <i>IEEE 802.11 Rate Adaptation:
>    * A Practical Approach</i>, by M. Lacage, M.H. Manshaei, and T. Turletti.
>    */
>   virtual bool IsLowLatency (void) const = 0;
>   /**
1274c1128
<    * \return the transmission mode to use to send an RTS to the station
---
>    * \return the transmission mode to use to send an rts to the station
1276,1277c1130,1131
<    * Note: This method is called before sending an RTS to a station
<    *       to decide which transmission mode to use for the RTS.
---
>    * Note: This method is called before sending an rts to a station
>    *       to decide which transmission mode to use for the rts.
1279a1134,1239
>   /**
>    * \param address the address of the recipient of the CTS
>    * \param ctsMode the mode to be used for the CTS
>    *
>    * \return the power level to be used to send the CTS
>    */
>   virtual uint8_t DoGetCtsTxPowerLevel (Mac48Address address, WifiMode ctsMode);
>   /**
>    * \param address the address of the recipient of the ACK
>    * \param ackMode the mode to be used for the ACK
>    *
>    * \return the power level to be used to send the ACK
>    */
>   virtual uint8_t DoGetAckTxPowerLevel (Mac48Address address, WifiMode ackMode);
>   /**
>    * \param address the address of the recipient of the Block ACK
>    * \param blockAckMode the mode to be used for the Block ACK
>    *
>    * \return the power level to be used to send the Block ACK
>    */
>   virtual uint8_t DoGetBlockAckTxPowerLevel (Mac48Address address, WifiMode blockAckMode);
> 
>   /**
>    * \param address the address of the recipient
>    * \param ctsMode the mode to be used
>    *
>    * \return the CTS transmit channel width
>    */
>   virtual uint16_t DoGetCtsTxChannelWidth (Mac48Address address, WifiMode ctsMode);
>   /**
>    * \param address the address of the recipient
>    * \param ctsMode the mode to be used
>    *
>    * \return the CTS transmit guard interval
>    */
>   virtual uint16_t DoGetCtsTxGuardInterval (Mac48Address address, WifiMode ctsMode);
>   /**
>    * \param address the address of the recipient
>    * \param ctsMode the mode to be used
>    *
>    * \return the CTS transmit NSS
>    */
>   virtual uint8_t DoGetCtsTxNss (Mac48Address address, WifiMode ctsMode);
>   /**
>    * \param address the address of the recipient
>    * \param ctsMode the mode to be used
>    *
>    * \return the CTS transmit NESS
>    */
>   virtual uint8_t DoGetCtsTxNess (Mac48Address address, WifiMode ctsMode);
>   /**
>    * \param address the address of the recipient
>    * \param ctsMode the mode to be used
>    *
>    * \return the ack transmit channel width
>    */
>   virtual uint16_t DoGetAckTxChannelWidth (Mac48Address address, WifiMode ctsMode);
>   /**
>    * \param address the address of the recipient
>    * \param ackMode the mode to be used
>    *
>    * \return the ack transmit guard interval
>    */
>   virtual uint16_t DoGetAckTxGuardInterval (Mac48Address address, WifiMode ackMode);
>   /**
>    * \param address the address of the recipient
>    * \param ackMode the mode to be used
>    *
>    * \return the ack transmit NSS
>    */
>   virtual uint8_t DoGetAckTxNss (Mac48Address address, WifiMode ackMode);
>   /**
>    * \param address the address of the recipient
>    * \param ackMode the mode to be used
>    *
>    * \return the ack transmit NESS
>    */
>   virtual uint8_t DoGetAckTxNess (Mac48Address address, WifiMode ackMode);
>   /**
>    * \param address the address of the recipient
>    * \param ctsMode the mode to be used
>    *
>    * \return the block ack transmit channel width
>    */
>   virtual uint16_t DoGetBlockAckTxChannelWidth (Mac48Address address, WifiMode ctsMode);
>   /**
>    * \param address the address of the recipient
>    * \param blockAckMode the mode to be used
>    *
>    * \return the block ack transmit guard interval
>    */
>   virtual uint16_t DoGetBlockAckTxGuardInterval (Mac48Address address, WifiMode blockAckMode);
>   /**
>    * \param address the address of the recipient
>    * \param blockAckMode the mode to be used
>    *
>    * \return the block ack transmit NSS
>    */
>   virtual uint8_t DoGetBlockAckTxNss (Mac48Address address, WifiMode blockAckMode);
>   /**
>    * \param address the address of the recipient
>    * \param blockAckMode the mode to be used
>    *
>    * \return the block ack transmit NESS
>    */
>   virtual uint8_t DoGetBlockAckTxNess (Mac48Address address, WifiMode blockAckMode);
1314,1315d1273
<    * \param dataChannelWidth the channel width (in MHz) of the DATA we sent
<    * \param dataNss the number of spatial streams used to send the DATA
1317,1318c1275,1276
<   virtual void DoReportDataOk (WifiRemoteStation *station, double ackSnr, WifiMode ackMode,
<                                double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss) = 0;
---
>   virtual void DoReportDataOk (WifiRemoteStation *station,
>                                double ackSnr, WifiMode ackMode, double dataSnr) = 0;
1355,1356d1312
<    * \param dataChannelWidth the channel width (in MHz) of the A-MPDU we sent
<    * \param dataNss the number of spatial streams used to send the A-MPDU
1358,1359c1314
<   virtual void DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus,
<                                       double rxSnr, double dataSnr, uint16_t dataChannelWidth, uint8_t dataNss);
---
>   virtual void DoReportAmpduTxStatus (WifiRemoteStation *station, uint8_t nSuccessfulMpdus, uint8_t nFailedMpdus, double rxSnr, double dataSnr);
1369c1324,1335
<    * Return the station associated with the given address.
---
>    * Return the station associated with the given address and TID.
>    *
>    * \param address the address of the station
>    * \param tid the TID
>    *
>    * \return WifiRemoteStation corresponding to the address
>    */
>   WifiRemoteStation* Lookup (Mac48Address address, uint8_t tid) const;
>   /// Find a remote station by its remote address and TID taken from MAC header
>   /**
>    * Return the station associated with the given address and MAC header.
>    * It simply gets TID from the MAC header and calls Lookup with tid.
1371a1338
>    * \param header MAC header
1375c1342,1364
<   WifiRemoteStation* Lookup (Mac48Address address) const;
---
>   WifiRemoteStation* Lookup (Mac48Address address, const WifiMacHeader *header) const;
> 
>   /**
>    * Return whether the modulation class of the selected mode for the
>    * control answer frame is allowed.
>    *
>    * \param modClassReq modulation class of the request frame
>    * \param modClassAnswer modulation class of the answer frame
>    *
>    * \return true if the modulation class of the selected mode for the
>    * control answer frame is allowed, false otherwise
>    */
>   bool IsAllowedControlAnswerModulationClass (WifiModulationClass modClassReq, WifiModulationClass modClassAnswer) const;
> 
>   /**
>    * Get control answer mode function.
>    *
>    * \param address the address of the station
>    * \param reqMode request mode
>    *
>    * \return control answer mode
>    */
>   WifiMode GetControlAnswerMode (Mac48Address address, WifiMode reqMode);
1400a1390,1398
>    * A vector of WifiRemoteStations
>    */
>   typedef std::vector <WifiRemoteStation *> Stations;
>   /**
>    * A vector of WifiRemoteStationStates
>    */
>   typedef std::vector <WifiRemoteStationState *> StationStates;
> 
>   /**
1427c1425
<   WifiModeList m_bssBasicMcsSet;  //!< basic MCS set
---
>   WifiModeList m_bssBasicMcsSet; //!< basic MCS set
1433c1431
<   WifiMode m_defaultTxMcs;  //!< The default transmission modulation-coding scheme (MCS)
---
>   WifiMode m_defaultTxMcs;   //!< The default transmission modulation-coding scheme (MCS)
1434a1433,1435
>   bool m_htSupported;  //!< Flag if HT capability is supported
>   bool m_vhtSupported; //!< Flag if VHT capability is supported
>   bool m_heSupported;  //!< Flag if HE capability is supported
1436,1440d1436
<   //// WIGIG ////
<   bool m_dmgSupported; //!< Flag if DMG capability is supported
<   bool m_edmgSupported;//!< Flag if EDMG capability is supported
<   double m_rxSnr;      //!< The value of the last received SNR.
<   //// WIGIG ////
1443,1444c1439,1440
<   uint32_t m_rtsCtsThreshold;             //!< Threshold for RTS/CTS
<   uint32_t m_fragmentationThreshold;      //!< Current threshold for fragmentation
---
>   uint32_t m_rtsCtsThreshold;  //!< Threshold for RTS/CTS
>   uint32_t m_fragmentationThreshold;  //!< Current threshold for fragmentation
1446,1453c1442,1449
<   uint8_t m_defaultTxPowerLevel;          //!< Default transmission power level
<   WifiMode m_nonUnicastMode;      //!< Transmission mode for non-unicast Data frames
<   bool m_useNonErpProtection;     //!< flag if protection for non-ERP stations against ERP transmissions is enabled
<   bool m_useNonHtProtection;      //!< flag if protection for non-HT stations against HT transmissions is enabled
<   bool m_useGreenfieldProtection; //!< flag if protection for stations that do not support HT Greenfield format is enabled
<   bool m_shortPreambleEnabled;    //!< flag if short PHY preamble is enabled
<   bool m_shortSlotTimeEnabled;    //!< flag if short slot time is enabled
<   bool m_rifsPermitted;           //!< flag if RIFS is enabled
---
>   uint8_t m_defaultTxPowerLevel;  //!< Default tranmission power level
>   WifiMode m_nonUnicastMode;  //!< Transmission mode for non-unicast DATA frames
>   bool m_useNonErpProtection; //!< flag if protection for non-ERP stations against ERP transmissions is enabled
>   bool m_useNonHtProtection;  //!< flag if protection for non-HT stations against HT transmissions is enabled
>   bool m_useGreenfieldProtection; //!< flag if protection for stations that do not support HT greenfield format is enabled
>   bool m_shortPreambleEnabled; //!< flag if short PLCP preamble is enabled
>   bool m_shortSlotTimeEnabled; //!< flag if short slot time is enabled
>   bool m_rifsPermitted;        //!< flag if RIFS is enabled
1457,1459d1452
<   std::array<uint32_t, AC_BE_NQOS> m_ssrc; //!< short retry count per AC
<   std::array<uint32_t, AC_BE_NQOS> m_slrc; //!< long retry count per AC
< 
1478c1471,1477
<   //// WIGIG ////
---
> };
> 
> /**
>  * A struct that holds information about each remote station.
>  */
> struct WifiRemoteStationState
> {
1480c1479
<    * The trace source fired when the transmission of a single MPDU has successed.
---
>    * State of the station
1482,1485c1481,1488
<   TracedCallback<Mac48Address> m_macTxOk;
<   Callback<void, Mac48Address> m_txCallbackOk;
<   Callback<void, Mac48Address> m_rxCallbackOk;
<   TracedCallback<WifiMacType, Mac48Address, double> m_macRxOk;   /* Trace for Successful WifiMAC Reception */
---
>   enum
>   {
>     BRAND_NEW,
>     DISASSOC,
>     WAIT_ASSOC_TX_OK,
>     GOT_ASSOC_TX_OK
>   } m_state;
> 
1487,1491c1490,1496
<    * TracedCallback signature for MAC Rx OK.
<    *
<    * \param type The type of the WifiMAC Header.
<    * \param address The MAC address of the station.
<    * \param snr The snr value in linear scale.
---
>    * This member is the list of WifiMode objects that comprise the
>    * OperationalRateSet parameter for this remote station. This list
>    * is constructed through calls to
>    * WifiRemoteStationManager::AddSupportedMode(), and an API that
>    * allows external access to it is available through
>    * WifiRemoteStationManager::GetNSupported() and
>    * WifiRemoteStationManager::GetSupported().
1493,1494c1498,1537
<   typedef void (* MacRxOkCallback)(WifiMacType type, Mac48Address address, double snr);
<   //// WIGIG ////
---
>   WifiModeList m_operationalRateSet; //!< opertional rate set
>   WifiModeList m_operationalMcsSet; //!< operational MCS set
>   Mac48Address m_address;  //!< Mac48Address of the remote station
>   WifiRemoteStationInfo m_info; //!< remote station info
> 
>   uint16_t m_channelWidth;    //!< Channel width (in MHz) supported by the remote station
>   bool m_shortGuardInterval;  //!< Flag if HT/VHT short guard interval is supported by the remote station
>   uint16_t m_guardInterval;   //!< HE Guard interval duration (in nanoseconds) supported by the remote station
>   uint8_t m_streams;          //!< Number of supported streams by the remote station
>   uint8_t m_ness;             //!< Number of streams in beamforming of the remote station
>   bool m_stbc;                //!< Flag if STBC is supported by the remote station
>   bool m_ldpc;                //!< Flag if LDPC is supported by the remote station
>   bool m_aggregation;         //!< Flag if MPDU aggregation is used by the remote station
>   bool m_greenfield;          //!< Flag if greenfield is supported by the remote station
>   bool m_shortPreamble;       //!< Flag if short PLCP preamble is supported by the remote station
>   bool m_shortSlotTime;       //!< Flag if short ERP slot time is supported by the remote station
>   bool m_qosSupported;        //!< Flag if HT is supported by the station
>   bool m_htSupported;         //!< Flag if HT is supported by the station
>   bool m_vhtSupported;        //!< Flag if VHT is supported by the station
>   bool m_heSupported;         //!< Flag if HE is supported by the station
> };
> 
> /**
>  * \brief hold per-remote-station state.
>  *
>  * The state in this class is used to keep track
>  * of association status if we are in an infrastructure
>  * network and to perform the selection of tx parameters
>  * on a per-packet basis.
>  *
>  * This class is typically subclassed and extended by
>  * rate control implementations
>  */
> struct WifiRemoteStation
> {
>   virtual ~WifiRemoteStation ();
>   WifiRemoteStationState *m_state;  //!< Remote station state
>   uint32_t m_ssrc;                  //!< STA short retry count
>   uint32_t m_slrc;                  //!< STA long retry count
>   uint8_t m_tid;                    //!< traffic ID
diff ../../NS3-WiGig/src/wifi/model/wifi-spectrum-phy-interface.h ../../ns-3-dev-git/src/wifi/model/wifi-spectrum-phy-interface.h
69c69
<   Ptr<SpectrumWifiPhy> m_spectrumWifiPhy; ///< spectrum PHY
---
>   Ptr<SpectrumWifiPhy> m_spectrumWifiPhy; ///< spectrum phy
diff ../../NS3-WiGig/src/wifi/model/wifi-spectrum-signal-parameters.cc ../../ns-3-dev-git/src/wifi/model/wifi-spectrum-signal-parameters.cc
23c23
< #include "wifi-ppdu.h"
---
> #include "ns3/packet.h"
39c39
<   ppdu = p.ppdu;
---
>   packet = p.packet;
diff ../../NS3-WiGig/src/wifi/model/wifi-spectrum-signal-parameters.h ../../ns-3-dev-git/src/wifi/model/wifi-spectrum-signal-parameters.h
29c29
< class WifiPpdu;
---
> class Packet;
54c54,57
<   Ptr<WifiPpdu> ppdu; ///< The PPDU being transmitted
---
>   /**
>    * The packet being transmitted with this signal
>    */
>   Ptr<Packet> packet;
diff ../../NS3-WiGig/src/wifi/model/wifi-tx-current-model.cc ../../ns-3-dev-git/src/wifi/model/wifi-tx-current-model.cc
67c67
<     .AddAttribute ("IdleCurrent", "The current in the IDLE state (in Ampere).",
---
>     .AddAttribute ("IdleCurrent", "The current in the IDLE state (in Watts).",
diff ../../NS3-WiGig/src/wifi/model/wifi-tx-current-model.h ../../ns-3-dev-git/src/wifi/model/wifi-tx-current-model.h
31c31
<  * \brief Model the transmit current as a function of the transmit power and mode
---
>  * \brief Modelize the transmit current as a function of the transmit power and mode
47c47
<    * \param txPowerDbm the nominal TX power in dBm
---
>    * \param txPowerDbm the nominal tx power in dBm
79c79
<  * If the TX current corresponding to a given nominal transmit power is known, the efficiency
---
>  * If the tx current corresponding to a given nominal transmit power is known, the efficiency
101,102c101,102
<   double m_voltage; ///< voltage in Volts
<   double m_idleCurrent; ///< idle current in Amperes
---
>   double m_voltage; ///< voltage
>   double m_idleCurrent; ///< idle current
diff ../../NS3-WiGig/src/wifi/model/wifi-tx-vector.cc ../../ns-3-dev-git/src/wifi/model/wifi-tx-vector.cc
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
21d19
<  *          Hany Assasa <hany.assasa@gmail.com>
29c27
<   : m_preamble (WIFI_PREAMBLE_LONG),
---
>   : m_preamble (WIFI_PREAMBLE_NONE),
37,38c35,36
<     m_bssColor (0),
<     m_modeInitialized (false)
---
>     m_modeInitialized (false),
>     m_txPowerLevelInitialized (false)
40,61d37
<   DoInitialize ();
< }
< 
< WifiTxVector::WifiTxVector (WifiMode mode,
<                             uint8_t powerLevel,
<                             WifiPreamble preamble,
<                             uint16_t channelWidth,
<                             bool aggregation)
<   : m_mode (mode),
<     m_txPowerLevel (powerLevel),
<     m_preamble (preamble),
<     m_channelWidth (channelWidth),
<     m_guardInterval (800),
<     m_nTx (1),
<     m_nss (1),
<     m_ness (0),
<     m_aggregation (aggregation),
<     m_stbc (false),
<     m_bssColor (0),
<     m_modeInitialized (true)
< {
<   DoInitialize ();
73,74c49
<                             bool stbc,
<                             uint8_t bssColor)
---
>                             bool stbc)
85,86c60,61
<     m_bssColor (bssColor),
<     m_modeInitialized (true)
---
>     m_modeInitialized (true),
>     m_txPowerLevelInitialized (true)
88,115d62
<   DoInitialize ();
< }
< 
< void
< WifiTxVector::DoInitialize (void)
< {
<   m_traingFieldLength = 0;
<   m_beamTrackingRequest = false;
<   m_lastRssi = 0;
<   m_numSts = 1;
<   m_numUsers = 1;
<   m_guardIntervalType = GI_NORMAL;
<   m_chBandwidth = 1;    // This corresponds to EDMG Channel 2 with 2.16 GHz bandwidth.
<   m_NCB = 1;
<   m_chAggregation = false;
<   m_nTxChains = 1;
<   m_shortLongLDCP = false;
<   m_edmgTrnLength = 0;
<   m_TrnSeqLen = TRN_SEQ_LENGTH_NORMAL;
<   m_isDMGBeacon = false;
<   m_trnRxPattern = QUASI_OMNI;
<   m_isControlTrailerPresent = false;
< }
< 
< bool
< WifiTxVector::GetModeInitialized (void) const
< {
<   return m_modeInitialized;
130a78,81
>   if (!m_txPowerLevelInitialized)
>     {
>       NS_FATAL_ERROR ("WifiTxVector txPowerLevel must be set before using");
>     }
192a144
>   m_txPowerLevelInitialized = true;
243,254d194
< void
< WifiTxVector::SetBssColor (uint8_t color)
< {
<   m_bssColor = color;
< }
< 
< uint8_t
< WifiTxVector::GetBssColor (void) const
< {
<   return m_bssColor;
< }
< 
258,261d197
<   if (!GetModeInitialized ())
<     {
<       return false;
<     }
305,663d240
< 
< //// WIGIG ////
< 
< void
< WifiTxVector::SetPacketType (PacketType type)
< {
<   m_packetType = type;
< }
< 
< PacketType
< WifiTxVector::GetPacketType (void) const
< {
<   return m_packetType;
< }
< 
< void
< WifiTxVector::SetTrainngFieldLength (uint8_t length)
< {
<   m_traingFieldLength = length;
< }
< 
< uint8_t
< WifiTxVector::GetTrainngFieldLength (void) const
< {
<   return m_traingFieldLength;
< }
< 
< void
< WifiTxVector::SetEDMGTrainingFieldLength (uint8_t length)
< {
<   m_edmgTrnLength = length;
< }
< 
< uint8_t
< WifiTxVector::GetEDMGTrainingFieldLength (void) const
< {
<   return m_edmgTrnLength;
< }
< 
< void
< WifiTxVector::RequestBeamTracking (void)
< {
<   m_beamTrackingRequest = true;
< }
< 
< bool
< WifiTxVector::IsBeamTrackingRequested (void) const
< {
<   return m_beamTrackingRequest;
< }
< 
< void
< WifiTxVector::SetLastRssi (uint8_t level)
< {
<   m_lastRssi = level;
< }
< 
< uint8_t
< WifiTxVector::GetLastRssi (void) const
< {
<   return m_lastRssi;
< }
< 
< void
< WifiTxVector::Set_NUM_STS (uint8_t num)
< {
<   NS_ASSERT (num > 0 && num <= 8);
<   m_numSts = num;
< }
< 
< uint8_t
< WifiTxVector::Get_NUM_STS (void) const
< {
<   return m_numSts;
< }
< 
< uint8_t
< WifiTxVector::Get_SC_EDMG_CEF (void) const
< {
<   if ((m_numSts == 1) || (m_numSts == 2))
<     {
<       return 1;
<     }
<   else if ((m_numSts == 3) || (m_numSts == 4))
<     {
<       return 2;
<     }
<   else
<     {
<       return 4;
<     }
< }
< 
< uint8_t
< WifiTxVector::Get_OFDM_EDMG_CEF (void) const
< {
<   if ((m_numSts == 1) || (m_numSts == 2))
<     {
<       return 2;
<     }
<   else if ((m_numSts == 3) || (m_numSts == 4))
<     {
<       return m_numSts;
<     }
<   else if ((m_numSts == 5) || (m_numSts == 6))
<     {
<       return 6;
<     }
<   else
<     {
<       return 8;
<     }
< }
< void
< WifiTxVector::SetNumUsers (uint8_t num)
< {
<   m_numUsers = num;
< }
< 
< uint8_t
< WifiTxVector::GetNumUsers (void) const
< {
<   return m_numUsers;
< }
< 
< void
< WifiTxVector::SetGaurdIntervalType (GuardIntervalLength gi)
< {
<   m_guardIntervalType = gi;
< }
< 
< GuardIntervalLength
< WifiTxVector::GetGaurdIntervalType (void) const
< {
<   return m_guardIntervalType;
< }
< 
< void
< WifiTxVector::SetPrimaryChannelNumber (uint8_t primaryCh)
< {
<   m_primaryChannel = primaryCh;
< }
< 
< uint8_t
< WifiTxVector::GetPrimaryChannelNumber (void) const
< {
<   return m_primaryChannel;
< }
< 
< void
< WifiTxVector::SetChBandwidth (EDMG_CHANNEL_CONFIG chConfig)
< {
<   m_primaryChannel = chConfig.primayChannel;
<   m_chBandwidth = chConfig.ch_bandwidth;
<   m_NCB = chConfig.NCB;
<   m_mask = chConfig.mask;
< }
< 
< void
< WifiTxVector::SetChannelConfiguration (uint8_t primaryCh, uint8_t bw)
< {
<   EDMG_CHANNEL_CONFIG chConfig = FindChannelConfiguration (primaryCh, bw);
<   m_primaryChannel = primaryCh;
<   m_channelWidth = chConfig.channelWidth;
<   SetChBandwidth (chConfig);
< }
< 
< uint8_t
< WifiTxVector::GetChBandwidth (void) const
< {
<   return m_chBandwidth;
< }
< 
< EDMG_TRANSMIT_MASK
< WifiTxVector::GetTransmitMask (void) const
< {
<   return m_mask;
< }
< 
< uint8_t
< WifiTxVector::GetNCB (void) const
< {
<   return m_NCB;
< }
< 
< void
< WifiTxVector::SetChannelAggregation (bool chAggregation)
< {
<   m_chAggregation = chAggregation;
< }
< 
< bool
< WifiTxVector::GetChannelAggregation (void) const
< {
<   return m_chAggregation;
< }
< 
< void
< WifiTxVector::SetNumberOfTxChains (uint8_t nTxChains)
< {
<   m_nTxChains = nTxChains;
< }
< 
< uint8_t
< WifiTxVector::GetNumberOfTxChains (void) const
< {
<   return m_nTxChains;
< }
< 
< void
< WifiTxVector::SetLdcpCwLength (bool cwLength)
< {
<   m_shortLongLDCP = cwLength;
< }
< 
< bool
< WifiTxVector::GetLdcpCwLength (void) const
< {
<   return m_shortLongLDCP;
< }
< void
< WifiTxVector::Set_TRN_SEQ_LEN (TRN_SEQ_LENGTH number)
< {
<   m_TrnSeqLen = number;
< }
< 
< TRN_SEQ_LENGTH
< WifiTxVector::Get_TRN_SEQ_LEN (void) const
< {
<   return m_TrnSeqLen;
< }
< 
< void
< WifiTxVector::Set_EDMG_TRN_P (uint8_t number)
< {
<   m_edmgTrnP = number;
< }
< 
< uint8_t
< WifiTxVector::Get_EDMG_TRN_P (void) const
< {
<   return m_edmgTrnP;
< }
< 
< void
< WifiTxVector::Set_EDMG_TRN_M (uint8_t number)
< {
<   m_edmgTrnM = number;
< }
< 
< uint8_t
< WifiTxVector::Get_EDMG_TRN_M (void) const
< {
<   return m_edmgTrnM;
< }
< 
< void
< WifiTxVector::Set_EDMG_TRN_N (uint8_t number)
< {
<   m_edmgTrnN = number;
< }
< 
< uint8_t
< WifiTxVector::Get_EDMG_TRN_N (void) const
< {
<   return m_edmgTrnN;
< }
< 
< uint8_t
< WifiTxVector::Get_TRN_T (void) const
< {
<   if (m_TrnSeqLen == TRN_SEQ_LENGTH_NORMAL)
<     {
<       return 2;
<     }
<   else if (m_TrnSeqLen == TRN_SEQ_LENGTH_LONG)
<     {
<       return 1;
<     }
<   else if (m_TrnSeqLen == TRN_SEQ_LENGTH_SHORT)
<     {
<       return 4;
<     }
<   else
<     NS_FATAL_ERROR ("Unvalid TRN Subfield Sequence Length");
< }
< 
< void
< WifiTxVector::Set_RxPerTxUnits (uint8_t number)
< {
<   m_rxPerTxUnits = number;
< }
< 
< uint8_t
< WifiTxVector::Get_RxPerTxUnits (void) const
< {
<   return m_rxPerTxUnits;
< }
< 
< void
< WifiTxVector::SetSender (Mac48Address sender)
< {
<   m_sender = sender;
< }
< 
< Mac48Address
< WifiTxVector::GetSender (void) const
< {
<   return m_sender;
< }
< 
< void
< WifiTxVector::SetDMGBeacon (bool beacon)
< {
<   m_isDMGBeacon = beacon;
< }
< 
< bool
< WifiTxVector::IsDMGBeacon (void) const
< {
<   return m_isDMGBeacon;
< }
< 
< void
< WifiTxVector::SetTrnRxPattern (rxPattern trnRxPattern)
< {
<   m_trnRxPattern = trnRxPattern;
< }
< 
< rxPattern
< WifiTxVector::GetTrnRxPattern (void) const
< {
<   return m_trnRxPattern;
< }
< 
< void
< WifiTxVector::SetBrpCdown (uint8_t brpCdown)
< {
<   m_brpCdown = brpCdown;
< }
< 
< uint8_t
< WifiTxVector::GetBrpCdown (void) const
< {
<   return m_brpCdown;
< }
< 
< void
< WifiTxVector::SetControlTrailerPresent (bool flag)
< {
<   m_isControlTrailerPresent = flag;
< }
< 
< bool
< WifiTxVector::IsControlTrailerPresent (void) const
< {
<   return m_isControlTrailerPresent;
< }
< //// WIGIG ////
diff ../../NS3-WiGig/src/wifi/model/wifi-tx-vector.h ../../ns-3-dev-git/src/wifi/model/wifi-tx-vector.h
4d3
<  * Copyright (c) 2015-2019 IMDEA Networks Institute
21d19
<  *          Hany Assasa <hany.assasa@gmail.com>
27,28d24
< #include "ns3/mac48-address.h"
< #include "ns3/nstime.h"
31,32d26
< #include "wifi-phy-standard.h"
< #include "wigig-data-types.h"
36,57d29
< /**
<  * The EDMG SC Guard Interval Length.
<  */
< enum GuardIntervalLength {
<   GI_SHORT  = 0,
<   GI_NORMAL = 1,
<   GI_LONG   = 2,
< };
< 
< /**
<  * EDMG TRN Sequence Length.
<  */
< enum TRN_SEQ_LENGTH {
<   TRN_SEQ_LENGTH_NORMAL = 0,
<   TRN_SEQ_LENGTH_LONG   = 1,
<   TRN_SEQ_LENGTH_SHORT  = 2,
< };
< 
< enum rxPattern {
<   QUASI_OMNI,
<   DIRECTIONAL
< };
62,63c34,35
<  * used for a transmission. See IEEE 802.11-2016 16.2.5 "Transmit PHY",
<  * and also 8.3.4.1 "PHY SAP peer-to-peer service primitive
---
>  * used for a transmission. See IEEE 802.11-2007 15.2.6 "Transmit PLCP",
>  * and also 15.4.4.2 "PMD_SAP peer-to-peer service primitive
81c53
<  * 16). TXVECTOR is defined also for the other PHYs, however they
---
>  * 15). TXVECTOR is defined also for the other PHYs, however they
99,112d70
<    * \param channelWidth the channel width in MHz
<    * \param aggregation enable or disable MPDU aggregation
<    */
<   WifiTxVector (WifiMode mode,
<                 uint8_t powerLevel,
<                 WifiPreamble preamble,
<                 uint16_t channelWidth,
<                 bool aggregation);
<   /**
<    * Create a TXVECTOR with the given parameters.
<    *
<    * \param mode WifiMode
<    * \param powerLevel transmission power level
<    * \param preamble preamble type
120d77
<    * \param bssColor the BSS color
131,136c88
<                 bool stbc,
<                 uint8_t bssColor = 0);
<   /**
<    * \returns whether mode has been initialized
<    */
<   bool GetModeInitialized (void) const;
---
>                 bool stbc);
144c96
<   * \param mode the payload WifiMode
---
>   * \param mode
154c106
<    * \param powerlevel the transmission power level
---
>    * \param powerlevel
164c116
<    * \param preamble the preamble type
---
>    * \param preamble
174c126
<    * \param channelWidth the channel width (in MHz)
---
>    * \param channelWidth
194c146
<    * \param nTx the number of TX antennas
---
>    * \param nTx
198c150
<    * \returns the number of spatial streams
---
>    * \returns the number of Nss
204c156
<    * \param nss the number of spatial streams
---
>    * \param nss
208c160
<    * \returns the number of extended spatial streams
---
>    * \returns the number of Ness
214c166
<    * \param ness the number of extended spatial streams
---
>    * \param ness
243,252d194
<    * Set the BSS color
<    * \param color the BSS color
<    */
<   void SetBssColor (uint8_t color);
<   /**
<    * Get the BSS color
<    * \return the BSS color
<    */
<   uint8_t GetBssColor (void) const;
<   /**
259,313c201
<   bool IsValid (void) const;
< 
<   //// WIGIG ////
<   /** IEEE 802.11ad DMG Tx Vector **/
< 
<   /**
<    * Set BRP Packet Type.
<    * \param type The type of BRP packet.
<    */
<   void SetPacketType (PacketType type);
<   /**
<    * Get BRP Packet Type.
<    * \return The type of BRP packet.
<    */
<   PacketType GetPacketType (void) const;
<   /**
<    * Set the length of te training field.
<    * \param length The length of the training field.
<    */
<   void SetTrainngFieldLength (uint8_t length);
<   /**
<    * Get the length of te training field.
<    * \return The length of te training field.
<    */
<   uint8_t GetTrainngFieldLength (void) const;
<   /**
<    * Request Beam Tracking.
<    */
<   void RequestBeamTracking (void);
<   /**
<    * \return True if Beam Tracking requested, otherwise false.
<    */
<   bool IsBeamTrackingRequested (void) const;
<   /**
<    * In the TXVECTOR, LAST_RSSI indicates the received power level of
<    * the last packet with a valid PHY header that was received a SIFS period
<    * before transmission of the current packet; otherwise, it is 0.
<    *
<    * In the RXVECTOR, LAST_RSSI indicates the value of the LAST_RSSI
<    * field from the PCLP header of the received packet. Valid values are
<    * integers in the range of 0 to 15:
<    * — Values of 2 to 14 represent power levels (–71+value×2) dBm.
<    * — A value of 15 represents power greater than or equal to –42 dBm.
<    * — A value of 1 represents power less than or equal to –68 dBm.
<    * — A value of 0 indicates that the previous packet was not received a
<    * SIFS period before the current transmission.
<    *
<    * \param length The length of the training field.
<    */
<   void SetLastRssi (uint8_t level);
<   /**
<    * Get the level of Last RSSI.
<    * \return The level of Last RSSI.
<    */
<   uint8_t GetLastRssi (void) const;
---
>    bool IsValid (void) const;
315,563d202
< public:
<   uint8_t remainingTrnUnits;
<   uint8_t remainingTrnSubfields;
<   uint8_t remainingTSubfields;
<   uint8_t remainingPSubfields;
<   uint8_t repeatSameAWVSubfield;
<   uint8_t repeatSameAWVUnit;
<   Time edmgTrnSubfieldDuration;
< 
<   /** IEEE 802.11ay EDMG Tx Vector **/
< 
<   /**
<    * Indicates the number of space-time streams. Value is an integer in the
<    * range 1 to 8 for an SU PPDU. For an MU PPDU, values are integers in the
<    * range 1 to 2 per user in the TXVECTOR, and 0 to 2 per user in the RXVECTOR.
<    * The sum of NUM_STS over all users is in the range of 1 to 8.
<    * \param num
<    */
<   void Set_NUM_STS (uint8_t num);
<   uint8_t Get_NUM_STS (void) const;
<   /**
<    * Indicates the number of EDMG CEF Fields transmitted when using SC mode.
<    * Depends on the number of space-time streams as specified in 29.12.3.3.
<    */
<   uint8_t Get_SC_EDMG_CEF (void) const;
<   /**
<    * Indicates the number of EDMG CEF Fields transmitted when using OFDM mode.
<    * Depends on the number of space-time streams as specified in 29.12.3.3.
<    */
<   uint8_t Get_OFDM_EDMG_CEF (void) const;
<   /**
<    * Indicates the number of users with nonzero space-time streams.
<    * Integer: range 1 to 8 in case of 1 space-time stream per user,
<    * range 1 to 4 in case of 2 space-time streams per user.
<    * \param num
<    */
<   void SetNumUsers (uint8_t num);
<   uint8_t GetNumUsers (void) const;
<   /**
<    * Indicates the length of the guard interval.
<    * Enumerated Type:
<    * - ShortGI
<    * - NormalGI
<    * - LongGI
<    * \param gi
<    */
<   void SetGaurdIntervalType (GuardIntervalLength gi);
<   GuardIntervalLength GetGaurdIntervalType (void) const;
<   /**
<    * Set the primary 2.16 GHz channel number.
<    * \param primaryCh The pimrary 2.16 GHz channel number.
<    */
<   void SetPrimaryChannelNumber (uint8_t primaryCh);
<   /**
<    * Get the primary 2.16 channel number.
<    * \return The primary 2.16 channel number.
<    */
<   uint8_t GetPrimaryChannelNumber (void) const;
<   /**
<    * Set channels on which the PPDU is transmitted and the value of the BW field in the EDMG Header-A.
<    * In the RXVECTOR, indicates the value of the BW field in the EDMG Header-A of a received PPDU.
<    * This parameter is a bitmap. Valid values for this parameter and the CHANNEL_AGGREGATION parameter
<    *  are indicated in Table 28-21, Table 28-22 and Table 28-23.
<    * \param bandwdith
<    */
<   void SetChBandwidth (EDMG_CHANNEL_CONFIG bandwdith);
<   /**
<    * \return The current EDMG channel bandwidth.
<    */
<   uint8_t GetChBandwidth (void) const;
<   /**
<    * Set channel configuration for the current transmission.
<    * \param primaryCh The primary 2.16 GHz channel number.
<    * \param bw The channels over which the PPDU is transmitted.
<    */
<   void SetChannelConfiguration (uint8_t primaryCh, uint8_t bw);
<   /**
<    * \return the current transmit mask corresponding to the current channel configuration.
<    */
<   EDMG_TRANSMIT_MASK GetTransmitMask (void) const;
<   /**
<    * Get the Number of contiguous 2.16 GHz channels, NCB = 1 for 2.16 GHz
<    * and 2.16+2.16 GHz, NCB = 2 for 4.32 GHz and 4.32+4.32 GHz, N CB = 3 for
<    * 6.48 GHz, and NCB = 4 for 8.64 GHz channel
<    * \return The number of continous channels.
<    */
<   uint8_t GetNCB (void) const;
<   /**
<    * Indicate whether Channel Aggregation is used or not.
<    * \param chAggregation
<    */
<   void SetChannelAggregation (bool chAggregation);
<   /**
<    * True if Channel Aggregation is used and false otherwise.
<    * \return if channel aggregation is used.
<    */
<   bool GetChannelAggregation (void) const;
<   /**
<    * Set the number of TX Chains used for transmission of the packet.
<    * \param nTxChains
<    */
<   void SetNumberOfTxChains (uint8_t nTxChains);
<   /**
<    * Return the number of tx chains used for transmission of the packet.
<    * \return  number of active tx chains.
<    */
<   uint8_t GetNumberOfTxChains (void) const;
<   /**
<    * Set the LDCP codeword length. Set to 0 for LDPC
<    * codeword of length 672, 624, 504, or 468. Set to 1 for LDPC codeword of
<    * length 1344, 1248, 1008, or 936.
<    * \param cwlength Short or Long LDCP CW length.
<    */
<   void SetLdcpCwLength (bool cwLength);
<   /**
<    * Get the LDCP codeword length. 0 means LDPC
<    * codeword of length 672, 624, 504, or 468. 1 means LDPC codeword of
<    * length 1344, 1248, 1008, or 936.
<    * \return Short or Long LDCP CW length.
<    */
<   bool GetLdcpCwLength (void) const;
<   /**
<    * Set the number of EDMG TRN units in the training field.
<    * \param length The number of EDMG TRN units.
<    */
<   void SetEDMGTrainingFieldLength (uint8_t length);
<   /**
<    * Get the number of EDMG TRN units in the training field.
<    * \return The number of EDMG TRN units.
<    */
<   uint8_t GetEDMGTrainingFieldLength (void) const;
<   /**
<    * Indicates the number of TRN subfields at the beginning of a TRN-Unit
<    * which are transmitted with the same AWV.
<    * \param number
<    */
<   void Set_EDMG_TRN_P (uint8_t number);
<   /**
<    * Returns the number of TRN subfields at the beginning of a TRN-Unit
<    * which are transmitted with the same AWV as defined in 29.9.2.2.3
<    * \param number
<    */
<   uint8_t Get_EDMG_TRN_P (void) const;
<   /**
<    * If EDMG_PACKET_TYPE is TRN-T-PACKET or TRN-R/T-PACKET, indicates the
<    * number of TRN subfields in a TRN-Unit that may be used for transmit
<    * training, as defined in 29.9.2.2.
<    * The parameter is reserved if TRN-LEN is 0. The parameter is reserved
<    * if EDMG_PACKET_TYPE is TRN-R-PACKET.
<    * \param number
<    */
<   void Set_EDMG_TRN_M (uint8_t number);
<   /**
<    * Returns the number of TRN Subfields used for transmit training as defined in 29.9.2.2.3.
<    * \param number
<    */
<   uint8_t Get_EDMG_TRN_M (void) const;
<   /**
<    * Indicates the number of consecutive TRN subfields within the EDMG
<    * TRN-Unit M of a TRN-Unit which are transmitted using the same AWV.
<    * \param number
<    */
<   void Set_EDMG_TRN_N (uint8_t number);
<   /**
<    * Returns the number of consecutive TRN subfields within the EDMG-Unit M
<    * which are transmitted using the same AWV as defined in 29.9.2.2.3
<    * \param number
<    */
<   uint8_t Get_EDMG_TRN_N (void) const;
<   /**
<    * Indicates the length of the Golay sequence to be used to transmit the
<    * TRN subfields present in the TRN field of the PPDU. Enumerated Type:
<    * - Normal: The Golay sequence has a length of 128×NCB.
<    * - Long: The Golay sequence has a length of 256× NCB.
<    * - Short: The Golay sequence has a length of 64× NCB.
<    * NCB represents the integer number of contiguous 2.16 GHz channels over
<    * which the TRN subfield is transmitted and 1 ≤ NCB ≤ 4.
<    * \param number
<    */
<   void Set_TRN_SEQ_LEN (TRN_SEQ_LENGTH number);
<   /**
<    * Returns the length of the Golay sequence to be used to transmit the
<    * TRN subfields present in the TRN field of the PPDU.
<    * \param number
<    */
<   TRN_SEQ_LENGTH Get_TRN_SEQ_LEN (void) const;
<   /**
<    * If EDMG_PACKET_TYPE is TRN-T-PACKET or TRN-R/T-PACKET, returns the number of
<    * TRN subfields repeated at the start of the TRN field with the same AWV as the
<    * rest of the packet and used as a transional period before the training.
<    * Can have the values 1,2 or 4 depending on the value of m_TrnSeqLen so that
<    * the duration of transmission of the T subfields remains the same.
<    */
<   uint8_t Get_TRN_T (void) const;
<   /**
<    * If EDMG_PACKET_TYPE is TRN-R/T-PACKET, indicates the number of
<    * TRN units repeated with the same AWV in order to perform RX training
<    * at the responder.
<    * \param number
<    */
<   void Set_RxPerTxUnits (uint8_t number);
<   /**
<    * Returns the number of TRN units repeated with the same AWV in order
<    * to perform RX training at the responder as defined in 29.9.2.2.3.
<    */
<   uint8_t Get_RxPerTxUnits (void) const;
<   /**
<    * Set the MAC address of the sender of the packet.
<    */
<   void SetSender (Mac48Address sender);
<   /**
<    * Returns the MAC address of the sender of the packet.
<   */
<   Mac48Address GetSender (void) const;
<   /**
<    * Whether the transmitted packet is a DMG beacon or not.
<    */
<   void SetDMGBeacon (bool beacon);
<   /**
<    * Returns whether the transmitted packet is a DMG beacon or not.
<   */
<   bool IsDMGBeacon (void) const;
<   /**
<    * Indicates the receive antenna pattern to be used
<    * when measuring TRN-Units present in a received PPDU.
<   */
<   void SetTrnRxPattern (rxPattern trnRxPattern);
<   /**
<    * Returns the receive antenna pattern to be used
<    * when measuring TRN-Units present in a received PPDU.
<   */
<   rxPattern GetTrnRxPattern (void) const;
<   /**
<    * Sets the BRP CDOWN value of the packet in EDMG BRP Packets
<    */
<   void SetBrpCdown (uint8_t brpCdown);
<   /**
<    * Returns the BRP CDOWN value in EDMG BRP Packets.
<   */
<   uint8_t GetBrpCdown (void) const;
<   /**
<    * Sets the flag for presence of a control trailer in the packet.
<    */
<   void SetControlTrailerPresent (bool flag);
<   /**
<    * Returns whether a control trailer is present in the packet.
<   */
<   bool IsControlTrailerPresent (void) const;
<   //// WIGIG ////
566,567d204
<   void DoInitialize(void);
< 
582d218
<   uint8_t  m_bssColor;           /**< BSS color */
586,621d221
< 
<   //// WIGIG ////
<   /** IEEE 802.11ad DMG Tx Vector **/
<   PacketType  m_packetType;               //!< BRP-RX, BRP-TX or BRP-RX/TX packet.
<   uint8_t     m_traingFieldLength;        //!< The length of the training field (Number of TRN-Units).
<   bool        m_beamTrackingRequest;      //!< Flag to indicate the need for beam tracking.
<   uint8_t     m_lastRssi;                 //!< Last Received Signal Strength Indicator.
< 
<   /** IEEE 802.11ay EDMG Tx Vector **/
< 
<   /* EDMG Header-A */
<   uint8_t m_numSts;                       //!< The number of space-time streams.
<   uint8_t m_numUsers;
<   GuardIntervalLength m_guardIntervalType;
<   uint8_t m_chBandwidth;
<   uint8_t m_primaryChannel;               //!< The primary 2.16 GHz channel.
<   uint8_t m_NCB;                          //!< Number of bonded channels.
<   EDMG_TRANSMIT_MASK m_mask;              //!< The EDMG transmit mask (Represent the numfer of channels).
<   bool m_chAggregation;                   //!< Flag to indicate whether channel aggregation is used or not.
<   uint8_t m_nTxChains;                    //!< The number of Tx Chains used for the transmission of the packet.
<   bool m_shortLongLDCP;                   //!< Flag to indicate whether the LDCP codewords have a short or long length.
<   uint8_t m_edmgTrnLength;                //!< The length of the EDMG training field (Number of EDMG TRN-Units).
<   uint8_t m_edmgTrnP;                     //!< Number of TRN Subfields repeated at the start of a unit with the same AWV.
<   uint8_t m_edmgTrnM;                     //!< In BRP-TX and BRP-RX/TX packets the number of TRN Subfields that can be used for training.
<   uint8_t m_edmgTrnN;                     //!< In BRP-TX packets the number of TRN Subfields in a unit transmitted with the same AWV.
<   TRN_SEQ_LENGTH m_TrnSeqLen;             //!< Length of the Golay Sequence used in the TRN Subfields.
<   uint8_t m_rxPerTxUnits;                 //!< In BRP-RX/TX packets the number of times a TRN unit is repeated for RX training at the responder.
<   rxPattern m_trnRxPattern;               //!< Indicates the receive antenna pattern to be used when measuring TRN-Units present in a received PPDU.
< 
<   /* Helper values needed for PHY processing of TRN fields */
<   Mac48Address m_sender;                  //!< MAC address of the sender of the packet.
<   bool m_isDMGBeacon;                     //!< Flag that specifies whether the transmitted packet is a DMG beacon or not.
<   uint8_t m_brpCdown;                     //!< BRP CDOWN value of the packet
<   //// WIGIG ////
<   bool m_isControlTrailerPresent;           //!< Flag that specifies if a control trailer is added at the end of the packet
< 
627,628c227,228
<  * \param os the output stream
<  * \param v the WifiTxVector to stringify
---
>  * \param os
>  * \param v
630c230
<  * \return ouput stream
---
>  * \return ostream
diff ../../NS3-WiGig/src/wifi/model/wifi-utils.cc ../../ns-3-dev-git/src/wifi/model/wifi-utils.cc
20a21
> #include "ns3/packet.h"
26,28d26
< #include "wifi-net-device.h"
< #include "ht-configuration.h"
< #include "he-configuration.h"
30d27
< #include "ampdu-subframe-header.h"
71,89d67
< ConvertGuardIntervalToNanoSeconds (WifiMode mode, const Ptr<WifiNetDevice> device)
< {
<   uint16_t gi = 800;
<   if (mode.GetModulationClass () == WIFI_MOD_CLASS_HE)
<     {
<       Ptr<HeConfiguration> heConfiguration = device->GetHeConfiguration ();
<       NS_ASSERT (heConfiguration); //If HE modulation is used, we should have a HE configuration attached
<       gi = static_cast<uint16_t> (heConfiguration->GetGuardInterval ().GetNanoSeconds ());
<     }
<   else if (mode.GetModulationClass () == WIFI_MOD_CLASS_HT || mode.GetModulationClass () == WIFI_MOD_CLASS_VHT)
<     {
<       Ptr<HtConfiguration> htConfiguration = device->GetHtConfiguration ();
<       NS_ASSERT (htConfiguration); //If HT/VHT modulation is used, we should have a HT configuration attached
<       gi = htConfiguration->GetShortGuardIntervalSupported () ? 400 : 800;
<     }
<   return gi;
< }
< 
< uint16_t
108,233d85
< uint16_t
< GetChannelWidthForTransmission (WifiMode mode, uint16_t maxSupportedChannelWidth)
< {
<   WifiModulationClass modulationClass = mode.GetModulationClass ();
<   if (maxSupportedChannelWidth > 20
<       && (modulationClass == WifiModulationClass::WIFI_MOD_CLASS_OFDM // all non-HT OFDM control and management frames
<           || modulationClass == WifiModulationClass::WIFI_MOD_CLASS_ERP_OFDM)) // special case of beacons at 2.4 GHz
<     {
<       return 20;
<     }
<   //at 2.4 GHz basic rate can be non-ERP DSSS
<   if (modulationClass == WifiModulationClass::WIFI_MOD_CLASS_DSSS
<       || modulationClass == WifiModulationClass::WIFI_MOD_CLASS_HR_DSSS)
<     {
<       return 22;
<     }
<   return maxSupportedChannelWidth;
< }
< 
< WifiPreamble
< GetWiGigPreamble (WifiModulationClass modulation)
< {
<   switch (modulation)
<     {
<     case WIFI_MOD_CLASS_DMG_CTRL:
<       return WIFI_PREAMBLE_DMG_CTRL;
< 
<     case WIFI_MOD_CLASS_DMG_SC:
<       return WIFI_PREAMBLE_DMG_SC;
< 
<     case WIFI_MOD_CLASS_DMG_OFDM:
<       return WIFI_PREAMBLE_DMG_OFDM;
< 
<     case WIFI_MOD_CLASS_EDMG_CTRL:
<       return WIFI_PREAMBLE_EDMG_CTRL;
< 
<     case WIFI_MOD_CLASS_EDMG_SC:
<       return WIFI_PREAMBLE_EDMG_SC;
< 
<     case WIFI_MOD_CLASS_EDMG_OFDM:
<       return WIFI_PREAMBLE_EDMG_OFDM;
< 
<     default:
<       NS_FATAL_ERROR ("unsupported modulation class");
<     }
< }
< 
< WifiPreamble
< GetPreambleForTransmission (WifiModulationClass modulation, bool useShortPreamble, bool useGreenfield)
< {
<   //// WIGIG ////
<   if (modulation == WIFI_MOD_CLASS_DMG_CTRL)
<     {
<       return WIFI_PREAMBLE_DMG_CTRL;
<     }
<   else if (modulation == WIFI_MOD_CLASS_DMG_SC)
<     {
<       return WIFI_PREAMBLE_DMG_SC;
<     }
<   else if (modulation == WIFI_MOD_CLASS_DMG_OFDM)
<     {
<       return WIFI_PREAMBLE_DMG_OFDM;
<     }
<   else if (modulation == WIFI_MOD_CLASS_EDMG_CTRL)
<     {
<       return WIFI_PREAMBLE_EDMG_CTRL;
<     }
<   else if (modulation == WIFI_MOD_CLASS_EDMG_SC)
<     {
<       return WIFI_PREAMBLE_EDMG_SC;
<     }
<   else if (modulation == WIFI_MOD_CLASS_EDMG_OFDM)
<     {
<       return WIFI_PREAMBLE_EDMG_OFDM;
<     }
<   //// WIGIG ////
<   else if (modulation == WIFI_MOD_CLASS_HE)
<     {
<       return WIFI_PREAMBLE_HE_SU;
<     }
<   else if (modulation == WIFI_MOD_CLASS_VHT)
<     {
<       return WIFI_PREAMBLE_VHT_SU;
<     }
<   else if (modulation == WIFI_MOD_CLASS_HT && useGreenfield)
<     {
<       //If protection for Greenfield is used we go for HT_MF preamble which is the default protection for GF format defined in the standard.
<       return WIFI_PREAMBLE_HT_GF;
<     }
<   else if (modulation == WIFI_MOD_CLASS_HT)
<     {
<       return WIFI_PREAMBLE_HT_MF;
<     }
<   else if (useShortPreamble)
<     {
<       return WIFI_PREAMBLE_SHORT;
<     }
<   else
<     {
<       return WIFI_PREAMBLE_LONG;
<     }
< }
< 
< bool
< IsAllowedControlAnswerModulationClass (WifiModulationClass modClassReq, WifiModulationClass modClassAnswer)
< {
<   switch (modClassReq)
<     {
<     case WIFI_MOD_CLASS_DSSS:
<       return (modClassAnswer == WIFI_MOD_CLASS_DSSS);
<     case WIFI_MOD_CLASS_HR_DSSS:
<       return (modClassAnswer == WIFI_MOD_CLASS_DSSS || modClassAnswer == WIFI_MOD_CLASS_HR_DSSS);
<     case WIFI_MOD_CLASS_ERP_OFDM:
<       return (modClassAnswer == WIFI_MOD_CLASS_DSSS || modClassAnswer == WIFI_MOD_CLASS_HR_DSSS || modClassAnswer == WIFI_MOD_CLASS_ERP_OFDM);
<     case WIFI_MOD_CLASS_OFDM:
<       return (modClassAnswer == WIFI_MOD_CLASS_OFDM);
<     case WIFI_MOD_CLASS_HT:
<     case WIFI_MOD_CLASS_VHT:
<     case WIFI_MOD_CLASS_HE:
<       return true;
<     default:
<       NS_FATAL_ERROR ("Modulation class not defined");
<       return false;
<     }
< }
< 
248c100,112
<   blockAck.SetType (type);
---
>   if (type == BASIC_BLOCK_ACK)
>     {
>       blockAck.SetType (BASIC_BLOCK_ACK);
>     }
>   else if (type == COMPRESSED_BLOCK_ACK)
>     {
>       blockAck.SetType (COMPRESSED_BLOCK_ACK);
>     }
>   else if (type == MULTI_TID_BLOCK_ACK)
>     {
>       //Not implemented
>       NS_ASSERT (false);
>     }
253,263c117
< GetBlockAckRequestSize (BlockAckType type)
< {
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_CTL_BACKREQ);
<   CtrlBAckRequestHeader bar;
<   bar.SetType (type);
<   return hdr.GetSize () + bar.GetSerializedSize () + 4;
< }
< 
< uint32_t
< GetRtsSize (bool addControlTrailer)
---
> GetRtsSize (void)
267,270c121
<   uint32_t rtsSize = rts.GetSize () + 4;
<   if (addControlTrailer)
<     rtsSize+= 18;
<   return rtsSize;
---
>   return rts.GetSize () + 4;
308,343d158
< }
< 
< Time
< GetPpduMaxTime (WifiPreamble preamble)
< {
<   Time duration;
< 
<   switch (preamble)
<     {
<     //// WIGIG ////
<     case WIFI_PREAMBLE_DMG_CTRL:
<     case WIFI_PREAMBLE_DMG_SC:
<     case WIFI_PREAMBLE_DMG_OFDM:
<     case WIFI_PREAMBLE_EDMG_CTRL:
<     case WIFI_PREAMBLE_EDMG_SC:
<     case WIFI_PREAMBLE_EDMG_OFDM:
<       duration = MilliSeconds (2);
<       break;
<     //// WIGIG ////
<     case WIFI_PREAMBLE_HT_GF:
<       duration = MicroSeconds (10000);
<       break;
<     case WIFI_PREAMBLE_HT_MF:
<     case WIFI_PREAMBLE_VHT_SU:
<     case WIFI_PREAMBLE_VHT_MU:
<     case WIFI_PREAMBLE_HE_SU:
<     case WIFI_PREAMBLE_HE_ER_SU:
<     case WIFI_PREAMBLE_HE_MU:
<     case WIFI_PREAMBLE_HE_TB:
<       duration = MicroSeconds (5484);
<       break;
<     default:
<       duration = MicroSeconds (0);
<       break;
<     }
<   return duration;
diff ../../NS3-WiGig/src/wifi/model/wifi-utils.h ../../ns-3-dev-git/src/wifi/model/wifi-utils.h
25,26d24
< #include "wifi-preamble.h"
< #include "wifi-mode.h"
30d27
< class WifiNetDevice;
47c44
<  * \param db the value in dB
---
>  * \param db
49c46
<  * \return ratio in linear scale
---
>  * \return ratio
63c60
<  * \param ratio the ratio in linear scale
---
>  * \param ratio
65c62
<  * \return the value in dB
---
>  * \return dB
79c76
<  * Convert the guard interval to nanoseconds based on the WifiMode.
---
>  * Convert the guard interval to nanoseconds based on the wifimode.
81,90c78
<  * \param mode the WifiMode
<  * \param device pointer to the WifiNetDevice object
<  *
<  * \return the guard interval duration in nanoseconds
<  */
< uint16_t ConvertGuardIntervalToNanoSeconds (WifiMode mode, const Ptr<WifiNetDevice> device);
< /**
<  * Convert the guard interval to nanoseconds based on the WifiMode.
<  *
<  * \param mode the WifiMode
---
>  * \param mode the wifimode
98,127c86
<  * Return the preamble to be used for the WiGig transmission.
<  *
<  * \param modulation the modulation selected for the transmission
<  *
<  * \return the preamble to be used for the transmission
<  */
< WifiPreamble GetWiGigPreamble (WifiModulationClass modulation);
< /**
<  * Return the preamble to be used for the transmission.
<  *
<  * \param modulation the modulation selected for the transmission
<  * \param useShortPreamble whether short preamble should be used
<  * \param useGreenfield whether HT Greenfield should be used
<  *
<  * \return the preamble to be used for the transmission
<  */
< WifiPreamble GetPreambleForTransmission (WifiModulationClass modulation, bool useShortPreamble = false, bool useGreenfield = false);
< /**
<  * Return the channel width that corresponds to the selected mode (instead of
<  * letting the PHY's default channel width). This is especially useful when using
<  * non-HT modes with HT/VHT/HE capable stations (with default width above 20 MHz).
<  *
<  * \param mode selected WifiMode
<  * \param maxSupportedChannelWidth maximum channel width supported by the PHY layer
<  * \return channel width adapted to the selected mode
<  */
< uint16_t GetChannelWidthForTransmission (WifiMode mode, uint16_t maxSupportedChannelWidth);
< /**
<  * Return whether the modulation class of the selected mode for the
<  * control answer frame is allowed.
---
>  * Return the total ACK size (including FCS trailer).
129,139c88
<  * \param modClassReq modulation class of the request frame
<  * \param modClassAnswer modulation class of the answer frame
<  *
<  * \return true if the modulation class of the selected mode for the
<  * control answer frame is allowed, false otherwise
<  */
< bool IsAllowedControlAnswerModulationClass (WifiModulationClass modClassReq, WifiModulationClass modClassAnswer);
< /**
<  * Return the total Ack size (including FCS trailer).
<  *
<  * \return the total Ack size in bytes
---
>  * \return the total ACK size
143c92
<  * Return the total BlockAck size (including FCS trailer).
---
>  * Return the total Block ACK size (including FCS trailer).
145,146c94,95
<  * \param type the BlockAck type
<  * \return the total BlockAck size in bytes
---
>  * \param type the Block ACK type
>  * \return the total Block ACK size
150,156d98
<  * Return the total BlockAckRequest size (including FCS trailer).
<  *
<  * \param type the BlockAckRequest type
<  * \return the total BlockAckRequest size in bytes
<  */
< uint32_t GetBlockAckRequestSize (BlockAckType type);
< /**
159c101
<  * \return the total RTS size in bytes
---
>  * \return the total RTS size
161c103
< uint32_t GetRtsSize (bool addControlTrailer = false);
---
> uint32_t GetRtsSize (void);
165c107
<  * \return the total CTS size in bytes
---
>  * \return the total CTS size
171c113
<  * \param winsize the size of the sequence number window
---
>  * \param winsize the size of the sequence number window (currently default is 64)
180c122
<  * \param packet the packet to add a trailer to
---
>  * \param packet
193,205d134
< /**
<  * Get the maximum PPDU duration (see Section 10.14 of 802.11-2016) for
<  * the PHY layers defining the aPPDUMaxTime characteristic (HT, VHT and HE).
<  * Return zero otherwise.
<  *
<  * \param preamble the preamble type
<  *
<  * \return the maximum PPDU duration, if defined, and zero otherwise
<  */
< Time GetPpduMaxTime (WifiPreamble preamble);
< 
< /// Size of the space of sequence numbers
< const uint16_t SEQNO_SPACE_SIZE = 4096;
207,208d135
< /// Size of the half the space of sequence numbers (used to determine old packets)
< const uint16_t SEQNO_SPACE_HALF_SIZE = SEQNO_SPACE_SIZE / 2;
Only in ../../NS3-WiGig/src/wifi/model: wigig-data-types.cc
Only in ../../NS3-WiGig/src/wifi/model: wigig-data-types.h
diff ../../NS3-WiGig/src/wifi/model/yans-error-rate-model.cc ../../ns-3-dev-git/src/wifi/model/yans-error-rate-model.cc
199c199
<                                     mode.GetPhyRate (txVector), //PHY rate
---
>                                     mode.GetPhyRate (txVector), //phy rate
208c208
<                                     mode.GetPhyRate (txVector), //PHY rate
---
>                                     mode.GetPhyRate (txVector), //phy rate
220c220
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
231c231
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
245c245
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
256c256
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
270c270
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
282c282
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
293c293
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
307c307
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
319c319
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
334c334
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
346c346
<                                    mode.GetPhyRate (txVector), //PHY rate
---
>                                    mode.GetPhyRate (txVector), //phy rate
diff ../../NS3-WiGig/src/wifi/model/yans-error-rate-model.h ../../ns-3-dev-git/src/wifi/model/yans-error-rate-model.h
44c44
<  *      approximations for DQPSK transmission bit error rate", G. Ferrari and G.E. Corazza
---
>  *      approximations for dqpsk transmission bit error rate", G. Ferrari and G.E. Corazza
47c47
<  *      performance of the IEEE 802.11b complementary code-key signal sets",
---
>  *      performance of the ieee 802.11b complementarycode-key signal sets",
diff ../../NS3-WiGig/src/wifi/model/yans-wifi-channel.cc ../../ns-3-dev-git/src/wifi/model/yans-wifi-channel.cc
20a21
> #include "ns3/packet.h"
32,33d32
< #include "wifi-ppdu.h"
< #include "wifi-psdu.h"
86c85
< YansWifiChannel::Send (Ptr<YansWifiPhy> sender, Ptr<const WifiPpdu> ppdu, double txPowerDbm) const
---
> YansWifiChannel::Send (Ptr<YansWifiPhy> sender, Ptr<const Packet> packet, double txPowerDbm, Time duration) const
88c87
<   NS_LOG_FUNCTION (this << sender << ppdu << txPowerDbm);
---
>   NS_LOG_FUNCTION (this << sender << packet << txPowerDbm << duration.GetSeconds ());
106c105
<           Ptr<WifiPpdu> copy = Copy (ppdu);
---
>           Ptr<Packet> copy = packet->Copy ();
120c119
<                                           (*i), copy, rxPowerDbm);
---
>                                           (*i), copy, rxPowerDbm, duration);
126c125
< YansWifiChannel::Receive (Ptr<YansWifiPhy> phy, Ptr<WifiPpdu> ppdu, double rxPowerDbm)
---
> YansWifiChannel::Receive (Ptr<YansWifiPhy> phy, Ptr<Packet> packet, double rxPowerDbm, Time duration)
128,136c127,128
<   NS_LOG_FUNCTION (phy << ppdu << rxPowerDbm);
<   // Do no further processing if signal is too weak
<   // Current implementation assumes constant RX power over the PPDU duration
<   if ((rxPowerDbm + phy->GetRxGain ()) < phy->GetRxSensitivity ())
<     {
<       NS_LOG_INFO ("Received signal too weak to process: " << rxPowerDbm << " dBm");
<       return;
<     }
<   phy->StartReceivePreamble (ppdu, DbmToW (rxPowerDbm + phy->GetRxGain ()));
---
>   NS_LOG_FUNCTION (phy << packet << rxPowerDbm << duration.GetSeconds ());
>   phy->StartReceivePreambleAndHeader (packet, DbmToW (rxPowerDbm + phy->GetRxGain ()), duration);
diff ../../NS3-WiGig/src/wifi/model/yans-wifi-channel.h ../../ns-3-dev-git/src/wifi/model/yans-wifi-channel.h
34d33
< class WifiPpdu;
78,80c77,80
<    * \param sender the PHY object from which the packet is originating.
<    * \param ppdu the PPDU to send
<    * \param txPowerDbm the TX power associated to the packet, in dBm
---
>    * \param sender the phy object from which the packet is originating.
>    * \param packet the packet to send
>    * \param txPowerDbm the tx power associated to the packet, in dBm
>    * \param duration the transmission duration associated with the packet
84c84
<    * attempts to deliver the PPDU to all other YansWifiPhy objects
---
>    * attempts to deliver the packet to all other YansWifiPhy objects
87c87
<   void Send (Ptr<YansWifiPhy> sender, Ptr<const WifiPpdu> ppdu, double txPowerDbm) const;
---
>   void Send (Ptr<YansWifiPhy> sender, Ptr<const Packet> packet, double txPowerDbm, Time duration) const;
110c110
<    * bit of the PPDU has arrived.
---
>    * bit of the packet has arrived.
113,114c113,115
<    * \param ppdu the PPDU being sent
<    * \param txPowerDbm the TX power associated to the packet being sent (dBm)
---
>    * \param packet the packet being sent
>    * \param txPowerDbm the tx power associated to the packet being sent (dBm)
>    * \param duration the transmission duration associated with the packet being sent
116c117
<   static void Receive (Ptr<YansWifiPhy> receiver, Ptr<WifiPpdu> ppdu, double txPowerDbm);
---
>   static void Receive (Ptr<YansWifiPhy> receiver, Ptr<Packet> packet, double txPowerDbm, Time duration);
diff ../../NS3-WiGig/src/wifi/model/yans-wifi-phy.cc ../../ns-3-dev-git/src/wifi/model/yans-wifi-phy.cc
23a24
> #include "ns3/packet.h"
26d26
< #include "wifi-ppdu.h"
78c78
< YansWifiPhy::StartTx (Ptr<WifiPpdu> ppdu)
---
> YansWifiPhy::StartTx (Ptr<Packet> packet, WifiTxVector txVector, Time txDuration)
80,81d79
<   NS_LOG_FUNCTION (this << ppdu);
<   WifiTxVector txVector = ppdu->GetTxVector ();
83c81
<   m_channel->Send (this, ppdu, GetTxPowerForTransmission (txVector) + GetTxGain ());
---
>   m_channel->Send (this, packet, GetPowerDbm (txVector.GetTxPowerLevel ()) + GetTxGain (), txDuration);
diff ../../NS3-WiGig/src/wifi/model/yans-wifi-phy.h ../../ns-3-dev-git/src/wifi/model/yans-wifi-phy.h
31d30
< class WifiPpdu;
60,63d58
<   // Implementation of pure virtual method.
<   void StartTx (Ptr<WifiPpdu> ppdu);
<   virtual Ptr<Channel> GetChannel (void) const;
< 
69a65,76
> 
>   /**
>    * \param packet the packet to send
>    * \param txVector the TXVECTOR that has tx parameters such as mode, the transmission mode to use to send
>    *        this packet, and txPowerLevel, a power level to use to send this packet. The real transmission
>    *        power is calculated as txPowerMin + txPowerLevel * (txPowerMax - txPowerMin) / nTxLevels
>    * \param txDuration duration of the transmission.
>    */
>   void StartTx (Ptr<Packet> packet, WifiTxVector txVector, Time txDuration);
> 
>   virtual Ptr<Channel> GetChannel (void) const;
> 
