Only in ../../ns-3-dev-git/src/wifi/test: 80211b.plt
diff ../../NS3-WiGig/src/wifi/test/block-ack-test-suite.cc ../../ns-3-dev-git/src/wifi/test/block-ack-test-suite.cc
22d21
< #include "ns3/string.h"
25,35d23
< #include "ns3/packet.h"
< #include "ns3/wifi-net-device.h"
< #include "ns3/ap-wifi-mac.h"
< #include "ns3/wifi-mac-header.h"
< #include "ns3/mobility-helper.h"
< #include "ns3/yans-wifi-helper.h"
< #include "ns3/packet-socket-server.h"
< #include "ns3/packet-socket-client.h"
< #include "ns3/packet-socket-helper.h"
< #include "ns3/config.h"
< #include "ns3/pointer.h"
254,547d241
< /**
<  * \ingroup wifi-test
<  * \ingroup tests
<  *
<  * \brief Test for the originator block ack window
<  */
< class OriginatorBlockAckWindowTest : public TestCase
< {
< public:
<   OriginatorBlockAckWindowTest ();
< private:
<   virtual void DoRun ();
< };
< 
< OriginatorBlockAckWindowTest::OriginatorBlockAckWindowTest ()
<   : TestCase ("Check the correctness of the originator block ack window")
< {
< }
< 
< void
< OriginatorBlockAckWindowTest::DoRun (void)
< {
<   uint16_t winSize = 16;
<   uint16_t startingSeq = 4090;
< 
<   OriginatorBlockAckAgreement agreement (Mac48Address ("00:00:00:00:00:01"), 0);
<   agreement.SetBufferSize (winSize);
<   agreement.SetStartingSequence (startingSeq);
<   agreement.InitTxWindow ();
< 
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.GetWinSize (), winSize, "Incorrect window size");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.GetWinStart (), startingSeq, "Incorrect winStart");
<   // check that all the elements in the window are cleared
<   for (uint16_t i = 0; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), false, "Not all flags are cleared after initialization");
<     }
< 
<   // Notify the acknowledgment of 5 packets
<   WifiMacHeader hdr;
<   hdr.SetType (WIFI_MAC_QOSDATA);
<   Ptr<WifiMacQueueItem> mpdu = Create<WifiMacQueueItem> (Create<Packet> (), hdr);
<   uint16_t seqNumber = startingSeq;
<   mpdu->GetHeader ().SetSequenceNumber (seqNumber);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   // the current window must look like this:
<   //
<   // |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|
<   //            ^
<   //            |
<   //           HEAD
< 
<   startingSeq = (seqNumber + 1) % SEQNO_SPACE_SIZE;
<   NS_TEST_EXPECT_MSG_EQ (agreement.GetStartingSequence (), startingSeq, "Incorrect starting sequence after 5 acknowledgments");
<   for (uint16_t i = 0; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), false, "Not all flags are cleared after 5 acknowledgments");
<     }
< 
<   // the next MPDU is not acknowledged, hence the window is blocked while the
<   // subsequent 4 MPDUs are acknowledged
<   ++seqNumber %= SEQNO_SPACE_SIZE;
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   // the current window must look like this:
<   //
<   // |0|0|0|0|0|0|1|1|1|1|0|0|0|0|0|0|
<   //            ^
<   //            |
<   //           HEAD
< 
<   NS_TEST_EXPECT_MSG_EQ (agreement.GetStartingSequence (), startingSeq, "Incorrect starting sequence after 1 unacknowledged MPDU");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (0), false, "Incorrect flag after 1 unacknowledged MPDU");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (1), true, "Incorrect flag after 1 unacknowledged MPDU");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (2), true, "Incorrect flag after 1 unacknowledged MPDU");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (3), true, "Incorrect flag after 1 unacknowledged MPDU");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (4), true, "Incorrect flag after 1 unacknowledged MPDU");
<   for (uint16_t i = 5; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), false, "Incorrect flag after 1 unacknowledged MPDU");
<     }
< 
<   // the missing MPDU is now acknowledged; the window moves forward and the starting
<   // sequence number is the one of the first unacknowledged MPDU
<   mpdu->GetHeader ().SetSequenceNumber (startingSeq);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   // the current window must look like this:
<   //
<   // |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|
<   //                      ^
<   //                      |
<   //                     HEAD
< 
<   startingSeq = (seqNumber + 1) % SEQNO_SPACE_SIZE;
<   NS_TEST_EXPECT_MSG_EQ (agreement.GetStartingSequence (), startingSeq, "Incorrect starting sequence after acknowledgment of missing MPDU");
<   for (uint16_t i = 0; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), false, "Not all flags are cleared after acknowledgment of missing MPDU");
<     }
< 
<   // Now, create a hole of 3 MPDUs before 4 acknowledged MPDUs, another hole of 2 MPDUs before 3 acknowledged MPDUs
<   seqNumber = (seqNumber + 4) % SEQNO_SPACE_SIZE;
<   mpdu->GetHeader ().SetSequenceNumber (seqNumber);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   seqNumber = (seqNumber + 3) % SEQNO_SPACE_SIZE;
<   mpdu->GetHeader ().SetSequenceNumber (seqNumber);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   mpdu->GetHeader ().SetSequenceNumber (++seqNumber %= SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   // the current window must look like this:
<   //
<   // |1|0|0|1|1|1|0|0|0|0|0|0|0|1|1|1|
<   //                      ^
<   //                      |
<   //                     HEAD
< 
<   NS_TEST_EXPECT_MSG_EQ (agreement.GetStartingSequence (), startingSeq, "Incorrect starting sequence after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (0), false, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (1), false, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (2), false, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (3), true, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (4), true, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (5), true, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (6), true, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (7), false, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (8), false, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (9), true, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (10), true, "Incorrect flag after 3 unacknowledged MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (11), true, "Incorrect flag after 3 unacknowledged MPDUs");
<   for (uint16_t i = 12; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), false, "Incorrect flag after 3 unacknowledged MPDUs");
<     }
< 
<   // the transmission of an MPDU beyond the current window (by 2 positions) is
<   // notified, hence the window moves forward 2 positions
<   seqNumber = (agreement.m_txWindow.GetWinEnd () + 2) % SEQNO_SPACE_SIZE;
<   mpdu->GetHeader ().SetSequenceNumber (seqNumber);
<   agreement.NotifyTransmittedMpdu (mpdu);
< 
<   // the current window must look like this:
<   //
<   // |1|0|0|1|1|1|0|0|0|0|0|0|0|1|1|1|
<   //                          ^
<   //                          |
<   //                         HEAD
< 
<   startingSeq = (startingSeq + 2) % SEQNO_SPACE_SIZE;
<   NS_TEST_EXPECT_MSG_EQ (agreement.GetStartingSequence (), startingSeq,
<                          "Incorrect starting sequence after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (0), false, "Incorrect flag after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (1), true, "Incorrect flag after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (2), true, "Incorrect flag after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (3), true, "Incorrect flag after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (4), true, "Incorrect flag after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (5), false, "Incorrect flag after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (6), false, "Incorrect flag after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (7), true, "Incorrect flag after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (8), true, "Incorrect flag after transmitting an MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (9), true, "Incorrect flag after transmitting an MPDU beyond the current window");
<   for (uint16_t i = 10; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), false, "Incorrect flag after transmitting an MPDU beyond the current window");
<     }
< 
<   // another MPDU is transmitted beyond the current window. Now, the window advances
<   // until the first unacknowledged MPDU
<   seqNumber = (agreement.m_txWindow.GetWinEnd () + 1) % SEQNO_SPACE_SIZE;
<   mpdu->GetHeader ().SetSequenceNumber (seqNumber);
<   agreement.NotifyTransmittedMpdu (mpdu);
< 
<   // the current window must look like this:
<   //
<   // |0|0|0|1|1|1|0|0|0|0|0|0|0|0|0|0|
<   //    ^
<   //    |
<   //   HEAD
< 
<   startingSeq = (startingSeq + 5) % SEQNO_SPACE_SIZE;
<   NS_TEST_EXPECT_MSG_EQ (agreement.GetStartingSequence (), startingSeq,
<                          "Incorrect starting sequence after transmitting another MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (0), false, "Incorrect flag after transmitting another MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (1), false, "Incorrect flag after transmitting another MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (2), true, "Incorrect flag after transmitting another MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (3), true, "Incorrect flag after transmitting another MPDU beyond the current window");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (4), true, "Incorrect flag after transmitting another MPDU beyond the current window");
<   for (uint16_t i = 5; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), false, "Incorrect flag after transmitting another MPDU beyond the current window");
<     }
< 
<   // the MPDU next to winStart is discarded, hence the window advances to make it an old packet.
<   // Since the subsequent MPDUs have been acknowledged, the window advances further.
<   seqNumber = (startingSeq + 1) % SEQNO_SPACE_SIZE;
<   mpdu->GetHeader ().SetSequenceNumber (seqNumber);
<   agreement.NotifyDiscardedMpdu (mpdu);
< 
<   // the current window must look like this:
<   //
<   // |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|
<   //              ^
<   //              |
<   //             HEAD
< 
<   startingSeq = (startingSeq + 5) % SEQNO_SPACE_SIZE;
<   NS_TEST_EXPECT_MSG_EQ (agreement.GetStartingSequence (), startingSeq,
<                          "Incorrect starting sequence after discarding an MPDU");
<   for (uint16_t i = 0; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), false, "Incorrect flag after discarding an MPDU");
<     }
< 
<   // Finally, check that the window correctly advances when the MPDU with the starting sequence number
<   // is acknowledged after being the only unacknowledged MPDU
<   for (uint16_t i = 1; i < winSize; i++)
<     {
<       mpdu->GetHeader ().SetSequenceNumber ((startingSeq + i) % SEQNO_SPACE_SIZE);
<       agreement.NotifyAckedMpdu (mpdu);
<     }
< 
<   // the current window must look like this:
<   //
<   // |1|1|1|1|1|1|0|1|1|1|1|1|1|1|1|1|
<   //              ^
<   //              |
<   //             HEAD
< 
<   NS_TEST_EXPECT_MSG_EQ (agreement.GetStartingSequence (), startingSeq,
<                          "Incorrect starting sequence after acknowledging all but the first MPDU");
<   NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (0), false, "Incorrect flag after acknowledging all but the first MPDU");
<   for (uint16_t i = 1; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), true, "Incorrect flag after acknowledging all but the first MPDU");
<     }
< 
<   // acknowledge the first MPDU
<   mpdu->GetHeader ().SetSequenceNumber (startingSeq % SEQNO_SPACE_SIZE);
<   agreement.NotifyAckedMpdu (mpdu);
< 
<   // the current window must look like this:
<   //
<   // |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|
<   //              ^
<   //              |
<   //             HEAD
< 
<   startingSeq = (startingSeq + winSize) % SEQNO_SPACE_SIZE;
<   NS_TEST_EXPECT_MSG_EQ (agreement.GetStartingSequence (), startingSeq,
<                          "Incorrect starting sequence after acknowledging the first MPDU");
<   for (uint16_t i = 0; i < winSize; i++)
<     {
<       NS_TEST_EXPECT_MSG_EQ (agreement.m_txWindow.At (i), false, "Incorrect flag after acknowledging the first MPDU");
<     }
< }
< 
615,934d308
< 
< /**
<  * \ingroup wifi-test
<  * \ingroup tests
<  *
<  * \brief Test for Block Ack Policy with aggregation disabled
<  *
<  * This test aims to check the Block Ack policy when A-MPDU aggregation is disabled.
<  * In this case, a QoS station can transmit multiple QoS data frames before requesting
<  * a Block Ack through a Block Ack Request frame. If the AC is granted a non-null TXOP
<  * limit, MPDUs can be separated by a SIFS.
<  *
<  * In this test, an HT STA sends 14 packets to an HT AP. The ack policy selector is
<  * configured so that a Block Ack is requested once 8 (= 0.125 * 64) MPDUs are sent
<  * in addition to the MPDU having the starting sequence number. The block ack threshold
<  * is set to 2, hence a block ack agreement is established when there are at least two
<  * packets in the EDCA queue.
<  *
<  * When the TXOP limit is null:
<  * - the first packet is sent with Normal Ack policy because the BA agreement has not
<  *   been established yet (there are no queued packets when the first one arrives);
<  * - packets from the 2nd to the 10th are sent with Block Ack policy (and hence
<  *   are not immediately acknowledged);
<  * - after the 10th packet, a Block Ack Request is sent, followed by a Block Ack;
<  * - the remaining 4 packets are sent with Block Ack policy (and hence
<  *   are not immediately acknowledged);
<  * - the last packet is followed by a Block Ack Request because there are no more
<  *   packets in the EDCA queue and hence a response is needed independently of
<  *   the number of outstanding MPDUs.
<  *
<  * When the TXOP is not null (and long enough to include the transmission of all packets):
<  * - the first packet is sent with Normal Ack policy because the BA agreement has not
<  *   been established yet (there are no queued packets when the first one arrives);
<  * - the second packet is sent with Normal Ack Policy because the first packet sent in
<  *   a TXOP shall request an immediate response and no previous MPDUs have to be
<  *   acknowledged;
<  * - packets from the 3rd to the 11th are sent with Block Ack policy (and hence
<  *   are not immediately acknowledged);
<  * - after the 11th packet, a Block Ack Request is sent, followed by a Block Ack;
<  * - the remaining 3 packets are sent with Block Ack policy (and hence
<  *   are not immediately acknowledged);
<  * - the last packet is followed by a Block Ack Request because there are no more
<  *   packets in the EDCA queue and hence a response is needed independently of
<  *   the number of outstanding MPDUs.
<  */
< class BlockAckAggregationDisabledTest : public TestCase
< {
<   /**
<   * Keeps the maximum duration among all TXOPs
<   */
<   struct TxopDurationTracer
<   {
<     /**
<      * Callback for the TxopTrace trace
<      * \param startTime TXOP start time
<      * \param duration TXOP duration
<      */
<     void Trace (Time startTime, Time duration);
<     Time m_max {Seconds (0)};  ///< max TXOP duration
<   };
< 
< public:
<   /**
<    * \brief Constructor
<    * \param txop true for non-null TXOP limit
<    */
<   BlockAckAggregationDisabledTest (bool txop);
<   virtual ~BlockAckAggregationDisabledTest ();
< 
<   virtual void DoRun (void);
< 
< 
< private:
<   bool m_txop; ///< true for non-null TXOP limit
<   uint32_t m_received; ///< received packets
<   uint16_t m_txTotal; ///< transmitted data packets
<   uint16_t m_txSinceBar; ///< packets transmitted since the agreement was established
<                          ///< or the last block ack was received
<   uint16_t m_nBar; ///< transmitted BlockAckReq frames
<   uint16_t m_nBa; ///< received BlockAck frames
< 
<   /**
<    * Function to trace packets received by the server application
<    * \param context the context
<    * \param p the packet
<    * \param adr the address
<    */
<   void L7Receive (std::string context, Ptr<const Packet> p, const Address &adr);
<   /**
<    * Callback invoked when PHY transmits a packet
<    * \param context the context
<    * \param p the packet
<    * \param power the tx power
<    */
<   void Transmit (std::string context, Ptr<const Packet> p, double power);
<   /**
<    * Callback invoked when PHY receives a packet
<    * \param context the context
<    * \param p the packet
<    */
<   void Receive (std::string context, Ptr<const Packet> p);
< };
< 
< void
< BlockAckAggregationDisabledTest::TxopDurationTracer::Trace (Time startTime, Time duration)
< {
<   if (duration > m_max)
<     {
<       m_max = duration;
<     }
< }
< 
< BlockAckAggregationDisabledTest::BlockAckAggregationDisabledTest (bool txop)
<   : TestCase ("Test case for Block Ack Policy with aggregation disabled"),
<     m_txop (txop),
<     m_received (0),
<     m_txTotal (0),
<     m_txSinceBar (0),
<     m_nBar (0),
<     m_nBa (0)
< {
< }
< 
< BlockAckAggregationDisabledTest::~BlockAckAggregationDisabledTest ()
< {
< }
< 
< void
< BlockAckAggregationDisabledTest::L7Receive (std::string context, Ptr<const Packet> p, const Address &adr)
< {
<   if (p->GetSize () == 1400)
<     {
<       m_received++;
<     }
< }
< 
< void
< BlockAckAggregationDisabledTest::Transmit (std::string context, Ptr<const Packet> p, double power)
< {
<   WifiMacHeader hdr;
<   p->PeekHeader (hdr);
< 
<   if (m_txSinceBar == 9 || m_txTotal == 14)
<     {
<       NS_TEST_ASSERT_MSG_EQ (hdr.IsBlockAckReq (), true, "Didn't get a BlockAckReq when expected");
<     }
<   else
<     {
<       NS_TEST_ASSERT_MSG_EQ (hdr.IsBlockAckReq (), false, "Got a BlockAckReq when not expected");
<     }
< 
<   if (hdr.IsQosData ())
<     {
<       m_txTotal++;
<       if (hdr.IsQosBlockAck ())
<         {
<           m_txSinceBar++;
<         }
< 
<       if (!m_txop)
<         {
<           NS_TEST_EXPECT_MSG_EQ ((m_txTotal == 1 || hdr.IsQosBlockAck ()), true, "Unexpected QoS ack policy");
<         }
<       else
<         {
<           NS_TEST_EXPECT_MSG_EQ ((m_txTotal <= 2 || hdr.IsQosBlockAck ()), true, "Unexpected QoS ack policy");
<         }
<     }
<   else if (hdr.IsBlockAckReq ())
<     {
<       m_txSinceBar = 0;
<       m_nBar++;
<     }
< }
< 
< void
< BlockAckAggregationDisabledTest::Receive (std::string context, Ptr<const Packet> p)
< {
<   WifiMacHeader hdr;
<   p->PeekHeader (hdr);
< 
<   if (hdr.IsBlockAck ())
<     {
<       m_nBa++;
<     }
< }
< 
< void
< BlockAckAggregationDisabledTest::DoRun (void)
< {
<   NodeContainer wifiStaNode;
<   wifiStaNode.Create (1);
< 
<   NodeContainer wifiApNode;
<   wifiApNode.Create (1);
< 
<   YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
<   YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
<   phy.SetChannel (channel.Create ());
< 
<   WifiHelper wifi;
<   wifi.SetStandard (WIFI_PHY_STANDARD_80211a);
<   wifi.SetAckPolicySelectorForAc (AC_BE, "ns3::ConstantWifiAckPolicySelector",
<                                   "BaThreshold", DoubleValue (0.125));
<   wifi.SetRemoteStationManager ("ns3::IdealWifiManager");
< 
<   WifiMacHelper mac;
<   Ssid ssid = Ssid ("ns-3-ssid");
<   mac.SetType ("ns3::StaWifiMac",
<                "QosSupported", BooleanValue (true),
<                "Ssid", SsidValue (ssid),
<                /* setting blockack threshold for sta's BE queue */
<                "BE_BlockAckThreshold", UintegerValue (2),
<                "ActiveProbing", BooleanValue (false));
< 
<   NetDeviceContainer staDevices;
<   staDevices = wifi.Install (phy, mac, wifiStaNode);
< 
<   mac.SetType ("ns3::ApWifiMac",
<                "QosSupported", BooleanValue (true),
<                "Ssid", SsidValue (ssid),
<                "BeaconGeneration", BooleanValue (true));
< 
<   NetDeviceContainer apDevices;
<   apDevices = wifi.Install (phy, mac, wifiApNode);
< 
<   MobilityHelper mobility;
<   Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
< 
<   positionAlloc->Add (Vector (0.0, 0.0, 0.0));
<   positionAlloc->Add (Vector (1.0, 0.0, 0.0));
<   mobility.SetPositionAllocator (positionAlloc);
< 
<   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
<   mobility.Install (wifiApNode);
<   mobility.Install (wifiStaNode);
< 
<   Ptr<WifiNetDevice> ap_device = DynamicCast<WifiNetDevice> (apDevices.Get (0));
<   Ptr<WifiNetDevice> sta_device = DynamicCast<WifiNetDevice> (staDevices.Get (0));
< 
<   // Disable A-MPDU aggregation
<   sta_device->GetMac ()->SetAttribute ("BE_MaxAmpduSize", UintegerValue (0));
<   TxopDurationTracer txopTracer;
< 
<   if (m_txop)
<     {
<       PointerValue ptr;
<       sta_device->GetMac ()->GetAttribute ("BE_Txop", ptr);
<       ptr.Get<QosTxop> ()->TraceConnectWithoutContext ("TxopTrace", MakeCallback (&TxopDurationTracer::Trace, &txopTracer));
< 
<       // set the TXOP limit on BE AC
<       Ptr<RegularWifiMac> ap_mac = DynamicCast<RegularWifiMac> (ap_device->GetMac ());
<       NS_ASSERT (ap_mac);
<       ap_mac->GetAttribute ("BE_Txop", ptr);
<       ptr.Get<QosTxop> ()->SetTxopLimit (MicroSeconds (4800));
<     }
< 
<   PacketSocketAddress socket;
<   socket.SetSingleDevice (sta_device->GetIfIndex ());
<   socket.SetPhysicalAddress (ap_device->GetAddress ());
<   socket.SetProtocol (1);
< 
<   // give packet socket powers to nodes.
<   PacketSocketHelper packetSocket;
<   packetSocket.Install (wifiStaNode);
<   packetSocket.Install (wifiApNode);
< 
<   // the first client application generates a single packet, which is sent
<   // with the normal ack policy because there are no other packets queued
<   Ptr<PacketSocketClient> client1 = CreateObject<PacketSocketClient> ();
<   client1->SetAttribute ("PacketSize", UintegerValue (1400));
<   client1->SetAttribute ("MaxPackets", UintegerValue (1));
<   client1->SetAttribute ("Interval", TimeValue (MicroSeconds (0)));
<   client1->SetRemote (socket);
<   wifiStaNode.Get (0)->AddApplication (client1);
<   client1->SetStartTime (Seconds (1));
<   client1->SetStopTime (Seconds (3.0));
< 
<   // the second client application generates 13 packets. Even if when the first
<   // packet is queued the queue is empty, the first packet is not transmitted
<   // immediately, but the EDCAF waits for the next slot boundary. At that time,
<   // other packets have been queued, hence a BA agreement is established first.
<   Ptr<PacketSocketClient> client2 = CreateObject<PacketSocketClient> ();
<   client2->SetAttribute ("PacketSize", UintegerValue (1400));
<   client2->SetAttribute ("MaxPackets", UintegerValue (13));
<   client2->SetAttribute ("Interval", TimeValue (MicroSeconds (0)));
<   client2->SetRemote (socket);
<   wifiStaNode.Get (0)->AddApplication (client2);
<   client2->SetStartTime (Seconds (1.5));
<   client2->SetStopTime (Seconds (3.0));
< 
<   Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer> ();
<   server->SetLocal (socket);
<   wifiApNode.Get (0)->AddApplication (server);
<   server->SetStartTime (Seconds (0.0));
<   server->SetStopTime (Seconds (4.0));
< 
<   Config::Connect ("/NodeList/*/ApplicationList/0/$ns3::PacketSocketServer/Rx", MakeCallback (&BlockAckAggregationDisabledTest::L7Receive, this));
<   Config::Connect ("/NodeList/0/DeviceList/0/Phy/PhyTxBegin", MakeCallback (&BlockAckAggregationDisabledTest::Transmit, this));
<   Config::Connect ("/NodeList/0/DeviceList/0/Phy/PhyRxBegin", MakeCallback (&BlockAckAggregationDisabledTest::Receive, this));
< 
<   Simulator::Stop (Seconds (5));
<   Simulator::Run ();
< 
<   Simulator::Destroy ();
< 
<   // The client applications generate 14 packets, so we expect that the wifi PHY
<   // layer transmits 14 MPDUs, the server application receives 14 packets, and
<   // two BARs are transmitted.
<   NS_TEST_EXPECT_MSG_EQ (m_txTotal, 14, "Unexpected number of transmitted packets");
<   NS_TEST_EXPECT_MSG_EQ (m_received, 14, "Unexpected number of received packets");
<   NS_TEST_EXPECT_MSG_EQ (m_nBar, 2, "Unexpected number of Block Ack Requests");
<   NS_TEST_EXPECT_MSG_EQ (m_nBa, 2, "Unexpected number of Block Ack Responses");
<   if (m_txop)
<     {
<       NS_TEST_EXPECT_MSG_LT (txopTracer.m_max, MicroSeconds (4800), "TXOP duration exceeded!");
<       NS_TEST_EXPECT_MSG_GT (txopTracer.m_max, MicroSeconds (3008), "The maximum TXOP duration is too short!");
<     }
< }
< 
952d325
<   AddTestCase (new OriginatorBlockAckWindowTest, TestCase::QUICK);
954,955d326
<   AddTestCase (new BlockAckAggregationDisabledTest (false), TestCase::QUICK);
<   AddTestCase (new BlockAckAggregationDisabledTest (true), TestCase::QUICK);
diff ../../NS3-WiGig/src/wifi/test/channel-access-manager-test.cc ../../ns-3-dev-git/src/wifi/test/channel-access-manager-test.cc
24c24
< #include "ns3/qos-txop.h"
---
> #include "ns3/txop.h"
29d28
< template <typename TxopType>
38,39c37
< template <typename TxopType>
< class TxopTest : public TxopType
---
> class TxopTest : public Txop
45,46c43,44
<    * \param test the test channel access manager
<    * \param i the index of the Txop
---
>    * \param test the test DCF manager
>    * \param i the DCF state
48c46
<   TxopTest (ChannelAccessManagerTest<TxopType> *test, uint32_t i);
---
>   TxopTest (ChannelAccessManagerTest *test, uint32_t i);
59,62c57
<   friend class ChannelAccessManagerTest<TxopType>;
< 
<   /// Inherited
<   void DoDispose (void);
---
>   friend class ChannelAccessManagerTest;
66,67c61,62
<   /// ExpectedBackoff structure
<   struct ExpectedBackoff
---
>   /// ExpectedCollision structure
>   struct ExpectedCollision
72c67
<   typedef std::list<struct ExpectedBackoff> ExpectedBackoffs; //!< expected backoffs typedef
---
>   typedef std::list<struct ExpectedCollision> ExpectedCollisions; //!< expected collisions typedef
74,75c69,70
<   ExpectedBackoffs m_expectedInternalCollision; //!< expected backoff due to an internal collision
<   ExpectedBackoffs m_expectedBackoff; //!< expected backoff (not due to an internal collision)
---
>   ExpectedCollisions m_expectedInternalCollision; //!< expected internal collisions
>   ExpectedCollisions m_expectedCollision; //!< expected collision
78,81d72
<   /**
<    * \returns true if access has been requested for this function and
<    *          has not been granted already, false otherwise.
<    */
83,85d73
<   /**
<    * Notify that access request has been received.
<    */
87,89d74
<   /**
<    * Notify the Txop that access has been granted.
<    */
91,93d75
<   /**
<    * Notify the Txop that internal collision has occurred.
<    */
95,106c77
<   /**
<    * Generate a new backoff now.
<    */
<   void GenerateBackoff (void);
<   /**
<    * Check if the Txop has frames to transmit.
<    * \return true if the Txop has frames to transmit.
<    */
<   bool HasFramesToTransmit (void);
<   /**
<    * When a channel switching occurs, enqueued packets are removed.
<    */
---
>   void NotifyCollision (void);
108,111d78
<   /**
<    * When sleep operation occurs, if there is a pending packet transmission,
<    * it will be reinserted to the front of the queue.
<    */
113,115d79
<   /**
<    * When wake up operation occurs, channel access will be restarted.
<    */
116a81
>   void DoDispose (void);
118,119c83,84
<   ChannelAccessManagerTest<TxopType> *m_test; //!< the test DCF/EDCA manager
<   uint32_t m_i; //!< the index of the Txop
---
>   ChannelAccessManagerTest *m_test; //!< the test DCF manager
>   uint32_t m_i; //!< the DCF state
136,139c101
<    * This function indicates whether Simulator::Now is in the CF period.
<    *
<    * \return true if Simulator::Now is in CF period,
<    *         false otherwise
---
>    * This function indicates whether it is the CF period.
151c113
<  * \brief Channel Access Manager Test
---
>  * \brief Dcf Manager Test
153d114
< template <typename TxopType>
162c123
<    * \param i the index of the Txop
---
>    * \param i the DCF state
167c128
<    * \param i the index of the Txop
---
>    * \param i the DCF state
171,172c132,133
<    * Generate backoff function
<    * \param i the index of the Txop
---
>    * Notify collision function
>    * \param i the DCF state
174c135
<   void GenerateBackoff (uint32_t i);
---
>   void NotifyCollision (uint32_t i);
177c138
<    * \param i the index of the Txop
---
>    * \param i the DCF state
188c149
<    * \param ackTimeoutValue the Ack timeout value
---
>    * \param ackTimeoutValue the ack timeout value
192c153
<    * Add Txop function
---
>    * Add DCF state function
195c156
<   void AddTxop (uint32_t aifsn);
---
>   void AddDcfState (uint32_t aifsn);
200c161
<    * \param time the expected time
---
>    * \param time the expectedtime
206,207c167,168
<    * Expect generate backoff function
<    * \param time the expected time
---
>    * Expect internal collision function
>    * \param time the expectedtime
211,217c172
<   void ExpectBackoff (uint64_t time, uint32_t nSlots, uint32_t from);
<   /**
<    * Schedule a check that the channel access manager is busy or idle
<    * \param time the expected time
<    * \param busy whether the manager is expected to be busy
<    */
<   void ExpectBusy (uint64_t time, bool busy);
---
>   void ExpectCollision (uint64_t time, uint32_t nSlots, uint32_t from);
219,225c174,175
<    * Perform check that channel access manager is busy or idle
<    * \param busy whether expected state is busy
<    */
<   void DoCheckBusy (bool busy);
<   /**
<    * Add receive OK event function
<    * \param at the event time
---
>    * Add expect collision function
>    * \param at
230c180
<    * Add receive error event function for error at end of frame
---
>    * Add receive error event function
236,242d185
<    * Add receive error event function for error during frame
<    * \param at the event time
<    * \param duration the duration
<    * \param timeUntilError the time after event time to force the error
<    */
<   void AddRxErrorEvt (uint64_t at, uint64_t duration, uint64_t timeUntilError);
<   /**
267c210
<    * Add Ack timeout reset function
---
>    * Add ack timeout reset function
276c219
<    * \param from the index of the requesting Txop
---
>    * \param from
281c224
<    * Add access request with Ack timeout
---
>    * Add access request with ack timeout
283,285c226,228
<    * \param txTime the transmit time
<    * \param expectedGrantTime the expected grant time
<    * \param from the index of the requesting Txop
---
>    * \param txTime DoAccessRequest txTime
>    * \param expectedGrantTime DoAccessRequest expectedGrantTime
>    * \param from DoAccessRequest TxopTest
292,295c235,238
<    * \param txTime the transmit time
<    * \param expectedGrantTime the expected grant time
<    * \param ackDelay the delay of the Ack after txEnd
<    * \param from the index of the requesting Txop
---
>    * \param txTime DoAccessRequest txTime
>    * \param expectedGrantTime DoAccessRequest expectedGrantTime
>    * \param ackDelay is delay of the ack after txEnd
>    * \param from DoAccessRequest TxopTest
300,302c243,245
<    * Add access request with successful Ack
<    * \param txTime the transmit time
<    * \param expectedGrantTime the expected grant time
---
>    * Add access request with successful ack
>    * \param txTime DoAccessRequest txTime
>    * \param expectedGrantTime DoAccessRequest expectedGrantTime
305c248
<   void DoAccessRequest (uint64_t txTime, uint64_t expectedGrantTime, Ptr<TxopTest<TxopType>> state);
---
>   void DoAccessRequest (uint64_t txTime, uint64_t expectedGrantTime, Ptr<TxopTest> state);
325c268
<   typedef std::vector<Ptr<TxopTest<TxopType>>> TxopTests; //!< the TXOP tests typedef
---
>   typedef std::vector<Ptr<TxopTest> > TxopTests; //!< the TXOP tests typedef
328,330c271,273
<   Ptr<ChannelAccessManager> m_ChannelAccessManager; //!< the channel access manager
<   TxopTests m_txop; //!< the vector of Txop test instances
<   uint32_t m_ackTimeoutValue; //!< the Ack timeout value
---
>   Ptr<ChannelAccessManager> m_ChannelAccessManager; //!< the DCF manager
>   TxopTests m_txop; //!< the TXOP
>   uint32_t m_ackTimeoutValue; //!< the ack timeout value
333d275
< template <typename TxopType>
335c277
< TxopTest<TxopType>::QueueTx (uint64_t txTime, uint64_t expectedGrantTime)
---
> TxopTest::QueueTx (uint64_t txTime, uint64_t expectedGrantTime)
340,341c282
< template <typename TxopType>
< TxopTest<TxopType>::TxopTest (ChannelAccessManagerTest<TxopType> *test, uint32_t i)
---
> TxopTest::TxopTest (ChannelAccessManagerTest *test, uint32_t i)
348d288
< template <typename TxopType>
350c290
< TxopTest<TxopType>::DoDispose (void)
---
> TxopTest::DoDispose (void)
356d295
< template <typename TxopType>
358c297
< TxopTest<TxopType>::IsAccessRequested (void) const
---
> TxopTest::IsAccessRequested (void) const
363d301
< template <typename TxopType>
365c303
< TxopTest<TxopType>::NotifyAccessRequested (void)
---
> TxopTest::NotifyAccessRequested (void)
370d307
< template <typename TxopType>
372c309
< TxopTest<TxopType>::NotifyAccessGranted (void)
---
> TxopTest::NotifyAccessGranted (void)
378d314
< template <typename TxopType>
380c316
< TxopTest<TxopType>::NotifyInternalCollision (void)
---
> TxopTest::NotifyInternalCollision (void)
385d320
< template <typename TxopType>
387,394c322
< TxopTest<TxopType>::GenerateBackoff (void)
< {
<   m_test->GenerateBackoff (m_i);
< }
< 
< template <typename TxopType>
< bool
< TxopTest<TxopType>::HasFramesToTransmit (void)
---
> TxopTest::NotifyCollision (void)
396c324
<   return !m_expectedGrants.empty ();
---
>   m_test->NotifyCollision (m_i);
399d326
< template <typename TxopType>
401c328
< TxopTest<TxopType>::NotifyChannelSwitching (void)
---
> TxopTest::NotifyChannelSwitching (void)
406d332
< template <typename TxopType>
408c334
< TxopTest<TxopType>::NotifySleep (void)
---
> TxopTest::NotifySleep (void)
412d337
< template <typename TxopType>
414c339
< TxopTest<TxopType>::NotifyWakeUp (void)
---
> TxopTest::NotifyWakeUp (void)
418,419c343
< template <typename TxopType>
< ChannelAccessManagerTest<TxopType>::ChannelAccessManagerTest ()
---
> ChannelAccessManagerTest::ChannelAccessManagerTest ()
424d347
< template <typename TxopType>
426c349
< ChannelAccessManagerTest<TxopType>::NotifyAccessGranted (uint32_t i)
---
> ChannelAccessManagerTest::NotifyAccessGranted (uint32_t i)
428c351
<   Ptr<TxopTest<TxopType>> state = m_txop[i];
---
>   Ptr<TxopTest> state = m_txop[i];
440d362
< template <typename TxopType>
442c364
< ChannelAccessManagerTest<TxopType>::AddTxEvt (uint64_t at, uint64_t duration)
---
> ChannelAccessManagerTest::AddTxEvt (uint64_t at, uint64_t duration)
449d370
< template <typename TxopType>
451c372
< ChannelAccessManagerTest<TxopType>::NotifyInternalCollision (uint32_t i)
---
> ChannelAccessManagerTest::NotifyInternalCollision (uint32_t i)
453c374
<   Ptr<TxopTest<TxopType>> state = m_txop[i];
---
>   Ptr<TxopTest> state = m_txop[i];
457c378
<       struct TxopTest<TxopType>::ExpectedBackoff expected = state->m_expectedInternalCollision.front ();
---
>       struct TxopTest::ExpectedCollision expected = state->m_expectedInternalCollision.front ();
464d384
< template <typename TxopType>
466c386
< ChannelAccessManagerTest<TxopType>::GenerateBackoff (uint32_t i)
---
> ChannelAccessManagerTest::NotifyCollision (uint32_t i)
468,470c388,390
<   Ptr<TxopTest<TxopType>> state = m_txop[i];
<   NS_TEST_EXPECT_MSG_EQ (state->m_expectedBackoff.empty (), false, "Have expected backoffs");
<   if (!state->m_expectedBackoff.empty ())
---
>   Ptr<TxopTest> state = m_txop[i];
>   NS_TEST_EXPECT_MSG_EQ (state->m_expectedCollision.empty (), false, "Have expected collisions");
>   if (!state->m_expectedCollision.empty ())
472,474c392,394
<       struct TxopTest<TxopType>::ExpectedBackoff expected = state->m_expectedBackoff.front ();
<       state->m_expectedBackoff.pop_front ();
<       NS_TEST_EXPECT_MSG_EQ (Simulator::Now (), MicroSeconds (expected.at), "Expected backoff is now");
---
>       struct TxopTest::ExpectedCollision expected = state->m_expectedCollision.front ();
>       state->m_expectedCollision.pop_front ();
>       NS_TEST_EXPECT_MSG_EQ (Simulator::Now (), MicroSeconds (expected.at), "Expected collision is now");
479d398
< template <typename TxopType>
481c400
< ChannelAccessManagerTest<TxopType>::NotifyChannelSwitching (uint32_t i)
---
> ChannelAccessManagerTest::NotifyChannelSwitching (uint32_t i)
483c402
<   Ptr<TxopTest<TxopType>> state = m_txop[i];
---
>   Ptr<TxopTest> state = m_txop[i];
493d411
< template <typename TxopType>
495c413
< ChannelAccessManagerTest<TxopType>::ExpectInternalCollision (uint64_t time, uint32_t nSlots, uint32_t from)
---
> ChannelAccessManagerTest::ExpectInternalCollision (uint64_t time, uint32_t nSlots, uint32_t from)
497,498c415,416
<   Ptr<TxopTest<TxopType>> state = m_txop[from];
<   struct TxopTest<TxopType>::ExpectedBackoff col;
---
>   Ptr<TxopTest> state = m_txop[from];
>   struct TxopTest::ExpectedCollision col;
504,523d421
< template <typename TxopType>
< void
< ChannelAccessManagerTest<TxopType>::ExpectBackoff (uint64_t time, uint32_t nSlots, uint32_t from)
< {
<   Ptr<TxopTest<TxopType>> state = m_txop[from];
<   struct TxopTest<TxopType>::ExpectedBackoff backoff;
<   backoff.at = time;
<   backoff.nSlots = nSlots;
<   state->m_expectedBackoff.push_back (backoff);
< }
< 
< template <typename TxopType>
< void
< ChannelAccessManagerTest<TxopType>::ExpectBusy (uint64_t time, bool busy)
< {
<   Simulator::Schedule (MicroSeconds (time) - Now (),
<                        &ChannelAccessManagerTest::DoCheckBusy, this, busy);
< }
< 
< template <typename TxopType>
525c423
< ChannelAccessManagerTest<TxopType>::DoCheckBusy (bool busy)
---
> ChannelAccessManagerTest::ExpectCollision (uint64_t time, uint32_t nSlots, uint32_t from)
527c425,429
<   NS_TEST_EXPECT_MSG_EQ (m_ChannelAccessManager->IsBusy (), busy, "Incorrect busy/idle state");
---
>   Ptr<TxopTest> state = m_txop[from];
>   struct TxopTest::ExpectedCollision col;
>   col.at = time;
>   col.nSlots = nSlots;
>   state->m_expectedCollision.push_back (col);
530d431
< template <typename TxopType>
532c433
< ChannelAccessManagerTest<TxopType>::StartTest (uint64_t slotTime, uint64_t sifs, uint64_t eifsNoDifsNoSifs, uint32_t ackTimeoutValue)
---
> ChannelAccessManagerTest::StartTest (uint64_t slotTime, uint64_t sifs, uint64_t eifsNoDifsNoSifs, uint32_t ackTimeoutValue)
536,537d436
<   m_low->SetSlotTime (MicroSeconds (slotTime));
<   m_low->SetSifs (MicroSeconds (sifs));
545d443
< template <typename TxopType>
547c445
< ChannelAccessManagerTest<TxopType>::AddTxop (uint32_t aifsn)
---
> ChannelAccessManagerTest::AddDcfState (uint32_t aifsn)
549c447
<   Ptr<TxopTest<TxopType>> txop = CreateObject<TxopTest<TxopType>> (this, m_txop.size ());
---
>   Ptr<TxopTest> txop = CreateObject<TxopTest> (this, m_txop.size ());
552,553c450
<   txop->SetChannelAccessManager (m_ChannelAccessManager);
<   txop->SetMacLow (m_low);
---
>   m_ChannelAccessManager->Add (txop);
556d452
< template <typename TxopType>
558c454
< ChannelAccessManagerTest<TxopType>::EndTest (void)
---
> ChannelAccessManagerTest::EndTest (void)
563c459
<   for (typename TxopTests::const_iterator i = m_txop.begin (); i != m_txop.end (); i++)
---
>   for (TxopTests::const_iterator i = m_txop.begin (); i != m_txop.end (); i++)
565c461
<       Ptr<TxopTest<TxopType>> state = *i;
---
>       Ptr<TxopTest> state = *i;
568,569c464
<       NS_TEST_EXPECT_MSG_EQ (state->m_expectedBackoff.empty (), true, "Have no expected backoffs");
<       state->Dispose ();
---
>       NS_TEST_EXPECT_MSG_EQ (state->m_expectedCollision.empty (), true, "Have no expected collisions");
573a469,476
>   for (TxopTests::const_iterator i = m_txop.begin (); i != m_txop.end (); i++)
>     {
>       Ptr<TxopTest> txop = *i;
>       txop->Dispose ();
>       txop = 0;
>     }
>   m_txop.clear ();
> 
578d480
< template <typename TxopType>
580c482
< ChannelAccessManagerTest<TxopType>::AddRxOkEvt (uint64_t at, uint64_t duration)
---
> ChannelAccessManagerTest::AddRxOkEvt (uint64_t at, uint64_t duration)
589d490
< template <typename TxopType>
591c492
< ChannelAccessManagerTest<TxopType>::AddRxInsideSifsEvt (uint64_t at, uint64_t duration)
---
> ChannelAccessManagerTest::AddRxInsideSifsEvt (uint64_t at, uint64_t duration)
598d498
< template <typename TxopType>
600c500
< ChannelAccessManagerTest<TxopType>::AddRxErrorEvt (uint64_t at, uint64_t duration)
---
> ChannelAccessManagerTest::AddRxErrorEvt (uint64_t at, uint64_t duration)
609,621d508
< template <typename TxopType>
< void
< ChannelAccessManagerTest<TxopType>::AddRxErrorEvt (uint64_t at, uint64_t duration, uint64_t timeUntilError)
< {
<   Simulator::Schedule (MicroSeconds (at) - Now (),
<                        &ChannelAccessManager::NotifyRxStartNow, m_ChannelAccessManager,
<                        MicroSeconds (duration));
<   Simulator::Schedule (MicroSeconds (at + timeUntilError) - Now (),
<                        &ChannelAccessManager::NotifyRxEndErrorNow, m_ChannelAccessManager);
< }
< 
< 
< template <typename TxopType>
623c510
< ChannelAccessManagerTest<TxopType>::AddNavReset (uint64_t at, uint64_t duration)
---
> ChannelAccessManagerTest::AddNavReset (uint64_t at, uint64_t duration)
630d516
< template <typename TxopType>
632c518
< ChannelAccessManagerTest<TxopType>::AddNavStart (uint64_t at, uint64_t duration)
---
> ChannelAccessManagerTest::AddNavStart (uint64_t at, uint64_t duration)
639d524
< template <typename TxopType>
641c526
< ChannelAccessManagerTest<TxopType>::AddAckTimeoutReset (uint64_t at)
---
> ChannelAccessManagerTest::AddAckTimeoutReset (uint64_t at)
647d531
< template <typename TxopType>
649c533
< ChannelAccessManagerTest<TxopType>::AddAccessRequest (uint64_t at, uint64_t txTime,
---
> ChannelAccessManagerTest::AddAccessRequest (uint64_t at, uint64_t txTime,
655d538
< template <typename TxopType>
657c540
< ChannelAccessManagerTest<TxopType>::AddAccessRequestWithAckTimeout (uint64_t at, uint64_t txTime,
---
> ChannelAccessManagerTest::AddAccessRequestWithAckTimeout (uint64_t at, uint64_t txTime,
665d547
< template <typename TxopType>
667c549
< ChannelAccessManagerTest<TxopType>::AddAccessRequestWithSuccessfullAck (uint64_t at, uint64_t txTime,
---
> ChannelAccessManagerTest::AddAccessRequestWithSuccessfullAck (uint64_t at, uint64_t txTime,
677d558
< template <typename TxopType>
679,680c560
< ChannelAccessManagerTest<TxopType>::DoAccessRequest (uint64_t txTime, uint64_t expectedGrantTime,
<                                                      Ptr<TxopTest<TxopType>> state)
---
> ChannelAccessManagerTest::DoAccessRequest (uint64_t txTime, uint64_t expectedGrantTime, Ptr<TxopTest> state)
682,685d561
<   if (m_ChannelAccessManager->NeedBackoffUponAccess (state))
<     {
<       state->GenerateBackoff ();
<     }
690d565
< template <typename TxopType>
692c567
< ChannelAccessManagerTest<TxopType>::AddCcaBusyEvt (uint64_t at, uint64_t duration)
---
> ChannelAccessManagerTest::AddCcaBusyEvt (uint64_t at, uint64_t duration)
699d573
< template <typename TxopType>
701c575
< ChannelAccessManagerTest<TxopType>::AddSwitchingEvt (uint64_t at, uint64_t duration)
---
> ChannelAccessManagerTest::AddSwitchingEvt (uint64_t at, uint64_t duration)
708d581
< template <typename TxopType>
710c583
< ChannelAccessManagerTest<TxopType>::AddRxStartEvt (uint64_t at, uint64_t duration)
---
> ChannelAccessManagerTest::AddRxStartEvt (uint64_t at, uint64_t duration)
717,720d589
< /*
<  * Specialization of DoRun () method for DCF
<  */
< template <>
722c591
< ChannelAccessManagerTest<Txop>::DoRun (void)
---
> ChannelAccessManagerTest::DoRun (void)
724,726c593,595
<   // DCF immediate access (no backoff)
<   //  1      4       5    6      8     11      12
<   //  | sifs | aifsn | tx | idle | sifs | aifsn | tx |
---
>   // Bug 2369 addresses this case
>   //  0      3       4    5      8       9  10   12
>   //  | sifs | aifsn | tx | sifs | aifsn |   | tx |
729,731c598,613
<   AddTxop (1);
<   AddAccessRequest (1, 1, 5, 0);
<   AddAccessRequest (8, 2, 12, 0);
---
>   AddDcfState (1);
>   AddAccessRequest (1, 1, 4, 0);
>   // Generate backoff when the request is within SIFS
>   ExpectCollision (1, 0, 0); // 0 slots
>   AddAccessRequest (10, 2, 10, 0);
>   EndTest ();
>   // Bug 2369 addresses this case
>   //  0      3       5    6      9       11  12   13
>   //  | sifs | aifsn | tx | sifs | aifsn |   | tx |
>   //
>   StartTest (1, 3, 10);
>   AddDcfState (2);
>   AddAccessRequest (4, 1, 5, 0);
>   // Generate backoff when the request is within AIFSN
>   ExpectCollision (4, 0, 0); // 0 slots
>   AddAccessRequest (12, 2, 12, 0);
734,737c616,617
<   //  1      4       5    6      9    10     14     17      18
<   //  | sifs | aifsn | tx | sifs | ack | idle | sifs | aifsn | tx |
<   //                        |
<   //                        7 start rx
---
>   //  0      3       4    5      8     9     12       13 14
>   //  | sifs | aifsn | tx | sifs | ack | sifs | aifsn |  |tx |
741,745c621,626
<   AddTxop (1);
<   AddAccessRequest (1, 1, 5, 0);
<   AddRxInsideSifsEvt (7, 10);
<   AddTxEvt (9, 1);
<   AddAccessRequest (14, 2, 18, 0);
---
>   AddDcfState (1);
>   AddAccessRequest (1, 1, 4, 0);
>   ExpectCollision (1, 0, 0);
>   AddRxInsideSifsEvt (6, 10);
>   AddTxEvt (8, 1);
>   AddAccessRequest (14, 2, 14, 0);
758c639
<   AddTxop (1);
---
>   AddDcfState (1);
762c643
<   ExpectBackoff (30, 4, 0); //backoff: 4 slots
---
>   ExpectCollision (30, 4, 0); //backoff: 4 slots
772c653
<   AddTxop (1);
---
>   AddDcfState (1);
775c656
<   ExpectBackoff (30, 0, 0); // backoff: 0 slots
---
>   ExpectCollision (30, 0, 0); // backoff: 0 slots
785c666
<   AddTxop (1);
---
>   AddDcfState (1);
789c670
<   ExpectBackoff (30, 0, 0); //backoff: 0 slots
---
>   ExpectCollision (30, 0, 0); //backoff: 0 slots
792c673
<   // Requesting access within SIFS interval (DCF immediate access)
---
>   // Bug 2369.  Test case of requesting access within SIFS interval
794,795c675,678
<   //  20    60     62     68      72
<   //   | rx  | idle | sifs | aifsn | tx |
---
>   //  20    60     66      70         74
>   //   | rx  | sifs | aifsn | backoff | tx |
>   //           |
>   //          62 request access.
798c681
<   AddTxop (1);
---
>   AddDcfState (1);
800c683,684
<   AddAccessRequest (62, 2, 72, 0);
---
>   AddAccessRequest (62, 2, 74, 0);
>   ExpectCollision (62, 1, 0); //backoff: 1 slots
803c687
<   // Requesting access after DIFS (DCF immediate access)
---
>   // Bug 2369.  Test case of requesting access after DIFS (no backoff)
805,806c689,692
<   //   20   60     70     76      80
<   //   | rx  | idle | sifs | aifsn | tx |
---
>   //  20    60     66      70
>   //   | rx  | sifs | aifsn | tx |
>   //                        |
>   //                       70 request access.
809c695
<   AddTxop (1);
---
>   AddDcfState (1);
811c697
<   AddAccessRequest (70, 2, 80, 0);
---
>   AddAccessRequest (70, 2, 70, 0);
821c707
<   AddTxop (1);
---
>   AddDcfState (1);
824,851c710
<   ExpectBackoff (30, 4, 0); //backoff: 4 slots
<   EndTest ();
< 
<   // Test DCF immediate access after an EIFS (EIFS is greater)
<   //
<   //  20          60     66           76             86
<   //               | <----+-eifs------>|
<   //   |    rx     | sifs | acktxttime | sifs + aifsn | tx |
<   //                             | sifs + aifsn |
<   //             request access 70             80
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxErrorEvt (20, 40);
<   AddAccessRequest (70, 2, 86, 0);
<   EndTest ();
< 
<   // Test that channel stays busy for first frame's duration after Rx error
<   //
<   //  20          60
<   //   |    rx     |
<   //        |
<   //       40 force Rx error
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxErrorEvt (20, 40, 20); // At time 20, start reception for 40, but force error 20 into frame
<   ExpectBusy (41, true); // channel should remain busy for remaining duration
<   ExpectBusy (59, true);
<   ExpectBusy (61, false);
---
>   ExpectCollision (30, 4, 0); //backoff: 4 slots
861c720
<   AddTxop (1);
---
>   AddDcfState (1);
864c723
<   ExpectBackoff (30, 4, 0); //backoff: 4 slots
---
>   ExpectCollision (30, 4, 0); //backoff: 4 slots
876,877c735,736
<   AddTxop (1); //high priority DCF
<   AddTxop (3); //low priority DCF
---
>   AddDcfState (1); //high priority DCF
>   AddDcfState (3); //low priority DCF
880c739
<   ExpectBackoff (30, 2, 0); //backoff: 2 slot
---
>   ExpectCollision (30, 2, 0); //backoff: 2 slot
882c741
<   ExpectBackoff (40, 0, 1); //backoff: 0 slot
---
>   ExpectCollision (40, 0, 1); //backoff: 0 slot
887c746
<   // inside the Ack timeout second queue with higher priority requests access.
---
>   // inside the ack timeout second queue with higher priority requests access.
889,897c748,757
<   //            20     26      34       54            74     80
<   // DCF1 - low  | sifs | aifsn |   tx   | Ack timeout | sifs |       |
<   // DCF0 - high |                              |      | sifs |  tx   |
<   //                                            ^ request access
<   StartTest (4, 6, 10);
<   AddTxop (0); //high priority DCF
<   AddTxop (2); //low priority DCF
<   AddAccessRequestWithAckTimeout (20, 20, 34, 1);
<   AddAccessRequest (64, 10, 80, 0);
---
>   //            20           40      50     60  66      76
>   // DCF0 - low  |     tx     | ack timeout |sifs|       |
>   // DCF1 - high |                    |     |sifs|  tx   |
>   //                                  ^ request access
>   StartTest (4, 6, 10);
>   AddDcfState (2); //high priority DCF
>   AddDcfState (0); //low priority DCF
>   AddAccessRequestWithAckTimeout (20, 20, 20, 0);
>   AddAccessRequest (50, 10, 66, 1);
>   ExpectCollision (50, 0, 1);
902c762
<   // First queue requests access and Ack is 2 us delayed (got Ack interval at the picture),
---
>   // First queue requests access and ack is 2 us delayed (got ack interval at the picture),
905,913c765,774
<   //            20     26      34           54        56     62
<   // DCF1 - low  | sifs | aifsn |     tx     | got Ack | sifs |       |
<   // DCF0 - high |                                |    | sifs |  tx   |
<   //                                              ^ request access
<   StartTest (4, 6, 10);
<   AddTxop (0); //high priority DCF
<   AddTxop (2); //low priority DCF
<   AddAccessRequestWithSuccessfullAck (20, 20, 34, 2, 1);
<   AddAccessRequest (55, 10, 62, 0);
---
>   //            20           40  41   42    48      58
>   // DCF0 - low  |     tx     |got ack |sifs|       |
>   // DCF1 - high |                |    |sifs|  tx   |
>   //                              ^ request access
>   StartTest (4, 6, 10);
>   AddDcfState (2); //high priority DCF
>   AddDcfState (0); //low priority DCF
>   AddAccessRequestWithSuccessfullAck (20, 20, 20, 2, 0);
>   AddAccessRequest (41, 10, 48, 1);
>   ExpectCollision (41, 0, 1);
917,919c778,780
<   //      20     26      34         54     60    62     68      76       80
<   // DCF0  | sifs | aifsn |    tx    | sifs | Ack | sifs | aifsn | bslot0 | tx |
<   //                                           ^ request access
---
>   //            20           40  41   42    48      58
>   // DCF0 - low  |     tx     |got ack |sifs|       |
>   //                              ^ request access
921,925c782,785
<   AddTxop (2);
<   AddAccessRequest (20, 20, 34, 0);
<   AddRxOkEvt (60, 2); // Ack
<   AddAccessRequest (61, 10, 80, 0);
<   ExpectBackoff (61, 1, 0); // 1 slot
---
>   AddDcfState (2);
>   AddAccessRequestWithSuccessfullAck (20, 20, 20, 2, 0);
>   AddAccessRequest (41, 10, 56, 0);
>   ExpectCollision (41, 0, 0);
928,930c788,790
<   // test simple NAV count. This scenario models a simple Data+Ack handshake
<   // where the data rate used for the Ack is higher than expected by the Data source
<   // so, the data exchange completes before the end of NAV.
---
>   // test simple NAV count. This scenario modelizes a simple DATA+ACK handshake
>   // where the data rate used for the ACK is higher than expected by the DATA source
>   // so, the data exchange completes before the end of nav.
932c792
<   AddTxop (1);
---
>   AddDcfState (1);
938c798
<   ExpectBackoff (30, 2, 0); //backoff: 2 slots
---
>   ExpectCollision (30, 2, 0); //backoff: 2 slot
941,942c801,802
<   // test more complex NAV handling by a CF-poll. This scenario models a
<   // simple Data+Ack handshake interrupted by a CF-poll which resets the
---
>   // test more complex NAV handling by a CF-poll. This scenario modelizes a
>   // simple DATA+ACK handshake interrupted by a CF-poll which resets the
945c805
<   AddTxop (1);
---
>   AddDcfState (1);
951c811
<   ExpectBackoff (30, 2, 0); //backoff: 2 slots
---
>   ExpectCollision (30, 2, 0); //backoff: 2 slot
955,957d814
<   //  20         60         80     86      94
<   //   |    rx    |   idle   | sifs | aifsn |    tx    |
<   //                         ^ request access
959c816
<   AddTxop (2);
---
>   AddDcfState (2);
961c818
<   AddAccessRequest (80, 10, 94, 0);
---
>   AddAccessRequest (80, 10, 80, 0);
966c823
<   AddTxop (2);
---
>   AddDcfState (2);
970c827
<   ExpectBackoff (30, 3, 0); //backoff: 3 slots
---
>   ExpectCollision (30, 3, 0); //backoff: 3 slots
976,978c833,836
<   //  0          20     21     24      25   26
<   //  | switching | idle | sifs | aifsn | tx |
<   //                     ^ access request.
---
>   //  0          20     23      24   25
>   //  | switching | sifs | aifsn | tx |
>   //                |
>   //               21 access request.
980,982c838,841
<   AddTxop (1);
<   AddSwitchingEvt (0, 20);
<   AddAccessRequest (21, 1, 25, 0);
---
>   AddDcfState (1);
>   AddSwitchingEvt (0,20);
>   AddAccessRequest (21, 1, 24, 0);
>   ExpectCollision (21, 0, 0);
991c850
<   AddTxop (1);
---
>   AddDcfState (1);
994c853
<   ExpectBackoff (45, 2, 0); //backoff: 2 slots
---
>   ExpectCollision (45, 2, 0); //backoff: 2 slots
998,1000c857,860
<   //  20     30          50     51     54      55   56
<   //   |  rx  | switching | idle | sifs | aifsn | tx |
<   //                             ^ access request.
---
>   //  20     30          50     53      54   55
>   //   |  rx  | switching | sifs | aifsn | tx |
>   //                        |
>   //                       51 access request.
1003,1006c863,867
<   AddTxop (1);
<   AddRxStartEvt (20, 40);
<   AddSwitchingEvt (30, 20);
<   AddAccessRequest (51, 1, 55, 0);
---
>   AddDcfState (1);
>   AddRxStartEvt (20,40);
>   AddSwitchingEvt (30,20);
>   AddAccessRequest (51, 1, 54, 0);
>   ExpectCollision (51, 0, 0);
1009,1011c870,873
<   //  20     30          50     51     54      55   56
<   //   | busy | switching | idle | sifs | aifsn | tx |
<   //                             ^ access request.
---
>   //  20     30          50     53      54   55
>   //   | busy | switching | sifs | aifsn | tx |
>   //                        |
>   //                       51 access request.
1014,1017c876,880
<   AddTxop (1);
<   AddCcaBusyEvt (20, 40);
<   AddSwitchingEvt (30, 20);
<   AddAccessRequest (51, 1, 55, 0);
---
>   AddDcfState (1);
>   AddCcaBusyEvt (20,40);
>   AddSwitchingEvt (30,20);
>   AddAccessRequest (51, 1, 54, 0);
>   ExpectCollision (51, 0, 0);
1020,1022c883,886
<   //  20      30          50     51     54      55   56
<   //   |  nav  | switching | idle | sifs | aifsn | tx |
<   //                              ^ access request.
---
>   //  20      30          50     53      54   55
>   //   |  nav  | switching | sifs | aifsn | tx |
>   //                        |
>   //                       51 access request.
1025c889
<   AddTxop (1);
---
>   AddDcfState (1);
1028c892,893
<   AddAccessRequest (51, 1, 55, 0);
---
>   AddAccessRequest (51, 1, 54, 0);
>   ExpectCollision (51, 0, 0);
1031,1034c896,899
<   //  20     23      24      44             54          59     60     63      64   65
<   //   | sifs | aifsn |  tx   | Ack timeout  | switching | idle | sifs | aifsn | tx |
<   //                                 |                          |
<   //                                49 access request.          ^ access request.
---
>   //  20      40             50          55     58      59   60
>   //   |  tx   | ack timeout  | switching | sifs | aifsn | tx |
>   //                  |                     |
>   //                 45 access request.    56 access request.
1037,1047c902,914
<   AddTxop (1);
<   AddAccessRequestWithAckTimeout (20, 20, 24, 0);
<   AddAccessRequest (49, 1, 54, 0);
<   AddSwitchingEvt (54, 5);
<   AddAccessRequest (60, 1, 64, 0);
<   EndTest ();
< 
<   //  20         60     66      70       74       78  80         100    101    107     111  113
<   //   |    rx    | sifs | aifsn | bslot0 | bslot1 |   | switching | idle | sifs | aifsn | tx |
<   //        |                                                             |
<   //       30 access request.                                             ^ access request.
---
>   AddDcfState (1);
>   AddAccessRequestWithAckTimeout (20, 20, 20, 0);
>   AddAccessRequest (45, 1, 50, 0);
>   ExpectCollision (45, 0, 0);
>   AddSwitchingEvt (50,5);
>   AddAccessRequest (56, 1, 59, 0);
>   ExpectCollision (56, 0, 0);
>   EndTest ();
> 
>   //  20         60     66      70       74       78  80         100    106     110  112
>   //   |    rx    | sifs | aifsn | bslot0 | bslot1 |   | switching | sifs | aifsn | tx |
>   //        |                                                        |
>   //       30 access request.                                      101 access request.
1050c917
<   AddTxop (1);
---
>   AddDcfState (1);
1053c920
<   ExpectBackoff (30, 4, 0); //backoff: 4 slots
---
>   ExpectCollision (30, 4, 0); //backoff: 4 slots
1055,1074c922,923
<   AddAccessRequest (101, 2, 111, 0);
<   EndTest ();
< }
< 
< /*
<  * Specialization of DoRun () method for EDCA
<  */
< template <>
< void
< ChannelAccessManagerTest<QosTxop>::DoRun (void)
< {
<   // Check alignment at slot boundary after successful reception (backoff = 0):
<   //    20     50     56      60     80
<   //     |  rx  | sifs | aifsn |  tx  |
<   //                |
<   //               52 request access
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxOkEvt (20, 30);
<   AddAccessRequest (52, 20, 60, 0);
---
>   AddAccessRequest (101, 2, 110, 0);
>   ExpectCollision (101, 0, 0); //backoff: 0 slots
1076,1179d924
< 
<   // Check alignment at slot boundary after successful reception (backoff = 0):
<   //    20     50     56      60     80
<   //     |  rx  | sifs | aifsn |  tx  |
<   //                       |
<   //                      58 request access
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxOkEvt (20, 30);
<   AddAccessRequest (52, 20, 60, 0);
<   EndTest ();
< 
<   // Check alignment at slot boundary after successful reception (backoff = 0):
<   //    20     50     56      60     64     84
<   //     |  rx  | sifs | aifsn | idle |  tx  |
<   //                               |
<   //                              62 request access
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxOkEvt (20, 30);
<   AddAccessRequest (62, 20, 64, 0);
<   EndTest ();
< 
<   // Check alignment at slot boundary after failed reception (backoff = 0):
<   //  20         50     56           66             76     96
<   //   |          | <------eifs------>|              |      |
<   //   |    rx    | sifs | acktxttime | sifs + aifsn |  tx  |
<   //                   |
<   //                  55 request access
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxErrorEvt (20, 30);
<   AddAccessRequest (55, 20, 76, 0);
<   EndTest ();
< 
<   // Check alignment at slot boundary after failed reception (backoff = 0):
<   //  20         50     56           66             76     96
<   //   |          | <------eifs------>|              |      |
<   //   |    rx    | sifs | acktxttime | sifs + aifsn |  tx  |
<   //                                        |
<   //                                       70 request access
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxErrorEvt (20, 30);
<   AddAccessRequest (70, 20, 76, 0);
<   EndTest ();
< 
<   // Check alignment at slot boundary after failed reception (backoff = 0):
<   //  20         50     56           66             76     84
<   //   |          | <------eifs------>|              |      |
<   //   |    rx    | sifs | acktxttime | sifs + aifsn | idle |  tx  |
<   //                                                     |
<   //                                                    82 request access
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxErrorEvt (20, 30);
<   AddAccessRequest (82, 20, 84, 0);
<   EndTest ();
< 
<   // Check backoff decrement at slot boundaries. Medium idle during backoff
<   //  20           50     56      60         64         68         72         76     96
<   //   |     rx     | sifs | aifsn |   idle   |   idle   |   idle   |   idle   |  tx  |
<   //      |                        |          |          |          |
<   //     30 request access.    decrement  decrement  decrement  decrement
<   //        backoff slots: 4    slots: 3   slots: 2   slots: 1   slots: 0
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxOkEvt (20, 30);
<   AddAccessRequest (30, 20, 76, 0);
<   ExpectBackoff (30, 4, 0);
<   EndTest ();
< 
<   // Check backoff decrement at slot boundaries. Medium becomes busy during backoff
<   //  20           50     56      60     61     71     77      81         85     87     97    103     107    127
<   //   |     rx     | sifs | aifsn | idle |  rx  | sifs | aifsn |   idle   | idle |  rx  | sifs | aifsn |  tx  |
<   //      |                        |                            |          |
<   //     30 request access.    decrement                    decrement  decrement
<   //        backoff slots: 3    slots: 2                     slots: 1   slots: 0
<   StartTest (4, 6, 10);
<   AddTxop (1);
<   AddRxOkEvt (20, 30);
<   AddRxOkEvt (61, 10);
<   AddRxOkEvt (87, 10);
<   AddAccessRequest (30, 20, 107, 0);
<   ExpectBackoff (30, 3, 0);
<   EndTest ();
< }
< 
< /**
<  * \ingroup wifi-test
<  * \ingroup tests
<  *
<  * \brief Txop Test Suite
<  */
< class TxopTestSuite : public TestSuite
< {
< public:
<   TxopTestSuite ();
< };
< 
< TxopTestSuite::TxopTestSuite ()
<   : TestSuite ("wifi-devices-dcf", UNIT)
< {
<   AddTestCase (new ChannelAccessManagerTest<Txop>, TestCase::QUICK);
1182d926
< static TxopTestSuite g_dcfTestSuite;
1188c932
<  * \brief QosTxop Test Suite
---
>  * \brief Dcf Test Suite
1190c934
< class QosTxopTestSuite : public TestSuite
---
> class DcfTestSuite : public TestSuite
1193c937
<   QosTxopTestSuite ();
---
>   DcfTestSuite ();
1196,1197c940,941
< QosTxopTestSuite::QosTxopTestSuite ()
<   : TestSuite ("wifi-devices-edca", UNIT)
---
> DcfTestSuite::DcfTestSuite ()
>   : TestSuite ("devices-wifi-dcf", UNIT)
1199c943
<   AddTestCase (new ChannelAccessManagerTest<QosTxop>, TestCase::QUICK);
---
>   AddTestCase (new ChannelAccessManagerTest, TestCase::QUICK);
1202c946
< static QosTxopTestSuite g_edcaTestSuite;
---
> static DcfTestSuite g_dcfTestSuite;
diff ../../NS3-WiGig/src/wifi/test/examples-to-run.py ../../ns-3-dev-git/src/wifi/test/examples-to-run.py
1c1
< #! /usr/bin/env python3
---
> #! /usr/bin/env python
306,314c306,310
<     ("wifi-test-interference-helper --enableCapture=0 --txPowerA=5 --txPowerB=15 --delay=10 --txModeA=OfdmRate6Mbps --txModeB=OfdmRate6Mbps --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=0", "True", "True"),
<     ("wifi-test-interference-helper --enableCapture=0 --txPowerA=5 --txPowerB=15  --delay=17 --standard=WIFI_PHY_STANDARD_80211ac --preamble=WIFI_PREAMBLE_VHT_SU --txModeA=VhtMcs0 --txModeB=VhtMcs0 --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=0", "True", "True"),
<     ("wifi-test-interference-helper --enableCapture=0 --txPowerA=5 --txPowerB=15  --delay=20 --standard=WIFI_PHY_STANDARD_80211ac --preamble=WIFI_PREAMBLE_VHT_SU --txModeA=VhtMcs0 --txModeB=VhtMcs0 --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=0", "True", "True"),
<     ("wifi-test-interference-helper --enableCapture=0 --txPowerA=5 --txPowerB=15  --delay=30 --standard=WIFI_PHY_STANDARD_80211ac --preamble=WIFI_PREAMBLE_VHT_SU --txModeA=VhtMcs0 --txModeB=VhtMcs0 --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=0", "True", "True"),
<     ("wifi-test-interference-helper --enableCapture=1 --txPowerA=5 --txPowerB=15 --delay=10 --txModeA=OfdmRate6Mbps --txModeB=OfdmRate6Mbps --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=1", "True", "False"),
<     ("wifi-bianchi --validate --phyRate=54 --nMinStas=5 --nMaxStas=10 --duration=5", "False", "False"), # TODO: run from N=5 to N=50 for 100s (TAKES_FOREVER) when issue #170 is fixed
<     ("wifi-bianchi --validate --phyRate=6 --nMinStas=5 --nMaxStas=10 --duration=15", "True", "False"), # TODO: run from N=5 to N=50 for 400s (TAKES_FOREVER) when issue #170 is fixed
<     ("wifi-bianchi --validate --phyRate=54 --nMinStas=5 --nMaxStas=10 --duration=5 --infra", "False", "False"), # TODO: run from N=5 to N=50 for 100s (TAKES_FOREVER) when issue #170 is fixed
<     ("wifi-bianchi --validate --phyRate=6 --nMinStas=5 --nMaxStas=10 --duration=20 --infra", "False", "False"), # TODO: run from N=5 to N=50 for 600s (TAKES_FOREVER) when issue #170 is fixed
---
>     ("test-interference-helper --enableCapture=0 --txPowerA=5 --txPowerB=15 --delay=10 --txModeA=OfdmRate6Mbps --txModeB=OfdmRate6Mbps --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=0", "True", "True"),
>     ("test-interference-helper --enableCapture=0 --txPowerA=5 --txPowerB=15  --delay=17 --standard=WIFI_PHY_STANDARD_80211ac --preamble=WIFI_PREAMBLE_VHT --txModeA=VhtMcs0 --txModeB=VhtMcs0 --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=0", "True", "True"),
>     ("test-interference-helper --enableCapture=0 --txPowerA=5 --txPowerB=15  --delay=20 --standard=WIFI_PHY_STANDARD_80211ac --preamble=WIFI_PREAMBLE_VHT --txModeA=VhtMcs0 --txModeB=VhtMcs0 --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=0", "True", "True"),
>     ("test-interference-helper --enableCapture=0 --txPowerA=5 --txPowerB=15  --delay=30 --standard=WIFI_PHY_STANDARD_80211ac --preamble=WIFI_PREAMBLE_VHT --txModeA=VhtMcs0 --txModeB=VhtMcs0 --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=0", "True", "True"),
>     ("test-interference-helper --enableCapture=1 --txPowerA=5 --txPowerB=15 --delay=10 --txModeA=OfdmRate6Mbps --txModeB=OfdmRate6Mbps --checkResults=1 --expectRxASuccessfull=0 --expectRxBSuccessfull=1", "True", "False"),
Only in ../../NS3-WiGig/src/wifi/test: inter-bss-test-suite.cc
diff ../../NS3-WiGig/src/wifi/test/power-rate-adaptation-test.cc ../../ns-3-dev-git/src/wifi/test/power-rate-adaptation-test.cc
76d75
<   Ptr<WifiNetDevice> dev = CreateObject<WifiNetDevice> ();
78d76
<   mac->SetDevice (dev);
88a87
>   Ptr<WifiNetDevice> dev = CreateObject<WifiNetDevice> ();
139d137
<   packetHeader.SetAddr1 (remoteAddress);
156c154
<   WifiTxVector txVector = manager->GetDataTxVector (packetHeader);
---
>   WifiTxVector txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
171c169
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
174c172
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
189c187
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
204c202
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
207c205
<   manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>   manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
209c207
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
224c222
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
240c238
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
255c253
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
258c256
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
273c271
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
288c286
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
291c289
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
306c304
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
309c307
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
322c320
<   manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>   manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
329c327
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
360d357
<   packetHeader.SetAddr1 (remoteAddress);
377c374
<   WifiTxVector txVector = manager->GetDataTxVector (packetHeader);
---
>   WifiTxVector txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
393c390
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
396c393
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
411c408
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
427c424
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
430c427
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
446c443
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
449c446
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
464c461
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
467c464
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
482c479
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
500c497
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
516c513
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
531c528
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
534c531
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
551c548
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
554c551
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
563c560
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
566c563
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
603d599
<   packetHeader.SetAddr1 (remoteAddress);
646c642
<   WifiTxVector txVector = manager->GetDataTxVector (packetHeader);
---
>   WifiTxVector txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
665c661
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
668c664
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
678c674
<   manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>   manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
680c676
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
698c694
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
707c703
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
722c718
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
725c721
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
734c730
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
737c733
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
746c742
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
749c745
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
758c754
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
761c757
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
770c766
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
773c769
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
782c778
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
785c781
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
794c790
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
797c793
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
814c810
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
817c813
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
824c820
<   manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>   manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
826c822
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
842c838
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
845c841
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
863c859
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
881c877
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
899c895
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
915c911
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
932c928
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
935c931
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
947c943
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
959c955
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
968c964
<       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>       manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
971c967
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
988c984
<           manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, txVector, packet->GetSize ());
---
>           manager->ReportDataOk (remoteAddress, &packetHeader, 0, ackMode, 0, packet->GetSize ());
997c993
<   txVector = manager->GetDataTxVector (packetHeader);
---
>   txVector = manager->GetDataTxVector (remoteAddress, &packetHeader, packet);
1033c1029
<   : TestSuite ("wifi-power-rate-adaptation", UNIT)
---
>   : TestSuite ("power-rate-adaptation-wifi", UNIT)
diff ../../NS3-WiGig/src/wifi/test/spectrum-wifi-phy-test.cc ../../ns-3-dev-git/src/wifi/test/spectrum-wifi-phy-test.cc
25a26,27
> #include "ns3/wifi-mac-trailer.h"
> #include "ns3/wifi-phy-tag.h"
29,30d30
< #include "ns3/wifi-psdu.h"
< #include "ns3/wifi-ppdu.h"
58d57
< 
75c74
<    * \param psdu the PSDU
---
>    * \param p the packet
78d76
<    * \param statusPerMpdu reception status per MPDU
80c78
<   void SpectrumWifiPhyRxSuccess (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu);
---
>   void SpectrumWifiPhyRxSuccess (Ptr<Packet> p, double snr, WifiTxVector txVector);
83,85c81,84
<    * \param psdu the PSDU
< -   */
<   void SpectrumWifiPhyRxFailure (Ptr<WifiPsdu> psdu);
---
>    * \param p the packet
>    * \param snr the SNR
>    */
>   void SpectrumWifiPhyRxFailure (Ptr<Packet> p, double snr);
87d85
< 
108c106,107
<   WifiTxVector txVector = WifiTxVector (WifiPhy::GetOfdmRate6Mbps (), 0, WIFI_PREAMBLE_LONG, 800, 1, 1, 0, 20, false, false);
---
>   WifiTxVector txVector = WifiTxVector (WifiPhy::GetOfdmRate6Mbps (), 0, WIFI_PREAMBLE_LONG, false, 1, 1, 0, 20, false, false);
>   MpduType mpdutype = NORMAL_MPDU;
111a111
>   WifiMacTrailer trailer;
115,120c115,122
< 
<   Ptr<WifiPsdu> psdu = Create<WifiPsdu> (pkt, hdr);
<   Time txDuration = m_phy->CalculateTxDuration (psdu->GetSize (), txVector, m_phy->GetFrequency ());
< 
<   Ptr<WifiPpdu> ppdu = Create<WifiPpdu> (psdu, txVector, txDuration, FREQUENCY);
< 
---
>   uint32_t size = pkt->GetSize () + hdr.GetSize () + trailer.GetSerializedSize ();
>   Time txDuration = m_phy->CalculateTxDuration (size, txVector, m_phy->GetFrequency (), mpdutype, 0);
>   hdr.SetDuration (txDuration);
> 
>   pkt->AddHeader (hdr);
>   pkt->AddTrailer (trailer);
>   WifiPhyTag tag (txVector, mpdutype, 1);
>   pkt->AddPacketTag (tag);
126,127c128
<   txParams->ppdu = ppdu;
< 
---
>   txParams->packet = pkt;
139c140
< SpectrumWifiPhyBasicTest::SpectrumWifiPhyRxSuccess (Ptr<WifiPsdu> psdu, double snr, WifiTxVector txVector, std::vector<bool> statusPerMpdu)
---
> SpectrumWifiPhyBasicTest::SpectrumWifiPhyRxSuccess (Ptr<Packet> p, double snr, WifiTxVector txVector)
141c142
<   NS_LOG_FUNCTION (this << *psdu << snr << txVector);
---
>   NS_LOG_FUNCTION (this << p << snr << txVector);
146c147
< SpectrumWifiPhyBasicTest::SpectrumWifiPhyRxFailure (Ptr<WifiPsdu> psdu)
---
> SpectrumWifiPhyBasicTest::SpectrumWifiPhyRxFailure (Ptr<Packet> p, double snr)
148c149
<   NS_LOG_FUNCTION (this << *psdu);
---
>   NS_LOG_FUNCTION (this << p << snr);
168a170,171
>   //Bug 2460: CcaMode1Threshold default should be set to -62 dBm when using Spectrum
>   m_phy->SetCcaMode1Threshold (-62.0);
180c183
<   // Send packets spaced 1 microsecond second apart; none should be received (PHY header reception failure)
---
>   // Send packets spaced 1 microsecond second apart; only one should be received
186c189
<   NS_TEST_ASSERT_MSG_EQ (m_count, 3, "Didn't receive right number of packets");
---
>   NS_TEST_ASSERT_MSG_EQ (m_count, 4, "Didn't receive right number of packets");
300d302
<   NS_TEST_ASSERT_MSG_EQ (m_listener->m_notifyMaybeCcaBusyStart, 2, "Didn't receive NotifyMaybeCcaBusyStart (preamble deteted + L-SIG received)");
302a305
>   NS_TEST_ASSERT_MSG_EQ (m_listener->m_notifyMaybeCcaBusyStart, 0, "Received NotifyMaybeCcaBusyStart unexpectedly");
321c324
<   : TestSuite ("wifi-spectrum-wifi-phy", UNIT)
---
>   : TestSuite ("spectrum-wifi-phy", UNIT)
diff ../../NS3-WiGig/src/wifi/test/tx-duration-test.cc ../../ns-3-dev-git/src/wifi/test/tx-duration-test.cc
52c52
<    * @param size size of payload in octets (includes everything after the PHY header)
---
>    * @param size size of payload in octets (includes everything after the PLCP header)
67c67
<    * @param size size of payload in octets (includes everything after the PHY header)
---
>    * @param size size of payload in octets (includes everything after the PLCP header)
215c215
<   //Similar, but we add PHY preamble and header durations
---
>   //Similar, but we add PLCP preamble and header durations
318,347c318,347
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs8 (), 20, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (196))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs8 (), 20, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (48))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs8 (), 20, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (40))
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs8 (), 20, 400, WIFI_PREAMBLE_VHT_SU, MicroSeconds (180))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs8 (), 20, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (46800))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs8 (), 20, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (39600))
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs9 (), 40, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (108))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs9 (), 40, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (40))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs9 (), 40, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (40))
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs9 (), 40, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (100800))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs9 (), 40, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (39600))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs9 (), 40, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (39600))
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs0 (), 80, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (460))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs0 (), 80, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (60))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs0 (), 80, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (44))
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs0 (), 80, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (417600))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs0 (), 80, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (57600))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs0 (), 80, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (43200))
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs9 (), 80, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (68))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs9 (), 80, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (40))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs9 (), 80, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (40))
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs9 (), 80, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (64800))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs9 (), 80, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (39600))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs9 (), 80, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (39600))
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs8 (), 160, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (56))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs8 (), 160, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (40))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs8 (), 160, 800, WIFI_PREAMBLE_VHT_SU, MicroSeconds (40))
<     && CheckTxDuration (1536, WifiPhy::GetVhtMcs8 (), 160, 400, WIFI_PREAMBLE_VHT_SU, MicroSeconds (54))
<     && CheckTxDuration (76, WifiPhy::GetVhtMcs8 (), 160, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (39600))
<     && CheckTxDuration (14, WifiPhy::GetVhtMcs8 (), 160, 400, WIFI_PREAMBLE_VHT_SU, NanoSeconds (39600));
---
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs8 (), 20, 800, WIFI_PREAMBLE_VHT, MicroSeconds (200))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs8 (), 20, 800, WIFI_PREAMBLE_VHT, MicroSeconds (52))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs8 (), 20, 800, WIFI_PREAMBLE_VHT, MicroSeconds (44))
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs8 (), 20, 400, WIFI_PREAMBLE_VHT, MicroSeconds (184))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs8 (), 20, 400, WIFI_PREAMBLE_VHT, NanoSeconds (50800))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs8 (), 20, 400, WIFI_PREAMBLE_VHT, NanoSeconds (43600))
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs9 (), 40, 800, WIFI_PREAMBLE_VHT, MicroSeconds (112))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs9 (), 40, 800, WIFI_PREAMBLE_VHT, MicroSeconds (44))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs9 (), 40, 800, WIFI_PREAMBLE_VHT, MicroSeconds (44))
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs9 (), 40, 400, WIFI_PREAMBLE_VHT, NanoSeconds (104800))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs9 (), 40, 400, WIFI_PREAMBLE_VHT, NanoSeconds (43600))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs9 (), 40, 400, WIFI_PREAMBLE_VHT, NanoSeconds (43600))
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs0 (), 80, 800, WIFI_PREAMBLE_VHT, MicroSeconds (464))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs0 (), 80, 800, WIFI_PREAMBLE_VHT, MicroSeconds (64))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs0 (), 80, 800, WIFI_PREAMBLE_VHT, MicroSeconds (48))
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs0 (), 80, 400, WIFI_PREAMBLE_VHT, NanoSeconds (421600))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs0 (), 80, 400, WIFI_PREAMBLE_VHT, NanoSeconds (61600))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs0 (), 80, 400, WIFI_PREAMBLE_VHT, NanoSeconds (47200))
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs9 (), 80, 800, WIFI_PREAMBLE_VHT, MicroSeconds (72))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs9 (), 80, 800, WIFI_PREAMBLE_VHT, MicroSeconds (44))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs9 (), 80, 800, WIFI_PREAMBLE_VHT, MicroSeconds (44))
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs9 (), 80, 400, WIFI_PREAMBLE_VHT, NanoSeconds (68800))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs9 (), 80, 400, WIFI_PREAMBLE_VHT, NanoSeconds (43600))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs9 (), 80, 400, WIFI_PREAMBLE_VHT, NanoSeconds (43600))
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs8 (), 160, 800, WIFI_PREAMBLE_VHT, MicroSeconds (60))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs8 (), 160, 800, WIFI_PREAMBLE_VHT, MicroSeconds (44))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs8 (), 160, 800, WIFI_PREAMBLE_VHT, MicroSeconds (44))
>     && CheckTxDuration (1536, WifiPhy::GetVhtMcs8 (), 160, 400, WIFI_PREAMBLE_VHT, MicroSeconds (58))
>     && CheckTxDuration (76, WifiPhy::GetVhtMcs8 (), 160, 400, WIFI_PREAMBLE_VHT, NanoSeconds (43600))
>     && CheckTxDuration (14, WifiPhy::GetVhtMcs8 (), 160, 400, WIFI_PREAMBLE_VHT, NanoSeconds (43600));
442c442
<   : TestSuite ("wifi-devices-tx-duration", UNIT)
---
>   : TestSuite ("devices-wifi-tx-duration", UNIT)
diff ../../NS3-WiGig/src/wifi/test/wifi-aggregation-test.cc ../../ns-3-dev-git/src/wifi/test/wifi-aggregation-test.cc
25,26c25,26
< #include "ns3/wifi-psdu.h"
< #include "ns3/sta-wifi-mac.h"
---
> #include "ns3/mac-low.h"
> #include "ns3/qos-txop.h"
29d28
< #include "ns3/mac-low.h"
32,43c31,32
< #include "ns3/wifi-net-device.h"
< #include "ns3/ht-configuration.h"
< #include "ns3/vht-configuration.h"
< #include "ns3/he-configuration.h"
< #include "ns3/node-container.h"
< #include "ns3/yans-wifi-helper.h"
< #include "ns3/mobility-helper.h"
< #include "ns3/pointer.h"
< #include "ns3/packet-socket-server.h"
< #include "ns3/packet-socket-client.h"
< #include "ns3/packet-socket-helper.h"
< #include <iterator>
---
> #include "ns3/mgt-headers.h"
> #include "ns3/wifi-remote-station-manager.h"
60,61c49
<   Ptr<WifiNetDevice> m_device; ///<WifiNetDevice
<   Ptr<StaWifiMac> m_mac; ///< Mac
---
>   Ptr<MacLow> m_low; ///< MacLow
62a51,52
>   Ptr<QosTxop> m_txop; ///< QosTxop
>   Ptr<MacTxMiddle> m_txMiddle; ///< MacTxMiddle
64a55,56
>   Ptr<MpduAggregator> m_mpduAggregator; ///< A-MPDU aggregrator
>   Ptr<ChannelAccessManager> m_channelAccessManager; ///< channel access manager
76,82d67
<    * Create device and attach HT configuration.
<    */
<   m_device = CreateObject<WifiNetDevice> ();
<   Ptr<HtConfiguration> htConfiguration = CreateObject<HtConfiguration> ();
<   m_device->SetHtConfiguration (htConfiguration);
< 
<   /*
86d70
<   m_phy->SetDevice (m_device);
88d71
<   m_device->SetPhy (m_phy);
98c81
<   m_device->SetRemoteStationManager (m_manager);
---
>   m_manager->SetHtSupported (true);
103,109c86,104
<   m_mac = CreateObject<StaWifiMac> ();
<   m_mac->SetDevice (m_device);
<   m_mac->SetWifiPhy (m_phy);
<   m_mac->SetWifiRemoteStationManager (m_manager);
<   m_mac->SetAddress (Mac48Address ("00:00:00:00:00:01"));
<   m_mac->ConfigureStandard (WIFI_PHY_STANDARD_80211n_5GHZ);
<   m_device->SetMac (m_mac);
---
>   m_low = CreateObject<MacLow> ();
>   m_low->SetPhy (m_phy);
>   m_low->SetWifiRemoteStationManager (m_manager);
>   m_low->SetAddress (Mac48Address ("00:00:00:00:00:01"));
> 
>   m_channelAccessManager = CreateObject<ChannelAccessManager> ();
>   m_channelAccessManager->SetupLow (m_low);
>   m_channelAccessManager->SetupPhyListener (m_phy);
>   m_channelAccessManager->SetSlot (MicroSeconds (9));
> 
>   m_txop = CreateObject<QosTxop> ();
>   m_txop->SetMacLow (m_low);
>   m_txop->SetAccessCategory (AC_BE);
>   m_txop->SetWifiRemoteStationManager (m_manager);
>   m_txop->SetChannelAccessManager (m_channelAccessManager);
> 
>   m_txMiddle = Create<MacTxMiddle> ();
>   m_txop->SetTxMiddle (m_txMiddle);
>   m_txop->CompleteConfig ();
114,118c109,113
<   m_mac->SetAttribute ("BE_MaxAmpduSize", UintegerValue (65535));
<   Ptr<HtCapabilities> htCapabilities = Create<HtCapabilities> ();
<   htCapabilities->SetMaxAmpduLength (65535);
<   m_manager->AddStationHtCapabilities (Mac48Address ("00:00:00:00:00:02"), htCapabilities);
<   m_manager->AddStationHtCapabilities (Mac48Address ("00:00:00:00:00:03"), htCapabilities);
---
>   m_factory = ObjectFactory ();
>   m_factory.SetTypeId ("ns3::MpduAggregator");
>   m_mpduAggregator = m_factory.Create<MpduAggregator> ();
>   m_mpduAggregator->SetMaxAmpduSize (65535);
>   m_txop->SetMpduAggregator (m_mpduAggregator);
130c125
<   uint16_t sequence = m_mac->m_txMiddle->GetNextSequenceNumberFor (&hdr);
---
>   uint16_t sequence = m_txMiddle->GetNextSequenceNumberFor (&hdr);
142c137
<   reqHdr.SetBufferSize (64);
---
>   reqHdr.SetBufferSize (0);
145,146c140
<   m_mac->GetBEQueue ()->m_baManager->CreateAgreement (&reqHdr, hdr.GetAddr1 ());
<   m_mac->GetBEQueue ()->m_baManager->NotifyAgreementEstablished (hdr.GetAddr1 (), 0, 0);
---
>   m_txop->m_baManager->CreateAgreement (&reqHdr, hdr.GetAddr1 ());
153,157c147,153
<   WifiTxVector txVector = m_mac->GetBEQueue ()->GetLow ()->GetDataTxVector (Create<const WifiMacQueueItem> (pkt, hdr));
< 
<   auto mpduList = m_mac->GetBEQueue ()->GetLow ()->GetMpduAggregator ()->GetNextAmpdu (Create<WifiMacQueueItem> (pkt, hdr),
<                                                                                        txVector);
<   NS_TEST_EXPECT_MSG_EQ (mpduList.empty (), true, "a single packet should not result in an A-MPDU");
---
>   m_low->m_currentHdr = hdr;
>   m_low->m_currentPacket = pkt->Copy ();
>   m_low->m_currentTxVector = m_low->GetDataTxVector (m_low->m_currentPacket, &m_low->m_currentHdr);
> 
>   bool isAmpdu = m_low->IsAmpdu (pkt, hdr);
>   NS_TEST_EXPECT_MSG_EQ (isAmpdu, false, "a single packet should not result in an A-MPDU");
>   NS_TEST_EXPECT_MSG_EQ (m_low->m_aggregateQueue[0]->GetNPackets (), 0, "aggregation queue is not flushed");
178,179c174,175
<   m_mac->GetBEQueue ()->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt1, hdr1));
<   m_mac->GetBEQueue ()->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt2, hdr2));
---
>   m_txop->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt1, hdr1));
>   m_txop->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt2, hdr2));
181,188c177,182
<   mpduList = m_mac->GetBEQueue ()->GetLow ()->GetMpduAggregator ()->GetNextAmpdu (Create<WifiMacQueueItem> (pkt, hdr),
<                                                                                   txVector);
<   Ptr<WifiPsdu> psdu = Create<WifiPsdu> (mpduList);
< 
<   NS_TEST_EXPECT_MSG_EQ (mpduList.empty (), false, "MPDU aggregation failed");
<   NS_TEST_EXPECT_MSG_EQ (psdu->GetSize (), 4606, "A-MPDU size is not correct");
<   NS_TEST_EXPECT_MSG_EQ (mpduList.size (), 3, "A-MPDU should contain 3 MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (m_mac->GetBEQueue ()->GetWifiMacQueue ()->GetNPackets (), 0, "queue should be empty");
---
>   isAmpdu = m_low->IsAmpdu (pkt, hdr);
>   uint32_t aggregationQueueSize = m_low->m_aggregateQueue[0]->GetNPackets ();
>   NS_TEST_EXPECT_MSG_EQ (isAmpdu, true, "MPDU aggregation failed");
>   NS_TEST_EXPECT_MSG_EQ (m_low->m_currentPacket->GetSize (), 4606, "A-MPDU size is not correct");
>   NS_TEST_EXPECT_MSG_EQ (aggregationQueueSize, 3, "aggregation queue should not be empty");
>   NS_TEST_EXPECT_MSG_EQ (m_txop->GetWifiMacQueue ()->GetNPackets (), 0, "queue should be empty");
192c186,187
<   for (uint32_t i = 0; i < psdu->GetNMpdus (); i++)
---
>   uint32_t i = 0;
>   for (; aggregationQueueSize > 0; aggregationQueueSize--, i++)
194c189,191
<       NS_TEST_EXPECT_MSG_EQ (psdu->GetHeader (i).GetSequenceNumber (), i, "wrong sequence number");
---
>       dequeuedItem = m_low->m_aggregateQueue[0]->Dequeue ();
>       dequeuedHdr = dequeuedItem->GetHeader ();
>       NS_TEST_EXPECT_MSG_EQ (dequeuedHdr.GetSequenceNumber (), i, "wrong sequence number");
195a193
>   NS_TEST_EXPECT_MSG_EQ (aggregationQueueSize, 0, "aggregation queue should be empty");
213c211
<   hdr2.SetType (WIFI_MAC_QOSDATA);
---
>   hdr2.SetType (WIFI_MAC_DATA);
221c219
<   hdr3.SetType (WIFI_MAC_QOSDATA);
---
>   hdr3.SetType (WIFI_MAC_DATA);
224c222
<   m_mac->GetBEQueue ()->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt3, hdr3));
---
>   m_txop->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt3, hdr3));
226,232c224,232
<   mpduList = m_mac->GetBEQueue ()->GetLow ()->GetMpduAggregator ()->GetNextAmpdu (Create<WifiMacQueueItem> (pkt1, hdr1),
<                                                                                   txVector);
<   NS_TEST_EXPECT_MSG_EQ (mpduList.empty (), true, "a single packet for this destination should not result in an A-MPDU");
< 
<   mpduList = m_mac->GetBEQueue ()->GetLow ()->GetMpduAggregator ()->GetNextAmpdu (Create<WifiMacQueueItem> (pkt2, hdr2),
<                                                                                   txVector);
<   NS_TEST_EXPECT_MSG_EQ (mpduList.empty (), true, "no MPDU aggregation should be performed if there is no agreement");
---
>   isAmpdu = m_low->IsAmpdu (pkt1, hdr1);
>   NS_TEST_EXPECT_MSG_EQ (isAmpdu, false, "a single packet for this destination should not result in an A-MPDU");
>   NS_TEST_EXPECT_MSG_EQ (m_low->m_aggregateQueue[0]->GetNPackets (), 0, "aggregation queue is not flushed");
> 
>   m_txop->m_currentHdr = hdr2;
>   m_txop->m_currentPacket = pkt2->Copy ();
>   isAmpdu = m_low->IsAmpdu (pkt2, hdr2);
>   NS_TEST_EXPECT_MSG_EQ (isAmpdu, false, "no MPDU aggregation should be performed if there is no agreement");
>   NS_TEST_EXPECT_MSG_EQ (m_low->m_aggregateQueue[0]->GetNPackets (), 0, "aggregation queue is not flushed");
235,237c235
<   m_mac->GetBEQueue ()->m_currentHdr = hdr2;
<   m_mac->GetBEQueue ()->m_currentPacket = pkt2->Copy ();
<   m_mac->GetBEQueue ()->MissedAck ();
---
>   m_txop->MissedAck ();
239,240c237,238
<   NS_TEST_EXPECT_MSG_EQ (m_mac->GetBEQueue ()->m_currentPacket, 0, "packet should be discarded");
<   m_mac->GetBEQueue ()->GetWifiMacQueue ()->Remove (pkt3);
---
>   NS_TEST_EXPECT_MSG_EQ (m_txop->m_currentPacket, 0, "packet should be discarded");
>   m_txop->GetWifiMacQueue ()->Remove (pkt3);
244,245c242,245
<   m_manager->Dispose ();
<   m_manager = 0;
---
>   m_txMiddle = 0;
> 
>   m_low->Dispose ();
>   m_low = 0;
247,248c247,248
<   m_device->Dispose ();
<   m_device = 0;
---
>   m_txop->Dispose ();
>   m_txop = 0;
250c250,251
<   htConfiguration = 0;
---
>   m_channelAccessManager->Dispose ();
>   m_channelAccessManager = 0;
266,267c267
<   Ptr<WifiNetDevice> m_device; ///<WifiNetDevice
<   Ptr<StaWifiMac> m_mac; ///< Mac
---
>   Ptr<MacLow> m_low; ///< MacLow
268a269
>   Ptr<QosTxop> m_txop; ///< QosTxop
270a272,273
>   Ptr<MsduAggregator> m_msduAggregator; ///< A-MSDU aggregator
>   Ptr<MpduAggregator> m_mpduAggregator; ///< A-MPDU aggregator
282,288d284
<    * Create device and attach HT configuration.
<    */
<   m_device = CreateObject<WifiNetDevice> ();
<   Ptr<HtConfiguration> htConfiguration = CreateObject<HtConfiguration> ();
<   m_device->SetHtConfiguration (htConfiguration);
< 
<   /*
292d287
<   m_phy->SetDevice (m_device);
294d288
<   m_device->SetPhy (m_phy);
304d297
<   m_device->SetRemoteStationManager (m_manager);
307c300
<    * Create and configure mac layer.
---
>    * Create and configure maclayer.
309,315c302,310
<   m_mac = CreateObject<StaWifiMac> ();
<   m_mac->SetDevice (m_device);
<   m_mac->SetWifiPhy (m_phy);
<   m_mac->SetWifiRemoteStationManager (m_manager);
<   m_mac->SetAddress (Mac48Address ("00:00:00:00:00:01"));
<   m_mac->ConfigureStandard (WIFI_PHY_STANDARD_80211n_5GHZ);
<   m_device->SetMac (m_mac);
---
>   m_low = CreateObject<MacLow> ();
>   m_low->SetPhy (m_phy);
>   m_low->SetWifiRemoteStationManager (m_manager);
> 
>   m_txop = CreateObject<QosTxop> ();
>   m_txop->SetMacLow (m_low);
>   m_txop->SetAccessCategory (AC_BE);
>   m_txop->SetWifiRemoteStationManager (m_manager);
>   m_txop->CompleteConfig ();
320,325c315,322
<   m_mac->SetAttribute ("BE_MaxAmsduSize", UintegerValue (4095));
<   m_mac->SetAttribute ("BE_MaxAmpduSize", UintegerValue (65535));
<   Ptr<HtCapabilities> htCapabilities = Create<HtCapabilities> ();
<   htCapabilities->SetMaxAmsduLength (7935);
<   htCapabilities->SetMaxAmpduLength (65535);
<   m_manager->AddStationHtCapabilities (Mac48Address ("00:00:00:00:00:02"), htCapabilities);
---
>   m_msduAggregator = CreateObject<MsduAggregator> ();
>   m_mpduAggregator = CreateObject<MpduAggregator> ();
> 
>   m_msduAggregator->SetMaxAmsduSize (4095);
>   m_mpduAggregator->SetMaxAmpduSize (65535);
> 
>   m_txop->SetMsduAggregator (m_msduAggregator);
>   m_txop->SetMpduAggregator (m_mpduAggregator);
332,334c329,331
<   WifiMacHeader hdr;
<   hdr.SetAddr1 (Mac48Address ("00:00:00:00:00:02"));
<   hdr.SetAddr2 (Mac48Address ("00:00:00:00:00:01"));
---
>   WifiMacHeader hdr, peekedHdr;
>   hdr.SetAddr1 (Mac48Address ("00:00:00:00:00:01"));
>   hdr.SetAddr2 (Mac48Address ("00:00:00:00:00:02"));
336a334
>   Time tstamp;
341c339
<    * Test MSDU aggregation of two packets using MsduAggregator::GetNextAmsdu.
---
>    * Test MSDU aggregation of two packets using MacLow::PerformMsduAggregation.
347,348c345,354
<   m_mac->GetBEQueue ()->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt, hdr));
<   m_mac->GetBEQueue ()->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt, hdr));
---
>   m_txop->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt, hdr));
>   m_txop->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt, hdr));
> 
>   Ptr<const WifiMacQueueItem> peekedItem = m_txop->GetWifiMacQueue ()->PeekByTidAndAddress (0, hdr.GetAddr1 ());
>   Ptr<const Packet> peekedPacket = peekedItem->GetPacket ();
>   peekedHdr = peekedItem->GetHeader ();
>   tstamp = peekedItem->GetTimeStamp ();
>   m_low->m_currentPacket = peekedPacket->Copy ();
>   m_low->m_currentHdr = peekedHdr;
>   m_low->m_currentTxVector = m_low->GetDataTxVector (m_low->m_currentPacket, &m_low->m_currentHdr);
350c356
<   WifiTxVector txVector = m_mac->GetBEQueue ()->GetLow ()->GetDataTxVector (Create<const WifiMacQueueItem> (pkt, hdr));
---
>   Ptr<Packet> packet = m_low->PerformMsduAggregation (peekedPacket, &peekedHdr, &tstamp, currentAggregatedPacket, 0);
352,355c358
<   Ptr<WifiMacQueueItem> item;
<   item = m_mac->GetBEQueue ()->GetLow ()->GetMsduAggregator ()->GetNextAmsdu (hdr.GetAddr1 (), 0, txVector,
<                                                                               currentAggregatedPacket->GetSize ());
<   bool result = (item != 0);
---
>   bool result = (packet != 0);
357,358c360,361
<   NS_TEST_EXPECT_MSG_EQ (item->GetPacket ()->GetSize (), 3030, "wrong packet size");
<   NS_TEST_EXPECT_MSG_EQ (m_mac->GetBEQueue ()->GetWifiMacQueue ()->GetNPackets (), 0, "aggregated packets not removed from the queue");
---
>   NS_TEST_EXPECT_MSG_EQ (packet->GetSize (), 3030, "wrong packet size");
>   NS_TEST_EXPECT_MSG_EQ (m_txop->GetWifiMacQueue ()->GetNPackets (), 0, "aggregated packets not removed from the queue");
365,366c368
<    * This test is needed to ensure that no packets are removed from the queue in
<    * MsduAggregator::GetNextAmsdu, since aggregation will no occur in MacLow::AggregateToAmpdu.
---
>    * This test is needed to ensure that no packets are removed from the queue in MacLow::PerformMsduAggregation, since aggregation will no occur in MacLow::AggregateToAmpdu.
368c370,374
<   m_mac->SetAttribute ("BE_MaxAmpduSize", UintegerValue (65535));
---
>   m_factory = ObjectFactory ();
>   m_factory.SetTypeId ("ns3::MpduAggregator");
>   m_mpduAggregator = m_factory.Create<MpduAggregator> ();
>   m_mpduAggregator->SetMaxAmpduSize (65535);
>   m_txop->SetMpduAggregator (m_mpduAggregator);
370c376,377
<   m_mac->GetBEQueue ()->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt, hdr));
---
>   m_txop->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt, hdr));
>   packet = m_low->PerformMsduAggregation (peekedPacket, &peekedHdr, &tstamp, currentAggregatedPacket, 0);
372,374c379
<   item = m_mac->GetBEQueue ()->GetLow ()->GetMsduAggregator ()->GetNextAmsdu (hdr.GetAddr1 (), 0, txVector,
<                                                                               currentAggregatedPacket->GetSize ());
<   result = (item != 0);
---
>   result = (packet != 0);
384,387c389
<   m_mac->SetAttribute ("BE_MaxAmpduSize", UintegerValue (4095));
< 
<   m_mac->GetBEQueue ()->GetWifiMacQueue ()->Remove (pkt);
<   m_mac->GetBEQueue ()->GetWifiMacQueue ()->Remove (pkt);
---
>   m_mpduAggregator->SetMaxAmpduSize (4095);
389,390c391,393
<   item = m_mac->GetBEQueue ()->GetLow ()->GetMsduAggregator ()->GetNextAmsdu (hdr.GetAddr1 (), 0, txVector,
<                                                                               currentAggregatedPacket->GetSize ());
---
>   m_txop->GetWifiMacQueue ()->Remove (pkt);
>   m_txop->GetWifiMacQueue ()->Remove (pkt);
>   packet = m_low->PerformMsduAggregation (peekedPacket, &peekedHdr, &tstamp, currentAggregatedPacket, 0);
392c395
<   result = (item != 0);
---
>   result = (packet != 0);
395,596d397
<   //-----------------------------------------------------------------------------------------------------
< 
<   /*
<    * Aggregation of MPDUs is stopped to prevent that the PPDU duration exceeds the TXOP limit.
<    * In this test, the VI AC is used, which has a default TXOP limit of 3008 microseconds.
<    */
< 
<   // Establish agreement.
<   uint8_t tid = 5;
<   MgtAddBaRequestHeader reqHdr;
<   reqHdr.SetImmediateBlockAck ();
<   reqHdr.SetTid (tid);
<   reqHdr.SetBufferSize (64);
<   reqHdr.SetTimeout (0);
<   reqHdr.SetStartingSequence (0);
<   m_mac->GetVIQueue ()->m_baManager->CreateAgreement (&reqHdr, hdr.GetAddr1 ());
<   m_mac->GetVIQueue ()->m_baManager->NotifyAgreementEstablished (hdr.GetAddr1 (), tid, 0);
< 
<   m_mac->SetAttribute ("VI_MaxAmsduSize", UintegerValue (3050));  // max 2 MSDUs per A-MSDU
<   m_mac->SetAttribute ("VI_MaxAmpduSize", UintegerValue (65535));
<   m_manager->SetAttribute ("DataMode", StringValue ("HtMcs2"));  // 19.5Mbps
< 
<   pkt = Create<Packet> (1400);
<   hdr.SetQosTid (tid);
< 
<   // Add 10 MSDUs to the EDCA queue
<   for (uint8_t i = 0; i < 10; i++)
<     {
<       m_mac->GetVIQueue ()->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt, hdr));
<     }
< 
<   txVector = m_mac->GetVIQueue ()->GetLow ()->GetDataTxVector (Create<const WifiMacQueueItem> (pkt, hdr));
<   Time txopLimit = m_mac->GetVIQueue ()->GetTxopLimit ();   // 3.008 ms
< 
<   // Compute the first MPDU to be aggregated in an A-MPDU. It must contain an A-MSDU
<   // aggregating two MSDUs
<   Ptr<WifiMacQueueItem> mpdu = m_mac->GetVIQueue ()->GetLow ()->GetMsduAggregator ()->GetNextAmsdu (hdr.GetAddr1 (), tid,
<                                                                                                     txVector, 0, txopLimit);
<   NS_TEST_EXPECT_MSG_EQ (m_mac->GetVIQueue ()->GetWifiMacQueue ()->GetNPackets (), 8, "There must be 8 MSDUs left in EDCA queue");
< 
<   auto mpduList = m_mac->GetVIQueue ()->GetLow ()->GetMpduAggregator ()->GetNextAmpdu (mpdu, txVector, txopLimit);
< 
<   // The maximum number of bytes that can be transmitted in a TXOP is (approximately, as we
<   // do not consider that the preamble is transmitted at a different rate):
<   // 19.5 Mbps * 3.008 ms = 7332 bytes
<   // Given that the max A-MSDU size is set to 3050, an A-MSDU will contain two MSDUs and have
<   // a size of 2 * 1400 (MSDU size) + 2 * 14 (A-MSDU subframe header size) + 2 (one padding field) = 2830 bytes
<   // Hence, we expect that the A-MPDU will consist of:
<   // - 2 MPDUs containing each an A-MSDU. The size of each MPDU is 2830 (A-MSDU) + 30 (header+trailer) = 2860
<   // - 1 MPDU containing a single MSDU. The size of such MPDU is 1400 (MSDU) + 30 (header+trailer) = 1430
<   // The size of the A-MPDU is 4 + 2860 + 4 + 2860 + 4 + 1430 = 7162
<   NS_TEST_EXPECT_MSG_EQ (mpduList.empty (), false, "aggregation failed");
<   NS_TEST_EXPECT_MSG_EQ (mpduList.size (), 3, "Unexpected number of MPDUs in the A-MPDU");
<   NS_TEST_EXPECT_MSG_EQ (mpduList.at (0)->GetSize (), 2860, "Unexpected size of the first MPDU");
<   NS_TEST_EXPECT_MSG_EQ (mpduList.at (1)->GetSize (), 2860, "Unexpected size of the second MPDU");
<   NS_TEST_EXPECT_MSG_EQ (mpduList.at (2)->GetSize (), 1430, "Unexpected size of the first MPDU");
<   NS_TEST_EXPECT_MSG_EQ (m_mac->GetVIQueue ()->GetWifiMacQueue ()->GetNPackets (), 5,
<                          "Unexpected number of MSDUs left in the EDCA queue");
< 
<   Ptr<WifiPsdu> psdu = Create<WifiPsdu> (mpduList);
<   NS_TEST_EXPECT_MSG_EQ (psdu->GetSize (), 7162, "Unexpected size of the A-MPDU");
< 
<   Simulator::Destroy ();
< 
<   m_device->Dispose ();
<   m_device = 0;
<   htConfiguration = 0;
< }
< 
< /**
<  * \ingroup wifi-test
<  * \ingroup tests
<  *
<  * \brief 802.11ax aggregation test which permits 64 or 256 MPDUs in A-MPDU according to the negociated buffer size.
<  */
< class HeAggregationTest : public TestCase
< {
< public:
<   HeAggregationTest ();
< 
< private:
<   void DoRun (void);
<   /**
<    * Run test for a given buffer size
<    *
<    * \param bufferSize the buffer size
<    */
<   void DoRunSubTest (uint16_t bufferSize);
<   Ptr<WifiNetDevice> m_device; ///<WifiNetDevice
<   Ptr<StaWifiMac> m_mac; ///< Mac
<   Ptr<YansWifiPhy> m_phy; ///< Phy
<   Ptr<WifiRemoteStationManager> m_manager; ///< remote station manager
<   ObjectFactory m_factory; ///< factory
< };
< 
< HeAggregationTest::HeAggregationTest ()
<   : TestCase ("Check the correctness of 802.11ax aggregation operations")
< {
< }
< 
< void
< HeAggregationTest::DoRunSubTest (uint16_t bufferSize)
< {
<   /*
<    * Create device and attach configurations.
<    */
<   m_device = CreateObject<WifiNetDevice> ();
<   Ptr<HtConfiguration> htConfiguration = CreateObject<HtConfiguration> ();
<   m_device->SetHtConfiguration (htConfiguration);
<   Ptr<VhtConfiguration> vhtConfiguration = CreateObject<VhtConfiguration> ();
<   m_device->SetVhtConfiguration (vhtConfiguration);
<   Ptr<HeConfiguration> heConfiguration = CreateObject<HeConfiguration> ();
<   m_device->SetHeConfiguration (heConfiguration);
< 
<   /*
<    * Create and configure phy layer.
<    */
<   m_phy = CreateObject<YansWifiPhy> ();
<   m_phy->SetDevice (m_device);
<   m_phy->ConfigureStandard (WIFI_PHY_STANDARD_80211ax_5GHZ);
<   m_device->SetPhy (m_phy);
< 
<   /*
<    * Create and configure manager.
<    */
<   m_factory = ObjectFactory ();
<   m_factory.SetTypeId ("ns3::ConstantRateWifiManager");
<   m_factory.Set ("DataMode", StringValue ("HeMcs11"));
<   m_manager = m_factory.Create<WifiRemoteStationManager> ();
<   m_manager->SetupPhy (m_phy);
<   m_device->SetRemoteStationManager (m_manager);
< 
<   /*
<    * Create and configure mac layer.
<    */
<   m_mac = CreateObject<StaWifiMac> ();
<   m_mac->SetDevice (m_device);
<   m_mac->SetWifiPhy (m_phy);
<   m_mac->SetWifiRemoteStationManager (m_manager);
<   m_mac->SetAddress (Mac48Address ("00:00:00:00:00:01"));
<   m_mac->ConfigureStandard (WIFI_PHY_STANDARD_80211ax_5GHZ);
<   m_device->SetMac (m_mac);
< 
<   /*
<    * Configure aggregation.
<    */
<   Ptr<HeCapabilities> heCapabilities = Create<HeCapabilities> ();
<   m_manager->AddStationHeCapabilities (Mac48Address ("00:00:00:00:00:02"), heCapabilities);
< 
<   /*
<    * Create a dummy packet of 100 bytes and fill mac header fields.
<    */
<   Ptr<const Packet> pkt = Create<Packet> (100);
<   Ptr<Packet> currentAggregatedPacket = Create<Packet> ();
<   WifiMacHeader hdr;
<   hdr.SetAddr1 (Mac48Address ("00:00:00:00:00:02"));
<   hdr.SetAddr2 (Mac48Address ("00:00:00:00:00:01"));
<   hdr.SetType (WIFI_MAC_QOSDATA);
<   hdr.SetQosTid (0);
<   uint16_t sequence = m_mac->m_txMiddle->GetNextSequenceNumberFor (&hdr);
<   hdr.SetSequenceNumber (sequence);
<   hdr.SetFragmentNumber (0);
<   hdr.SetNoMoreFragments ();
<   hdr.SetNoRetry ();
< 
<   /*
<    * Establish agreement.
<    */
<   MgtAddBaRequestHeader reqHdr;
<   reqHdr.SetImmediateBlockAck ();
<   reqHdr.SetTid (0);
<   reqHdr.SetBufferSize (bufferSize);
<   reqHdr.SetTimeout (0);
<   reqHdr.SetStartingSequence (0);
<   m_mac->GetBEQueue ()->m_baManager->CreateAgreement (&reqHdr, hdr.GetAddr1 ());
<   m_mac->GetBEQueue ()->m_baManager->NotifyAgreementEstablished (hdr.GetAddr1 (), 0, 0);
< 
<   /*
<    * Test behavior when 300 packets are ready for transmission but negociated buffer size is 64
<    */
<   for (uint16_t i = 0; i < 300; i++)
<     {
<       Ptr<const Packet> pkt = Create<Packet> (100);
<       WifiMacHeader hdr;
< 
<       hdr.SetAddr1 (Mac48Address ("00:00:00:00:00:02"));
<       hdr.SetAddr2 (Mac48Address ("00:00:00:00:00:01"));
<       hdr.SetType (WIFI_MAC_QOSDATA);
<       hdr.SetQosTid (0);
< 
<       m_mac->GetBEQueue ()->GetWifiMacQueue ()->Enqueue (Create<WifiMacQueueItem> (pkt, hdr));
<   }
< 
<   WifiTxVector txVector = m_mac->GetBEQueue ()->GetLow ()->GetDataTxVector (Create<const WifiMacQueueItem> (pkt, hdr));
< 
<   auto mpduList = m_mac->GetBEQueue ()->GetLow ()->GetMpduAggregator ()-> GetNextAmpdu (Create<WifiMacQueueItem> (pkt, hdr),
<                                                                                         txVector);
<   NS_TEST_EXPECT_MSG_EQ (mpduList.empty (), false, "MPDU aggregation failed");
<   NS_TEST_EXPECT_MSG_EQ (mpduList.size (), bufferSize, "A-MPDU should countain " << bufferSize << " MPDUs");
<   uint16_t expectedRemainingPacketsInQueue = 300 - bufferSize + 1;
<   NS_TEST_EXPECT_MSG_EQ (m_mac->GetBEQueue ()->GetWifiMacQueue ()->GetNPackets (), expectedRemainingPacketsInQueue, "queue should contain 300 - "<< bufferSize - 1 << " = "<< expectedRemainingPacketsInQueue << " packets");
< 
599,692c400,401
<   m_manager->Dispose ();
<   m_manager = 0;
< 
<   m_device->Dispose ();
<   m_device = 0;
< 
<   htConfiguration = 0;
<   vhtConfiguration = 0;
<   heConfiguration = 0;
< }
< 
< void
< HeAggregationTest::DoRun ()
< {
<   DoRunSubTest (64);
<   DoRunSubTest (256);
< }
< 
< /**
<  * \ingroup wifi-test
<  * \ingroup tests
<  *
<  * \brief Test for A-MSDU and A-MPDU aggregation
<  *
<  * This test aims to check that the packets passed to the MAC layer (on the sender
<  * side) are forwarded up to the upper layer (on the receiver side) when A-MSDU and
<  * A-MPDU aggregation are used. This test checks that no packet copies are performed,
<  * hence packets can be tracked by means of a pointer.
<  *
<  * In this test, an HT STA sends 8 packets (each of 1000 bytes) to an HT AP.
<  * The block ack threshold is set to 2, hence the first packet is sent as an MPDU
<  * containing a single MSDU because the establishment of a Block Ack agreement is
<  * not triggered yet. The maximum A-MSDU size is set to 4500 bytes and the
<  * maximum A-MPDU size is set to 7500 bytes, hence the remaining packets are sent
<  * in an A-MPDU containing two MPDUs, the first one including 4 MSDUs and the second
<  * one including 3 MPDUs.
<  */
< class PreservePacketsInAmpdus : public TestCase
< {
< public:
<   PreservePacketsInAmpdus ();
<   virtual ~PreservePacketsInAmpdus ();
< 
<   virtual void DoRun (void);
< 
< 
< private:
<   std::list<Ptr<const Packet>> m_packetList; ///< List of packets passed to the MAC
<   std::vector<std::size_t> m_nMpdus;         ///< Number of MPDUs in PSDUs passed to the PHY
<   std::vector<std::size_t> m_nMsdus;         ///< Number of MSDUs in MPDUs passed to the PHY
< 
<   /**
<    * Callback invoked when an MSDU is passed to the MAC
<    * \param packet the MSDU to transmit
<    */
<   void NotifyMacTransmit (Ptr<const Packet> packet);
<   /**
<    * Callback invoked when the sender MAC passes a PSDU(s) to the PHY
<    * \param psdu the PSDU
<    * \param txVector the TX vector
<    * \param txPowerW the transmit power in Watts
<    */
<   void NotifyPsduForwardedDown (Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW);
<   /**
<    * Callback invoked when the receiver MAC forwards a packet up to the upper layer
<    * \param p the packet
<    */
<   void NotifyMacForwardUp (Ptr<const Packet> p);
< };
< 
< PreservePacketsInAmpdus::PreservePacketsInAmpdus ()
<   : TestCase ("Test case to check that the Wifi Mac forwards up the same packets received at sender side.")
< {
< }
< 
< PreservePacketsInAmpdus::~PreservePacketsInAmpdus ()
< {
< }
< 
< void
< PreservePacketsInAmpdus::NotifyMacTransmit (Ptr<const Packet> packet)
< {
<   m_packetList.push_back (packet);
< }
< 
< void
< PreservePacketsInAmpdus::NotifyPsduForwardedDown (Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW)
< {
<   if (!psdu->GetHeader (0).IsQosData ())
<     {
<       return;
<     }
< 
<   m_nMpdus.push_back (psdu->GetNMpdus ());
---
>   m_low->Dispose ();
>   m_low = 0;
694,699c403,404
<   for (auto& mpdu : *PeekPointer (psdu))
<     {
<       std::size_t dist = std::distance (mpdu->begin (), mpdu->end ());
<       // the list of aggregated MSDUs is empty if the MPDU includes a non-aggregated MSDU
<       m_nMsdus.push_back (dist > 0 ? dist : 1);
<     }
---
>   m_txop->Dispose ();
>   m_txop = 0;
702,816d406
< void
< PreservePacketsInAmpdus::NotifyMacForwardUp (Ptr<const Packet> p)
< {
<   auto it = std::find (m_packetList.begin (), m_packetList.end (), p);
<   NS_TEST_EXPECT_MSG_EQ ((it != m_packetList.end ()), true, "Packet being forwarded up not found");
<   m_packetList.erase (it);
< }
< 
< void
< PreservePacketsInAmpdus::DoRun (void)
< {
<   NodeContainer wifiStaNode;
<   wifiStaNode.Create (1);
< 
<   NodeContainer wifiApNode;
<   wifiApNode.Create (1);
< 
<   YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
<   YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
<   phy.SetChannel (channel.Create ());
< 
<   WifiHelper wifi;
<   wifi.SetStandard (WIFI_PHY_STANDARD_80211n_5GHZ);
<   wifi.SetRemoteStationManager ("ns3::IdealWifiManager");
< 
<   WifiMacHelper mac;
<   Ssid ssid = Ssid ("ns-3-ssid");
<   mac.SetType ("ns3::StaWifiMac",
<                "BE_MaxAmsduSize", UintegerValue (4500),
<                "BE_MaxAmpduSize", UintegerValue (7500),
<                "Ssid", SsidValue (ssid),
<                /* setting blockack threshold for sta's BE queue */
<                "BE_BlockAckThreshold", UintegerValue (2),
<                "ActiveProbing", BooleanValue (false));
< 
<   NetDeviceContainer staDevices;
<   staDevices = wifi.Install (phy, mac, wifiStaNode);
< 
<   mac.SetType ("ns3::ApWifiMac",
<                "Ssid", SsidValue (ssid),
<                "BeaconGeneration", BooleanValue (true));
< 
<   NetDeviceContainer apDevices;
<   apDevices = wifi.Install (phy, mac, wifiApNode);
< 
<   MobilityHelper mobility;
<   Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
< 
<   positionAlloc->Add (Vector (0.0, 0.0, 0.0));
<   positionAlloc->Add (Vector (1.0, 0.0, 0.0));
<   mobility.SetPositionAllocator (positionAlloc);
< 
<   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
<   mobility.Install (wifiApNode);
<   mobility.Install (wifiStaNode);
< 
<   Ptr<WifiNetDevice> ap_device = DynamicCast<WifiNetDevice> (apDevices.Get (0));
<   Ptr<WifiNetDevice> sta_device = DynamicCast<WifiNetDevice> (staDevices.Get (0));
< 
<   PacketSocketAddress socket;
<   socket.SetSingleDevice (sta_device->GetIfIndex ());
<   socket.SetPhysicalAddress (ap_device->GetAddress ());
<   socket.SetProtocol (1);
< 
<   // install packet sockets on nodes.
<   PacketSocketHelper packetSocket;
<   packetSocket.Install (wifiStaNode);
<   packetSocket.Install (wifiApNode);
< 
<   Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient> ();
<   client->SetAttribute ("PacketSize", UintegerValue (1000));
<   client->SetAttribute ("MaxPackets", UintegerValue (8));
<   client->SetAttribute ("Interval", TimeValue (Seconds (1)));
<   client->SetRemote (socket);
<   wifiStaNode.Get (0)->AddApplication (client);
<   client->SetStartTime (Seconds (1));
<   client->SetStopTime (Seconds (3.0));
<   Simulator::Schedule (Seconds (1.5), &PacketSocketClient::SetAttribute, client,
<                        "Interval", TimeValue (MicroSeconds (0)));
< 
<   Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer> ();
<   server->SetLocal (socket);
<   wifiApNode.Get (0)->AddApplication (server);
<   server->SetStartTime (Seconds (0.0));
<   server->SetStopTime (Seconds (4.0));
< 
<   PointerValue ptr;
<   sta_device->GetMac ()->GetAttribute ("BE_Txop", ptr);
<   Ptr<QosTxop> qosTxop = ptr.Get<QosTxop> ();
< 
<   sta_device->GetMac ()->TraceConnectWithoutContext ("MacTx",
<     MakeCallback (&PreservePacketsInAmpdus::NotifyMacTransmit, this));
<   qosTxop->GetLow ()->GetPhy ()->TraceConnectWithoutContext ("PhyTxPsduBegin",
<     MakeCallback (&PreservePacketsInAmpdus::NotifyPsduForwardedDown, this));
<   ap_device->GetMac ()->TraceConnectWithoutContext ("MacRx",
<     MakeCallback (&PreservePacketsInAmpdus::NotifyMacForwardUp, this));
< 
<   Simulator::Stop (Seconds (5));
<   Simulator::Run ();
< 
<   Simulator::Destroy ();
< 
<   // Two packets are transmitted. The first one is an MPDU containing a single MSDU.
<   // The second one is an A-MPDU containing two MPDUs: the first MPDU contains 4 MSDUs
<   // and the second MPDU contains 3 MSDUs
<   NS_TEST_EXPECT_MSG_EQ (m_nMpdus.size (), 2, "Unexpected number of transmitted packets");
<   NS_TEST_EXPECT_MSG_EQ (m_nMsdus.size (), 3, "Unexpected number of transmitted MPDUs");
<   NS_TEST_EXPECT_MSG_EQ (m_nMpdus[0], 1, "Unexpected number of MPDUs in the first A-MPDU");
<   NS_TEST_EXPECT_MSG_EQ (m_nMsdus[0], 1, "Unexpected number of MSDUs in the first MPDU");
<   NS_TEST_EXPECT_MSG_EQ (m_nMpdus[1], 2, "Unexpected number of MPDUs in the second A-MPDU");
<   NS_TEST_EXPECT_MSG_EQ (m_nMsdus[1], 4, "Unexpected number of MSDUs in the second MPDU");
<   NS_TEST_EXPECT_MSG_EQ (m_nMsdus[2], 3, "Unexpected number of MSDUs in the third MPDU");
<   // All the packets must have been forwarded up at the receiver
<   NS_TEST_EXPECT_MSG_EQ (m_packetList.empty (), true, "Some packets have not been forwarded up");
< }
831c421
<   : TestSuite ("wifi-aggregation", UNIT)
---
>   : TestSuite ("aggregation-wifi", UNIT)
835,836d424
<   AddTestCase (new HeAggregationTest, TestCase::QUICK);
<   AddTestCase (new PreservePacketsInAmpdus, TestCase::QUICK);
diff ../../NS3-WiGig/src/wifi/test/wifi-error-rate-models-test.cc ../../ns-3-dev-git/src/wifi/test/wifi-error-rate-models-test.cc
20a21
> #include <cmath>
24,25c25
< #include "ns3/wifi-phy.h"
< #include "ns3/wifi-utils.h"
---
> #include "ns3/wifi-tx-vector.h"
294,452d293
< class TestInterferenceHelper : public InterferenceHelper
< {
< public:
<   using InterferenceHelper::InterferenceHelper;
<   using InterferenceHelper::CalculateChunkSuccessRate;
<   using InterferenceHelper::CalculateSnr;
< };
< 
< /**
<  * \ingroup wifi-test
<  * \ingroup tests
<  *
<  * \brief Wifi Error Rate Models Test Case MIMO
<  */
< class WifiErrorRateModelsTestCaseMimo : public TestCase
< {
< public:
<   WifiErrorRateModelsTestCaseMimo ();
<   virtual ~WifiErrorRateModelsTestCaseMimo ();
< 
< private:
<   virtual void DoRun (void);
< };
< 
< WifiErrorRateModelsTestCaseMimo::WifiErrorRateModelsTestCaseMimo ()
<   : TestCase ("WifiErrorRateModel test case MIMO")
< {
< }
< 
< WifiErrorRateModelsTestCaseMimo::~WifiErrorRateModelsTestCaseMimo ()
< {
< }
< 
< void
< WifiErrorRateModelsTestCaseMimo::DoRun (void)
< {
<   TestInterferenceHelper interference;
<   interference.SetNoiseFigure (0);
<   WifiMode mode = WifiPhy::GetHtMcs0 ();
<   WifiTxVector txVector;
< 
<   txVector.SetMode (mode);
<   txVector.SetTxPowerLevel (0);
<   txVector.SetChannelWidth (20);
<   txVector.SetNss (1);
<   txVector.SetNTx (1);
< 
<   interference.SetNumberOfReceiveAntennas (1);
<   Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel> ();
<   interference.SetErrorRateModel (nist);
< 
<   // SISO: initial SNR set to 4dB
<   double initialSnr = 4.0;
<   double snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr, 0.1, "Attempt to set initial SNR to known value failed");
<   Time duration = MilliSeconds (2);
<   double chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (chunkSuccess, 0.905685, 0.000001, "CSR not within tolerance for SISO");
<   double sisoChunkSuccess = chunkSuccess;
< 
<   // MIMO 2x1:2: expect no SNR gain in AWGN channel
<   txVector.SetNss (2);
<   txVector.SetNTx (2);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr, 0.1, "SNR not within tolerance for 2x1:2 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (chunkSuccess, 0.905685, 0.000001, "CSR not within tolerance for SISO");
< 
<   // MIMO 1x2:1: expect that SNR is increased by a factor of 3 dB (10 log 2/1) compared to SISO thanks to RX diversity
<   txVector.SetNss (1);
<   txVector.SetNTx (1);
<   interference.SetNumberOfReceiveAntennas (2);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr + 3, 0.1, "SNR not within tolerance for 1x2:1 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_GT (chunkSuccess, sisoChunkSuccess, "CSR not within tolerance for 1x2:1 MIMO");
< 
<   // MIMO 2x2:1: expect that SNR is increased by a factor of 3 dB (10 log 2/1) compared to SISO thanks to RX diversity
<   txVector.SetNss (1);
<   txVector.SetNTx (2);
<   interference.SetNumberOfReceiveAntennas (2);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr + 3, 0.1, "SNR not equal within tolerance for 2x2:1 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_GT (chunkSuccess, sisoChunkSuccess, "CSR not within tolerance for 2x2:1 MIMO");
< 
<  // MIMO 2x2:2: expect no SNR gain in AWGN channel
<   txVector.SetNss (2);
<   txVector.SetNTx (2);
<   interference.SetNumberOfReceiveAntennas (2);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr, 0.1, "SNR not equal within tolerance for 2x2:2 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (chunkSuccess, sisoChunkSuccess, 0.000001, "CSR not within tolerance for 2x2:2 MIMO");
< 
<   // MIMO 3x3:1: expect that SNR is increased by a factor of 4.8 dB (10 log 3/1) compared to SISO thanks to RX diversity
<   txVector.SetNss (1);
<   txVector.SetNTx (3);
<   interference.SetNumberOfReceiveAntennas (3);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr + 4.8, 0.1, "SNR not within tolerance for 3x3:1 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_GT (chunkSuccess, sisoChunkSuccess, "CSR not within tolerance for 3x3:1 MIMO");
< 
<   // MIMO 3x3:2: expect that SNR is increased by a factor of 1.8 dB (10 log 3/2) compared to SISO thanks to RX diversity
<   txVector.SetNss (2);
<   txVector.SetNTx (3);
<   interference.SetNumberOfReceiveAntennas (3);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr + 1.8, 0.1, "SNR not within tolerance for 3x3:2 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_GT (chunkSuccess, sisoChunkSuccess, "CSR not within tolerance for 3x3:2 MIMO");
< 
<   // MIMO 3x3:3: expect no SNR gain in AWGN channel
<   txVector.SetNss (3);
<   txVector.SetNTx (3);
<   interference.SetNumberOfReceiveAntennas (3);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr, 0.1, "SNR not within tolerance for 3x3:3 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (chunkSuccess, sisoChunkSuccess, 0.000001, "CSR not equal within tolerance for 3x3:3 MIMO");
< 
<   // MIMO 4x4:1: expect that SNR is increased by a factor of 6 dB (10 log 4/1) compared to SISO thanks to RX diversity
<   txVector.SetNss (1);
<   txVector.SetNTx (4);
<   interference.SetNumberOfReceiveAntennas (4);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr + 6, 0.1, "SNR not within tolerance for 4x4:1 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_GT (chunkSuccess, sisoChunkSuccess, "CSR not within tolerance for 4x4:1 MIMO");
< 
<   // MIMO 4x4:2: expect that SNR is increased by a factor of 3 dB (10 log 4/2) compared to SISO thanks to RX diversity
<   txVector.SetNss (2);
<   txVector.SetNTx (4);
<   interference.SetNumberOfReceiveAntennas (4);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr + 3, 0.1, "SNR not within tolerance for 4x4:2 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_GT (chunkSuccess, sisoChunkSuccess, "CSR not within tolerance for 4x4:2 MIMO");
< 
<   // MIMO 4x4:3: expect that SNR is increased by a factor of 1.2 dB (10 log 4/3) compared to SISO thanks to RX diversity
<   txVector.SetNss (3);
<   txVector.SetNTx (4);
<   interference.SetNumberOfReceiveAntennas (4);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr + 1.2, 0.1, "SNR not within tolerance for 4x4:3 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_GT (chunkSuccess, sisoChunkSuccess, "CSR not within tolerance for 4x4:1 MIMO");
< 
<   // MIMO 4x4:4: expect no SNR gain in AWGN channel
<   txVector.SetNss (4);
<   txVector.SetNTx (4);
<   interference.SetNumberOfReceiveAntennas (4);
<   snr = interference.CalculateSnr (0.001, 0.001 / DbToRatio (initialSnr), txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (RatioToDb (snr), initialSnr, 0.1, "SNR not within tolerance for 4x4:4 MIMO");
<   chunkSuccess = interference.CalculateChunkSuccessRate (snr, duration, mode, txVector);
<   NS_TEST_ASSERT_MSG_EQ_TOL (chunkSuccess, sisoChunkSuccess, 0.000001, "CSR not within tolerance for 4x4:4 MIMO");
< }
< 
470d310
<   AddTestCase (new WifiErrorRateModelsTestCaseMimo, TestCase::QUICK);
Only in ../../NS3-WiGig/src/wifi/test: wifi-phy-reception-test.cc
Only in ../../NS3-WiGig/src/wifi/test: wifi-phy-thresholds-test.cc
diff ../../NS3-WiGig/src/wifi/test/wifi-test.cc ../../ns-3-dev-git/src/wifi/test/wifi-test.cc
37,38d36
< #include "ns3/error-model.h"
< #include "ns3/socket.h"
44a43
> #include "ns3/wifi-phy-tag.h"
47,51d45
< #include "ns3/ht-configuration.h"
< #include "ns3/wifi-ppdu.h"
< #include "ns3/wifi-psdu.h"
< #include "ns3/waypoint-mobility-model.h"
< #include "ns3/wifi-mac-trailer.h"
140d133
<   mac->SetDevice (dev);
290c283
<   Ptr<Packet> p = Create<Packet> (1000);
---
>   Ptr<Packet> p = Create<Packet> (9999);
308d300
<   mac->SetDevice (dev);
451d442
<    * \param txPowerW the tx power
453c444
<   void NotifyPhyTxBegin (Ptr<const Packet> p, double txPowerW);
---
>   void NotifyPhyTxBegin (Ptr<const Packet> p);
462c453
< DcfImmediateAccessBroadcastTestCase::NotifyPhyTxBegin (Ptr<const Packet> p, double txPowerW)
---
> DcfImmediateAccessBroadcastTestCase::NotifyPhyTxBegin (Ptr<const Packet> p)
465a457
>       NS_ASSERT_MSG (Simulator::Now () == Time (Seconds (1)), "Packet 0 not transmitted at 1 second");
503d494
<   txMac->SetDevice (txDev);
541,544d531
<   // First packet is transmitted a DIFS after the packet is queued. A DIFS
<   // is 2 slots (2 * 9 = 18 us) plus a SIFS (16 us), i.e., 34 us
<   Time expectedFirstTransmissionTime = Seconds (1.0) + MicroSeconds (34);
< 
550,551c537,538
<   Time expectedSecondTransmissionTime = expectedFirstTransmissionTime + MicroSeconds (expectedWait1);
<   NS_TEST_ASSERT_MSG_EQ (m_firstTransmissionTime, expectedFirstTransmissionTime, "The first transmission time not correct!");
---
>   Time expectedSecondTransmissionTime = MicroSeconds (expectedWait1) + MilliSeconds (1000);
>   NS_TEST_ASSERT_MSG_EQ (m_firstTransmissionTime, MilliSeconds (1000), "The first transmission time not correct!");
616a604,605
>   Config::SetDefault ("ns3::WifiRemoteStationManager::FragmentationThreshold", StringValue ("2304"));
> 
699,861d687
< //-----------------------------------------------------------------------------
< /**
<  * Make sure that fragmentation works with QoS stations.
<  *
<  * The scenario considers a TCP transmission between an 802.11n station and an 802.11n
<  * access point.
<  */
< 
< class QosFragmentationTestCase : public TestCase
< {
< public:
<   QosFragmentationTestCase ();
<   virtual ~QosFragmentationTestCase ();
< 
<   virtual void DoRun (void);
< 
< 
< private:
<   uint32_t m_received; ///< received packets
<   uint32_t m_fragments; ///< transmitted fragments
< 
<   /**
<    * Receive function
<    * \param context the context
<    * \param p the packet
<    * \param adr the address
<    */
<   void Receive (std::string context, Ptr<const Packet> p, const Address &adr);
< 
<   /**
<    * Callback invoked when PHY transmits a packet
<    * \param context the context
<    * \param p the packet
<    * \param power the tx power
<    */
<   void Transmit (std::string context, Ptr<const Packet> p, double power);
< };
< 
< QosFragmentationTestCase::QosFragmentationTestCase ()
<   : TestCase ("Test case for fragmentation with QoS stations"),
<     m_received (0),
<     m_fragments (0)
< {
< }
< 
< QosFragmentationTestCase::~QosFragmentationTestCase ()
< {
< }
< 
< void
< QosFragmentationTestCase::Receive (std::string context, Ptr<const Packet> p, const Address &adr)
< {
<   if (p->GetSize () == 1400)
<     {
<       m_received++;
<     }
< }
< 
< void
< QosFragmentationTestCase::Transmit (std::string context, Ptr<const Packet> p, double power)
< {
<   WifiMacHeader hdr;
<   p->PeekHeader (hdr);
<   if (hdr.IsQosData ())
<     {
<       NS_TEST_EXPECT_MSG_LT_OR_EQ (p->GetSize (), 400, "Unexpected fragment size");
<       m_fragments++;
<     }
< }
< 
< void
< QosFragmentationTestCase::DoRun (void)
< {
<   NodeContainer wifiStaNode;
<   wifiStaNode.Create (1);
< 
<   NodeContainer wifiApNode;
<   wifiApNode.Create (1);
< 
<   YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
<   YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
<   phy.SetChannel (channel.Create ());
< 
<   WifiHelper wifi;
<   wifi.SetStandard (WIFI_PHY_STANDARD_80211n_5GHZ);
<   wifi.SetRemoteStationManager ("ns3::ConstantRateWifiManager",
<                                 "DataMode", StringValue ("HtMcs7"));
< 
<   WifiMacHelper mac;
<   Ssid ssid = Ssid ("ns-3-ssid");
<   mac.SetType ("ns3::StaWifiMac",
<                "Ssid", SsidValue (ssid),
<                "ActiveProbing", BooleanValue (false));
< 
<   NetDeviceContainer staDevices;
<   staDevices = wifi.Install (phy, mac, wifiStaNode);
< 
<   mac.SetType ("ns3::ApWifiMac",
<                "Ssid", SsidValue (ssid),
<                "BeaconGeneration", BooleanValue (true));
< 
<   NetDeviceContainer apDevices;
<   apDevices = wifi.Install (phy, mac, wifiApNode);
< 
<   MobilityHelper mobility;
<   Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
< 
<   positionAlloc->Add (Vector (0.0, 0.0, 0.0));
<   positionAlloc->Add (Vector (1.0, 0.0, 0.0));
<   mobility.SetPositionAllocator (positionAlloc);
< 
<   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
<   mobility.Install (wifiApNode);
<   mobility.Install (wifiStaNode);
< 
<   Ptr<WifiNetDevice> ap_device = DynamicCast<WifiNetDevice> (apDevices.Get (0));
<   Ptr<WifiNetDevice> sta_device = DynamicCast<WifiNetDevice> (staDevices.Get (0));
< 
<   // set the TXOP limit on BE AC
<   Ptr<RegularWifiMac> sta_mac = DynamicCast<RegularWifiMac> (sta_device->GetMac ());
<   NS_ASSERT (sta_mac);
<   PointerValue ptr;
<   sta_mac->GetAttribute ("BE_Txop", ptr);
<   ptr.Get<QosTxop> ()->SetTxopLimit (MicroSeconds (3008));
< 
<   PacketSocketAddress socket;
<   socket.SetSingleDevice (sta_device->GetIfIndex ());
<   socket.SetPhysicalAddress (ap_device->GetAddress ());
<   socket.SetProtocol (1);
< 
<   // give packet socket powers to nodes.
<   PacketSocketHelper packetSocket;
<   packetSocket.Install (wifiStaNode);
<   packetSocket.Install (wifiApNode);
< 
<   Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient> ();
<   client->SetAttribute ("PacketSize", UintegerValue (1400));
<   client->SetAttribute ("MaxPackets", UintegerValue (1));
<   client->SetRemote (socket);
<   wifiStaNode.Get (0)->AddApplication (client);
<   client->SetStartTime (Seconds (1));
<   client->SetStopTime (Seconds (3.0));
< 
<   Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer> ();
<   server->SetLocal (socket);
<   wifiApNode.Get (0)->AddApplication (server);
<   server->SetStartTime (Seconds (0.0));
<   server->SetStopTime (Seconds (4.0));
< 
<   Config::Connect ("/NodeList/*/ApplicationList/0/$ns3::PacketSocketServer/Rx", MakeCallback (&QosFragmentationTestCase::Receive, this));
< 
<   Config::Set ("/NodeList/0/DeviceList/0/RemoteStationManager/FragmentationThreshold", StringValue ("400"));
<   Config::Connect ("/NodeList/0/DeviceList/0/Phy/PhyTxBegin", MakeCallback (&QosFragmentationTestCase::Transmit, this));
< 
<   Simulator::Stop (Seconds (5));
<   Simulator::Run ();
< 
<   Simulator::Destroy ();
< 
<   NS_TEST_ASSERT_MSG_EQ (m_received, 1, "Unexpected number of received packets");
<   NS_TEST_ASSERT_MSG_EQ (m_fragments, 4, "Unexpected number of transmitted fragments");
< }
< 
1071a898
>   // modify cases 13 and 14 to avoid Config::SetDefault ()
1198a1026
> 
1228c1056
<   void TxDataFailedTrace (std::string context, Mac48Address adress);
---
>   void TxDataFailedTrace (std::string context, Mac48Address adr);
1256c1084
<   RngSeedManager::SetRun (16);
---
>   RngSeedManager::SetRun (2);
1308,1309c1136,1137
<   clientLowPriority->SetStartTime (Seconds (0.0));
<   clientLowPriority->SetStopTime (Seconds (1.0));
---
>   clientLowPriority->SetStartTime (Seconds (1.0));
>   clientLowPriority->SetStopTime (Seconds (2.0));
1317,1318c1145,1146
<   clientHighPriority->SetStartTime (Seconds (0.0));
<   clientHighPriority->SetStopTime (Seconds (1.0));
---
>   clientHighPriority->SetStartTime (Seconds (1.0));
>   clientHighPriority->SetStopTime (Seconds (2.0));
1323,1324c1151,1152
<   server->SetStartTime (Seconds (0.0));
<   server->SetStopTime (Seconds (1.0));
---
>   server->SetStartTime (Seconds (1.0));
>   server->SetStopTime (Seconds (2.0));
1328c1156
<   Simulator::Stop (Seconds (1.0));
---
>   Simulator::Stop (Seconds (2.0));
1345c1173
<  * See \bugid{2843}
---
>  * See \bugid{2483}
1348c1176
< class Bug2843TestCase : public TestCase
---
> class Bug2483TestCase : public TestCase
1351,1352c1179,1180
<   Bug2843TestCase ();
<   virtual ~Bug2843TestCase ();
---
>   Bug2483TestCase ();
>   virtual ~Bug2483TestCase ();
1371c1199
<    * \param numPackets number of packets in burst
---
>    * \param numPackets number of packets in burst (maximum: 255)
1376,1377d1203
< 
<   uint16_t m_channelWidth; ///< channel width (in MHz)
1380,1382c1206,1207
< Bug2843TestCase::Bug2843TestCase ()
<   : TestCase ("Test case for Bug 2843"),
<     m_channelWidth (20)
---
> Bug2483TestCase::Bug2483TestCase ()
>   : TestCase ("Test case for Bug 2483")
1386c1211
< Bug2843TestCase::~Bug2843TestCase ()
---
> Bug2483TestCase::~Bug2483TestCase ()
1391c1216
< Bug2843TestCase::StoreDistinctTuple (std::string context,  Ptr<SpectrumSignalParameters> txParams)
---
> Bug2483TestCase::StoreDistinctTuple (std::string context,  Ptr<SpectrumSignalParameters> txParams)
1400,1403c1225,1233
< 
<   Ptr<WifiPpdu> ppdu = Copy (wifiTxParams->ppdu);
<   WifiTxVector txVector = ppdu->GetTxVector ();
<   m_channelWidth = txVector.GetChannelWidth ();
---
>   Ptr<Packet> packet = wifiTxParams->packet->Copy ();
>   WifiPhyTag tag;
>   if (!packet->RemovePacketTag (tag))
>     {
>       NS_FATAL_ERROR ("Received Wi-Fi Signal with no WifiPhyTag");
>       return;
>     }
>   WifiTxVector txVector = tag.GetWifiTxVector ();
>   uint16_t channelWidth = txVector.GetChannelWidth ();
1407c1237,1238
<   FreqWidthSubbandModulationTuple tupleForCurrentTx = std::make_tuple (startingFreq, m_channelWidth, numBands, modulationClass);
---
>   FreqWidthSubbandModulationTuple tupleForCurrentTx = std::make_tuple (startingFreq, channelWidth,
>                                                                        numBands, modulationClass);
1423c1254
< Bug2843TestCase::SendPacketBurst (uint8_t numPackets, Ptr<NetDevice> sourceDevice,
---
> Bug2483TestCase::SendPacketBurst (uint8_t numPackets, Ptr<NetDevice> sourceDevice,
1434c1265
< Bug2843TestCase::DoRun (void)
---
> Bug2483TestCase::DoRun (void)
1435a1267,1269
>   Config::SetDefault ("ns3::WifiRemoteStationManager::RtsCtsThreshold", StringValue ("500")); // so as to force RTS/CTS for data frames
>   Config::SetDefault ("ns3::WifiPhy::CcaMode1Threshold", DoubleValue (-62.0));
> 
1465,1466c1299
<                                 "ControlMode", StringValue ("VhtMcs8"),
<                                 "RtsCtsThreshold", StringValue ("500")); // so as to force RTS/CTS for data frames
---
>                                 "ControlMode", StringValue ("VhtMcs8"));
1488,1489c1321,1322
<   Simulator::Schedule (Seconds (0.5), &Bug2843TestCase::SendPacketBurst, this, 5, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (0.6), &Bug2843TestCase::SendPacketBurst, this, 5, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
---
>   Simulator::Schedule (Seconds (0.5), &Bug2483TestCase::SendPacketBurst, this, 5, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
>   Simulator::Schedule (Seconds (0.6), &Bug2483TestCase::SendPacketBurst, this, 5, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
1491c1324
<   Config::Connect ("/ChannelList/*/$ns3::MultiModelSpectrumChannel/TxSigParams", MakeCallback (&Bug2843TestCase::StoreDistinctTuple, this));
---
>   Config::Connect ("/ChannelList/*/$ns3::MultiModelSpectrumChannel/TxSigParams", MakeCallback (&Bug2483TestCase::StoreDistinctTuple, this));
1502c1335
<   // Note that the first tuple should the one initiated by the beacon, i.e. non-HT OFDM (20 MHz)
---
>   // Note that the first tuple should the one initiated by the beacon, i.e. legacy OFDM (20 MHz)
1580,1582d1412
<   /* Remove Trailer */
<   WifiMacTrailer fcs;
<   packet->RemoveTrailer (fcs);
1595,1596c1425,1426
<       Ptr<HtOperation> htOperation = StaticCast<HtOperation> (beacon.GetInformationElement (std::make_pair (IE_HT_OPERATION, 0)));
<       if (htOperation->GetStaChannelWidth () > 0)
---
>       HtOperation htOperation = beacon.GetHtOperation ();
>       if (htOperation.GetStaChannelWidth () > 0)
1620,1621d1449
<   Ptr<HtConfiguration> apHtConfiguration = CreateObject<HtConfiguration> ();
<   apDev->SetHtConfiguration (apHtConfiguration);
1626d1453
<   apMac->SetDevice (apDev);
1631,1632d1457
<   Ptr<HtConfiguration> staHtConfiguration = CreateObject<HtConfiguration> ();
<   staDev->SetHtConfiguration (staHtConfiguration);
1635d1459
<   staMac->SetDevice (staDev);
1772c1596
<   phy->SetOffMode ();
---
>   phy->SetOffMode();
1829,1831d1652
<     RngSeedManager::SetSeed (1);
<     RngSeedManager::SetRun (1);
< 
1846,1848d1666
<     RngSeedManager::SetSeed (1);
<     RngSeedManager::SetRun (1);
< 
1861,1863d1678
<     RngSeedManager::SetSeed (1);
<     RngSeedManager::SetRun (1);
< 
1878,2932d1692
< //-----------------------------------------------------------------------------
< /**
<  * Make sure that the ADDBA handshake process is protected.
<  *
<  * The scenario considers an access point and a station. It utilizes
<  * ReceiveListErrorModel to drop by force ADDBA request on STA or ADDBA
<  * response on AP. The AP sends 5 packets of each 1000 bytes (thus generating
<  * BA agreement), 2 times during the test at 0.5s and 0.8s. We only drop the
<  * first ADDBA request/response of the first BA negotiation. Therefore, we
<  * expect that the packets still in queue after the failed BA agreement will be
<  * sent with normal MPDU, and packets queued after that should be sent with
<  * A-MPDU.
<  *
<  * This test consider 2 cases:
<  *
<  *   1. ADDBA request packets are blocked on receive at STA, triggering
<  *      transmission failure at AP
<  *   2. ADDBA response packets are blocked on receive at AP, STA stops
<  *      retransmission of ADDBA response
<  *
<  * See \bugid{2470}
<  */
< 
< class Bug2470TestCase : public TestCase
< {
< public:
<   Bug2470TestCase ();
<   virtual ~Bug2470TestCase ();
<   virtual void DoRun (void);
< 
< private:
<   /**
<    * Callback when ADDBA state changed
<    * \param context node context
<    * \param t the time the state changed
<    * \param recipient the MAC address of the recipient
<    * \param tid the TID
<    * \param state the state
<    */
<   void AddbaStateChangedCallback (std::string context, Time t, Mac48Address recipient, uint8_t tid, OriginatorBlockAckAgreement::State state);
<   /**
<    * Callback when packet is received
<    * \param context node context
<    * \param p the received packet
<    * \param channelFreqMhz the channel frequency in MHz
<    * \param txVector the TX vector
<    * \param aMpdu the A-MPDU info
<    * \param signalNoise the signal noise in dBm
<    */
<   void RxCallback (std::string context, Ptr<const Packet> p, uint16_t channelFreqMhz, WifiTxVector txVector, MpduInfo aMpdu, SignalNoiseDbm signalNoise);
<   /**
<    * Callback when packet is dropped
<    * \param context node context
<    * \param p the failed packet
<    * \param snr the SNR of the failed packet in linear scale
<    */
<   void RxErrorCallback (std::string context, Ptr<const Packet> p, double snr);
<   /**
<    * Triggers the arrival of a burst of 1000 Byte-long packets in the source device
<    * \param numPackets number of packets in burst
<    * \param sourceDevice pointer to the source NetDevice
<    * \param destination address of the destination device
<    */
<   void SendPacketBurst (uint32_t numPackets, Ptr<NetDevice> sourceDevice, Address& destination) const;
<   /**
<    * Run subtest for this test suite
<    * \param apErrorModel ErrorModel used for AP
<    * \param staErrorModel ErrorModel used for STA
<    */
<   void RunSubtest (PointerValue apErrorModel, PointerValue staErrorModel);
< 
<   uint16_t m_receivedNormalMpduCount; ///< Count received normal MPDU packets on STA
<   uint16_t m_receivedAmpduCount;      ///< Count received A-MPDU packets on STA
<   uint16_t m_failedActionCount;       ///< Count failed ADDBA request/response
<   uint16_t m_addbaEstablishedCount;   ///< Count number of times ADDBA state machine is in established state
<   uint16_t m_addbaPendingCount;       ///< Count number of times ADDBA state machine is in pending state
<   uint16_t m_addbaRejectedCount;      ///< Count number of times ADDBA state machine is in rejected state
<   uint16_t m_addbaNoReplyCount;       ///< Count number of times ADDBA state machine is in no_reply state
<   uint16_t m_addbaResetCount;         ///< Count number of times ADDBA state machine is in reset state
< };
< 
< Bug2470TestCase::Bug2470TestCase ()
<   : TestCase ("Test case for Bug 2470"),
<     m_receivedNormalMpduCount (0),
<     m_receivedAmpduCount (0),
<     m_failedActionCount (0),
<     m_addbaEstablishedCount (0),
<     m_addbaPendingCount (0),
<     m_addbaRejectedCount (0),
<     m_addbaNoReplyCount (0),
<     m_addbaResetCount (0)
< {
< }
< 
< Bug2470TestCase::~Bug2470TestCase ()
< {
< }
< 
< void
< Bug2470TestCase::AddbaStateChangedCallback (std::string context, Time t, Mac48Address recipient, uint8_t tid, OriginatorBlockAckAgreement::State state)
< {
<   switch (state)
<     {
<     case OriginatorBlockAckAgreement::ESTABLISHED:
<       m_addbaEstablishedCount++;
<       break;
<     case OriginatorBlockAckAgreement::PENDING:
<       m_addbaPendingCount++;
<       break;
<     case OriginatorBlockAckAgreement::REJECTED:
<       m_addbaRejectedCount++;
<       break;
<     case OriginatorBlockAckAgreement::NO_REPLY:
<       m_addbaNoReplyCount++;
<       break;
<     case OriginatorBlockAckAgreement::RESET:
<       m_addbaResetCount++;
<       break;
<     }
< }
< 
< void
< Bug2470TestCase::RxCallback (std::string context, Ptr<const Packet> p, uint16_t channelFreqMhz, WifiTxVector txVector, MpduInfo aMpdu, SignalNoiseDbm signalNoise)
< {
<   Ptr<Packet> packet = p->Copy ();
<   if (aMpdu.type != MpduType::NORMAL_MPDU)
<     {
<       m_receivedAmpduCount++;
<     }
<   else
<     {
<       WifiMacHeader hdr;
<       packet->RemoveHeader (hdr);
<       if (hdr.IsData ())
<         {
<           m_receivedNormalMpduCount++;
<         }
<     }
< }
< 
< void
< Bug2470TestCase::RxErrorCallback (std::string context, Ptr<const Packet> p, double snr)
< {
<   Ptr<Packet> packet = p->Copy ();
<   WifiMacHeader hdr;
<   packet->RemoveHeader (hdr);
<   if (hdr.IsAction ())
<     {
<       m_failedActionCount++;
<     }
< }
< 
< void
< Bug2470TestCase::SendPacketBurst (uint32_t numPackets, Ptr<NetDevice> sourceDevice,
<                                   Address& destination) const
< {
<   for (uint32_t i = 0; i < numPackets; i++)
<     {
<       Ptr<Packet> pkt = Create<Packet> (1000); // 1000 dummy bytes of data
<       sourceDevice->Send (pkt, destination, 0);
<     }
< }
< 
< void
< Bug2470TestCase::RunSubtest (PointerValue apErrorModel, PointerValue staErrorModel)
< {
<   RngSeedManager::SetSeed (1);
<   RngSeedManager::SetRun (1);
<   int64_t streamNumber = 200;
< 
<   NodeContainer wifiApNode, wifiStaNode;
<   wifiApNode.Create (1);
<   wifiStaNode.Create (1);
< 
<   YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
<   YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
<   phy.SetChannel (channel.Create ());
< 
<   WifiHelper wifi;
<   wifi.SetStandard (WIFI_PHY_STANDARD_80211n_5GHZ);
<   wifi.SetRemoteStationManager ("ns3::ConstantRateWifiManager",
<                                 "DataMode", StringValue ("HtMcs7"),
<                                 "ControlMode", StringValue ("HtMcs7"));
< 
<   WifiMacHelper mac;
<   NetDeviceContainer apDevice;
<   phy.Set ("PostReceptionErrorModel", apErrorModel);
<   mac.SetType ("ns3::ApWifiMac", "EnableBeaconJitter", BooleanValue (false));
<   apDevice = wifi.Install (phy, mac, wifiApNode);
< 
<   NetDeviceContainer staDevice;
<   phy.Set ("PostReceptionErrorModel", staErrorModel);
<   mac.SetType ("ns3::StaWifiMac");
<   staDevice = wifi.Install (phy, mac, wifiStaNode);
< 
<   // Assign fixed streams to random variables in use
<   wifi.AssignStreams (apDevice, streamNumber);
<   wifi.AssignStreams (staDevice, streamNumber);
< 
<   MobilityHelper mobility;
<   Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
<   positionAlloc->Add (Vector (0.0, 0.0, 0.0));
<   positionAlloc->Add (Vector (1.0, 0.0, 0.0));
<   mobility.SetPositionAllocator (positionAlloc);
< 
<   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
<   mobility.Install (wifiApNode);
<   mobility.Install (wifiStaNode);
< 
<   Config::Connect ("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/MonitorSnifferRx", MakeCallback (&Bug2470TestCase::RxCallback, this));
<   Config::Connect ("/NodeList/*/DeviceList/*/Phy/State/RxError", MakeCallback (&Bug2470TestCase::RxErrorCallback, this));
<   Config::Connect ("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::RegularWifiMac/BE_Txop/BlockAckManager/AgreementState", MakeCallback (&Bug2470TestCase::AddbaStateChangedCallback, this));
< 
<   Simulator::Schedule (Seconds (0.5), &Bug2470TestCase::SendPacketBurst, this, 1, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (0.5) + MicroSeconds (5), &Bug2470TestCase::SendPacketBurst, this, 4, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (0.8), &Bug2470TestCase::SendPacketBurst, this, 1, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (0.8) + MicroSeconds (5), &Bug2470TestCase::SendPacketBurst, this, 4, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
< 
<   Simulator::Stop (Seconds (1.0));
<   Simulator::Run ();
<   Simulator::Destroy ();
< }
< 
< void
< Bug2470TestCase::DoRun (void)
< {
<   // Create ReceiveListErrorModel to corrupt ADDBA req packet. We use ReceiveListErrorModel
<   // instead of ListErrorModel since packet UID is incremented between simulations. But
<   // problem may occur because of random stream, therefore we suppress usage of RNG as
<   // much as possible (i.e., removing beacon jitter).
<   Ptr<ReceiveListErrorModel> staPem = CreateObject<ReceiveListErrorModel> ();
<   std::list<uint32_t> blackList;
<   // Block ADDBA request 6 times (== maximum number of MAC frame transmissions in the ADDBA response timeout interval)
<   blackList.push_back (8);
<   blackList.push_back (9);
<   blackList.push_back (10);
<   blackList.push_back (11);
<   blackList.push_back (12);
<   blackList.push_back (13);
<   staPem->SetList (blackList);
< 
<   {
<     RunSubtest (PointerValue (), PointerValue (staPem));
<     NS_TEST_ASSERT_MSG_EQ (m_failedActionCount, 6, "ADDBA request packets are not failed");
<     // There are two sets of 5 packets to be transmitted. The first 5 packets should be sent by normal
<     // MPDU because of failed ADDBA handshake. For the second set, the first packet should be sent by
<     // normal MPDU, and the rest with A-MPDU. In total we expect to receive 2 normal MPDU packets and
<     // 8 A-MPDU packets.
<     NS_TEST_ASSERT_MSG_EQ (m_receivedNormalMpduCount, 2, "Receiving incorrect number of normal MPDU packet on subtest 1");
<     NS_TEST_ASSERT_MSG_EQ (m_receivedAmpduCount, 8, "Receiving incorrect number of A-MPDU packet on subtest 1");
< 
<     NS_TEST_ASSERT_MSG_EQ (m_addbaEstablishedCount, 1, "Incorrect number of times the ADDBA state machine was in established state on subtest 1");
<     NS_TEST_ASSERT_MSG_EQ (m_addbaPendingCount, 1, "Incorrect number of times the ADDBA state machine was in pending state on subtest 1");
<     NS_TEST_ASSERT_MSG_EQ (m_addbaRejectedCount, 0, "Incorrect number of times the ADDBA state machine was in rejected state on subtest 1");
<     NS_TEST_ASSERT_MSG_EQ (m_addbaNoReplyCount, 0, "Incorrect number of times the ADDBA state machine was in no_reply state on subtest 1");
<     NS_TEST_ASSERT_MSG_EQ (m_addbaResetCount, 0, "Incorrect number of times the ADDBA state machine was in reset state on subtest 1");
<   }
< 
<   m_receivedNormalMpduCount = 0;
<   m_receivedAmpduCount = 0;
<   m_failedActionCount = 0;
<   m_addbaEstablishedCount = 0;
<   m_addbaPendingCount = 0;
<   m_addbaRejectedCount = 0;
<   m_addbaNoReplyCount = 0;
<   m_addbaResetCount = 0;
< 
<   Ptr<ReceiveListErrorModel> apPem = CreateObject<ReceiveListErrorModel> ();
<   blackList.clear ();
<   // Block ADDBA request 3 times (== maximum number of MAC frame transmissions in the ADDBA response timeout interval)
<   blackList.push_back (4);
<   blackList.push_back (5);
<   blackList.push_back (6);
<   apPem->SetList (blackList);
< 
<   {
<     RunSubtest (PointerValue (apPem), PointerValue ());
<     NS_TEST_ASSERT_MSG_EQ (m_failedActionCount, 3, "ADDBA response packets are not failed");
<     // Similar to subtest 1, we also expect to receive 6 normal MPDU packets and 4 A-MPDU packets.
<     NS_TEST_ASSERT_MSG_EQ (m_receivedNormalMpduCount, 6, "Receiving incorrect number of normal MPDU packet on subtest 2");
<     NS_TEST_ASSERT_MSG_EQ (m_receivedAmpduCount, 4, "Receiving incorrect number of A-MPDU packet on subtest 2");
< 
<     NS_TEST_ASSERT_MSG_EQ (m_addbaEstablishedCount, 1, "Incorrect number of times the ADDBA state machine was in established state on subtest 2");
<     NS_TEST_ASSERT_MSG_EQ (m_addbaPendingCount, 1, "Incorrect number of times the ADDBA state machine was in pending state on subtest 2");
<     NS_TEST_ASSERT_MSG_EQ (m_addbaRejectedCount, 0, "Incorrect number of times the ADDBA state machine was in rejected state on subtest 2");
<     NS_TEST_ASSERT_MSG_EQ (m_addbaNoReplyCount, 1, "Incorrect number of times the ADDBA state machine was in no_reply state on subtest 2");
<     NS_TEST_ASSERT_MSG_EQ (m_addbaResetCount, 0, "Incorrect number of times the ADDBA state machine was in reset state on subtest 2");
<   }
< 
<   // TODO: In the second test set, it does not go to reset state since ADDBA response is received after timeout (NO_REPLY)
<   // but before it does not enter RESET state. More tests should be written to verify all possible scenarios.
< }
< 
< 
< //-----------------------------------------------------------------------------
< /**
<  * Make sure that Ideal rate manager recovers when the station is moving away from the access point.
<  *
<  * The scenario considers an access point and a moving station.
<  * Initially, the station is located at 1 meter from the access point.
<  * After 1s, the station moves away from the access for 0.5s to
<  * reach a point away of 50 meters from the access point.
<  * The tests checks the Ideal rate manager is reset once it has
<  * failed to transmit a data packet, so that the next data packets
<  * can be successfully transmitted using a lower modulation.
<  *
<  * See \issueid{40}
<  */
< 
< class Issue40TestCase : public TestCase
< {
< public:
<   Issue40TestCase ();
<   virtual ~Issue40TestCase ();
<   virtual void DoRun (void);
< 
< private:
<   /**
<    * Run one function
<    * \param useAmpdu flag to indicate whether the test should be run with A-MPDU
<    */
<   void RunOne (bool useAmpdu);
< 
<   /**
<    * Callback when packet is successfully received
<    * \param context node context
<    * \param p the received packet
<    */
<   void RxSuccessCallback (std::string context, Ptr<const Packet> p);
<   /**
<    * Triggers the arrival of 1000 Byte-long packets in the source device
<    * \param numPackets number of packets in burst
<    * \param sourceDevice pointer to the source NetDevice
<    * \param destination address of the destination device
<    */
<    void SendPackets (uint8_t numPackets, Ptr<NetDevice> sourceDevice, Address& destination);
<   /**
<    * Transmit final data failed function
<    * \param context the context
<    * \param adr the MAC address
<    */
<   void TxFinalDataFailedCallback (std::string context, Mac48Address address);
< 
<   uint16_t m_rxCount; ///< Count number of successfully received data packets
<   uint16_t m_txCount; ///< Count number of transmitted data packets
<   uint16_t m_txMacFinalDataFailedCount; ///< Count number of unsuccessfully transmitted data packets
< };
< 
< Issue40TestCase::Issue40TestCase ()
<   : TestCase ("Test case for issue #40"),
<     m_rxCount (0),
<     m_txCount (0),
<     m_txMacFinalDataFailedCount (0)
< {
< }
< 
< Issue40TestCase::~Issue40TestCase ()
< {
< }
< 
< void
< Issue40TestCase::RxSuccessCallback (std::string context, Ptr<const Packet> p)
< {
<   m_rxCount++;
< }
< 
< void
< Issue40TestCase::SendPackets (uint8_t numPackets, Ptr<NetDevice> sourceDevice, Address& destination)
< {
<   for (uint8_t i = 0; i < numPackets; i++)
<     {
<       Ptr<Packet> pkt = Create<Packet> (1000); // 1000 dummy bytes of data
<       sourceDevice->Send (pkt, destination, 0);
<       m_txCount++;
<     }
< }
< 
< void
< Issue40TestCase::TxFinalDataFailedCallback (std::string context, Mac48Address address)
< {
<   m_txMacFinalDataFailedCount++;
< }
< 
< void
< Issue40TestCase::RunOne (bool useAmpdu)
< {
<   m_rxCount = 0;
<   m_txCount = 0;
<   m_txMacFinalDataFailedCount = 0;
< 
<   RngSeedManager::SetSeed (1);
<   RngSeedManager::SetRun (1);
<   int64_t streamNumber = 100;
< 
<   NodeContainer wifiApNode, wifiStaNode;
<   wifiApNode.Create (1);
<   wifiStaNode.Create (1);
< 
<   YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
<   YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
<   phy.SetChannel (channel.Create ());
< 
<   WifiHelper wifi;
<   wifi.SetStandard (WIFI_PHY_STANDARD_80211ac);
<   wifi.SetRemoteStationManager ("ns3::IdealWifiManager");
< 
<   WifiMacHelper mac;
<   NetDeviceContainer apDevice;
<   mac.SetType ("ns3::ApWifiMac");
<   apDevice = wifi.Install (phy, mac, wifiApNode);
< 
<   NetDeviceContainer staDevice;
<   mac.SetType ("ns3::StaWifiMac");
<   staDevice = wifi.Install (phy, mac, wifiStaNode);
< 
<   // Assign fixed streams to random variables in use
<   wifi.AssignStreams (apDevice, streamNumber);
<   wifi.AssignStreams (staDevice, streamNumber);
< 
<   MobilityHelper mobility;
<   Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
<   positionAlloc->Add (Vector (0.0, 0.0, 0.0));
<   positionAlloc->Add (Vector (10.0, 0.0, 0.0));
<   mobility.SetPositionAllocator (positionAlloc);
< 
<   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
<   mobility.Install (wifiApNode);
< 
<   mobility.SetMobilityModel("ns3::WaypointMobilityModel");
<   mobility.Install (wifiStaNode);
< 
<   Config::Connect ("/NodeList/*/DeviceList/*/RemoteStationManager/MacTxFinalDataFailed", MakeCallback (&Issue40TestCase::TxFinalDataFailedCallback, this));
<   Config::Connect ("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::WifiMac/MacRx", MakeCallback (&Issue40TestCase::RxSuccessCallback, this));
<               
<   Ptr<WaypointMobilityModel> staWaypointMobility = DynamicCast<WaypointMobilityModel>(wifiStaNode.Get(0)->GetObject<MobilityModel>());
<   staWaypointMobility->AddWaypoint (Waypoint (Seconds(1.0), Vector (10.0, 0.0, 0.0)));
<   staWaypointMobility->AddWaypoint (Waypoint (Seconds(1.5), Vector (50.0, 0.0, 0.0)));
< 
<   if (useAmpdu)
<     {
<       // Disable use of BAR that are sent with the lowest modulation so that we can also reproduce the problem with A-MPDU, i.e. the lack of feedback about SNR change
<       Ptr<WifiNetDevice> ap_device = DynamicCast<WifiNetDevice> (apDevice.Get (0));
<       Ptr<RegularWifiMac> ap_mac = DynamicCast<RegularWifiMac> (ap_device->GetMac ());
<       NS_ASSERT (ap_mac);
<       PointerValue ptr;
<       ap_mac->GetAttribute ("BE_Txop", ptr);
<       ptr.Get<QosTxop> ()->SetAttribute ("UseExplicitBarAfterMissedBlockAck", BooleanValue (false));
<   }
< 
<   // Transmit a first data packet before the station moves: it should be sent with a high modulation and successfully received
<   Simulator::Schedule (Seconds (0.5), &Issue40TestCase::SendPackets, this, useAmpdu ? 2 : 1, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
< 
<   // Transmit a second data packet once the station is away from the access point: it should be sent with the same high modulation and be unsuccessfully received
<   Simulator::Schedule (Seconds (2.0), &Issue40TestCase::SendPackets, this, useAmpdu ? 2 : 1, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
< 
<   // Keep on transmitting data packets while the station is away from the access point: it should be sent with a lower modulation and be successfully received
<   Simulator::Schedule (Seconds (2.1), &Issue40TestCase::SendPackets, this, useAmpdu ? 2 : 1, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (2.2), &Issue40TestCase::SendPackets, this, useAmpdu ? 2 : 1, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (2.3), &Issue40TestCase::SendPackets, this, useAmpdu ? 2 : 1, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (2.4), &Issue40TestCase::SendPackets, this, useAmpdu ? 2 : 1, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (2.5), &Issue40TestCase::SendPackets, this, useAmpdu ? 2 : 1, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
< 
<   Simulator::Stop (Seconds (3.0));
<   Simulator::Run ();
< 
<   NS_TEST_ASSERT_MSG_EQ (m_txCount, (useAmpdu ? 14 : 7), "Incorrect number of transmitted packets");
<   NS_TEST_ASSERT_MSG_EQ (m_rxCount, (useAmpdu ? 12 : 6), "Incorrect number of successfully received packets");
<   NS_TEST_ASSERT_MSG_EQ (m_txMacFinalDataFailedCount, 1, "Incorrect number of dropped TX packets");
< 
<   Simulator::Destroy ();
< }
< 
< void
< Issue40TestCase::DoRun (void)
< {
<   //Test without A-MPDU
<   RunOne (false);
< 
<   //Test with A-MPDU
<   RunOne (true);
< }
< 
< //-----------------------------------------------------------------------------
< /**
<  * Make sure that Ideal rate manager is able to handle non best-effort traffic.
<  *
<  * The scenario considers an access point and a fixed station.
<  * The station first sends a best-effort packet to the access point,
<  * for which Ideal rate manager should select a VHT rate. Then,
<  * the station sends a non best-effort (voice) packet to the access point,
<  * and since SNR is unchanged, the same VHT rate should be used.
<  *
<  * See \issueid{169}
<  */
< 
< class Issue169TestCase : public TestCase
< {
< public:
<   Issue169TestCase ();
<   virtual ~Issue169TestCase ();
<   virtual void DoRun (void);
< 
< private:
<   /**
<    * Triggers the transmission of a 1000 Byte-long data packet from the source device
<    * \param numPackets number of packets in burst
<    * \param sourceDevice pointer to the source NetDevice
<    * \param destination address of the destination device
<    * \param priority the priority of the packets to send
<    */
<    void SendPackets (uint8_t numPackets, Ptr<NetDevice> sourceDevice, Address& destination, uint8_t priority);
< 
<   /**
<    * Callback that indicates a PSDU is being transmitted
<    * \param context the context
<    * \param psdu the PSDU to transmit
<    * \param txVector the TX vector
<    * \param txPowerW the TX power (W)
<    */
<   void TxCallback (std::string context, Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW);
< };
< 
< Issue169TestCase::Issue169TestCase ()
<   : TestCase ("Test case for issue #169")
< {
< }
< 
< Issue169TestCase::~Issue169TestCase ()
< {
< }
< 
< void
< Issue169TestCase::SendPackets (uint8_t numPackets, Ptr<NetDevice> sourceDevice, Address& destination, uint8_t priority)
< {
<   SocketPriorityTag priorityTag;
<   priorityTag.SetPriority (priority);
<   for (uint8_t i = 0; i < numPackets; i++)
<     {
<       Ptr<Packet> packet = Create<Packet> (1000); // 1000 dummy bytes of data
<       packet->AddPacketTag (priorityTag);
<       sourceDevice->Send (packet, destination, 0);
<     }
< }
< 
< void
< Issue169TestCase::TxCallback (std::string context, Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW)
< {
<   if (psdu->GetSize () >= 1000)
<     {
<       NS_TEST_ASSERT_MSG_EQ (txVector.GetMode ().GetModulationClass (), WifiModulationClass::WIFI_MOD_CLASS_VHT, "Ideal rate manager selected incorrect modulation class");
<     }
< }
< 
< void
< Issue169TestCase::DoRun (void)
< {
<   RngSeedManager::SetSeed (1);
<   RngSeedManager::SetRun (1);
<   int64_t streamNumber = 100;
< 
<   NodeContainer wifiApNode, wifiStaNode;
<   wifiApNode.Create (1);
<   wifiStaNode.Create (1);
< 
<   YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
<   YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
<   phy.SetChannel (channel.Create ());
< 
<   WifiHelper wifi;
<   wifi.SetStandard (WIFI_PHY_STANDARD_80211ac);
<   wifi.SetRemoteStationManager ("ns3::IdealWifiManager");
< 
<   WifiMacHelper mac;
<   NetDeviceContainer apDevice;
<   mac.SetType ("ns3::ApWifiMac");
<   apDevice = wifi.Install (phy, mac, wifiApNode);
< 
<   NetDeviceContainer staDevice;
<   mac.SetType ("ns3::StaWifiMac");
<   staDevice = wifi.Install (phy, mac, wifiStaNode);
< 
<   // Assign fixed streams to random variables in use
<   wifi.AssignStreams (apDevice, streamNumber);
<   wifi.AssignStreams (staDevice, streamNumber);
< 
<   MobilityHelper mobility;
<   Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
<   positionAlloc->Add (Vector (0.0, 0.0, 0.0));
<   positionAlloc->Add (Vector (1.0, 0.0, 0.0));
<   mobility.SetPositionAllocator (positionAlloc);
< 
<   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
<   mobility.Install (wifiApNode);
<   mobility.Install (wifiStaNode);
< 
<   Config::Connect ("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyTxPsduBegin", MakeCallback (&Issue169TestCase::TxCallback, this));
< 
<   //Send best-effort packet (i.e. priority 0)
<   Simulator::Schedule (Seconds (0.5), &Issue169TestCase::SendPackets, this, 1, apDevice.Get (0), staDevice.Get (0)->GetAddress (), 0);
< 
<   //Send non best-effort (voice) packet (i.e. priority 6)
<   Simulator::Schedule (Seconds (1.0), &Issue169TestCase::SendPackets, this, 1, apDevice.Get (0), staDevice.Get (0)->GetAddress (), 6);
< 
<   Simulator::Stop (Seconds (2.0));
<   Simulator::Run ();
< 
<   Simulator::Destroy ();
< }
< 
< 
< //-----------------------------------------------------------------------------
< /**
<  * Make sure that Ideal rate manager properly selects MCS based on the configured channel width.
<  *
<  * The scenario considers an access point and a fixed station.
<  * The access point first sends a 80 MHz PPDU to the station,
<  * for which Ideal rate manager should select VH-MCS 0 based
<  * on the distance (no interference generatd in this test). Then,
<  * the access point sends a 20 MHz PPDU to the station,
<  * which corresponds to a SNR 6 dB higher than previously, hence
<  * VHT-MCS 2 should be selected. Finally, the access point sends a
<  * 40 MHz PPDU to the station, which means corresponds to a SNR 3 dB
<  * lower than previously, hence VHT-MCS 1 should be selected.
<  */
< 
< class IdealRateManagerChannelWidthTest : public TestCase
< {
< public:
<   IdealRateManagerChannelWidthTest ();
<   virtual ~IdealRateManagerChannelWidthTest ();
<   virtual void DoRun (void);
< 
< private:
<   /**
<    * Change the configured channel width for all nodes
<    * \param channelWidth the channel width (in MHz)
<    */
<   void ChangeChannelWidth (uint16_t channelWidth);
< 
<   /**
<    * Triggers the transmission of a 1000 Byte-long data packet from the source device
<    * \param sourceDevice pointer to the source NetDevice
<    * \param destination address of the destination device
<    */
<    void SendPacket (Ptr<NetDevice> sourceDevice, Address& destination);
< 
<   /**
<    * Callback that indicates a PSDU is being transmitted
<    * \param context the context
<    * \param psdu the PSDU to transmit
<    * \param txVector the TX vector
<    * \param txPowerW the TX power (W)
<    */
<   void TxCallback (std::string context, Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW);
< 
<   /**
<    * Check if the selected WifiMode is correct
<    * \param expectedMode the expected WifiMode
<    */
<   void CheckLastSelectedMode (WifiMode expectedMode);
< 
<   WifiMode m_txMode; ///< Store the last selected mode to send data packet
< };
< 
< IdealRateManagerChannelWidthTest::IdealRateManagerChannelWidthTest ()
<   : TestCase ("Test case for use of channel bonding with Ideal rate manager")
< {
< }
< 
< IdealRateManagerChannelWidthTest::~IdealRateManagerChannelWidthTest ()
< {
< }
< 
< void
< IdealRateManagerChannelWidthTest::ChangeChannelWidth (uint16_t channelWidth)
< {
<   Config::Set ("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/ChannelWidth", UintegerValue (channelWidth));
< }
< 
< void
< IdealRateManagerChannelWidthTest::SendPacket (Ptr<NetDevice> sourceDevice, Address& destination)
< {
<   Ptr<Packet> packet = Create<Packet> (1000);
<   sourceDevice->Send (packet, destination, 0);
< }
< 
< void
< IdealRateManagerChannelWidthTest::TxCallback (std::string context, Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW)
< {
<   if (psdu->GetSize () >= 1000)
<     {
<       m_txMode = txVector.GetMode ();
<     }
< }
< 
< void
< IdealRateManagerChannelWidthTest::CheckLastSelectedMode (WifiMode expectedMode)
< {
<   NS_TEST_ASSERT_MSG_EQ (m_txMode, expectedMode, "Last selected WifiMode " << m_txMode << " does not match expected WifiMode " << expectedMode);
< }
< 
< void
< IdealRateManagerChannelWidthTest::DoRun (void)
< {
<   RngSeedManager::SetSeed (1);
<   RngSeedManager::SetRun (1);
<   int64_t streamNumber = 100;
< 
<   NodeContainer wifiApNode, wifiStaNode;
<   wifiApNode.Create (1);
<   wifiStaNode.Create (1);
< 
<   YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
<   YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
<   phy.SetChannel (channel.Create ());
< 
<   WifiHelper wifi;
<   wifi.SetStandard (WIFI_PHY_STANDARD_80211ac);
<   wifi.SetRemoteStationManager ("ns3::IdealWifiManager");
< 
<   WifiMacHelper mac;
<   NetDeviceContainer apDevice;
<   mac.SetType ("ns3::ApWifiMac");
<   apDevice = wifi.Install (phy, mac, wifiApNode);
< 
<   NetDeviceContainer staDevice;
<   mac.SetType ("ns3::StaWifiMac");
<   staDevice = wifi.Install (phy, mac, wifiStaNode);
< 
<   // Assign fixed streams to random variables in use
<   wifi.AssignStreams (apDevice, streamNumber);
<   wifi.AssignStreams (staDevice, streamNumber);
< 
<   MobilityHelper mobility;
<   Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
<   positionAlloc->Add (Vector (0.0, 0.0, 0.0));
<   positionAlloc->Add (Vector (50.0, 0.0, 0.0));
<   mobility.SetPositionAllocator (positionAlloc);
< 
<   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
<   mobility.Install (wifiApNode);
<   mobility.Install (wifiStaNode);
< 
<   Config::Connect ("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyTxPsduBegin", MakeCallback (&IdealRateManagerChannelWidthTest::TxCallback, this));
< 
<   //Set channel width to 80 MHz & send packet
<   Simulator::Schedule (Seconds (0.5), &IdealRateManagerChannelWidthTest::ChangeChannelWidth, this, 80);
<   Simulator::Schedule (Seconds (1.0), &IdealRateManagerChannelWidthTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   //Selected rate should be VHT-MCS 0
<   Simulator::Schedule (Seconds (1.1), &IdealRateManagerChannelWidthTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs0 ());
< 
<   //Set channel width to 20 MHz & send packet
<   Simulator::Schedule (Seconds (1.5), &IdealRateManagerChannelWidthTest::ChangeChannelWidth, this, 20);
<   Simulator::Schedule (Seconds (2.0), &IdealRateManagerChannelWidthTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   //Selected rate should be VHT-MCS 2 since SNR should be 6 dB higher than previously
<   Simulator::Schedule (Seconds (2.1), &IdealRateManagerChannelWidthTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs2 ());
< 
<   //Set channel width to 40 MHz & send packet
<   Simulator::Schedule (Seconds (2.5), &IdealRateManagerChannelWidthTest::ChangeChannelWidth, this, 40);
<   Simulator::Schedule (Seconds (3.0), &IdealRateManagerChannelWidthTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   //Selected rate should be VHT-MCS 1 since SNR should be 3 dB lower than previously
<   Simulator::Schedule (Seconds (3.1), &IdealRateManagerChannelWidthTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs1 ());
< 
<   Simulator::Stop (Seconds (3.2));
<   Simulator::Run ();
< 
<   Simulator::Destroy ();
< }
< 
< 
< //-----------------------------------------------------------------------------
< /**
<  * Test to validate that Ideal rate manager properly selects TXVECTOR in scenarios where MIMO is used.
<  * The test consider both balanced and unbalanced MIMO settings, and verify ideal picks the correct number
<  * of spatial streams and the correct MCS, taking into account potential diversity in AWGN channels when the
<  * number of antenna at the receiver is higher than the number of spatial streams used for the transmission.
<  */
< 
< class IdealRateManagerMimoTest : public TestCase
< {
< public:
<   IdealRateManagerMimoTest ();
<   virtual ~IdealRateManagerMimoTest ();
<   virtual void DoRun (void);
< 
< private:
<   /**
<    * Change the configured MIMO  settings  for AP node
<    * \param antennas the number of active antennas
<    * \param maxStreams the maximum number of allowed spatial streams
<    */
<   void SetApMimoSettings (uint8_t antennas, uint8_t maxStreams);
<   /**
<    * Change the configured MIMO  settings  for STA node
<    * \param antennas the number of active antennas
<    * \param maxStreams the maximum number of allowed spatial streams
<    */
<   void SetStaMimoSettings (uint8_t antennas, uint8_t maxStreams);
<   /**
<    * Triggers the transmission of a 1000 Byte-long data packet from the source device
<    * \param sourceDevice pointer to the source NetDevice
<    * \param destination address of the destination device
<    */
<    void SendPacket (Ptr<NetDevice> sourceDevice, Address& destination);
< 
<   /**
<    * Callback that indicates a PSDU is being transmitted
<    * \param context the context
<    * \param psdu the PSDU to transmit
<    * \param txVector the TX vector
<    * \param txPowerW the TX power (W)
<    */
<   void TxCallback (std::string context, Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW);
< 
<   /**
<    * Check if the selected WifiMode is correct
<    * \param expectedMode the expected WifiMode
<    */
<   void CheckLastSelectedMode (WifiMode expectedMode);
<   /**
<    * Check if the selected Nss is correct
<    * \param expectedNss the expected Nss
<    */
<   void CheckLastSelectedNss (uint8_t expectedNss);
< 
<   WifiTxVector m_txVector; ///< Store the last TXVECTOR used to transmit Data
< };
< 
< IdealRateManagerMimoTest::IdealRateManagerMimoTest ()
<   : TestCase ("Test case for use of imbalanced MIMO settings with Ideal rate manager")
< {
< }
< 
< IdealRateManagerMimoTest::~IdealRateManagerMimoTest ()
< {
< }
< 
< void
< IdealRateManagerMimoTest::SetApMimoSettings (uint8_t antennas, uint8_t maxStreams)
< {
<   Config::Set ("/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/Antennas", UintegerValue (antennas));
<   Config::Set ("/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/MaxSupportedTxSpatialStreams", UintegerValue (maxStreams));
<   Config::Set ("/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/MaxSupportedRxSpatialStreams", UintegerValue (maxStreams));
< }
< 
< void
< IdealRateManagerMimoTest::SetStaMimoSettings (uint8_t antennas, uint8_t maxStreams)
< {
<   Config::Set ("/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/Phy/Antennas", UintegerValue (antennas));
<   Config::Set ("/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/Phy/MaxSupportedTxSpatialStreams", UintegerValue (maxStreams));
<   Config::Set ("/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/Phy/MaxSupportedRxSpatialStreams", UintegerValue (maxStreams));
< }
< 
< void
< IdealRateManagerMimoTest::SendPacket (Ptr<NetDevice> sourceDevice, Address& destination)
< {
<   Ptr<Packet> packet = Create<Packet> (1000);
<   sourceDevice->Send (packet, destination, 0);
< }
< 
< void
< IdealRateManagerMimoTest::TxCallback (std::string context, Ptr<const WifiPsdu> psdu, WifiTxVector txVector, double txPowerW)
< {
<   if (psdu->GetSize () >= 1000)
<     {
<       m_txVector = txVector;
<     }
< }
< 
< void
< IdealRateManagerMimoTest::CheckLastSelectedNss (uint8_t expectedNss)
< {
<   NS_TEST_ASSERT_MSG_EQ (m_txVector.GetNss (), expectedNss, "Last selected Nss " << m_txVector.GetNss () << " does not match expected Nss " << expectedNss);
< }
< 
< void
< IdealRateManagerMimoTest::CheckLastSelectedMode (WifiMode expectedMode)
< {
<   NS_TEST_ASSERT_MSG_EQ (m_txVector.GetMode (), expectedMode, "Last selected WifiMode " << m_txVector.GetMode () << " does not match expected WifiMode " << expectedMode);
< }
< 
< void
< IdealRateManagerMimoTest::DoRun (void)
< {
<   RngSeedManager::SetSeed (1);
<   RngSeedManager::SetRun (1);
<   int64_t streamNumber = 100;
< 
<   NodeContainer wifiApNode, wifiStaNode;
<   wifiApNode.Create (1);
<   wifiStaNode.Create (1);
< 
<   YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();
<   YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();
<   phy.SetChannel (channel.Create ());
< 
<   WifiHelper wifi;
<   wifi.SetStandard (WIFI_PHY_STANDARD_80211ac);
<   wifi.SetRemoteStationManager ("ns3::IdealWifiManager");
< 
<   WifiMacHelper mac;
<   NetDeviceContainer apDevice;
<   mac.SetType ("ns3::ApWifiMac");
<   apDevice = wifi.Install (phy, mac, wifiApNode);
< 
<   NetDeviceContainer staDevice;
<   mac.SetType ("ns3::StaWifiMac");
<   staDevice = wifi.Install (phy, mac, wifiStaNode);
< 
<   // Assign fixed streams to random variables in use
<   wifi.AssignStreams (apDevice, streamNumber);
<   wifi.AssignStreams (staDevice, streamNumber);
< 
<   MobilityHelper mobility;
<   Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();
<   positionAlloc->Add (Vector (0.0, 0.0, 0.0));
<   positionAlloc->Add (Vector (40.0, 0.0, 0.0));
<   mobility.SetPositionAllocator (positionAlloc);
< 
<   mobility.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
<   mobility.Install (wifiApNode);
<   mobility.Install (wifiStaNode);
< 
<   Config::Connect ("/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyTxPsduBegin", MakeCallback (&IdealRateManagerMimoTest::TxCallback, this));
< 
< 
<   // TX: 1 antenna
<   Simulator::Schedule (Seconds (0.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 1, 1);
<   // RX: 1 antenna
<   Simulator::Schedule (Seconds (0.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 1, 1);
<   // Send packets (2 times to get one feedback)
<   Simulator::Schedule (Seconds (1.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (1.1), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   // Selected NSS should be 1 since both TX and RX support a single antenna
<   Simulator::Schedule (Seconds (1.2), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 1);
<   // Selected rate should be VHT-MCS1 because of settings and distance between TX and RX
<   Simulator::Schedule (Seconds (1.2), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs1 ());
< 
< 
<   // TX: 1 antenna
<   Simulator::Schedule (Seconds (1.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 1, 1);
<   // RX: 2 antennas, but only supports 1 spatial stream
<   Simulator::Schedule (Seconds (1.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 2, 1);
<   // Send packets (2 times to get one feedback)
<   Simulator::Schedule (Seconds (2.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (2.1), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   // Selected NSS should be 1 since both TX and RX support a single antenna
<   Simulator::Schedule (Seconds (2.2), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 1);
<   // Selected rate should be increased to VHT-MCS2 because of RX diversity resulting in SNR improvement of about 3dB
<   Simulator::Schedule (Seconds (2.2), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs2 ());
< 
< 
<   // TX: 1 antenna
<   Simulator::Schedule (Seconds (2.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 1, 1);
<   // RX: 2 antennas, and supports 2 spatial streams
<   Simulator::Schedule (Seconds (2.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 2, 2);
<   // Send packets (2 times to get one feedback)
<   Simulator::Schedule (Seconds (3.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (3.1), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   // Selected NSS should be 1 since TX supports a single antenna
<   Simulator::Schedule (Seconds (3.2), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 1);
<   // Selected rate should be as previously
<   Simulator::Schedule (Seconds (3.2), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs2 ());
< 
< 
<   // TX: 2 antennas, but only supports 1 spatial stream
<   Simulator::Schedule (Seconds (3.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 2, 1);
<   // RX: 1 antenna
<   Simulator::Schedule (Seconds (3.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 1, 1);
<   // Send packets (2 times to get one feedback)
<   Simulator::Schedule (Seconds (4.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (4.1), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   // Selected NSS should be 1 since both TX and RX support a single antenna
<   Simulator::Schedule (Seconds (4.2), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 1);
<   // Selected rate should be VHT-MCS1 because we do no longer have diversity in this scenario (more antennas at TX does not result in SNR improvement in AWGN channel)
<   Simulator::Schedule (Seconds (4.2), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs1 ());
< 
< 
<   // TX: 2 antennas, but only supports 1 spatial stream
<   Simulator::Schedule (Seconds (4.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 2, 1);
<   // RX: 2 antennas, but only supports 1 spatial stream
<   Simulator::Schedule (Seconds (4.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 2, 1);
<   // Send packets (2 times to get one feedback)
<   Simulator::Schedule (Seconds (5.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (5.1), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   // Selected NSS should be 1 since both TX and RX support a single antenna
<   Simulator::Schedule (Seconds (5.2), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 1);
<   // Selected rate should be increased to VHT-MCS2 because of RX diversity resulting in SNR improvement of about 3dB (more antennas at TX does not result in SNR improvement in AWGN channel)
<   Simulator::Schedule (Seconds (5.2), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs2 ());
< 
< 
<   // TX: 2 antennas, but only supports 1 spatial stream
<   Simulator::Schedule (Seconds (5.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 2, 1);
<   // RX: 2 antennas, and supports 2 spatial streams
<   Simulator::Schedule (Seconds (5.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 2, 2);
<   // Send packets (2 times to get one feedback)
<   Simulator::Schedule (Seconds (6.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (6.1), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   // Selected NSS should be 1 since TX supports a single antenna
<   Simulator::Schedule (Seconds (6.2), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 1);
<   // Selected rate should be as previously
<   Simulator::Schedule (Seconds (6.2), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs2 ());
< 
< 
<   // TX: 2 antennas, and supports 2 spatial streams
<   Simulator::Schedule (Seconds (6.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 2, 2);
<   // RX: 1 antenna
<   Simulator::Schedule (Seconds (6.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 1, 1);
<   // Send packets (2 times to get one feedback)
<   Simulator::Schedule (Seconds (7.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (7.1), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   // Selected NSS should be 1 since RX supports a single antenna
<   Simulator::Schedule (Seconds (7.2), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 1);
<   // Selected rate should be VHT-MCS1 because we do no longer have diversity in this scenario (more antennas at TX does not result in SNR improvement in AWGN channel)
<   Simulator::Schedule (Seconds (7.2), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs1 ());
< 
< 
<   // TX: 2 antennas, and supports 2 spatial streams
<   Simulator::Schedule (Seconds (7.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 2, 2);
<   // RX: 2 antennas, but only supports 1 spatial stream
<   Simulator::Schedule (Seconds (7.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 2, 1);
<   // Send packets (2 times to get one feedback)
<   Simulator::Schedule (Seconds (8.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (8.1), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   // Selected NSS should be 1 since RX supports a single antenna
<   Simulator::Schedule (Seconds (8.2), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 1);
<   // Selected rate should be increased to VHT-MCS2 because of RX diversity resulting in SNR improvement of about 3dB (more antennas at TX does not result in SNR improvement in AWGN channel)
<   Simulator::Schedule (Seconds (8.2), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs2 ());
< 
< 
<   // TX: 2 antennas, and supports 2 spatial streams
<   Simulator::Schedule (Seconds (8.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 2, 2);
<   // RX: 2 antennas, and supports 2 spatial streams
<   Simulator::Schedule (Seconds (8.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 2, 2);
<   // Send packets (2 times to get one feedback)
<   Simulator::Schedule (Seconds (9.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (9.1), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   // Selected NSS should be 2 since both TX and RX support 2 antennas
<   Simulator::Schedule (Seconds (9.2), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 2);
<   // Selecte rate should be the same as without diversity, as it uses 2 spatial streams so there is no more benefits from diversity in AWGN channels
<   Simulator::Schedule (Seconds (9.2), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs1 ());
< 
< 
<   // Verify we can go back to initial situation
<   Simulator::Schedule (Seconds (9.9), &IdealRateManagerMimoTest::SetApMimoSettings, this, 1, 1);
<   Simulator::Schedule (Seconds (9.9), &IdealRateManagerMimoTest::SetStaMimoSettings, this, 1, 1);
<   Simulator::Schedule (Seconds (10.0), &IdealRateManagerMimoTest::SendPacket, this, apDevice.Get (0), staDevice.Get (0)->GetAddress ());
<   Simulator::Schedule (Seconds (10.1), &IdealRateManagerMimoTest::CheckLastSelectedNss, this, 1);
<   Simulator::Schedule (Seconds (10.1), &IdealRateManagerMimoTest::CheckLastSelectedMode, this, WifiPhy::GetVhtMcs1 ());
< 
<   Simulator::Stop (Seconds (10.2));
<   Simulator::Run ();
<   Simulator::Destroy ();
< }
< 
2946c1706
<   : TestSuite ("wifi-devices", UNIT)
---
>   : TestSuite ("devices-wifi", UNIT)
2953d1712
<   AddTestCase (new QosFragmentationTestCase, TestCase::QUICK);
2956c1715
<   AddTestCase (new Bug2843TestCase, TestCase::QUICK); //Bug 2843
---
>   AddTestCase (new Bug2483TestCase, TestCase::QUICK); //Bug 2483
2959,2963d1717
<   AddTestCase (new Bug2470TestCase, TestCase::QUICK); //Bug 2470
<   AddTestCase (new Issue40TestCase, TestCase::QUICK); //Issue #40
<   AddTestCase (new Issue169TestCase, TestCase::QUICK); //Issue #169
<   AddTestCase (new IdealRateManagerChannelWidthTest, TestCase::QUICK);
<   AddTestCase (new IdealRateManagerMimoTest, TestCase::QUICK);
