diff ../../NS3-WiGig/src/wifi/helper/athstats-helper.cc ../../ns-3-dev-git/src/wifi/helper/athstats-helper.cc
59c59
<   Config::Connect (devicepath + "/RemoteStationManager/MacTxRtsFailed", MakeCallback (&AthstatsWifiTraceSink::TxRtsFailedTrace, athstats));
---
>   Config::Connect (devicepath + "/RemoteStationManager/TxRtsFailed", MakeCallback (&AthstatsWifiTraceSink::TxRtsFailedTrace, athstats));
267,268c267,268
<             (unsigned int) m_txCount, // /proc/net/dev transmitted packets to which we should subtract management frames
<             (unsigned int) m_rxCount, // /proc/net/dev received packets but subtracts management frames from it
---
>             (unsigned int) m_txCount, // /proc/net/dev transmitted packets to which we should subtract mgmt frames
>             (unsigned int) m_rxCount, // /proc/net/dev received packets but subracts mgmt frames from it
diff ../../NS3-WiGig/src/wifi/helper/athstats-helper.h ../../ns-3-dev-git/src/wifi/helper/athstats-helper.h
109c109
<    * @param context the calling context
---
>    * @param context
117c117
<    * @param context the calling context
---
>    * @param context
126c126
<    * @param context the calling context
---
>    * @param context
135c135
<    * @param context the calling context
---
>    * @param context
144c144
<    * @param context the calling context
---
>    * @param context
153c153
<    * @param context the calling context
---
>    * @param context
162,166c162,166
<    * @param context the calling context
<    * @param packet the packet
<    * @param snr the SNR in linear scale
<    * @param mode the WifiMode
<    * @param preamble the wifi preamble
---
>    * @param context
>    * @param packet
>    * @param snr
>    * @param mode
>    * @param preamble
175,177c175,177
<    * @param context the calling context
<    * @param packet the packet
<    * @param snr the SNR in linear scale
---
>    * @param context
>    * @param packet
>    * @param snr
185,189c185,189
<    * @param context the calling context
<    * @param packet the packet
<    * @param mode the WifiMode
<    * @param preamble the wifi preamble
<    * @param txPower the transmit power level
---
>    * @param context
>    * @param packet
>    * @param mode
>    * @param preamble
>    * @param txPower
197,200c197,200
<    * @param context the calling context
<    * @param start the time at which the state changed
<    * @param duration the duration of the state
<    * @param state the PHY layer state
---
>    * @param context
>    * @param start
>    * @param duration
>    * @param state
218,221c218,221
<   uint32_t m_txCount;            ///< transmit count
<   uint32_t m_rxCount;            ///< receive count
<   uint32_t m_shortRetryCount;    ///< short retry count
<   uint32_t m_longRetryCount;     ///< long retry count
---
>   uint32_t m_txCount; ///< transmit count
>   uint32_t m_rxCount; ///< receive count
>   uint32_t m_shortRetryCount; ///< short retry count
>   uint32_t m_longRetryCount; ///< long retry count
223,225c223,225
<   uint32_t m_phyRxOkCount;       ///< PHY receive OK count
<   uint32_t m_phyRxErrorCount;    ///< PHY receive error count
<   uint32_t m_phyTxCount;         ///< PHY transmit count
---
>   uint32_t m_phyRxOkCount; ///< phy receive ok count
>   uint32_t m_phyRxErrorCount; ///< phy receive error count
>   uint32_t m_phyTxCount; ///< phy transmit count
Only in ../../NS3-WiGig/src/wifi/helper: beamforming-trace-helper.cc
Only in ../../NS3-WiGig/src/wifi/helper: beamforming-trace-helper.h
Only in ../../NS3-WiGig/src/wifi/helper: codebook-parametric-helper.cc
Only in ../../NS3-WiGig/src/wifi/helper: codebook-parametric-helper.h
Only in ../../NS3-WiGig/src/wifi/helper: dmg-wifi-helper.cc
Only in ../../NS3-WiGig/src/wifi/helper: dmg-wifi-helper.h
Only in ../../NS3-WiGig/src/wifi/helper: dmg-wifi-mac-helper.cc
Only in ../../NS3-WiGig/src/wifi/helper: dmg-wifi-mac-helper.h
Only in ../../NS3-WiGig/src/wifi/helper: multi-band-wifi-helper.cc
Only in ../../NS3-WiGig/src/wifi/helper: multi-band-wifi-helper.h
diff ../../NS3-WiGig/src/wifi/helper/spectrum-wifi-helper.cc ../../ns-3-dev-git/src/wifi/helper/spectrum-wifi-helper.cc
26,27d25
< #include "ns3/frame-capture-model.h"
< #include "ns3/preamble-detection-model.h"
69,78d66
<   if (m_frameCaptureModel.IsTypeIdSet ())
<     {
<       Ptr<FrameCaptureModel> capture = m_frameCaptureModel.Create<FrameCaptureModel> ();
<       phy->SetFrameCaptureModel (capture);
<     }
<   if (m_preambleDetectionModel.IsTypeIdSet ())
<     {
<       Ptr<PreambleDetectionModel> capture = m_preambleDetectionModel.Create<PreambleDetectionModel> ();
<       phy->SetPreambleDetectionModel (capture);
<     }
diff ../../NS3-WiGig/src/wifi/helper/spectrum-wifi-helper.h ../../ns-3-dev-git/src/wifi/helper/spectrum-wifi-helper.h
33c33
<  * The Pcap and ASCII traces generated by the EnableAscii and EnablePcap methods defined
---
>  * The Pcap and ascii traces generated by the EnableAscii and EnablePcap methods defined
41c41
<    * Create a PHY helper without any parameter set. The user must set
---
>    * Create a phy helper without any parameter set. The user must set
47c47
<    * Create a PHY helper in a default working state.
---
>    * Create a phy helper in a default working state.
diff ../../NS3-WiGig/src/wifi/helper/wifi-helper.cc ../../ns-3-dev-git/src/wifi/helper/wifi-helper.cc
34,42d33
< //#include "ns3/multi-band-net-device.h"
< #include "ns3/net-device-queue-interface.h"
< #include "ns3/wifi-mac-queue.h"
< #include "ns3/qos-utils.h"
< #include "ns3/ht-configuration.h"
< #include "ns3/vht-configuration.h"
< #include "ns3/he-configuration.h"
< #include "ns3/obss-pd-algorithm.h"
< #include "ns3/wifi-ack-policy-selector.h"
44d34
< #include "ns3/channel.h"
51c41
<  * ASCII trace PHY transmit sink with context
---
>  * ASCII trace Phy transmit sink with context
73c63
<  * ASCII trace PHY transmit sink without context
---
>  * ASCII trace Phy transmit sink without context
93c83
<  * ASCII trace PHY receive sink with context
---
>  * ASCII trace Phy receive sink with context
115c105
<  * ASCII trace PHY receive sink without context
---
>  * ASCII trace Phy receive sink without context
134,162d123
< /**
<  * ASCII PHY Activity trace without context
<  * \param stream the output stream
<  * \param srcID the ID of the transmitting node.
<  * \param dstID the ID of the receiving node.
<  * \param duration the duration of the activity in nanoseconds.
<  * \param power the power of the transmitted or received part of the PLCP.
<  * \param fieldType the type of the PLCP field being transmitted or received.
<  * \param activityType the type of the PHY activity.
<  */
< static void
< AsciiPhyActivityTraceWithoutContext (
<   Ptr<OutputStreamWrapper> stream,
<   uint32_t srcID,
<   uint32_t dstID,
<   Time duration,
<   double power,
<   uint16_t fieldType,
<   uint16_t activityType)
< {
<   *stream->GetStream () << Simulator::Now ().GetNanoSeconds () << ","
<                         << srcID << ","
<                         << dstID << ","
<                         << duration.GetNanoSeconds () << ","
<                         << power << ","
<                         << fieldType << ","
<                         << activityType << std::endl;
< }
< 
164,166c125
<   : m_pcapDlt (PcapHelper::DLT_IEEE802_11),
<     m_asciiTraceType (ASCII_TRACE_LEGACY),
<     m_snaplen (std::numeric_limits<uint32_t>::max ())
---
>   : m_pcapDlt (PcapHelper::DLT_IEEE802_11)
168d126
<   SetPreambleDetectionModel ("ns3::ThresholdPreambleDetectionModel");
205,281d162
< WifiPhyHelper::SetFrameCaptureModel (std::string name,
<                                      std::string n0, const AttributeValue &v0,
<                                      std::string n1, const AttributeValue &v1,
<                                      std::string n2, const AttributeValue &v2,
<                                      std::string n3, const AttributeValue &v3,
<                                      std::string n4, const AttributeValue &v4,
<                                      std::string n5, const AttributeValue &v5,
<                                      std::string n6, const AttributeValue &v6,
<                                      std::string n7, const AttributeValue &v7)
< {
<   m_frameCaptureModel = ObjectFactory ();
<   m_frameCaptureModel.SetTypeId (name);
<   m_frameCaptureModel.Set (n0, v0);
<   m_frameCaptureModel.Set (n1, v1);
<   m_frameCaptureModel.Set (n2, v2);
<   m_frameCaptureModel.Set (n3, v3);
<   m_frameCaptureModel.Set (n4, v4);
<   m_frameCaptureModel.Set (n5, v5);
<   m_frameCaptureModel.Set (n6, v6);
<   m_frameCaptureModel.Set (n7, v7);
< }
< 
< void
< WifiPhyHelper::SetPreambleDetectionModel (std::string name,
<                                           std::string n0, const AttributeValue &v0,
<                                           std::string n1, const AttributeValue &v1,
<                                           std::string n2, const AttributeValue &v2,
<                                           std::string n3, const AttributeValue &v3,
<                                           std::string n4, const AttributeValue &v4,
<                                           std::string n5, const AttributeValue &v5,
<                                           std::string n6, const AttributeValue &v6,
<                                           std::string n7, const AttributeValue &v7)
< {
<   m_preambleDetectionModel = ObjectFactory ();
<   m_preambleDetectionModel.SetTypeId (name);
<   m_preambleDetectionModel.Set (n0, v0);
<   m_preambleDetectionModel.Set (n1, v1);
<   m_preambleDetectionModel.Set (n2, v2);
<   m_preambleDetectionModel.Set (n3, v3);
<   m_preambleDetectionModel.Set (n4, v4);
<   m_preambleDetectionModel.Set (n5, v5);
<   m_preambleDetectionModel.Set (n6, v6);
<   m_preambleDetectionModel.Set (n7, v7);
< }
< 
< void
< WifiPhyHelper::DisablePreambleDetectionModel ()
< {
<     m_preambleDetectionModel.SetTypeId (TypeId ());
< }
< 
< void
< WifiPhyHelper::EnableMultiBandPcap (std::string prefix, Ptr<NetDevice> nd, Ptr<WifiPhy> phy)
< {
<   //All of the Pcap enable functions vector through here including the ones
<   //that are wandering through all of devices on perhaps all of the nodes in
<   //the system. We can only deal with devices of type WifiNetDevice.
< //  Ptr<MultiBandNetDevice> device = nd->GetObject<MultiBandNetDevice> ();
< //  if (device == 0)
< //    {
< //      NS_LOG_INFO ("DmgWifiHelper::EnablePcapInternal(): Device " << &device << " not of type ns3::WifiNetDevice");
< //      return;
< //    }
< //  NS_ABORT_MSG_IF (phy == 0, "DmgWifiPhyHelper::EnablePcapInternal(): Phy layer in MultiBandNetDevice must be set");
< 
< //  PcapHelper pcapHelper;
< 
< //  std::string filename;
< //  filename = pcapHelper.GetFilenameFromDevice (prefix, device);
< 
< //  Ptr<PcapFileWrapper> file = pcapHelper.CreateFile (filename, std::ios::out, m_pcapDlt);
< 
< //  phy->TraceConnectWithoutContext ("MonitorSnifferTx", MakeBoundCallback (&WifiPhyHelper::PcapSniffTxEvent, file));
< //  phy->TraceConnectWithoutContext ("MonitorSnifferRx", MakeBoundCallback (&WifiPhyHelper::PcapSniffRxEvent, file));
< }
< 
< void
379,386c260
<       && txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HE
<       && txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_DMG_CTRL
<       && txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_DMG_SC
<       && txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_DMG_OFDM
<       && txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_DMG_LP_SC
<       && txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_EDMG_CTRL
<       && txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_EDMG_SC
<       && txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_EDMG_OFDM)
---
>       && txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_HE)
393,399c267
<   if (txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_DMG_CTRL &&
<       txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_DMG_SC &&
<       txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_DMG_OFDM &&
<       txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_DMG_LP_SC &&
<       txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_EDMG_CTRL &&
<       txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_EDMG_SC &&
<       txVector.GetMode ().GetModulationClass () != WIFI_MOD_CLASS_EDMG_OFDM)
---
>   switch (rate)
401,412c269,278
<       switch (rate)
<         {
<         case 2:  //1Mbps
<         case 4:  //2Mbps
<         case 10: //5Mbps
<         case 22: //11Mbps
<           channelFlags |= RadiotapHeader::CHANNEL_FLAG_CCK;
<           break;
<         default:
<           channelFlags |= RadiotapHeader::CHANNEL_FLAG_OFDM;
<           break;
<         }
---
>     case 2:  //1Mbps
>     case 4:  //2Mbps
>     case 10: //5Mbps
>     case 22: //11Mbps
>       channelFlags |= RadiotapHeader::CHANNEL_FLAG_CCK;
>       break;
>     default:
>       channelFlags |= RadiotapHeader::CHANNEL_FLAG_OFDM;
>       break;
>     }
414,421c280,282
<       if (channelFreqMhz < 2500)
<         {
<           channelFlags |= RadiotapHeader::CHANNEL_FLAG_SPECTRUM_2GHZ;
<         }
<       else
<         {
<           channelFlags |= RadiotapHeader::CHANNEL_FLAG_SPECTRUM_5GHZ;
<         }
---
>   if (channelFreqMhz < 2500)
>     {
>       channelFlags |= RadiotapHeader::CHANNEL_FLAG_SPECTRUM_2GHZ;
422a284,288
>   else
>     {
>       channelFlags |= RadiotapHeader::CHANNEL_FLAG_SPECTRUM_5GHZ;
>     }
> 
471,484d336
<   if ((txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_CTRL) ||
<       (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_SC) ||
<       (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_LP_SC) ||
<       (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_DMG_OFDM) ||
<       (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_CTRL) ||
<       (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_SC) ||
<       (txVector.GetMode ().GetModulationClass () == WIFI_MOD_CLASS_EDMG_OFDM))
<     {
<       uint8_t mcsKnown = RadiotapHeader::MCS_KNOWN_NONE;
<       uint8_t mcsFlags = RadiotapHeader::MCS_FLAGS_NONE;
<       mcsKnown |= RadiotapHeader::MCS_KNOWN_INDEX;
<       header.SetMcsFields (mcsKnown, mcsFlags, txVector.GetMode ().GetMcsValue ());
<     }
< 
619,630d470
< void
< WifiPhyHelper::SetAsciiTraceType (SupportedAsciiTraceTypes traceType)
< {
<   m_asciiTraceType = traceType;
< }
< 
< void
< WifiPhyHelper::SetSnapshotLength (uint32_t length)
< {
<   m_snaplen = length;
< }
< 
637,642d476
< uint32_t
< WifiPhyHelper::GetSnapshotLength (void) const
< {
<   return m_snaplen;
< }
< 
673c507
<   Ptr<PcapFileWrapper> file = pcapHelper.CreateFile (filename, std::ios::out, m_pcapDlt, m_snaplen);
---
>   Ptr<PcapFileWrapper> file = pcapHelper.CreateFile (filename, std::ios::out, m_pcapDlt);
686c520
<   //All of the ASCII enable functions vector through here including the ones
---
>   //All of the ascii enable functions vector through here including the ones
696c530,542
<   if (m_asciiTraceType == ASCII_TRACE_LEGACY)
---
>   //Our trace sinks are going to use packet printing, so we have to make sure
>   //that is turned on.
>   Packet::EnablePrinting ();
> 
>   uint32_t nodeid = nd->GetNode ()->GetId ();
>   uint32_t deviceid = nd->GetIfIndex ();
>   std::ostringstream oss;
> 
>   //If we are not provided an OutputStreamWrapper, we are expected to create
>   //one using the usual trace filename conventions and write our traces
>   //without a context since there will be one file per context and therefore
>   //the context would be redundant.
>   if (stream == 0)
698,760d543
<       //Our trace sinks are going to use packet printing, so we have to make sure
<       //that is turned on.
<       Packet::EnablePrinting ();
< 
<       uint32_t nodeid = nd->GetNode ()->GetId ();
<       uint32_t deviceid = nd->GetIfIndex ();
<       std::ostringstream oss;
< 
<       //If we are not provided an OutputStreamWrapper, we are expected to create
<       //one using the usual trace filename conventions and write our traces
<       //without a context since there will be one file per context and therefore
<       //the context would be redundant.
<       if (stream == 0)
<         {
<           //Set up an output stream object to deal with private ofstream copy
<           //constructor and lifetime issues. Let the helper decide the actual
<           //name of the file given the prefix.
<           AsciiTraceHelper asciiTraceHelper;
< 
<           std::string filename;
<           if (explicitFilename)
<             {
<               filename = prefix;
<             }
<           else
<             {
<               filename = asciiTraceHelper.GetFilenameFromDevice (prefix, device);
<             }
< 
<           Ptr<OutputStreamWrapper> theStream = asciiTraceHelper.CreateFileStream (filename);
<           //We could go poking through the phy and the state looking for the
<           //correct trace source, but we can let Config deal with that with
<           //some search cost.  Since this is presumably happening at topology
<           //creation time, it doesn't seem much of a price to pay.
<           oss.str ("");
<           oss << "/NodeList/" << nodeid << "/DeviceList/" << deviceid << "/$ns3::WifiNetDevice/Phy/State/RxOk";
<           Config::ConnectWithoutContext (oss.str (), MakeBoundCallback (&AsciiPhyReceiveSinkWithoutContext, theStream));
< 
<           oss.str ("");
<           oss << "/NodeList/" << nodeid << "/DeviceList/" << deviceid << "/$ns3::WifiNetDevice/Phy/State/Tx";
<           Config::ConnectWithoutContext (oss.str (), MakeBoundCallback (&AsciiPhyTransmitSinkWithoutContext, theStream));
< 
<           return;
<         }
< 
<       //If we are provided an OutputStreamWrapper, we are expected to use it, and
<       //to provide a context. We are free to come up with our own context if we
<       //want, and use the AsciiTraceHelper Hook*WithContext functions, but for
<       //compatibility and simplicity, we just use Config::Connect and let it deal
<       //with coming up with a context.
<       oss.str ("");
<       oss << "/NodeList/" << nodeid << "/DeviceList/" << deviceid << "/$ns3::WifiNetDevice/Phy/State/RxOk";
<       Config::Connect (oss.str (), MakeBoundCallback (&AsciiPhyReceiveSinkWithContext, stream));
< 
<       oss.str ("");
<       oss << "/NodeList/" << nodeid << "/DeviceList/" << deviceid << "/$ns3::WifiNetDevice/Phy/State/Tx";
<       Config::Connect (oss.str (), MakeBoundCallback (&AsciiPhyTransmitSinkWithContext, stream));
<     }
<   else if (m_asciiTraceType == ASCII_TRACE_PHY_ACTIVITY)
<     {
<       Ptr<Channel> channel = device->GetChannel ();
<       NS_ABORT_MSG_IF (channel == 0, "WifiPhyHelper::EnableAsciiInternal(): Channel in WifiNetDevice must be set");
< 
777,781c560,572
<       channel->TraceConnectWithoutContext ("PhyActivityTracker", MakeBoundCallback (&AsciiPhyActivityTraceWithoutContext, theStream));
<     }
<   else
<     {
<       NS_ABORT_MSG ("Unsupported ASCII Trace Type");
---
>       //We could go poking through the phy and the state looking for the
>       //correct trace source, but we can let Config deal with that with
>       //some search cost.  Since this is presumably happening at topology
>       //creation time, it doesn't seem much of a price to pay.
>       oss.str ("");
>       oss << "/NodeList/" << nodeid << "/DeviceList/" << deviceid << "/$ns3::WifiNetDevice/Phy/State/RxOk";
>       Config::ConnectWithoutContext (oss.str (), MakeBoundCallback (&AsciiPhyReceiveSinkWithoutContext, theStream));
> 
>       oss.str ("");
>       oss << "/NodeList/" << nodeid << "/DeviceList/" << deviceid << "/$ns3::WifiNetDevice/Phy/State/Tx";
>       Config::ConnectWithoutContext (oss.str (), MakeBoundCallback (&AsciiPhyTransmitSinkWithoutContext, theStream));
> 
>       return;
782a574,586
> 
>   //If we are provided an OutputStreamWrapper, we are expected to use it, and
>   //to provide a context. We are free to come up with our own context if we
>   //want, and use the AsciiTraceHelper Hook*WithContext functions, but for
>   //compatibility and simplicity, we just use Config::Connect and let it deal
>   //with coming up with a context.
>   oss.str ("");
>   oss << "/NodeList/" << nodeid << "/DeviceList/" << deviceid << "/$ns3::WifiNetDevice/Phy/State/RxOk";
>   Config::Connect (oss.str (), MakeBoundCallback (&AsciiPhyReceiveSinkWithContext, stream));
> 
>   oss.str ("");
>   oss << "/NodeList/" << nodeid << "/DeviceList/" << deviceid << "/$ns3::WifiNetDevice/Phy/State/Tx";
>   Config::Connect (oss.str (), MakeBoundCallback (&AsciiPhyTransmitSinkWithContext, stream));
790,791c594
<   : m_standard (WIFI_PHY_STANDARD_80211a),
<     m_selectQueueCallback (&SelectQueueByDSField)
---
>   : m_standard (WIFI_PHY_STANDARD_80211a)
794,797d596
<   SetAckPolicySelectorForAc (AC_BE, "ns3::ConstantWifiAckPolicySelector");
<   SetAckPolicySelectorForAc (AC_BK, "ns3::ConstantWifiAckPolicySelector");
<   SetAckPolicySelectorForAc (AC_VI, "ns3::ConstantWifiAckPolicySelector");
<   SetAckPolicySelectorForAc (AC_VO, "ns3::ConstantWifiAckPolicySelector");
824,869d622
< WifiHelper::SetObssPdAlgorithm (std::string type,
<                                 std::string n0, const AttributeValue &v0,
<                                 std::string n1, const AttributeValue &v1,
<                                 std::string n2, const AttributeValue &v2,
<                                 std::string n3, const AttributeValue &v3,
<                                 std::string n4, const AttributeValue &v4,
<                                 std::string n5, const AttributeValue &v5,
<                                 std::string n6, const AttributeValue &v6,
<                                 std::string n7, const AttributeValue &v7)
< {
<   m_obssPdAlgorithm = ObjectFactory ();
<   m_obssPdAlgorithm.SetTypeId (type);
<   m_obssPdAlgorithm.Set (n0, v0);
<   m_obssPdAlgorithm.Set (n1, v1);
<   m_obssPdAlgorithm.Set (n2, v2);
<   m_obssPdAlgorithm.Set (n3, v3);
<   m_obssPdAlgorithm.Set (n4, v4);
<   m_obssPdAlgorithm.Set (n5, v5);
<   m_obssPdAlgorithm.Set (n6, v6);
<   m_obssPdAlgorithm.Set (n7, v7);
< }
< 
< void
< WifiHelper::SetAckPolicySelectorForAc (AcIndex ac, std::string type,
<                                        std::string n0, const AttributeValue &v0,
<                                        std::string n1, const AttributeValue &v1,
<                                        std::string n2, const AttributeValue &v2,
<                                        std::string n3, const AttributeValue &v3,
<                                        std::string n4, const AttributeValue &v4,
<                                        std::string n5, const AttributeValue &v5,
<                                        std::string n6, const AttributeValue &v6,
<                                        std::string n7, const AttributeValue &v7)
< {
<   m_ackPolicySelector[ac] = ObjectFactory ();
<   m_ackPolicySelector[ac].SetTypeId (type);
<   m_ackPolicySelector[ac].Set (n0, v0);
<   m_ackPolicySelector[ac].Set (n1, v1);
<   m_ackPolicySelector[ac].Set (n2, v2);
<   m_ackPolicySelector[ac].Set (n3, v3);
<   m_ackPolicySelector[ac].Set (n4, v4);
<   m_ackPolicySelector[ac].Set (n5, v5);
<   m_ackPolicySelector[ac].Set (n6, v6);
<   m_ackPolicySelector[ac].Set (n7, v7);
< }
< 
< void
875,880d627
< void
< WifiHelper::SetSelectQueueCallback (SelectQueueCallback f)
< {
<   m_selectQueueCallback = f;
< }
< 
892,906d638
<       if (m_standard >= WIFI_PHY_STANDARD_80211n_2_4GHZ)
<         {
<           Ptr<HtConfiguration> htConfiguration = CreateObject<HtConfiguration> ();
<           device->SetHtConfiguration (htConfiguration);
<         }
<       if ((m_standard == WIFI_PHY_STANDARD_80211ac) || (m_standard == WIFI_PHY_STANDARD_80211ax_5GHZ))
<         {
<           Ptr<VhtConfiguration> vhtConfiguration = CreateObject<VhtConfiguration> ();
<           device->SetVhtConfiguration (vhtConfiguration);
<         }
<       if (m_standard >= WIFI_PHY_STANDARD_80211ax_2_4GHZ)
<         {
<           Ptr<HeConfiguration> heConfiguration = CreateObject<HeConfiguration> ();
<           device->SetHeConfiguration (heConfiguration);
<         }
908c640
<       Ptr<WifiMac> mac = macHelper.Create (device);
---
>       Ptr<WifiMac> mac = macHelper.Create ();
917,922d648
<       if ((m_standard >= WIFI_PHY_STANDARD_80211ax_2_4GHZ) && (m_obssPdAlgorithm.IsTypeIdSet ()))
<         {
<           Ptr<ObssPdAlgorithm> obssPdAlgorithm = m_obssPdAlgorithm.Create<ObssPdAlgorithm> ();
<           device->AggregateObject (obssPdAlgorithm);
<           obssPdAlgorithm->ConnectWifiNetDevice (device);
<         }
925,979d650
<       // Aggregate a NetDeviceQueueInterface object if a RegularWifiMac is installed
<       Ptr<RegularWifiMac> rmac = DynamicCast<RegularWifiMac> (mac);
<       if (rmac)
<         {
<           Ptr<NetDeviceQueueInterface> ndqi;
<           BooleanValue qosSupported;
<           PointerValue ptr;
<           Ptr<WifiMacQueue> wmq;
<           Ptr<WifiAckPolicySelector> ackSelector;
< 
<           rmac->GetAttributeFailSafe ("QosSupported", qosSupported);
<           if (qosSupported.Get ())
<             {
<               ndqi = CreateObjectWithAttributes<NetDeviceQueueInterface> ("NTxQueues",
<                                                                           UintegerValue (4));
< 
<               rmac->GetAttributeFailSafe ("BE_Txop", ptr);
<               ackSelector = m_ackPolicySelector[AC_BE].Create<WifiAckPolicySelector> ();
<               ackSelector->SetQosTxop (ptr.Get<QosTxop> ());
<               ptr.Get<QosTxop> ()->SetAckPolicySelector (ackSelector);
<               wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
<               ndqi->GetTxQueue (0)->ConnectQueueTraces (wmq);
< 
<               rmac->GetAttributeFailSafe ("BK_Txop", ptr);
<               ackSelector = m_ackPolicySelector[AC_BK].Create<WifiAckPolicySelector> ();
<               ackSelector->SetQosTxop (ptr.Get<QosTxop> ());
<               ptr.Get<QosTxop> ()->SetAckPolicySelector (ackSelector);
<               wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
<               ndqi->GetTxQueue (1)->ConnectQueueTraces (wmq);
< 
<               rmac->GetAttributeFailSafe ("VI_Txop", ptr);
<               ackSelector = m_ackPolicySelector[AC_VI].Create<WifiAckPolicySelector> ();
<               ackSelector->SetQosTxop (ptr.Get<QosTxop> ());
<               ptr.Get<QosTxop> ()->SetAckPolicySelector (ackSelector);
<               wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
<               ndqi->GetTxQueue (2)->ConnectQueueTraces (wmq);
< 
<               rmac->GetAttributeFailSafe ("VO_Txop", ptr);
<               ackSelector = m_ackPolicySelector[AC_VO].Create<WifiAckPolicySelector> ();
<               ackSelector->SetQosTxop (ptr.Get<QosTxop> ());
<               ptr.Get<QosTxop> ()->SetAckPolicySelector (ackSelector);
<               wmq = ptr.Get<QosTxop> ()->GetWifiMacQueue ();
<               ndqi->GetTxQueue (3)->ConnectQueueTraces (wmq);
<               ndqi->SetSelectQueueCallback (m_selectQueueCallback);
<             }
<           else
<             {
<               ndqi = CreateObject<NetDeviceQueueInterface> ();
< 
<               rmac->GetAttributeFailSafe ("Txop", ptr);
<               wmq = ptr.Get<Txop> ()->GetWifiMacQueue ();
<               ndqi->GetTxQueue (0)->ConnectQueueTraces (wmq);
<             }
<           device->AggregateObject (ndqi);
<         }
1009,1011d679
<   LogComponentEnableAll (LOG_PREFIX_TIME);
<   LogComponentEnableAll (LOG_PREFIX_NODE);
< 
1023d690
<   LogComponentEnable ("ConstantObssPdAlgorithm", LOG_LEVEL_ALL);
1040d706
<   LogComponentEnable ("ObssPdAlgorithm", LOG_LEVEL_ALL);
1046d711
<   LogComponentEnable ("SimpleFrameCaptureModel", LOG_LEVEL_ALL);
1050d714
<   LogComponentEnable ("ThresholdPreambleDetectionModel", LOG_LEVEL_ALL);
1056,1057d719
<   LogComponentEnable ("WifiPpdu", LOG_LEVEL_ALL);
<   LogComponentEnable ("WifiPsdu", LOG_LEVEL_ALL);
diff ../../NS3-WiGig/src/wifi/helper/wifi-helper.h ../../ns-3-dev-git/src/wifi/helper/wifi-helper.h
28d27
< #include "ns3/qos-utils.h"
30d28
< #include <functional>
37,45d34
< class QueueItem;
< 
< /**
<  * An enumeration of the ASCII trace types.
<  */
< enum SupportedAsciiTraceTypes {
<   ASCII_TRACE_LEGACY = 0,
<   ASCII_TRACE_PHY_ACTIVITY = 1,
< };
112,176d100
<   /**
<    * \param name the name of the frame capture model to set.
<    * \param n0 the name of the attribute to set
<    * \param v0 the value of the attribute to set
<    * \param n1 the name of the attribute to set
<    * \param v1 the value of the attribute to set
<    * \param n2 the name of the attribute to set
<    * \param v2 the value of the attribute to set
<    * \param n3 the name of the attribute to set
<    * \param v3 the value of the attribute to set
<    * \param n4 the name of the attribute to set
<    * \param v4 the value of the attribute to set
<    * \param n5 the name of the attribute to set
<    * \param v5 the value of the attribute to set
<    * \param n6 the name of the attribute to set
<    * \param v6 the value of the attribute to set
<    * \param n7 the name of the attribute to set
<    * \param v7 the value of the attribute to set
<    *
<    * Set the frame capture model and its attributes to use when Install is called.
<    */
<   void SetFrameCaptureModel (std::string name,
<                              std::string n0 = "", const AttributeValue &v0 = EmptyAttributeValue (),
<                              std::string n1 = "", const AttributeValue &v1 = EmptyAttributeValue (),
<                              std::string n2 = "", const AttributeValue &v2 = EmptyAttributeValue (),
<                              std::string n3 = "", const AttributeValue &v3 = EmptyAttributeValue (),
<                              std::string n4 = "", const AttributeValue &v4 = EmptyAttributeValue (),
<                              std::string n5 = "", const AttributeValue &v5 = EmptyAttributeValue (),
<                              std::string n6 = "", const AttributeValue &v6 = EmptyAttributeValue (),
<                              std::string n7 = "", const AttributeValue &v7 = EmptyAttributeValue ());
<   /**
<    * \param name the name of the preamble detection model to set.
<    * \param n0 the name of the attribute to set
<    * \param v0 the value of the attribute to set
<    * \param n1 the name of the attribute to set
<    * \param v1 the value of the attribute to set
<    * \param n2 the name of the attribute to set
<    * \param v2 the value of the attribute to set
<    * \param n3 the name of the attribute to set
<    * \param v3 the value of the attribute to set
<    * \param n4 the name of the attribute to set
<    * \param v4 the value of the attribute to set
<    * \param n5 the name of the attribute to set
<    * \param v5 the value of the attribute to set
<    * \param n6 the name of the attribute to set
<    * \param v6 the value of the attribute to set
<    * \param n7 the name of the attribute to set
<    * \param v7 the value of the attribute to set
<    *
<    * Set the preamble detection model and its attributes to use when Install is called.
<    */
<   void SetPreambleDetectionModel (std::string name,
<                                   std::string n0 = "", const AttributeValue &v0 = EmptyAttributeValue (),
<                                   std::string n1 = "", const AttributeValue &v1 = EmptyAttributeValue (),
<                                   std::string n2 = "", const AttributeValue &v2 = EmptyAttributeValue (),
<                                   std::string n3 = "", const AttributeValue &v3 = EmptyAttributeValue (),
<                                   std::string n4 = "", const AttributeValue &v4 = EmptyAttributeValue (),
<                                   std::string n5 = "", const AttributeValue &v5 = EmptyAttributeValue (),
<                                   std::string n6 = "", const AttributeValue &v6 = EmptyAttributeValue (),
<                                   std::string n7 = "", const AttributeValue &v7 = EmptyAttributeValue ());
< 
<   /**
<    * Disable the preamble detection model.
<    */
<   void DisablePreambleDetectionModel ();
202,217d125
<    * Set the type of the ascii trace to be printed. This function has to be
<    * called before EnableAscii(), so that the type of the ascii trace file
<    * can be written correctly.
<    *
<    * \param traceType The type of the ascrii trace to be printed.
<    */
<   void SetAsciiTraceType (SupportedAsciiTraceTypes traceType);
< 
<   /**
<    * Set the maximum length of packet data stored in the PCAP file.
<    *
<    * \param length The length of the snapshot in bytes.
<    */
<   void SetSnapshotLength (uint32_t length);
< 
<   /**
225,243d132
<   /**
<    * Get the maximum length of packet data stored in the PCAP file.
<    *
<    * \return length The length of the snapshot in bytes.
<    */
<   uint32_t GetSnapshotLength (void) const;
<   /**
<    * Enable pcap output for the indicated net device.
<    *
<    * NetDevice-specific implementation mechanism for hooking the trace and
<    * writing to the trace file.
<    *
<    * \param prefix Filename prefix to use for pcap files.
<    * \param nd Net device for which you want to enable tracing.
<    * \param promiscuous If true capture all possible packets available at the device.
<    */
<   void EnableMultiBandPcap (std::string prefix,
<                             Ptr<NetDevice> nd,
<                             Ptr<WifiPhy> phy);
254c143
<    * Handle TX pcap.
---
>    * Handle tx pcap.
267c156
<    * \param signalNoise the RX signal and noise information
---
>    * \param signalNoise the rx signal and noise information
269c158
<    * Handle RX pcap.
---
>    * Handle rx pcap.
280,284d168
<   PcapHelper::DataLinkType m_pcapDlt; ///< PCAP data link type
<   SupportedAsciiTraceTypes m_asciiTraceType;  ///< ASCII Trace type.
<   uint32_t m_snaplen; ///< Snapshot length in bytes.
<   ObjectFactory m_frameCaptureModel; ///< frame capture model
<   ObjectFactory m_preambleDetectionModel; ///< preamble detection model
289c173
<    * Get the Radiotap header.
---
>    * Get the radiotap header.
296c180
<    * \returns the Radiotap header
---
>    * \returns the radiotap header
320c204
<    * \brief Enable ASCII trace output on the indicated net device.
---
>    * \brief Enable ascii trace output on the indicated net device.
325,326c209,210
<    * \param stream The output stream object to use when logging ASCII traces.
<    * \param prefix Filename prefix to use for ASCII trace files.
---
>    * \param stream The output stream object to use when logging ascii traces.
>    * \param prefix Filename prefix to use for ascii trace files.
334a219
>   PcapHelper::DataLinkType m_pcapDlt; ///< PCAP data link type
391,466d275
< 
<   /**
<    * \param type the type of ns3::ObssPdAlgorithm to create.
<    * \param n0 the name of the attribute to set
<    * \param v0 the value of the attribute to set
<    * \param n1 the name of the attribute to set
<    * \param v1 the value of the attribute to set
<    * \param n2 the name of the attribute to set
<    * \param v2 the value of the attribute to set
<    * \param n3 the name of the attribute to set
<    * \param v3 the value of the attribute to set
<    * \param n4 the name of the attribute to set
<    * \param v4 the value of the attribute to set
<    * \param n5 the name of the attribute to set
<    * \param v5 the value of the attribute to set
<    * \param n6 the name of the attribute to set
<    * \param v6 the value of the attribute to set
<    * \param n7 the name of the attribute to set
<    * \param v7 the value of the attribute to set
<    *
<    * All the attributes specified in this method should exist
<    * in the requested algorithm.
<    */
<   void SetObssPdAlgorithm (std::string type,
<                            std::string n0 = "", const AttributeValue &v0 = EmptyAttributeValue (),
<                            std::string n1 = "", const AttributeValue &v1 = EmptyAttributeValue (),
<                            std::string n2 = "", const AttributeValue &v2 = EmptyAttributeValue (),
<                            std::string n3 = "", const AttributeValue &v3 = EmptyAttributeValue (),
<                            std::string n4 = "", const AttributeValue &v4 = EmptyAttributeValue (),
<                            std::string n5 = "", const AttributeValue &v5 = EmptyAttributeValue (),
<                            std::string n6 = "", const AttributeValue &v6 = EmptyAttributeValue (),
<                            std::string n7 = "", const AttributeValue &v7 = EmptyAttributeValue ());
< 
<   /**
<    * \param ac the Access Category to attach the ack policy selector to.
<    * \param type the type of ns3::WifiAckPolicySelector to create.
<    * \param n0 the name of the attribute to set
<    * \param v0 the value of the attribute to set
<    * \param n1 the name of the attribute to set
<    * \param v1 the value of the attribute to set
<    * \param n2 the name of the attribute to set
<    * \param v2 the value of the attribute to set
<    * \param n3 the name of the attribute to set
<    * \param v3 the value of the attribute to set
<    * \param n4 the name of the attribute to set
<    * \param v4 the value of the attribute to set
<    * \param n5 the name of the attribute to set
<    * \param v5 the value of the attribute to set
<    * \param n6 the name of the attribute to set
<    * \param v6 the value of the attribute to set
<    * \param n7 the name of the attribute to set
<    * \param v7 the value of the attribute to set
<    *
<    * All the attributes specified in this method should exist
<    * in the requested ack policy selector.
<    */
<   void SetAckPolicySelectorForAc (AcIndex ac, std::string type,
<                                   std::string n0 = "", const AttributeValue &v0 = EmptyAttributeValue (),
<                                   std::string n1 = "", const AttributeValue &v1 = EmptyAttributeValue (),
<                                   std::string n2 = "", const AttributeValue &v2 = EmptyAttributeValue (),
<                                   std::string n3 = "", const AttributeValue &v3 = EmptyAttributeValue (),
<                                   std::string n4 = "", const AttributeValue &v4 = EmptyAttributeValue (),
<                                   std::string n5 = "", const AttributeValue &v5 = EmptyAttributeValue (),
<                                   std::string n6 = "", const AttributeValue &v6 = EmptyAttributeValue (),
<                                   std::string n7 = "", const AttributeValue &v7 = EmptyAttributeValue ());
< 
<   /// Callback invoked to determine the MAC queue selected for a given packet
<   typedef std::function<std::size_t (Ptr<QueueItem>)> SelectQueueCallback;
< 
<   /**
<    * \param f the select queue callback
<    *
<    * Set the select queue callback to set on the NetDevice queue interface aggregated
<    * to the WifiNetDevice, in case RegularWifiMac with QoS enabled is used
<    */
<   void SetSelectQueueCallback (SelectQueueCallback f);
504c313
<    * \param standard the PHY standard to configure during installation
---
>    * \param standard the phy standard to configure during installation
507c316
<    * parameters such as SIFS time, slot time, timeout values, etc.,
---
>    * parameters such as sifs time, slot time, timeout values, etc.,
510c319
<    * installed MAC object.
---
>    * installed mac object.
536c345
<   * used by the PHY and MAC aspects of the Wifi models.  Each device in
---
>   * used by the Phy and Mac aspects of the Wifi models.  Each device in
552,556c361,362
<   ObjectFactory m_stationManager;            ///< station manager
<   ObjectFactory m_ackPolicySelector[4];      ///< ack policy selector for all ACs
<   WifiPhyStandard m_standard;                ///< wifi standard
<   SelectQueueCallback m_selectQueueCallback; ///< select queue callback
<   ObjectFactory m_obssPdAlgorithm;           ///< OBSS_PD algorithm
---
>   ObjectFactory m_stationManager; ///< station manager
>   WifiPhyStandard m_standard; ///< wifi standard
diff ../../NS3-WiGig/src/wifi/helper/wifi-mac-helper.cc ../../ns-3-dev-git/src/wifi/helper/wifi-mac-helper.cc
21d20
< #include "ns3/net-device.h"
67,92d65
< void
< WifiMacHelper::SetAttrbiute (std::string n0, const AttributeValue &v0,
<                              std::string n1, const AttributeValue &v1,
<                              std::string n2, const AttributeValue &v2,
<                              std::string n3, const AttributeValue &v3,
<                              std::string n4, const AttributeValue &v4,
<                              std::string n5, const AttributeValue &v5,
<                              std::string n6, const AttributeValue &v6,
<                              std::string n7, const AttributeValue &v7,
<                              std::string n8, const AttributeValue &v8,
<                              std::string n9, const AttributeValue &v9,
<                              std::string n10, const AttributeValue &v10)
< {
<   m_mac.Set (n0, v0);
<   m_mac.Set (n1, v1);
<   m_mac.Set (n2, v2);
<   m_mac.Set (n3, v3);
<   m_mac.Set (n4, v4);
<   m_mac.Set (n5, v5);
<   m_mac.Set (n6, v6);
<   m_mac.Set (n7, v7);
<   m_mac.Set (n8, v8);
<   m_mac.Set (n9, v9);
<   m_mac.Set (n10, v10);
< }
< 
94c67
< WifiMacHelper::Create (Ptr<NetDevice> device) const
---
> WifiMacHelper::Create (void) const
97d69
<   mac->SetDevice (device);
diff ../../NS3-WiGig/src/wifi/helper/wifi-mac-helper.h ../../ns-3-dev-git/src/wifi/helper/wifi-mac-helper.h
29d28
< class NetDevice;
87c86
<    * in the requested MAC.
---
>    * in the requested mac.
103,142d101
<    * \param n0 the name of the attribute to set
<    * \param v0 the value of the attribute to set
<    * \param n1 the name of the attribute to set
<    * \param v1 the value of the attribute to set
<    * \param n2 the name of the attribute to set
<    * \param v2 the value of the attribute to set
<    * \param n3 the name of the attribute to set
<    * \param v3 the value of the attribute to set
<    * \param n4 the name of the attribute to set
<    * \param v4 the value of the attribute to set
<    * \param n5 the name of the attribute to set
<    * \param v5 the value of the attribute to set
<    * \param n6 the name of the attribute to set
<    * \param v6 the value of the attribute to set
<    * \param n7 the name of the attribute to set
<    * \param v7 the value of the attribute to set
<    * \param n8 the name of the attribute to set
<    * \param v8 the value of the attribute to set
<    * \param n9 the name of the attribute to set
<    * \param v9 the value of the attribute to set
<    * \param n10 the name of the attribute to set
<    * \param v10 the value of the attribute to set
<    *
<    * All the attributes specified in this method should exist
<    * in the requested mac.
<    */
<   virtual void SetAttrbiute (std::string n0 = "", const AttributeValue &v0 = EmptyAttributeValue (),
<                              std::string n1 = "", const AttributeValue &v1 = EmptyAttributeValue (),
<                              std::string n2 = "", const AttributeValue &v2 = EmptyAttributeValue (),
<                              std::string n3 = "", const AttributeValue &v3 = EmptyAttributeValue (),
<                              std::string n4 = "", const AttributeValue &v4 = EmptyAttributeValue (),
<                              std::string n5 = "", const AttributeValue &v5 = EmptyAttributeValue (),
<                              std::string n6 = "", const AttributeValue &v6 = EmptyAttributeValue (),
<                              std::string n7 = "", const AttributeValue &v7 = EmptyAttributeValue (),
<                              std::string n8 = "", const AttributeValue &v8 = EmptyAttributeValue (),
<                              std::string n9 = "", const AttributeValue &v9 = EmptyAttributeValue (),
<                              std::string n10 = "", const AttributeValue &v10 = EmptyAttributeValue ());
< 
<   /**
<    * \param device the device within which the MAC object will reside
147c106
<   virtual Ptr<WifiMac> Create (Ptr<NetDevice> device) const;
---
>   virtual Ptr<WifiMac> Create (void) const;
diff ../../NS3-WiGig/src/wifi/helper/wifi-radio-energy-model-helper.cc ../../ns-3-dev-git/src/wifi/helper/wifi-radio-energy-model-helper.cc
131c131
<   // create and register energy model PHY listener
---
>   // create and register energy model phy listener
diff ../../NS3-WiGig/src/wifi/helper/wifi-radio-energy-model-helper.h ../../ns-3-dev-git/src/wifi/helper/wifi-radio-energy-model-helper.h
62c62,63
<   void SetDepletionCallback (WifiRadioEnergyModel::WifiRadioEnergyDepletionCallback callback);
---
>   void SetDepletionCallback (
>     WifiRadioEnergyModel::WifiRadioEnergyDepletionCallback callback);
69c70,71
<   void SetRechargedCallback (WifiRadioEnergyModel::WifiRadioEnergyRechargedCallback callback);
---
>   void SetRechargedCallback (
>     WifiRadioEnergyModel::WifiRadioEnergyRechargedCallback callback);
diff ../../NS3-WiGig/src/wifi/helper/yans-wifi-helper.cc ../../ns-3-dev-git/src/wifi/helper/yans-wifi-helper.cc
27,28d26
< #include "ns3/frame-capture-model.h"
< #include "ns3/preamble-detection-model.h"
159,168d156
<   if (m_frameCaptureModel.IsTypeIdSet ())
<     {
<       Ptr<FrameCaptureModel> capture = m_frameCaptureModel.Create<FrameCaptureModel> ();
<       phy->SetFrameCaptureModel (capture);
<     }
<   if (m_preambleDetectionModel.IsTypeIdSet ())
<     {
<       Ptr<PreambleDetectionModel> capture = m_preambleDetectionModel.Create<PreambleDetectionModel> ();
<       phy->SetPreambleDetectionModel (capture);
<     }
diff ../../NS3-WiGig/src/wifi/helper/yans-wifi-helper.h ../../ns-3-dev-git/src/wifi/helper/yans-wifi-helper.h
30c30
<  * \brief manage and create wifi channel objects for the YANS model.
---
>  * \brief manage and create wifi channel objects for the yans model.
33c33
<  * which implements the YANS channel model. The YANS channel model is described
---
>  * which implements the yans channel model. The yans channel model is described
75c75
<    * such as a log distance + Jakes model, etc.
---
>    * such as a log distance + jakes model, etc.
78c78
<    * propagation models are dependent of the "txPower" (e.g. Nakagami model), and
---
>    * propagation models are dependent of the "txPower" (eg. Nakagami model), and
151c151
<  * \brief Make it easy to create and manage PHY objects for the YANS model.
---
>  * \brief Make it easy to create and manage PHY objects for the yans model.
153c153
<  * The YANS PHY model is described in "Yet Another Network Simulator",
---
>  * The yans PHY model is described in "Yet Another Network Simulator",
156c156
<  * The Pcap and ASCII traces generated by the EnableAscii and EnablePcap methods defined
---
>  * The Pcap and ascii traces generated by the EnableAscii and EnablePcap methods defined
164c164
<    * Create a PHY helper without any parameter set. The user must set
---
>    * Create a phy helper without any parameter set. The user must set
170c170
<    * Create a PHY helper in a default working state.
---
>    * Create a phy helper in a default working state.
198c198
<   Ptr<YansWifiChannel> m_channel; ///< YANS wifi channel
---
>   Ptr<YansWifiChannel> m_channel; ///< yans wifi channel
